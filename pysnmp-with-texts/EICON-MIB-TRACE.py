#
# PySNMP MIB module EICON-MIB-TRACE (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EICON-MIB-TRACE
# Produced by pysmi-0.3.4 at Wed May  1 12:59:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, iso, Counter32, MibIdentifier, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, NotificationType, enterprises, Integer32, Gauge32, ObjectIdentity, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "Counter32", "MibIdentifier", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "NotificationType", "enterprises", "Integer32", "Gauge32", "ObjectIdentity", "IpAddress", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
eicon = MibIdentifier((1, 3, 6, 1, 4, 1, 434))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2))
mibv2 = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2))
module = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4))
class ActionState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("done", 1), ("failed", 2), ("in-progress", 3))

class ControlOnOff(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("stop", 1), ("start", 2), ("invalid", 3))

class CardRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 6)

class PortRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 48)

class PositiveInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

trace = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15))
traceFreeEntryIndex = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 1), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceFreeEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: traceFreeEntryIndex.setDescription('The number indicating to the Manager the first available index for the new Entry in the traceTable. The Manager will first get this value from the Agent and then use it to attempt to create an entry with that index value.')
traceControlTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2), )
if mibBuilder.loadTexts: traceControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: traceControlTable.setDescription('Trace control paramters table, one row per port. All parameters in this table have read-write access and have to be set before the trace can be started.')
traceControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1), ).setIndexNames((0, "EICON-MIB-TRACE", "traceCntrlIndex"))
if mibBuilder.loadTexts: traceControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: traceControlEntry.setDescription('The set of attributes for each port.')
traceCntrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 1), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceCntrlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlIndex.setDescription('Index of the table')
traceCntrlEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("create", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlEntryStatus.setDescription('Status of this entry in the table')
traceCntrlEntryOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlEntryOwner.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlEntryOwner.setDescription('Owner of entry')
traceCntrlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("x25", 1), ("sdlc", 2), ("frelay", 3), ("hdlc", 4), ("xportiso", 5), ("xporttgx", 6), ("llc", 7), ("sna", 8), ("ppp", 9), ("snafr", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlProtocol.setDescription('The Protocol to trace')
traceCntrlEntryReclaimTime = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlEntryReclaimTime.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlEntryReclaimTime.setDescription('This is the amount of time the the entry is valid. a value of 0 means valid forever. default is 1 day ticks')
traceCntrlOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("start", 1), ("read", 2), ("stop", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlOnOff.setDescription('The start/stop parameter')
traceCntrlActionState = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 7), ActionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceCntrlActionState.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlActionState.setDescription("Result of the Trace start operation. Management Station should read this value after starting the trace to find it's status.")
traceCntrlActionError = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-error", 1), ("bad-param", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceCntrlActionError.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlActionError.setDescription('The error codes if traceStartResult has start-failed')
traceCntrlFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlFileName.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlFileName.setDescription('The trace file name (full). Has to be provided by the Operator. The Agent will create the file traceFileName.')
traceCntrlCardRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 10), CardRef()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlCardRef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlCardRef.setDescription('The EiconCard Reference if the traced protocol requires a card reference.')
traceCntrlPortRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 11), PortRef()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlPortRef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlPortRef.setDescription('The pointer to the port, the same as hdlcParmPortRef from the hdlcParmTable.')
traceCntrlConnectionRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlConnectionRef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlConnectionRef.setDescription('Connection Id reference, for Transport and Frame Relay.')
traceCntrlPURef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlPURef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlPURef.setDescription('PU name for SNA PC.')
traceCntrlModeRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlModeRef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlModeRef.setDescription('Mode reference name for SNA APPC.')
traceCntrlLURef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlLURef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlLURef.setDescription('LU reference for SNA PC')
traceCntrlStationRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlStationRef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlStationRef.setDescription('Station reference for SDLC')
traceCntrlLLURef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlLLURef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlLLURef.setDescription('LLU reference.')
traceCntrlRLURef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlRLURef.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlRLURef.setDescription('RLU reference.')
traceCntrlOption = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("append", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlOption.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlOption.setDescription('The option to reset the trace buffer')
traceCntrlPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlPeriod.setDescription('The time period for the trace, in seconds')
traceCntrlMask = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlMask.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlMask.setDescription('The filter for the EiconCard trace function. The value has to be OR-ed using the following components, specific for each protocol. hdlc,sdlc: nothing (0), framesI (1), framesRR (2), framesRNR&REJ (4), framesFRMR&SAMB&DISC&UA(8), for hdlc only, framesFRMR&SNRM&DISC&UA&DM(8), for sdlc only, framesOther (16), for hdlc only: all frames other than indicated by values 1,2,4 ,8, framesXID&Other (16) for sdlc only: all frames other than indicated by values 1,2,4 ,8 x.25: nothing (0), packets-data (1), packets-RR&RNR (2), packets-Reset&Interrupt (4), packets-Call&Clear (8), other (16), all packets other than indicated by values 1,2,4 ,8, appc, SNA-FM, SNA-PC: nothing (0), frames-LU-LU-FMD (1), frames-LU-LU-DFC (2), frames-LU-LU-SC (4), frames-SSCP-LU-FMD (8), frames-SSCP-LU-SC (16), frames-SSCP-PU-FMD (32), frames-SSCP-PU-SC (64). ')
traceCntrlBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlBufSize.setDescription('The size of the trace buffer on the EiconCard')
traceCntrlEntrySize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlEntrySize.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlEntrySize.setDescription('The buffer entry truncation length.')
traceCntrlBufFullAction = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wrap", 1), ("stop", 2), ("stopAndAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlBufFullAction.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlBufFullAction.setDescription('The buffer-full action of the EiconCard, wrap or stop and alarm. Only wrap is implemented in this first version.')
traceCntrlReadFromEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlReadFromEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlReadFromEntryIndex.setDescription('This parameter is used to indicate to the EiconCard trace function the position in the buffer when reading the trace buffer. Used with the GET for traceTable.')
traceCntrlFileType = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 15, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascii", 1), ("ebcdic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceCntrlFileType.setStatus('mandatory')
if mibBuilder.loadTexts: traceCntrlFileType.setDescription(' ')
mibBuilder.exportSymbols("EICON-MIB-TRACE", traceCntrlStationRef=traceCntrlStationRef, traceCntrlOnOff=traceCntrlOnOff, mibv2=mibv2, ActionState=ActionState, traceCntrlActionError=traceCntrlActionError, traceCntrlMask=traceCntrlMask, PortRef=PortRef, CardRef=CardRef, traceCntrlProtocol=traceCntrlProtocol, trace=trace, traceCntrlBufFullAction=traceCntrlBufFullAction, module=module, traceCntrlCardRef=traceCntrlCardRef, traceCntrlPeriod=traceCntrlPeriod, traceCntrlFileType=traceCntrlFileType, traceCntrlLLURef=traceCntrlLLURef, traceCntrlEntrySize=traceCntrlEntrySize, traceCntrlBufSize=traceCntrlBufSize, ControlOnOff=ControlOnOff, traceCntrlPURef=traceCntrlPURef, traceCntrlEntryOwner=traceCntrlEntryOwner, management=management, traceCntrlIndex=traceCntrlIndex, traceCntrlActionState=traceCntrlActionState, traceCntrlLURef=traceCntrlLURef, traceCntrlPortRef=traceCntrlPortRef, traceCntrlModeRef=traceCntrlModeRef, traceCntrlEntryReclaimTime=traceCntrlEntryReclaimTime, eicon=eicon, traceCntrlReadFromEntryIndex=traceCntrlReadFromEntryIndex, traceCntrlRLURef=traceCntrlRLURef, traceCntrlEntryStatus=traceCntrlEntryStatus, traceCntrlConnectionRef=traceCntrlConnectionRef, traceControlTable=traceControlTable, traceCntrlOption=traceCntrlOption, PositiveInteger=PositiveInteger, traceFreeEntryIndex=traceFreeEntryIndex, traceCntrlFileName=traceCntrlFileName, traceControlEntry=traceControlEntry)

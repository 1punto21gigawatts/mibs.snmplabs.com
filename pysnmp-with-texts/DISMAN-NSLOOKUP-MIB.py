#
# PySNMP MIB module DISMAN-NSLOOKUP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DISMAN-NSLOOKUP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:47:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter32, Gauge32, mib_2, MibIdentifier, Integer32, Unsigned32, ObjectIdentity, iso, IpAddress, TimeTicks, NotificationType, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter32", "Gauge32", "mib-2", "MibIdentifier", "Integer32", "Unsigned32", "ObjectIdentity", "iso", "IpAddress", "TimeTicks", "NotificationType", "Counter64")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
lookupMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 82))
lookupMIB.setRevisions(('2006-06-13 00:00', '2000-09-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: lookupMIB.setRevisionsDescriptions(('Updated version, published as RFC 4560. - Replaced references to RFC 2575 by RFC 3415 - Replaced references to RFC 2571 by RFC 3411 - Replaced references to RFC 2851 by RFC 4001 - Added value enabled(1) to SYNTAX clause of lookupCtlOperStatus - Added lookupMinimumCompliance - Defined semantics of value 0 for object lookupPurgeTime - Added DEFVAL { unknown } to object lookupCtlTargetAddressType OBJECT-TYPE', 'Initial version, published as RFC 2925.',))
if mibBuilder.loadTexts: lookupMIB.setLastUpdated('200606130000Z')
if mibBuilder.loadTexts: lookupMIB.setOrganization('IETF Distributed Management Working Group')
if mibBuilder.loadTexts: lookupMIB.setContactInfo('Juergen Quittek NEC Europe Ltd. Network Laboratories Kurfuersten-Anlage 36 69115 Heidelberg Germany Phone: +49 6221 4342-115 Email: quittek@netlab.nec.de')
if mibBuilder.loadTexts: lookupMIB.setDescription('The Lookup MIB (DISMAN-NSLOOKUP-MIB) enables determination of either the name(s) corresponding to a host address or of the address(es) associated with a host name at a remote host. Copyright (C) The Internet Society (2006). This version of this MIB module is part of RFC 4560; see the RFC itself for full legal notices.')
lookupObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 82, 1))
lookupConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 82, 2))
lookupMaxConcurrentRequests = MibScalar((1, 3, 6, 1, 2, 1, 82, 1, 1), Unsigned32().clone(10)).setUnits('requests').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lookupMaxConcurrentRequests.setStatus('current')
if mibBuilder.loadTexts: lookupMaxConcurrentRequests.setDescription('The maximum number of concurrent active lookup requests that are allowed within an agent implementation. A value of 0 for this object implies that there is no limit for the number of concurrent active requests in effect. The limit applies only to new requests being activated. When a new value is set, the agent will continue processing all the requests already active, even if their number exceed the limit just imposed.')
lookupPurgeTime = MibScalar((1, 3, 6, 1, 2, 1, 82, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(900)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lookupPurgeTime.setStatus('current')
if mibBuilder.loadTexts: lookupPurgeTime.setDescription('The amount of time to wait before automatically deleting an entry in the lookupCtlTable and any dependent lookupResultsTable entries after the lookup operation represented by a lookupCtlEntry has been completed. A lookupCtEntry is considered complete when its lookupCtlOperStatus object has a value of completed(3). A value of 0 indicates that automatic deletion of entries is disabled.')
lookupCtlTable = MibTable((1, 3, 6, 1, 2, 1, 82, 1, 3), )
if mibBuilder.loadTexts: lookupCtlTable.setStatus('current')
if mibBuilder.loadTexts: lookupCtlTable.setDescription('Defines the Lookup Control Table for providing the capability of performing a lookup operation for a symbolic host name or for a host address from a remote host.')
lookupCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 82, 1, 3, 1), ).setIndexNames((0, "DISMAN-NSLOOKUP-MIB", "lookupCtlOwnerIndex"), (0, "DISMAN-NSLOOKUP-MIB", "lookupCtlOperationName"))
if mibBuilder.loadTexts: lookupCtlEntry.setStatus('current')
if mibBuilder.loadTexts: lookupCtlEntry.setDescription('Defines an entry in the lookupCtlTable. A lookupCtlEntry is initially indexed by lookupCtlOwnerIndex, which is a type of SnmpAdminString, a textual convention that allows for the use of the SNMPv3 View-Based Access Control Model (RFC 3415, VACM) and that also allows a management application to identify its entries. The second index element, lookupCtlOperationName, enables the same lookupCtlOwnerIndex entity to have multiple outstanding requests. The value of lookupCtlTargetAddressType determines which lookup function to perform.')
lookupCtlOwnerIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: lookupCtlOwnerIndex.setStatus('current')
if mibBuilder.loadTexts: lookupCtlOwnerIndex.setDescription("To facilitate the provisioning of access control by a security administrator using the View-Based Access Control Model (RFC 2575, VACM) for tables in which multiple users may need to create or modify entries independently, the initial index is used as an 'owner index'. Such an initial index has a syntax of SnmpAdminString and can thus be trivially mapped to a securityName or groupName defined in VACM, in accordance with a security policy. When used in conjunction with such a security policy all entries in the table belonging to a particular user (or group) will have the same value for this initial index. For a given user's entries in a particular table, the object identifiers for the information in these entries will have the same subidentifiers (except for the 'column' subidentifier) up to the end of the encoded owner index. To configure VACM to permit access to this portion of the table, one would create vacmViewTreeFamilyTable entries with the value of vacmViewTreeFamilySubtree including the owner index portion, and vacmViewTreeFamilyMask 'wildcarding' the column subidentifier. More elaborate configurations are possible.")
lookupCtlOperationName = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: lookupCtlOperationName.setStatus('current')
if mibBuilder.loadTexts: lookupCtlOperationName.setDescription('The name of a lookup operation. This is locally unique, within the scope of an lookupCtlOwnerIndex.')
lookupCtlTargetAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 3), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lookupCtlTargetAddressType.setStatus('current')
if mibBuilder.loadTexts: lookupCtlTargetAddressType.setDescription('Specifies the type of address for performing a lookup operation for a symbolic host name or for a host address from a remote host. Specification of dns(16) as the value for this object means that a function such as, for example, getaddrinfo() or gethostbyname() should be performed to return one or more numeric addresses. Use of a value of either ipv4(1) or ipv6(2) means that a functions such as, for example, getnameinfo() or gethostbyaddr() should be used to return the symbolic names associated with a host.')
lookupCtlTargetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lookupCtlTargetAddress.setStatus('current')
if mibBuilder.loadTexts: lookupCtlTargetAddress.setDescription('Specifies the address used for a resolver lookup at a remote host. The corresponding lookupCtlTargetAddressType objects determines its type, as well as the function that can be requested. A value for this object MUST be set prior to transitioning its corresponding lookupCtlEntry to active(1) via lookupCtlRowStatus.')
lookupCtlOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("notStarted", 2), ("completed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lookupCtlOperStatus.setStatus('current')
if mibBuilder.loadTexts: lookupCtlOperStatus.setDescription('Reflects the operational state of an lookupCtlEntry: enabled(1) - Operation is active. notStarted(2) - Operation has not been enabled. completed(3) - Operation has been completed. An operation is automatically enabled(1) when its lookupCtlRowStatus object is transitioned to active(1) status. Until this occurs, lookupCtlOperStatus MUST report a value of notStarted(2). After the lookup operation is completed (success or failure), the value for lookupCtlOperStatus MUST be transitioned to completed(3).')
lookupCtlTime = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 6), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lookupCtlTime.setStatus('current')
if mibBuilder.loadTexts: lookupCtlTime.setDescription('Reports the number of milliseconds that a lookup operation required to be completed at a remote host. Completed means operation failure as well as success.')
lookupCtlRc = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lookupCtlRc.setStatus('current')
if mibBuilder.loadTexts: lookupCtlRc.setDescription('The system-specific return code from a lookup operation. All implementations MUST return a value of 0 for this object when the remote lookup operation succeeds. A non-zero value for this objects indicates failure. It is recommended that implementations return the error codes that are generated by the lookup function used.')
lookupCtlRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lookupCtlRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: lookupCtlRowStatus.setStatus('current')
if mibBuilder.loadTexts: lookupCtlRowStatus.setDescription('This object allows entries to be created and deleted in the lookupCtlTable. A remote lookup operation is started when an entry in this table is created via an SNMP set request and the entry is activated. This occurs by setting the value of this object to CreateAndGo(4) during row creation or by setting this object to active(1) after the row is created. A value MUST be specified for lookupCtlTargetAddress prior to the acceptance of a transition to active(1) state. A remote lookup operation starts when its entry first becomes active(1). Transitions in and out of active(1) state have no effect on the operational behavior of a remote lookup operation, with the exception that deletion of an entry in this table by setting its RowStatus object to destroy(6) will stop an active remote lookup operation. The operational state of a remote lookup operation can be determined by examination of its lookupCtlOperStatus object.')
lookupResultsTable = MibTable((1, 3, 6, 1, 2, 1, 82, 1, 4), )
if mibBuilder.loadTexts: lookupResultsTable.setStatus('current')
if mibBuilder.loadTexts: lookupResultsTable.setDescription("Defines the Lookup Results Table for providing the capability of determining the results of a operation at a remote host. One or more entries are added to the lookupResultsTable when a lookup operation, as reflected by an lookupCtlEntry, is completed successfully. All entries related to a successful lookup operation MUST be added to the lookupResultsTable at the same time that the associating lookupCtlOperStatus object is transitioned to completed(2). The number of entries added depends on the results determined for a particular lookup operation. All entries associated with an lookupCtlEntry are removed when the lookupCtlEntry is deleted. A remote host can be multi-homed and have more than one IP address associated with it (returned by lookup function), or it can have more than one symbolic name (returned by lookup function). A function such as, for example, getnameinfo() or gethostbyaddr() is called with a host address as its parameter and is used primarily to determine a symbolic name to associate with the host address. Entries in the lookupResultsTable MUST be made for each host name returned. If the function identifies an 'official host name,' then this symbolic name MUST be assigned a lookupResultsIndex of 1. A function such as, for example, getaddrinfo() or gethostbyname() is called with a symbolic host name and is used primarily to retrieve a host address. The entries MUST be stored in the order that they are retrieved from the lookup function. lookupResultsIndex 1 MUST be assigned to the first entry.")
lookupResultsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 82, 1, 4, 1), ).setIndexNames((0, "DISMAN-NSLOOKUP-MIB", "lookupCtlOwnerIndex"), (0, "DISMAN-NSLOOKUP-MIB", "lookupCtlOperationName"), (0, "DISMAN-NSLOOKUP-MIB", "lookupResultsIndex"))
if mibBuilder.loadTexts: lookupResultsEntry.setStatus('current')
if mibBuilder.loadTexts: lookupResultsEntry.setDescription('Defines an entry in the lookupResultsTable. The first two index elements identify the lookupCtlEntry that a lookupResultsEntry belongs to. The third index element selects a single lookup operation result.')
lookupResultsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: lookupResultsIndex.setStatus('current')
if mibBuilder.loadTexts: lookupResultsIndex.setDescription('Entries in the lookupResultsTable are created when the result of a lookup operation is determined. Entries MUST be stored in the lookupResultsTable in the order that they are retrieved. Values assigned to lookupResultsIndex MUST start at 1 and increase consecutively.')
lookupResultsAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 4, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lookupResultsAddressType.setStatus('current')
if mibBuilder.loadTexts: lookupResultsAddressType.setDescription("Indicates the type of result of a remote lookup operation. A value of unknown(0) implies either that the operation hasn't been started or that it has failed.")
lookupResultsAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 82, 1, 4, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lookupResultsAddress.setStatus('current')
if mibBuilder.loadTexts: lookupResultsAddress.setDescription('Reflects a result for a remote lookup operation as per the value of lookupResultsAddressType. The address type (InetAddressType) that relates to this object is specified by the corresponding value of lookupResultsAddress.')
lookupCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 82, 2, 1))
lookupGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 82, 2, 2))
lookupCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 82, 2, 1, 1)).setObjects(("DISMAN-NSLOOKUP-MIB", "lookupGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lookupCompliance = lookupCompliance.setStatus('current')
if mibBuilder.loadTexts: lookupCompliance.setDescription('The compliance statement for SNMP entities that fully implement the DISMAN-NSLOOKUP-MIB.')
lookupMinimumCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 82, 2, 1, 2)).setObjects(("DISMAN-NSLOOKUP-MIB", "lookupGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lookupMinimumCompliance = lookupMinimumCompliance.setStatus('current')
if mibBuilder.loadTexts: lookupMinimumCompliance.setDescription('The minimum compliance statement for SNMP entities that implement the minimal subset of the DISMAN-NSLOOKUP-MIB. Implementors might choose this subset for small devices with limited resources.')
lookupGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 82, 2, 2, 1)).setObjects(("DISMAN-NSLOOKUP-MIB", "lookupMaxConcurrentRequests"), ("DISMAN-NSLOOKUP-MIB", "lookupPurgeTime"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlOperStatus"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlTargetAddressType"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlTargetAddress"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlTime"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlRc"), ("DISMAN-NSLOOKUP-MIB", "lookupCtlRowStatus"), ("DISMAN-NSLOOKUP-MIB", "lookupResultsAddressType"), ("DISMAN-NSLOOKUP-MIB", "lookupResultsAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lookupGroup = lookupGroup.setStatus('current')
if mibBuilder.loadTexts: lookupGroup.setDescription('The group of objects that constitute the remote Lookup operation.')
mibBuilder.exportSymbols("DISMAN-NSLOOKUP-MIB", lookupMaxConcurrentRequests=lookupMaxConcurrentRequests, lookupCtlTime=lookupCtlTime, lookupCompliances=lookupCompliances, lookupCtlTargetAddress=lookupCtlTargetAddress, lookupCtlRowStatus=lookupCtlRowStatus, lookupCtlTable=lookupCtlTable, lookupPurgeTime=lookupPurgeTime, lookupResultsAddressType=lookupResultsAddressType, lookupCtlOperStatus=lookupCtlOperStatus, lookupCtlRc=lookupCtlRc, lookupResultsEntry=lookupResultsEntry, lookupGroups=lookupGroups, lookupCtlOwnerIndex=lookupCtlOwnerIndex, lookupResultsTable=lookupResultsTable, lookupResultsIndex=lookupResultsIndex, lookupResultsAddress=lookupResultsAddress, lookupObjects=lookupObjects, lookupCtlEntry=lookupCtlEntry, lookupGroup=lookupGroup, lookupCompliance=lookupCompliance, lookupConformance=lookupConformance, lookupMinimumCompliance=lookupMinimumCompliance, lookupMIB=lookupMIB, PYSNMP_MODULE_ID=lookupMIB, lookupCtlTargetAddressType=lookupCtlTargetAddressType, lookupCtlOperationName=lookupCtlOperationName)

#
# PySNMP MIB module HH3C-MDC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-MDC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Gauge32, IpAddress, Integer32, Counter32, Counter64, ModuleIdentity, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Bits, MibIdentifier, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Gauge32", "IpAddress", "Integer32", "Counter32", "Counter64", "ModuleIdentity", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Bits", "MibIdentifier", "TimeTicks", "NotificationType")
TextualConvention, DisplayString, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue", "RowStatus")
hh3cMDC = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 136))
hh3cMDC.setRevisions(('2013-03-05 14:48',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cMDC.setRevisionsDescriptions(('The initial revision of this MIB module.',))
if mibBuilder.loadTexts: hh3cMDC.setLastUpdated('201303051448Z')
if mibBuilder.loadTexts: hh3cMDC.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cMDC.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085')
if mibBuilder.loadTexts: hh3cMDC.setDescription('This MIB contains objects to manage MDC (Multitenant Device Context) operations. Such as: 1. Configure MDCs for a device and display MDCs and their status. 2. Assign CPU, storage space, and memory space resources to the MDC, and display their status. 3. Authorize the MDC to use the interface cards, and assign physical interfaces to an MDC. Default MDC: A device supporting MDCs is an MDC itself, and it is called the default MDC. From the default MDC, administrators can manage the entire physical device, create and delete non-default MDCs, and assign interfaces, CPU resources, storage space, and memory space to non-default MDCs. Non-default MDC: No MDCs can be created on a non-default MDC. Administrators of non-default MDCs can only manage and maintain their respective MDCs. A non-default MDC can use only the resources assigned to it.')
class Hh3cMdcActionValue(TextualConvention, Integer32):
    description = 'start: start the MDC stop: stop the MDC'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("start", 1), ("stop", 2))

class Hh3cMdcRunStatus(TextualConvention, Integer32):
    description = 'Status of the MDC: inactive: The MDC is stopped or not started yet. starting: The device is executing the mdc start command to start the MDC. active: The MDC is operating properly. stopping: The device is executing the undo mdc start command to stop the MDC. updating: The device is executing the location command to authorize the MDC to use an interface card.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("inactive", 1), ("starting", 2), ("active", 3), ("stopping", 4), ("updating", 5))

hh3cMDCScalarObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 1))
hh3cMDCMaxMDCNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 136, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCMaxMDCNum.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMaxMDCNum.setDescription('The maximum number of MDCs which the system supported to create.')
hh3cMDCCurrentMDCNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 136, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCCurrentMDCNum.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCCurrentMDCNum.setDescription('The current number of MDCs which the system has created.')
hh3cMDCTables = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2))
hh3cMDCControl = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1))
hh3cMDCControlTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1), )
if mibBuilder.loadTexts: hh3cMDCControlTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCControlTable.setDescription("This table is used to configure MDCs for a device and show MDC's status.")
hh3cMDCControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1), ).setIndexNames((0, "HH3C-MDC-MIB", "hh3cMDCIndex"))
if mibBuilder.loadTexts: hh3cMDCControlEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCControlEntry.setDescription('An entry of the hh3cMDCControlTable, every entry is corresponding with an MDC.')
hh3cMDCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cMDCIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCIndex.setDescription('MDC ID is used as MDCIndex, the value range of MDC ID depends on the device model. MDCIndex cannot be modified after creation.')
hh3cMDCName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cMDCName.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCName.setDescription('Specifies the MDC name, a case-sensitive string of 1 to 15 characters. The MDC name cannot be modified after creation.')
hh3cMDCAction = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1, 3), Hh3cMdcActionValue().clone('stop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCAction.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAction.setDescription('State of MDC action: start/stop. After an MDC is started, administrators of the MDC can log in to the MDC for MDC configuration and maintenance. Stopping an MDC interrupts all services on the MDC and logs out all users of the MDC. Non-default MDC cannot operate.')
hh3cMDCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1, 4), Hh3cMdcRunStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCStatus.setDescription('Status of MDCs.')
hh3cMDCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cMDCRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCRowStatus.setDescription('The status of this table entry. Only support active, createAndGo and destroy.')
hh3cMDCResource = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2))
hh3cMDCDISKResourceTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1), )
if mibBuilder.loadTexts: hh3cMDCDISKResourceTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceTable.setDescription('This table is for disk resource management: Specify a disk space percentage for an MDC and display the disk space usage. Default: All MDCs share the disk space in the system, and an MDC can use all free disk space in the system. Non-default MDC can only query the disk space usage.')
hh3cMDCDISKResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "HH3C-MDC-MIB", "hh3cMDCIndex"), (0, "HH3C-MDC-MIB", "hh3cMDCDISKResourceInstance"))
if mibBuilder.loadTexts: hh3cMDCDISKResourceEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceEntry.setDescription("An entry of the hh3cMDCDISKResourceTable, every entry is corresponding to disk resource of an MDC. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCDISKResourceInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cMDCDISKResourceInstance.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceInstance.setDescription('Instance index of disk resource. Different instances for disk: Flash, CF cards.')
hh3cMDCDISKResourceInstanceName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCDISKResourceInstanceName.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceInstanceName.setDescription('Instance name of disk resource. Such as: Flash, CF cards.')
hh3cMDCDISKResourceMinLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCDISKResourceMinLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceMinLimit.setDescription('Limit minimum (reserve resources, must be all 0).')
hh3cMDCDISKResourceMaxLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCDISKResourceMaxLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceMaxLimit.setDescription('Maximum of available resources of disk. Make sure the disk space amount assigned to an MDC is greater than the disk space amount the MDC is using. Non-default MDC cannot set')
hh3cMDCDISKResourceReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 5), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCDISKResourceReserve.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceReserve.setDescription('The reserve limit resources of disk.')
hh3cMDCDISKResourceQuota = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 6), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCDISKResourceQuota.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceQuota.setDescription('The total limit resources of disk according to hh3cMDCDiskResourceMaxLimit.')
hh3cMDCDISKResourceUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 7), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCDISKResourceUsage.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceUsage.setDescription('Current usage of disk resources.')
hh3cMDCDISKResourceAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 1, 1, 8), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCDISKResourceAvailable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCDISKResourceAvailable.setDescription('Current available resources of disk.')
hh3cMDCMemoryResourceTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2), )
if mibBuilder.loadTexts: hh3cMDCMemoryResourceTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceTable.setDescription('This table is for memory resource management: Specify a memory space percentage for an MDC and display the memory space usage. Default: All MDCs share the memory space in the system, and an MDC can use all free memory. Non-default MDC can only query resource message of memory.')
hh3cMDCMemoryResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "HH3C-MDC-MIB", "hh3cMDCIndex"))
if mibBuilder.loadTexts: hh3cMDCMemoryResourceEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceEntry.setDescription("An entry of the hh3cMDCMemoryResourceTable, every entry is corresponding with memory resource of an MDC. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCMemoryResourceMinLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceMinLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceMinLimit.setDescription('Limit minimum(reserve resources, must be all 0). Non-default MDC cannot set.')
hh3cMDCMemoryResourceMaxLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceMaxLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceMaxLimit.setDescription('Maximum of available resources of memory, it specifies the ratio of the memory space that an MDC can use. Make sure this amount is sufficient for the MDC to operate properly. Non-default MDC cannot set.')
hh3cMDCMemoryResourceReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 3), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceReserve.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceReserve.setDescription('The reserve limit resources of memory.')
hh3cMDCMemoryResourceQuota = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 4), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceQuota.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceQuota.setDescription('The total limit resources of memory.')
hh3cMDCMemoryResourceUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 5), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceUsage.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceUsage.setDescription('Current usage of memory resources.')
hh3cMDCMemoryResourceAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 2, 1, 6), Unsigned32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCMemoryResourceAvailable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCMemoryResourceAvailable.setDescription('Current available value of memory resources.')
hh3cMDCCPUResourceTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 3), )
if mibBuilder.loadTexts: hh3cMDCCPUResourceTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCCPUResourceTable.setDescription('This table is for CPU resource management: Specify a CPU weight for an MDC and display the CPU usage. The amount of CPU resources an MDC can use depends on the CPU weight settings for all MDCs that share the same CPU. Non-default MDC can only query CPU resources.')
hh3cMDCCPUResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 3, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "HH3C-MDC-MIB", "hh3cMDCIndex"))
if mibBuilder.loadTexts: hh3cMDCCPUResourceEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCCPUResourceEntry.setDescription("An entry of the hh3cMDCCPUResourceTable, every entry is corresponding with CPU resources of an MDC. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCCPUResourceLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('weight').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCCPUResourceLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCCPUResourceLimit.setDescription('CPU weight-maximum of available resources of CPU, this number specifies a CPU weight for an MDC. Non-default MDC cannot set.')
hh3cMDCCPUResourceUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCCPUResourceUsage.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCCPUResourceUsage.setDescription('the CPU usage')
hh3cMDCLocation = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 3))
hh3cMDCLocationTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 3, 1), )
if mibBuilder.loadTexts: hh3cMDCLocationTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCLocationTable.setDescription('This table is for location management: Authorize an MDC to use an interface card and query state of location. To assign physical interfaces to an MDC, administrators must authorize the MDC to use the interface cards to which the physical interfaces belong. Default: All interface cards of the device belong to the default MDC, and a non-default MDC cannot use any interface card. Non-default MDC can only query location state.')
hh3cMDCLocationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 3, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "HH3C-MDC-MIB", "hh3cMDCIndex"))
if mibBuilder.loadTexts: hh3cMDCLocationEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCLocationEntry.setDescription("An entry of the hh3cMDCLocationTable, every entry is the status whether an MDC has been Authorized to use the interface cards. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCLocationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 3, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCLocationStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCLocationStatus.setDescription("To authorize the MDC to use the interface cards, set the value of this object to 'true (1)'. To cancel the authorization, set this value to 'false (2)'. Note that the return noError means the command is being executed. For the execution result, check hh3cMDCLocationStatus.")
hh3cMDCAllocate = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4))
hh3cMDCGroupIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 1), )
if mibBuilder.loadTexts: hh3cMDCGroupIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCGroupIfTable.setDescription('This table indication of relation between interfaces and groups, which helps to realize the allocation, together with hh3cMDCAllocateTable. Non-default MDC cannot operate.')
hh3cMDCGroupIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: hh3cMDCGroupIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCGroupIfEntry.setDescription("An entry of the hh3cMDCGroupIfTable, every entry is the relationship between interfaces and groups. Due to hardware restrictions, the interfaces on some interface cards are grouped. The interfaces in a group must be assigned to the same MDC at the same time or removed from an MDC at the same time. Interface grouping depends on the device model. This table is used for hh3cMDCAllocateTable to show interfae group lists. Note that only entPhysicalIndex values that represent physical ports (i.e., associated entPhysicalClass value is 'port(10)') are permitted to exist in this table.")
hh3cMDCGroupIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCGroupIdentity.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCGroupIdentity.setDescription("The interface group ID. There are two parts for this id depicted as follows: 31 7 0 +++++++++++++++++++++++++++++++++++++++++ + entity index + group index + + ( bit 8..31 ) ( bit 0..7 ) + +++++++++++++++++++++++++++++++++++++++++ From bit0 to bit7 (one byte), it is interfaces group index. From bit8 to bit31 (three bytes), it is the physical index the same as the entPhysicalIndex specified in ENTITY-MIB. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCAllocateTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 2), )
if mibBuilder.loadTexts: hh3cMDCAllocateTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAllocateTable.setDescription('This table is used to assigning a physical interface to an MDC. It is allowed that allocate interfaces to a non-default MDC from the default MDC, and allocate interfaces back to the default MDC from a non-default MDC. All physical interfaces on the device belong to the default MDC, and a non-default MDC has no physical interfaces to use. Multiple physical interfaces can be assigned to a non-default MDC. A physical interface must meet the following conditions to be assigned to a non-default MDC: 1. Belongs to the default MDC. 2. Not the console or AUX port. 3. Not the management Ethernet interface. 4. Not in an interface group with an interface assigned to another MDC. 5. The default MDC uses only the physical interfaces that are not assigned to a non-default MDC. Non-default MDC cannot set this table.')
hh3cMDCAllocateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 2, 1), ).setIndexNames((0, "HH3C-MDC-MIB", "hh3cMDCAllocateGroupIndex"))
if mibBuilder.loadTexts: hh3cMDCAllocateEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAllocateEntry.setDescription('An entry of the hh3cMDCAllocateTable, every entry is the status whether physical interfaces have been assigned to an MDC.')
hh3cMDCAllocateGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cMDCAllocateGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAllocateGroupIndex.setDescription("The interface group ID, the same as hh3cMDCGroupIdentity. There are two parts for this id. depicted as follows: 31 7 0 +++++++++++++++++++++++++++++++++++++++++ + entity index + group index + + ( bit 8..31 ) ( bit 0..7 ) + +++++++++++++++++++++++++++++++++++++++++ From bit0 to bit7 (one byte), it is interfaces group index. From bit8 to bit31 (three bytes), it is the physical index the same as the entPhysicalIndex specified in ENTITY-MIB. Note that only entPhysicalIndex values that represent physical boards (i.e., associated entPhysicalClass value is 'module(9)') are permitted to exist in this table.")
hh3cMDCAllocateGroupDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMDCAllocateGroupDescription.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAllocateGroupDescription.setDescription('Interfaces list Such as: GigabitEthernet4/5/0/1 to GigabitEthernet4/5/0/24, GigabitEthernet4/5/0/48')
hh3cMDCAllocateMDCId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 136, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMDCAllocateMDCId.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCAllocateMDCId.setDescription('MDC ID is used as hh3cMDCAllocateMDCId. Default MDC: It is allowed that allocate interfaces to non-default MDC from the default MDC, and allocate interfaces back to the default MDC from a non-default MDC. Non-default MDC cannot set allocation, can only query grouping of own MDC.')
hh3cMDCNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 3))
hh3cMDCNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 136, 3, 0))
hh3cMDCStateChangeToActive = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 136, 3, 0, 1)).setObjects(("HH3C-MDC-MIB", "hh3cMDCIndex"), ("HH3C-MDC-MIB", "hh3cMDCName"))
if mibBuilder.loadTexts: hh3cMDCStateChangeToActive.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCStateChangeToActive.setDescription('The hh3cMDCStateChangeToActive trap indicates that the MDC status has changed to active.')
hh3cMDCStateChangeToInactive = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 136, 3, 0, 2)).setObjects(("HH3C-MDC-MIB", "hh3cMDCIndex"), ("HH3C-MDC-MIB", "hh3cMDCName"))
if mibBuilder.loadTexts: hh3cMDCStateChangeToInactive.setStatus('current')
if mibBuilder.loadTexts: hh3cMDCStateChangeToInactive.setDescription('The hh3cMDCStateChangeToInactive trap indicates that the MDC status has changed to inactive.')
mibBuilder.exportSymbols("HH3C-MDC-MIB", hh3cMDCStateChangeToActive=hh3cMDCStateChangeToActive, hh3cMDCStatus=hh3cMDCStatus, hh3cMDCAllocateMDCId=hh3cMDCAllocateMDCId, hh3cMDCResource=hh3cMDCResource, Hh3cMdcActionValue=Hh3cMdcActionValue, hh3cMDCDISKResourceInstance=hh3cMDCDISKResourceInstance, hh3cMDCDISKResourceUsage=hh3cMDCDISKResourceUsage, hh3cMDCName=hh3cMDCName, hh3cMDCScalarObjects=hh3cMDCScalarObjects, hh3cMDCMemoryResourceMinLimit=hh3cMDCMemoryResourceMinLimit, hh3cMDCCPUResourceUsage=hh3cMDCCPUResourceUsage, hh3cMDCDISKResourceReserve=hh3cMDCDISKResourceReserve, hh3cMDCAllocateGroupDescription=hh3cMDCAllocateGroupDescription, hh3cMDCStateChangeToInactive=hh3cMDCStateChangeToInactive, hh3cMDCMemoryResourceAvailable=hh3cMDCMemoryResourceAvailable, hh3cMDCMaxMDCNum=hh3cMDCMaxMDCNum, hh3cMDCDISKResourceMaxLimit=hh3cMDCDISKResourceMaxLimit, hh3cMDCCPUResourceTable=hh3cMDCCPUResourceTable, hh3cMDCGroupIfTable=hh3cMDCGroupIfTable, hh3cMDCCPUResourceEntry=hh3cMDCCPUResourceEntry, hh3cMDCDISKResourceMinLimit=hh3cMDCDISKResourceMinLimit, hh3cMDCDISKResourceAvailable=hh3cMDCDISKResourceAvailable, hh3cMDCCPUResourceLimit=hh3cMDCCPUResourceLimit, hh3cMDCGroupIfEntry=hh3cMDCGroupIfEntry, hh3cMDCMemoryResourceUsage=hh3cMDCMemoryResourceUsage, hh3cMDCDISKResourceTable=hh3cMDCDISKResourceTable, hh3cMDCAllocateGroupIndex=hh3cMDCAllocateGroupIndex, hh3cMDCControlTable=hh3cMDCControlTable, hh3cMDCLocationTable=hh3cMDCLocationTable, hh3cMDCAllocateTable=hh3cMDCAllocateTable, hh3cMDCLocationEntry=hh3cMDCLocationEntry, Hh3cMdcRunStatus=Hh3cMdcRunStatus, hh3cMDCNotificationObjects=hh3cMDCNotificationObjects, hh3cMDCDISKResourceInstanceName=hh3cMDCDISKResourceInstanceName, hh3cMDCControl=hh3cMDCControl, hh3cMDCDISKResourceEntry=hh3cMDCDISKResourceEntry, hh3cMDCMemoryResourceReserve=hh3cMDCMemoryResourceReserve, hh3cMDCCurrentMDCNum=hh3cMDCCurrentMDCNum, hh3cMDCAction=hh3cMDCAction, hh3cMDCAllocate=hh3cMDCAllocate, hh3cMDCAllocateEntry=hh3cMDCAllocateEntry, hh3cMDCLocation=hh3cMDCLocation, hh3cMDC=hh3cMDC, hh3cMDCMemoryResourceMaxLimit=hh3cMDCMemoryResourceMaxLimit, hh3cMDCMemoryResourceQuota=hh3cMDCMemoryResourceQuota, hh3cMDCControlEntry=hh3cMDCControlEntry, hh3cMDCIndex=hh3cMDCIndex, hh3cMDCRowStatus=hh3cMDCRowStatus, hh3cMDCMemoryResourceTable=hh3cMDCMemoryResourceTable, hh3cMDCLocationStatus=hh3cMDCLocationStatus, hh3cMDCNotification=hh3cMDCNotification, PYSNMP_MODULE_ID=hh3cMDC, hh3cMDCDISKResourceQuota=hh3cMDCDISKResourceQuota, hh3cMDCTables=hh3cMDCTables, hh3cMDCMemoryResourceEntry=hh3cMDCMemoryResourceEntry, hh3cMDCGroupIdentity=hh3cMDCGroupIdentity)

#
# PySNMP MIB module LIEBERT-UPSTATION-S3-UPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-UPSTATION-S3-UPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:07:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysUpTime, = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks, ModuleIdentity, Bits, Counter64, Counter32, Integer32, IpAddress, Gauge32, ObjectIdentity, enterprises, NotificationType, MibIdentifier, iso, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks", "ModuleIdentity", "Bits", "Counter64", "Counter32", "Integer32", "IpAddress", "Gauge32", "ObjectIdentity", "enterprises", "NotificationType", "MibIdentifier", "iso", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
emerson = MibIdentifier((1, 3, 6, 1, 4, 1, 476))
liebertCorp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1))
liebertUps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1))
luExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1))
luExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 2))
luPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 3))
luCore = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1))
lcUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1))
lcUpsIdentManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setDescription('The UPS manufacturer.')
lcUpsIdentModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsIdentModel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentModel.setDescription('The UPS Model designation.')
lcUpsIdentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setDescription('The UPS SNMP Agent software version.')
lcUpsIdentSpecific = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSpecific.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSpecific.setDescription('A reference to MIB definitions specific to the particular UPS being managed. This object is used to locate the product-specific MIB for this device. If this information is not present, its value should be the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
lcUpsBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2))
lcUpsBatTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setDescription('The estimated time to depletion of battery charge. (Unit of measure: Minute)')
lcUpsBatTemperature = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTemperature.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTemperature.setDescription('The battery temperature. (Unit of measure: Degree, Centigrade)')
lcUpsBatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatVoltage.setDescription('The current battery voltage. (Unit of measure: volt)')
lcUpsBatCurrent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCurrent.setDescription('The current battery discharging/charging current. (Unit of measure: Amp)')
lcUpsInput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3))
lcUpsInputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputFrequency.setDescription('The current input frequency. (Unit of measure: Hertz)')
lcUpsInputBrownOuts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputBrownOuts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputBrownOuts.setDescription('The number of brown-out conditions the UPS has experienced.')
lcUpsInputBlackOuts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputBlackOuts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputBlackOuts.setDescription('The number of black-out conditions the UPS has experienced.')
lcUpsInputTransients = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputTransients.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputTransients.setDescription('The number of transient (surge and spike) conditions the UPS has experienced.')
lcUpsInputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputNumLines.setDescription('The number of input lines utilized in this device. This entry indicates the number of rows in the input table.')
lcUpsInputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6), )
if mibBuilder.loadTexts: lcUpsInputTable.setStatus('optional')
lcUpsInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsInputLine"))
if mibBuilder.loadTexts: lcUpsInputEntry.setStatus('optional')
lcUpsInputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputLine.setDescription('The input Line.')
lcUpsInputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVoltage.setDescription('The input voltage. (Unit of measure: Volt)')
lcUpsInputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputCurrent.setDescription('The input current. (Unit of measure: Amp)')
lcUpsInputVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVA.setDescription('The input volt-amps.')
lcUpsOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4))
lcUpsOutputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputFrequency.setDescription('The current output frequency. (Unit of measure: Hertz)')
lcUpsOutputLoad = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLoad.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLoad.setDescription('The current output load percentage.')
lcUpsOutputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputNumLines.setDescription('The number of output lines utilized in this device. This entry indicates the number of rows in the output table.')
lcUpsOutputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4), )
if mibBuilder.loadTexts: lcUpsOutputTable.setStatus('optional')
lcUpsOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsOutputLine"))
if mibBuilder.loadTexts: lcUpsOutputEntry.setStatus('optional')
lcUpsOutputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLine.setDescription('The output Line.')
lcUpsOutputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputVoltage.setDescription('The output voltage. (Unit of measure: Volt)')
lcUpsOutputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputCurrent.setDescription('The output current. (Unit of measure: Amp)')
lcUpsOutputVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputVA.setDescription('The output volt-amps.')
lcUpsInverter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5))
lcUpsInverterStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterStatus.setDescription('The state of the inverter. Unknown is returned if the state can not be determined.')
lcUpsInverterTemp = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterTemp.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterTemp.setDescription('The temperature of the inverter. (Unit of measure: degree, Centigrade)')
lcUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6))
lcUpsAlarms = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarms.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarms.setDescription('The current number of alarm conditions.')
lcUpsAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2), )
if mibBuilder.loadTexts: lcUpsAlarmTable.setStatus('optional')
lcUpsAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsAlarmId"))
if mibBuilder.loadTexts: lcUpsAlarmEntry.setStatus('optional')
lcUpsAlarmId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmId.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmId.setDescription('A unique identifier for an alarm condition. This value must remain constant between agent initializations.')
lcUpsAlarmDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmDescr.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmDescr.setDescription('A reference to an alarm description object. The object referenced should not be accessible, but rather be used to provide a unique description of the alarm condition.')
lcUpsAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmTime.setDescription('The value of sysUpTime when the alarm condition occured.')
lcUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3))
lcUpsAlarmLowBatteryWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 1))
lcUpsAlarmLowBatteryShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 2))
lcUpsAlarmUtilFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 3))
lcUpsAlarmOverTempWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 4))
lcUpsAlarmOutputOverloadWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 6))
lcUpsAlarmInputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 8))
lcUpsAlarmBatteryBad = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 9))
lcUpsAlarmOnBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 10))
lcUpsAlarmUpsOff = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 12))
lcUpsTest = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7))
lcUpsTestBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestBattery.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBattery.setDescription("Setting this variable to 'start' will initiate the battery test. Setting this variable to 'abort' will stop the battery test if the test is in- progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'. If 'lcUpsTestBatteryStatus' is 'failed' the test may not be performed again and the status will remain in the failure state.")
lcUpsTestBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setDescription('The status of the battery test.')
lcUpsTestDiag = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestDiag.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiag.setDescription("Setting this variable to 'start' will initiate the diagnostics test. Setting this variable to 'abort' will stop the diagnostics test if the test is in-progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'.")
lcUpsTestDiagStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setDescription('The status of the diagnostics test.')
lcUpsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8))
lcUpsControlOutputOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOffTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setDescription("When 'lcUpsControlOutputOffDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlOutputOnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setDescription("When 'lcUpsControlOutputOnDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlUnixShutdownDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setDescription("Setting this object causes the agent to instruct the UPS to perform a UNIX Shutdown in the indicated number of seconds. The agent counts down the number of seconds until the event will take place. A Unix shutdown is only valid if the UPS is on Battery. During a UNIX Shutdown, the UPS will turn off the output even if the Utility comes back on line before the shutdown time arrives. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value 'cancel'.")
lcUpsControlUnixShutdownTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setDescription("When 'lcUpsControlUnixShutdownDelay' reaches a value less than or equal to this object's value, an lcUpsUnixShutdownWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlCancelCommands = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setDescription("Setting this variable to 'cancel' will cause the agent to issue instructions to the UPS to cancel all outstanding commands, such as lcUpsControlOutputOff, lcUpsControlOutputOn, lcUpsControlUnixShutdown.")
lcUpsControlRebootAgentDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setDescription('Setting this object causes the agent to reboot after the indicated number of seconds have expired. The value will count down until the event takes place. The command can be cancelled by setting lcUpsControlCancleCommand to the value cancel.')
lcUpsNominal = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9))
lcUpsNominalOutputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setDescription('The nominal output voltage. (Unit of measure: volt)')
lcUpsNominalInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setDescription('The nominal input voltage. (Unit of measure: volt)')
lcUpsNominalOutputVA = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setDescription('The nominal Volt-Amp rating.')
lcUpsNominalOutputWatts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputWatts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputWatts.setDescription('The nominal power rating. (Unit of measure: watt)')
lcUpsNominalOutputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setDescription('The nominal output frequency. (Unit of measure: Hertz)')
lcUpsNominalInputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setDescription('The nominal input frequency. (Unit of measure: Hertz)')
lcUpsSwitchedReceptacles = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12))
lcUpsSwitchedReceptMaxNum = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptMaxNum.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptMaxNum.setDescription('The maximum number of switched receptacles supported by the Ups.')
lcUpsSwitchedReceptTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2), )
if mibBuilder.loadTexts: lcUpsSwitchedReceptTable.setStatus('optional')
lcUpsSwitchedReceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsSwitchedReceptEntry.setStatus('optional')
lcUpsSwitchedReceptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptIndex.setStatus('optional')
lcUpsSwitchedReceptOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on a receptacle after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsReceptOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsSwitchedCancelCommand to the value cancel.")
lcUpsSwitchedReceptOnTrapDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnTrapDelay.setDescription("When 'lcUpsSwitchedReceptOnDelay' reaches a value less than or equal to this object's value, an lcUpsReceptOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsSwitchedReceptOffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off a receptacle after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsReceptOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsSwitchedCancelCommand to the value cancel.")
lcUpsSwitchedReceptOffTrapDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffTrapDelay.setDescription("When 'lcUpsSwitchedReceptOffDelay' reaches a value less than or equal to this object's value, an lcUpsReceptOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsSwitchedReceptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptStatus.setDescription('The status of the device receptacle. Note that some devices may support Switched of device receptacles as a group only (by using lcUpsSwitchedOutputOffDelay and lcUpsSwitchedOutputOnDelay).')
lcUpsSwitchedReceptLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptLabel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptLabel.setDescription('A user-defined text string associated with a switched receptacle. This may be used to describe the load powered from the receptacle. The text string is stored in non-volatile memory.')
lcUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11))
lcUpsOverloadWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadWarningTrap.setDescription("An lcUpsOverloadWarningTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity.")
lcUpsOnBatteryTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOnBatteryTrap.setDescription('An lcUpsOnBatteryTrap signifies that the UPS is currently on Battery Power.')
lcUpsLowBatteryWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryWarningTrap.setDescription('An lcUpsLowBatteryWarningTrap signifies that the UPS has entered a Low Battery state.')
lcUpsUtilPowerFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,6)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerFailedTrap.setDescription('An lcUpsUtilPowerFailedTrap signifies that the utility power input to the UPS has been lost.')
lcUpsUtilPowerRestoredTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,7)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerRestoredTrap.setDescription('An lcUpsUtilPowerRestoredTrap signifies that the utility power has been restored to the UPS.')
lcUpsInputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,8)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputOverVoltageTrap.setDescription('An lcUpsInputOverVoltageTrap signifies that the UPS has detected a high input voltage condition.')
lcUpsOverTempWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,9)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempWarningTrap.setDescription('An lcUpsOverTempWarningTrap signifies that the UPS has detected a excessive temperature condition.')
lcUpsAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,11)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsAlarmTrap.setDescription('An Alarm condition has occurred and is being reported in the lcUpsAlarmTable.')
lcUpsOutputOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,12)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffTrap.setDescription('An lcUpsOutputOffTrap is sent when the UPS turns all of its output off, either at the inverter or via a relay.')
lcUpsOutputOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,13)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffWarningTrap.setDescription('An lcUpsOutputOffWarningTrap is sent when the lcUpsControlOutputOffDelay reaches the value of lcUpsControlOutputOffTrapDelay.')
lcUpsOutputOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,14)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnTrap.setDescription('An lcUpsOutputOnTrap is sent when the UPS turns all of its output back on, either at the inverter or via a relay.')
lcUpsOutputOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,15)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnWarningTrap.setDescription('An lcUpsOutputOnWarningTrap is sent when the lcUpsControlOutputOnDelay reaches the value of lcUpsControlOutputOnTrapDelay.')
lcUpsUnixShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,16)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownTrap.setDescription('An lcUpsUnixShutodwnTrap is sent 2 seconds before the UPS is scheduled to perform a Unix Shutdown.')
lcUpsUnixShutdownWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,17)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownWarningTrap.setDescription('An lcUpsUnixShutdownWarningTrap is sent when the lcUpsControlUnixShudownDelay reaches the value of lcUpsControlUnixShutdownTrapDelay.')
lcUpsReceptOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,18)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOffTrap.setDescription('An lcUpsReceptOffTrap is sent when the UPS turns an output receptacle off.')
lcUpsReceptOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,19)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOffWarningTrap.setDescription('An lcUpsReceptOffWarningTrap is sent when the lcUpsSwitchedReceptOffDelay reaches the value of lcUpsSwitchedReceptOffTrapDelay.')
lcUpsReceptOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,20)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOnTrap.setDescription('An lcUpsReceptOnTrap is sent when the UPS turns an output receptacle on.')
lcUpsReceptOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,21)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPSTATION-S3-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOnWarningTrap.setDescription('An lcUpsReceptOnWarningTrap is sent when the lcUpsSwitchedReceptOnDelay reaches the value of lcUpsSwitchedReceptOnTrapDelay.')
luUPStationS = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2))
lsUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 1))
lsUpsIdentFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsIdentFirmwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lsUpsIdentFirmwareVersion.setDescription('The firmware revision level of the UPS.')
lsUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6))
lsUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6, 1))
lsUpsAlarmCheckAirFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6, 1, 1))
lsUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 11))
lsUpsCheckAirFilterTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lsUpsCheckAirFilterTrap.setDescription('An lsUpsCheckAirFilterTrap signifies that the programmed time interval for checking the air filter has passed and it is time to check the air filter.')
lsUpsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 12))
lsUpsConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: lsUpsConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
lsUpsBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13))
lsUpsOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsOnBypass.setStatus('optional')
if mibBuilder.loadTexts: lsUpsOnBypass.setDescription('Indicates that the UPS is currently on bypass.')
lsUpsBypassFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassFrequency.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassFrequency.setDescription('The current bypass frequency. (Unit of measure: Hertz)')
lsUpsBypassNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassNumLines.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassNumLines.setDescription('The number of bypass lines utilized in this device. This entry indicates the number of rows in the bypass table.')
lsUpsBypassTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4), )
if mibBuilder.loadTexts: lsUpsBypassTable.setStatus('optional')
lsUpsBypassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-S3-UPS-MIB", "lsUpsBypassLine"))
if mibBuilder.loadTexts: lsUpsBypassEntry.setStatus('optional')
lsUpsBypassLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassLine.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassLine.setDescription('The bypass Line.')
lsUpsBypassVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassVoltage.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassVoltage.setDescription('The bypass voltage. (Unit of measure: Volt)')
lsUpsBypassCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassCurrent.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassCurrent.setDescription('The bypass current. (Unit of measure: Amp)')
luUPStationS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 7))
mibBuilder.exportSymbols("LIEBERT-UPSTATION-S3-UPS-MIB", lcUpsAlarms=lcUpsAlarms, lcUpsAlarmLowBatteryWarning=lcUpsAlarmLowBatteryWarning, lcUpsTestDiag=lcUpsTestDiag, lcUpsTest=lcUpsTest, lcUpsInputCurrent=lcUpsInputCurrent, lcUpsOutputOffTrap=lcUpsOutputOffTrap, lcUpsControlOutputOnDelay=lcUpsControlOutputOnDelay, lcUpsOutputLine=lcUpsOutputLine, lsUpsBypassEntry=lsUpsBypassEntry, lcUpsNominalOutputVoltage=lcUpsNominalOutputVoltage, lcUpsInputBrownOuts=lcUpsInputBrownOuts, lcUpsControlUnixShutdownTrapDelay=lcUpsControlUnixShutdownTrapDelay, lcUpsSwitchedReceptOnTrapDelay=lcUpsSwitchedReceptOnTrapDelay, lcUpsOutputOnWarningTrap=lcUpsOutputOnWarningTrap, lcUpsControlCancelCommands=lcUpsControlCancelCommands, lcUpsIdentManufacturer=lcUpsIdentManufacturer, lcUpsBatCurrent=lcUpsBatCurrent, lcUpsAlarmUpsOff=lcUpsAlarmUpsOff, lcUpsAlarmOutputOverloadWarning=lcUpsAlarmOutputOverloadWarning, lsUpsBypassNumLines=lsUpsBypassNumLines, lcUpsInputVA=lcUpsInputVA, lcUpsControlOutputOffDelay=lcUpsControlOutputOffDelay, lcUpsUtilPowerFailedTrap=lcUpsUtilPowerFailedTrap, lcUpsOutputLoad=lcUpsOutputLoad, lcUpsTestBattery=lcUpsTestBattery, lcUpsControl=lcUpsControl, lsUpsBypass=lsUpsBypass, lcUpsIdentSpecific=lcUpsIdentSpecific, lcUpsAlarmLowBatteryShutdown=lcUpsAlarmLowBatteryShutdown, lcUpsAlarmTable=lcUpsAlarmTable, lcUpsLowBatteryWarningTrap=lcUpsLowBatteryWarningTrap, lcUpsNominalInputVoltage=lcUpsNominalInputVoltage, lcUpsInputVoltage=lcUpsInputVoltage, lcUpsOverTempWarningTrap=lcUpsOverTempWarningTrap, lcUpsAlarmTime=lcUpsAlarmTime, lcUpsIdentModel=lcUpsIdentModel, lcUpsInputLine=lcUpsInputLine, lcUpsOutputNumLines=lcUpsOutputNumLines, lcUpsNominalOutputVA=lcUpsNominalOutputVA, lcUpsOutputFrequency=lcUpsOutputFrequency, lcUpsOutput=lcUpsOutput, lsUpsOnBypass=lsUpsOnBypass, lcUpsNominal=lcUpsNominal, lcUpsSwitchedReceptOffDelay=lcUpsSwitchedReceptOffDelay, lsUpsIdent=lsUpsIdent, lcUpsNominalInputFreq=lcUpsNominalInputFreq, luExtensions=luExtensions, luUPStationS3=luUPStationS3, lcUpsNominalOutputWatts=lcUpsNominalOutputWatts, lcUpsReceptOnWarningTrap=lcUpsReceptOnWarningTrap, lcUpsIdent=lcUpsIdent, luPrivate=luPrivate, lcUpsAlarmBatteryBad=lcUpsAlarmBatteryBad, lsUpsAlarm=lsUpsAlarm, emerson=emerson, lcUpsInputNumLines=lcUpsInputNumLines, lcUpsBatTemperature=lcUpsBatTemperature, lcUpsSwitchedReceptMaxNum=lcUpsSwitchedReceptMaxNum, lcUpsOverloadWarningTrap=lcUpsOverloadWarningTrap, lcUpsOnBatteryTrap=lcUpsOnBatteryTrap, luUPStationS=luUPStationS, lcUpsAlarmOverTempWarning=lcUpsAlarmOverTempWarning, lcUpsInputTable=lcUpsInputTable, lcUpsSwitchedReceptacles=lcUpsSwitchedReceptacles, lcUpsOutputEntry=lcUpsOutputEntry, lcUpsOutputVA=lcUpsOutputVA, lcUpsUnixShutdownTrap=lcUpsUnixShutdownTrap, lsUpsBypassTable=lsUpsBypassTable, lcUpsSwitchedReceptLabel=lcUpsSwitchedReceptLabel, lcUpsOutputOffWarningTrap=lcUpsOutputOffWarningTrap, lcUpsSwitchedReceptTable=lcUpsSwitchedReceptTable, lcUpsControlOutputOnTrapDelay=lcUpsControlOutputOnTrapDelay, lcUpsInput=lcUpsInput, lcUpsOutputTable=lcUpsOutputTable, lcUpsUtilPowerRestoredTrap=lcUpsUtilPowerRestoredTrap, luCore=luCore, lcUpsInverterTemp=lcUpsInverterTemp, lcUpsControlUnixShutdownDelay=lcUpsControlUnixShutdownDelay, lcUpsSwitchedReceptEntry=lcUpsSwitchedReceptEntry, lcUpsIdentSoftwareVersion=lcUpsIdentSoftwareVersion, lcUpsAlarmTrap=lcUpsAlarmTrap, lsUpsCheckAirFilterTrap=lsUpsCheckAirFilterTrap, lcUpsAlarmDescr=lcUpsAlarmDescr, lcUpsInputBlackOuts=lcUpsInputBlackOuts, lcUpsSwitchedReceptOnDelay=lcUpsSwitchedReceptOnDelay, lcUpsInverter=lcUpsInverter, lcUpsControlRebootAgentDelay=lcUpsControlRebootAgentDelay, liebertUps=liebertUps, lcUpsInputEntry=lcUpsInputEntry, lcUpsBatTimeRemaining=lcUpsBatTimeRemaining, lsUpsAlarmCheckAirFilter=lsUpsAlarmCheckAirFilter, lsUpsConfig=lsUpsConfig, lsUpsBypassLine=lsUpsBypassLine, lcUpsTraps=lcUpsTraps, luExperimental=luExperimental, liebertCorp=liebertCorp, lsUpsConfigBypassInstalled=lsUpsConfigBypassInstalled, lsUpsTraps=lsUpsTraps, lcUpsAlarm=lcUpsAlarm, lcUpsBattery=lcUpsBattery, lcUpsAlarmUtilFailed=lcUpsAlarmUtilFailed, lcUpsOutputOnTrap=lcUpsOutputOnTrap, lcUpsAlarmConditions=lcUpsAlarmConditions, lcUpsReceptOffWarningTrap=lcUpsReceptOffWarningTrap, lcUpsInputTransients=lcUpsInputTransients, lcUpsOutputVoltage=lcUpsOutputVoltage, lcUpsAlarmId=lcUpsAlarmId, lcUpsAlarmEntry=lcUpsAlarmEntry, lcUpsBatVoltage=lcUpsBatVoltage, lcUpsTestBatteryStatus=lcUpsTestBatteryStatus, lcUpsSwitchedReceptStatus=lcUpsSwitchedReceptStatus, lcUpsInputOverVoltageTrap=lcUpsInputOverVoltageTrap, lcUpsInverterStatus=lcUpsInverterStatus, lcUpsUnixShutdownWarningTrap=lcUpsUnixShutdownWarningTrap, lcUpsTestDiagStatus=lcUpsTestDiagStatus, lcUpsInputFrequency=lcUpsInputFrequency, lcUpsControlOutputOffTrapDelay=lcUpsControlOutputOffTrapDelay, lcUpsReceptOnTrap=lcUpsReceptOnTrap, lcUpsAlarmInputOverVoltage=lcUpsAlarmInputOverVoltage, lcUpsReceptOffTrap=lcUpsReceptOffTrap, lcUpsSwitchedReceptIndex=lcUpsSwitchedReceptIndex, lcUpsAlarmOnBattery=lcUpsAlarmOnBattery, lsUpsBypassVoltage=lsUpsBypassVoltage, lsUpsBypassFrequency=lsUpsBypassFrequency, lcUpsSwitchedReceptOffTrapDelay=lcUpsSwitchedReceptOffTrapDelay, lsUpsAlarmConditions=lsUpsAlarmConditions, lsUpsIdentFirmwareVersion=lsUpsIdentFirmwareVersion, lcUpsNominalOutputFreq=lcUpsNominalOutputFreq, lcUpsOutputCurrent=lcUpsOutputCurrent, lsUpsBypassCurrent=lsUpsBypassCurrent)

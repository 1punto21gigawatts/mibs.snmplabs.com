#
# PySNMP MIB module CISCO-VISM-CAC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-VISM-CAC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:18:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
voice, vismChanCnfGrp = mibBuilder.importSymbols("BASIS-MIB", "voice", "vismChanCnfGrp")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, ModuleIdentity, Integer32, Unsigned32, Counter64, IpAddress, Gauge32, TimeTicks, iso, ObjectIdentity, Counter32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "ModuleIdentity", "Integer32", "Unsigned32", "Counter64", "IpAddress", "Gauge32", "TimeTicks", "iso", "ObjectIdentity", "Counter32", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ciscoVismCacMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 96))
ciscoVismCacMIB.setRevisions(('2004-02-20 00:00', '2003-06-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoVismCacMIB.setRevisionsDescriptions(('Update with description changes. ', 'Initial version of the MIB. The content of this MIB was originally available in SMIv1 version. The MIB has been converted to SMIv2 version and descriptions of some of the objects have been modified. ',))
if mibBuilder.loadTexts: ciscoVismCacMIB.setLastUpdated('200402200000Z')
if mibBuilder.loadTexts: ciscoVismCacMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoVismCacMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoVismCacMIB.setDescription('The MIB module containing the CAC information for VISM service module.')
vismCardCacFailuresGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20))
vismChanCacTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3), )
if mibBuilder.loadTexts: vismChanCacTable.setStatus('current')
if mibBuilder.loadTexts: vismChanCacTable.setDescription("This table defines the CAC success or failure statistics. CAC functionality is applied on a per PVC(Permanent virtual circuit) basis for accepting the new calls in a switching model (i.e when CRCX(CreateConnection) message is received from the call agent) and when adding a new binding between a CID(Channel Identifier) and a PVC in the AAL2 trunking application ('addcid' command). In both switching and trunking models, the CAC functionality is applied for upspeeding the connections due to the detection of fax/modem tone on a connection configured with voice compression. The entries in this table are implicitly created and deleted with the creation and deletion of entries in vismChanCnfGrpEntry (defined in CISCO-VISM-CONN-MIB MIB). ")
vismChanCacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1), ).setIndexNames((0, "CISCO-VISM-CAC-MIB", "vismChanNum"))
if mibBuilder.loadTexts: vismChanCacEntry.setStatus('current')
if mibBuilder.loadTexts: vismChanCacEntry.setDescription('Each entry in this table corresponds to a PVC, since the CAC functionality is applied on a per PVC basis. The bandwidth is allocated on a per PVC basis and the connection admission control is done by comparing the available bandwidth on a PVC with the required bandwidth as a result of new connection setup request or upspeed request. ')
vismChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanNum.setStatus('current')
if mibBuilder.loadTexts: vismChanNum.setDescription('This attribute defines the index for the vismChanCac Table. The LCN(Logical channel number) number is the same as the LCN value used as the index for the vismChanCnfGrpTable (defined in CISCO-VISM-CONN-MIB MIB) i.e. vismCnfChanNum. ')
vismChanCacMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2))).clone('master')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCacMaster.setStatus('current')
if mibBuilder.loadTexts: vismChanCacMaster.setDescription('This attribute defines whether the PVC is the master end or slave end. CAC functionality is applied only at the master end of the PVC. It is not necessary if the PVC end is configured as the slave end. This is to prevent the glare condition resulting from the simultaneous allocation of the same bandwidth for different calls from both ends. This parameter is applicable only in the trunking mode. ')
vismChanCacPassedCons = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanCacPassedCons.setStatus('current')
if mibBuilder.loadTexts: vismChanCacPassedCons.setDescription("This attribute defines the count of connections that passed successfully the CAC function. CAC functionality is applied either due to 1) The CRCX message sent to VISM from the Call Agent to set up a new connection OR at the time of 'addcid' command in AAL2 trunking application. 2) Upspeed request due to fax/modem tone detection on a connection configured for compression. ")
vismChanCacRejectedCons = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanCacRejectedCons.setStatus('current')
if mibBuilder.loadTexts: vismChanCacRejectedCons.setDescription('This attribute defines the count of connections that got rejected due to CAC function. The CAC rejection was due to the bandwidth not being available on a given PVC. ')
vismChanCacRejectionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("maintain", 2), ("unspecified", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCacRejectionPolicy.setStatus('current')
if mibBuilder.loadTexts: vismChanCacRejectionPolicy.setDescription("This attribute defines the policy that needs to be applied once the CAC function rejects the upspeeding of a connection, due to a fax/modem switchover request. The applicable options are 'delete' - to delete the connection that got rejected by CAC for upspeed. 'maintain' - to maintain the connection with the prior compression scheme. 'unspecified' - The CAC rejection policy as defined in the card level object vismCacRejectionPolicy(defined in CISCO-VISM-MODULE-MIB MIB) will be used, else the value of this object will be used. Note that the default value of maintaining the prior encoding scheme is applicable in the trunking application only since the connection is not deleted after the fax/modem switchover.In the case of switching application, the connection is deleted after the fax/modem switchover. Configuring this object will not have any affect when card level CAC object vismCacEnable(defined in CISCO-VISM-MODULE-MIB MIB) is disabled. ")
vismChanCarrierLossPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("previousCodec", 1), ("upspeedCodec", 2), ("unspecified", 3))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCarrierLossPolicy.setStatus('current')
if mibBuilder.loadTexts: vismChanCarrierLossPolicy.setDescription("This object defines the policy that needs to be applied when a carrier loss is detected. The possible policies are defined as follows: 'previousCodec' - switch to the pre-upspeed codec when a a carrier loss is detected. 'upspeedCodec' - remain with the upspeed codec when a carrier loss is detected. 'unspecified' - The card level object value vismCarrierLossPolicy(defined in CISCO-VISM-MODULE-MIB MIB) will be used. Configuring this object will not have any affect when card level CAC object vismCacEnable (defined in CISCO-VISM-MODULE-MIB MIB) is disabled. ")
vismChanVADTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(100)).setUnits('0.0001 percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanVADTolerance.setStatus('current')
if mibBuilder.loadTexts: vismChanVADTolerance.setDescription('The value in this object refers to the customer accepted drop rate for voice connections when the bandwidth usage exceeds allowed value. A value of zero indicates the card level object vismVADTolerance(defined in CISCO-VISM-MODULE-MIB MIB) value will be used. Configuring this object will not have any affect when card level CAC object vismCacEnable(defined in CISCO-VISM-MODULE-MIB MIB) is disabled. ')
vismChanVADDutyCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(61)).setUnits('0.01 percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanVADDutyCycle.setStatus('current')
if mibBuilder.loadTexts: vismChanVADDutyCycle.setDescription('This object refers to the talk-spurts duty cycle. A value of zero indicates the card level object vismVADDutyCycle(defined in CISCO-VISM-MODULE-MIB MIB) value will be used. Configuring this object will not have any affect when card level CAC object vismCacEnable(defined in CISCO-VISM-MODULE-MIB MIB) is disabled. ')
networkCacConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("notOk", 2))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: networkCacConfigState.setStatus('current')
if mibBuilder.loadTexts: networkCacConfigState.setDescription("This attribute defines whether the originating and terminating VISMs are configured properly or not, by default the configuration is assumed to be 'ok' and this object is set to 'ok', if later during upspeed if we discover that both the originating and terminating VISMs are configured as either CAC master or slave then it is considered as an invalid configuration and this object will be set to 'notOk' and trapNetworkCacConfigState(defined in CISCO-VISM-TRAPS-MIB MIB) change trap will be sent. This parameter is applicable only in trunking applications. ")
vismPortCacPvcAddFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacPvcAddFailures.setStatus('current')
if mibBuilder.loadTexts: vismPortCacPvcAddFailures.setDescription('Total number of attempts to add or modify a PVC to VISM virtual port that were rejected by port level CAC. ')
vismPortCacSvcAddFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacSvcAddFailures.setStatus('current')
if mibBuilder.loadTexts: vismPortCacSvcAddFailures.setDescription('Total number of attempts to add a SVC (Switched Virtual Circuit) to VISM virtual port that were rejected by port level CAC. ')
vismVcCacPvcFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismVcCacPvcFailures.setStatus('current')
if mibBuilder.loadTexts: vismVcCacPvcFailures.setDescription('Total number of attempts to admit voice connections over bearer PVC connections that were rejected by voice CAC. It is sum of all voice CAC failures for all VISM bearer PVC connections. ')
vismVcCacPvcUpspeedFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismVcCacPvcUpspeedFailures.setStatus('current')
if mibBuilder.loadTexts: vismVcCacPvcUpspeedFailures.setDescription('Total number of attempts to upspeed voice connections over bearer PVC connections that were rejected by port level CAC. ')
vismPortCacSvcUpspeedFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacSvcUpspeedFailures.setStatus('current')
if mibBuilder.loadTexts: vismPortCacSvcUpspeedFailures.setDescription('Total number of attempts to upspeed voice connections over bearer SVC connections that were rejected by port level CAC. ')
ciscoVismCacMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 96, 2))
ciscoVismCacMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 96, 2, 1))
ciscoVismCacMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 96, 2, 2))
ciscoVismCacCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 96, 2, 2, 1)).setObjects(("CISCO-VISM-CAC-MIB", "ciscoVismChanCacGroup"), ("CISCO-VISM-CAC-MIB", "ciscoVismCardCacFailuresGrp"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismCacCompliance = ciscoVismCacCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoVismCacCompliance.setDescription('The compliance statement for objects related to VISM CAC module.')
ciscoVismChanCacGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 96, 2, 1, 1)).setObjects(("CISCO-VISM-CAC-MIB", "vismChanNum"), ("CISCO-VISM-CAC-MIB", "vismChanCacMaster"), ("CISCO-VISM-CAC-MIB", "vismChanCacPassedCons"), ("CISCO-VISM-CAC-MIB", "vismChanCacRejectedCons"), ("CISCO-VISM-CAC-MIB", "vismChanCacRejectionPolicy"), ("CISCO-VISM-CAC-MIB", "vismChanCarrierLossPolicy"), ("CISCO-VISM-CAC-MIB", "vismChanVADTolerance"), ("CISCO-VISM-CAC-MIB", "vismChanVADDutyCycle"), ("CISCO-VISM-CAC-MIB", "networkCacConfigState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismChanCacGroup = ciscoVismChanCacGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismChanCacGroup.setDescription('A collection of objects providing CAC feature on PVC. ')
ciscoVismCardCacFailuresGrp = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 96, 2, 1, 2)).setObjects(("CISCO-VISM-CAC-MIB", "vismPortCacPvcAddFailures"), ("CISCO-VISM-CAC-MIB", "vismPortCacSvcAddFailures"), ("CISCO-VISM-CAC-MIB", "vismVcCacPvcFailures"), ("CISCO-VISM-CAC-MIB", "vismVcCacPvcUpspeedFailures"), ("CISCO-VISM-CAC-MIB", "vismPortCacSvcUpspeedFailures"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismCardCacFailuresGrp = ciscoVismCardCacFailuresGrp.setStatus('current')
if mibBuilder.loadTexts: ciscoVismCardCacFailuresGrp.setDescription('A collection of objects providing CAC statistics for both SVC and PVC connection. ')
mibBuilder.exportSymbols("CISCO-VISM-CAC-MIB", networkCacConfigState=networkCacConfigState, vismChanVADDutyCycle=vismChanVADDutyCycle, vismVcCacPvcFailures=vismVcCacPvcFailures, vismPortCacPvcAddFailures=vismPortCacPvcAddFailures, ciscoVismCacMIBConformance=ciscoVismCacMIBConformance, ciscoVismChanCacGroup=ciscoVismChanCacGroup, PYSNMP_MODULE_ID=ciscoVismCacMIB, vismChanCacMaster=vismChanCacMaster, vismVcCacPvcUpspeedFailures=vismVcCacPvcUpspeedFailures, vismPortCacSvcUpspeedFailures=vismPortCacSvcUpspeedFailures, ciscoVismCacMIBCompliances=ciscoVismCacMIBCompliances, vismChanCacRejectionPolicy=vismChanCacRejectionPolicy, vismChanVADTolerance=vismChanVADTolerance, ciscoVismCacMIBGroups=ciscoVismCacMIBGroups, ciscoVismCacMIB=ciscoVismCacMIB, vismCardCacFailuresGrp=vismCardCacFailuresGrp, vismChanCacEntry=vismChanCacEntry, vismChanCacRejectedCons=vismChanCacRejectedCons, vismChanNum=vismChanNum, vismChanCacTable=vismChanCacTable, vismChanCarrierLossPolicy=vismChanCarrierLossPolicy, ciscoVismCacCompliance=ciscoVismCacCompliance, vismPortCacSvcAddFailures=vismPortCacSvcAddFailures, ciscoVismCardCacFailuresGrp=ciscoVismCardCacFailuresGrp, vismChanCacPassedCons=vismChanCacPassedCons)

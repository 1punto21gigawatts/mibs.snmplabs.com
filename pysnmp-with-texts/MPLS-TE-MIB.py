#
# PySNMP MIB module MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-TE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:19:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv4, InetAddressIPv6 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddressIPv6")
MplsBurstSize, MplsBitRate, MplsLSPID = mibBuilder.importSymbols("MPLS-LSR-MIB", "MplsBurstSize", "MplsBitRate", "MplsLSPID")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Integer32, NotificationType, IpAddress, Counter32, Unsigned32, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ModuleIdentity, experimental, ObjectIdentity, MibIdentifier, iso, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "IpAddress", "Counter32", "Unsigned32", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ModuleIdentity", "experimental", "ObjectIdentity", "MibIdentifier", "iso", "Gauge32")
TruthValue, RowPointer, StorageType, RowStatus, TimeStamp, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowPointer", "StorageType", "RowStatus", "TimeStamp", "TextualConvention", "DisplayString")
mplsTeMIB = ModuleIdentity((1, 3, 6, 1, 3, 95))
mplsTeMIB.setRevisions(('2000-11-21 12:00', '2000-07-14 12:00', '2000-05-26 12:00', '2000-03-03 12:00', '1999-07-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsTeMIB.setRevisionsDescriptions(('Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Initial draft version.',))
if mibBuilder.loadTexts: mplsTeMIB.setLastUpdated('200011211200Z')
if mibBuilder.loadTexts: mplsTeMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsTeMIB.setContactInfo(' Cheenu Srinivasan Postal: Tachion Networks, Inc. Monmouth Park Corporate Center I Building C, 185 Monmouth Park Highway West Long Branch, NJ 07764 Tel: +1-732-542-7750 x1234 Email: cheenu@tachion.com Arun Viswanathan Postal: Force10 Networks, Inc. 1440 McCarthy Blvd Milpitas, CA 95035 Tel: +1-408-571-3516 Email: arun@force10networks.com Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-244-3051 Email: tnadeau@cisco.com')
if mibBuilder.loadTexts: mplsTeMIB.setDescription("This MIB module contains managed object definitions for MPLS Traffic Engineering (TE) as defined in: Extensions to RSVP for LSP Tunnels, Awduche et al, Internet Draft <draft-ietf-mpls- rsvp-lsp-tunnel-07.txt>, August 2000; Constraint- Based LSP Setup using LDP, B. Jamoussi, Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>, July 2000; Requirements for Traffic Engineering Over MPLS, Awduche, D., J. Malcolm, J., Agogbua, J., O'Dell, M., J. McManus, <rfc2702.txt>, September 1999.")
class MplsTunnelIndex(TextualConvention, Integer32):
    description = 'Index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class MplsTunnelInstanceIndex(TextualConvention, Unsigned32):
    description = 'Instance index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class MplsLsrId(TextualConvention, Unsigned32):
    description = 'A unique identifier for an MPLS LSR. This MAY represent an IpV4 address.'
    status = 'current'

class MplsPathIndex(TextualConvention, Unsigned32):
    description = 'A unique identifier used to identify a specific path used by a tunnel.'
    status = 'current'

class MplsPathIndexOrZero(TextualConvention, Unsigned32):
    description = 'A unique identifier used to identify a specific path used by a tunnel. If this value is set to 0, it indicates that no path is in use.'
    status = 'current'

mplsTeScalars = MibIdentifier((1, 3, 6, 1, 3, 95, 1))
mplsTeObjects = MibIdentifier((1, 3, 6, 1, 3, 95, 2))
mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 3, 95, 3))
mplsTeNotifyPrefix = MibIdentifier((1, 3, 6, 1, 3, 95, 3, 0))
mplsTeConformance = MibIdentifier((1, 3, 6, 1, 3, 95, 4))
mplsTunnelConfigured = MibScalar((1, 3, 6, 1, 3, 95, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelConfigured.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelConfigured.setDescription('The number of tunnels configured on this device. A tunnel is considered configured if the mplsTunnelRowStatus is active(1).')
mplsTunnelActive = MibScalar((1, 3, 6, 1, 3, 95, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelActive.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelActive.setDescription('The number of tunnels active on this device. A tunnel is considered active if the mplsTunnelOperStatus is up(1).')
mplsTunnelTEDistProto = MibScalar((1, 3, 6, 1, 3, 95, 1, 3), Bits().clone(namedValues=NamedValues(("other", 0), ("ospf", 1), ("isis", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setDescription('The traffic engineering distribution protocol(s) used by this LSR. Note that an LSR may support more than one distribution protocols simultaneously.')
mplsTunnelMaxHops = MibScalar((1, 3, 6, 1, 3, 95, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMaxHops.setDescription('The maximum number of hops that can be specified for a tunnel on this device.')
mplsTunnelIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNext.setDescription('This object contains the next appropriate value to be used for mplsTunnelIndex when creating entries in mplsTunnelTable. If the number of unassigned entries is exhausted, a retrival operation will return a value of 0. This object may also return a value of 0 when the LSR is unable to accept conceptual row creation, for example, if the mplsTunnelTable is implemented as read-only. To obtain the value of mplsTunnelIndex for a new entry, the manager must first issue a management protocol retrieval operation to obtain the current value of this object. The agent should modify the value to reflect the next unassigned index after each retrieval operation. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsTunnelTable = MibTable((1, 3, 6, 1, 3, 95, 2, 2), )
if mibBuilder.loadTexts: mplsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTable.setDescription('The mplsTunnelTable allows new MPLS tunnels to be created between an LSR and a remote endpoint, and existing tunnels to be reconfigured or removed. Note that only point-to-point tunnel segments are supported, although multi-point-to-point and point- to-multi-point connections are supported by an LSR acting as a cross-connect. Each MPLS tunnel can thus have one out-segment originating at this LSR and/or one in-segment terminating at this LSR.')
mplsTunnelEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 2, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: mplsTunnelEntry.setReference('1. RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997 2. RFC 1700 - Assigned Numbers, Reynolds, J. and J. Postel, Oct. 1994')
if mibBuilder.loadTexts: mplsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEntry.setDescription('An entry in this table represents an MPLS tunnel. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol. Whenever a new entry is created with mplsTunnelIsIf set to true(1), then a corresponding entry is created in ifTable as well (see RFC 2233). The ifType of this entry is mplsTunnel(150).')
mplsTunnelIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 1), MplsTunnelIndex())
if mibBuilder.loadTexts: mplsTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndex.setDescription('Uniquely identifies this row.')
mplsTunnelInstance = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstance.setDescription('Uniquely identifies an instance of a tunnel. It is useful to identify multiple instances of tunnels for the purposes of backup and parallel tunnels.')
mplsTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 3), MplsLsrId())
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al, Internet Draft <draft-ietf-mpls- rsvp-lsp-tunnel-07.txt>, August 2000., 2. Constraint-Based LSP Setup using LDP, Jamoussi, Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setDescription('The purpose of this object is to uniquely identity a tunnel within a network. When the MPLS signalling protoocol is rsvp(2) this value should mimic the Extended Tunnel Id field in the Session object. When the MPLS signalling protoocol is crldp(3) this value should mimic the Ingress LSR Router ID field in the LSPID TLV object.')
mplsTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 4), MplsLsrId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setDescription('Specifies the egress LSR Id.')
mplsTunnelName = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelName.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelName.setDescription('The canonical name assigned to the tunnel. This name can be used to refer to the tunnel on the LSRs console port. If mplsTunnelIsIf is set to true then the ifName of the interface corresponding to this tunnel should have a value equal to mplsTunnelName. Also see the description of ifName in RFC 2233.')
mplsTunnelDescr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 6), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDescr.setDescription('A textual string containing information about the tunnel. If there is no description this object contains a zero length string.')
mplsTunnelIsIf = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIf.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIsIf.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIf.setDescription('Denotes whether or not this tunnel corresponds to an interface represented in the interfaces group table. Note that if this variable is set to true then the ifName of the interface corresponding to this tunnel should have a value equal to mplsTunnelName. Also see the description of ifName in RFC 2233.')
mplsTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setDescription('If mplsTunnelIsIf is set to true, then this value contains the LSR-assigned ifIndex which corresponds to an entry in the interfaces table. Otherwise this variable should contain the value of zero indicating that a valid ifIndex was not assigned to this tunnel interface.')
mplsTunnelXCPointer = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 9), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelXCPointer.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS Label Switch Router Management Information Base Using SMIv2, Internet Draft <draft-ietf-mpls- lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setDescription('This variable points to a row in the mplsXCTable. This table identifies the segments that compose this tunnel, their characteristics, and relationships to each other. A value of zeroDotZero indicates that no LSP has been associated with this tunnel yet.')
mplsTunnelSignallingProto = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rsvp", 2), ("crldp", 3), ("other", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setDescription('The signaling protocol, if any, which was used to setup this tunnel.')
mplsTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al, Internet Draft <draft-ietf-mpls- rsvp-lsp-tunnel-07.txt>, August 2000., 2. Constraint-Based LSP Setup using LDP, Jamoussi, Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setDescription('Indicates the setup priority of this tunnel.')
mplsTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al, Internet Draft <draft-ietf-mpls- rsvp-lsp-tunnel-07.txt>, August 2000., 2. Constraint-Based LSP Setup using LDP, Jamoussi, Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setDescription('Indicates the holding priority for this tunnel.')
mplsTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 13), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("isComputed", 4), ("recordRoute", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al, Internet Draft <draft-ietf-mpls- rsvp-lsp-tunnel-07.txt>, August 2000.')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setDescription('This bitmask indicates optional session values for this tunnel. The following describes these bitfields: fastRerouteThis flag indicates that the any tunnel hop may choose to reroute this tunnel without tearing it down. This flag permits transit routers to use a local repair mechanism which may result in violation of the explicit routing of this tunnel. When a fault is detected on an adjacent downstream link or node, a transit router can reroute traffic for fast service restoration. mergingPermitted This flag permits transit routers to merge this session with other RSVP sessions for the purpose of reducing resource overhead on downstream transit routers, thereby providing better network scalability. isPersistent Indicates whether this tunnel should be restored automatically after a failure occurs. isPinned This flag indicates whether the loose- routed hops of this tunnel are to be pinned. isComputed This flag indicates whether the tunnel path is computed using a constraint-based routing algorithm based on the mplsTunnelHopTable entries. recordRoute This flag indicates whether or not the signaling protocol should remember the tunnel path after it has been signaled.')
mplsTunnelOwner = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("admin", 1), ("rsvp", 2), ("crldp", 3), ("policyAgent", 4), ("other", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOwner.setDescription('Indicates which protocol created and is responsible for managing this tunnel. Values rsvp(2) and crldp(3) should not be used at the head-end of a MPLS tunnel.')
mplsTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 15), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setDescription('Indicates that the local repair mechanism is in use to maintain this tunnel (usually in the face of an outage of the link it was previously routed over).')
mplsTunnelResourcePointer = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 16), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setDescription('This variable represents a pointer to the traffic parameter specification for this tunnel. This value may point at an entry in the mplsTunnelResourceEntry to indicate which mplsTunnelResourceEntry is to be assigned to this segment. This value may optionally point at an externally defined traffic parameter specification table. A value of zeroDotZero indicates best- effort treatment. By having the same value of this object, two or more segments can indicate resource sharing.')
mplsTunnelInstancePriority = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setDescription('This value indicates which priority, in descending order, with 0 indicating the lowest priority, within a group of tunnel instances. A group of tunnel instances is defined as a set of tunnels with the same mplsTunnelIndex in this table, but with a different mplsTunnelInstance. Tunnel group priorities are used to denote the priority at which a particular tunnel instance will supercede another. Instances of tunnels containing the same mplsTunnelInstancePriority will be used for load sharing.')
mplsTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 18), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setDescription('Index into the mplsTunnelHopTable entry that specifies the explicit route hops for this tunnel.')
mplsTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 19), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setDescription('Index into the mplsTunnelARHopTable entry that specifies the actual hops traversed by the tunnel.')
mplsTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 20), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setDescription('Index into the mplsTunnelCHopTable entry that specifies the computed hops traversed by the tunnel.')
mplsTunnelPrimaryInstance = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 21), MplsTunnelInstanceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setDescription('Specifies the instance index of the primary instance of this tunnel.')
mplsTunnelPrimaryTimeUp = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryTimeUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryTimeUp.setDescription('Specifies the total time the primary instance of this tunnel has been active. The primary instance of this tunnel is defined in mplsTunnelPrimaryInstance.')
mplsTunnelPathChanges = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPathChanges.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathChanges.setDescription('Specifies the number of times the paths has changed for this tunnel.')
mplsTunnelLastPathChange = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setDescription('Specifies the time since the last path change for this tunnel.')
mplsTunnelCreationTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 25), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCreationTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCreationTime.setDescription('Specifies the value of SysUpTime when the first instance of this tunnel came into existence.')
mplsTunnelStateTransitions = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setDescription('Specifies the number of times the state of this tunnel instance has changed.')
mplsTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 27), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP Tunnels, draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setDescription('A link satisfies the include-any constraint if and only if the constraint is zero, or the link and the constraint have a resource class in common.')
mplsTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 28), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP Tunnels, draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setDescription('A link satisfies the include-all constraint if and only if the link contains all of the adminstrative groups specified in the constraint.')
mplsTunnelExcludeAllAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 29), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP Tunnels, draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setDescription('A link satisfies the exclude-all constraint if and only if the link contains none of the adminstrative groups specifie in the constraint.')
mplsTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 30), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathInUse.setDescription('This value denotes the configured path that was chosen for this tunnel. This value reflects the secondary index into the TunnelHopTable. This path may not exactly match the one in the ARHopTable due to the fact that some CSPF modification may have taken place. See the ARHopTable for the actual path being taken by the tunnel. A value of zero denotes that no path is currently in use or available.')
mplsTunnelRole = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("head", 1), ("transit", 2), ("tail", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRole.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRole.setDescription('This value signifies the role that this tunnel entry/instance represents. This value MUST be set to head(1) at the originating point of the tunnel. This value MUST be set to transit(2) at transit points along the tunnel, if transit points are supported. This value MUST be set to tail(3) at the terminating point of the tunnel if tunnel tails are supported.')
mplsTunnelTotalUpTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 32), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setDescription('This value represents the aggregate up time for all instances of this tunnel, if available. If this value is unavailable, it MUST return a value of 0.')
mplsTunnelInstanceUpTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 33), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setDescription("This value identifies the total time that this tunnel instance's operStatus has been Up(1).")
mplsTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setDescription('Indicates the desired operational status of this tunnel.')
mplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOperStatus.setDescription('Indicates the actual operational status of this tunnel, which is typically but not limited to, a function of the state of individual segments of this tunnel.')
mplsTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 36), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsTunnelStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 37), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStorageType.setDescription('This variable indicates the storage type for this object.')
mplsTunnelHopListIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopListIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndexNext.setDescription('This object contains an appropriate value to be used for mplsTunnelHopListIndex when creating entries in the mplsTunnelHopTable. If the number of unassigned entries is exhausted, a retrival operation will return a value of 0. This object may also return a value of 0 when the LSR is unable to accept conceptual row creation, for example, if the mplsTunnelHopTable is implemented as read-only. To obtain the value of mplsTunnelHopListIndex for a new entry in the mplsTunnelHopTable, the manager issues a management protocol retrieval operation to obtain the current value of mplsTunnelHopIndex. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsTunnelHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 4), )
if mibBuilder.loadTexts: mplsTunnelHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTable.setDescription('The mplsTunnelHopTable is used to indicate the hops, strict or loose, for an MPLS tunnel defined in mplsTunnelTable, when it is established via signaling, for the outgoing direction of the tunnel. Each row in this table is indexed by mplsTunnelHopListIndex. Each row also has a secondary index mplsTunnelHopIndex corresponding to the next hop that this row corresponds to. The first row in the table is the first hop after the origination point of the tunnel. In case we want to specify a particular interface on the originating LSR of an outgoing tunnel by which we want packets to exit the LSR, we specify this as the first hop for this tunnel in mplsTunnelHopTable.')
mplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 4, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-MIB", "mplsPathOptionIndex"), (0, "MPLS-TE-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: mplsTunnelHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopEntry.setDescription('An entry in this table represents a tunnel hop. An entry is created by a network administrator for signaled ERLSP set up by an MPLS signaling protocol.')
mplsTunnelHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setDescription('Primary index into this table identifying a particular explicit route object.')
mplsPathOptionIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsPathOptionIndex.setStatus('current')
if mibBuilder.loadTexts: mplsPathOptionIndex.setDescription('Secondary index into this table identifying a particular group of hops representing a particular configured path. This is otherwise known as a path option.')
mplsTunnelHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 3), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndex.setDescription('Secondary index into this table identifying a particular hop.')
mplsTunnelHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3), ("lspid", 4))).clone('ipV4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 5), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setDescription('If mplsTunnelHopAddrType is set to ipV4(1), then this value will contain the IPv4 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setDescription("If mplsTunnelHopAddrType is ipV4(1), then the prefix length for this hop's IPv4 address is contained herein. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 7), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setDescription('If the mplsTunnelHopAddrType is set to ipV6(2), then this variable contains the IPv6 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setDescription("If mplsTunnelHopAddrType is set to ipV6(2), this value will contain the prefix length for this hop's IPv6 address. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setDescription('If mplsTunnelHopAddrType is set to asNumber(3), then this value will contain the AS number of this hop. This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
mplsTunnelHopLspId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 10), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopLspId.setDescription('If mplsTunnelHopAddrType is set to lspid(4), then this value will contain the LSPID of a tunnel of this hop. The present tunnel being configured is tunneled through this hop (using label stacking). This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
mplsTunnelHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopType.setDescription('Denotes whether this tunnel hop is routed in a strict or loose fashion.')
mplsTunnelHopRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsTunnelHopStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setDescription('This variable indicates the storage type for this object.')
mplsTunnelResourceIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setDescription('This object contains the next appropriate value to be used for mplsTunnelResourceIndex when creating entries in the mplsTunnelResourceTable. If the number of unassigned entries is exhausted, a retrival operation will return a value of 0. This object may also return a value of 0 when the LSR is unable to accept conceptual row creation, for example, if the mplsTunnelTable is implemented as read-only. To obtain the mplsTunnelResourceIndex value for a new entry, the manager must first issue a management protocol retrieval operation to obtain the current value of this object. The agent should modify the value to reflect the next unassigned index after each retrieval operation. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsTunnelResourceTable = MibTable((1, 3, 6, 1, 3, 95, 2, 6), )
if mibBuilder.loadTexts: mplsTunnelResourceTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceTable.setDescription('The mplsTunnelResourceTable allows a manager to specify which resources are desired for an MPLS tunnel. This table also allows several tunnels to point to a single entry in this table, implying that these tunnels should share resources.')
mplsTunnelResourceEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 6, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setDescription('An entry in this table represents a set of resources for an MPLS tunnel. An entry can be created by a network administrator or by an SNMP agent as instructed by any MPLS signaling protocol.')
mplsTunnelResourceIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setDescription('Uniquely identifies this row.')
mplsTunnelResourceMaxRate = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 2), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS Label Switch Router Management Information Base Using SMIv2, Internet Draft <draft-ietf-mpls- lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setDescription('The maximum rate in bits/second. Note that setting mplsTunnelResourceMaxRate, mplsTunnelResourceMeanRate, and mplsTunnelResourceMaxBurstSize to 0 indicates best- effort treatment. This object is copied to an instance of mplsTrafficParamMaxRate in mplsTrafficParamTable the OID of which is copied into the corresponding mplsInSegmentTrafficParamPtr.')
mplsTunnelResourceMeanRate = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 3), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS Label Switch Router Management Information Base Using SMIv2, Internet Draft <draft-ietf-mpls- lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setDescription('This object is copied into an instance of mplsTrafficParamMeanRate in the mplsTrafficParamTable. The OID of this table entry is then copied into the corresponding mplsInSegmentTrafficParamPtr. When resource allocation is performed as requested by this TSpec object, it is copied into an entry in mplsTrafficParamTable [LSRMIB]: mplsTunnelInMeanRate to mplsTrafficParamMeanRate. The OID of this entry is copied to mplsInSegmentTrafficParamPtr of the corresponding in-segment entry.')
mplsTunnelResourceMaxBurstSize = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS Label Switch Router Management Information Base Using SMIv2, Internet Draft <draft-ietf-mpls- lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setDescription('The maximum burst size in bytes. This object is copied to mplsInSegmentMaxBurstSize of the corresponding in-segment. When resource allocation is performed as requested by this TSpec object, it is copied into an entry in mplsTrafficParamTable [LSRMIB]: mplsTunnelInMaxBurstSize to mplsTrafficParamMaxBurstSize. The OID of this entry is copied to mplsInSegmentTrafficParamPtr of the corresponding in-segment entry.')
mplsTunnelResourceRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsTunnelResourceStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setDescription('This variable indicates the storage type for this object.')
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 7), )
if mibBuilder.loadTexts: mplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription('The mplsTunnelARHopTable is used to indicate the hops, strict or loose, for an MPLS tunnel defined in mplsTunnelTable, as reported by the MPLS signaling protocol, for the outgoing direction of the tunnel. Each row in this table is indexed by mplsTunnelARHopListIndex. Each row also has a secondary index mplsTunnelARHopIndex, corresponding to the next hop that this row corresponds to. The first row in the table is the first hop after the origination point of the tunnel. In case we want to specify a particular interface on the originating LSR of an outgoing tunnel by which we want packets to exit the LSR, we specify this as the first hop for this tunnel in mplsTunnelARHopTable. Please note that since the information necessary to build entries within this table are not provided by some MPLS signaling protocols, implementation of this table is optional. Furthermore, since the information in this table is actually provided by the MPLS signaling protocol after the path has been set-up, the entries in this table are provided only for observation, and hence, all variables in this table are accessible exclusively as read-only.')
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 7, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription('An entry in this table represents a tunnel hop. An entry is created by a network administrator for signaled ERLSP set up by an MPLS signaling protocol.')
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription('Primary index into this table identifying a particular recorded hop list.')
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription('Secondary index into this table identifying the particular hop.')
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelARHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 4), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setDescription('If mplsTunnelARHopAddrType is set to ipV4(1), then this value will contain the IPv4 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelARHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setDescription("If mplsTunnelARHopAddrType is ipV4(1), then the prefix length for this hop's IPv4 address is contained herein. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelARHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setDescription('If the mplsTunnelARHopAddrType is set to ipV6(2), then this variable contains the IPv6 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelARHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setDescription("If mplsTunnelARHopAddrType is set to ipV6(2), this value will contain the prefix length for this hop's IPv6 address. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelARHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setDescription('If mplsTunnelARHopAddrType is set to asNumber(3), then this value will contain the AS number of this hop. This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
mplsTunnelARHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopType.setDescription('Denotes whether this is tunnel hop is routed in a strict or loose fashion.')
mplsTunnelCHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 8), )
if mibBuilder.loadTexts: mplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTable.setDescription('The mplsTunnelCHopTable is used to indicate the hops, strict or loose, for an MPLS tunnel defined in mplsTunnelTable, as computed by a constraint- based routing protocol, based on the mplsTunnelHopTable for the outgoing direction of the tunnel. Each row in this table is indexed by mplsTunnelCHopListIndex. Each row also has a secondary index mplsTunnelCHopIndex, corresponding to the next hop that this row corresponds to. The first row in the table is the first hop after the origination point of the tunnel. In case we want to specify a particular interface on the originating LSR of an outgoing tunnel by which we want packets to exit the LSR, we specify this as the first hop for this tunnel in mplsTunnelCHopTable. Please note that since the information necessary to build entries within this table may not be supported by some LSRs, implementation of this table is optional. Furthermore, since the information in this table is actually provided by routing protocol after the path has been computed, the entries in this table are provided only for observation, and hence, all variables in this table are accessible exclusively as read-only.')
mplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 8, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelCHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setDescription('An entry in this table represents a tunnel hop. An entry in this table is created by a constraint- based routing protocol based on the hops specified in the corresponding mplsTunnelHopTable.')
mplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a particular computed hop list.')
mplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setDescription('Secondary index into this table identifying the particular hop.')
mplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelCHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 4), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv4Addr.setDescription('If mplsTunnelCHopAddrType is set to ipV4(1), then this value will contain the IPv4 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelCHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv4PrefixLen.setDescription("If mplsTunnelCHopAddrType is ipV4(1), then the prefix length for this hop's IPv4 address is contained herein. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelCHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv6Addr.setDescription('If the mplsTunnelCHopAddrType is set to ipV6(2), then this variable contains the IPv6 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
mplsTunnelCHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv6PrefixLen.setDescription("If mplsTunnelCHopAddrType is set to ipV6(2), this value will contain the prefix length for this hop's IPv6 address. This object is otherwise insignificant and should contain a value of 0.")
mplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setDescription('If mplsTunnelCHopAddrType is set to asNumber(3), then this value will contain the AS number of this hop. This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
mplsTunnelCHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopType.setDescription('Denotes whether this is tunnel hop is routed in a strict or loose fashion.')
mplsTunnelPerfTable = MibTable((1, 3, 6, 1, 3, 95, 2, 9), )
if mibBuilder.loadTexts: mplsTunnelPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfTable.setDescription('This table provides per-tunnel MPLS performance information.')
mplsTunnelPerfEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 9, 1), )
mplsTunnelEntry.registerAugmentions(("MPLS-TE-MIB", "mplsTunnelPerfEntry"))
mplsTunnelPerfEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setDescription('An entry in this table is created by the LSR for every tunnel. Its is an extension to mplsTunnelEntry.')
mplsTunnelPerfPackets = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setDescription('Number of packets forwarded by the tunnel.')
mplsTunnelPerfHCPackets = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setDescription('High capacity counter for number of packets forwarded by the tunnel.')
mplsTunnelPerfErrors = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setDescription('Number of errored packets.')
mplsTunnelPerfBytes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setDescription('Number of bytes forwarded by the tunnel.')
mplsTunnelPerfHCBytes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setDescription('High capacity counter for number of bytes forwarded by the tunnel.')
mplsTunnelTrapEnable = MibScalar((1, 3, 6, 1, 3, 95, 2, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setDescription('If this object is true, then it enables the generation of mplsTunnelUp and mplsTunnelDown traps, otherwise these traps are not emitted.')
mplsTunnelUp = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUp.setDescription('This notification is generated when a mplsTunnelOperStatus object for one of the configured tunnels is about to leave the down state and transition into some other state (but not into the notPresent state). This other state is indicated by the included value of mplsTunnelOperStatus.')
mplsTunnelDown = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDown.setDescription('This notification is generated when a mplsTunnelOperStatus object for one of the configured tunnels is about to enter the down state from some other state (but not from the notPresent state). This other state is indicated by the included value of mplsTunnelOperStatus.')
mplsTunnelRerouted = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelRerouted.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRerouted.setDescription('This notification is generated when a tunnel is rerouted or re-optimized. If the Actual Path is used, then this object MAY contain the new path for this tunnel some time after this trap is issued by the agent.')
mplsTeGroups = MibIdentifier((1, 3, 6, 1, 3, 95, 4, 1))
mplsTeCompliances = MibIdentifier((1, 3, 6, 1, 3, 95, 4, 2))
mplsTeModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 95, 4, 2, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelGroup"), ("MPLS-TE-MIB", "mplsTunnelScalarGroup"), ("MPLS-TE-MIB", "mplsTunnelManualGroup"), ("MPLS-TE-MIB", "mplsTunnelSignaledGroup"), ("MPLS-TE-MIB", "mplsTunnelIsNotIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelIsIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelOptionalGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeModuleCompliance = mplsTeModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsTeModuleCompliance.setDescription('Compliance statement for agents that support the MPLS TE MIB.')
mplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndexNext"), ("MPLS-TE-MIB", "mplsTunnelName"), ("MPLS-TE-MIB", "mplsTunnelDescr"), ("MPLS-TE-MIB", "mplsTunnelOwner"), ("MPLS-TE-MIB", "mplsTunnelXCPointer"), ("MPLS-TE-MIB", "mplsTunnelIfIndex"), ("MPLS-TE-MIB", "mplsTunnelHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelARHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelCHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-MIB", "mplsTunnelRowStatus"), ("MPLS-TE-MIB", "mplsTunnelTrapEnable"), ("MPLS-TE-MIB", "mplsTunnelStorageType"), ("MPLS-TE-MIB", "mplsTunnelConfigured"), ("MPLS-TE-MIB", "mplsTunnelActive"), ("MPLS-TE-MIB", "mplsTunnelPrimaryInstance"), ("MPLS-TE-MIB", "mplsTunnelPrimaryTimeUp"), ("MPLS-TE-MIB", "mplsTunnelPathChanges"), ("MPLS-TE-MIB", "mplsTunnelLastPathChange"), ("MPLS-TE-MIB", "mplsTunnelCreationTime"), ("MPLS-TE-MIB", "mplsTunnelStateTransitions"), ("MPLS-TE-MIB", "mplsTunnelEgressLSRId"), ("MPLS-TE-MIB", "mplsTunnelIncludeAnyAffinity"), ("MPLS-TE-MIB", "mplsTunnelIncludeAllAffinity"), ("MPLS-TE-MIB", "mplsTunnelExcludeAllAffinity"), ("MPLS-TE-MIB", "mplsTunnelPerfPackets"), ("MPLS-TE-MIB", "mplsTunnelPerfHCPackets"), ("MPLS-TE-MIB", "mplsTunnelPerfErrors"), ("MPLS-TE-MIB", "mplsTunnelPerfBytes"), ("MPLS-TE-MIB", "mplsTunnelPerfHCBytes"), ("MPLS-TE-MIB", "mplsTunnelResourcePointer"), ("MPLS-TE-MIB", "mplsTunnelInstancePriority"), ("MPLS-TE-MIB", "mplsTunnelPathInUse"), ("MPLS-TE-MIB", "mplsTunnelRole"), ("MPLS-TE-MIB", "mplsTunnelTotalUpTime"), ("MPLS-TE-MIB", "mplsTunnelInstanceUpTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelGroup = mplsTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGroup.setDescription('Necessary, but not sufficient, set of objects to implement tunnels. In addition, depending on the type of the tunnels supported (for example, manually configured or signaled, persistent or non- persistent, etc.), the following other groups defined below are mandatory: mplsTunnelManualGroup and/or mplsTunnelSignaledGroup, mplsTunnelIsNotIntfcGroup and/or mplsTunnelIsIntfcGroup.')
mplsTunnelManualGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelSignallingProto"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelManualGroup = mplsTunnelManualGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManualGroup.setDescription('Object(s) needed to implement manually configured tunnels.')
mplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelSetupPrio"), ("MPLS-TE-MIB", "mplsTunnelHoldingPrio"), ("MPLS-TE-MIB", "mplsTunnelSignallingProto"), ("MPLS-TE-MIB", "mplsTunnelLocalProtectInUse"), ("MPLS-TE-MIB", "mplsTunnelSessionAttributes"), ("MPLS-TE-MIB", "mplsTunnelHopListIndexNext"), ("MPLS-TE-MIB", "mplsTunnelHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelHopLspId"), ("MPLS-TE-MIB", "mplsTunnelHopType"), ("MPLS-TE-MIB", "mplsTunnelHopRowStatus"), ("MPLS-TE-MIB", "mplsTunnelHopStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelSignaledGroup = mplsTunnelSignaledGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignaledGroup.setDescription('Object needed to implement signaled tunnels.')
mplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 4)).setObjects(("MPLS-TE-MIB", "mplsTunnelConfigured"), ("MPLS-TE-MIB", "mplsTunnelActive"), ("MPLS-TE-MIB", "mplsTunnelTEDistProto"), ("MPLS-TE-MIB", "mplsTunnelMaxHops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelScalarGroup = mplsTunnelScalarGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelScalarGroup.setDescription('Scalar object needed to implement MPLS tunnels.')
mplsTunnelIsIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 5)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsIntfcGroup = mplsTunnelIsIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIntfcGroup.setDescription('Objects needed to implement tunnels that are interfaces.')
mplsTunnelIsNotIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 6)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsNotIntfcGroup = mplsTunnelIsNotIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsNotIntfcGroup.setDescription('Objects needed to implement tunnels that are not interfaces.')
mplsTunnelOptionalGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 7)).setObjects(("MPLS-TE-MIB", "mplsTunnelResourceIndexNext"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMeanRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxBurstSize"), ("MPLS-TE-MIB", "mplsTunnelResourceRowStatus"), ("MPLS-TE-MIB", "mplsTunnelResourceStorageType"), ("MPLS-TE-MIB", "mplsTunnelARHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelARHopType"), ("MPLS-TE-MIB", "mplsTunnelCHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelCHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelCHopType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelOptionalGroup = mplsTunnelOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOptionalGroup.setDescription('The objects in this group are optional.')
mplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 95, 4, 1, 8)).setObjects(("MPLS-TE-MIB", "mplsTunnelUp"), ("MPLS-TE-MIB", "mplsTunnelDown"), ("MPLS-TE-MIB", "mplsTunnelRerouted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeNotificationGroup = mplsTeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTeNotificationGroup.setDescription('Set of notifications implemented in this module. None is mandatory.')
mibBuilder.exportSymbols("MPLS-TE-MIB", mplsTunnelResourceMaxBurstSize=mplsTunnelResourceMaxBurstSize, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex, mplsTunnelHopIpv6Addr=mplsTunnelHopIpv6Addr, MplsPathIndexOrZero=MplsPathIndexOrZero, mplsTunnelIndexNext=mplsTunnelIndexNext, mplsTunnelTrapEnable=mplsTunnelTrapEnable, mplsTunnelIncludeAllAffinity=mplsTunnelIncludeAllAffinity, mplsTunnelHopLspId=mplsTunnelHopLspId, mplsTeModuleCompliance=mplsTeModuleCompliance, mplsTunnelSignallingProto=mplsTunnelSignallingProto, mplsTunnelHopEntry=mplsTunnelHopEntry, mplsTunnelRerouted=mplsTunnelRerouted, mplsTunnelCHopListIndex=mplsTunnelCHopListIndex, mplsTunnelIfIndex=mplsTunnelIfIndex, mplsTunnelEntry=mplsTunnelEntry, mplsTunnelActive=mplsTunnelActive, mplsTunnelHopListIndexNext=mplsTunnelHopListIndexNext, mplsTunnelResourceIndex=mplsTunnelResourceIndex, mplsTunnelPerfPackets=mplsTunnelPerfPackets, mplsTunnelTEDistProto=mplsTunnelTEDistProto, mplsTunnelOwner=mplsTunnelOwner, mplsTunnelHopRowStatus=mplsTunnelHopRowStatus, mplsTunnelEgressLSRId=mplsTunnelEgressLSRId, mplsTunnelXCPointer=mplsTunnelXCPointer, mplsTunnelHopStorageType=mplsTunnelHopStorageType, mplsTunnelLastPathChange=mplsTunnelLastPathChange, mplsTunnelPrimaryInstance=mplsTunnelPrimaryInstance, mplsTunnelCreationTime=mplsTunnelCreationTime, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsTunnelPerfHCPackets=mplsTunnelPerfHCPackets, MplsTunnelInstanceIndex=MplsTunnelInstanceIndex, mplsTunnelHopTable=mplsTunnelHopTable, mplsTunnelInstanceUpTime=mplsTunnelInstanceUpTime, mplsTunnelResourceStorageType=mplsTunnelResourceStorageType, mplsTunnelInstance=mplsTunnelInstance, mplsTeNotificationGroup=mplsTeNotificationGroup, PYSNMP_MODULE_ID=mplsTeMIB, mplsTeNotifications=mplsTeNotifications, mplsTunnelGroup=mplsTunnelGroup, mplsTunnelSetupPrio=mplsTunnelSetupPrio, mplsTunnelCHopIpv4PrefixLen=mplsTunnelCHopIpv4PrefixLen, mplsTunnelCHopIpv6Addr=mplsTunnelCHopIpv6Addr, MplsPathIndex=MplsPathIndex, mplsTunnelCHopIpv6PrefixLen=mplsTunnelCHopIpv6PrefixLen, mplsTunnelARHopIpv6Addr=mplsTunnelARHopIpv6Addr, mplsTunnelHopTableIndex=mplsTunnelHopTableIndex, mplsTeGroups=mplsTeGroups, mplsTunnelInstancePriority=mplsTunnelInstancePriority, mplsTunnelLocalProtectInUse=mplsTunnelLocalProtectInUse, mplsTunnelName=mplsTunnelName, mplsTunnelStorageType=mplsTunnelStorageType, mplsTunnelARHopIpv4Addr=mplsTunnelARHopIpv4Addr, mplsTunnelARHopIpv6PrefixLen=mplsTunnelARHopIpv6PrefixLen, mplsTunnelSessionAttributes=mplsTunnelSessionAttributes, mplsTunnelResourceRowStatus=mplsTunnelResourceRowStatus, mplsTunnelUp=mplsTunnelUp, mplsTunnelCHopIpv4Addr=mplsTunnelCHopIpv4Addr, MplsLsrId=MplsLsrId, mplsTunnelRole=mplsTunnelRole, mplsTunnelHopListIndex=mplsTunnelHopListIndex, mplsTeScalars=mplsTeScalars, mplsTunnelARHopIpv4PrefixLen=mplsTunnelARHopIpv4PrefixLen, mplsTeMIB=mplsTeMIB, mplsTunnelScalarGroup=mplsTunnelScalarGroup, mplsTunnelPerfBytes=mplsTunnelPerfBytes, mplsTunnelDown=mplsTunnelDown, mplsTunnelIndex=mplsTunnelIndex, mplsTunnelTable=mplsTunnelTable, mplsTunnelCHopEntry=mplsTunnelCHopEntry, mplsTeNotifyPrefix=mplsTeNotifyPrefix, mplsTunnelTotalUpTime=mplsTunnelTotalUpTime, mplsTunnelResourceTable=mplsTunnelResourceTable, mplsTunnelHoldingPrio=mplsTunnelHoldingPrio, MplsTunnelIndex=MplsTunnelIndex, mplsTunnelCHopAsNumber=mplsTunnelCHopAsNumber, mplsTunnelPerfErrors=mplsTunnelPerfErrors, mplsTunnelCHopTableIndex=mplsTunnelCHopTableIndex, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsTunnelPerfEntry=mplsTunnelPerfEntry, mplsTunnelResourceMeanRate=mplsTunnelResourceMeanRate, mplsTunnelResourceIndexNext=mplsTunnelResourceIndexNext, mplsTunnelHopIpv6PrefixLen=mplsTunnelHopIpv6PrefixLen, mplsTunnelResourceMaxRate=mplsTunnelResourceMaxRate, mplsTunnelPathChanges=mplsTunnelPathChanges, mplsTunnelExcludeAllAffinity=mplsTunnelExcludeAllAffinity, mplsTunnelResourceEntry=mplsTunnelResourceEntry, mplsTunnelHopIpv4PrefixLen=mplsTunnelHopIpv4PrefixLen, mplsTunnelARHopAsNumber=mplsTunnelARHopAsNumber, mplsTunnelIsIf=mplsTunnelIsIf, mplsTunnelHopIndex=mplsTunnelHopIndex, mplsTunnelPerfTable=mplsTunnelPerfTable, mplsTunnelHopAddrType=mplsTunnelHopAddrType, mplsTunnelDescr=mplsTunnelDescr, mplsTunnelARHopTable=mplsTunnelARHopTable, mplsTunnelPerfHCBytes=mplsTunnelPerfHCBytes, mplsTeCompliances=mplsTeCompliances, mplsTunnelAdminStatus=mplsTunnelAdminStatus, mplsTunnelCHopType=mplsTunnelCHopType, mplsTeConformance=mplsTeConformance, mplsTunnelIncludeAnyAffinity=mplsTunnelIncludeAnyAffinity, mplsTunnelARHopType=mplsTunnelARHopType, mplsTunnelPrimaryTimeUp=mplsTunnelPrimaryTimeUp, mplsTunnelResourcePointer=mplsTunnelResourcePointer, mplsTunnelStateTransitions=mplsTunnelStateTransitions, mplsPathOptionIndex=mplsPathOptionIndex, mplsTunnelCHopAddrType=mplsTunnelCHopAddrType, mplsTunnelHopIpv4Addr=mplsTunnelHopIpv4Addr, mplsTunnelOptionalGroup=mplsTunnelOptionalGroup, mplsTunnelRowStatus=mplsTunnelRowStatus, mplsTunnelIngressLSRId=mplsTunnelIngressLSRId, mplsTunnelHopAsNumber=mplsTunnelHopAsNumber, mplsTunnelIsIntfcGroup=mplsTunnelIsIntfcGroup, mplsTunnelPathInUse=mplsTunnelPathInUse, mplsTunnelARHopTableIndex=mplsTunnelARHopTableIndex, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsTunnelOperStatus=mplsTunnelOperStatus, mplsTunnelCHopTable=mplsTunnelCHopTable, mplsTeObjects=mplsTeObjects, mplsTunnelIsNotIntfcGroup=mplsTunnelIsNotIntfcGroup, mplsTunnelMaxHops=mplsTunnelMaxHops, mplsTunnelHopType=mplsTunnelHopType, mplsTunnelSignaledGroup=mplsTunnelSignaledGroup, mplsTunnelCHopIndex=mplsTunnelCHopIndex, mplsTunnelManualGroup=mplsTunnelManualGroup, mplsTunnelConfigured=mplsTunnelConfigured)

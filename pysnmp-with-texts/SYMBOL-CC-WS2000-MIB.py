#
# PySNMP MIB module SYMBOL-CC-WS2000-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYMBOL-CC-WS2000-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:13:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
enterprises, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Bits, MibIdentifier, Counter64, iso, Unsigned32, ObjectIdentity, IpAddress, Gauge32, NotificationType, ModuleIdentity, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Bits", "MibIdentifier", "Counter64", "iso", "Unsigned32", "ObjectIdentity", "IpAddress", "Gauge32", "NotificationType", "ModuleIdentity", "TimeTicks", "Counter32")
DisplayString, TruthValue, TextualConvention, TestAndIncr, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention", "TestAndIncr", "PhysAddress")
moduleid = ModuleIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 1))
moduleid.setRevisions(('2010-04-24 09:37', '2009-12-30 13:25', '2004-12-10 16:49', '2004-10-28 16:32', '2004-09-08 12:07', '2004-02-04 15:32', '2004-01-06 00:00', '2003-12-11 01:00', '2003-12-11 00:00', '2003-12-02 00:00', '2003-11-26 00:00', '2003-11-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: moduleid.setRevisionsDescriptions(('DNS Relay Mode added', 'ccLoadFw and ccLoadCfg modified to add SFTP support', '09a00: Initial clean-up for WS2000 v2.0 release.', '08a43: Final clean-up for WS2000 v1.5 release candidate: Adopted new mib versioning scheme. Details can be found in the description of ccIdMibVersion. ', '8a: Final clean-up for WS2000 v1.5 beta release: Added RF utilization, efficiency & health and system stats at the Mu, Portal, Wlan and Switch level. Enabled config files up/down via TFTP Added 4 static and 4 stats traps', "7a: Final clean-up for WS2000 v1.0 release: Removed -07A from MIB name, (can't chg after MIB locked). Rename ccPortalType to ccPortalRadioType. New RadioType; used in ccPortalRadioType & ccMuRadioType. Moved ccAp: Name, Location, & LastReset to ccPortal_. Delete ccAssociation: LastUnAssociate, CountUnAssociates. Change ccMuSymbolRogueApEna from int to TruthValue. Change ccPortalLastReason & ccMuLastReason: int to enum. Some items OIDs changed. Locked MIB after these chgs; (no prior diffs possible); all chgs after this shall be backward compatible. ", '6a: Change a few items from RW to RO. Added ranges to all RW values. Added descriptions to all items. Some items OIDs changed. ', '5a: First release of WS2000 MIB (aside from development team). ', '4a: Forth preliminary draft of WS2000 MIB. ', '3a: Third preliminary draft of WS2000 MIB. ', '2a: Second preliminary draft of WS2000 MIB. ', '1a: First preliminary draft of WS2000 MIB. MIB naming include 2-digits & 1-letter; digits increase for substantive chgs; letter chgs for non-substantive chgs: -- chgs to comments -- chgs to descriptions -- any other chg that person with MIB browser could not detect. ',))
if mibBuilder.loadTexts: moduleid.setLastUpdated('201004242137Z')
if mibBuilder.loadTexts: moduleid.setOrganization('Symbol WSD (Wireless Infrastructure Division, San Jose)')
if mibBuilder.loadTexts: moduleid.setContactInfo('Carl Mower cmower@symbol.com')
if mibBuilder.loadTexts: moduleid.setDescription(' ')
class SinglePointer(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class MultiPointer63(Bits):
    namedValues = NamedValues(("null", 0), ("referToEntry001", 1), ("referToEntry002", 2), ("referToEntry003", 3), ("referToEntry004", 4), ("referToEntry005", 5), ("referToEntry006", 6), ("referToEntry007", 7), ("referToEntry008", 8), ("referToEntry009", 9), ("referToEntry010", 10), ("referToEntry011", 11), ("referToEntry012", 12), ("referToEntry013", 13), ("referToEntry014", 14), ("referToEntry015", 15), ("referToEntry016", 16), ("referToEntry017", 17), ("referToEntry018", 18), ("referToEntry019", 19), ("referToEntry020", 20), ("referToEntry021", 21), ("referToEntry022", 22), ("referToEntry023", 23), ("referToEntry024", 24), ("referToEntry025", 25), ("referToEntry026", 26), ("referToEntry027", 27), ("referToEntry028", 28), ("referToEntry029", 29), ("referToEntry030", 30), ("referToEntry031", 31), ("referToEntry032", 32), ("referToEntry033", 33), ("referToEntry034", 34), ("referToEntry035", 35), ("referToEntry036", 36), ("referToEntry037", 37), ("referToEntry038", 38), ("referToEntry039", 39), ("referToEntry040", 40), ("referToEntry041", 41), ("referToEntry042", 42), ("referToEntry043", 43), ("referToEntry044", 44), ("referToEntry045", 45), ("referToEntry046", 46), ("referToEntry047", 47), ("referToEntry048", 48), ("referToEntry049", 49), ("referToEntry050", 50), ("referToEntry051", 51), ("referToEntry052", 52), ("referToEntry053", 53), ("referToEntry054", 54), ("referToEntry055", 55), ("referToEntry056", 56), ("referToEntry057", 57), ("referToEntry058", 58), ("referToEntry059", 59), ("referToEntry060", 60), ("referToEntry061", 61), ("referToEntry062", 62), ("referToEntry063", 63))

class MultiPointer255(Bits):
    namedValues = NamedValues(("null", 0), ("referToEntry001", 1), ("referToEntry002", 2), ("referToEntry003", 3), ("referToEntry004", 4), ("referToEntry005", 5), ("referToEntry006", 6), ("referToEntry007", 7), ("referToEntry008", 8), ("referToEntry009", 9), ("referToEntry010", 10), ("referToEntry011", 11), ("referToEntry012", 12), ("referToEntry013", 13), ("referToEntry014", 14), ("referToEntry015", 15), ("referToEntry016", 16), ("referToEntry017", 17), ("referToEntry018", 18), ("referToEntry019", 19), ("referToEntry020", 20), ("referToEntry021", 21), ("referToEntry022", 22), ("referToEntry023", 23), ("referToEntry024", 24), ("referToEntry025", 25), ("referToEntry026", 26), ("referToEntry027", 27), ("referToEntry028", 28), ("referToEntry029", 29), ("referToEntry030", 30), ("referToEntry031", 31), ("referToEntry032", 32), ("referToEntry033", 33), ("referToEntry034", 34), ("referToEntry035", 35), ("referToEntry036", 36), ("referToEntry037", 37), ("referToEntry038", 38), ("referToEntry039", 39), ("referToEntry040", 40), ("referToEntry041", 41), ("referToEntry042", 42), ("referToEntry043", 43), ("referToEntry044", 44), ("referToEntry045", 45), ("referToEntry046", 46), ("referToEntry047", 47), ("referToEntry048", 48), ("referToEntry049", 49), ("referToEntry050", 50), ("referToEntry051", 51), ("referToEntry052", 52), ("referToEntry053", 53), ("referToEntry054", 54), ("referToEntry055", 55), ("referToEntry056", 56), ("referToEntry057", 57), ("referToEntry058", 58), ("referToEntry059", 59), ("referToEntry060", 60), ("referToEntry061", 61), ("referToEntry062", 62), ("referToEntry063", 63), ("referToEntry064", 64), ("referToEntry065", 65), ("referToEntry066", 66), ("referToEntry067", 67), ("referToEntry068", 68), ("referToEntry069", 69), ("referToEntry070", 70), ("referToEntry071", 71), ("referToEntry072", 72), ("referToEntry073", 73), ("referToEntry074", 74), ("referToEntry075", 75), ("referToEntry076", 76), ("referToEntry077", 77), ("referToEntry078", 78), ("referToEntry079", 79), ("referToEntry080", 80), ("referToEntry081", 81), ("referToEntry082", 82), ("referToEntry083", 83), ("referToEntry084", 84), ("referToEntry085", 85), ("referToEntry086", 86), ("referToEntry087", 87), ("referToEntry088", 88), ("referToEntry089", 89), ("referToEntry090", 90), ("referToEntry091", 91), ("referToEntry092", 92), ("referToEntry093", 93), ("referToEntry094", 94), ("referToEntry095", 95), ("referToEntry096", 96), ("referToEntry097", 97), ("referToEntry098", 98), ("referToEntry099", 99), ("referToEntry100", 100), ("referToEntry101", 101), ("referToEntry102", 102), ("referToEntry103", 103), ("referToEntry104", 104), ("referToEntry105", 105), ("referToEntry106", 106), ("referToEntry107", 107), ("referToEntry108", 108), ("referToEntry109", 109), ("referToEntry110", 110), ("referToEntry111", 111), ("referToEntry112", 112), ("referToEntry113", 113), ("referToEntry114", 114), ("referToEntry115", 115), ("referToEntry116", 116), ("referToEntry117", 117), ("referToEntry118", 118), ("referToEntry119", 119), ("referToEntry120", 120), ("referToEntry121", 121), ("referToEntry122", 122), ("referToEntry123", 123), ("referToEntry124", 124), ("referToEntry125", 125), ("referToEntry126", 126), ("referToEntry127", 127), ("referToEntry128", 128), ("referToEntry129", 129), ("referToEntry130", 130), ("referToEntry131", 131), ("referToEntry132", 132), ("referToEntry133", 133), ("referToEntry134", 134), ("referToEntry135", 135), ("referToEntry136", 136), ("referToEntry137", 137), ("referToEntry138", 138), ("referToEntry139", 139), ("referToEntry140", 140), ("referToEntry141", 141), ("referToEntry142", 142), ("referToEntry143", 143), ("referToEntry144", 144), ("referToEntry145", 145), ("referToEntry146", 146), ("referToEntry147", 147), ("referToEntry148", 148), ("referToEntry149", 149), ("referToEntry150", 150), ("referToEntry151", 151), ("referToEntry152", 152), ("referToEntry153", 153), ("referToEntry154", 154), ("referToEntry155", 155), ("referToEntry156", 156), ("referToEntry157", 157), ("referToEntry158", 158), ("referToEntry159", 159), ("referToEntry160", 160), ("referToEntry161", 161), ("referToEntry162", 162), ("referToEntry163", 163), ("referToEntry164", 164), ("referToEntry165", 165), ("referToEntry166", 166), ("referToEntry167", 167), ("referToEntry168", 168), ("referToEntry169", 169), ("referToEntry170", 170), ("referToEntry171", 171), ("referToEntry172", 172), ("referToEntry173", 173), ("referToEntry174", 174), ("referToEntry175", 175), ("referToEntry176", 176), ("referToEntry177", 177), ("referToEntry178", 178), ("referToEntry179", 179), ("referToEntry180", 180), ("referToEntry181", 181), ("referToEntry182", 182), ("referToEntry183", 183), ("referToEntry184", 184), ("referToEntry185", 185), ("referToEntry186", 186), ("referToEntry187", 187), ("referToEntry188", 188), ("referToEntry189", 189), ("referToEntry190", 190), ("referToEntry191", 191), ("referToEntry192", 192), ("referToEntry193", 193), ("referToEntry194", 194), ("referToEntry195", 195), ("referToEntry196", 196), ("referToEntry197", 197), ("referToEntry198", 198), ("referToEntry199", 199), ("referToEntry200", 200), ("referToEntry201", 201), ("referToEntry202", 202), ("referToEntry203", 203), ("referToEntry204", 204), ("referToEntry205", 205), ("referToEntry206", 206), ("referToEntry207", 207), ("referToEntry208", 208), ("referToEntry209", 209), ("referToEntry210", 210), ("referToEntry211", 211), ("referToEntry212", 212), ("referToEntry213", 213), ("referToEntry214", 214), ("referToEntry215", 215), ("referToEntry216", 216), ("referToEntry217", 217), ("referToEntry218", 218), ("referToEntry219", 219), ("referToEntry220", 220), ("referToEntry221", 221), ("referToEntry222", 222), ("referToEntry223", 223), ("referToEntry224", 224), ("referToEntry225", 225), ("referToEntry226", 226), ("referToEntry227", 227), ("referToEntry228", 228), ("referToEntry229", 229), ("referToEntry230", 230), ("referToEntry231", 231), ("referToEntry232", 232), ("referToEntry233", 233), ("referToEntry234", 234), ("referToEntry235", 235), ("referToEntry236", 236), ("referToEntry237", 237), ("referToEntry238", 238), ("referToEntry239", 239), ("referToEntry240", 240), ("referToEntry241", 241), ("referToEntry242", 242), ("referToEntry243", 243), ("referToEntry244", 244), ("referToEntry245", 245), ("referToEntry246", 246), ("referToEntry247", 247), ("referToEntry248", 248), ("referToEntry249", 249), ("referToEntry250", 250), ("referToEntry251", 251), ("referToEntry252", 252), ("referToEntry253", 253), ("referToEntry254", 254)) + NamedValues(("referToEntry255", 255))

class DoActionNow(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("doActionRightNow", 1), ("idleState", 2))

class RadioType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("radio802dot11A", 1), ("radio802dot11B", 2), ("radio802dot11G", 3), ("radio802dot11FH", 4))

class Password(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class StaticRowEnable(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enable", 1), ("disable", 2))

class PartsPer10k(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 10000)

class ScaleBy100(Unsigned32):
    pass

class AbbrevRowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(4, 6))
    namedValues = NamedValues(("createAndGo", 4), ("destroy", 6))

class DoActionShowProgress(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("doActionRightNow", 1), ("idleState", 2))

class HexPassword(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class TransmitRate(Bits):
    namedValues = NamedValues(("null", 0), ("rate1Mb", 1), ("rate2Mb", 2), ("rate5pt5Mb", 3), ("rate6Mb", 4), ("rate9Mb", 5), ("rate11Mb", 6), ("rate12Mb", 7), ("rate18Mb", 8), ("rate22Mb", 9), ("rate24Mb", 10), ("rate36Mb", 11), ("rate48Mb", 12), ("rate54Mb", 13))

class RowStatus(TextualConvention, Integer32):
    description = "The RowStatus textual convention is used to manage the creation and deletion of conceptual rows, and is used as the value of the SYNTAX clause for the status column of a conceptual row (as described in Section 7.7.1 of [2].) The status column has six defined values: - `active', which indicates that the conceptual row is available for use by the managed device; - `notInService', which indicates that the conceptual row exists in the agent, but is unavailable for use by the managed device (see NOTE below); - `notReady', which indicates that the conceptual row exists in the agent, but is missing information necessary in order to be available for use by the managed device; - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device; - `createAndWait', which is supplied by a management station wishing to create a new instance of a conceptual row (but not make it available for use by the managed device); and, - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Whereas five of the six values (all except `notReady') may be specified in a management protocol set operation, only three values will be returned in response to a management protocol retrieval operation: `notReady', `notInService' or `active'. That is, when queried, an existing conceptual row has only three states: it is either available for use by the managed device (the status column has value `active'); it is not available for use by the managed device, though the agent has sufficient information to make it so (the status column has value `notInService'); or, it is not available for use by the managed device, and an attempt to make it so would fail because the agent has insufficient information (the state column has value `notReady'). NOTE WELL This textual convention may be used for a MIB table, irrespective of whether the values of that table's conceptual rows are able to be modified while it is active, or whether its conceptual rows must be taken out of service in order to be modified. That is, it is the responsibility of the DESCRIPTION clause of the status column to specify whether the status column must not be `active' in order for the value of some other column of the same conceptual row to be modified. If such a specification is made, affected columns may be changed by an SNMP set PDU if the RowStatus would not be equal to `active' either immediately before or after processing the PDU. In other words, if the PDU also contained a varbind that would change the RowStatus value, the column in question may be changed if the RowStatus was not equal to `active' as the PDU was received, or if the varbind sets the status to a value other than 'active'. Also note that whenever any elements of a row exist, the RowStatus column must also exist. To summarize the effect of having a conceptual row with a status column having a SYNTAX clause value of RowStatus, consider the following state diagram: STATE +--------------+-----------+-------------+------------- | A | B | C | D | |status col.|status column| |status column | is | is |status column ACTION |does not exist| notReady | notInService| is active --------------+--------------+-----------+-------------+------------- set status |noError ->D|inconsist- |inconsistent-|inconsistent- column to | or | entValue| Value| Value createAndGo |inconsistent- | | | | Value| | | --------------+--------------+-----------+-------------+------------- set status |noError see 1|inconsist- |inconsistent-|inconsistent- column to | or | entValue| Value| Value createAndWait |wrongValue | | | --------------+--------------+-----------+-------------+------------- set status |inconsistent- |inconsist- |noError |noError column to | Value| entValue| | active | | | | | | or | | | | | | | |see 2 ->D| ->D| ->D --------------+--------------+-----------+-------------+------------- set status |inconsistent- |inconsist- |noError |noError ->C column to | Value| entValue| | notInService | | | | | | or | | or | | | | | |see 3 ->C| ->C|wrongValue --------------+--------------+-----------+-------------+------------- set status |noError |noError |noError |noError column to | | | | destroy | ->A| ->A| ->A| ->A --------------+--------------+-----------+-------------+------------- set any other |see 4 |noError |noError |see 5 column to some| | | | value | | see 1| ->C| ->D --------------+--------------+-----------+-------------+------------- (1) goto B or C, depending on information available to the agent. (2) if other variable bindings included in the same PDU, provide values for all columns which are missing but required, then return noError and goto D. (3) if other variable bindings included in the same PDU, provide values for all columns which are missing but required, then return noError and goto C. (4) at the discretion of the agent, the return value may be either: inconsistentName: because the agent does not choose to create such an instance when the corresponding RowStatus instance does not exist, or inconsistentValue: if the supplied value is inconsistent with the state of some other MIB object's value, or noError: because the agent chooses to create the instance. If noError is returned, then the instance of the status column must also be created, and the new state is B or C, depending on the information available to the agent. If inconsistentName or inconsistentValue is returned, the row remains in state A. (5) depending on the MIB definition for the column/table, either noError or inconsistentValue may be returned. NOTE: Other processing of the set request may result in a response other than noError being returned, e.g., wrongValue, noCreation, etc. Conceptual Row Creation There are four potential interactions when creating a conceptual row: selecting an instance-identifier which is not in use; creating the conceptual row; initializing any objects for which the agent does not supply a default; and, making the conceptual row available for use by the managed device. Interaction 1: Selecting an Instance-Identifier The algorithm used to select an instance-identifier varies for each conceptual row. In some cases, the instance- identifier is semantically significant, e.g., the destination address of a route, and a management station selects the instance-identifier according to the semantics. In other cases, the instance-identifier is used solely to distinguish conceptual rows, and a management station without specific knowledge of the conceptual row might examine the instances present in order to determine an unused instance-identifier. (This approach may be used, but it is often highly sub-optimal; however, it is also a questionable practice for a naive management station to attempt conceptual row creation.) Alternately, the MIB module which defines the conceptual row might provide one or more objects which provide assistance in determining an unused instance-identifier. For example, if the conceptual row is indexed by an integer-value, then an object having an integer-valued SYNTAX clause might be defined for such a purpose, allowing a management station to issue a management protocol retrieval operation. In order to avoid unnecessary collisions between competing management stations, `adjacent' retrievals of this object should be different. Finally, the management station could select a pseudo-random number to use as the index. In the event that this index was already in use and an inconsistentValue was returned in response to the management protocol set operation, the management station should simply select a new pseudo-random number and retry the operation. A MIB designer should choose between the two latter algorithms based on the size of the table (and therefore the efficiency of each algorithm). For tables in which a large number of entries are expected, it is recommended that a MIB object be defined that returns an acceptable index for creation. For tables with small numbers of entries, it is recommended that the latter pseudo-random index mechanism be used. Interaction 2: Creating the Conceptual Row Once an unused instance-identifier has been selected, the management station determines if it wishes to create and activate the conceptual row in one transaction or in a negotiated set of interactions. Interaction 2a: Creating and Activating the Conceptual Row The management station must first determine the column requirements, i.e., it must determine those columns for which it must or must not provide values. Depending on the complexity of the table and the management station's knowledge of the agent's capabilities, this determination can be made locally by the management station. Alternately, the management station issues a management protocol get operation to examine all columns in the conceptual row that it wishes to create. In response, for each column, there are three possible outcomes: - a value is returned, indicating that some other management station has already created this conceptual row. We return to interaction 1. - the exception `noSuchInstance' is returned, indicating that the agent implements the object-type associated with this column, and that this column in at least one conceptual row would be accessible in the MIB view used by the retrieval were it to exist. For those columns to which the agent provides read-create access, the `noSuchInstance' exception tells the management station that it should supply a value for this column when the conceptual row is to be created. - the exception `noSuchObject' is returned, indicating that the agent does not implement the object-type associated with this column or that there is no conceptual row for which this column would be accessible in the MIB view used by the retrieval. As such, the management station can not issue any management protocol set operations to create an instance of this column. Once the column requirements have been determined, a management protocol set operation is accordingly issued. This operation also sets the new instance of the status column to `createAndGo'. When the agent processes the set operation, it verifies that it has sufficient information to make the conceptual row available for use by the managed device. The information available to the agent is provided by two sources: the management protocol set operation which creates the conceptual row, and, implementation-specific defaults supplied by the agent (note that an agent must provide implementation-specific defaults for at least those objects which it implements as read-only). If there is sufficient information available, then the conceptual row is created, a `noError' response is returned, the status column is set to `active', and no further interactions are necessary (i.e., interactions 3 and 4 are skipped). If there is insufficient information, then the conceptual row is not created, and the set operation fails with an error of `inconsistentValue'. On this error, the management station can issue a management protocol retrieval operation to determine if this was because it failed to specify a value for a required column, or, because the selected instance of the status column already existed. In the latter case, we return to interaction 1. In the former case, the management station can re-issue the set operation with the additional information, or begin interaction 2 again using `createAndWait' in order to negotiate creation of the conceptual row. NOTE WELL Regardless of the method used to determine the column requirements, it is possible that the management station might deem a column necessary when, in fact, the agent will not allow that particular columnar instance to be created or written. In this case, the management protocol set operation will fail with an error such as `noCreation' or `notWritable'. In this case, the management station decides whether it needs to be able to set a value for that particular columnar instance. If not, the management station re-issues the management protocol set operation, but without setting a value for that particular columnar instance; otherwise, the management station aborts the row creation algorithm. Interaction 2b: Negotiating the Creation of the Conceptual Row The management station issues a management protocol set operation which sets the desired instance of the status column to `createAndWait'. If the agent is unwilling to process a request of this sort, the set operation fails with an error of `wrongValue'. (As a consequence, such an agent must be prepared to accept a single management protocol set operation, i.e., interaction 2a above, containing all of the columns indicated by its column requirements.) Otherwise, the conceptual row is created, a `noError' response is returned, and the status column is immediately set to either `notInService' or `notReady', depending on whether it has sufficient information to make the conceptual row available for use by the managed device. If there is sufficient information available, then the status column is set to `notInService'; otherwise, if there is insufficient information, then the status column is set to `notReady'. Regardless, we proceed to interaction 3. Interaction 3: Initializing non-defaulted Objects The management station must now determine the column requirements. It issues a management protocol get operation to examine all columns in the created conceptual row. In the response, for each column, there are three possible outcomes: - a value is returned, indicating that the agent implements the object-type associated with this column and had sufficient information to provide a value. For those columns to which the agent provides read-create access (and for which the agent allows their values to be changed after their creation), a value return tells the management station that it may issue additional management protocol set operations, if it desires, in order to change the value associated with this column. - the exception `noSuchInstance' is returned, indicating that the agent implements the object-type associated with this column, and that this column in at least one conceptual row would be accessible in the MIB view used by the retrieval were it to exist. However, the agent does not have sufficient information to provide a value, and until a value is provided, the conceptual row may not be made available for use by the managed device. For those columns to which the agent provides read-create access, the `noSuchInstance' exception tells the management station that it must issue additional management protocol set operations, in order to provide a value associated with this column. - the exception `noSuchObject' is returned, indicating that the agent does not implement the object-type associated with this column or that there is no conceptual row for which this column would be accessible in the MIB view used by the retrieval. As such, the management station can not issue any management protocol set operations to create an instance of this column. If the value associated with the status column is `notReady', then the management station must first deal with all `noSuchInstance' columns, if any. Having done so, the value of the status column becomes `notInService', and we proceed to interaction 4. Interaction 4: Making the Conceptual Row Available Once the management station is satisfied with the values associated with the columns of the conceptual row, it issues a management protocol set operation to set the status column to `active'. If the agent has sufficient information to make the conceptual row available for use by the managed device, the management protocol set operation succeeds (a `noError' response is returned). Otherwise, the management protocol set operation fails with an error of `inconsistentValue'. NOTE WELL A conceptual row having a status column with value `notInService' or `notReady' is unavailable to the managed device. As such, it is possible for the managed device to create its own instances during the time between the management protocol set operation which sets the status column to `createAndWait' and the management protocol set operation which sets the status column to `active'. In this case, when the management protocol set operation is issued to set the status column to `active', the values held in the agent supersede those used by the managed device. If the management station is prevented from setting the status column to `active' (e.g., due to management station or network failure) the conceptual row will be left in the `notInService' or `notReady' state, consuming resources indefinitely. The agent must detect conceptual rows that have been in either state for an abnormally long period of time and remove them. It is the responsibility of the DESCRIPTION clause of the status column to indicate what an abnormally long period of time would be. This period of time should be long enough to allow for human response time (including `think time') between the creation of the conceptual row and the setting of the status to `active'. In the absense of such information in the DESCRIPTION clause, it is suggested that this period be approximately 5 minutes in length. This removal action applies not only to newly-created rows, but also to previously active rows which are set to, and left in, the notInService state for a prolonged period exceeding that which is considered normal for such a conceptual row. Conceptual Row Suspension When a conceptual row is `active', the management station may issue a management protocol set operation which sets the instance of the status column to `notInService'. If the agent is unwilling to do so, the set operation fails with an error of `wrongValue'. Otherwise, the conceptual row is taken out of service, and a `noError' response is returned. It is the responsibility of the DESCRIPTION clause of the status column to indicate under what circumstances the status column should be taken out of service (e.g., in order for the value of some other column of the same conceptual row to be modified). Conceptual Row Deletion For deletion of conceptual rows, a management protocol set operation is issued which sets the instance of the status column to `destroy'. This request may be made regardless of the current value of the status column (e.g., it is possible to delete conceptual rows which are either `notReady', `notInService' or `active'.) If the operation succeeds, then all instances associated with the conceptual row are immediately removed."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class DateAndTime(TextualConvention, OctetString):
    description = "A date-time specification. field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC 0..11 10 11 minutes from UTC 0..59 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known, then timezone information (fields 8-10) is not present."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

symbol = MibIdentifier((1, 3, 6, 1, 4, 1, 388))
wsd = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11))
sysoids = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 1))
ws2000 = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 1, 1))
if mibBuilder.loadTexts: ws2000.setStatus('current')
if mibBuilder.loadTexts: ws2000.setDescription('WS2000 with 1 WAN port, 6 LAN ports.')
ws2k = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2))
ccAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2))
ccInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1))
ccInfoSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ccInfoSerialNumber.setDescription('The serial number of the switch. This value is unique for each instance of the WS2000 switch.')
ccInfoCountrySelection = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccInfoCountrySelection.setStatus('current')
if mibBuilder.loadTexts: ccInfoCountrySelection.setDescription('This value is a two-character representation of the country code. Note: when changing this _CountrySelection, the current channel and power levels are NOT changed. The prior settings for these values may or may not be valid/legal for the new country selected. It is up to the network management software to ensure that channel and/or power settings are changed BEFORE changing the country selection so that no such invalid/illegal state is reached, even for a short interim. country code: Argentina: ar Australia: au Austria: at Bahrain: bh Belarus: by Belgium: be Botswana: bw Brazil: br Bulgaria: bg Canada: ca Chile: cl China: cn Colombia: co Costa Rica: cr Croatia: hr Czech Republic: cz Denmark: dk Ecuador: ec Egypt: eg Estonia: ee Finland: fi France: fr Germany: de Greece: gr Hong Kong: hk Hungary: hu Iceland: is India: in Indonesia: id Ireland: ie Israel: il Italy: it Japan: jp Jordan: jo Kazakhstan: kz Kuwait: kw Latvia: lv Liechtenstein: li Lithuania: lt Luxembourg: lu Malaysia: my Mexico: mx Morocco: ma Namibia: na Netherlands: nl New Zealand: nz Norway: no Oman: om Peru: pe Philippines: ph Poland: pl Portugal: pt Qatar: qa Romania: ro Russia: ru Saudi Arabia: sa Singapore: sg Slovak Republic: sk Slovenia: si South Africa: za South Korea: kr Spain: es Sri Lanka: lk Sweden: se Switzerland: ch Taiwan: tw Thailand: th Turkey: tr Ukraine: ua United Arab Emirates: ae United Kingdom: uk United States: us Uruguay: uy Venezuela: ve Vietnam: vn ')
ccIdentfication = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3))
ccIdHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdHwVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdHwVersion.setDescription("The same text that follows 'HW=' in sysDescr, EXCLUDING the 'HW='.")
ccIdFwVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdFwVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdFwVersion.setDescription("The same text that follows 'FW=' in sysDescr, EXCLUDING the 'FW='. (The bootcode version).")
ccIdSwVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdSwVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdSwVersion.setDescription("The same text that follows 'SW=' in sysDescr, EXCLUDING the 'SW='.")
ccIdMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdMibVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdMibVersion.setDescription("The same text that follows 'MIB=' in sysDescr, EXCLUDING the 'MIB='. The MIB version is identified by a two-digit major version number (with a leading zero if needed), followed by a lower-case letter minor version and 0 or more character info number. The major MIB version is changed whenever it becomes incompatible to its previous version; i.e., some variables have been deleted or the behavior/meaning has been changed. Minor version number is changed when new features have been added, but existing behavior is completely unchanged. ")
ccIdCliVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdCliVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdCliVersion.setDescription("The same text that follows 'CLI=' in sysDescr, EXCLUDING the 'CLI='.")
ccIdXmlVersion = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdXmlVersion.setStatus('current')
if mibBuilder.loadTexts: ccIdXmlVersion.setDescription('Version of XML template implemented on this switch. (Much like MIB version - read details there).')
ccIdSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 3, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccIdSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ccIdSerialNumber.setDescription('The serial number of the switch. This value is unique for each instance of a given switch type.')
ccSysDNSRelayMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSysDNSRelayMode.setStatus('current')
if mibBuilder.loadTexts: ccSysDNSRelayMode.setDescription('Enable/Disable DNS Relay Mode')
ccApSslv2Mode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccApSslv2Mode.setStatus('current')
if mibBuilder.loadTexts: ccApSslv2Mode.setDescription('Enable/Disable SSLV2 Support')
ccApSshv1Mode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccApSshv1Mode.setStatus('current')
if mibBuilder.loadTexts: ccApSshv1Mode.setDescription('Enable/Disable SSHV1 Support')
ccApSslWeakCipherSupport = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccApSslWeakCipherSupport.setStatus('current')
if mibBuilder.loadTexts: ccApSslWeakCipherSupport.setDescription('Enable/Disable SSL Weak Cipher Support')
ccReset = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2))
ccResetFactory = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccResetFactory.setStatus('current')
if mibBuilder.loadTexts: ccResetFactory.setDescription('Writing this value causes the switch to reset to factory conditions. NOTHING is retained, NOT the static IP address assignments (if any), NOR any non-factory-default SNMP settings, nor any other non-factory-default settings. Given this, be warned that setting this value may very well cause all communication paths to the WS2000 to be lost. (However, if DHCP is used to obtain an IP addr on the WAN port, and only default SNMP settings are used, communications may be possible after the factory reset).')
ccResetSwitch = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccResetSwitch.setStatus('current')
if mibBuilder.loadTexts: ccResetSwitch.setDescription('Writing this value causes the switch to reset in the same fashion as a common, (non-factory) reset.')
ccResetMuCounters = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccResetMuCounters.setStatus('obsolete')
if mibBuilder.loadTexts: ccResetMuCounters.setDescription('Writing this value resets all counters in the ccRf > ccMus sub-tree. Obsolete in WS2000 v1.5')
ccResetFactoryExceptIpSnmp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2, 4), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccResetFactoryExceptIpSnmp.setStatus('current')
if mibBuilder.loadTexts: ccResetFactoryExceptIpSnmp.setDescription('Performs a factory reset, EXCEPT that Wan IP and SNMP access settings are retained across the reset. Specifically: Wan Ip + related settings Pppoe settings WS2000 wan access SNMP setting SNMP v1/v2/v3 access settings ')
ccResetStatCounters = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 2, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccResetStatCounters.setStatus('current')
if mibBuilder.loadTexts: ccResetStatCounters.setDescription('Writing this value resets all counters in the ccRf sub-tree except for the ccPortalSystemStatsTable and ccPortalTable ')
ccLoadFw = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3))
ccLoadFwOperation = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("ftpFirmwareServerToSwitch", 2), ("tftpFirmwareServerToSwitch", 3), ("cfFirmwareToSwitch", 4), ("sftpFirmwareServerToSwitch", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFwOperation.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwOperation.setDescription('Specifies if the firmware is to be loaded to the switch via FTP or TFTP or SFTP or CF Card.')
ccLoadFwInterface = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 11, 12, 13, 14))).clone(namedValues=NamedValues(("unspecified", 1), ("wan", 2), ("subnet1", 11), ("subnet2", 12), ("subnet3", 13), ("subnet4", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFwInterface.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwInterface.setDescription('The interface to use in contacting the FTP or TFTP or SFTP server. This is required since the actual firmware load is accomplished via boot code that does not contain routing logic.')
ccLoadFwServerPath = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFwServerPath.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwServerPath.setDescription("The path to the firmware on the SFTP/TFTP/FTP server. Remember that the type of separator varies depending on the operating system of the server. For Windows, use '\\', for Unix use '/'. No path need be specified, (in which case the default directory for the TFTP/FTP/SFTP server will be used); if a path is specified, remember to terminate it with a trailing '/' or '\\'.")
ccLoadFwServerFilename = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFwServerFilename.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwServerFilename.setDescription('The name, (on the server), of the firmware file to load. If operation is set to cfFirmwareToSwitch, this variable is the file name on the compact flash card.')
ccLoadFwStart = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFwStart.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwStart.setDescription("Set this value to start the firmware load operation. Note that the actual SFTP/TFTP/FTP does not begin immediately, as first the 'operational' firmware shuts-down, and returns to low-level boot code, which actually starts the transfer.")
ccLoadFwResult = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccLoadFwResult.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwResult.setDescription('This value reflects the result of the most-recent firmware load since reboot, (if any).')
ccLoadFwSuccess = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 3, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccLoadFwSuccess.setStatus('current')
if mibBuilder.loadTexts: ccLoadFwSuccess.setDescription('The success/failure status of the most recent firmware load.')
ccLoadCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4))
ccLoadCfgOperation = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unspecified", 1), ("ftpConfigServerToSwitch", 2), ("ftpConfigSwitchToServer", 3), ("tftpConfigServerToSwitch", 4), ("tftpConfigSwitchToServer", 5), ("sftpConfigServerToSwitch", 6), ("sftpConfigSwitchToServer", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadCfgOperation.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgOperation.setDescription('Specifies the type and direction of the transfer to perform involving the configuration file.')
ccLoadCfgServerPath = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadCfgServerPath.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgServerPath.setDescription("The path to the firmware on the SFTP/TFTP/FTP server. Remember that the type of separator varies depending on the operating system of the server. For Windows, use '\\', for Unix use '/'. No path need be specified, (in which case the default directory for the SFTP/TFTP/FTP server will be used); if a path is specified, remember to terminate it with a trailing '/' or '\\'.")
ccLoadCfgServerFilename = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadCfgServerFilename.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgServerFilename.setDescription('The name, (on the server), of the configuration file to load/store from/to the server.')
ccLoadCfgStart = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadCfgStart.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgStart.setDescription('Set this value to start the configuration file operation. Note that unlike a firmware load, the actual FTP/TFTP/SFTP transfer does begin virtually immediately.')
ccLoadCfgOperationsDone = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccLoadCfgOperationsDone.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgOperationsDone.setDescription('This value counts the total number of configuration file transfers completed, (whether they succeed or fail). The SNMP manager should save the value of this counter just before starting a LoadCfg operation, and then wait for this value to increment before checking the Result and/or Success values.')
ccLoadCfgResult = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccLoadCfgResult.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgResult.setDescription('This value reflects the result of the most-recent configuration file load/store.')
ccLoadCfgSuccess = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 4, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccLoadCfgSuccess.setStatus('current')
if mibBuilder.loadTexts: ccLoadCfgSuccess.setDescription('The success/failure status of the most recent configuration file load/store.')
ccCfgHist = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 5))
ccCfgHistChangeCount = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 5, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCfgHistChangeCount.setStatus('current')
if mibBuilder.loadTexts: ccCfgHistChangeCount.setDescription('This value will increment by 1 or more for each config change. It persists across reboots. This variable can only be SET with the same value that it currently contains. Any other value will cause a SET-FAILED. Note that this is NOT a TEST-AND-INCREMENT semaphore, as this value does not immediately increment after a config change, but only after a short, though non-zero, delay. Because of this non-zero delay, it is not suitable as a semaphore. Note also that this value counts the number of times that Flash memory has been written, which may be greater than the number of config changes.')
ccCfgHistChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 5, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCfgHistChangeTime.setStatus('current')
if mibBuilder.loadTexts: ccCfgHistChangeTime.setDescription('A snapshot of sysUpTime as of the last config change.')
ccCfgHistSemaphore = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 5, 3), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCfgHistSemaphore.setStatus('current')
if mibBuilder.loadTexts: ccCfgHistSemaphore.setDescription('Can be used to solve the multiple-manager problem. Before performing any SETs, the manager reads this value. As a VAR-BIND of the only/last SET PDU, this value is written with that value read. If some other manager had made changes, this value would have incremented, and the SET to it will fail. Note that this only guards against other managers that use this semaphore. Changes made without using this value will NOT be protected against. For this reason, it is suggested that ccCfgHistChangeCount also be SET - though that is not a perfectly fail-safe semaphore, it will in most cases protect even against this latter case.')
ccLoad = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 6))
ccLoadServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 6, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadServerIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccLoadServerIpAddr.setDescription('IP address of the server used for a firmware load, or configuration file load/store operation.')
ccLoadFtpUsername = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFtpUsername.setStatus('current')
if mibBuilder.loadTexts: ccLoadFtpUsername.setDescription('Username for FTP LoadFw or LoadCfg operations.')
ccLoadFtpPassword = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 6, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoadFtpPassword.setStatus('current')
if mibBuilder.loadTexts: ccLoadFtpPassword.setDescription('Password for FTP LoadFw or LoadCfg operations.')
ccSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7))
ccSnmpAclViolations = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSnmpAclViolations.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAclViolations.setDescription('Counts the total number of SNMP requests rejected due to ACL violations since boot.')
ccSnmpLastDeniedIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSnmpLastDeniedIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccSnmpLastDeniedIpAddr.setDescription('The IP address of the last SNMP request to be denied due to ACL violation.')
ccSnmpV3EngineId = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSnmpV3EngineId.setStatus('current')
if mibBuilder.loadTexts: ccSnmpV3EngineId.setDescription('SNMPv3 Engine ID')
ccSnmpAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4))
ccSnmpAccessV12Table = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1), )
if mibBuilder.loadTexts: ccSnmpAccessV12Table.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Table.setDescription('Table of SNMP v1/v2 access entries.')
ccSnmpAccessV12Entry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12Index"))
if mibBuilder.loadTexts: ccSnmpAccessV12Entry.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Entry.setDescription('Description.')
ccSnmpAccessV12Index = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSnmpAccessV12Index.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Index.setDescription('Simple Index.')
ccSnmpAccessV12Community = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV12Community.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Community.setDescription('Community Name of the SNMP manager.')
ccSnmpAccessV12CustomOid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV12CustomOid.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12CustomOid.setDescription('Starting OID.')
ccSnmpAccessV12OidLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("all", 1), ("custom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV12OidLimit.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12OidLimit.setDescription('OID Limit whether the entire MIB tree or a specific OID set.')
ccSnmpAccessV12Access = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV12Access.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Access.setDescription('Access type whether RO or RW.')
ccSnmpAccessV12Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 1, 1, 6), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV12Enable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV12Enable.setDescription('Row Status.')
ccSnmpAccessV3Table = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2), )
if mibBuilder.loadTexts: ccSnmpAccessV3Table.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3Table.setDescription('Table of SNMP v3 access entries.')
ccSnmpAccessV3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3Index"))
if mibBuilder.loadTexts: ccSnmpAccessV3Entry.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3Entry.setDescription('Description.')
ccSnmpAccessV3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSnmpAccessV3Index.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3Index.setDescription('Simple Index.')
ccSnmpAccessV3User = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3User.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3User.setDescription('v3 User Name.')
ccSnmpAccessV3SecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAuth", 1), ("authNoPriv", 2), ("authPriv", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3SecurityLevel.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3SecurityLevel.setDescription('Security Level.')
ccSnmpAccessV3CustomOid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3CustomOid.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3CustomOid.setDescription('Starting OID.')
ccSnmpAccessV3OidLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("all", 1), ("custom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3OidLimit.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3OidLimit.setDescription('OID Limit whether the entire MIB tree or a specific OID set.')
ccSnmpAccessV3Access = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3Access.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3Access.setDescription('Access type whether RO or RW.')
ccSnmpAccessV3AuthAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3AuthAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3AuthAlgorithm.setDescription('Authentication Algorithm used.')
ccSnmpAccessV3AuthPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 8), Password().subtype(subtypeSpec=ValueSizeConstraint(8, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3AuthPassword.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3AuthPassword.setDescription('Authentication Password.')
ccSnmpAccessV3PrivacyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("des", 1), ("aes128", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3PrivacyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3PrivacyAlgorithm.setDescription('Privacy Algorithm used.')
ccSnmpAccessV3PrivacyPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 10), Password().subtype(subtypeSpec=ValueSizeConstraint(8, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3PrivacyPassword.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3PrivacyPassword.setDescription('Privacy Password.')
ccSnmpAccessV3Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 2, 1, 11), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessV3Enable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessV3Enable.setDescription('Row Status.')
ccSnmpAccessControlTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3), )
if mibBuilder.loadTexts: ccSnmpAccessControlTable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlTable.setDescription('Table of SNMP access control entries.')
ccSnmpAccessControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSnmpAccessControlIndex"))
if mibBuilder.loadTexts: ccSnmpAccessControlEntry.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlEntry.setDescription('Description.')
ccSnmpAccessControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSnmpAccessControlIndex.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlIndex.setDescription('Simple Index.')
ccSnmpAccessControlStartIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessControlStartIp.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlStartIp.setDescription('Starting IP range of the SNMP manager allowed to access the switch.')
ccSnmpAccessControlEndIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessControlEndIp.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlEndIp.setDescription('Ending IP range of the SNMP manager allowed to access the switch.')
ccSnmpAccessControlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 4, 3, 1, 4), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpAccessControlEnable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAccessControlEnable.setDescription('Row Status.')
ccSnmpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5))
ccSnmpTrapSinkV12Table = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1), )
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Table.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Table.setDescription('Table of SNMP v1/v2 trap configuration entries.')
ccSnmpTrapSinkV12Entry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Index"))
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Entry.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Entry.setDescription('Description.')
ccSnmpTrapSinkV12Index = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Index.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Index.setDescription('Simple Index.')
ccSnmpTrapSinkV12DestinationIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12DestinationIp.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12DestinationIp.setDescription('Destination IP of Trap Manager.')
ccSnmpTrapSinkV12Port = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Port.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Port.setDescription('Destination Port of Trap Manager.')
ccSnmpTrapSinkV12Community = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Community.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Community.setDescription('Community Name.')
ccSnmpTrapSinkV12Version = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("snmpV1", 1), ("snmpV2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Version.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Version.setDescription('SNMP protocol version.')
ccSnmpTrapSinkV12Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 1, 1, 6), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Enable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV12Enable.setDescription('Row Status.')
ccSnmpTrapSinkV3Table = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2), )
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Table.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Table.setDescription('Table of SNMP v3 trap configuration entries.')
ccSnmpTrapSinkV3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3Index"))
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Entry.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Entry.setDescription('Description.')
ccSnmpTrapSinkV3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Index.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Index.setDescription('Simple Index.')
ccSnmpTrapSinkV3DestinationIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3DestinationIp.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3DestinationIp.setDescription('Destination IP of Trap Manager.')
ccSnmpTrapSinkV3Port = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Port.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Port.setDescription('Destination Port of Trap Manager.')
ccSnmpTrapSinkV3Username = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Username.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Username.setDescription('User name of SNMP v3 user.')
ccSnmpTrapSinkV3SecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auth", 1), ("authNoPriv", 2), ("authPriv", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3SecurityLevel.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3SecurityLevel.setDescription('Security Level.')
ccSnmpTrapSinkV3AuthAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3AuthAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3AuthAlgorithm.setDescription('SNMP v3 Authentication Algorithm.')
ccSnmpTrapSinkV3AuthPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 7), Password().subtype(subtypeSpec=ValueSizeConstraint(8, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3AuthPassword.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3AuthPassword.setDescription('SNMP v3 Authentication Password.')
ccSnmpTrapSinkV3PrivacyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("des", 1), ("aes128", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3PrivacyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3PrivacyAlgorithm.setDescription('SNMP v3 Privacy Algorithm.')
ccSnmpTrapSinkV3PrivacyPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 9), Password().subtype(subtypeSpec=ValueSizeConstraint(8, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3PrivacyPassword.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3PrivacyPassword.setDescription('SNMP v3 Privacy Password.')
ccSnmpTrapSinkV3Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 7, 5, 2, 1, 10), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Enable.setStatus('current')
if mibBuilder.loadTexts: ccSnmpTrapSinkV3Enable.setDescription('Row Status.')
ccCompactFlash = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 8))
ccCompactFlashCapacity = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCompactFlashCapacity.setStatus('current')
if mibBuilder.loadTexts: ccCompactFlashCapacity.setDescription('Capacity of the Compact Flash card in Kbyte. ')
ccCompactFlashUsed = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCompactFlashUsed.setStatus('current')
if mibBuilder.loadTexts: ccCompactFlashUsed.setDescription('Number of Kbyte in use on the Compact Flash card.')
ccSumStats = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 9))
ccSumStatsShortWindow = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 9, 1), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSumStatsShortWindow.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsShortWindow.setDescription("The number of seconds backwards from the specified timestamp that the the 'Short' window extends backwards in time.")
ccSumStatsShortUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 9, 2), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSumStatsShortUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsShortUpdateInterval.setDescription("The frequency at which the 'Short' summary stats are updated.")
ccSumStatsLongWindow = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 9, 3), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSumStatsLongWindow.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsLongWindow.setDescription("Same as corresponding 'Short' value, for the 'Long' window.")
ccSumStatsLongUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 9, 4), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSumStatsLongUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsLongUpdateInterval.setDescription("Same as corresponding 'Short' value, for the 'Long' window.")
ccMgmtAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10))
ccMgmtAccessToAllow = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 1), Bits().clone(namedValues=NamedValues(("fromLanAppletHttp", 0), ("fromLanAppletHttps", 1), ("fromLanCliTelnet", 2), ("fromLanSsh", 3), ("fromLanSnmp", 4), ("fromWanAppletHttp", 5), ("fromWanAppletHttps", 6), ("fromWanCliTelnet", 7), ("fromWanSsh", 8), ("fromWanSnmp", 9), ("fromWanFtp", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessToAllow.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessToAllow.setDescription('Types of network management access to permit.')
ccMgmtAccessAirbeam = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 2))
ccMgmtAccessAirbeamAllow = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAirbeamAllow.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAirbeamAllow.setDescription('Allow Airbeam smart. (If enabled, Airbeam access is only allowed from the LAN interfaces).')
ccMgmtAccessAirbeamPassword = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 2, 2), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAirbeamPassword.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAirbeamPassword.setDescription("Airbeam password. (username is 'airbeam').")
ccMgmtAccessAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3))
ccMgmtAccessAdminAuth = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("radius", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAdminAuth.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAdminAuth.setDescription('The type of authentication used to authenticate the administrator.It can be a local database or a radius server. ')
ccMgmtAccessAdminPassword = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3, 2), Password().subtype(subtypeSpec=ValueSizeConstraint(1, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAdminPassword.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAdminPassword.setDescription('Administrator password. Can only be read, (via GET), using a community string capable of writing, (via SET), the value. If an otherwise valid community string is used, a string of length 0 is returned.')
ccMgmtAccessAdminAuthRadiusServerIp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusServerIp.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusServerIp.setDescription('The IP address of the radius server which is used to authenticate the administrator ')
ccMgmtAccessAdminAuthRadiusServerPort = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusServerPort.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusServerPort.setDescription('The port of the radius server which is used to authenticate the administrator')
ccMgmtAccessAdminAuthRadiusSharedSecret = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 3, 6), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusSharedSecret.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessAdminAuthRadiusSharedSecret.setDescription('The shared secret the radius server which is used to authenticate the administrator')
ccMgmtAccessSsh = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 4))
ccMgmtAccessSshAuthTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 4, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessSshAuthTimeout.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessSshAuthTimeout.setDescription('The duration within which the user can enter the password after providing the user id.')
ccMgmtAccessSshInactivityTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 4, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessSshInactivityTimeout.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessSshInactivityTimeout.setDescription('The duration within which the server should receive the keep alive responses from the client. In SSH v2, the server shall timeout if does not receive Keep alive responses from the client. ')
ccMgmtAccessHttpsTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 10, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccMgmtAccessHttpsTimeout.setStatus('current')
if mibBuilder.loadTexts: ccMgmtAccessHttpsTimeout.setDescription('HTTP/HTTPS connection timeout.')
ccLogging = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11))
ccLoggingLevel = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("level0Emergency", 0), ("level1Alert", 1), ("level2Critical", 2), ("level3Errors", 3), ("level4Warnings", 4), ("level5Notice", 5), ("level6Info", 6), ("level7Debug", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoggingLevel.setStatus('current')
if mibBuilder.loadTexts: ccLoggingLevel.setDescription('Level of logging to perform.')
ccLoggingToSyslog = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoggingToSyslog.setStatus('current')
if mibBuilder.loadTexts: ccLoggingToSyslog.setDescription('Send logs to external syslog.')
ccLoggingSyslogServer = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoggingSyslogServer.setStatus('current')
if mibBuilder.loadTexts: ccLoggingSyslogServer.setDescription('IP addr of syslog server.')
ccLoggingDeleteCoreFile = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11, 4), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoggingDeleteCoreFile.setStatus('current')
if mibBuilder.loadTexts: ccLoggingDeleteCoreFile.setDescription('Delete the Core File.')
ccLoggingTransferCoreFile = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 11, 5), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLoggingTransferCoreFile.setStatus('current')
if mibBuilder.loadTexts: ccLoggingTransferCoreFile.setDescription('Transfer the core file to external FTP server.')
ccNtp = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12))
ccNtpEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtpEnable.setStatus('current')
if mibBuilder.loadTexts: ccNtpEnable.setDescription('Enable NTP.')
ccNtp0Server = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp0Server.setStatus('current')
if mibBuilder.loadTexts: ccNtp0Server.setDescription('Preferred NTP server IPaddr.')
ccNtp0Port = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp0Port.setStatus('current')
if mibBuilder.loadTexts: ccNtp0Port.setDescription('Preferred NTP server port number.')
ccNtp1Server = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp1Server.setStatus('current')
if mibBuilder.loadTexts: ccNtp1Server.setDescription('1st alternate NTP server IPaddr.')
ccNtp1Port = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp1Port.setStatus('current')
if mibBuilder.loadTexts: ccNtp1Port.setDescription('1st alternate NTP server port number.')
ccNtp2Server = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp2Server.setStatus('current')
if mibBuilder.loadTexts: ccNtp2Server.setDescription('2nd alternate NTP server IPaddr.')
ccNtp2Port = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtp2Port.setStatus('current')
if mibBuilder.loadTexts: ccNtp2Port.setDescription('2nd alternate NTP server port number.')
ccNtpGmtHourOffset = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccNtpGmtHourOffset.setStatus('current')
if mibBuilder.loadTexts: ccNtpGmtHourOffset.setDescription('GMT Hour Offset. Not implemented in WS2000 2.0')
ccNtpGmtMinuteOffset = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccNtpGmtMinuteOffset.setStatus('current')
if mibBuilder.loadTexts: ccNtpGmtMinuteOffset.setDescription('GMT Minute Offset. Not implemented in WS2000 2.0')
ccNtpCurrentDateTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccNtpCurrentDateTime.setStatus('current')
if mibBuilder.loadTexts: ccNtpCurrentDateTime.setDescription('Current date/time. If NTP is not running, or has not yet synchronized the time, this value will be 0. ')
ccNtpSyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 12, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccNtpSyncInterval.setStatus('current')
if mibBuilder.loadTexts: ccNtpSyncInterval.setDescription('Synchronization Interval (in minutes)')
ccDhcpOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14))
ccDhcpOptionsUpdateFwEna = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDhcpOptionsUpdateFwEna.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsUpdateFwEna.setDescription('Enable updating of firmware using DHCP vendor options ')
ccDhcpOptionsUpdateCfgEna = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDhcpOptionsUpdateCfgEna.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsUpdateCfgEna.setDescription('Enable updating of configuration using DHCP vendor options')
ccDhcpOptionsUpdateInterface = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("wan", 1), ("subnet1", 2), ("subnet2", 3), ("subnet3", 4), ("subnet4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDhcpOptionsUpdateInterface.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsUpdateInterface.setDescription('The interface to use in contacting the FTP or TFTP server. This is required since the actual firmware load is accomplished via boot code that does not contain routing logic.')
ccDhcpOptionsUpdateFwFilename = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDhcpOptionsUpdateFwFilename.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsUpdateFwFilename.setDescription('The firmware filename most recently provided via DHCP options. The success/failure of actually fetching that file via TFTP is reported in ccLoadFwSuccess and ccLoadFwResult. ')
ccDhcpOptionsUpdateCfgFilename = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 14, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDhcpOptionsUpdateCfgFilename.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsUpdateCfgFilename.setDescription('The config filename most recently provided via DHCP options. The success/failure of actually fetching that file via TFTP is reported in ccLoadCfgSuccess and ccLoadCfgResult. ')
ccRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15))
ccRedundancyAdminState = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("standby", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRedundancyAdminState.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyAdminState.setDescription("The desired state of redundancy for this switch. 'standAlone' is for a switch with no redundancy. 'redundantPrimary' and 'redundantStandby' for when the switch is desired to be part of a pair of switches for redundancy. 'redundantUpgrade' is used to update the firmware of one switch of a pair configured for redundancy. This mode is just like 'standAlone' except that switch will not adopt portals. Note that when configuring two switches, both starting in 'standAlone' state, configure the primary first. (If you configure the desired standby first, it will NOT hear heartbeats from the primary, and will quickly transition to _OperState = 'redundantPrimary'). ")
ccRedundancyOperState = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("redundancy", 1), ("upgrade", 2), ("standAlone", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRedundancyOperState.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyOperState.setDescription('The actual state of redundancy for this switch.')
ccRedundancyHeartbeatInterface = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("port1", 1), ("port2", 2), ("port3", 3), ("port4", 4), ("port5", 5), ("port6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRedundancyHeartbeatInterface.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyHeartbeatInterface.setDescription('The interface to use in contacting the FTP or TFTP server. This is required since the actual firmware load is accomplished via boot code that does not contain routing logic.')
ccRedundancyHeartbeatInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRedundancyHeartbeatInterval.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyHeartbeatInterval.setDescription('The duration in seconds between consecutive heartbeats. User can control the frequency of hearbeats by tuning this parameter.')
ccRedundancyRevertDelay = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 5), Unsigned32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRedundancyRevertDelay.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyRevertDelay.setDescription('The duration which the master WS2000 shall wait before taking over from a backup WS2000.')
ccRedundancyOperMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 15, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRedundancyOperMode.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyOperMode.setDescription('Current Operational Mode of the switch.')
ccCertMgnt = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16))
ccCertMgntSelfCerts = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1))
ccCertMgntSelfCertsReqTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1), )
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqTable.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqTable.setDescription('This table allows the admin to create and store up to three certificate signature requests. The required fields are ccSelfCertsReqKeyId and ccSelfCertReqSubject. ')
ccCertMgntSelfCertsReqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqIndex"))
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqEntry.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqEntry.setDescription(' ')
ccCertMgntSelfCertsReqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqIndex.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqIndex.setDescription('Simple index.')
ccCertMgntSelfCertsReqKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqKeyId.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqKeyId.setDescription('The ID for the certificate. Use this field to distinguish between certificates. This is a required field. ')
ccCertMgntSelfCertsReqSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqSubject.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqSubject.setDescription('The subject of the certificate. This is a required field. ')
ccCertMgntSelfCertsReqDept = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqDept.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqDept.setDescription('The department that is making the request. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqOrg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqOrg.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqOrg.setDescription('The name of the organization or company that is making the request. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqCity = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCity.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCity.setDescription('The name of the city where the organization resides. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqState.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqState.setDescription('The name of the state where the organzation resides. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqPostal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqPostal.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqPostal.setDescription('The postal code (zip code in US) for the organization. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqCountry = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCountry.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCountry.setDescription('The two-letter ISO code for the country where the organization resides. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqEmail = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqEmail.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqEmail.setDescription('The email address to be used for identification purposes. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 49))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqDomain.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqDomain.setDescription('The domain name to associate with the certificate. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqIp.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqIp.setDescription('The WAN IP of the WS 2000 Wireless Switch. Contact your CA to determine whether this field is required.')
ccCertMgntSelfCertsReqSigAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cryptoMd5Rsa", 1), ("cryptoSha1Rsa", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqSigAlgo.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqSigAlgo.setDescription('The signature algorithm you want used for the certificate. The options are: MD5-RSA: This option uses the Message Digest 5 algorithm in combination with RSA encryption. SHA1-RSA: This options uses the Secure Hash Algorithm 1 in combination with RSA encryption. This is a required field. ')
ccCertMgntSelfCertsReqKeyLen = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("keylen512", 1), ("keylen1024", 2), ("keylen2048", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqKeyLen.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqKeyLen.setDescription('The desired length of the key. Possible values are 512, 1024, and 2048. Select a lower number to enhance performance. Select a large number to enhance security.')
ccCertMgntSelfCertsReqGenReq = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 15), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqGenReq.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqGenReq.setDescription('Start generating certificate request.')
ccCertMgntSelfCertsReqCertReqStr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCertReqStr.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqCertReqStr.setDescription('The generated certificate request string.')
ccCertMgntSelfCertsReqRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 1, 1, 17), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsReqRowStatus.setDescription('Row status.')
ccCertMgntSelfCertsIdName = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsIdName.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsIdName.setDescription('ID Name of the signed certificate.')
ccCertMgntSelfCertsSignedStr = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedStr.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedStr.setDescription('The signed certificate.')
ccCertMgntSelfCertsSignedImport = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 4), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedImport.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedImport.setDescription('Start importing the signed certificate from ccCertMgntSelfCertsSignedStr to a new row in ccCertMgntSelfCertsSignedTable. ')
ccCertMgntSelfCertsSignedTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5), )
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedTable.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedTable.setDescription('This table allows the admin to store up to three signed certificates. This table supports a max size of three rows.')
ccCertMgntSelfCertsSignedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedIndex"))
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedEntry.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedEntry.setDescription(' ')
ccCertMgntSelfCertsSignedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedIndex.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedIndex.setDescription('Simple index.')
ccCertMgntSelfCertsSignedKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedKeyId.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedKeyId.setDescription('The ID for the certificate. Use this field to distinguish between certificates. ')
ccCertMgntSelfCertsSignedIssuerName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedIssuerName.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedIssuerName.setDescription('The name of the certificate authority who signed the certificate.')
ccCertMgntSelfCertsSignedSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedSubject.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedSubject.setDescription('The subject of the certificate.')
ccCertMgntSelfCertsSignedSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedSerialNumber.setDescription('The serial number of the certificate.')
ccCertMgntSelfCertsSignedExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedExpiry.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedExpiry.setDescription('The date when the certificate expires.')
ccCertMgntSelfCertsSignedDeleteRow = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 1, 5, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedDeleteRow.setStatus('current')
if mibBuilder.loadTexts: ccCertMgntSelfCertsSignedDeleteRow.setDescription('Delete row.')
ccCACerts = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2))
ccCACertsStr = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCACertsStr.setStatus('current')
if mibBuilder.loadTexts: ccCACertsStr.setDescription('The CA certificate to be imported.')
ccCACertsImport = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 2), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCACertsImport.setStatus('current')
if mibBuilder.loadTexts: ccCACertsImport.setDescription('Start import operation for the CA certificate stored in ccCACertsStr. This operation adds a row in ccCACertsTable.')
ccCACertsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3), )
if mibBuilder.loadTexts: ccCACertsTable.setStatus('current')
if mibBuilder.loadTexts: ccCACertsTable.setDescription('This table allows the admin to store up to three CA certificates. This table supports a max size of three rows.')
ccCACertsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccCACertsIndex"))
if mibBuilder.loadTexts: ccCACertsEntry.setStatus('current')
if mibBuilder.loadTexts: ccCACertsEntry.setDescription(' ')
ccCACertsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccCACertsIndex.setStatus('current')
if mibBuilder.loadTexts: ccCACertsIndex.setDescription('Simple index.')
ccCACertsKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCACertsKeyId.setStatus('current')
if mibBuilder.loadTexts: ccCACertsKeyId.setDescription('The ID for the certificate. Use this field to distinguish between certificates. ')
ccCACertsIssuerName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCACertsIssuerName.setStatus('current')
if mibBuilder.loadTexts: ccCACertsIssuerName.setDescription('The name of the certificate authority.')
ccCACertsSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCACertsSubject.setStatus('current')
if mibBuilder.loadTexts: ccCACertsSubject.setDescription('The subject of the certificate.')
ccCACertsSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCACertsSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ccCACertsSerialNumber.setDescription('The serial number of the certificate.')
ccCACertsExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCACertsExpiry.setStatus('current')
if mibBuilder.loadTexts: ccCACertsExpiry.setDescription('The date when the certificate expires.')
ccCACertsDeleteRow = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 2, 16, 2, 3, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCACertsDeleteRow.setStatus('current')
if mibBuilder.loadTexts: ccCACertsDeleteRow.setDescription('Delete Row.')
ccNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3))
ccPortalAdopted = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"))
if mibBuilder.loadTexts: ccPortalAdopted.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdopted.setDescription('A Portal has been adopted by the switch. Example: Portal MAC=%s1 has been adopted.')
ccPortalUnAdopted = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 2)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastReason"))
if mibBuilder.loadTexts: ccPortalUnAdopted.setStatus('current')
if mibBuilder.loadTexts: ccPortalUnAdopted.setDescription('A Portal has been un-adopted by the switch. Example: Portal MAC=%s1 has been UN-adopted for reason %s2.')
ccPortalDenied = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 3)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastReason"))
if mibBuilder.loadTexts: ccPortalDenied.setStatus('current')
if mibBuilder.loadTexts: ccPortalDenied.setDescription('A Portal has been denied adoption by the switch. Example: Portal MAC=%s1 has been denied adopted for reason %s2.')
ccMuAssociated = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 4)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"))
if mibBuilder.loadTexts: ccMuAssociated.setStatus('current')
if mibBuilder.loadTexts: ccMuAssociated.setDescription('An MU has been associated to a Portal adopted by this switch. Example: MU MAC=%s1 has associated to Portal MAC=%s2.')
ccMuUnAssociated = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 5)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastReason"))
if mibBuilder.loadTexts: ccMuUnAssociated.setStatus('current')
if mibBuilder.loadTexts: ccMuUnAssociated.setDescription('An MU has been un-associated to a Portal adopted by this switch. Example: MU MAC=%s1 has UN-associated from Portal MAC=%s2 for reason %s3.')
ccMuDenied = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 6)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastReason"))
if mibBuilder.loadTexts: ccMuDenied.setStatus('current')
if mibBuilder.loadTexts: ccMuDenied.setDescription('An MU has been denied association to a Portal adopted by this switch. Example: MU MAC=%s1 has been denied association to Portal MAC=%s2 for reason %s3.')
ccConfigChange = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 7)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeTime"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeCount"))
if mibBuilder.loadTexts: ccConfigChange.setStatus('current')
if mibBuilder.loadTexts: ccConfigChange.setDescription('The configuration of this switch has changed. Example: The configuration of the switch changed as of sysUpTime=%s1; the total number of config changes since reboot is now %s2.')
ccSnmpAclViolation = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 8)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccSnmpLastDeniedIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolations"))
if mibBuilder.loadTexts: ccSnmpAclViolation.setStatus('current')
if mibBuilder.loadTexts: ccSnmpAclViolation.setDescription('An attempt to communicate via SNMP to the switch has been denied based on configured ACLs. Example: IP-addr %s1 has attempted, but been prohibited, from communicating with the switch via SNMP; total number of such ACL violations = %s2.')
ccPortStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 9)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortStatus"))
if mibBuilder.loadTexts: ccPortStatusChange.setStatus('current')
if mibBuilder.loadTexts: ccPortStatusChange.setDescription("A [physical] port's state has changed from up-->down, or down-->up. Example: Port %i1 has changed state to %s1.")
ccCfAlmostFull = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 10)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccCompactFlashCapacity"), ("SYMBOL-CC-WS2000-MIB", "ccCompactFlashUsed"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlCfAlmostFullThreshold"))
if mibBuilder.loadTexts: ccCfAlmostFull.setStatus('current')
if mibBuilder.loadTexts: ccCfAlmostFull.setDescription('The compact flash is almost full; (it has crossed the threshold defined by ccTrapCtrlCfAlmostFullThreshold). Example: The compact flash is almost full; Used=%s1, Capacity=%s2, Threshold=%s3.')
ccFirewallUnderAttack = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 11)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlFirewallUnderAttackDescription"))
if mibBuilder.loadTexts: ccFirewallUnderAttack.setStatus('current')
if mibBuilder.loadTexts: ccFirewallUnderAttack.setDescription('The firewall has detected an attack in progress. Example: The WAN firewall is being attached by method %s1.')
ccRadarDetected = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 12)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedChannel"))
if mibBuilder.loadTexts: ccRadarDetected.setStatus('current')
if mibBuilder.loadTexts: ccRadarDetected.setDescription('Radar has been detected on a Portal channel. Example: Radar has been detected on Portal MAC=%s1, on channel %s2.')
ccSumStatsMu = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 13)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsDescr"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdMu"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"), ("SYMBOL-CC-WS2000-MIB", "ccMuMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuIpAddr"))
if mibBuilder.loadTexts: ccSumStatsMu.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsMu.setDescription("A summary statistic has crossed the prescribed threshold by an MU. Example: Threshold '%s1' of value %s2 (units:%s3) has been crossed by MU MAC=%s4 with IP-addr=%s5.")
ccSumStatsPortal = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 14)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdPortals"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"), ("SYMBOL-CC-WS2000-MIB", "ccPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLocation"))
if mibBuilder.loadTexts: ccSumStatsPortal.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsPortal.setDescription('A summary statistic has crossed the prescribed threshold by a Portal. Example: Threshold #%s1 of value %s2 (units:%s3) has been crossed by Portal index=%s4 with MAC=%s5.')
ccSumStatsWlan = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 15)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsDescr"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdWlans"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"), ("SYMBOL-CC-WS2000-MIB", "ccWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEssid"))
if mibBuilder.loadTexts: ccSumStatsWlan.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsWlan.setDescription('A summary statistic has crossed the prescribed threshold by a WLAN. Example: Threshold #%s1 of value %s2 (units:%s3) has been crossed by WLAN index=%s4 with name=%s5.')
ccSumStatsSwitch = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 16)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsDescr"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"))
if mibBuilder.loadTexts: ccSumStatsSwitch.setStatus('current')
if mibBuilder.loadTexts: ccSumStatsSwitch.setDescription('A summary statistic has crossed the prescribed threshold by the entire Switch. Example: Threshold %s1 of value %s2 (units:%s3) has been crossed by the entire switch.')
ccLanVlanActivated = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 17)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlLanVlanActivatedVlanId"))
if mibBuilder.loadTexts: ccLanVlanActivated.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanActivated.setDescription('A Vlan is activated. When ever a MU is associated with the switch, and it receives a VLAN attribute from the radius server, the specified VLAN is activated. ')
ccDhcpOptionsFileTransferStatus = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 18)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlDhcpOptionsFileTransferStatusRequested"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgResult"))
if mibBuilder.loadTexts: ccDhcpOptionsFileTransferStatus.setStatus('current')
if mibBuilder.loadTexts: ccDhcpOptionsFileTransferStatus.setDescription('Trap to say that the device received DHCP options instructing it to load a new fw or cnfg file, and that it has completed the transfer. The varbinds tell if the transfer was successful. Note that this trap will NOT be issued if the DHCP options specify the same file as was most recently loaded. Example: (if FW bit set in _Requested): The switch was instructed to load firmware %s2, and success=%s3 with result=%s4. (if CFG bit set in _Requested): The switch was instructed to load config %s5, and success=%s6 with result=%s7. ')
ccRedundancyStateChange = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 19)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccRedundancyOperState"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRedundancyPreviousOperState"))
if mibBuilder.loadTexts: ccRedundancyStateChange.setStatus('current')
if mibBuilder.loadTexts: ccRedundancyStateChange.setDescription("The state of this switch's ccRedundancyOperState has changed. Example: The switch has changed it's redundancy state to %s1. ")
ccTrapCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000))
ccTrapCtrlEnableTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 1), )
if mibBuilder.loadTexts: ccTrapCtrlEnableTable.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlEnableTable.setDescription('Table of Trap Enable entries.')
ccTrapCtrlEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccTrapCtrlEnableIndex"))
if mibBuilder.loadTexts: ccTrapCtrlEnableEntry.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlEnableEntry.setDescription('Description.')
ccTrapCtrlEnableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("trapCtrlPortalAdopted", 1), ("trapCtrlPortalUnAdopted", 2), ("trapCtrlPortalDeniedAdoption", 3), ("trapCtrlMuAssociated", 4), ("trapCtrlMuUnAssociated", 5), ("trapCtrlMuDeniedAssociation", 6), ("trapCtrlSnmpAuthFailure", 7), ("trapCtrlSnmpAclViolation", 8), ("trapCtrlSnmpColdStart", 9), ("trapCtrlSnmpConfigChanged", 10), ("trapCtrlCfAlmostFull", 11), ("trapCtrlPortStatusChange", 12), ("trapCtrlDenialofService", 13), ("trapCtrlMuAuthDenied", 14), ("trapCtrlRadarDetected", 15), ("trapCtrlRogueApDetected", 16)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlEnableIndex.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlEnableIndex.setDescription('Simple Index.')
ccTrapCtrlEnableName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlEnableName.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlEnableName.setDescription('Name of the Trap.')
ccTrapCtrlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlEnable.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlEnable.setDescription('Enable/Disbale a particular Trap.')
ccTrapCtrlDetails = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2))
ccTrapCtrlPortalAdopted = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 1))
if mibBuilder.loadTexts: ccTrapCtrlPortalAdopted.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlPortalAdopted.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlPortalUnAdopted = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 2))
if mibBuilder.loadTexts: ccTrapCtrlPortalUnAdopted.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlPortalUnAdopted.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlPortalDenied = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 3))
if mibBuilder.loadTexts: ccTrapCtrlPortalDenied.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlPortalDenied.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlMuAssociated = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 4))
if mibBuilder.loadTexts: ccTrapCtrlMuAssociated.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlMuAssociated.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlMuUnAssociated = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 5))
if mibBuilder.loadTexts: ccTrapCtrlMuUnAssociated.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlMuUnAssociated.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlMuDenied = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 6))
if mibBuilder.loadTexts: ccTrapCtrlMuDenied.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlMuDenied.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlConfigChange = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 7))
if mibBuilder.loadTexts: ccTrapCtrlConfigChange.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlConfigChange.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlSnmpAclViolation = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 8))
if mibBuilder.loadTexts: ccTrapCtrlSnmpAclViolation.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSnmpAclViolation.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlPortStatusChange = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 9))
if mibBuilder.loadTexts: ccTrapCtrlPortStatusChange.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlPortStatusChange.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlCfAlmostFull = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 10))
ccTrapCtrlCfAlmostFullThreshold = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 10, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlCfAlmostFullThreshold.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlCfAlmostFullThreshold.setDescription('A ccCfAlmostFull trap will be sent when less than this number of bytes are remained on the Compact Flash card. The trap is currently scheduled to fire every 5 minutes when the condition is met. ')
ccTrapCtrlFirewallUnderAttack = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 11))
ccTrapCtrlFirewallUnderAttackDescription = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 11, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlFirewallUnderAttackDescription.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlFirewallUnderAttackDescription.setDescription('Description of Firewall Under Attack.')
ccTrapCtrlFirewallUnderAttackRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 11, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlFirewallUnderAttackRateLimit.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlFirewallUnderAttackRateLimit.setDescription('The max rate at which ccFirewallUnderAttack traps/notifications will be sent from the switch. If the switch detects a FirewallUnderAttack condition and it has NOT been at least this many seconds since the last ccFirewallUnderAttack trap/notification, this current event will NOT result in a trap/notification. If this value is set to 0, every such event results in a trap/notification. Factory-default state is 1 [second]. ')
ccTrapCtrlRadarDetected = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 12))
ccTrapCtrlRadarDetectedPortalMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 12, 1), PhysAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlRadarDetectedPortalMac.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlRadarDetectedPortalMac.setDescription('MAC address of the Portal that has detected Radar. (Note that this variable is accessible-for-notify only).')
ccTrapCtrlRadarDetectedChannel = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 12, 2), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlRadarDetectedChannel.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlRadarDetectedChannel.setDescription('Channel on which Radar has been detected. (Note that this variable is accessible-for-notify only).')
ccTrapCtrlSumStats = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13))
ccTrapCtrlSumStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1), )
if mibBuilder.loadTexts: ccTrapCtrlSumStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsTable.setDescription("This table configures thresholds that can be monitored for - all MUs and/or - all Portals and/or - all WLANs and/or - for the entire switch When a given threshold is crossed, it generates the appropriate corresponding notification, (ccSumStats_: _MU, _Portal, _WLAN, or _Switch). Some thresholds result in notifications when exceeded, and some when the current value sinks below the threshold. This is indicated by the wording of the entry in the entry's _Descr value. In all cases, the summary stat being monitored is the Short value, never the Long value. Note that for thresholds of type thresholdsAvgMuSignal & thresholdsAvgMuNoise, the values being 'watched' are actually negative. In these cases the threshold is specified as a Unsigned32. For example, if you wish to trap on Signal being worse than -75dBm, enter '70'. This works since a user would never want to trap on a threshold of Sinal worse than +10dBm. (SNR is not an issue, since that is a positive value). Any values reported as var-binds in the resultant trap(s) are likewise reported as positive values.")
ccTrapCtrlSumStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsIndex"))
if mibBuilder.loadTexts: ccTrapCtrlSumStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsEntry.setDescription('The rows/instances in this table occur at the exact same indices as the corresponding monitored data occurs in the _SumStats tables. For example, row #2 / instance .2 represents the threshold(s) for the _PktsPerSec values for MU, Portal, WLAN, and Switch. If a given threshold does not make sense for one of those 4 entities, its corresponding TruthValue will be false.')
ccTrapCtrlSumStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("unusedTimestamp", 1), ("unusedNumPkts", 2), ("thresholdsPktsPerSec", 3), ("unusedPktsPerSecTx", 4), ("unusedPktsPerSecRx", 5), ("thresholdsThroughput", 6), ("unusedThroughputTx", 7), ("unusedThroughputRx", 8), ("thresholdsAvgBitSpeed", 9), ("thresholdsAvgMuSignal", 10), ("thresholdsAvgMuNoise", 11), ("thresholdsAvgMuSnr", 12), ("thresholdsPctNUcastPkts", 13), ("thresholdsPpmTxWithRetires", 14), ("thresholdsPpmTxDropped", 15), ("thresholdsTxAvgRetries", 16), ("thresholdsPpmRxUndecrypt", 17), ("thresholdsTotalMus", 18), ("thresholdsPctRfUtil", 19), ("thresholdsPctDropped", 20)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsIndex.setDescription('Index into table. Note that specific thresholds occur at specific instance values as denoted by the enumeration values assigned to this variable.')
ccTrapCtrlSumStatsDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsDescr.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsDescr.setDescription('Description of the threshold.')
ccTrapCtrlSumStatsUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsUnits.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsUnits.setDescription('Units of the the threshold.')
ccTrapCtrlSumStatsCanBeSetMu = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetMu.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetMu.setDescription('If true, the threshold can be set for MUs. If false, attempting the threshold will return a READ-ONLY.')
ccTrapCtrlSumStatsThresholdMu = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdMu.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdMu.setDescription('The threshold for all MUs. If 0, no threshold checking is performed.')
ccTrapCtrlSumStatsCanBeSetPortal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetPortal.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetPortal.setDescription('If true, the threshold can be set for Portals. If false, attempting the threshold will return a READ-ONLY.')
ccTrapCtrlSumStatsThresholdPortals = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdPortals.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdPortals.setDescription('The threshold for all Portals. If 0, no threshold checking is performed.')
ccTrapCtrlSumStatsCanBeSetWlan = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetWlan.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetWlan.setDescription('If true, the threshold can be set for Wlans. If false, attempting the threshold will return a READ-ONLY.')
ccTrapCtrlSumStatsThresholdWlans = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdWlans.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdWlans.setDescription('The threshold for all Wlans. If 0, no threshold checking is performed.')
ccTrapCtrlSumStatsCanBeSetSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetSwitch.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsCanBeSetSwitch.setDescription('If true, the threshold can be set for the entire switch. If false, attempting the threshold will return a READ-ONLY.')
ccTrapCtrlSumStatsThresholdSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 1, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdSwitch.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsThresholdSwitch.setDescription('The threshold for the entire Switch. If 0, no threshold checking is performed.')
ccTrapCtrlSumStatsMinPktsForTrap = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 13, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccTrapCtrlSumStatsMinPktsForTrap.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsMinPktsForTrap.setDescription("The minimum number of packets that must be in a window/dataset before any of the threshold traps will 'fire'.")
ccTrapCtrlSumStatsPortal = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 14))
if mibBuilder.loadTexts: ccTrapCtrlSumStatsPortal.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsPortal.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlSumStatsWlan = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 15))
if mibBuilder.loadTexts: ccTrapCtrlSumStatsWlan.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsWlan.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlSumStatsSwitch = ObjectIdentity((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 16))
if mibBuilder.loadTexts: ccTrapCtrlSumStatsSwitch.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlSumStatsSwitch.setDescription('(place-holder for future use and to keep the last OID of each ccTrapCtrl_ item here to match the last OID of the corresponding notification).')
ccTrapCtrlLanVlanActivated = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 17))
ccTrapCtrlLanVlanActivatedVlanId = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 17, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlLanVlanActivatedVlanId.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlLanVlanActivatedVlanId.setDescription('VLAN ID to which MU has been associated. (Note that this variable is accessible-for-notify only).')
ccTrapCtrlDhcpOptionsFileTransferStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 18))
ccTrapCtrlDhcpOptionsFileTransferStatusRequested = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 18, 1), Bits().clone(namedValues=NamedValues(("dhcpRequestedFwLoad", 0), ("dhcpRequestedCfgLoad", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlDhcpOptionsFileTransferStatusRequested.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlDhcpOptionsFileTransferStatusRequested.setDescription('DHCP request received. (Note that this variable is accessible-for-notify only).')
ccTrapCtrlRedundancyStateChange = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 19))
ccTrapCtrlRedundancyPreviousOperState = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 3, 1000, 2, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("standAlone", 1), ("redundantPrimary", 2), ("redundantStandby", 3), ("redundantUpgrade", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccTrapCtrlRedundancyPreviousOperState.setStatus('current')
if mibBuilder.loadTexts: ccTrapCtrlRedundancyPreviousOperState.setDescription('The actual state of redundancy for this switch.')
ccRf = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4))
ccAp = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1))
ccApTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1), )
if mibBuilder.loadTexts: ccApTable.setStatus('current')
if mibBuilder.loadTexts: ccApTable.setDescription('This table lists all Access Ports that contain at least one Portal that has been adopted by this WS2000.')
ccApEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccApIndex"))
if mibBuilder.loadTexts: ccApEntry.setStatus('current')
if mibBuilder.loadTexts: ccApEntry.setDescription(' ')
ccApIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccApIndex.setStatus('current')
if mibBuilder.loadTexts: ccApIndex.setDescription('Small, arbitrary integer index.')
ccApNicMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApNicMac.setStatus('current')
if mibBuilder.loadTexts: ccApNicMac.setDescription('MAC address of this Access Port.')
ccApModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApModelNumber.setStatus('current')
if mibBuilder.loadTexts: ccApModelNumber.setDescription('Model number of the Access Port.')
ccApSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ccApSerialNumber.setDescription('Serial Number of this Access Port.')
ccApPcbRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApPcbRevision.setStatus('current')
if mibBuilder.loadTexts: ccApPcbRevision.setDescription('Revision of the printed circuit board for this Access Port.')
ccApBootLoaderRev = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApBootLoaderRev.setStatus('current')
if mibBuilder.loadTexts: ccApBootLoaderRev.setDescription('Revision of the boot loader code in this Access Port.')
ccApWispVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApWispVersion.setStatus('current')
if mibBuilder.loadTexts: ccApWispVersion.setDescription('Version of the WISP (AP-switch) protocol implemented by this Access Port.')
ccApRuntimeFwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApRuntimeFwVersion.setStatus('current')
if mibBuilder.loadTexts: ccApRuntimeFwVersion.setDescription('Version of run-time code on this Access Port.')
ccApNumPortals = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApNumPortals.setStatus('current')
if mibBuilder.loadTexts: ccApNumPortals.setDescription('The number of Portals implemented on this Access Port.')
ccApPointersToPortals = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 1, 1, 1, 10), MultiPointer255()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccApPointersToPortals.setStatus('current')
if mibBuilder.loadTexts: ccApPointersToPortals.setDescription("If bit <n> of this value is set, this ApTable entry 'points' to entry <n> in the Portal Table. Such a reference conveys that the Portal entry pointed-to represents a Portal contained in the Access Port represented by this entry. Note that since one Access Port can implement 1, 2, (and in the future possibly more), Portals, this 'pointer' field had to be a bit-mask.")
ccPortal = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2))
ccPortalTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1), )
if mibBuilder.loadTexts: ccPortalTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalTable.setDescription('This table lists all Portals that have been adopted or have failed adoption (by this WS2000).')
ccPortalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalEntry.setDescription(' ')
ccPortalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccPortalIndex.setStatus('current')
if mibBuilder.loadTexts: ccPortalIndex.setDescription('Small, arbitrary integer index.')
ccPortalPointerToAp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 2), SinglePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalPointerToAp.setStatus('current')
if mibBuilder.loadTexts: ccPortalPointerToAp.setDescription("This value is the index in the ApTable for the entry representing the Access Port that contains this Portal. Since each Portal has one and only one Access Port as 'parent', this value is a simple integer, not a bit-mask.")
ccPortalPointersToWlans = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 3), MultiPointer63()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalPointersToWlans.setStatus('current')
if mibBuilder.loadTexts: ccPortalPointersToWlans.setDescription('(Reserved for future implementation).')
ccPortalName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalName.setStatus('current')
if mibBuilder.loadTexts: ccPortalName.setDescription('Name of this Portal, as assigned by the Web UI or CLI.')
ccPortalLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalLocation.setStatus('current')
if mibBuilder.loadTexts: ccPortalLocation.setDescription('Location string for this Portal, as assigned by the Web UI or CLI.')
ccPortalOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 6), Bits().clone(namedValues=NamedValues(("undefined00", 0), ("undefined01", 1), ("undefined02", 2), ("undefined03", 3), ("undefined04", 4), ("undefined05", 5), ("undefined06", 6), ("undefined07", 7), ("undefined08", 8), ("undefined09", 9), ("undefined10", 10), ("undefined11", 11), ("externalSecondaryAntInstalled", 12), ("internalSecondaryAntInstalled", 13), ("externalPrimaryAntInstalled", 14), ("internalPrimaryAntInstalled", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalOptions.setStatus('current')
if mibBuilder.loadTexts: ccPortalOptions.setDescription('This value describes the presence/absence of internal and/or external primary and/or secondary antennas.')
ccPortalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 7), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalMac.setStatus('current')
if mibBuilder.loadTexts: ccPortalMac.setDescription('MAC address of the Portal.')
ccPortalNumberOfEss = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalNumberOfEss.setStatus('current')
if mibBuilder.loadTexts: ccPortalNumberOfEss.setDescription('The number of ESSs implemented by this Portal.')
ccPortalNumberOfBss = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalNumberOfBss.setStatus('current')
if mibBuilder.loadTexts: ccPortalNumberOfBss.setDescription('The number of BSSs implemented by this Portal.')
ccPortalAssociatedMus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalAssociatedMus.setStatus('current')
if mibBuilder.loadTexts: ccPortalAssociatedMus.setDescription('The number of MUs currently associated to this Portal.')
ccPortalRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 11), RadioType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRadioType.setStatus('current')
if mibBuilder.loadTexts: ccPortalRadioType.setDescription('Radio type of the Portal.')
ccPortalChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161))).clone(namedValues=NamedValues(("ieee802dot11bChannel01", 1), ("ieee802dot11bChannel02", 2), ("ieee802dot11bChannel03", 3), ("ieee802dot11bChannel04", 4), ("ieee802dot11bChannel05", 5), ("ieee802dot11bChannel06", 6), ("ieee802dot11bChannel07", 7), ("ieee802dot11bChannel08", 8), ("ieee802dot11bChannel09", 9), ("ieee802dot11bChannel10", 10), ("ieee802dot11bChannel11", 11), ("ieee802dot11bChannel12", 12), ("ieee802dot11bChannel13", 13), ("ieee802dot11bChannel14", 14), ("ieee802dot11aChannel036", 36), ("ieee802dot11aChannel040", 40), ("ieee802dot11aChannel044", 44), ("ieee802dot11aChannel048", 48), ("ieee802dot11aChannel052", 52), ("ieee802dot11aChannel056", 56), ("ieee802dot11aChannel060", 60), ("ieee802dot11aChannel064", 64), ("ieee802dot11aChannel149", 149), ("ieee802dot11aChannel153", 153), ("ieee802dot11aChannel157", 157), ("ieee802dot11aChannel161", 161)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalChannel.setDescription('The value describes the channel the Portal is currently operating on. ')
ccPortalTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('milli-Watts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPowerLevel.setDescription('Output power level for the Portal. ')
ccPortalLastAdoption = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalLastAdoption.setStatus('current')
if mibBuilder.loadTexts: ccPortalLastAdoption.setDescription("A snapshot of the WS2000's sysUpTime when this Portal was last adopted.")
ccPortalState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("portalUpAndWaitingForConfig", 1), ("portalReceivingConfig", 2), ("portalUpAndAdopted", 3), ("portalDeniedAdoptionDueToAcl", 4), ("portalBroken", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalState.setStatus('current')
if mibBuilder.loadTexts: ccPortalState.setDescription("This value describes the state of the Portal. A healthy Portal would power-on, and quickly advance from portalUpAndWaitingForConfig and then on to portalReceivingConfig and then on to portalUpAndAdopted. A Portal that is denied adoption due to ACLs would show: portalDeniedAdoptionDueToAcl. A Portal that does not 'handshake' with the switch properly would be found in state: portalBroken.")
ccPortalBackgroundNoiseNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalBackgroundNoiseNumSamples.setStatus('current')
if mibBuilder.loadTexts: ccPortalBackgroundNoiseNumSamples.setDescription('Total packets received via the Portal included in all the other counters reported in this row.')
ccPortalBackgroundNoiseBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 17), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalBackgroundNoiseBest.setStatus('current')
if mibBuilder.loadTexts: ccPortalBackgroundNoiseBest.setDescription('The best Signal value seen from the Portal so far. (Remember that a -20dBm Signal is better than -60dBm). This value is initialized to 500dBm. ')
ccPortalBackgroundNoiseWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 18), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalBackgroundNoiseWorst.setStatus('current')
if mibBuilder.loadTexts: ccPortalBackgroundNoiseWorst.setDescription('The worst Signal value seen from the Portal so far. (Remember that a -80dBm Signal is worse than -60dBm). This value is initialized to -500dBm. ')
ccPortalBackgroundNoiseSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 19), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalBackgroundNoiseSum.setStatus('current')
if mibBuilder.loadTexts: ccPortalBackgroundNoiseSum.setDescription('A running sum of all Signal values calculated by the switch (using reported RSSI values), for packets received via this Portal. Note that this value is normally a negative value ranging from -10dBm to -80dBm. It is possible for this value to be positive, but that would be rare, and would signal an exceptionally strong signal. (This value divided by ccPortalRxRssiNumPkts yields the average Signal value for all packets received from this Portal).')
ccPortalBackgroundNoiseSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 1, 1, 20), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalBackgroundNoiseSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccPortalBackgroundNoiseSumSquares.setDescription('A sum of the squares of each Signal value calculated for packets received via this Portal. Unlike _SignalSum, this value is never negative, since the square of a negative number is a positive. (This value can be used to calculate the standard deviation for Signal values calculated for packets from this Portal).')
ccPortalLastMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalLastMac.setStatus('current')
if mibBuilder.loadTexts: ccPortalLastMac.setDescription('This scalar records the MAC address of the most recent Portal to be Adopted, UnAdopted, or Denied.')
ccPortalLastReason = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("success", 1), ("aclViolation", 2), ("timeout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalLastReason.setStatus('current')
if mibBuilder.loadTexts: ccPortalLastReason.setDescription('This value notes the reason for the most-recent Portal UnAdoption or Denial.')
ccPortalAdoptionTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4), )
if mibBuilder.loadTexts: ccPortalAdoptionTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionTable.setDescription("Table describing which WLANs are eligible to adopt a new portal. The illegal MAC address value of 'FF:FF:FF:FF:FF:FF' is used in both _StartMac and _EndMac fields to indicate the special row used to declare 'default' behavior. That is, if no other row in the table applies, which WLANs are eligible to adopt the portal. This one special row cannot be deleted.")
ccPortalAdoptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionIndex"))
if mibBuilder.loadTexts: ccPortalAdoptionEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionEntry.setDescription(' ')
ccPortalAdoptionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccPortalAdoptionIndex.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionIndex.setDescription('Table that describes which portals can be adopted by which WLANs.')
ccPortalAdoptionStartMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalAdoptionStartMac.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionStartMac.setDescription('Starting MAC address of range of MAC addresses.')
ccPortalAdoptionEndMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalAdoptionEndMac.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionEndMac.setDescription('Ending MAC address of range of MAC addresses.')
ccPortalAdoptionWlanPointers = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1, 4), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalAdoptionWlanPointers.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionWlanPointers.setDescription("Pointer to zero or more WLANs which are eligible to adopt portals whose MAC address falls within the specified range. Any WLAN selected by this value must first be removed from the 'default' row first. Note that to make an adoption rule apply to more than one WLAN, you must create multiple rows in this table. (This is due to the way the adoption rules are stored inside the switch). ")
ccPortalAdoptionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 4, 1, 5), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalAdoptionRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccPortalAdoptionRowStatus.setDescription('Simple row status.')
ccPortalSystemStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5), )
if mibBuilder.loadTexts: ccPortalSystemStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsTable.setDescription('This table includes statistics for 802.11 system packets transmitted/received at each Portal.')
ccPortalSystemStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalSystemStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsEntry.setDescription(' ')
ccPortalSystemStatsBeaconsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsBeaconsTx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsBeaconsTx.setDescription('The number of Beacons sent.')
ccPortalSystemStatsBeaconsTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsBeaconsTxOctets.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsBeaconsTxOctets.setDescription('The number of octets sent in Beacons.')
ccPortalSystemStatsProbeReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeReqRx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeReqRx.setDescription('The number of Probe Request packets received.')
ccPortalSystemStatsProbeReqRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeReqRxOctets.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeReqRxOctets.setDescription('The number of octets received in Probe Request packets.')
ccPortalSystemStatsProbeRespRetriesNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetriesNone.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetriesNone.setDescription('The number of Probe Response packets sent with no retries.')
ccPortalSystemStatsProbeRespRetries1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries1.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries1.setDescription('The number of Probe Response packets sent with exactly 1 retry.')
ccPortalSystemStatsProbeRespRetries2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries2.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries2.setDescription('The number of Probe Response packets sent with exactly 2 retries.')
ccPortalSystemStatsProbeRespRetries3OrMore = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries3OrMore.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetries3OrMore.setDescription('The number of Probe Response packets sent with exactly 3 retries or more retries. ')
ccPortalSystemStatsProbeRespRetriesFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetriesFailed.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespRetriesFailed.setDescription('The number of Probe Response packets that were never successfully transmitted because the max retry count was reached.')
ccPortalSystemStatsProbeRespTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 5, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespTxOctets.setStatus('current')
if mibBuilder.loadTexts: ccPortalSystemStatsProbeRespTxOctets.setDescription('The number of octets successfully transmitted in Probe Response packets. (For example, the octets in a Probe Response that is transmitted twice - one retry - only counts once in this sum).')
ccPortalSettingsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6), )
if mibBuilder.loadTexts: ccPortalSettingsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsTable.setDescription('Use ccPortalSettingsTable to view and set the properties of the Access Ports. ')
ccPortalSettingsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalSettingsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsEntry.setDescription(' ')
ccPortalSettingsName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsName.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsName.setDescription('Name of Access Port.')
ccPortalSettingsLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsLocation.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsLocation.setDescription('Site location of Access Port.')
ccPortalSettingsAntenna = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullDiversity", 1), ("primaryOnly", 2), ("secondaryOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsAntenna.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsAntenna.setDescription('The antenna diversity setting for the access port.')
ccPortalSettingsShortPreamble = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsShortPreamble.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsShortPreamble.setDescription('Enable support for Short Preamble when MUs associate with the Access Port. Enabling Short Preamble may cause incompatibility with some older clients.')
ccPortalSettingsUniSpread = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsUniSpread.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsUniSpread.setDescription('Eable the Uniform Spreading feature of the AP300. To comply with Dynamic Frequency Selection(DFS) requirements in the European Union, the 802.11a radio on AP300 Access Ports will come up on a random channel each time it is powered on.')
ccPortalSettingsRtsThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsRtsThresh.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsRtsThresh.setDescription("The Request To Send(RTS) threshold(in bytes) for use by the WLAN's adopted Access Port.")
ccPortalSettingsBeaconInt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsBeaconInt.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsBeaconInt.setDescription('Specify a beacon interval in units of 1,000 microseconds (K-us). This is a multiple of the DTIM (ccPortalCfgDefaultADtimPrd) value, for example, 100 : 10. ')
ccPortalSettingsDtimPrd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDtimPrd.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDtimPrd.setDescription('Specify a period for the Delivery Traffic Indication Message (DTIM). This is a divisor of the beacon interval (in milliseconds), for example, 10 : 100. ')
ccPortalSettingsSecBeacon = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsSecBeacon.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsSecBeacon.setDescription('Enable the Secure Beacon checkbox to disallow the Access Port from broadcasting an ESSID in its beacons. This is a safeguard to prevent intruders from tapping into the WLAN. Consider this security measure for a private, corporate network.')
ccPortalSettingsPriWlan = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 10), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsPriWlan.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsPriWlan.setDescription('Associate a primary WLAN with the Access Port for broadcast of the Extended Service Set Identification (ESSID). The purpose of such broadcasting is to allow mobile units to identify Access Ports that are associated with the WLAN.')
ccPortalSettingsBasicRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 11), TransmitRate()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsBasicRates.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsBasicRates.setDescription('List of basic rates for the radio.')
ccPortalSettingsSupportedRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 12), TransmitRate()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsSupportedRates.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsSupportedRates.setDescription('List of supported rates for the radio.')
ccPortalSettingsBGMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("modeBandG", 1), ("modeG", 2), ("modeB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsBGMode.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsBGMode.setDescription('Radio mode.')
ccPortalSettingsAdoptedWlan = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 14), MultiPointer63()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSettingsAdoptedWlan.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsAdoptedWlan.setDescription('Enable the bits for the WLANs you wish to associate the Access Port with.')
ccPortalSettingsDetector = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 6, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDetector.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDetector.setDescription('Description.')
ccPortalCfgRadioTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7), )
if mibBuilder.loadTexts: ccPortalCfgRadioTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioTable.setDescription('Use ccPortalCfgRadioTable to view and set the radio properties of the Access Ports. The process can be broken down into the following steps: 1. Set ccPortalCfgRadioReset to TRUE. 2. Set ccPortalCfgRadioDesPlacement 3. Get ccPortalCfgRadioPosChannel 4. Set ccPortalCfgRadioDesChannel 5. Get ccPortalCfgRadioPosPowerLevel 6. Set ccPortalCfgRadioDesPowerLevel 7. Get ccPortalCfgRadioPowerInMW 8. Set and pull progress of ccPortalCfgRadioSet 9. Validate the configuration has been set by getting ccPortalCfgRadioPlacement ccPortalCfgRadioChannel ccPortalCfgRadioPowerLevel ')
ccPortalCfgRadioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalCfgRadioEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioEntry.setDescription(' ')
ccPortalCfgRadioDesPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("indoor", 1), ("outdoor", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDesPlacement.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDesPlacement.setDescription('The desired placement for radio.')
ccPortalCfgRadioPosChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 2), Bits().clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 12), ("achannel40", 13), ("achannel44", 14), ("achannel48", 15), ("achannel52", 16), ("achannel56", 17), ("achannel60", 18), ("achannel64", 19), ("achannel149", 20), ("achannel153", 21), ("achannel157", 22), ("achannel161", 23)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioPosChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioPosChannel.setDescription('The possible channels that can be set when placement = ccPortalCfgRadioDesPlacement.')
ccPortalCfgRadioDesChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161))).clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 36), ("achannel40", 40), ("achannel44", 44), ("achannel48", 48), ("achannel52", 52), ("achannel56", 56), ("achannel60", 60), ("achannel64", 64), ("achannel149", 149), ("achannel153", 153), ("achannel157", 157), ("achannel161", 161)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDesChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDesChannel.setDescription('The desired channel for radio.')
ccPortalCfgRadioPosPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioPosPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioPosPowerLevel.setDescription('The max possible power level (dBm) that can be set when channel= ccPortalCfgRadioDesChannel.')
ccPortalCfgRadioDesPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDesPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDesPowerLevel.setDescription('The desired power level (dBm) for radio.')
ccPortalCfgRadioDesPowerInMW = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDesPowerInMW.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDesPowerInMW.setDescription('ccPortalCfgRadioDesPowerLevel in mW.')
ccPortalCfgRadioSet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 7), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioSet.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioSet.setDescription('Validate values in ccPortalCfgRadioDes_ fields. If it is a valid combination, configure the switch with this combination and set ccPortalCfgRadio_ to these values.')
ccPortalCfgRadioReset = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 8), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioReset.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioReset.setDescription('Reset the following OIDs. ccPortalCfgRadioDesPlacement ccPortalCfgRadioDesChannel ccPortalCfgRadioDesPowerLevel ccPortalCfgRadioPosChannel ccPortalCfgRadioPosPowerLevel ccPortalCfgRadioPowerInMW ')
ccPortalCfgRadioPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("indoor", 1), ("outdoor", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioPlacement.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioPlacement.setDescription('The placement configuration for radio.')
ccPortalCfgRadioChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161))).clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 36), ("achannel40", 40), ("achannel44", 44), ("achannel48", 48), ("achannel52", 52), ("achannel56", 56), ("achannel60", 60), ("achannel64", 64), ("achannel149", 149), ("achannel153", 153), ("achannel157", 157), ("achannel161", 161)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioChannel.setDescription('The channel configuration for radio.')
ccPortalCfgRadioPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioPowerLevel.setDescription('The power level (dBm) configuration for radio.')
ccPortalCfgRadioPowerInMW = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 7, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioPowerInMW.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioPowerInMW.setDescription('ccPortalCfgRadioPowerLevel in mW.')
ccPortalSettingsDefaultTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8), )
if mibBuilder.loadTexts: ccPortalSettingsDefaultTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultTable.setDescription('The ccPortalSettingsDefaultsTable contains the initial settings for the Access Ports. ')
ccPortalSettingsDefaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultIndex"))
if mibBuilder.loadTexts: ccPortalSettingsDefaultEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultEntry.setDescription(' ')
ccPortalSettingsDefaultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("radioA", 1), ("radioB", 2), ("radioG", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccPortalSettingsDefaultIndex.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultIndex.setDescription('The type of the radio')
ccPortalSettingsDefaultAntenna = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullDiversity", 1), ("primaryOnly", 2), ("secondaryOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultAntenna.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultAntenna.setDescription('The antenna diversity setting for the access port.')
ccPortalSettingsDefaultShortPreamble = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultShortPreamble.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultShortPreamble.setDescription('Enable support for Short Preamble when MUs associate with the Access Port. Enabling Short Preamble may cause incompatibility with some older clients.')
ccPortalSettingsDefaultUniSpread = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultUniSpread.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultUniSpread.setDescription('Eable the Uniform Spreading feature of the AP300. To comply with Dynamic Frequency Selection(DFS) requirements in the European Union, the 802.11a radio on AP300 Access Ports will come up on a random channel each time it is powered on.')
ccPortalSettingsDefaultRtsThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultRtsThresh.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultRtsThresh.setDescription("The Request To Send(RTS) threshold(in bytes) for use by the WLAN's adopted Access Port.")
ccPortalSettingsDefaultBeaconInt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultBeaconInt.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultBeaconInt.setDescription('Specify a beacon interval in units of 1,000 microseconds (K-us). This is a multiple of the DTIM (ccPortalCfgDefaultADtimPrd) value, for example, 100 : 10. ')
ccPortalSettingsDefaultDtimPrd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultDtimPrd.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultDtimPrd.setDescription('Specify a period for the Delivery Traffic Indication Message (DTIM). This is a divisor of the beacon interval (in milliseconds), for example, 10 : 100. ')
ccPortalSettingsDefaultSecBeacon = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultSecBeacon.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultSecBeacon.setDescription('Enable the Secure Beacon checkbox to disallow the Access Port from broadcasting an ESSID in its beacons. This is a safeguard to prevent intruders from tapping into the WLAN. Consider this security measure for a private, corporate network.')
ccPortalSettingsDefaultPriWlan = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 9), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultPriWlan.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultPriWlan.setDescription('Associate a primary WLAN with the Access Port for broadcast of the Extended Service Set Identification (ESSID). The purpose of such broadcasting is to allow mobile units to identify Access Ports that are associated with the WLAN.')
ccPortalSettingsDefaultBasicRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 10), TransmitRate()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultBasicRates.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultBasicRates.setDescription('List of basic rates for the radio.')
ccPortalSettingsDefaultSupportedRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 11), TransmitRate()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultSupportedRates.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultSupportedRates.setDescription('List of supported rates for the radio.')
ccPortalSettingsDefaultBGMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("modeBandG", 1), ("modeG", 2), ("modeB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalSettingsDefaultBGMode.setStatus('current')
if mibBuilder.loadTexts: ccPortalSettingsDefaultBGMode.setDescription('Radio mode.')
ccPortalCfgRadioDefaultTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9), )
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultTable.setDescription('The ccPortalCfgRadioDefaultTable contains the initial settings for the radio settings of the Access Ports. Please refer to descriptions in ccPortalCfgRadioTable. ')
ccPortalCfgRadioDefaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultIndex"))
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultEntry.setDescription(' ')
ccPortalCfgRadioDefaultDesPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("indoor", 1), ("outdoor", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPlacement.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPlacement.setDescription('The default desired placement for radio type.')
ccPortalCfgRadioDefaultPosChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 2), Bits().clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 12), ("achannel40", 13), ("achannel44", 14), ("achannel48", 15), ("achannel52", 16), ("achannel56", 17), ("achannel60", 18), ("achannel64", 19), ("achannel149", 20), ("achannel153", 21), ("achannel157", 22), ("achannel161", 23)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPosChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPosChannel.setDescription('The possible channels that can be set when placement = ccPortalCfgRadioDefaultDesPlacement.')
ccPortalCfgRadioDefaultDesChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161))).clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 36), ("achannel40", 40), ("achannel44", 44), ("achannel48", 48), ("achannel52", 52), ("achannel56", 56), ("achannel60", 60), ("achannel64", 64), ("achannel149", 149), ("achannel153", 153), ("achannel157", 157), ("achannel161", 161)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesChannel.setDescription('The default desired channel for radio type.')
ccPortalCfgRadioDefaultPosPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPosPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPosPowerLevel.setDescription('The max possible power level (dBm) that can be set when channel= ccPortalCfgRadioDefaultDesChannel.')
ccPortalCfgRadioDefaultDesPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPowerLevel.setDescription('The desired power level (dBm) for radio.')
ccPortalCfgRadioDefaultDesPowerInMW = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPowerInMW.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultDesPowerInMW.setDescription('ccPortalCfgRadioDefaultDesPowerLevel in mW.')
ccPortalCfgRadioDefaultSet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 7), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultSet.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultSet.setDescription('Validate values in ccPortalCfgRadioDefaultDes_ fields. If it is a valid combination, configure the switch with this combination and set ccPortalCfgRadioDefault_ to these values.')
ccPortalCfgRadioDefaultReset = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 8), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultReset.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultReset.setDescription('Reset the following OIDs. ccPortalCfgRadioDefaultDesPlacement ccPortalCfgRadioDefaultDesChannel ccPortalCfgRadioDefaultDesPowerLevel ccPortalCfgRadioDefaultPosChannel ccPortalCfgRadioDefaultPosPowerLevel ccPortalCfgRadioDefaultPowerInMW ')
ccPortalCfgRadioDefaultPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("indoor", 1), ("outdoor", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPlacement.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPlacement.setDescription('The default placement configuration for radio type.')
ccPortalCfgRadioDefaultChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161))).clone(namedValues=NamedValues(("null", 0), ("bchannel01", 1), ("bchannel02", 2), ("bchannel03", 3), ("bchannel04", 4), ("bchannel05", 5), ("bchannel06", 6), ("bchannel07", 7), ("bchannel08", 8), ("bchannel09", 9), ("bchannel10", 10), ("bchannel11", 11), ("achannel36", 36), ("achannel40", 40), ("achannel44", 44), ("achannel48", 48), ("achannel52", 52), ("achannel56", 56), ("achannel60", 60), ("achannel64", 64), ("achannel149", 149), ("achannel153", 153), ("achannel157", 157), ("achannel161", 161)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultChannel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultChannel.setDescription('The default channel configuration for radio type.')
ccPortalCfgRadioDefaultPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPowerLevel.setDescription('The default power level (dBm) configuration for radio type.')
ccPortalCfgRadioDefaultPowerInMW = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 9, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPowerInMW.setStatus('current')
if mibBuilder.loadTexts: ccPortalCfgRadioDefaultPowerInMW.setDescription('ccPortalCfgRadioDefaultPowerLevel in mW.')
cc802dt1xPortAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 10))
cc802dt1xPortAuthLogin = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 10, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cc802dt1xPortAuthLogin.setStatus('current')
if mibBuilder.loadTexts: cc802dt1xPortAuthLogin.setDescription('802.1x Port Authentication username.')
cc802dt1xPortAuthPass = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 10, 2), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cc802dt1xPortAuthPass.setStatus('current')
if mibBuilder.loadTexts: cc802dt1xPortAuthPass.setDescription('802.1x Port Authentication password.')
cc802dt1xPortAuthSetAp300 = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 10, 3), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cc802dt1xPortAuthSetAp300.setStatus('current')
if mibBuilder.loadTexts: cc802dt1xPortAuthSetAp300.setDescription('Set the username and password stored in cc802dt1xPortAuthLogin and cc802dt1xPortAuthPass on all AP 300 Access Ports adopted by the switch.')
ccPortalRfSum = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100))
ccPortalStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1), )
if mibBuilder.loadTexts: ccPortalStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalStatsTable.setDescription('This table describes general statistics about packets sent/recieved via each Portal on the switch.')
ccPortalStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalStatsEntry.setDescription(' ')
ccPortalTxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsUcast.setDescription('Count of unicast packets sent via the Portal.')
ccPortalRxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsUcast.setDescription('Count of unicast packets received via the Portal.')
ccPortalRxPktsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsNUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsNUcast.setDescription('Count of non-unicast (broadcast & multicast) packets received via the Portal.')
ccPortalTxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsUcast.setDescription('Count of unicast octets sent via the Portal.')
ccPortalRxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsUcast.setDescription('Count of unicast octets received via the Portal.')
ccPortalRxOctetsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsNUcast.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsNUcast.setDescription('Count of non-unicast (broadcast & multicast) octets received via the Portal.')
ccPortalRxUndecryptablePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxUndecryptablePkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxUndecryptablePkts.setDescription('Count of packets received via the Portal that could not be decrypted.')
ccPortalLastActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 1, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalLastActivity.setStatus('current')
if mibBuilder.loadTexts: ccPortalLastActivity.setDescription("A snapshot of the switch's sysUpTime at the time of the last activity (packet sent or received) via the Portal.")
ccPortalRxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2), )
if mibBuilder.loadTexts: ccPortalRxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsTable.setDescription('For each Portal on the switch, this table describes counts of packets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccPortalRxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalRxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsEntry.setDescription(' ')
ccPortalRxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt1Mb.setDescription('Number of pkts received via this Portal at 1 Mb.')
ccPortalRxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt2Mb.setDescription('Number of pkts received via this Portal at 2 Mb.')
ccPortalRxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt5pt5Mb.setDescription('Number of pkts received via this Portal at 5.5 Mb.')
ccPortalRxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt6Mb.setDescription('Number of pkts received via this Portal at 6 Mb.')
ccPortalRxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt9Mb.setDescription('Number of pkts received via this Portal at 9 Mb.')
ccPortalRxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt11Mb.setDescription('Number of pkts received via this Portal at 11 Mb.')
ccPortalRxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt12Mb.setDescription('Number of pkts received via this Portal at 12 Mb.')
ccPortalRxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt18Mb.setDescription('Number of pkts received via this Portal at 18 Mb.')
ccPortalRxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt22Mb.setDescription('Number of pkts received via this Portal at 22 Mb.')
ccPortalRxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt24Mb.setDescription('Number of pkts received via this Portal at 24 Mb.')
ccPortalRxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt36Mb.setDescription('Number of pkts received via this Portal at 36 Mb.')
ccPortalRxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt48Mb.setDescription('Number of pkts received via this Portal at 48 Mb.')
ccPortalRxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxPktsAt54Mb.setDescription('Number of pkts received via this Portal at 54 Mb.')
ccPortalTxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3), )
if mibBuilder.loadTexts: ccPortalTxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsTable.setDescription('For each Portal on the switch, this table describes counts of packets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccPortalTxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalTxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsEntry.setDescription(' ')
ccPortalTxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt1Mb.setDescription('Number of pkts transmitted via this Portal at 1 Mb.')
ccPortalTxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt2Mb.setDescription('Number of pkts transmitted via this Portal at 2 Mb.')
ccPortalTxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt5pt5Mb.setDescription('Number of pkts transmitted via this Portal at 5.5 Mb.')
ccPortalTxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt6Mb.setDescription('Number of pkts transmitted via this Portal at 6 Mb.')
ccPortalTxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt9Mb.setDescription('Number of pkts transmitted via this Portal at 9 Mb.')
ccPortalTxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt11Mb.setDescription('Number of pkts transmitted via this Portal at 11 Mb.')
ccPortalTxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt12Mb.setDescription('Number of pkts transmitted via this Portal at 12 Mb.')
ccPortalTxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt18Mb.setDescription('Number of pkts transmitted via this Portal at 18 Mb.')
ccPortalTxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt22Mb.setDescription('Number of pkts transmitted via this Portal at 22 Mb.')
ccPortalTxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt24Mb.setDescription('Number of pkts transmitted via this Portal at 24 Mb.')
ccPortalTxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt36Mb.setDescription('Number of pkts transmitted via this Portal at 36 Mb.')
ccPortalTxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt48Mb.setDescription('Number of pkts transmitted via this Portal at 48 Mb.')
ccPortalTxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxPktsAt54Mb.setDescription('Number of pkts transmitted via this Portal at 54 Mb.')
ccPortalRxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4), )
if mibBuilder.loadTexts: ccPortalRxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsTable.setDescription('For each Portal on this switch, this table describes counts of octets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccPortalRxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalRxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsEntry.setDescription(' ')
ccPortalRxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt1Mb.setDescription('Number of octets received via this Portal at 1 Mb.')
ccPortalRxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt2Mb.setDescription('Number of octets received via this Portal at 2 Mb.')
ccPortalRxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt5pt5Mb.setDescription('Number of octets received via this Portal at 5.5 Mb.')
ccPortalRxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt6Mb.setDescription('Number of octets received via this Portal at 6 Mb.')
ccPortalRxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt9Mb.setDescription('Number of octets received via this Portal at 9 Mb.')
ccPortalRxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt11Mb.setDescription('Number of octets received via this Portal at 11 Mb.')
ccPortalRxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt12Mb.setDescription('Number of octets received via this Portal at 12 Mb.')
ccPortalRxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt18Mb.setDescription('Number of octets received via this Portal at 18 Mb.')
ccPortalRxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt22Mb.setDescription('Number of octets received via this Portal at 22 Mb.')
ccPortalRxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt24Mb.setDescription('Number of octets received via this Portal at 24 Mb.')
ccPortalRxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt36Mb.setDescription('Number of octets received via this Portal at 36 Mb.')
ccPortalRxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt48Mb.setDescription('Number of octets received via this Portal at 48 Mb.')
ccPortalRxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalRxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalRxOctetsAt54Mb.setDescription('Number of octets received via this Portal at 54 Mb.')
ccPortalTxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5), )
if mibBuilder.loadTexts: ccPortalTxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsTable.setDescription('For each Portal on this switch, this table describes counts of octets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccPortalTxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalTxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsEntry.setDescription(' ')
ccPortalTxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt1Mb.setDescription('Number octets transmitted via this Portal at 1 Mb.')
ccPortalTxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt2Mb.setDescription('Number octets transmitted via this Portal at 2 Mb.')
ccPortalTxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt5pt5Mb.setDescription('Number octets transmitted via this Portal at 5.5 Mb.')
ccPortalTxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt6Mb.setDescription('Number octets transmitted via this Portal at 6 Mb.')
ccPortalTxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt9Mb.setDescription('Number octets transmitted via this Portal at 9 Mb.')
ccPortalTxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt11Mb.setDescription('Number octets transmitted via this Portal at 11 Mb.')
ccPortalTxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt12Mb.setDescription('Number octets transmitted via this Portal at 12 Mb.')
ccPortalTxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt18Mb.setDescription('Number octets transmitted via this Portal at 18 Mb.')
ccPortalTxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt22Mb.setDescription('Number octets transmitted via this Portal at 22 Mb.')
ccPortalTxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt24Mb.setDescription('Number octets transmitted via this Portal at 24 Mb.')
ccPortalTxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt36Mb.setDescription('Number octets transmitted via this Portal at 36 Mb.')
ccPortalTxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt48Mb.setDescription('Number octets transmitted via this Portal at 48 Mb.')
ccPortalTxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxOctetsAt54Mb.setDescription('Number octets transmitted via this Portal at 54 Mb.')
ccPortalTxRetriesPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6), )
if mibBuilder.loadTexts: ccPortalTxRetriesPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPktsTable.setDescription('For each Portal on the switch, this table describes counts of the number of packets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccPortalTxRetriesPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalTxRetriesPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPktsEntry.setDescription(' ')
ccPortalTxRetriesPktsNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPktsNone.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPktsNone.setDescription('Number of pkts successfully transmitted via this Portal with no retries.')
ccPortalTxRetriesPkts01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts01.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts01.setDescription('Number of pkts successfully transmitted via this Portal with exactly 1 retry.')
ccPortalTxRetriesPkts02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts02.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts02.setDescription('Number of pkts successfully transmitted via this Portal with exactly 2 retries.')
ccPortalTxRetriesPkts03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts03.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts03.setDescription('Number of pkts successfully transmitted via this Portal with exactly 3 retries.')
ccPortalTxRetriesPkts04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts04.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts04.setDescription('Number of pkts successfully transmitted via this Portal with exactly 4 retries.')
ccPortalTxRetriesPkts05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts05.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts05.setDescription('Number of pkts successfully transmitted via this Portal with exactly 5 retries.')
ccPortalTxRetriesPkts06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts06.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts06.setDescription('Number of pkts successfully transmitted via this Portal with exactly 6 retries.')
ccPortalTxRetriesPkts07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts07.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts07.setDescription('Number of pkts successfully transmitted via this Portal with exactly 7 retries.')
ccPortalTxRetriesPkts08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts08.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts08.setDescription('Number of pkts successfully transmitted via this Portal with exactly 8 retries.')
ccPortalTxRetriesPkts09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts09.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts09.setDescription('Number of pkts successfully transmitted via this Portal with exactly 9 retries.')
ccPortalTxRetriesPkts10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts10.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts10.setDescription('Number of pkts successfully transmitted via this Portal with exactly 10 retries.')
ccPortalTxRetriesPkts11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts11.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts11.setDescription('Number of pkts successfully transmitted via this Portal with exactly 11 retries.')
ccPortalTxRetriesPkts12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts12.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts12.setDescription('Number of pkts successfully transmitted via this Portal with exactly 12 retries.')
ccPortalTxRetriesPkts13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts13.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts13.setDescription('Number of pkts successfully transmitted via this Portal with exactly 13 retries.')
ccPortalTxRetriesPkts14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts14.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts14.setDescription('Number of pkts successfully transmitted via this Portal with exactly 14 retries.')
ccPortalTxRetriesPkts15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPkts15.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPkts15.setDescription('Number of pkts successfully transmitted via this Portal with exactly 15 retries.')
ccPortalTxRetriesPktsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesPktsFailed.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesPktsFailed.setDescription('Number of pkts that never were successfully transmitted to via this Portal because the max retry count was exceeded.')
ccPortalTxRetriesOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7), )
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsTable.setDescription('For each Portal on the switch, this table describes counts of the number of octets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccPortalTxRetriesOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsEntry.setDescription(' ')
ccPortalTxRetriesOctetsNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsNone.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsNone.setDescription('Number of octets successfully transmitted via this Portal with no retries.')
ccPortalTxRetriesOctets01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets01.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets01.setDescription('Number of octets successfully transmitted via this Portal with exactly 1 retry.')
ccPortalTxRetriesOctets02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets02.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets02.setDescription('Number of octets successfully transmitted via this Portal with exactly 2 retries.')
ccPortalTxRetriesOctets03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets03.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets03.setDescription('Number of octets successfully transmitted via this Portal with exactly 3 retries.')
ccPortalTxRetriesOctets04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets04.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets04.setDescription('Number of octets successfully transmitted via this Portal with exactly 4 retries.')
ccPortalTxRetriesOctets05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets05.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets05.setDescription('Number of octets successfully transmitted via this Portal with exactly 5 retries.')
ccPortalTxRetriesOctets06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets06.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets06.setDescription('Number of octets successfully transmitted via this Portal with exactly 6 retries.')
ccPortalTxRetriesOctets07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets07.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets07.setDescription('Number of octets successfully transmitted via this Portal with exactly 7 retries.')
ccPortalTxRetriesOctets08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets08.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets08.setDescription('Number of octets successfully transmitted via this Portal with exactly 8 retries.')
ccPortalTxRetriesOctets09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets09.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets09.setDescription('Number of octets successfully transmitted via this Portal with exactly 9 retries.')
ccPortalTxRetriesOctets10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets10.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets10.setDescription('Number of octets successfully transmitted via this Portal with exactly 10 retries.')
ccPortalTxRetriesOctets11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets11.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets11.setDescription('Number of octets successfully transmitted via this Portal with exactly 11 retries.')
ccPortalTxRetriesOctets12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets12.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets12.setDescription('Number of octets successfully transmitted via this Portal with exactly 12 retries.')
ccPortalTxRetriesOctets13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets13.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets13.setDescription('Number of octets successfully transmitted via this Portal with exactly 13 retries.')
ccPortalTxRetriesOctets14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets14.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets14.setDescription('Number of octets successfully transmitted via this Portal with exactly 14 retries.')
ccPortalTxRetriesOctets15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctets15.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctets15.setDescription('Number of octets successfully transmitted via this Portal with exactly 15 retries.')
ccPortalTxRetriesOctetsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsFailed.setStatus('current')
if mibBuilder.loadTexts: ccPortalTxRetriesOctetsFailed.setDescription('Number of octets that never were successfully transmitted to via this Portal because the max retry count was exceeded.')
ccPortalSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8), )
if mibBuilder.loadTexts: ccPortalSigStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsTable.setDescription('This table describes statistics about RSSI, Signal, Noise, and SNR for packets recieved via each Portal on the switch.')
ccPortalSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalSigStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsEntry.setDescription(' ')
ccPortalSigStatsNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNumPkts.setDescription('Total packets received via the Portal included in all the other counters reported in this row.')
ccPortalSigStatsSignalBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 2), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSignalBest.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSignalBest.setDescription('The best Signal value seen from the Portal so far. (Remember that a -20dBm Signal is better than -60dBm). This value is initialized to -500dBm. ')
ccPortalSigStatsSignalWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 3), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSignalWorst.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSignalWorst.setDescription('The worst Signal value seen from the Portal so far. (Remember that a -80dBm Signal is worse than -60dBm). This value is initialized to 500dBm.')
ccPortalSigStatsSignalSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 4), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSignalSum.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSignalSum.setDescription('A running sum of all Signal values calculated by the switch (using reported RSSI values), for packets received via this Portal. Note that this value is normally a negative value ranging from -10dBm to -80dBm. It is possible for this value to be positive, but that would be rare, and would signal an exceptionally strong signal. (This value divided by ccPortalSigStatsNumPkts yields the average Signal value for all packets received from this MU).')
ccPortalSigStatsSignalSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 5), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSignalSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSignalSumSquares.setDescription('A sum of the squares of each Signal value calculated for packets received via this Portal. Unlike _SignalSum, this value is never negative, since the square of a negative number is a positive. (This value can be used to calculate the standard deviation for Signal values calculated for packets from this Portal).')
ccPortalSigStatsSignalMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 6), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSignalMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSignalMostRecent.setDescription('The best Signal value seen from the Portal so far. (Remember that a -20dBm Signal is better than -60dBm). This value does not make sense when ccPortalSigStatsNumPkts equals to 0.')
ccPortalSigStatsNoiseBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 7), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNoiseBest.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNoiseBest.setDescription('The best Noise value seen from the Portal so far. (Remember that -80dBm Noise is better than -70dBm). This value is initialized to 500dBm.')
ccPortalSigStatsNoiseWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 8), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNoiseWorst.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNoiseWorst.setDescription('The worst Noise value seen from the Portal so far. (Remember that -50dBm Noise is worse than -60dBm). This value is initialized to -500dBm.')
ccPortalSigStatsNoiseSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 9), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNoiseSum.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNoiseSum.setDescription('A running sum of all Noise values calculated by the switch (using reported RSSI values), for packets received via this Portal. Like _SignalSum, this value is normally a negative value. (This value divided by ccPortalSigStatsNumPkts yields the average Noise value for all packets received from this MU).')
ccPortalSigStatsNoiseSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 10), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNoiseSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNoiseSumSquares.setDescription('A sum of the squares of each Noise value calculated for packets received via this Portal. As with _SignalSumSquares, this value is never negative. (This value can be used to calculate the standard deviation for Noise values calculated for packets from this Portal).')
ccPortalSigStatsNoiseMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsNoiseMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsNoiseMostRecent.setDescription('The best Noise value seen from the Portal so far. (Remember that -80dBm Noise is better than -70dBm). This value does not make sense when ccPortalSigStatsNumPkts equals to 0.')
ccPortalSigStatsSnrBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSnrBest.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSnrBest.setDescription('The best SNR value seen from the Portal so far. (Remember that +30dBm SNR is better than +20dBm). This value is initialized to -500dB.')
ccPortalSigStatsSnrWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 13), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSnrWorst.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSnrWorst.setDescription('The worst SNR value seen from the Portal so far. (Remember that +10dBm SNR is worse than +20dBm). This value is initialized to 500dB.')
ccPortalSigStatsSnrSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 14), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSnrSum.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSnrSum.setDescription('A running sum of all SNR values calculated by the switch (using reported RSSI values), for packets received via this Portal. Unlike _Signal and _Noise, this value is never negative. (This value divided by ccPortalSigStatsNumPkts yields the average SNR value for all packets received from this MU).')
ccPortalSigStatsSnrSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 15), Counter64()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSnrSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSnrSumSquares.setDescription('A sum of the squares of each SNR value calculated for packets received via this Portal. This value is never negative. (This value can be used to calculate the standard deviation for SNR values calculated for packets from this Portal).')
ccPortalSigStatsSnrMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 8, 1, 16), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSigStatsSnrMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccPortalSigStatsSnrMostRecent.setDescription('The best SNR value seen from the Portal so far. (Remember that +30dBm SNR is better than +20dBm). This value does not make sense when ccPortalSigStatsNumPkts equals to 0.')
ccPortalSumStatsShortTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9), )
if mibBuilder.loadTexts: ccPortalSumStatsShortTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortTable.setDescription('Averages and rates calculated over the SHORT window for each Portal.')
ccPortalSumStatsShortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalSumStatsShortEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortEntry.setDescription(' ')
ccPortalSumStatsShortTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortTimestamp.setDescription("Snapshot of sysUpTime as of the END of the 'window' of time that this entry of values represents.")
ccPortalSumStatsShortNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortNumPkts.setDescription('The number of packets used to calculate the statistics in this window.')
ccPortalSumStatsShortPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSec100.setDescription("Packets per second as averaged over the 'window'. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccPortalSumStatsShortPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSecTx100.setDescription("Packets per second TX as averaged over the 'window'. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccPortalSumStatsShortPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPktsPerSecRx100.setDescription("Packets per second RX as averaged over the 'window'. Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccPortalSumStatsShortThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughput.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughput.setDescription('Actual number of bits sent and received over the window, divided by the number of seconds in the window. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccPortalSumStatsShortThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughputTx.setDescription('Actual number of bits TX over the window, divided by the number of seconds in the window. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccPortalSumStatsShortThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortThroughputRx.setDescription('Actual number of bits RX over the window, divided by the number of seconds in the window.')
ccPortalSumStatsShortAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgBitSpeed.setDescription('An octet-weighted average of the speeds of all packets sent/received. (For each possible speed, multiply the number of octets sent/received by that speed; divide the sum by the total number of octets; multiply by 8). For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). This can be said in more plain english as: the average bit-speed at which packets were sent/received.')
ccPortalSumStatsShortAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuSignal.setDescription('The average of all signal values over the window. NOTE: dBm are normally negative. Here the NEGATIVE values are reported as POSITIVE values. PO')
ccPortalSumStatsShortAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuNoise.setDescription('The average of all noise values over the window.')
ccPortalSumStatsShortAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortAvgMuSnr.setDescription('The average of all SNR values over the window.')
ccPortalSumStatsShortPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kNUcastPkts.setDescription('Ratio of packets that were NOT unicast. Expressed as parts-per-10000. ')
ccPortalSumStatsShortPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kTxWithRetries.setDescription('Ratio of TX packets that experienced one or more retries. Expressed as parts-per-10000. ')
ccPortalSumStatsShortPp10kTxMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kTxMaxRetries.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kTxMaxRetries.setDescription('Ratio of TX packets that were dropped due to excessive. Expressed as parts-per-10000. ')
ccPortalSumStatsShortTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortTxAvgRetries100.setDescription('For all transmit packets (those that experienced some retries, those that were successfully transmitted with only 1 transmission, and those that attempted max times and gave-up), the average number of RE-transmission attempts. Said another (though identical) way: the sum of all tranmission attempts divided by the number of unique packets attempted to be sent. Since SNMP does not convey decimal values, the result above is multiplied by 100. If there were no RE-transmissions, this value would be 0. If every single packet required exactly two tranmissions, this value would be 100, (representing 1.00).')
ccPortalSumStatsShortPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kRxUndecrypt.setDescription('Ratio of RX packets that were undecryptable. Expressed as parts-per-10000. ')
ccPortalSumStatsShortTotalMus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('number of MUs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortTotalMus.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortTotalMus.setDescription('The total number of MUs associated to the given Portal.')
ccPortalSumStatsShortPp10kRfUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 9, 1, 19), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kRfUtil.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsShortPp10kRfUtil.setDescription("The approximate utilization of the Portal's RF port. Calculated as Throughput divided by AvgBitSpeed. Expressed as parts-per-10000. ")
ccPortalSumStatsLongTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10), )
if mibBuilder.loadTexts: ccPortalSumStatsLongTable.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongTable.setDescription('Averages and rates calculated over the LONG window for each Portal. (Refer to ccPortalSumStatsShortTable for descriptions).')
ccPortalSumStatsLongEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccPortalSumStatsLongEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongEntry.setDescription(' ')
ccPortalSumStatsLongTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongTimestamp.setDescription(' ')
ccPortalSumStatsLongNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongNumPkts.setDescription(' ')
ccPortalSumStatsLongPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSec100.setDescription(' ')
ccPortalSumStatsLongPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSecTx100.setDescription(' ')
ccPortalSumStatsLongPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPktsPerSecRx100.setDescription(' ')
ccPortalSumStatsLongThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughput.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughput.setDescription(' ')
ccPortalSumStatsLongThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughputTx.setDescription(' ')
ccPortalSumStatsLongThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongThroughputRx.setDescription(' ')
ccPortalSumStatsLongAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgBitSpeed.setDescription(' ')
ccPortalSumStatsLongAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuSignal.setDescription(' ')
ccPortalSumStatsLongAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuNoise.setDescription(' ')
ccPortalSumStatsLongAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongAvgMuSnr.setDescription(' ')
ccPortalSumStatsLongPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kNUcastPkts.setDescription(' ')
ccPortalSumStatsLongPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kTxWithRetries.setDescription(' ')
ccPortalSumStatsLongPp10kTxMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kTxMaxRetries.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kTxMaxRetries.setDescription(' ')
ccPortalSumStatsLongTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongTxAvgRetries100.setDescription(' ')
ccPortalSumStatsLongPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kRxUndecrypt.setDescription(' ')
ccPortalSumStatsLongTotalMus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('number of MUs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongTotalMus.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongTotalMus.setDescription(' ')
ccPortalSumStatsLongPp10kRfUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 2, 100, 10, 1, 19), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kRfUtil.setStatus('current')
if mibBuilder.loadTexts: ccPortalSumStatsLongPp10kRfUtil.setDescription(' ')
ccAssociation = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3))
ccAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3, 1), )
if mibBuilder.loadTexts: ccAssociationTable.setStatus('current')
if mibBuilder.loadTexts: ccAssociationTable.setDescription('This table contains one entry for each Portal-MU association.')
ccAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccAssociationEntry.setStatus('current')
if mibBuilder.loadTexts: ccAssociationEntry.setDescription(' ')
ccAssociationFirstAssociate = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAssociationFirstAssociate.setStatus('current')
if mibBuilder.loadTexts: ccAssociationFirstAssociate.setDescription("A snapshot of the switch's sysUpTime at the time of the first time this MU associated to this Portal.")
ccAssociationLastAssociate = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAssociationLastAssociate.setStatus('current')
if mibBuilder.loadTexts: ccAssociationLastAssociate.setDescription("A snapshot of the switch's sysUpTime at the time of the time this MU most recently associated to this Portal.")
ccAssociationCountAssociates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAssociationCountAssociates.setStatus('current')
if mibBuilder.loadTexts: ccAssociationCountAssociates.setDescription('A count of the total number of times this MU has associated to this Portal.')
ccMus = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4))
ccMuInfoTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1), )
if mibBuilder.loadTexts: ccMuInfoTable.setStatus('current')
if mibBuilder.loadTexts: ccMuInfoTable.setDescription('This table describes general information about each MU serviced by the switch.')
ccMuInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuInfoEntry.setDescription(' ')
ccMuMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuMac.setStatus('current')
if mibBuilder.loadTexts: ccMuMac.setDescription('MAC address of the MU.')
ccMuWlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuWlanIndex.setStatus('current')
if mibBuilder.loadTexts: ccMuWlanIndex.setDescription('(Reserved for future implementation).')
ccMuWlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuWlanName.setStatus('current')
if mibBuilder.loadTexts: ccMuWlanName.setDescription('The name of the WLAN this MU is associated to.')
ccMuIsDataReady = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuIsDataReady.setStatus('current')
if mibBuilder.loadTexts: ccMuIsDataReady.setDescription("This value is true if the WS2000 is ready to forward/switch packets to/from this MU, (internally called the 'data ready' state). Otherwise this value is false.")
ccMuPortalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuPortalIndex.setStatus('current')
if mibBuilder.loadTexts: ccMuPortalIndex.setDescription('The index of the entry in the PortalTable to which this MU is associated.')
ccMuPortalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuPortalMac.setStatus('current')
if mibBuilder.loadTexts: ccMuPortalMac.setDescription('The MAC address of the Portal to which this MU is associated.')
ccMuSymbolRogueApEna = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSymbolRogueApEna.setStatus('current')
if mibBuilder.loadTexts: ccMuSymbolRogueApEna.setDescription("If true, this MU supports Symbol's Rogue AP detection assist algorithm.")
ccMuIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccMuIpAddr.setDescription('IP address of the MU.')
ccMuType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("voice", 2), ("accessPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuType.setStatus('current')
if mibBuilder.loadTexts: ccMuType.setDescription('Type of the MU.')
ccMuRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 10), RadioType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRadioType.setStatus('current')
if mibBuilder.loadTexts: ccMuRadioType.setDescription('Radio type of the MU.')
ccMuSupportedRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 11), Bits().clone(namedValues=NamedValues(("supports1Mb", 0), ("supports2Mb", 1), ("supports5dot5Mb", 2), ("supports6Mb", 3), ("supports9Mb", 4), ("supports11Mb", 5), ("supports12Mb", 6), ("supports18Mb", 7), ("supports22Mb", 8), ("supports24Mb", 9), ("supports36Mb", 10), ("supports48Mb", 11), ("supports54Mb", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSupportedRates.setStatus('current')
if mibBuilder.loadTexts: ccMuSupportedRates.setDescription('A bit-mask of rates supported by this MU.')
ccMuPowerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("continuousAccessMode", 1), ("powerSavePolling", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuPowerMode.setStatus('current')
if mibBuilder.loadTexts: ccMuPowerMode.setDescription("Power-mode implemented by the MU. A MU's status will constantly switch between PSP and CAM mode when it is in PSP mode. ")
ccMuAuthenticationMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("eap802dot1x", 2), ("kerberos", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuAuthenticationMethod.setStatus('current')
if mibBuilder.loadTexts: ccMuAuthenticationMethod.setDescription('Authentication method implemented by the MU.')
ccMuEncryptionMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("wep40", 2), ("wep128", 3), ("keyGuardMCM", 4), ("wpaTKIP", 5), ("wpa2AesCcmp", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuEncryptionMethod.setStatus('current')
if mibBuilder.loadTexts: ccMuEncryptionMethod.setDescription('Encryption method implemented by the MU.')
ccMuVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuVlanId.setStatus('current')
if mibBuilder.loadTexts: ccMuVlanId.setDescription('The VLAN that this MU is assigned to. ')
ccMuStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2), )
if mibBuilder.loadTexts: ccMuStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuStatsTable.setDescription('This table describes general statistics about packets sent/recieved via each MU serviced by the switch.')
ccMuStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuStatsEntry.setDescription(' ')
ccMuTxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsUcast.setDescription('Count of unicast packets sent.')
ccMuRxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsUcast.setDescription('Count of unicast packets received.')
ccMuRxPktsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsNUcast.setStatus('obsolete')
if mibBuilder.loadTexts: ccMuRxPktsNUcast.setDescription('Count of non-unicast (broadcast & multicast) packets received.')
ccMuTxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsUcast.setDescription('Count of unicast octets sent.')
ccMuRxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsUcast.setDescription('Count of unicast octets received.')
ccMuRxOctetsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsNUcast.setStatus('obsolete')
if mibBuilder.loadTexts: ccMuRxOctetsNUcast.setDescription('Count of non-unicast (broadcast & multicast) octets received.')
ccMuRxUndecryptablePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxUndecryptablePkts.setStatus('current')
if mibBuilder.loadTexts: ccMuRxUndecryptablePkts.setDescription('Count of packets received that could not be decrypted.')
ccMuRxRssiNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxRssiNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuRxRssiNumPkts.setDescription('Total RSSI packets received.')
ccMuRxRssiSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxRssiSum.setStatus('current')
if mibBuilder.loadTexts: ccMuRxRssiSum.setDescription('A running sum of all RSSI values calculated by the switch for packets.')
ccMuRxRssiSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxRssiSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccMuRxRssiSumSquares.setDescription('A sum of the squares of each RSSI value calculated for packets received. This value is never negative.')
ccMuRxRssiMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxRssiMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccMuRxRssiMostRecent.setDescription('The best RSSI value seen so far. (Remember that -80dBm Noise is better than -70dBm). This value does not make sense when ccMuRxRssiNumPkts equals to 0.')
ccMuLastActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuLastActivity.setStatus('current')
if mibBuilder.loadTexts: ccMuLastActivity.setDescription("A snapshot of the switch's sysUpTime at the time of the last activity (packet sent or received).")
ccMuRxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3), )
if mibBuilder.loadTexts: ccMuRxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsTable.setDescription('For each MU serviced by the switch, this table describes counts of packets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccMuRxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuRxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsEntry.setDescription(' ')
ccMuRxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt1Mb.setDescription('Number of pkts received at 1 Mb.')
ccMuRxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt2Mb.setDescription('Number of pkts received at 2 Mb.')
ccMuRxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt5pt5Mb.setDescription('Number of pkts received at 5.5 Mb.')
ccMuRxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt6Mb.setDescription('Number of pkts received at 6 Mb.')
ccMuRxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt9Mb.setDescription('Number of pkts received at 9 Mb.')
ccMuRxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt11Mb.setDescription('Number of pkts received at 11 Mb.')
ccMuRxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt12Mb.setDescription('Number of pkts received at 12 Mb.')
ccMuRxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt18Mb.setDescription('Number of pkts received at 18 Mb.')
ccMuRxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt22Mb.setDescription('Number of pkts received at 22 Mb.')
ccMuRxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt24Mb.setDescription('Number of pkts received at 24 Mb.')
ccMuRxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt36Mb.setDescription('Number of pkts received at 36 Mb.')
ccMuRxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt48Mb.setDescription('Number of pkts received at 48 Mb.')
ccMuRxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxPktsAt54Mb.setDescription('Number of pkts received at 54 Mb.')
ccMuTxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4), )
if mibBuilder.loadTexts: ccMuTxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsTable.setDescription('For each MU serviced by the switch, this table describes counts of packets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccMuTxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuTxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsEntry.setDescription(' ')
ccMuTxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt1Mb.setDescription('Number of pkts transmitted at 1 Mb.')
ccMuTxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt2Mb.setDescription('Number of pkts transmitted at 2 Mb.')
ccMuTxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt5pt5Mb.setDescription('Number of pkts transmitted at 5.5 Mb.')
ccMuTxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt6Mb.setDescription('Number of pkts transmitted at 6 Mb.')
ccMuTxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt9Mb.setDescription('Number of pkts transmitted at 9 Mb.')
ccMuTxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt11Mb.setDescription('Number of pkts transmitted at 11 Mb.')
ccMuTxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt12Mb.setDescription('Number of pkts transmitted at 12 Mb.')
ccMuTxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt18Mb.setDescription('Number of pkts transmitted at 18 Mb.')
ccMuTxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt22Mb.setDescription('Number of pkts transmitted at 22 Mb.')
ccMuTxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt24Mb.setDescription('Number of pkts transmitted at 24 Mb.')
ccMuTxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt36Mb.setDescription('Number of pkts transmitted at 36 Mb.')
ccMuTxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt48Mb.setDescription('Number of pkts transmitted at 48 Mb.')
ccMuTxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxPktsAt54Mb.setDescription('Number of pkts transmitted at 54 Mb.')
ccMuRxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5), )
if mibBuilder.loadTexts: ccMuRxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsTable.setDescription('For each MU serviced by this switch, this table describes counts of octets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccMuRxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuRxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsEntry.setDescription(' ')
ccMuRxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt1Mb.setDescription('Number of octets received at 1 Mb.')
ccMuRxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt2Mb.setDescription('Number of octets received at 2 Mb.')
ccMuRxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt5pt5Mb.setDescription('Number of octets received at 5.5 Mb.')
ccMuRxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt6Mb.setDescription('Number of octets received at 6 Mb.')
ccMuRxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt9Mb.setDescription('Number of octets received at 9 Mb.')
ccMuRxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt11Mb.setDescription('Number of octets received at 11 Mb.')
ccMuRxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt12Mb.setDescription('Number of octets received at 12 Mb.')
ccMuRxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt18Mb.setDescription('Number of octets received at 18 Mb.')
ccMuRxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt22Mb.setDescription('Number of octets received at 22 Mb.')
ccMuRxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt24Mb.setDescription('Number of octets received at 24 Mb.')
ccMuRxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt36Mb.setDescription('Number of octets received at 36 Mb.')
ccMuRxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt48Mb.setDescription('Number of octets received at 48 Mb.')
ccMuRxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuRxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuRxOctetsAt54Mb.setDescription('Number of octets received at 54 Mb.')
ccMuTxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6), )
if mibBuilder.loadTexts: ccMuTxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsTable.setDescription('For each MU serviced by this switch, this table describes counts of octets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccMuTxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuTxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsEntry.setDescription(' ')
ccMuTxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt1Mb.setDescription('Number of octets transmitted at 1 Mb.')
ccMuTxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt2Mb.setDescription('Number of octets transmitted at 2 Mb.')
ccMuTxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt5pt5Mb.setDescription('Number of octets transmitted at 5.5 Mb.')
ccMuTxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt6Mb.setDescription('Number of octets transmitted at 6 Mb.')
ccMuTxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt9Mb.setDescription('Number of octets transmitted at 9 Mb.')
ccMuTxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt11Mb.setDescription('Number of octets transmitted at 11 Mb.')
ccMuTxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt12Mb.setDescription('Number of octets transmitted at 12 Mb.')
ccMuTxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt18Mb.setDescription('Number of octets transmitted at 18 Mb.')
ccMuTxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt22Mb.setDescription('Number of octets transmitted at 22 Mb.')
ccMuTxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt24Mb.setDescription('Number of octets transmitted at 24 Mb.')
ccMuTxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt36Mb.setDescription('Number of octets transmitted at 36 Mb.')
ccMuTxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt48Mb.setDescription('Number of octets transmitted at 48 Mb.')
ccMuTxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccMuTxOctetsAt54Mb.setDescription('Number of octets transmitted at 54 Mb.')
ccMuTxRetriesTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7), )
if mibBuilder.loadTexts: ccMuTxRetriesTable.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesTable.setDescription('For each MU serviced by the switch, this table describes counts of the number of packets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccMuTxRetriesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuTxRetriesEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesEntry.setDescription(' ')
ccMuTxRetriesNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesNone.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesNone.setDescription('Number of pkts successfully transmitted with no retries.')
ccMuTxRetries01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries01.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries01.setDescription('Number of pkts successfully transmitted with exactly 1 retries.')
ccMuTxRetries02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries02.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries02.setDescription('Number of pkts successfully transmitted with exactly 2 retries.')
ccMuTxRetries03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries03.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries03.setDescription('Number of pkts successfully transmitted with exactly 3 retries.')
ccMuTxRetries04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries04.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries04.setDescription('Number of pkts successfully transmitted with exactly 4 retries.')
ccMuTxRetries05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries05.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries05.setDescription('Number of pkts successfully transmitted with exactly 5 retries.')
ccMuTxRetries06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries06.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries06.setDescription('Number of pkts successfully transmitted with exactly 6 retries.')
ccMuTxRetries07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries07.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries07.setDescription('Number of pkts successfully transmitted with exactly 7 retries.')
ccMuTxRetries08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries08.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries08.setDescription('Number of pkts successfully transmitted with exactly 8 retries.')
ccMuTxRetries09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries09.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries09.setDescription('Number of pkts successfully transmitted with exactly 9 retries.')
ccMuTxRetries10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries10.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries10.setDescription('Number of pkts successfully transmitted with exactly 10 retries.')
ccMuTxRetries11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries11.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries11.setDescription('Number of pkts successfully transmitted with exactly 11 retries.')
ccMuTxRetries12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries12.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries12.setDescription('Number of pkts successfully transmitted with exactly 12 retries.')
ccMuTxRetries13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries13.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries13.setDescription('Number of pkts successfully transmitted with exactly 13 retries.')
ccMuTxRetries14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries14.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries14.setDescription('Number of pkts successfully transmitted with exactly 14 retries.')
ccMuTxRetries15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetries15.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetries15.setDescription('Number of pkts successfully transmitted with exactly 15 retries.')
ccMuTxRetriesFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesFailed.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesFailed.setDescription('Number of pkts that never were successfully transmitted to because the max retry count was exceeded.')
ccMuTxRetriesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesTotal.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesTotal.setDescription('A total sum of all retries across all packets sent to this MU. For example, if 4 packets have been sent, with the following number of retires: 2, 0, 5, gave-up, this value would be 2+0+5+16 = 23.')
ccMuTxRetriesMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesMostRecent.setDescription('Most recent retry done by MU.')
ccMuLastMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 8), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuLastMac.setStatus('current')
if mibBuilder.loadTexts: ccMuLastMac.setDescription('This scalar records the MAC address of the most recent MU to be Adopted, UnAdopted, or Denied.')
ccMuLastReason = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("success", 1), ("aclViolation", 2), ("timeout", 3), ("associationFailed", 4), ("authenticationFailedOn802dot1x", 5), ("kerberosWrongUsername", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuLastReason.setStatus('current')
if mibBuilder.loadTexts: ccMuLastReason.setDescription('This value notes the reason for the most-recent MU UnAdoption or Denial. Enum item associationFailed indicates that a key association field was missing, or a mismatch of supported rates, etc.')
ccMuLastPortal = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 10), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuLastPortal.setStatus('current')
if mibBuilder.loadTexts: ccMuLastPortal.setDescription('This value notes the reason for the most-recent MU UnAdoption or Denial.')
ccMuRfSum = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100))
ccMuTxRetriesOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1), )
if mibBuilder.loadTexts: ccMuTxRetriesOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctetsTable.setDescription('For each MU serviced by the switch, this table describes counts of the number of octets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccMuTxRetriesOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuTxRetriesOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctetsEntry.setDescription(' ')
ccMuTxRetriesOctetsNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctetsNone.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctetsNone.setDescription('Number of octets successfully transmitted with no retries.')
ccMuTxRetriesOctets01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets01.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets01.setDescription('Number of octets successfully transmitted with exactly 1 retries.')
ccMuTxRetriesOctets02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets02.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets02.setDescription('Number of octets successfully transmitted with exactly 2 retries.')
ccMuTxRetriesOctets03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets03.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets03.setDescription('Number of octets successfully transmitted with exactly 3 retries.')
ccMuTxRetriesOctets04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets04.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets04.setDescription('Number of octets successfully transmitted with exactly 4 retries.')
ccMuTxRetriesOctets05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets05.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets05.setDescription('Number of octets successfully transmitted with exactly 5 retries.')
ccMuTxRetriesOctets06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets06.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets06.setDescription('Number of octets successfully transmitted with exactly 6 retries.')
ccMuTxRetriesOctets07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets07.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets07.setDescription('Number of octets successfully transmitted with exactly 7 retries.')
ccMuTxRetriesOctets08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets08.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets08.setDescription('Number of octets successfully transmitted with exactly 8 retries.')
ccMuTxRetriesOctets09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets09.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets09.setDescription('Number of octets successfully transmitted with exactly 9 retries.')
ccMuTxRetriesOctets10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets10.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets10.setDescription('Number of octets successfully transmitted with exactly 10 retries.')
ccMuTxRetriesOctets11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets11.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets11.setDescription('Number of octets successfully transmitted with exactly 11 retries.')
ccMuTxRetriesOctets12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets12.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets12.setDescription('Number of octets successfully transmitted with exactly 12 retries.')
ccMuTxRetriesOctets13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets13.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets13.setDescription('Number of octets successfully transmitted with exactly 13 retries.')
ccMuTxRetriesOctets14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets14.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets14.setDescription('Number of octets successfully transmitted with exactly 14 retries.')
ccMuTxRetriesOctets15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctets15.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctets15.setDescription('Number of octets successfully transmitted with exactly 15 retries.')
ccMuTxRetriesOctetsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuTxRetriesOctetsFailed.setStatus('current')
if mibBuilder.loadTexts: ccMuTxRetriesOctetsFailed.setDescription('Number of octets that never were successfully transmitted to because the max retry count was exceeded.')
ccMuSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2), )
if mibBuilder.loadTexts: ccMuSigStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsTable.setDescription('This table describes statistics about RSSI, Signal, Noise, and SNR for packets recieved via each MU serviced by the switch.')
ccMuSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuSigStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsEntry.setDescription(' ')
ccMuSigStatsNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNumPkts.setDescription('Total packets received included in all the other counters reported in this row.')
ccMuSigStatsSignalBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 2), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSignalBest.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSignalBest.setDescription('The best Signal value seen so far. (Remember that a -20dBm Signal is better than -60dBm). This value is initialized to -500dBm. ')
ccMuSigStatsSignalWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 3), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSignalWorst.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSignalWorst.setDescription('The worst Signal value seen so far. (Remember that a -80dBm Signal is worse than -60dBm). This value is initialized to 500dBm.')
ccMuSigStatsSignalSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 4), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSignalSum.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSignalSum.setDescription('A running sum of all Signal values calculated by the switch (using reported RSSI values), for packets received. Note that this value is normally a negative value ranging from -10dBm to -80dBm. It is possible for this value to be positive, but that would be rare, and would signal an exceptionally strong signal.')
ccMuSigStatsSignalSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 5), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSignalSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSignalSumSquares.setDescription('A sum of the squares of each Signal value calculated for packets received. Unlike _SignalSum, this value is never negative, since the square of a negative number is a positive.')
ccMuSigStatsSignalMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 6), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSignalMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSignalMostRecent.setDescription('The best Signal value seen so far. (Remember that a -20dBm Signal is better than -60dBm). This value does not make sense when ccMuSigStatsNumPkts equals to 0.')
ccMuSigStatsNoiseBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 7), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNoiseBest.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNoiseBest.setDescription('The best Noise value seen so far. (Remember that -80dBm Noise is better than -70dBm). This value is initialized to 500dBm.')
ccMuSigStatsNoiseWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 8), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNoiseWorst.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNoiseWorst.setDescription('The worst Noise value seen so far. (Remember that -50dBm Noise is worse than -60dBm). This value is initialized to -500dBm.')
ccMuSigStatsNoiseSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 9), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNoiseSum.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNoiseSum.setDescription('A running sum of all Noise values calculated by the switch (using reported RSSI values), for packets. Like _SignalSum, this value is normally a negative value.')
ccMuSigStatsNoiseSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 10), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNoiseSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNoiseSumSquares.setDescription('A sum of the squares of each Noise value calculated for packets received. As with _SignalSumSquares, this value is never negative.')
ccMuSigStatsNoiseMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsNoiseMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsNoiseMostRecent.setDescription('The best Noise value seen so far. (Remember that -80dBm Noise is better than -70dBm). This value does not make sense when ccMuSigStatsNumPkts equals to 0.')
ccMuSigStatsSnrBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSnrBest.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSnrBest.setDescription('The best SNR value seen so far. (Remember that +30dBm SNR is better than +20dBm). This value is initialized to -500dB.')
ccMuSigStatsSnrWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 13), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSnrWorst.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSnrWorst.setDescription('The worst SNR value seen so far. (Remember that +10dBm SNR is worse than +20dBm). This value is initialized to 500dB.')
ccMuSigStatsSnrSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 14), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSnrSum.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSnrSum.setDescription('A running sum of all SNR values calculated by the switch (using reported RSSI values), for packets received. Unlike _Signal and _Noise, this value is never negative.')
ccMuSigStatsSnrSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 15), Counter64()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSnrSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSnrSumSquares.setDescription('A sum of the squares of each SNR value calculated for packets received. This value is never negative.')
ccMuSigStatsSnrMostRecent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 2, 1, 16), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSigStatsSnrMostRecent.setStatus('current')
if mibBuilder.loadTexts: ccMuSigStatsSnrMostRecent.setDescription('The best SNR value seen so far. (Remember that +30dBm SNR is better than +20dBm). This value does not make sense when ccMuSigStatsNumPkts equals to 0.')
ccMuSumStatsShortTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3), )
if mibBuilder.loadTexts: ccMuSumStatsShortTable.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortTable.setDescription('Averages and rates calculated over the SHORT window for each MU.')
ccMuSumStatsShortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuSumStatsShortEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortEntry.setDescription(' ')
ccMuSumStatsShortTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortTimestamp.setDescription("Snapshot of sysUpTime as of the END of the 'window' of time that this entry of values represents.")
ccMuSumStatsShortNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortNumPkts.setDescription('The number of packets used to calculate the statistics in this window.')
ccMuSumStatsShortPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSec100.setDescription("Packets per second as averaged over the 'window'. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccMuSumStatsShortPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSecTx100.setDescription("Packets per second TX as averaged over the 'window'. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccMuSumStatsShortPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPktsPerSecRx100.setDescription("Packets per second RX as averaged over the 'window'. Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccMuSumStatsShortThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortThroughput.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortThroughput.setDescription('Actual number of bits sent and received over the window, divided by the number of seconds in the window. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccMuSumStatsShortThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortThroughputTx.setDescription('Actual number of bits TX over the window, divided by the number of seconds in the window. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccMuSumStatsShortThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortThroughputRx.setDescription('Actual number of bits RX over the window, divided by the number of seconds in the window.')
ccMuSumStatsShortAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortAvgBitSpeed.setDescription('An octet-weighted average of the speeds of all packets sent/received. (For each possible speed, multiply the number of octets sent/received by that speed; divide the sum by the total number of octets; multiply by 8). For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). This can be said in more plain english as: the average bit-speed at which packets were sent/received.')
ccMuSumStatsShortAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuSignal.setDescription('The average of all signal values over the window. NOTE: dBm are normally negative. Here the NEGATIVE values are reported as POSITIVE values. PO')
ccMuSumStatsShortAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuNoise.setDescription('The average of all noise values over the window.')
ccMuSumStatsShortAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortAvgMuSnr.setDescription('The average of all SNR values over the window.')
ccMuSumStatsShortPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kNUcastPkts.setDescription('Ratio of packets that were NOT unicast. Expressed as parts-per-10000.')
ccMuSumStatsShortPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kTxWithRetries.setDescription('Ratio of TX packets that experienced one or more retries. Expressed as parts-per-10000.')
ccMuSumStatsShortPp10kDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kDropped.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kDropped.setDescription('Packets dropped divided by packets sent. Dropped here means dropped intentionally due to the appropriate QoS queue being full. Other reasons for dropped packets are not counted in this ratio. Calculated as an average for all WLANs implemented on this MU.')
ccMuSumStatsShortTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortTxAvgRetries100.setDescription('For all transmit packets (those that experienced some retries, those that were successfully transmitted with only 1 transmission, and those that attempted max times and gave-up), the average number of RE-transmission attempts. Said another (though identical) way: the sum of all tranmission attempts divided by the number of unique packets attempted to be sent. Since SNMP does not convey decimal values, the result above is multiplied by 100. If there were no RE-transmissions, this value would be 0. If every single packet required exactly two tranmissions, this value would be 100, (representing 1.00).')
ccMuSumStatsShortPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 3, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsShortPp10kRxUndecrypt.setDescription('Ratio of RX packets that were undecryptable. Expressed as parts-per-10000. ')
ccMuSumStatsLongTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4), )
if mibBuilder.loadTexts: ccMuSumStatsLongTable.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongTable.setDescription('Averages and rates calculated over the LONG window for each MU. (Refer to ccMuSumStatsShortTable for descriptions).')
ccMuSumStatsLongEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccMuMac"))
if mibBuilder.loadTexts: ccMuSumStatsLongEntry.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongEntry.setDescription(' ')
ccMuSumStatsLongTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongTimestamp.setDescription(' ')
ccMuSumStatsLongNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongNumPkts.setDescription(' ')
ccMuSumStatsLongPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSec100.setDescription(' ')
ccMuSumStatsLongPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSecTx100.setDescription(' ')
ccMuSumStatsLongPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPktsPerSecRx100.setDescription(' ')
ccMuSumStatsLongThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongThroughput.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongThroughput.setDescription(' ')
ccMuSumStatsLongThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongThroughputTx.setDescription(' ')
ccMuSumStatsLongThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongThroughputRx.setDescription(' ')
ccMuSumStatsLongAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongAvgBitSpeed.setDescription(' ')
ccMuSumStatsLongAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuSignal.setDescription(' ')
ccMuSumStatsLongAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuNoise.setDescription(' ')
ccMuSumStatsLongAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongAvgMuSnr.setDescription(' ')
ccMuSumStatsLongPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kNUcastPkts.setDescription(' ')
ccMuSumStatsLongPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kTxWithRetries.setDescription(' ')
ccMuSumStatsLongPp10kDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kDropped.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kDropped.setDescription(' ')
ccMuSumStatsLongTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongTxAvgRetries100.setDescription(' ')
ccMuSumStatsLongPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 4, 100, 4, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccMuSumStatsLongPp10kRxUndecrypt.setDescription(' ')
ccWlan = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5))
ccWlanTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1), )
if mibBuilder.loadTexts: ccWlanTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanTable.setDescription('Table of wireless LANs configured on the switch.')
ccWlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanEntry.setDescription(' ')
ccWlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1001))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWlanIndex.setStatus('current')
if mibBuilder.loadTexts: ccWlanIndex.setDescription('Simple index. (In the ccRfSum tables, entry 1001 is used to represent the roll-up of all RF communications on this switch). ')
ccWlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanName.setStatus('current')
if mibBuilder.loadTexts: ccWlanName.setDescription('Name of the WLAN.')
ccWlanEssid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanEssid.setStatus('current')
if mibBuilder.loadTexts: ccWlanEssid.setDescription('ESSID of the WLAN.')
ccWlanSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 4), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanSubnet.setStatus('current')
if mibBuilder.loadTexts: ccWlanSubnet.setDescription('The subnet/LAN this WLAN is associated with. If not associated with any subnet/LAN, this value will be 0.')
ccWlanPortalsAdopted = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 5), MultiPointer255()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanPortalsAdopted.setStatus('current')
if mibBuilder.loadTexts: ccWlanPortalsAdopted.setDescription('Pointer to portal(s) adopted by this WLAN.')
ccWlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 6), StaticRowEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanEnable.setStatus('current')
if mibBuilder.loadTexts: ccWlanEnable.setDescription('Row enable.')
ccWlanDisallowMuToMu = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanDisallowMuToMu.setStatus('current')
if mibBuilder.loadTexts: ccWlanDisallowMuToMu.setDescription('Set to true to prohibit MU-to-MU communication.')
ccWlanVoicePrioritization = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanVoicePrioritization.setStatus('current')
if mibBuilder.loadTexts: ccWlanVoicePrioritization.setDescription('Enable voice prioritization.')
ccWlanAnswerBroadcastEss = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAnswerBroadcastEss.setStatus('current')
if mibBuilder.loadTexts: ccWlanAnswerBroadcastEss.setDescription('Answer broadcast ESS.')
ccWlanMulticastAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 10), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMulticastAddr1.setStatus('current')
if mibBuilder.loadTexts: ccWlanMulticastAddr1.setDescription('Multicast address 1.')
ccWlanMulticastAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 11), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMulticastAddr2.setStatus('current')
if mibBuilder.loadTexts: ccWlanMulticastAddr2.setDescription('Multicast address 2.')
ccWlanMuAclDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allowAllMusExceptThoseMatchingAclRules", 1), ("denyAllMusExceptThoseMatchingAclRules", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMuAclDefault.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclDefault.setDescription("Describes the default behavior if none of this WLAN's ccWlanMuAclTable entries match the MAC address of an MU attempting to associate with this WLAN.")
ccWlanAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("authNone", 1), ("auth802dot1xEap", 2), ("authKerberos", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthentication.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthentication.setDescription('If auth802dot1xEap, additional EAP settings for this WLAN will be used from the matching entry in the ccWlanAuthEapTable. Likewise, if authKerberos, use the settings in the matching entry in the ccWlanAuthKerberosTable.')
ccWlanEncryption = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("cryptoNone", 1), ("cryptoWep40", 2), ("cryptoWep104", 3), ("cryptoKeyguardMcm", 4), ("cryptoWpaTkip", 5), ("cryptoWpa2Ccmp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanEncryption.setStatus('current')
if mibBuilder.loadTexts: ccWlanEncryption.setDescription('If cryptoWep40 or cryptoWep128, additional WEP settings for this WLAN will be used from the matching entry in the ccWlanCryptoWepTable. Likewise, if cryptoWpaTkip, use the settings in the matching entry in the ccWlanCryptoWpaTable. Likewise, if cryptoKeyguardMcm, use the settings in the matching entry in the ccWlanCryptoKeyguardTable.')
ccWlanWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanWeight.setStatus('current')
if mibBuilder.loadTexts: ccWlanWeight.setDescription('The weight to be used when QoS for all WLANs is set to weighted-round-robin. Note that the sum of all weights across all WLANs need not total 100. ')
ccWlanAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2))
ccWlanAuthEapTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1), )
if mibBuilder.loadTexts: ccWlanAuthEapTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapTable.setDescription('Table of EAP authentication settings for each WLAN.')
ccWlanAuthEapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanAuthEapEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapEntry.setDescription(' ')
ccWlanAuthEapReauthenticationEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationEnable.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationEnable.setDescription('Enable reauthentication.')
ccWlanAuthEapReauthenticationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 9999))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationPeriod.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationPeriod.setDescription('Reauthentication period.')
ccWlanAuthEapReauthenticationMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationMaxRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapReauthenticationMaxRetries.setDescription('Reauthentication max retries.')
ccWlanAuthEapRadius1Server = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius1Server.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius1Server.setDescription('IP address of the primary RADIUS server.')
ccWlanAuthEapRadius1Port = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius1Port.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius1Port.setDescription('Port number of the primary RADIUS server.')
ccWlanAuthEapRadius1SharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 6), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius1SharedSecret.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius1SharedSecret.setDescription('Shared secret of the primary RADIUS server.')
ccWlanAuthEapRadius2Server = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius2Server.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius2Server.setDescription('IP address of the secondary RADIUS server.')
ccWlanAuthEapRadius2Port = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius2Port.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius2Port.setDescription('Port number of the secondary RADIUS server.')
ccWlanAuthEapRadius2SharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 9), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadius2SharedSecret.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadius2SharedSecret.setDescription('Shared secret of the secondary RADIUS server.')
ccWlanAuthEapMuQuietPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapMuQuietPeriod.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapMuQuietPeriod.setDescription('MU quiet period.')
ccWlanAuthEapMuTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapMuTimeout.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapMuTimeout.setDescription('MU timeout.')
ccWlanAuthEapMuTxPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapMuTxPeriod.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapMuTxPeriod.setDescription('MU Tx period.')
ccWlanAuthEapMuMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapMuMaxRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapMuMaxRetries.setDescription('MU max retries.')
ccWlanAuthEapServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapServerTimeout.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapServerTimeout.setDescription('Server timeout.')
ccWlanAuthEapServerMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapServerMaxRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapServerMaxRetries.setDescription('Server max retries.')
ccWlanAuthEapRadiusAcctMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMode.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMode.setDescription('Radius Accounting Mode.')
ccWlanAuthEapRadiusAcctMuTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMuTimeout.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMuTimeout.setDescription('Radius Accounting MU Timeout.')
ccWlanAuthEapRadiusAcctMuRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMuRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapRadiusAcctMuRetries.setDescription('Radius Accounting MU Retries.')
ccWlanAuthEapSyslogMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapSyslogMode.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapSyslogMode.setDescription('Logging Mode.')
ccWlanAuthEapSyslogSeverIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 1, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthEapSyslogSeverIp.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthEapSyslogSeverIp.setDescription('Syslog Server IP Address.')
ccWlanAuthKerberosTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2), )
if mibBuilder.loadTexts: ccWlanAuthKerberosTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosTable.setDescription('Table of Kerberos authentication settings for each WLAN.')
ccWlanAuthKerberosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanAuthKerberosEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosEntry.setDescription(' ')
ccWlanAuthKerberosRealmName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosRealmName.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosRealmName.setDescription('Realm name.')
ccWlanAuthKerberosUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosUsername.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosUsername.setDescription('Username.')
ccWlanAuthKerberosPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 3), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosPassword.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosPassword.setDescription('Password.')
ccWlanAuthKerberosKdcServerIp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIp1.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIp1.setDescription('Primary KDC server IP addr.')
ccWlanAuthKerberosKdcPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPort1.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPort1.setDescription('Primary KDC port.')
ccWlanAuthKerberosKdcServerIp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIp2.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIp2.setDescription('Backup KDC server IP addr.')
ccWlanAuthKerberosKdcPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPort2.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPort2.setDescription('Backup KDC port.')
ccWlanAuthKerberosKdcServerIpR = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIpR.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcServerIpR.setDescription('Remote KDC server IP addr.')
ccWlanAuthKerberosKdcPortR = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPortR.setStatus('current')
if mibBuilder.loadTexts: ccWlanAuthKerberosKdcPortR.setDescription('Remote KDC port.')
ccWlanCrypto = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3))
ccWlanCryptoWepTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1), )
if mibBuilder.loadTexts: ccWlanCryptoWepTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepTable.setDescription('Table of WEP encryption settings for each WLAN.')
ccWlanCryptoWepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanCryptoWepEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepEntry.setDescription(' ')
ccWlanCryptoWepPassKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 1), Password().subtype(subtypeSpec=ValueSizeConstraint(4, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepPassKey.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepPassKey.setDescription('Pass key. If this value is written, the four WepKey1..4 will be overwritten.')
ccWlanCryptoWepKey1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepKey1.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepKey1.setDescription('WEP key #1 exactly 13 octets for WEP-128 (104-bit key); exactly 5 octets for WEP-64 (40-bit key).')
ccWlanCryptoWepKey2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepKey2.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepKey2.setDescription('WEP key #2 exactly 13 octets for WEP-128 (104-bit key); exactly 5 octets for WEP-64 (40-bit key).')
ccWlanCryptoWepKey3 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepKey3.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepKey3.setDescription('WEP key #3 exactly 13 octets for WEP-128 (104-bit key); exactly 5 octets for WEP-64 (40-bit key).')
ccWlanCryptoWepKey4 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepKey4.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepKey4.setDescription('WEP key #4 exactly 13 octets for WEP-128 (104-bit key); exactly 5 octets for WEP-64 (40-bit key).')
ccWlanCryptoWepKeyToUse = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWepKeyToUse.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWepKeyToUse.setDescription('Specifies which WEP key to use.')
ccWlanCryptoWpaTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2), )
if mibBuilder.loadTexts: ccWlanCryptoWpaTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTable.setDescription('Table of WPA-TKIP encryption settings for each WLAN.')
ccWlanCryptoWpaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanCryptoWpaEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaEntry.setDescription(' ')
ccWlanCryptoWpaBcastKeyRotation = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaBcastKeyRotation.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaBcastKeyRotation.setDescription('Use broadcast key rotation.')
ccWlanCryptoWpaKeyRotationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 604800))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaKeyRotationInterval.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaKeyRotationInterval.setDescription('Broadcast key rotation, (if enabled), occurs every this many seconds.')
ccWlanCryptoWpaKeyToUse = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use128bitKey", 1), ("useAsciiPassPhrase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaKeyToUse.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaKeyToUse.setDescription('Specifies which key to use.')
ccWlanCryptoWpaPassphrase = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaPassphrase.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaPassphrase.setDescription('Passphrase.')
ccWlanCryptoWpaKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaKey.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaKey.setDescription('Key.')
ccWlanCryptoKeyguardTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3), )
if mibBuilder.loadTexts: ccWlanCryptoKeyguardTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardTable.setDescription('Table of KeyGuard-MCM encryption settings for each WLAN.')
ccWlanCryptoKeyguardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanCryptoKeyguardEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardEntry.setDescription(' ')
ccWlanCryptoKeyguardPasskey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardPasskey.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardPasskey.setDescription('Pass key.')
ccWlanCryptoKeyguardKey1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey1.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey1.setDescription('Key #1.')
ccWlanCryptoKeyguardKey2 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey2.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey2.setDescription('Key #2.')
ccWlanCryptoKeyguardKey3 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey3.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey3.setDescription('Key #3.')
ccWlanCryptoKeyguardKey4 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey4.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKey4.setDescription('Key #4.')
ccWlanCryptoKeyguardKeyToUse = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKeyToUse.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoKeyguardKeyToUse.setDescription('Specifies which WEP key to use.')
ccWlanCryptoWpaTwoTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4), )
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoTable.setDescription('Table of WPA-CCMP encryption settings for each WLAN.')
ccWlanCryptoWpaTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoEntry.setDescription('Description.')
ccWlanCryptoWpaTwoBcastKeyRotation = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoBcastKeyRotation.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoBcastKeyRotation.setDescription('Use broadcast key rotation.')
ccWlanCryptoWpaTwoKeyRotationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 604800))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKeyRotationInterval.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKeyRotationInterval.setDescription('Broadcast key rotation, (if enabled), occurs every this many seconds.')
ccWlanCryptoWpaTwoKeyToUse = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("useAsciiPassphrase", 1), ("use128bitKey", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKeyToUse.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKeyToUse.setDescription('Specifies which key to use.')
ccWlanCryptoWpaTwoPassphrase = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 4), Password().subtype(subtypeSpec=ValueSizeConstraint(8, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoPassphrase.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoPassphrase.setDescription('Passphrase.')
ccWlanCryptoWpaTwoKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKey.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoKey.setDescription('Key.')
ccWlanCryptoWpaTwoAllowTkipClient = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoAllowTkipClient.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoAllowTkipClient.setDescription('WPA2-CCMP Mixed Mode enables WPA2-CCMP and WPA-TKIP Clients to operate simultaneously on the network. Enabling this option allows backwards compatiblity for clients that support WPA-TKIP but do not support WPA2-CCMP.')
ccWlanCryptoWpaTwoFastRoamPreAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoFastRoamPreAuth.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoFastRoamPreAuth.setDescription('Enabling this option enables a client associated with one Access Port to carry out an 802.1x authentication with another Access Port before it roams over to it. The WS2000 will cache the keying information of the client until it roams to the new Access Port. This enables the roaming the client to start sending and receiving data sooner by not having to do 802.1x authentication after it roams. Note: This option only works when 802.1x authentication is enabled for the WLAN. ')
ccWlanCryptoWpaTwoFastRoamKeyCache = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 3, 4, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoFastRoamKeyCache.setStatus('current')
if mibBuilder.loadTexts: ccWlanCryptoWpaTwoFastRoamKeyCache.setDescription('This option enables the WS2000 to use a Pairwise Master Key (PMK) derived with a client on one Access Port, with the same client when it roams over to another Access Port. Upon roaming the client does not have to do 802.1x authentication and can start sending/receiving data sooner. Note: This option only works when 802.1x authentication is enabled for the WLAN. ')
ccWlanMuAclTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4), )
if mibBuilder.loadTexts: ccWlanMuAclTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclTable.setDescription('Table describing ACLs for allowing or denying, (depending on default behavior for the WLAN specified in ccWlanMuAclDefault), MU association with each WLAN.')
ccWlanMuAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccWlanMuAclIndex"))
if mibBuilder.loadTexts: ccWlanMuAclEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclEntry.setDescription(' ')
ccWlanMuAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWlanMuAclIndex.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclIndex.setDescription('Simple index.')
ccWlanMuAclStartingMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMuAclStartingMac.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclStartingMac.setDescription('Starting MAC address in a range of addresses.')
ccWlanMuAclEndingMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMuAclEndingMac.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclEndingMac.setDescription('Ending MAC address in a range of addresses.')
ccWlanMuAclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 4, 1, 4), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanMuAclRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccWlanMuAclRowStatus.setDescription('Row status.')
ccWlanBwShareMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("roundRobin", 2), ("weightedRoundRobin", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanBwShareMode.setStatus('current')
if mibBuilder.loadTexts: ccWlanBwShareMode.setDescription("This variable configures the manner in which bandwidth is shared among the WLANs. Only in mode 'weightedRoundRobin' are the ccWlanWeight values for each WLAN used.")
ccWlanQosMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 6), )
if mibBuilder.loadTexts: ccWlanQosMonitorTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanQosMonitorTable.setDescription('Table of QOS values.')
ccWlanQosMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 6, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccPortalIndex"))
if mibBuilder.loadTexts: ccWlanQosMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanQosMonitorEntry.setDescription('Description.')
ccWlanQosMonitorSent = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanQosMonitorSent.setStatus('current')
if mibBuilder.loadTexts: ccWlanQosMonitorSent.setDescription('Packets Sent.')
ccWlanQosMonitorDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanQosMonitorDropped.setStatus('current')
if mibBuilder.loadTexts: ccWlanQosMonitorDropped.setDescription('Packets Dropped.')
ccWlanRfSum = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100))
ccWlanStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1), )
if mibBuilder.loadTexts: ccWlanStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanStatsTable.setDescription('This table describes general statistics about packets sent/recieved via each WLAN on the switch.')
ccWlanStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanStatsEntry.setDescription(' ')
ccWlanTxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsUcast.setDescription('Count of unicast packets sent.')
ccWlanRxPktsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsUcast.setDescription('Count of unicast packets received.')
ccWlanRxPktsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsNUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsNUcast.setDescription('Count of non-unicast (broadcast & multicast) packets received.')
ccWlanTxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsUcast.setDescription('Count of unicast octets sent.')
ccWlanRxOctetsUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsUcast.setDescription('Count of unicast octets received.')
ccWlanRxOctetsNUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsNUcast.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsNUcast.setDescription('Count of non-unicast (broadcast & multicast) octets received.')
ccWlanRxUndecryptablePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxUndecryptablePkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxUndecryptablePkts.setDescription('Count of packets received that could not be decrypted.')
ccWlanLastActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 1, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanLastActivity.setStatus('current')
if mibBuilder.loadTexts: ccWlanLastActivity.setDescription("A snapshot of the switch's sysUpTime at the time of the last activity (packet sent or received).")
ccWlanRxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2), )
if mibBuilder.loadTexts: ccWlanRxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsTable.setDescription('For each WLAN on the switch, this table describes counts of packets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccWlanRxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanRxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsEntry.setDescription(' ')
ccWlanRxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt1Mb.setDescription('Number of pkts received at 1 Mb.')
ccWlanRxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt2Mb.setDescription('Number of pkts received at 2 Mb.')
ccWlanRxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt5pt5Mb.setDescription('Number of pkts received at 5.5 Mb.')
ccWlanRxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt6Mb.setDescription('Number of pkts received at 6 Mb.')
ccWlanRxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt9Mb.setDescription('Number of pkts received at 9 Mb.')
ccWlanRxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt11Mb.setDescription('Number of pkts received at 11 Mb.')
ccWlanRxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt12Mb.setDescription('Number of pkts received at 12 Mb.')
ccWlanRxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt18Mb.setDescription('Number of pkts received at 18 Mb.')
ccWlanRxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt22Mb.setDescription('Number of pkts received at 22 Mb.')
ccWlanRxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt24Mb.setDescription('Number of pkts received at 24 Mb.')
ccWlanRxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt36Mb.setDescription('Number of pkts received at 36 Mb.')
ccWlanRxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt48Mb.setDescription('Number of pkts received at 48 Mb.')
ccWlanRxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxPktsAt54Mb.setDescription('Number of pkts received at 54 Mb.')
ccWlanTxPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3), )
if mibBuilder.loadTexts: ccWlanTxPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsTable.setDescription('For each MU serviced by the switch, this table describes counts of packets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccWlanTxPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanTxPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsEntry.setDescription(' ')
ccWlanTxPktsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt1Mb.setDescription('Number of pkts transmitted at 1 Mb.')
ccWlanTxPktsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt2Mb.setDescription('Number of pkts transmitted at 2 Mb.')
ccWlanTxPktsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt5pt5Mb.setDescription('Number of pkts transmitted at 5.5 Mb.')
ccWlanTxPktsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt6Mb.setDescription('Number of pkts transmitted at 6 Mb.')
ccWlanTxPktsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt9Mb.setDescription('Number of pkts transmitted at 9 Mb.')
ccWlanTxPktsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt11Mb.setDescription('Number of pkts transmitted at 11 Mb.')
ccWlanTxPktsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt12Mb.setDescription('Number of pkts transmitted at 12 Mb.')
ccWlanTxPktsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt18Mb.setDescription('Number of pkts transmitted at 18 Mb.')
ccWlanTxPktsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt22Mb.setDescription('Number of pkts transmitted at 22 Mb.')
ccWlanTxPktsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt24Mb.setDescription('Number of pkts transmitted at 24 Mb.')
ccWlanTxPktsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt36Mb.setDescription('Number of pkts transmitted at 36 Mb.')
ccWlanTxPktsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt48Mb.setDescription('Number of pkts transmitted at 48 Mb.')
ccWlanTxPktsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxPktsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxPktsAt54Mb.setDescription('Number of pkts transmitted at 54 Mb.')
ccWlanRxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4), )
if mibBuilder.loadTexts: ccWlanRxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsTable.setDescription('For each MU serviced by this switch, this table describes counts of octets received at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccWlanRxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanRxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsEntry.setDescription(' ')
ccWlanRxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt1Mb.setDescription('Number of octets received at 1 Mb.')
ccWlanRxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt2Mb.setDescription('Number of octets received at 2 Mb.')
ccWlanRxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt5pt5Mb.setDescription('Number of octets received at 5.5 Mb.')
ccWlanRxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt6Mb.setDescription('Number of octets received at 6 Mb.')
ccWlanRxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt9Mb.setDescription('Number of octets received at 9 Mb.')
ccWlanRxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt11Mb.setDescription('Number of octets received at 11 Mb.')
ccWlanRxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt12Mb.setDescription('Number of octets received at 12 Mb.')
ccWlanRxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt18Mb.setDescription('Number of octets received at 18 Mb.')
ccWlanRxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt22Mb.setDescription('Number of octets received at 22 Mb.')
ccWlanRxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt24Mb.setDescription('Number of octets received at 24 Mb.')
ccWlanRxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt36Mb.setDescription('Number of octets received at 36 Mb.')
ccWlanRxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt48Mb.setDescription('Number of octets received at 48 Mb.')
ccWlanRxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanRxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanRxOctetsAt54Mb.setDescription('Number of octets received at 54 Mb.')
ccWlanTxOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5), )
if mibBuilder.loadTexts: ccWlanTxOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsTable.setDescription('For each WLAN on this switch, this table describes counts of octets transmitted at each possible speed, (1Mb, 2Mb, 5.5Mb, 6Mb...).')
ccWlanTxOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanTxOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsEntry.setDescription(' ')
ccWlanTxOctetsAt1Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt1Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt1Mb.setDescription('Number of octets transmitted at 1 Mb.')
ccWlanTxOctetsAt2Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt2Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt2Mb.setDescription('Number of octets transmitted at 2 Mb.')
ccWlanTxOctetsAt5pt5Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt5pt5Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt5pt5Mb.setDescription('Number of octets transmitted at 5.5 Mb.')
ccWlanTxOctetsAt6Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt6Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt6Mb.setDescription('Number of octets transmitted at 6 Mb.')
ccWlanTxOctetsAt9Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt9Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt9Mb.setDescription('Number of octets transmitted at 9 Mb.')
ccWlanTxOctetsAt11Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt11Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt11Mb.setDescription('Number of octets transmitted at 11 Mb.')
ccWlanTxOctetsAt12Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt12Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt12Mb.setDescription('Number of octets transmitted at 12 Mb.')
ccWlanTxOctetsAt18Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt18Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt18Mb.setDescription('Number of octets transmitted at 18 Mb.')
ccWlanTxOctetsAt22Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt22Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt22Mb.setDescription('Number of octets transmitted at 22 Mb.')
ccWlanTxOctetsAt24Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt24Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt24Mb.setDescription('Number of octets transmitted at 24 Mb.')
ccWlanTxOctetsAt36Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt36Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt36Mb.setDescription('Number of octets transmitted at 36 Mb.')
ccWlanTxOctetsAt48Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt48Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt48Mb.setDescription('Number of octets transmitted at 48 Mb.')
ccWlanTxOctetsAt54Mb = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxOctetsAt54Mb.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxOctetsAt54Mb.setDescription('Number of octets transmitted at 54 Mb.')
ccWlanTxRetriesPktsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6), )
if mibBuilder.loadTexts: ccWlanTxRetriesPktsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPktsTable.setDescription('For each WLAN on the switch, this table describes counts of the number of packets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccWlanTxRetriesPktsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanTxRetriesPktsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPktsEntry.setDescription(' ')
ccWlanTxRetriesPktsNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPktsNone.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPktsNone.setDescription('Number of pkts successfully transmitted with no retries.')
ccWlanTxRetriesPkts01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts01.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts01.setDescription('Number of pkts successfully transmitted with exactly 1 retries.')
ccWlanTxRetriesPkts02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts02.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts02.setDescription('Number of pkts successfully transmitted with exactly 2 retries.')
ccWlanTxRetriesPkts03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts03.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts03.setDescription('Number of pkts successfully transmitted with exactly 3 retries.')
ccWlanTxRetriesPkts04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts04.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts04.setDescription('Number of pkts successfully transmitted with exactly 4 retries.')
ccWlanTxRetriesPkts05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts05.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts05.setDescription('Number of pkts successfully transmitted with exactly 5 retries.')
ccWlanTxRetriesPkts06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts06.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts06.setDescription('Number of pkts successfully transmitted with exactly 6 retries.')
ccWlanTxRetriesPkts07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts07.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts07.setDescription('Number of pkts successfully transmitted with exactly 7 retries.')
ccWlanTxRetriesPkts08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts08.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts08.setDescription('Number of pkts successfully transmitted with exactly 8 retries.')
ccWlanTxRetriesPkts09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts09.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts09.setDescription('Number of pkts successfully transmitted with exactly 9 retries.')
ccWlanTxRetriesPkts10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts10.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts10.setDescription('Number of pkts successfully transmitted with exactly 10 retries.')
ccWlanTxRetriesPkts11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts11.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts11.setDescription('Number of pkts successfully transmitted with exactly 11 retries.')
ccWlanTxRetriesPkts12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts12.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts12.setDescription('Number of pkts successfully transmitted with exactly 12 retries.')
ccWlanTxRetriesPkts13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts13.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts13.setDescription('Number of pkts successfully transmitted with exactly 13 retries.')
ccWlanTxRetriesPkts14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts14.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts14.setDescription('Number of pkts successfully transmitted with exactly 14 retries.')
ccWlanTxRetriesPkts15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPkts15.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPkts15.setDescription('Number of pkts successfully transmitted with exactly 15 retries.')
ccWlanTxRetriesPktsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesPktsFailed.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesPktsFailed.setDescription('Number of pkts that never were successfully transmitted to because the max retry count was exceeded.')
ccWlanTxRetriesOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7), )
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsTable.setDescription('For each WLAN on the switch, this table describes counts of the number of octets affected by transmit retries, (no retries, 1 retry, 2 retries,... gave-up).')
ccWlanTxRetriesOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsEntry.setDescription(' ')
ccWlanTxRetriesOctetsNone = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsNone.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsNone.setDescription('Number of octets successfully transmitted with no retries.')
ccWlanTxRetriesOctets01 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets01.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets01.setDescription('Number of octets successfully transmitted with exactly 1 retries.')
ccWlanTxRetriesOctets02 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets02.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets02.setDescription('Number of octets successfully transmitted with exactly 2 retries.')
ccWlanTxRetriesOctets03 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets03.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets03.setDescription('Number of octets successfully transmitted with exactly 3 retries.')
ccWlanTxRetriesOctets04 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets04.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets04.setDescription('Number of octets successfully transmitted with exactly 4 retries.')
ccWlanTxRetriesOctets05 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets05.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets05.setDescription('Number of octets successfully transmitted with exactly 5 retries.')
ccWlanTxRetriesOctets06 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets06.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets06.setDescription('Number of octets successfully transmitted with exactly 6 retries.')
ccWlanTxRetriesOctets07 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets07.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets07.setDescription('Number of octets successfully transmitted with exactly 7 retries.')
ccWlanTxRetriesOctets08 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets08.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets08.setDescription('Number of octets successfully transmitted with exactly 8 retries.')
ccWlanTxRetriesOctets09 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets09.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets09.setDescription('Number of octets successfully transmitted with exactly 9 retries.')
ccWlanTxRetriesOctets10 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets10.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets10.setDescription('Number of octets successfully transmitted with exactly 10 retries.')
ccWlanTxRetriesOctets11 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets11.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets11.setDescription('Number of octets successfully transmitted with exactly 11 retries.')
ccWlanTxRetriesOctets12 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets12.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets12.setDescription('Number of octets successfully transmitted with exactly 12 retries.')
ccWlanTxRetriesOctets13 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets13.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets13.setDescription('Number of octets successfully transmitted with exactly 13 retries.')
ccWlanTxRetriesOctets14 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets14.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets14.setDescription('Number of octets successfully transmitted with exactly 14 retries.')
ccWlanTxRetriesOctets15 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctets15.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctets15.setDescription('Number of octets successfully transmitted with exactly 15 retries.')
ccWlanTxRetriesOctetsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsFailed.setStatus('current')
if mibBuilder.loadTexts: ccWlanTxRetriesOctetsFailed.setDescription('Number of octets that never were successfully transmitted to because the max retry count was exceeded.')
ccWlanSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8), )
if mibBuilder.loadTexts: ccWlanSigStatsTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsTable.setDescription('This table describes statistics about RSSI, Signal, Noise, and SNR for packets recieved via each WLAN on the switch.')
ccWlanSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanSigStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsEntry.setDescription(' ')
ccWlanSigStatsNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsNumPkts.setDescription('Total packets received included in all the other counters reported in this row.')
ccWlanSigStatsSignalBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 2), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSignalBest.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSignalBest.setDescription('The best Signal value seen so far. (Remember that a -20dBm Signal is better than -60dBm). This value is initialized to -500dBm.')
ccWlanSigStatsSignalWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 3), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSignalWorst.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSignalWorst.setDescription('The worst Signal value seen so far. (Remember that a -80dBm Signal is worse than -60dBm). This value is initialized to 500dBm.')
ccWlanSigStatsSignalSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 4), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSignalSum.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSignalSum.setDescription('A running sum of all Signal values calculated by the switch (using reported RSSI values), for packets received. Note that this value is normally a negative value ranging from -10dBm to -80dBm. It is possible for this value to be positive, but that would be rare, and would signal an exceptionally strong signal.')
ccWlanSigStatsSignalSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 5), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSignalSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSignalSumSquares.setDescription('A sum of the squares of each Signal value calculated for packets received. Unlike _SignalSum, this value is never negative, since the square of a negative number is a positive.')
ccWlanSigStatsNoiseBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 6), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsNoiseBest.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsNoiseBest.setDescription('The best Noise value seen so far. (Remember that -80dBm Noise is better than -70dBm). This value is initialized to 500dBm.')
ccWlanSigStatsNoiseWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 7), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsNoiseWorst.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsNoiseWorst.setDescription('The worst Noise value seen so far. (Remember that -50dBm Noise is worse than -60dBm). This value is initialized to -500dBm.')
ccWlanSigStatsNoiseSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 8), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsNoiseSum.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsNoiseSum.setDescription('A running sum of all Noise values calculated by the switch (using reported RSSI values), for packets. Like _SignalSum, this value is normally a negative value.')
ccWlanSigStatsNoiseSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 9), Counter64()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsNoiseSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsNoiseSumSquares.setDescription('A sum of the squares of each Noise value calculated for packets received. As with _SignalSumSquares, this value is never negative.')
ccWlanSigStatsSnrBest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 10), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSnrBest.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSnrBest.setDescription('The best SNR value seen so far. (Remember that +30dBm SNR is better than +20dBm). This value is initialized to -500dB.')
ccWlanSigStatsSnrWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 11), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSnrWorst.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSnrWorst.setDescription('The worst SNR value seen so far. (Remember that +10dBm SNR is worse than +20dBm). This value is initialized to 500dB.')
ccWlanSigStatsSnrSum = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSnrSum.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSnrSum.setDescription('A running sum of all SNR values calculated by the switch (using reported RSSI values), for packets received. Unlike _Signal and _Noise, this value is never negative.')
ccWlanSigStatsSnrSumSquares = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 8, 1, 13), Counter64()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSigStatsSnrSumSquares.setStatus('current')
if mibBuilder.loadTexts: ccWlanSigStatsSnrSumSquares.setDescription('A sum of the squares of each SNR value calculated for packets received. This value is never negative.')
ccWlanSumStatsShortTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9), )
if mibBuilder.loadTexts: ccWlanSumStatsShortTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortTable.setDescription('Averages and rates calculated over the SHORT window for each WLAN.')
ccWlanSumStatsShortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanSumStatsShortEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortEntry.setDescription(' ')
ccWlanSumStatsShortTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortTimestamp.setDescription("Snapshot of sysUpTime as of the END of the 'window' of time that this entry of values represents.")
ccWlanSumStatsShortNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortNumPkts.setDescription('The number of packets used to calculate the statistics in this window.')
ccWlanSumStatsShortPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSec100.setDescription("Packets per second as averaged over the 'window'. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccWlanSumStatsShortPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSecTx100.setDescription("Packets per second TX as averaged over the 'window'. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries). Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccWlanSumStatsShortPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPktsPerSecRx100.setDescription("Packets per second RX as averaged over the 'window'. Since SNMP does not convey decimal values, the result is multiplied by 100.")
ccWlanSumStatsShortThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughput.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughput.setDescription('Actual number of bits sent and received over the window, divided by the number of seconds in the window. For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccWlanSumStatsShortThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughputTx.setDescription('Actual number of bits TX over the window, divided by the number of seconds in the window. Each packet sucessfully sent counts as 1, (not N, where N is the number of retries).')
ccWlanSumStatsShortThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortThroughputRx.setDescription('Actual number of bits RX over the window, divided by the number of seconds in the window.')
ccWlanSumStatsShortAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgBitSpeed.setDescription('An octet-weighted average of the speeds of all packets sent/received. (For each possible speed, multiply the number of octets sent/received by that speed; divide the sum by the total number of octets; multiply by 8). For transmitted packets, each packet sucessfully sent counts as 1, (not N, where N is the number of retries). This can be said in more plain english as: the average bit-speed at which packets were sent/received.')
ccWlanSumStatsShortAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuSignal.setDescription('The average of all signal values over the window. NOTE: dBm are normally negative. Here the NEGATIVE values are reported as POSITIVE values. PO')
ccWlanSumStatsShortAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuNoise.setDescription('The average of all noise values over the window.')
ccWlanSumStatsShortAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortAvgMuSnr.setDescription('The average of all SNR values over the window.')
ccWlanSumStatsShortPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kNUcastPkts.setDescription('Ratio of packets that were NOT unicast. Expressed as parts-per-10000.')
ccWlanSumStatsShortPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kTxWithRetries.setDescription('Ratio of TX packets that experienced one or more retries. Expressed as parts-per-10000.')
ccWlanSumStatsShortPp10kDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kDropped.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kDropped.setDescription('Packets dropped divided by packets sent. Dropped here means dropped intentionally due to the appropriate QoS queue being full. Other reasons for dropped packets are not counted in this ratio.')
ccWlanSumStatsShortTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortTxAvgRetries100.setDescription('For all transmit packets (those that experienced some retries, those that were successfully transmitted with only 1 transmission, and those that attempted max times and gave-up), the average number of RE-transmission attempts. Said another (though identical) way: the sum of all tranmission attempts divided by the number of unique packets attempted to be sent. Since SNMP does not convey decimal values, the result above is multiplied by 100. If there were no RE-transmissions, this value would be 0. If every single packet required exactly two tranmissions, this value would be 100, (representing 1.00).')
ccWlanSumStatsShortPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortPp10kRxUndecrypt.setDescription('Ratio of RX packets that were undecryptable. Expressed as parts-per-10000.')
ccWlanSumStatsShortTotalMus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('number of MUs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsShortTotalMus.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsShortTotalMus.setDescription('The number of packets used to calculate the statistics in this window for all MUs associated with WLAN.')
ccWlanSumStatsShortSkip1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 9, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanSumStatsShortSkip1.setStatus('obsolete')
if mibBuilder.loadTexts: ccWlanSumStatsShortSkip1.setDescription('Not relevant for WS2000 2.0.')
ccWlanSumStatsLongTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10), )
if mibBuilder.loadTexts: ccWlanSumStatsLongTable.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongTable.setDescription('Averages and rates calculated over the LONG window for each WLAN. (Refer to ccWlanSumStatsShortTable for descriptions).')
ccWlanSumStatsLongEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWlanIndex"))
if mibBuilder.loadTexts: ccWlanSumStatsLongEntry.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongEntry.setDescription(' ')
ccWlanSumStatsLongTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongTimestamp.setDescription(' ')
ccWlanSumStatsLongNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongNumPkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongNumPkts.setDescription(' ')
ccWlanSumStatsLongPktsPerSec100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 3), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSec100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSec100.setDescription(' ')
ccWlanSumStatsLongPktsPerSecTx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 4), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSecTx100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSecTx100.setDescription(' ')
ccWlanSumStatsLongPktsPerSecRx100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 5), ScaleBy100()).setUnits('pkts per sec x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSecRx100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPktsPerSecRx100.setDescription(' ')
ccWlanSumStatsLongThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 6), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughput.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughput.setDescription(' ')
ccWlanSumStatsLongThroughputTx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 7), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughputTx.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughputTx.setDescription(' ')
ccWlanSumStatsLongThroughputRx = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 8), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughputRx.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongThroughputRx.setDescription(' ')
ccWlanSumStatsLongAvgBitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 9), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgBitSpeed.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgBitSpeed.setDescription(' ')
ccWlanSumStatsLongAvgMuSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuSignal.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuSignal.setDescription(' ')
ccWlanSumStatsLongAvgMuNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuNoise.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuNoise.setDescription(' ')
ccWlanSumStatsLongAvgMuSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 12), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuSnr.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongAvgMuSnr.setDescription(' ')
ccWlanSumStatsLongPp10kNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 13), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kNUcastPkts.setDescription(' ')
ccWlanSumStatsLongPp10kTxWithRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 14), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kTxWithRetries.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kTxWithRetries.setDescription(' ')
ccWlanSumStatsLongPp10kDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 15), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kDropped.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kDropped.setDescription(' ')
ccWlanSumStatsLongTxAvgRetries100 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 16), ScaleBy100()).setUnits('average x100').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongTxAvgRetries100.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongTxAvgRetries100.setDescription(' ')
ccWlanSumStatsLongPp10kRxUndecrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 17), PartsPer10k()).setUnits('parts-per-10000').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kRxUndecrypt.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongPp10kRxUndecrypt.setDescription(' ')
ccWlanSumStatsLongTotalMus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('number of MUs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWlanSumStatsLongTotalMus.setStatus('current')
if mibBuilder.loadTexts: ccWlanSumStatsLongTotalMus.setDescription(' ')
ccWlanSumStatsLongSkip1 = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 4, 5, 100, 10, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWlanSumStatsLongSkip1.setStatus('obsolete')
if mibBuilder.loadTexts: ccWlanSumStatsLongSkip1.setDescription('Description.')
ccSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5))
ccWan = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1))
ccWanTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1), )
if mibBuilder.loadTexts: ccWanTable.setStatus('current')
if mibBuilder.loadTexts: ccWanTable.setDescription('Table of WAN interfaces. There is only one WAN interface on the WS2000, but we show the WAN interface in a table for consistancy and to have an entry to point to from other tables, (such as the MatrixSrc and MatrixDest tables).')
ccWanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanIndex"))
if mibBuilder.loadTexts: ccWanEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanEntry.setDescription(' ')
ccWanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanIndex.setDescription('Simple index.')
ccWanDhcpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanDhcpEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpEnable.setDescription('Enable DHCP on this WAN interface. ')
ccWanDhcpIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanDhcpIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpIpAddr.setDescription('The IP address obtained via DHCP. If DHCP is disabled or if DHCP has not yet obtained values, this value will be 0.0.0.0.')
ccWanDhcpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanDhcpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpSubnetMask.setDescription('The subnet mask address obtained via DHCP. If DHCP is disabled or if DHCP has not yet obtained values, this value will be 0.0.0.0.')
ccWanDhcpDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanDhcpDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpDefaultGateway.setDescription('The default gateway obtained via DHCP. If DHCP is disabled or if DHCP has not yet obtained values, this value will be 0.0.0.0.')
ccWanDhcpPrimaryDnsServer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanDhcpPrimaryDnsServer.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpPrimaryDnsServer.setDescription('The primary DNS server obtained via DHCP. If DHCP is disabled or if DHCP has not yet obtained values, this value will be 0.0.0.0.')
ccWanDhcpSecondaryDnsServer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanDhcpSecondaryDnsServer.setStatus('current')
if mibBuilder.loadTexts: ccWanDhcpSecondaryDnsServer.setDescription('The secondary DNS server obtained via DHCP. If DHCP is disabled or if DHCP has not yet obtained values, this value will be 0.0.0.0.')
ccWanSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ccWanSubnetMask.setDescription('The subnet mask to use if DHCP is not enabled. If DHCP is enabled, this value is still writeable, but is not used.')
ccWanDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: ccWanDefaultGateway.setDescription('The default gateway to use if DHCP is not enabled. If DHCP is enabled, this value is still writeable, but is not used.')
ccWanPrimaryDnsServer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPrimaryDnsServer.setStatus('current')
if mibBuilder.loadTexts: ccWanPrimaryDnsServer.setDescription('The primary DNS server to use if DHCP is not enabled. If DHCP is enabled, this value is still writeable, but is not used.')
ccWanSecondaryDnsServer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanSecondaryDnsServer.setStatus('current')
if mibBuilder.loadTexts: ccWanSecondaryDnsServer.setDescription('The secondary DNS server to use if DHCP is not enabled. If DHCP is enabled, this value is still writeable, but is not used.')
ccWanPppoeTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2), )
if mibBuilder.loadTexts: ccWanPppoeTable.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeTable.setDescription('PPPoE settings for WAN interfaces.')
ccWanPppoeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanIndex"))
if mibBuilder.loadTexts: ccWanPppoeEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeEntry.setDescription(' ')
ccWanPppoeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 1), StaticRowEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoeEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeEnable.setDescription('Enable PPPoE for this WAN interface.')
ccWanPppoeUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoeUsername.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeUsername.setDescription('PPPoE username.')
ccWanPppoePassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoePassword.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoePassword.setDescription('PPPoE password. When this value is read, the switch returns a DisplayString of zero length.')
ccWanPppoeKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoeKeepAlive.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeKeepAlive.setDescription('PPPoE keep-alive.')
ccWanPppoeIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoeIdleTime.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeIdleTime.setDescription('PPPoE idle time.')
ccWanPppoeAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("papOrChap", 2), ("pap", 3), ("chap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanPppoeAuthType.setStatus('current')
if mibBuilder.loadTexts: ccWanPppoeAuthType.setDescription('PPPoE authentication type. If no bits are set, no authentication is done. If more than one bit is set, any of the selected methods may be used by the switch.')
ccWanIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 3), )
if mibBuilder.loadTexts: ccWanIpAddrTable.setStatus('current')
if mibBuilder.loadTexts: ccWanIpAddrTable.setDescription('Table of IP addresses for the given WAN interface. Up to 8 IP addresses per WAN interface.')
ccWanIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanIpAddrIndex"))
if mibBuilder.loadTexts: ccWanIpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanIpAddrEntry.setDescription(' ')
ccWanIpAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanIpAddrIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanIpAddrIndex.setDescription('Simple index 1..8 of entries for each WAN interface.')
ccWanIpAddrEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 3, 1, 2), StaticRowEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanIpAddrEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanIpAddrEnable.setDescription('Enable this entry.')
ccWanIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanIpAddr.setDescription('WAN IP address.')
ccWanFirewall = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4))
ccWanFirewallGlobalEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanFirewallGlobalEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallGlobalEnable.setDescription('This variable enables/disables the global state of the firewall. Note that if the firewall function is disabled, NAT, VPN, content filtering and subnet access are also disabled. (Disabling all these functions would only be useful in using the WS2000 in an existing network topology). Factory-default state is TRUE.')
ccWanFirewallTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2), )
if mibBuilder.loadTexts: ccWanFirewallTable.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallTable.setDescription('Table of Firewall attacks that can be enabled/disabled.')
ccWanFirewallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanIndex"))
if mibBuilder.loadTexts: ccWanFirewallEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallEntry.setDescription(' ')
ccWanFirewallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("fwIpSpoofing", 1), ("fwPingOfDeath", 2), ("fwLandAttack", 3), ("fwReassemblyAttack", 4), ("fwSynFloodAttack", 5), ("fwSourceRouting", 6), ("fwWinnukeAttack", 7), ("fwFtpBounceAttack", 8), ("fwIpUnalignedTimestamp", 9), ("fwIpSequenceNumberPrediction", 10), ("fwMimeFloodAttack", 11)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanFirewallIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallIndex.setDescription('Simple index, but with explicitly enumerated values.')
ccWanFirewallDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanFirewallDescription.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallDescription.setDescription('Short description of the type of attack.')
ccWanFirewallAlwaysEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanFirewallAlwaysEnabled.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallAlwaysEnabled.setDescription('A few of the firewall algorithms can NOT be disabled. If this value is TRUE, this is one of those algorithms. Any attempt to set ccWanFwEnable to FALSE will result in a BAD-VALUE error.')
ccWanFirewallEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanFirewallEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallEnable.setDescription('Set to TRUE to enable this type of firewall check.')
ccWanFirewallMimeFloodMaxHeaderLength = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 3), Unsigned32()).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanFirewallMimeFloodMaxHeaderLength.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallMimeFloodMaxHeaderLength.setDescription('Mime flood attack check max header length.')
ccWanFirewallMimeFloodMaxHeaders = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanFirewallMimeFloodMaxHeaders.setStatus('current')
if mibBuilder.loadTexts: ccWanFirewallMimeFloodMaxHeaders.setDescription('Mime flood attack check max headers.')
ccWanNatTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 4, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatTimeout.setStatus('current')
if mibBuilder.loadTexts: ccWanNatTimeout.setDescription('Timeout value for NAT.')
ccWanNat = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5))
ccWanNatLowestUnusedSlot = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanNatLowestUnusedSlot.setStatus('current')
if mibBuilder.loadTexts: ccWanNatLowestUnusedSlot.setDescription('Since the ccWanNatTable is actually implemented as a single list of entries, the second index of the ccWanNatTable, (ccWanNatIndex), must be unique across all ccWanNatTable entries. This scalar tells the network management software the lowest unused value that is available to be used for ccWanNatIndex, when creating a new ccWanNatTable entry. ')
ccWanNatTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2), )
if mibBuilder.loadTexts: ccWanNatTable.setStatus('current')
if mibBuilder.loadTexts: ccWanNatTable.setDescription('Table of NAT mappings for each IP address assigned to each WAN interface. (The WS2000 currently only has one WAN interface, but all MIBs are designed for the possibility of multiple WAN interfaces).')
ccWanNatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanNatIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanNatWanIpAddress"))
if mibBuilder.loadTexts: ccWanNatEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanNatEntry.setDescription(' ')
ccWanNatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanNatIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanNatIndex.setDescription('Simple index matching the simple index in the ccWanTable.')
ccWanNatWanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 2), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanNatWanIpAddress.setStatus('current')
if mibBuilder.loadTexts: ccWanNatWanIpAddress.setDescription('One, (of possibly several), IP addresses assigned to this WAN interface. One entries in this table will appear for each matching entry in the ccWanIpAddrTable.')
ccWanNatType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("natNone", 1), ("nat1to1", 2), ("nat1toMany", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatType.setStatus('current')
if mibBuilder.loadTexts: ccWanNatType.setDescription("Configure the NAT type. Only if 'nat1to1' is selected is the ccWanNat1to1IpAddr value is used. In such a case, any corresponding entries in the ccWanNatInboundTable and the ccWanNatOutboundTable are ignored. If 'none' is selected, all the above mentioned values are ignored. If '1toMany' is selected, the ccWanNat1to1IpAddr value is ignored, but entries, (if any), in the two tables are relevant.")
ccWanNat1to1IpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNat1to1IpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanNat1to1IpAddr.setDescription("The IP address to use for outbound 1-to-1 mapping. Only used if ccWanNatType is '1to1'.")
ccWanNatInboundDefaultEna = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundDefaultEna.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundDefaultEna.setDescription('If set, any port that is NOT found in the ccWanNatInboundTable entries is forwarded to the IP addr specified by ccWanNatInboundDefaultIp.')
ccWanNatInboundDefaultIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundDefaultIp.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundDefaultIp.setDescription('IP addr to send ports that do not match any entry in the ccWanNatInboundTable.')
ccWanNatInboundTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3), )
if mibBuilder.loadTexts: ccWanNatInboundTable.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundTable.setDescription("Table of inbound NAT mappings for IP addresses on WAN interfaces that are set to ccWanNatType of '1to1' or '1toMany'.")
ccWanNatInboundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanNatIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanNatWanIpAddress"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanNatInboundIndex"))
if mibBuilder.loadTexts: ccWanNatInboundEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundEntry.setDescription(' ')
ccWanNatInboundIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanNatInboundIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundIndex.setDescription('A given IP address on a given WAN interface may have many inbound NAT mappings. This (3rd) index numbers those many mappings.')
ccWanNatInboundName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundName.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundName.setDescription('Name of the inbound mapping.')
ccWanNatInboundTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("ah", 5), ("esp", 6), ("gre", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundTransport.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundTransport.setDescription('Transport for which this mapping applies.')
ccWanNatInboundStartPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundStartPort.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundStartPort.setDescription('Low-end of the port range.')
ccWanNatInboundEndPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundEndPort.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundEndPort.setDescription('High-end of the port range.')
ccWanNatInboundIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundIpAddr.setDescription('IP address to map to.')
ccWanNatInboundTranslationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundTranslationPort.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundTranslationPort.setDescription('Description.')
ccWanNatInboundRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 3, 1, 8), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatInboundRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccWanNatInboundRowStatus.setDescription('Simple row status.')
ccWanNatOutboundTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4), )
if mibBuilder.loadTexts: ccWanNatOutboundTable.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundTable.setDescription("Table of outbound NAT mappings for IP addresses on WAN interfaces that are set to ccWanNatType of '1toMany'.")
ccWanNatOutboundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanNatIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanNatWanIpAddress"), (0, "SYMBOL-CC-WS2000-MIB", "ccWanNatOutboundSubnetIndex"))
if mibBuilder.loadTexts: ccWanNatOutboundEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundEntry.setDescription(' ')
ccWanNatOutboundSubnetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanNatOutboundSubnetIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundSubnetIndex.setDescription('A different mapping can be set for each subnet. This (3rd) index specifies the subnet. This index is the same value for a given subnet as in the ccLanTable.')
ccWanNatOutboundEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatOutboundEnable.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundEnable.setDescription('Enable the Outbound entry.')
ccWanNatOutboundPossibleIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4, 1, 3), MultiPointer63()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanNatOutboundPossibleIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundPossibleIpAddr.setDescription('This multi-bit-mask-pointer points to every IP address in the ccWanIpAddrTable that is a valid outbound NAT mapping for this subnet. Setting this value to all 0s effectively disables this NAT mapping.')
ccWanNatOutboundIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 5, 4, 1, 4), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanNatOutboundIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccWanNatOutboundIpAddr.setDescription('This value points to the ccWanIpAddrTable entry that has been selected for the outbound NAT mapping.')
ccWanVpn = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6))
ccWanVpnTunnelConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4))
ccWanVpnTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1), )
if mibBuilder.loadTexts: ccWanVpnTable.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnTable.setDescription('Table of VPN entries.')
ccWanVpnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanVpnIndex"))
if mibBuilder.loadTexts: ccWanVpnEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnEntry.setDescription('Description.')
ccWanVpnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccWanVpnIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIndex.setDescription('Simple Index.')
ccWanVpnName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnName.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnName.setDescription('Name of VPN tunnel.')
ccWanVpnLocalSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 3), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnLocalSubnet.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnLocalSubnet.setDescription('Points to a ccSubnetTable entry. 1-LAN1, 2-LAN2, 3-WAN')
ccWanVpnLocalWanIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 4), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnLocalWanIp.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnLocalWanIp.setDescription('Points to a ccWanIpAddr entry.')
ccWanVpnRemoteSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnRemoteSubnet.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnRemoteSubnet.setDescription('IP addr of the remote subnet.')
ccWanVpnRemoteSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnRemoteSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnRemoteSubnetMask.setDescription('Mask for remote subnet.')
ccWanVpnRemoteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnRemoteGateway.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnRemoteGateway.setDescription('Gateway IP addr for the remote subnet.')
ccWanVpnKeyExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2))).clone('manual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyExchange.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyExchange.setDescription('Selects manual or automatic key exchange mechanism.')
ccWanVpnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnRowStatus.setDescription('Used to create/destroy rows.')
ccWanVpnKeyManualTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2), )
if mibBuilder.loadTexts: ccWanVpnKeyManualTable.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualTable.setDescription('Table of Manual Key Setting entries.')
ccWanVpnKeyManualEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1), )
ccWanVpnEntry.registerAugmentions(("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualEntry"))
ccWanVpnKeyManualEntry.setIndexNames(*ccWanVpnEntry.getIndexNames())
if mibBuilder.loadTexts: ccWanVpnKeyManualEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualEntry.setDescription('Description.')
ccWanVpnKeyManualAhAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("md5", 2), ("sha1", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualAhAuth.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualAhAuth.setDescription('data authentication and anti-replay services for the VPN tunnel. The following 2 keys have max length: md5 - 32 hex characters sha1 - 40 ')
ccWanVpnKeyManualInAhAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 2), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualInAhAuthKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualInAhAuthKey.setDescription('AH Authentication Key for inbound traffic.')
ccWanVpnKeyManualOutAhAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 3), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualOutAhAuthKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualOutAhAuthKey.setDescription('AH Authentication Key for outbound traffic.')
ccWanVpnKeyManualInAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualInAhSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualInAhSpi.setDescription('inbound security association created by the AH algorithm.')
ccWanVpnKeyManualOutAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualOutAhSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualOutAhSpi.setDescription('outbound security association created by the AH algorithm.')
ccWanVpnKeyManualEspType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("esp", 2), ("espWithAuthentication", 3))).clone('esp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualEspType.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualEspType.setDescription('packet encryption and optional data authentication and anti-replay services for the VPN tunnel. Some of the next 6 variables are used depending on: none - all 6 variables are ignored esp - first 3 are used, next 3 ignored espWithAuth - all 6 are used ')
ccWanVpnKeyManualEspEncrypAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("des", 1), ("des3", 2), ("aes128bit", 3), ("aes192bit", 4), ("aes256bit", 5))).clone('des')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualEspEncrypAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualEspEncrypAlg.setDescription('ESP Encryption Algorithm. The following 2 keys have max length: des - 16 hex characters des3 - 48 aes128bit - 32 aes192bit - 48 aes256bit - 64 ')
ccWanVpnKeyManualInEspEncrypKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 8), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspEncrypKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspEncrypKey.setDescription('ESP Encryption Key for inbound traffic.')
ccWanVpnKeyManualOutEspEncrypKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 9), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspEncrypKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspEncrypKey.setDescription('ESP Encryption Key for inbound traffic.')
ccWanVpnKeyManualEspAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha1", 2))).clone('md5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualEspAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualEspAuthAlg.setDescription('ESP Authentication Algorithm. The following 2 keys have max length: md5 - 32 hex characters sha1 - 40')
ccWanVpnKeyManualInEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 11), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspAuthKey.setDescription('ESP Authentication Key for inbound traffic.')
ccWanVpnKeyManualOutEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 12), HexPassword().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspAuthKey.setDescription('ESP Authentication Key for outbound traffic.')
ccWanVpnKeyManualInEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualInEspSpi.setDescription('inbound security association created by the ESP algorithm.')
ccWanVpnKeyManualOutEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyManualOutEspSpi.setDescription('outbound security association created by the ESP algorithm.')
ccWanVpnKeyAutoTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3), )
if mibBuilder.loadTexts: ccWanVpnKeyAutoTable.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoTable.setDescription('Table of Auto Key Setting entries.')
ccWanVpnKeyAutoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1), )
ccWanVpnEntry.registerAugmentions(("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoEntry"))
ccWanVpnKeyAutoEntry.setIndexNames(*ccWanVpnEntry.getIndexNames())
if mibBuilder.loadTexts: ccWanVpnKeyAutoEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoEntry.setDescription('Description.')
ccWanVpnKeyAutoUsePerfectSecrecy = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoUsePerfectSecrecy.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoUsePerfectSecrecy.setDescription('enable Perfect Forward Secrecy.')
ccWanVpnKeyAutoAhAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("md5", 2), ("sha1", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoAhAuth.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoAhAuth.setDescription('data authentication and anti-replay services for the VPN tunnel.')
ccWanVpnKeyAutoEspType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("esp", 2), ("espWithAuthentication", 3))).clone('esp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspType.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspType.setDescription('packet encryption and optional data authentication and anti-replay services for the VPN tunnel. Some of the next 2 variables are used depending on: none - the 2 variables are ignored esp - the first is used, the second is ignored espWithAuth - both variables are used')
ccWanVpnKeyAutoEspEncrypAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("des", 1), ("des3", 2), ("aes128bit", 3), ("aes196bit", 4), ("aes256bit", 5))).clone('des')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspEncrypAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspEncrypAlg.setDescription('ESP Encryption Algorithm.')
ccWanVpnKeyAutoEspAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha1", 2))).clone('md5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoEspAuthAlg.setDescription('ESP Authentication Algorithm. ')
ccWanVpnKeyAutoIkeOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("aggressive", 2))).clone('main')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeOperationMode.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeOperationMode.setDescription('IKE opreational mode. IKE main mode refers to the identity-protection exchange, and IKE aggressive mode refers to the aggressive exchange')
ccWanVpnKeyAutoIkeLocalIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("fqdn", 2), ("ufqdn", 3))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeLocalIdType.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeLocalIdType.setDescription("type of ID to be used for the WS 2000 end of the SA. The next variable only applies if this is set to 'fqdn' or 'ufqdn'. ")
ccWanVpnKeyAutoIkeLocalIdData = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 8), DisplayString().clone('?')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeLocalIdData.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeLocalIdData.setDescription('Based upon the Local ID type you gave, specify the FQDN or UFQDN,')
ccWanVpnKeyAutoIkeRemoteIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("fqdn", 2), ("ufqdn", 3))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeRemoteIdType.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeRemoteIdType.setDescription("type of ID to be used for the remote end of the SA. The next variable only applies if this is set to 'fqdn' or 'ufqdn'. ")
ccWanVpnKeyAutoIkeRemoteIdData = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 10), DisplayString().clone('?')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeRemoteIdData.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeRemoteIdData.setDescription('Based upon the Remote ID type you gave, specify the FQDN or UFQDN.')
ccWanVpnKeyAutoIkeAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("psk", 1), ("rsa", 2))).clone('psk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthType.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthType.setDescription('IKE Authentication Type.')
ccWanVpnKeyAutoIkeAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha1", 2))).clone('md5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthAlg.setDescription('IKE Authentication Algorithm.')
ccWanVpnKeyAutoIkeAuthPassphrase = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 13), Password().clone('?')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthPassphrase.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeAuthPassphrase.setDescription('With Pre-Shared Key as the authentication mode, provide a key. MD5 : 32-character hexadecimal key. SHA1 : 40-character hexadecimal key. ')
ccWanVpnKeyAutoIkeEncrypAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("des", 1), ("des3", 2), ("aes128bit", 3), ("aes196bit", 4), ("aes256bit", 5))).clone('des')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeEncrypAlg.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeEncrypAlg.setDescription('IKE Encryption Algorithm.')
ccWanVpnKeyAutoIkeXauthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("generic", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthMode.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthMode.setDescription("Currently XAUTH mechanism is not supported by WS2000 version 2.0. If 'none', the next 2 variables are ignored. ")
ccWanVpnKeyAutoIkeXauthUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 16), DisplayString().clone('?')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthUsername.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthUsername.setDescription('Currently XAUTH mechanism is not supported by WS2000 version 2.0.')
ccWanVpnKeyAutoIkeXauthPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 17), Password().clone('?')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthPassword.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeXauthPassword.setDescription('Currently XAUTH mechanism is not supported by WS2000 version 2.0.')
ccWanVpnKeyAutoIkeKeyLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 4294967295))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeKeyLifetime.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeKeyLifetime.setDescription('The number of seconds that the key is valid.')
ccWanVpnKeyAutoIkeDiffieHelmanGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 4, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("group1length768bit", 1), ("group2length1024bit", 2))).clone('group1length768bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeDiffieHelmanGroup.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnKeyAutoIkeDiffieHelmanGroup.setDescription('The Diffie-Hellman key agreement protocol allows two users to exchange a secret key over an insecure medium without any prior secrets.')
ccWanVpnTunnelStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5))
ccWanVpnSaTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1), )
if mibBuilder.loadTexts: ccWanVpnSaTable.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaTable.setDescription('Status of all tunnels that have been configured on the switch.')
ccWanVpnSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanVpnSaTunnelName"))
if mibBuilder.loadTexts: ccWanVpnSaEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaEntry.setDescription('Description.')
ccWanVpnSaTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaTunnelName.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaTunnelName.setDescription('Tunnel Name.')
ccWanVpnSaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("nonActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaStatus.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaStatus.setDescription('Status of each of the configured tunnels. When the tunnel is not in use the status will read NOT_ACTIVE. When the tunnel is connected the status will read ACTIVE.')
ccWanVpnSaInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaInSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaInSpi.setDescription('Inbound SPI Security Parameter Index (SPI) for each of the tunnels. This is used locally by the switch to identify a security association. There are unique outbound and inbound SPIs.')
ccWanVpnSaOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaOutSpi.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaOutSpi.setDescription('Outbound Security Parameter Index (SPI) for each of the tunnels. This is used locally by the switch to identify a security association. There are unique outbound and inbound SPIs.')
ccWanVpnSaLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaLifetime.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaLifetime.setDescription('Lifetime associated with a particular Security Association (SA). ')
ccWanVpnSaTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaTxBytes.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaTxBytes.setDescription('Total number amount of data (in bytes) transmitted through each of the configured tunnels.')
ccWanVpnSaRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnSaRxBytes.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnSaRxBytes.setDescription('Total number amount of data (in bytes) received through each of the configured tunnels.')
ccWanVpnIkeTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 2), )
if mibBuilder.loadTexts: ccWanVpnIkeTable.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIkeTable.setDescription('Table of tunnels configured to use IKE for automatic key exchange')
ccWanVpnIkeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanVpnIkeTunnelName"))
if mibBuilder.loadTexts: ccWanVpnIkeEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIkeEntry.setDescription('Description.')
ccWanVpnIkeTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnIkeTunnelName.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIkeTunnelName.setDescription('Tunnel name.')
ccWanVpnIkeState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnIkeState.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIkeState.setDescription('State for each of the tunnels configured to use IKE for automatic key exchange. When the tunnel is not active this will display NOT_CONNECTED. When the tunnel is active this will display CONNECTED. ')
ccWanVpnIkeRemainingLife = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 6, 5, 2, 1, 3), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanVpnIkeRemainingLife.setStatus('current')
if mibBuilder.loadTexts: ccWanVpnIkeRemainingLife.setDescription('Remaining life for the current IKE key for each of the listed tunnels.')
ccWanContentBlock = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7))
ccWanContentBlockSmtp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 1), Bits().clone(namedValues=NamedValues(("blockSmtpHelo", 0), ("blockSmtpMail", 1), ("blockSmtpRcpt", 2), ("blockSmtpData", 3), ("blockSmtpQuit", 4), ("blockSmtpSend", 5), ("blockSmtpSaml", 6), ("blockSmtpReset", 7), ("blockSmtpVrfy", 8), ("blockSmtpExpn", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanContentBlockSmtp.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockSmtp.setDescription('SMTP content block.')
ccWanContentBlockFtp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 2), Bits().clone(namedValues=NamedValues(("blockFtpStoringFiles", 0), ("blockFtpRetrievingFiles", 1), ("blockFtpDirectoryList", 2), ("blockFtpCreateDirectory", 3), ("blockFtpChangeDirectory", 4), ("blockFtpPassiveOperation", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanContentBlockFtp.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockFtp.setDescription('FTP content block.')
ccWanContentBlockHttp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 3), Bits().clone(namedValues=NamedValues(("blockHttpWebProxy", 0), ("blockHttpActiveX", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanContentBlockHttp.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockHttp.setDescription('HTTP content block.')
ccWanContentBlockOutUrlTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 4), )
if mibBuilder.loadTexts: ccWanContentBlockOutUrlTable.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockOutUrlTable.setDescription('Table of Content Block URL entries.')
ccWanContentBlockOutUrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccWanContentBlockOutUrlIndex"))
if mibBuilder.loadTexts: ccWanContentBlockOutUrlEntry.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockOutUrlEntry.setDescription('Description.')
ccWanContentBlockOutUrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccWanContentBlockOutUrlIndex.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockOutUrlIndex.setDescription('Simple Index.')
ccWanContentBlockOutUrlExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanContentBlockOutUrlExtension.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockOutUrlExtension.setDescription('URL extension.')
ccWanContentBlockOutUrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 1, 7, 4, 1, 3), StaticRowEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccWanContentBlockOutUrlRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccWanContentBlockOutUrlRowStatus.setDescription('Row Status.')
ccPort = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2))
ccPortTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1), )
if mibBuilder.loadTexts: ccPortTable.setStatus('current')
if mibBuilder.loadTexts: ccPortTable.setDescription('This table contains one entry for each physical port on the switch.')
ccPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccPortIndex"))
if mibBuilder.loadTexts: ccPortEntry.setStatus('current')
if mibBuilder.loadTexts: ccPortEntry.setDescription(' ')
ccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccPortIndex.setStatus('current')
if mibBuilder.loadTexts: ccPortIndex.setDescription("Simple index. Instance/index .1 represents the port labelled '1' on the physical unit. The WAN port will reside after all ports that are numbered on the physcial unit.")
ccPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wanPort", 1), ("lanPort", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortType.setStatus('current')
if mibBuilder.loadTexts: ccPortType.setDescription('Indicates the type of the port.')
ccPortPoeEquipped = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortPoeEquipped.setStatus('current')
if mibBuilder.loadTexts: ccPortPoeEquipped.setDescription('Indicates the port can provide power-over-ethernet.')
ccPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortStatus.setStatus('current')
if mibBuilder.loadTexts: ccPortStatus.setDescription('Tells if the port is up/down.')
ccPortDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortDuplex.setStatus('current')
if mibBuilder.loadTexts: ccPortDuplex.setDescription('Describes the duplex, (half/full), status of the port.')
ccPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccPortSpeed.setStatus('current')
if mibBuilder.loadTexts: ccPortSpeed.setDescription("Link's speed in bits per second.")
ccLan = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4))
ccSubnet = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2))
ccSubnetTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1), )
if mibBuilder.loadTexts: ccSubnetTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetTable.setDescription('Table of Subnets.')
ccSubnetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"))
if mibBuilder.loadTexts: ccSubnetEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetEntry.setDescription(' ')
ccSubnetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSubnetIndex.setStatus('current')
if mibBuilder.loadTexts: ccSubnetIndex.setDescription('Simple index, 1..4')
ccSubnetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 2), StaticRowEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetEnable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetEnable.setDescription('Enable this Subnet.')
ccSubnetName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetName.setStatus('current')
if mibBuilder.loadTexts: ccSubnetName.setDescription('Subnet name.')
ccSubnetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetIpAddress.setStatus('current')
if mibBuilder.loadTexts: ccSubnetIpAddress.setDescription('Ip address of this Subnet.')
ccSubnetIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ccSubnetIpSubnetMask.setDescription('IPaddr subnet mask of this Subnet')
ccSubnetPortMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 6), Bits().clone(namedValues=NamedValues(("null", 0), ("port1", 1), ("port2", 2), ("port3", 3), ("port4", 4), ("port5", 5), ("port6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetPortMembers.setStatus('current')
if mibBuilder.loadTexts: ccSubnetPortMembers.setDescription('Pointer to zero or more ports that are members of this Subnet. No port can be a member of more than one Subnet at any given time.')
ccSubnetWlanMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 7), Bits().clone(namedValues=NamedValues(("null", 0), ("wlan1", 1), ("wlan2", 2), ("wlan3", 3), ("wlan4", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetWlanMembers.setStatus('current')
if mibBuilder.loadTexts: ccSubnetWlanMembers.setDescription('Pointer to zero or more WLANs that are members of this Subnet. No Subnet can be a member of more than one Subnet at any given time.')
ccSubnetDhcpState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dhcpClient", 1), ("dhcpServer", 2), ("dhcpNone", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpState.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpState.setDescription('Specifies how Subnet gets its IP address/mask.')
ccSubnetDhcpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetDhcpIpAddress.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpIpAddress.setDescription('The IP address obtained via DHCP if this Subnet is configured as a DHCP client. If this Subnet is configured to not use DHCP, or is a DHCP server this value will be 0.0.0.0. Likewise, if this Subnet is configured to be a DHCP client but has not yet obtained a value via DHCP, this value will be 0.0.0.0.')
ccSubnetDhcpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 1, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetDhcpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpSubnetMask.setDescription('The Subnet IPaddr subnet mask obtained via DHCP if this Subnet is configured as a DHCP client. If this Subnet is configured to not use DHCP, or is a DHCP server this value will be 0.0.0.0. Likewise, if this Subnet is configured to be a DHCP client but has not yet obtained a value via DHCP, this value will be 0.0.0.0.')
ccSubnetDhcpServerTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2), )
if mibBuilder.loadTexts: ccSubnetDhcpServerTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerTable.setDescription('Configures a DHCP server for a Subnet. While these values can always be SET, they will only take effect if the given Subnet is enabled and configured to be a DHCP server.')
ccSubnetDhcpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"))
if mibBuilder.loadTexts: ccSubnetDhcpServerEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerEntry.setDescription(' ')
ccSubnetDhcpServerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 1), StaticRowEnable()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetDhcpServerEnable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerEnable.setDescription('Enable DHCP Server functionality on this Subnet.')
ccSubnetDhcpServerPoolStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerPoolStart.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerPoolStart.setDescription('The start/low end of the range of IP addresses to give-out.')
ccSubnetDhcpServerPoolEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerPoolEnd.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerPoolEnd.setDescription('The end/high-end of the range of IP addresses to give-out.')
ccSubnetDhcpServerPrimaryDns = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerPrimaryDns.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerPrimaryDns.setDescription('IP address of primary DNS server to assign to DHCP clients.')
ccSubnetDhcpServerSecondaryDns = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerSecondaryDns.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerSecondaryDns.setDescription('IP address of secondary DNS server to assign to DHCP clients.')
ccSubnetDhcpServerDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerDefaultGateway.setDescription('IP address of default gateway to assign to DHCP clients.')
ccSubnetDhcpServerLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 7), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerLeaseTime.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerLeaseTime.setDescription('DHCP lease time.')
ccSubnetDhcpServerWinsServer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerWinsServer.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerWinsServer.setDescription('DHCP Server WINS server IP Address.')
ccSubnetDhcpServerDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 2, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetDhcpServerDomainName.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerDomainName.setDescription('DHCP server Domain Name.')
ccSubnetDhcpServerStaticMapTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 3), )
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapTable.setDescription('Table of static MAC-IPaddr mappings for the given DHCP server.')
ccSubnetDhcpServerStaticMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerStaticMapMac"))
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapEntry.setDescription(' ')
ccSubnetDhcpServerStaticMapMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 3, 1, 1), PhysAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapMac.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapMac.setDescription('MAC address to be mapped.')
ccSubnetDhcpServerStaticMapIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapIpAddr.setDescription('IP address to assign to this MAC address.')
ccSubnetDhcpServerStaticMapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 3, 1, 3), AbbrevRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapEnable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetDhcpServerStaticMapEnable.setDescription('Value to control row creation/deletion.')
ccSubnetAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4))
ccSubnetAccessTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1), )
if mibBuilder.loadTexts: ccSubnetAccessTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessTable.setDescription('Describes how packets are allowed to flow from different sources to different destinations. Note that since only subnets can be sources for this table, the ccSubnetTable:ccSubnetIndex is used as the 1st index to this table. Note that this table never contains entries where src==dest, for example, there is no entry with: _SrcPointerToSource points to subnet1 _DestPointerToSource points to subnet1 Note also that if a given subnet does not exisit, (because it has not been enabled in ccSubnetTable), no entries in this table will exist with that subnet as either src or dest. ')
ccSubnetAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"), (0, "SYMBOL-CC-WS2000-MIB", "ccSubnetAccessDestIndex"))
if mibBuilder.loadTexts: ccSubnetAccessEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessEntry.setDescription(' ')
ccSubnetAccessDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSubnetAccessDestIndex.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessDestIndex.setDescription('Simple index for destination.')
ccSubnetAccessDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("destSubnet", 1), ("destWan", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetAccessDestType.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessDestType.setDescription("Type of the destination. destDrop is a 'virtual' destination that accounts for all dropped packets.")
ccSubnetAccessDestPtrToDest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1, 3), SinglePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetAccessDestPtrToDest.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessDestPtrToDest.setDescription('A pointer to the corresponding entry in the ccSubnet or ccWan table, (depending on _DestType). ')
ccSubnetAccessRuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleType.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleType.setDescription('All ccSubnetAccessRuleTable entries for this combination of ccSubnetIndex and ccSubnetAccessDestIndex will be of the same type, (accept or deny). ')
ccSubnetAccessPtrToRules = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 1, 1, 5), MultiPointer255()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccSubnetAccessPtrToRules.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessPtrToRules.setDescription('Points to the zero or more ccSubnetAccessRuleTable entries that correspond to this ccSubnetIndex + ccSubnetAccessDestIndex combination/entry. This value cannot be changed here, but is a reflection of the ccSubnetAccessRuleTable entries that currently point to this entry via their ccSubnetAccessRuleSrcPtr and _DestPtr values. ')
ccSubnetAccessRuleTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2), )
if mibBuilder.loadTexts: ccSubnetAccessRuleTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleTable.setDescription('Describes how packets are allowed to flow from different sources to different destinations. Note that since only subnets can be sources for this table, the ccSubnetTable:ccSubnetIndex is used as the 1st index to this table. Note that this table never contains entries where src==dest, for example, there is no entry with: _SrcPointerToSource points to subnet1 _DestPointerToSource points to subnet1 Note also that if a given subnet does not exisit, (because it has not been enabled in ccSubnetTable), no entries in this table will exist with that subnet as either src or dest. ')
ccSubnetAccessRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleIndex"))
if mibBuilder.loadTexts: ccSubnetAccessRuleEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleEntry.setDescription(' ')
ccSubnetAccessRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSubnetAccessRuleIndex.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleIndex.setDescription('Each src/dest combination can have several rules; this value is the index.')
ccSubnetAccessRuleSrcPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 2), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleSrcPtr.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleSrcPtr.setDescription('This is the value of ccSubnetIndex corresponding to the source for this rule.')
ccSubnetAccessRuleDestPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 3), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleDestPtr.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleDestPtr.setDescription('This is the value of ccSubnetAccessDestIndex corresponding to the destination for this rule.')
ccSubnetAccessRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleName.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleName.setDescription('Name of ACL entry.')
ccSubnetAccessRuleTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("ah", 5), ("esp", 6), ("gre", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleTransport.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleTransport.setDescription('Transport.')
ccSubnetAccessRuleStartPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleStartPort.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleStartPort.setDescription('Starting port number.')
ccSubnetAccessRuleEndPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleEndPort.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleEndPort.setDescription('Ending port number.')
ccSubnetAccessRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 2, 1, 8), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessRuleRowStatus.setDescription('Row status.')
ccSubnetAccessAdvInTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3), )
if mibBuilder.loadTexts: ccSubnetAccessAdvInTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInTable.setDescription('Table of Advanced Inbound entries.')
ccSubnetAccessAdvInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInIndex"))
if mibBuilder.loadTexts: ccSubnetAccessAdvInEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInEntry.setDescription('Description.')
ccSubnetAccessAdvInIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSubnetAccessAdvInIndex.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInIndex.setDescription('Description.')
ccSubnetAccessAdvInSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcIp.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcIp.setDescription('Source IP address')
ccSubnetAccessAdvInSrcIpLength = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcIpLength.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcIpLength.setDescription('Mask length for the IP address')
ccSubnetAccessAdvInDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestIp.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestIp.setDescription('Destination IP address ')
ccSubnetAccessAdvInDestIpLength = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestIpLength.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestIpLength.setDescription('mask length for the IP address')
ccSubnetAccessAdvInTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("ah", 5), ("esp", 6), ("gre", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInTransport.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInTransport.setDescription('Type of transport')
ccSubnetAccessAdvInSrcPortStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcPortStart.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcPortStart.setDescription('start of source port list ')
ccSubnetAccessAdvInSrcPortEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcPortEnd.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInSrcPortEnd.setDescription('End of source port list ')
ccSubnetAccessAdvInDestPortStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestPortStart.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestPortStart.setDescription('start of destination port list ')
ccSubnetAccessAdvInDestPortEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestPortEnd.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInDestPortEnd.setDescription('End of destination port list ')
ccSubnetAccessAdvInReverseNatIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInReverseNatIp.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInReverseNatIp.setDescription('Address to use for reverse NAT. To disable, use 0.0.0.0.')
ccSubnetAccessAdvInReverseNatPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInReverseNatPort.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInReverseNatPort.setDescription('Port to use for reverse NAT.')
ccSubnetAccessAdvInAction = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInAction.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInAction.setDescription('Action on the acl i.e allow or deny ')
ccSubnetAccessAdvInRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 3, 1, 15), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvInRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvInRowStatus.setDescription('status of the row ')
ccSubnetAccessAdvOutTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4), )
if mibBuilder.loadTexts: ccSubnetAccessAdvOutTable.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutTable.setDescription('Table of Advanced Outbound entries.')
ccSubnetAccessAdvOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutIndex"))
if mibBuilder.loadTexts: ccSubnetAccessAdvOutEntry.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutEntry.setDescription('Description.')
ccSubnetAccessAdvOutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutIndex.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutIndex.setDescription('Description.')
ccSubnetAccessAdvOutSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcIp.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcIp.setDescription('Source IP address')
ccSubnetAccessAdvOutSrcIpLength = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcIpLength.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcIpLength.setDescription('Mask length for the IP address')
ccSubnetAccessAdvOutDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestIp.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestIp.setDescription('Destination IP address')
ccSubnetAccessAdvOutDestIpLength = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestIpLength.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestIpLength.setDescription('mask length for the IP address')
ccSubnetAccessAdvOutTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("ah", 5), ("esp", 6), ("gre", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutTransport.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutTransport.setDescription('Type of transport')
ccSubnetAccessAdvOutSrcPortStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcPortStart.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcPortStart.setDescription('start of source port list')
ccSubnetAccessAdvOutSrcPortEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcPortEnd.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutSrcPortEnd.setDescription('End of source port list')
ccSubnetAccessAdvOutDestPortStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestPortStart.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestPortStart.setDescription('start of destination port list')
ccSubnetAccessAdvOutDestPortEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestPortEnd.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutDestPortEnd.setDescription('End of destination port list ')
ccSubnetAccessAdvOutReverseNat = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 11), SinglePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutReverseNat.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutReverseNat.setDescription('Points to a ccWanIpAddrTable entry representing the WAN IP addr to be used for NAT. To disable NAT, set this value to 0.')
ccSubnetAccessAdvOutAction = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutAction.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutAction.setDescription('Action on the acl i.e allow or deny')
ccSubnetAccessAdvOutRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 4, 1, 13), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOutRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOutRowStatus.setDescription('status of the row')
ccSubnetAccessAdvOverrideMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvOverrideMode.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvOverrideMode.setDescription('Override the Subnet Access and NAT settings.')
ccSubnetAccessAdvImportRules = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 2, 4, 6), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccSubnetAccessAdvImportRules.setStatus('current')
if mibBuilder.loadTexts: ccSubnetAccessAdvImportRules.setDescription('When set to 1 the Subnet Access Rules shall be imported on top of the Advanced Access rules.')
ccLanVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3))
ccLanVlanType = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("portBased", 1), ("userBased", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLanVlanType.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanType.setDescription('Type of the VLAN port/user based ')
ccLanVlanTrunkPort = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLanVlanTrunkPort.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanTrunkPort.setDescription('Port used for VLAN trunking ( 1-6) ')
ccLanVlanDefaultTag = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLanVlanDefaultTag.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanDefaultTag.setDescription('Deafult VLAN tag ( default is 1) ')
ccLanVlanTrunked = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 4), Bits().clone(namedValues=NamedValues(("noVlansAreTrunked", 0), ("trunkVlan01", 1), ("trunkVlan02", 2), ("trunkVlan03", 3), ("trunkVlan04", 4), ("trunkVlan05", 5), ("trunkVlan06", 6), ("trunkVlan07", 7), ("trunkVlan08", 8), ("trunkVlan09", 9), ("trunkVlan10", 10), ("trunkVlan11", 11), ("trunkVlan12", 12), ("trunkVlan13", 13), ("trunkVlan14", 14), ("trunkVlan15", 15), ("trunkVlan16", 16), ("trunkVlan17", 17), ("trunkVlan18", 18), ("trunkVlan19", 19), ("trunkVlan20", 20), ("trunkVlan21", 21), ("trunkVlan22", 22), ("trunkVlan23", 23), ("trunkVlan24", 24), ("trunkVlan25", 25), ("trunkVlan26", 26), ("trunkVlan27", 27), ("trunkVlan28", 28), ("trunkVlan29", 29), ("trunkVlan30", 30), ("trunkVlan31", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLanVlanTrunked.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanTrunked.setDescription('List of VLANs which are trunked. ')
ccLanVlanTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 5), )
if mibBuilder.loadTexts: ccLanVlanTable.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanTable.setDescription('Table of VLAN IDs mapped to Subnets.')
ccLanVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 5, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"))
if mibBuilder.loadTexts: ccLanVlanEntry.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanEntry.setDescription('Description.')
ccLanVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 5, 4, 3, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccLanVlanId.setStatus('current')
if mibBuilder.loadTexts: ccLanVlanId.setDescription('Vlan associated with a subnet ')
ccRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 6))
ccRouterRip = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1))
ccRouterRipType = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noRip", 1), ("ripV1", 2), ("ripV2withV1compatibility", 3), ("ripV2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRipType.setStatus('current')
if mibBuilder.loadTexts: ccRouterRipType.setDescription('RIP type.')
ccRouterRipDirection = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("rxOnly", 2), ("txOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRipDirection.setStatus('current')
if mibBuilder.loadTexts: ccRouterRipDirection.setDescription('RIP direction.')
ccRouterRip2 = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3))
ccRouterRip2AuthType = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("md5", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2AuthType.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2AuthType.setDescription('RIP v2 authentication type.')
ccRouterRip2SimplePassword = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 2), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2SimplePassword.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2SimplePassword.setDescription('Password used for RIP v2 simple authentication.')
ccRouterRip2Md5Key1Id = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2Md5Key1Id.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2Md5Key1Id.setDescription('RIP v2 with MD5 authentication: key #1 - ID.')
ccRouterRip2Md5Key1AuthKey = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 4), Password().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2Md5Key1AuthKey.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2Md5Key1AuthKey.setDescription('RIP v2 with MD5 authentication: key #1 - auth key.')
ccRouterRip2Md5Key2Id = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2Md5Key2Id.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2Md5Key2Id.setDescription('RIP v2 with MD5 authentication: key #2 - ID.')
ccRouterRip2Md5Key2AuthKey = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 1, 3, 6), Password().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterRip2Md5Key2AuthKey.setStatus('current')
if mibBuilder.loadTexts: ccRouterRip2Md5Key2AuthKey.setDescription('RIP v2 with MD5 authentication: key #2 - auth key.')
ccRouterRoutesTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2), )
if mibBuilder.loadTexts: ccRouterRoutesTable.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesTable.setDescription('Description.')
ccRouterRoutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRouterRoutesIndex"))
if mibBuilder.loadTexts: ccRouterRoutesEntry.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesEntry.setDescription('Table of Routing entries.')
ccRouterRoutesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRouterRoutesIndex.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesIndex.setDescription('Simple Index.')
ccRouterRoutesDest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRouterRoutesDest.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesDest.setDescription('IP address of the destination ')
ccRouterRoutesDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRouterRoutesDestMask.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesDestMask.setDescription('Mask used to specify the route ')
ccRouterRoutesGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRouterRoutesGateway.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesGateway.setDescription('Ip address of the gateway for this route ')
ccRouterRoutesInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 5), SinglePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRouterRoutesInterface.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesInterface.setDescription('Interface used for this route ')
ccRouterRoutesMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRouterRoutesMetric.setStatus('current')
if mibBuilder.loadTexts: ccRouterRoutesMetric.setDescription('Metric specified for this route.')
ccRouterUserRoutesTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3), )
if mibBuilder.loadTexts: ccRouterUserRoutesTable.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesTable.setDescription('Table of User defined Routes.')
ccRouterUserRoutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesIndex"))
if mibBuilder.loadTexts: ccRouterUserRoutesEntry.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesEntry.setDescription('User defined routes ')
ccRouterUserRoutesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRouterUserRoutesIndex.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesIndex.setDescription('Simple Index.')
ccRouterUserRoutesDest = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesDest.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesDest.setDescription('IP address of the destination')
ccRouterUserRoutesDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesDestMask.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesDestMask.setDescription('Mask used to specify the route')
ccRouterUserRoutesGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesGateway.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesGateway.setDescription('Ip address of the gateway for this route')
ccRouterUserRoutesInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("wan", 1), ("subnet1", 2), ("subnet2", 3), ("subnet3", 4), ("subnet4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesInterface.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesInterface.setDescription('Interface used for this route')
ccRouterUserRoutesMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesMetric.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesMetric.setDescription('Metric specified for this route.')
ccRouterUserRoutesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 6, 3, 1, 7), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRouterUserRoutesRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccRouterUserRoutesRowStatus.setDescription('Status of this row. ')
ccRap = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7))
ccRapControl = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1))
ccRapControlPollSymbolMus = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 3))
ccRapPollSymbolMusEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 3, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPollSymbolMusEnable.setStatus('current')
if mibBuilder.loadTexts: ccRapPollSymbolMusEnable.setDescription('Enable/disable polling MUs for their lists of known APs. The state of this variable persists across reboots. The factory-default state is disabled.')
ccRapPollSymbolMusInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 3, 2), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPollSymbolMusInterval.setStatus('current')
if mibBuilder.loadTexts: ccRapPollSymbolMusInterval.setDescription('Amount of time to wait before polling the same MU for its known AP list again. Assuming the MU is disrupted for 3sec when it is polled, a value of 5min or more would interrupt MUs less than 1% of the time. The state of this variable persists across reboots. The factory-default state is 10 (minutes).')
ccRapControlOnChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 4))
ccRapOnChannelEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapOnChannelEnable.setStatus('current')
if mibBuilder.loadTexts: ccRapOnChannelEnable.setDescription('Enable/disable polling MUs for their lists of known APs. The state of this variable persists across reboots. The factory-default state is disabled.')
ccRapOnChannelInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 4, 2), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapOnChannelInterval.setStatus('current')
if mibBuilder.loadTexts: ccRapOnChannelInterval.setDescription('Amount of time to wait before polling the same MU for its known AP list again. Assuming the MU is disrupted for 3sec when it is polled, a value of 5min or more would interrupt MUs less than 1% of the time. The state of this variable persists across reboots. The factory-default state is 10 (minutes).')
ccRapControlDetectors = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 5))
ccRapDetectorsEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 5, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapDetectorsEnable.setStatus('current')
if mibBuilder.loadTexts: ccRapDetectorsEnable.setDescription("Enable/disable the entire 'detector' sub-system. On the true-to-false transition, any portals previously claimed as listeners will be released and reset. Once reset, they will appear to the switch as if just newly installed, (and thus may or may not be adopted depending on settings in the switch). The state of this variable persists across reboots. The factory-default state is disabled.")
ccRapDetectorsInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 1, 5, 2), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapDetectorsInterval.setStatus('current')
if mibBuilder.loadTexts: ccRapDetectorsInterval.setDescription('Amount of time to wait before polling the same MU for its known AP list again. Assuming the MU is disrupted for 3sec when it is polled, a value of 5min or more would interrupt MUs less than 1% of the time. The state of this variable persists across reboots. The factory-default state is 10 (minutes).')
ccRapAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2))
ccRapAuthList = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2))
ccRapAuthAllSymbolMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthAllSymbolMac.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthAllSymbolMac.setDescription('If TRUE, any newly-discovered AP that has a MAC address with a Symbol vendor prefix is authorized, regardless of the ESSID.')
ccRapAuthTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2), )
if mibBuilder.loadTexts: ccRapAuthTable.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthTable.setDescription("A list of 'authorized' APs. There is no need to include on this list any APs adopted by the switch. Typically, this list will contain APs that are located in neighboring stores/buildings that are known by some means to NOT be rogue. So this is the List of APs that are Authorized and upon heard shall automatically be added to the Approved List instead of labelling them as Rogue APs. Note that this table persists across reboots. ")
ccRapAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRapAuthIndex"))
if mibBuilder.loadTexts: ccRapAuthEntry.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthEntry.setDescription(' ')
ccRapAuthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRapAuthIndex.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthIndex.setDescription('Index.')
ccRapAuthMacFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthMacFilter.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthMacFilter.setDescription("MAC address of AP to consider 'authorized'. To specify the entire MAC address as a wildcard, (match any MAC address), use FF:FF:FF:FF:FF:FF. (While it had been considered, it is NOT possible to wildcard just the vendor portion of the MAC).")
ccRapAuthEssidFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthEssidFilter.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthEssidFilter.setDescription("ESSID of AP to consider 'authorized'. Set to 33 '*' characters for wildcard, (to match any ESSID). (ESSIDs must be 32ch or less).")
ccRapAuthRowExists = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthRowExists.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthRowExists.setDescription('A kludge to avoid RowStatus and save development time. Set this value to true when creating the row. Set this value to false to destroy the row. ??- better name.')
ccRapAuthErase = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 3), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthErase.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthErase.setDescription('Setting this value to TRUE erases all AuthTable entries.')
ccRapAuthCopyAllApproved = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 4), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthCopyAllApproved.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthCopyAllApproved.setDescription('Causes all ccRapResultsApprovedTable entries to be immediately copied to the ccRapAuthTable.')
ccRapAuthCopyAllRogue = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 2, 2, 5), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapAuthCopyAllRogue.setStatus('current')
if mibBuilder.loadTexts: ccRapAuthCopyAllRogue.setDescription('Causes all ccRapResultsRogueTable entries to be immediately copied to the ccRapAuthTable.')
ccRapResults = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3))
ccRapResultsApproved = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1))
ccRapResultsApprovedAgeOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 1), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsApprovedAgeOut.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedAgeOut.setDescription("If an entry in the _ResultsApproved table is not heard by any means for this number of minutes, is elligable to be removed from the table by the switch; (the switch, however, might not remove the entry until it gets around to it). A value of 0 indicates that entries will never be 'aged-out' of the table. The state of this variable persists across reboots. The factory-default state is 1 week, (10080 min).")
ccRapResultsApprovedTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2), )
if mibBuilder.loadTexts: ccRapResultsApprovedTable.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedTable.setDescription("Each AP MAC/ESSID combination heard by any enabled detection method will be reported in this table, if it has been determined to be 'approved' via one of the enabled methods controlled in ccAuth. Entries persist until that MAC/ESSID combination has not been heard for _AgeOut minutes.")
ccRapResultsApprovedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedIndex"))
if mibBuilder.loadTexts: ccRapResultsApprovedEntry.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedEntry.setDescription(' ')
ccRapResultsApprovedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRapResultsApprovedIndex.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedIndex.setDescription('Simple Index.')
ccRapResultsApprovedApMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedApMac.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedApMac.setDescription('MAC address of the heard AP.')
ccRapResultsApprovedEssid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedEssid.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedEssid.setDescription('ESSID of the heard AP.')
ccRapResultsApprovedCopyToAuthTable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 4), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsApprovedCopyToAuthTable.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedCopyToAuthTable.setDescription('When set to TRUE, this entry is copied to the RuleTable.')
ccRapResultsApprovedFirstHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedFirstHeard.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedFirstHeard.setDescription('Snapshot of sysUpTime the first time this AP MAC/ESSID combination was heard by any Symbol MU.')
ccRapResultsApprovedLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedLastHeard.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedLastHeard.setDescription('Snapshot of sysUpTime the most recent time this AP MAC/ESSID combination was heard by any Symbol MU.')
ccRapResultsApprovedPortalPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 7), MultiPointer255()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedPortalPtr.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedPortalPtr.setDescription("A mask of Portal table entries. Those Portal entries indicated by a '1' in this mask were at one time the servicing Portal for an MU that reported hearing this AP. For a rogue of limited range in the parking lot on the north side of a store, it would be expected that only the Portals located in the north end of the store would be indicated by this mask, thus giving a rough indication of general direction of the rogue.")
ccRapResultsApprovedHowFound = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("viaSymbolMuPolling", 1), ("viaOnChannelDetection", 2), ("viaDetector", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedHowFound.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedHowFound.setDescription("Describes the status of this AP. ??- I don't think we would report adoptedAp on the results table, so don't need this enum value.")
ccRapResultsApprovedHowAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("onAuthList", 1), ("viaRadius", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedHowAuth.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedHowAuth.setDescription('Describes how this AP was authorized, (or not). The order in which the various methods of authorizing APs is attempted is exactly the numerical order of the enums. ??- I deleted adoptedAp, since it seems to me that there is no good reason to report APs that this switch has adopted.')
ccRapResultsApprovedChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsApprovedChannel.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedChannel.setDescription('Describes on which channel this AP was found.')
ccRapResultsApprovedErase = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 3), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsApprovedErase.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsApprovedErase.setDescription('Setting this value to TRUE erases all Results entries. Any APs heard after that event will be treated as newly heard; (which means they will also generate notifications, if enabled). ??- need 2nd scalar.')
ccRapNewApprovedAp = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 1, 4)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedPortalPtr"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedHowFound"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedHowAuth"))
if mibBuilder.loadTexts: ccRapNewApprovedAp.setStatus('current')
if mibBuilder.loadTexts: ccRapNewApprovedAp.setDescription('A new AP has been heard that was in some manner authorized.')
ccRapResultsRogue = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2))
ccRapResultsRogueAgeOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 1), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsRogueAgeOut.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueAgeOut.setDescription("If an entry in the _ResultsRogue table is not heard by any means for this number of minutes, is elligable to be removed from the table by the switch; (the switch, however, might not remove the entry until it gets around to it). A value of 0 indicates that entries will never be 'aged-out' of the table. The state of this variable persists across reboots. The factory-default state is 1 week, (10080 min).")
ccRapResultsRogueTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2), )
if mibBuilder.loadTexts: ccRapResultsRogueTable.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueTable.setDescription("Each AP MAC/ESSID combination heard by any enabled detection method will be reported in this table, if it has NOT been determined to be 'approved' via one of the enabled methods controlled in ccAuth. Entries persist until that MAC/ESSID combination has not been heard for _AgeOut minutes.")
ccRapResultsRogueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueIndex"))
if mibBuilder.loadTexts: ccRapResultsRogueEntry.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueEntry.setDescription(' ')
ccRapResultsRogueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRapResultsRogueIndex.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueIndex.setDescription('Simple Index.')
ccRapResultsRogueApMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueApMac.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueApMac.setDescription('MAC address of the heard AP.')
ccRapResultsRogueEssid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueEssid.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueEssid.setDescription('ESSID of the heard AP.')
ccRapResultsRogueCopyToAuthTable = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 4), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsRogueCopyToAuthTable.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueCopyToAuthTable.setDescription('When set to TRUE, this entry is copied to the RuleTable.')
ccRapResultsRogueFirstHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueFirstHeard.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueFirstHeard.setDescription('Snapshot of sysUpTime the first time this AP MAC/ESSID combination was heard by any Symbol MU.')
ccRapResultsRogueLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueLastHeard.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueLastHeard.setDescription('Snapshot of sysUpTime the most recent time this AP MAC/ESSID combination was heard by any Symbol MU.')
ccRapResultsRoguePortalPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 7), MultiPointer255()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRoguePortalPtr.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRoguePortalPtr.setDescription("A mask of Portal table entries. Those Portal entries indicated by a '1' in this mask were at one time the servicing Portal for an MU that reported hearing this AP. For a rogue of limited range in the parking lot on the north side of a store, it would be expected that only the Portals located in the north end of the store would be indicated by this mask, thus giving a rough indication of general direction of the rogue.")
ccRapResultsRogueHowFound = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("viaSymbolMuPolling", 1), ("viaOnChannelDetection", 2), ("viaDetector", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueHowFound.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueHowFound.setDescription("Describes the status of this AP. ??- I don't think we would report adoptedAp on the results table, so don't need this enum value.")
ccRapResultsRogueClosestPortalPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 9), SinglePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueClosestPortalPtr.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueClosestPortalPtr.setDescription("A pointer to closest reporting Portal to the Rogue AP, (where 'closest' is defined as greatest RSSI value among all Portals reporting this AP).")
ccRapResultsRogueClosestPortalRssi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueClosestPortalRssi.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueClosestPortalRssi.setDescription('RSSI reported by the closest Portal.')
ccRapResultsRogueChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapResultsRogueChannel.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueChannel.setDescription('Describes on which channel this AP was found.')
ccRapResultsRogueErase = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 3), DoActionNow()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapResultsRogueErase.setStatus('current')
if mibBuilder.loadTexts: ccRapResultsRogueErase.setDescription('Setting this value to TRUE erases all Results entries. Any APs heard after that event will be treated as newly heard; (which means they will also generate notifications, if enabled). ??- need 2nd scalar.')
ccRapNewRogueAp = NotificationType((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 3, 2, 4)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccRapResultsRoguePortalPtr"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueHowFound"))
if mibBuilder.loadTexts: ccRapNewRogueAp.setStatus('current')
if mibBuilder.loadTexts: ccRapNewRogueAp.setDescription('A new AP has been heard that was NOT authorized.')
ccRapLocate = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4))
ccRapPortalResults = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1))
ccRapPortalResultsApMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 1), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPortalResultsApMac.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsApMac.setDescription('The MAC address of the AP to be reported. (No wildcarding of the AP MAC is allowed. If it were, several APs could be found that match the selection criteria).')
ccRapPortalResultsApEssid = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPortalResultsApEssid.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsApEssid.setDescription('The ESSID of the AP to be reported. (No wildcarding of the AP ESSID is allowed. If it were, several APs could be found that match the selection criteria).')
ccRapPortalResultsInProcess = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 3), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPortalResultsInProcess.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsInProcess.setDescription('Setting to true erases the _PortalResultsTable, and immediately initiates a scan of all Portals currently enabled in ccRapControlOnChannel and ccRapControlDetectors. The switch does NOT wait until the next scan interval(s), but performs the scan immediately; (a human is most likely waiting for the results in mere seconds). Once the switch has completed scanning all enabled Portals, it sets this value to false.')
ccRapPortalResultsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 4), )
if mibBuilder.loadTexts: ccRapPortalResultsTable.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsTable.setDescription("Each (enabled/configured) Portal that hears the specified AP's MAC/ESSID combination will be reported as one entry in this table. For a rogue of limited range in the parking lot on the north side of a store, it would be expected that only the Portals located in the north end of the store would be indicated by this mask, thus giving a rough indication of general direction of the rogue. Individual RSSI values combined with exact locations of the Portals can be used to triangulate the approximate position of the Rogue.")
ccRapPortalResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsIndex"))
if mibBuilder.loadTexts: ccRapPortalResultsEntry.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsEntry.setDescription(' ')
ccRapPortalResultsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRapPortalResultsIndex.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsIndex.setDescription('Simple Index.')
ccRapPortalResultsPortalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 4, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPortalResultsPortalMac.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsPortalMac.setDescription('MAC address of the Portal reporting having heard the specified AP.')
ccRapPortalResultsRssi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPortalResultsRssi.setStatus('current')
if mibBuilder.loadTexts: ccRapPortalResultsRssi.setDescription('RSSI value heard by the Portal.')
ccRapPollOneMu = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2))
ccRapPollOneMuMac = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 1), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPollOneMuMac.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuMac.setDescription("Writing this value with the MAC address of a MU causes the switch to read that MU's known AP list. This read is performed just once, (it is not repeated). This read occurs regardless of the state of ccRapPollSymbolMusEnable. The read is also performed immediately - the switch does NOT wait until the next Sybmol MU poll interval, (as specified in ccRapPollSymbolMusInterval).")
ccRapPollOneMuInProcess = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 2), DoActionShowProgress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRapPollOneMuInProcess.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuInProcess.setDescription("Setting to true initiates the polling of one specified MU's known AP table. Once the switch receives a response from the requested MU, it sets this value to false. If the network management software sets this value to false, any future response from the MU will be ignored.")
ccRapPollOneMuStatus = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSymbolRogueEnabled", 1), ("symbolRogueEnabled", 2), ("notAssociated", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPollOneMuStatus.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuStatus.setDescription('Describes if the MU is associated or not, and if so, if the MU is Symbol Rogue detect enabled or not.')
ccRapPollOneMuResultsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4), )
if mibBuilder.loadTexts: ccRapPollOneMuResultsTable.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsTable.setDescription("Shows the known AP table as read from the specified MU. This table is NOT cumulative; that is, it only reflects exactly what was read from the most recent read of the specified MU's known AP table. If a non-Symbol MUs is specified, or if the MU is not currently associated with any Portal, the resulting table will be empty.")
ccRapPollOneMuResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuResultsIndex"))
if mibBuilder.loadTexts: ccRapPollOneMuResultsEntry.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsEntry.setDescription(' ')
ccRapPollOneMuResultsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRapPollOneMuResultsIndex.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsIndex.setDescription('Simple index into the table.')
ccRapPollOneMuResultsRssi = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPollOneMuResultsRssi.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsRssi.setDescription('RSSI reported for that known AP.')
ccRapPollOneMuResultsEssid = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPollOneMuResultsEssid.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsEssid.setDescription('ESSID of the heard AP.')
ccRapPollOneMuResultsApMac = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 7, 4, 2, 4, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRapPollOneMuResultsApMac.setStatus('current')
if mibBuilder.loadTexts: ccRapPollOneMuResultsApMac.setDescription('MAC address of the heard AP.')
ccRadiusServer = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8))
ccRadius = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1))
ccRadiusDataSource = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("ldap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusDataSource.setStatus('current')
if mibBuilder.loadTexts: ccRadiusDataSource.setDescription('Source of data for authentication. It can be local database on the switch or LDAP database i.e ADS or openLDAP')
ccRadiusDefaultEapType = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ttls", 1), ("peap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusDefaultEapType.setStatus('current')
if mibBuilder.loadTexts: ccRadiusDefaultEapType.setDescription('Deafult EAP type advertised by the radius server. ')
ccRadiusAuthTypePeap = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gtc", 1), ("msChap2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusAuthTypePeap.setStatus('current')
if mibBuilder.loadTexts: ccRadiusAuthTypePeap.setDescription('Type of EAP type within PEAP ')
ccRadiusAuthTypeTtls = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("md5", 1), ("pap", 2), ("msChap2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusAuthTypeTtls.setStatus('current')
if mibBuilder.loadTexts: ccRadiusAuthTypeTtls.setDescription('Type of EAP type within TTLS')
ccRadiusServerCertificate = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusServerCertificate.setStatus('current')
if mibBuilder.loadTexts: ccRadiusServerCertificate.setDescription('Id of the ceritificate used by RADIUS ')
ccRadiusCACertificate = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusCACertificate.setStatus('current')
if mibBuilder.loadTexts: ccRadiusCACertificate.setDescription('ID of the CA certificate used by RADIUS')
ccRadiusClientAuthTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8), )
if mibBuilder.loadTexts: ccRadiusClientAuthTable.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthTable.setDescription('Table of Radius Client Entries.')
ccRadiusClientAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthIndex"))
if mibBuilder.loadTexts: ccRadiusClientAuthEntry.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthEntry.setDescription('Description.')
ccRadiusClientAuthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRadiusClientAuthIndex.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthIndex.setDescription('Simple Index.')
ccRadiusClientAuthIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusClientAuthIpAddr.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthIpAddr.setDescription('IP address of the client ')
ccRadiusClientAuthMask = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusClientAuthMask.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthMask.setDescription("Mask of the client's IP address ")
ccRadiusClientAuthSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1, 4), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusClientAuthSharedSecret.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthSharedSecret.setDescription('Shared secret between the client and the radius server ')
ccRadiusClientAuthRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 1, 8, 1, 5), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusClientAuthRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccRadiusClientAuthRowStatus.setDescription('Row Status. ')
ccRadiusProxy = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2))
ccRadiusProxyRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyRetryCount.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyRetryCount.setDescription('Number of retries for sending messages to a proxy ')
ccRadiusProxyTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyTimeout.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyTimeout.setDescription('TImeout in seconds before retrying to a proxy ')
ccRadiusProxyServerTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3), )
if mibBuilder.loadTexts: ccRadiusProxyServerTable.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerTable.setDescription('Table of Proxy Realm Entries.')
ccRadiusProxyServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerIndex"))
if mibBuilder.loadTexts: ccRadiusProxyServerEntry.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerEntry.setDescription('Description.')
ccRadiusProxyServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ccRadiusProxyServerIndex.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerIndex.setDescription('Simple Index.')
ccRadiusProxyServerPrefixOrSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyServerPrefixOrSuffix.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerPrefixOrSuffix.setDescription('Prefix of suffix used for proxying radius request to a proxy server ')
ccRadiusProxyServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyServerIp.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerIp.setDescription('IP address of the proxy server ')
ccRadiusProxyServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyServerPort.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerPort.setDescription('Port of proxy server ')
ccRadiusProxyServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 5), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyServerSharedSecret.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerSharedSecret.setDescription('Shared secret between radius server and proxy server ')
ccRadiusProxyServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 2, 3, 1, 6), AbbrevRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusProxyServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccRadiusProxyServerRowStatus.setDescription('Row Status. ')
ccRadiusLdap = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3))
ccRadiusLdapServerIp = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapServerIp.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapServerIp.setDescription('IP address of the LDAP server ')
ccRadiusLdapServerPort = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapServerPort.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapServerPort.setDescription('Port of the LDAP server ')
ccRadiusLdapLoginAttribute = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapLoginAttribute.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapLoginAttribute.setDescription('Name of the login attribute used by LDAP for authenticating the user. ')
ccRadiusLdapPasswordAttribute = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapPasswordAttribute.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapPasswordAttribute.setDescription('Name of the login attribute used by LDAP for authenticating the user. ')
ccRadiusLdapBindDistinguishedName = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapBindDistinguishedName.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapBindDistinguishedName.setDescription('Bind DN used the LDAP client on the WS2000 to connect to a LDAP server ')
ccRadiusLdapBindDistinguishedPassword = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 6), Password()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapBindDistinguishedPassword.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapBindDistinguishedPassword.setDescription('Bind password used the LDAP client on the WS2000 to connect to a LDAP server')
ccRadiusLdapBaseDistinguishedName = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapBaseDistinguishedName.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapBaseDistinguishedName.setDescription('Base DN used the LDAP client on the WS2000 to connect to a LDAP server.')
ccRadiusLdapGroupAttribute = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapGroupAttribute.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapGroupAttribute.setDescription('Name of the group attribute used by LDAP for retrieving the group associated with a user ')
ccRadiusLdapGroupFilter = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapGroupFilter.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapGroupFilter.setDescription('Filter specification used by the LDAP client to retrieve the groups associated with a user ')
ccRadiusLdapGroupMembershipAttribute = MibScalar((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 3, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusLdapGroupMembershipAttribute.setStatus('current')
if mibBuilder.loadTexts: ccRadiusLdapGroupMembershipAttribute.setDescription('Name of the attribute in the user schema which specifies groups associated with the user. This is used if the group filter specified by ccRadiusGroupFilter return an error. ')
ccRadiusUsers = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4))
ccRadiusUsersGroupTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 1), )
if mibBuilder.loadTexts: ccRadiusUsersGroupTable.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusUsersGroupTable.setDescription('Table of Group entries.')
ccRadiusUsersGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroup"))
if mibBuilder.loadTexts: ccRadiusUsersGroupEntry.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusUsersGroupEntry.setDescription('Description.')
ccRadiusUsersGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusUsersGroup.setDescription('Name of the group ')
ccRadiusUsersGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 1, 1, 2), AbbrevRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersGroupRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusUsersGroupRowStatus.setDescription('Row status ')
ccRadiusUsersGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccRadiusUsersGroupId.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusUsersGroupId.setDescription('Actual index of that Group in the Configuration. Added to solve a problem encountered by SEMM for resolving the Multipointer ccRadiusUsersGroups.')
ccRadiusUsersTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2), )
if mibBuilder.loadTexts: ccRadiusUsersTable.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersTable.setDescription('Table of User entries.')
ccRadiusUsersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRadiusUsersId"))
if mibBuilder.loadTexts: ccRadiusUsersEntry.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersEntry.setDescription('Description.')
ccRadiusUsersId = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersId.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersId.setDescription('User name.')
ccRadiusUsersPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2, 1, 2), Password().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersPassword.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersPassword.setDescription('Password.')
ccRadiusUsersGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2, 1, 3), Bits().clone(namedValues=NamedValues(("null", 0), ("group1", 1), ("group2", 2), ("group3", 3), ("group4", 4), ("group5", 5), ("group6", 6), ("group7", 7), ("group8", 8), ("group9", 9), ("group10", 10)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersGroups.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersGroups.setDescription('List of groups associated with the user. Note that if a group is deleted, the corresponding bit pointing to that group will be cleared in this variable for all users that previously had it set.')
ccRadiusUsersRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 4, 2, 1, 4), AbbrevRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccRadiusUsersRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccRadiusUsersRowStatus.setDescription('Row Status.')
ccRadiusAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 5))
ccRadiusAccessTable = MibTable((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 5, 1), )
if mibBuilder.loadTexts: ccRadiusAccessTable.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusAccessTable.setDescription('Table of Access Policy entries.')
ccRadiusAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 5, 1, 1), ).setIndexNames((0, "SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroup"))
if mibBuilder.loadTexts: ccRadiusAccessEntry.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusAccessEntry.setDescription('Acess table entry specifying the the WLANs allowed for each group ')
ccRadiusAccessWlanPtrs = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 11, 2, 8, 5, 1, 1, 2), Bits().clone(namedValues=NamedValues(("null", 0), ("wlan1", 1), ("wlan2", 2), ("wlan3", 3), ("wlan4", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccRadiusAccessWlanPtrs.setStatus('obsolete')
if mibBuilder.loadTexts: ccRadiusAccessWlanPtrs.setDescription('Points to the zero or more WLANs for which the given GroupId is allowed access. ')
ccGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000))
ccGroupsV1dot0 = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1))
ccAdminGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 1)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccInfoSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccResetFactory"), ("SYMBOL-CC-WS2000-MIB", "ccResetSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwInterface"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperationsDone"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeCount"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeTime"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistSemaphore"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpLastDeniedIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccSysDNSRelayMode"), ("SYMBOL-CC-WS2000-MIB", "ccApSslv2Mode"), ("SYMBOL-CC-WS2000-MIB", "ccApSshv1Mode"), ("SYMBOL-CC-WS2000-MIB", "ccApSslWeakCipherSupport"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolations"), ("SYMBOL-CC-WS2000-MIB", "ccLoadServerIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFtpUsername"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccAdminGroup = ccAdminGroup.setStatus('current')
if mibBuilder.loadTexts: ccAdminGroup.setDescription(' ')
ccNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 2)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalUnAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalDenied"), ("SYMBOL-CC-WS2000-MIB", "ccMuAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuUnAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuDenied"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolation"), ("SYMBOL-CC-WS2000-MIB", "ccConfigChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccNotificationsGroup = ccNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ccNotificationsGroup.setDescription(' ')
ccApGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 3)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccApIndex"), ("SYMBOL-CC-WS2000-MIB", "ccApNicMac"), ("SYMBOL-CC-WS2000-MIB", "ccApModelNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApPcbRevision"), ("SYMBOL-CC-WS2000-MIB", "ccApBootLoaderRev"), ("SYMBOL-CC-WS2000-MIB", "ccApWispVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApRuntimeFwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApNumPortals"), ("SYMBOL-CC-WS2000-MIB", "ccApPointersToPortals"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccApGroup = ccApGroup.setStatus('current')
if mibBuilder.loadTexts: ccApGroup.setDescription(' ')
ccPortalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 4)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointerToAp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointersToWlans"), ("SYMBOL-CC-WS2000-MIB", "ccPortalOptions"), ("SYMBOL-CC-WS2000-MIB", "ccPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfEss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfBss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAssociatedMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccPortalName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLocation"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastAdoption"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRadioType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccPortalGroup = ccPortalGroup.setStatus('current')
if mibBuilder.loadTexts: ccPortalGroup.setDescription(' ')
ccAssociationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 5)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccAssociationFirstAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationLastAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationCountAssociates"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccAssociationGroup = ccAssociationGroup.setStatus('current')
if mibBuilder.loadTexts: ccAssociationGroup.setDescription(' ')
ccMuGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 1, 6)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccMuMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuSymbolRogueApEna"), ("SYMBOL-CC-WS2000-MIB", "ccMuIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccMuType"), ("SYMBOL-CC-WS2000-MIB", "ccMuRadioType"), ("SYMBOL-CC-WS2000-MIB", "ccMuSupportedRates"), ("SYMBOL-CC-WS2000-MIB", "ccMuPowerMode"), ("SYMBOL-CC-WS2000-MIB", "ccMuAuthenticationMethod"), ("SYMBOL-CC-WS2000-MIB", "ccMuEncryptionMethod"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries01"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries02"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries03"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries04"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries05"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries06"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries07"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries08"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries09"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries10"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries11"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries12"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries13"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries14"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries15"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesNone"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesFailed"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesTotal"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccMuIsDataReady"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccMuGroup = ccMuGroup.setStatus('current')
if mibBuilder.loadTexts: ccMuGroup.setDescription(' ')
ccGroupsV1dot5 = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 2))
ccGroupsV1dot5variables = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 2, 1))
for _ccGroupsV1dot5variables_obj in [[("SYMBOL-CC-WS2000-MIB", "ccInfoSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccInfoCountrySelection"), ("SYMBOL-CC-WS2000-MIB", "ccIdHwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdFwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdSwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdMibVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdCliVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdXmlVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccResetFactory"), ("SYMBOL-CC-WS2000-MIB", "ccResetSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccResetFactoryExceptIpSnmp"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwInterface"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperationsDone"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeCount"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeTime"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistSemaphore"), ("SYMBOL-CC-WS2000-MIB", "ccLoadServerIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFtpUsername"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFtpPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolations"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpLastDeniedIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccCompactFlashCapacity"), ("SYMBOL-CC-WS2000-MIB", "ccCompactFlashUsed"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsShortWindow"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsShortUpdateInterval"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsLongWindow"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsLongUpdateInterval"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlCfAlmostFullThreshold"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlFirewallUnderAttackDescription"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlFirewallUnderAttackRateLimit"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedChannel"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsDescr"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetMu"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdMu"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetPortal"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdPortals"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetWlan"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdWlans"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsMinPktsForTrap"), ("SYMBOL-CC-WS2000-MIB", "ccApIndex"), ("SYMBOL-CC-WS2000-MIB", "ccApNicMac"), ("SYMBOL-CC-WS2000-MIB", "ccApModelNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApPcbRevision"), ("SYMBOL-CC-WS2000-MIB", "ccApBootLoaderRev"), ("SYMBOL-CC-WS2000-MIB", "ccApWispVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApRuntimeFwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApNumPortals"), ("SYMBOL-CC-WS2000-MIB", "ccApPointersToPortals"), ("SYMBOL-CC-WS2000-MIB", "ccPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointerToAp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointersToWlans"), ("SYMBOL-CC-WS2000-MIB", "ccPortalName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLocation"), ("SYMBOL-CC-WS2000-MIB", "ccPortalOptions"), ("SYMBOL-CC-WS2000-MIB", "ccPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfEss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfBss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAssociatedMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRadioType"), ("SYMBOL-CC-WS2000-MIB", "ccPortalChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastAdoption"), ("SYMBOL-CC-WS2000-MIB", "ccPortalState"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsBeaconsTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsBeaconsTxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeReqRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeReqRxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetriesNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries1"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries2"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetriesFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespTxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPktsNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts01"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts02"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts03"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts04"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts05"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts06"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts07"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts08"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts09"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts10"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts11"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts12"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts13"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts14"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts15"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPktsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets04"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kRfUtil"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kRfUtil"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationFirstAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationLastAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationCountAssociates"), ("SYMBOL-CC-WS2000-MIB", "ccMuMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccMuIsDataReady"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuSymbolRogueApEna"), ("SYMBOL-CC-WS2000-MIB", "ccMuIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccMuType"), ("SYMBOL-CC-WS2000-MIB", "ccMuRadioType"), ("SYMBOL-CC-WS2000-MIB", "ccMuSupportedRates"), ("SYMBOL-CC-WS2000-MIB", "ccMuPowerMode"), ("SYMBOL-CC-WS2000-MIB", "ccMuAuthenticationMethod")], [("SYMBOL-CC-WS2000-MIB", "ccMuEncryptionMethod"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesNone"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries01"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries02"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries03"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries04"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries05"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries06"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries07"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries08"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries09"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries10"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries11"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries12"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries13"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries14"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries15"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesFailed"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesTotal"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets04"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEssid"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSubnet"), ("SYMBOL-CC-WS2000-MIB", "ccWlanPortalsAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWlanDisallowMuToMu"), ("SYMBOL-CC-WS2000-MIB", "ccWlanVoicePrioritization"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAnswerBroadcastEss"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMulticastAddr1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMulticastAddr2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclDefault"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthentication"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEncryption"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1Server"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1Port"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1SharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2Server"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2Port"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2SharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuQuietPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuTxPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapServerTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapServerMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosRealmName"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosUsername"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosPassword"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIp1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPort1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIp2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPort2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIpR"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPortR"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepPassKey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey3"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey4"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaBcastKeyRotation"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKeyRotationInterval"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaPassphrase"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardPasskey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey3"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey4"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt5pt5Mb")], [("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPktsNone"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts01"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts02"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts03"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts04"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts05"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts06"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts07"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts08"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts09"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts10"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts11"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts12"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts13"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts14"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts15"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPktsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets04"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccWanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpDefaultGateway"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpPrimaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpSecondaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccWanDefaultGateway"), ("SYMBOL-CC-WS2000-MIB", "ccWanPrimaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanSecondaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeUsername"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoePassword"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeKeepAlive"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeIdleTime"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeAuthType"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddrIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddrEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallGlobalEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallDescription"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallAlwaysEnabled"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallMimeFloodMaxHeaderLength"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallMimeFloodMaxHeaders"), ("SYMBOL-CC-WS2000-MIB", "ccPortIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortType"), ("SYMBOL-CC-WS2000-MIB", "ccPortPoeEquipped"), ("SYMBOL-CC-WS2000-MIB", "ccPortStatus"), ("SYMBOL-CC-WS2000-MIB", "ccPortDuplex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseNumSamples"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kDropped"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kDropped"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries3OrMore"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kTxMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccPortSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccResetStatCounters")]]:
    if getattr(mibBuilder, 'version', 0) < (4, 4, 2):
        # WARNING: leading objects get lost here!
        ccGroupsV1dot5variables = ccGroupsV1dot5variables.setObjects(*_ccGroupsV1dot5variables_obj)
    else:
        ccGroupsV1dot5variables = ccGroupsV1dot5variables.setObjects(*_ccGroupsV1dot5variables_obj, **dict(append=True))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV1dot5variables = ccGroupsV1dot5variables.setStatus('current')
if mibBuilder.loadTexts: ccGroupsV1dot5variables.setDescription('variables implemented in v1.5')
ccGroupsV1dot5obsoleted = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 2, 2)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccLoadFtpPassword"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccResetMuCounters"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV1dot5obsoleted = ccGroupsV1dot5obsoleted.setStatus('obsolete')
if mibBuilder.loadTexts: ccGroupsV1dot5obsoleted.setDescription('variables obsoleted in v1.5')
ccGroupsV1dot5notifications = NotificationGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 2, 3)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortStatusChange"), ("SYMBOL-CC-WS2000-MIB", "ccCfAlmostFull"), ("SYMBOL-CC-WS2000-MIB", "ccFirewallUnderAttack"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsMu"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsPortal"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsWlan"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccRadarDetected"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalUnAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalDenied"), ("SYMBOL-CC-WS2000-MIB", "ccMuAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuUnAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuDenied"), ("SYMBOL-CC-WS2000-MIB", "ccConfigChange"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV1dot5notifications = ccGroupsV1dot5notifications.setStatus('current')
if mibBuilder.loadTexts: ccGroupsV1dot5notifications.setDescription('notifications implemented in v1.5')
ccGroupsV2dot0 = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 3))
ccGroupsV2dot0variables = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 3, 1))
for _ccGroupsV2dot0variables_obj in [[("SYMBOL-CC-WS2000-MIB", "ccInfoSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccInfoCountrySelection"), ("SYMBOL-CC-WS2000-MIB", "ccIdHwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdFwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdSwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdMibVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdCliVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdXmlVersion"), ("SYMBOL-CC-WS2000-MIB", "ccIdSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccResetFactory"), ("SYMBOL-CC-WS2000-MIB", "ccResetSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccResetFactoryExceptIpSnmp"), ("SYMBOL-CC-WS2000-MIB", "ccResetStatCounters"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwInterface"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFwSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperation"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerPath"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgServerFilename"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgStart"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgOperationsDone"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgResult"), ("SYMBOL-CC-WS2000-MIB", "ccLoadCfgSuccess"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeCount"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistChangeTime"), ("SYMBOL-CC-WS2000-MIB", "ccCfgHistSemaphore"), ("SYMBOL-CC-WS2000-MIB", "ccLoadServerIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFtpUsername"), ("SYMBOL-CC-WS2000-MIB", "ccLoadFtpPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolations"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpLastDeniedIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12Index"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12Community"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12CustomOid"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12OidLimit"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12Access"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV12Enable"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3Index"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3SecurityLevel"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3CustomOid"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3OidLimit"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3Access"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3AuthAlgorithm"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3AuthPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3PrivacyAlgorithm"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3PrivacyPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3Enable"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessControlIndex"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessControlStartIp"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessControlEndIp"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessControlEnable"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Index"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12DestinationIp"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Port"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Community"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Version"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV12Enable"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3Index"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3DestinationIp"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3Port"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3Username"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3SecurityLevel"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3AuthAlgorithm"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3AuthPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3PrivacyAlgorithm"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3PrivacyPassword"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpTrapSinkV3Enable"), ("SYMBOL-CC-WS2000-MIB", "ccCompactFlashCapacity"), ("SYMBOL-CC-WS2000-MIB", "ccCompactFlashUsed"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsShortWindow"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsShortUpdateInterval"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsLongWindow"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsLongUpdateInterval"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessToAllow"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAirbeamAllow"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAirbeamPassword"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAdminAuth"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAdminPassword"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAdminAuthRadiusServerIp"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAdminAuthRadiusServerPort"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessAdminAuthRadiusSharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessSshAuthTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessSshInactivityTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccLoggingLevel"), ("SYMBOL-CC-WS2000-MIB", "ccLoggingToSyslog"), ("SYMBOL-CC-WS2000-MIB", "ccLoggingSyslogServer"), ("SYMBOL-CC-WS2000-MIB", "ccNtpEnable"), ("SYMBOL-CC-WS2000-MIB", "ccNtp0Server"), ("SYMBOL-CC-WS2000-MIB", "ccNtp0Port"), ("SYMBOL-CC-WS2000-MIB", "ccNtp1Server"), ("SYMBOL-CC-WS2000-MIB", "ccNtp1Port"), ("SYMBOL-CC-WS2000-MIB", "ccNtp2Server"), ("SYMBOL-CC-WS2000-MIB", "ccNtp2Port"), ("SYMBOL-CC-WS2000-MIB", "ccNtpGmtHourOffset"), ("SYMBOL-CC-WS2000-MIB", "ccNtpGmtMinuteOffset"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsUpdateFwEna"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsUpdateCfgEna"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsUpdateInterface"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsUpdateFwFilename"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsUpdateCfgFilename"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyAdminState"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyOperState"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyHeartbeatInterval"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyRevertDelay"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlCfAlmostFullThreshold"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlFirewallUnderAttackDescription"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlFirewallUnderAttackRateLimit"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRadarDetectedChannel"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsDescr"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsUnits"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetMu"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdMu"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetPortal"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdPortals"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetWlan"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdWlans"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsCanBeSetSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsThresholdSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlSumStatsMinPktsForTrap"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlLanVlanActivatedVlanId"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlDhcpOptionsFileTransferStatusRequested"), ("SYMBOL-CC-WS2000-MIB", "ccApIndex"), ("SYMBOL-CC-WS2000-MIB", "ccApNicMac"), ("SYMBOL-CC-WS2000-MIB", "ccApModelNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccApPcbRevision"), ("SYMBOL-CC-WS2000-MIB", "ccApBootLoaderRev"), ("SYMBOL-CC-WS2000-MIB", "ccApWispVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApRuntimeFwVersion"), ("SYMBOL-CC-WS2000-MIB", "ccApNumPortals"), ("SYMBOL-CC-WS2000-MIB", "ccApPointersToPortals"), ("SYMBOL-CC-WS2000-MIB", "ccPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointerToAp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalPointersToWlans"), ("SYMBOL-CC-WS2000-MIB", "ccPortalName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLocation"), ("SYMBOL-CC-WS2000-MIB", "ccPortalOptions"), ("SYMBOL-CC-WS2000-MIB", "ccPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfEss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalNumberOfBss"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAssociatedMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRadioType"), ("SYMBOL-CC-WS2000-MIB", "ccPortalChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastAdoption"), ("SYMBOL-CC-WS2000-MIB", "ccPortalState"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseNumSamples"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalBackgroundNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionStartMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionEndMac"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionWlanPointers"), ("SYMBOL-CC-WS2000-MIB", "ccPortalAdoptionRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsBeaconsTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsBeaconsTxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeReqRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeReqRxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetriesNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries1"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries2"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetriesFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespTxOctets"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPktsNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts01"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts02"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts03"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts04"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts05"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts06"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts07"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts08"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts09"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts10"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts11"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts12"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts13"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts14"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPkts15"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesPktsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets04")], [("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccPortalTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSignalMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsNoiseMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSigStatsSnrMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsShortPp10kRfUtil"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kRfUtil"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationFirstAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationLastAssociate"), ("SYMBOL-CC-WS2000-MIB", "ccAssociationCountAssociates"), ("SYMBOL-CC-WS2000-MIB", "ccMuMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccMuIsDataReady"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalIndex"), ("SYMBOL-CC-WS2000-MIB", "ccMuPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuSymbolRogueApEna"), ("SYMBOL-CC-WS2000-MIB", "ccMuIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccMuType"), ("SYMBOL-CC-WS2000-MIB", "ccMuRadioType"), ("SYMBOL-CC-WS2000-MIB", "ccMuSupportedRates"), ("SYMBOL-CC-WS2000-MIB", "ccMuPowerMode"), ("SYMBOL-CC-WS2000-MIB", "ccMuAuthenticationMethod"), ("SYMBOL-CC-WS2000-MIB", "ccMuEncryptionMethod"), ("SYMBOL-CC-WS2000-MIB", "ccMuVlanId"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxRssiMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesNone"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries01"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries02"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries03"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries04"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries05"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries06"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries07"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries08"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries09"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries10"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries11"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries12"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries13"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries14"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetries15"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesFailed"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesTotal"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastMac"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastReason"), ("SYMBOL-CC-WS2000-MIB", "ccMuLastPortal"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets04"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccMuTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSignalMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsNoiseMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccMuSigStatsSnrMostRecent"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccMuSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWlanName"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEssid"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSubnet"), ("SYMBOL-CC-WS2000-MIB", "ccWlanPortalsAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWlanDisallowMuToMu"), ("SYMBOL-CC-WS2000-MIB", "ccWlanVoicePrioritization"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAnswerBroadcastEss"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMulticastAddr1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMulticastAddr2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclDefault"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthentication"), ("SYMBOL-CC-WS2000-MIB", "ccWlanEncryption"), ("SYMBOL-CC-WS2000-MIB", "ccWlanWeight"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapReauthenticationMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1Server"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1Port"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius1SharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2Server"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2Port"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadius2SharedSecret")], [("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuQuietPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuTxPeriod"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapMuMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapServerTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapServerMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosRealmName"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosUsername"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosPassword"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIp1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPort1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIp2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPort2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcServerIpR"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthKerberosKdcPortR"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepPassKey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey3"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKey4"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWepKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaBcastKeyRotation"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKeyRotationInterval"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaPassphrase"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaKey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardPasskey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey2"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey3"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKey4"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoKeyguardKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclStartingMac"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclEndingMac"), ("SYMBOL-CC-WS2000-MIB", "ccWlanMuAclRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWlanBwShareMode"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsNUcast"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxUndecryptablePkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanLastActivity"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxPktsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanRxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt1Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt2Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt5pt5Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt6Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt9Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt11Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt12Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt18Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt22Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt24Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt36Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt48Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxOctetsAt54Mb"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPktsNone"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts01"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts02"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts03"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts04"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts05"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts06"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts07"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts08"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts09"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts10"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts11"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts12"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts13"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts14"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPkts15"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesPktsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctetsNone"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets01"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets02"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets03"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets04"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets05"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets06"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets07"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets08"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets09"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets10"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets11"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets12"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets13"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets14"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctets15"), ("SYMBOL-CC-WS2000-MIB", "ccWlanTxRetriesOctetsFailed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSignalSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsNoiseSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrBest"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrWorst"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrSum"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSigStatsSnrSumSquares"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTimestamp"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongNumPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSec100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSecTx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPktsPerSecRx100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughput"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughputTx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongThroughputRx"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgBitSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuSignal"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuNoise"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongAvgMuSnr"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kNUcastPkts"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kTxWithRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTxAvgRetries100"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kRxUndecrypt"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongTotalMus"), ("SYMBOL-CC-WS2000-MIB", "ccWanIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpDefaultGateway"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpPrimaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanDhcpSecondaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccWanDefaultGateway"), ("SYMBOL-CC-WS2000-MIB", "ccWanPrimaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanSecondaryDnsServer"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeUsername"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoePassword"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeKeepAlive"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeIdleTime"), ("SYMBOL-CC-WS2000-MIB", "ccWanPppoeAuthType"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddrIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddrEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallGlobalEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallDescription"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallAlwaysEnabled"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallMimeFloodMaxHeaderLength"), ("SYMBOL-CC-WS2000-MIB", "ccWanFirewallMimeFloodMaxHeaders"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatWanIpAddress"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatType"), ("SYMBOL-CC-WS2000-MIB", "ccWanNat1to1IpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundDefaultEna"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundDefaultIp"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundName"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundTransport"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundStartPort"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundEndPort"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatOutboundSubnetIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatOutboundPossibleIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatOutboundIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnName"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnLocalSubnet"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnLocalWanIp"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnRemoteSubnet"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnRemoteSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnRemoteGateway"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyExchange"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualAhAuth"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualInAhAuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualOutAhAuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualInAhSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualOutAhSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualEspType"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualEspEncrypAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualInEspEncrypKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualOutEspEncrypKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualEspAuthAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualInEspAuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualOutEspAuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualInEspSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyManualOutEspSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoUsePerfectSecrecy"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoAhAuth"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoEspType"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoEspEncrypAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoEspAuthAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeOperationMode"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeLocalIdType"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeLocalIdData"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeRemoteIdType"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeRemoteIdData"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeAuthAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeAuthPassphrase")], [("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeEncrypAlg"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeXauthMode"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeXauthUsername"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeXauthPassword"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeKeyLifetime"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeDiffieHelmanGroup"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaTunnelName"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaInSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaOutSpi"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaLifetime"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaTxBytes"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnSaRxBytes"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnIkeTunnelName"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnIkeState"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnIkeRemainingLife"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockSmtp"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockFtp"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockHttp"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockOutUrlIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockOutUrlExtension"), ("SYMBOL-CC-WS2000-MIB", "ccWanContentBlockOutUrlRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccPortIndex"), ("SYMBOL-CC-WS2000-MIB", "ccPortType"), ("SYMBOL-CC-WS2000-MIB", "ccPortPoeEquipped"), ("SYMBOL-CC-WS2000-MIB", "ccPortStatus"), ("SYMBOL-CC-WS2000-MIB", "ccPortDuplex"), ("SYMBOL-CC-WS2000-MIB", "ccPortSpeed"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetIndex"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetEnable"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetName"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetIpAddress"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetIpSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetPortMembers"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetWlanMembers"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpState"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpIpAddress"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpSubnetMask"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerEnable"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerPoolStart"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerPoolEnd"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerPrimaryDns"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerSecondaryDns"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerDefaultGateway"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerLeaseTime"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerStaticMapMac"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerStaticMapIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerStaticMapEnable"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessDestIndex"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleIndex"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessDestType"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessDestPtrToDest"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleName"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleType"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInIndex"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanType"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanTrunkPort"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanDefaultTag"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanTrunked"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanId"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRipType"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRipDirection"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2AuthType"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2SimplePassword"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2Md5Key1Id"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2Md5Key1AuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2Md5Key2Id"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRip2Md5Key2AuthKey"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesDest"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesDestMask"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesGateway"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesInterface"), ("SYMBOL-CC-WS2000-MIB", "ccRouterRoutesMetric"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesDest"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesDestMask"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesGateway"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesInterface"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesMetric"), ("SYMBOL-CC-WS2000-MIB", "ccRouterUserRoutesRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollSymbolMusEnable"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollSymbolMusInterval"), ("SYMBOL-CC-WS2000-MIB", "ccRapOnChannelEnable"), ("SYMBOL-CC-WS2000-MIB", "ccRapOnChannelInterval"), ("SYMBOL-CC-WS2000-MIB", "ccRapDetectorsEnable"), ("SYMBOL-CC-WS2000-MIB", "ccRapDetectorsInterval"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthAllSymbolMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthMacFilter"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthEssidFilter"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthRowExists"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthErase"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthCopyAllApproved"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedAgeOut"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedApMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedEssid"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedCopyToAuthTable"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedFirstHeard"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedLastHeard"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedPortalPtr"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedHowFound"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedHowAuth"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedErase"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueAgeOut"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueApMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueEssid"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueCopyToAuthTable"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueFirstHeard"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueLastHeard"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRoguePortalPtr"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueHowFound"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueClosestPortalPtr"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueClosestPortalRssi"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueErase"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsApMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsApEssid"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsInProcess"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsPortalMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsRssi"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuMac"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuInProcess"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuStatus"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuResultsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuResultsRssi"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuResultsEssid"), ("SYMBOL-CC-WS2000-MIB", "ccRapPollOneMuResultsApMac"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusDataSource"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusDefaultEapType"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthIpAddr"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthMask"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthSharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyRetryCount"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerIp"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerPort"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerSharedSecret"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapServerIp"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapServerPort"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapLoginAttribute"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapPasswordAttribute"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapBindDistinguishedName"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapBindDistinguishedPassword"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapBaseDistinguishedName"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapGroupAttribute"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapGroupFilter"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusLdapGroupMembershipAttribute"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersId"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersPassword"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroups"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccNtpCurrentDateTime"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusAuthTypePeap"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusAuthTypeTtls"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusClientAuthRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerPrefixOrSuffix"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInSrcIp"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInSrcIpLength"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInDestIp"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInDestIpLength"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInTransport"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInSrcPortStart"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInSrcPortEnd"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInDestPortStart"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInDestPortEnd"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInAction"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutIndex"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutSrcIp"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutSrcIpLength"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutDestIp"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutDestIpLength"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutTransport"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutSrcPortStart"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutSrcPortEnd"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutDestPortStart"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutDestPortEnd"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutReverseNat"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutAction"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlRedundancyPreviousOperState"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOutRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatLowestUnusedSlot"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessPtrToRules"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleSrcPtr"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleDestPtr"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleTransport"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleStartPort"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleEndPort"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessRuleRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlEnableIndex"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlEnableName"), ("SYMBOL-CC-WS2000-MIB", "ccTrapCtrlEnable"), ("SYMBOL-CC-WS2000-MIB", "ccWlanQosMonitorSent"), ("SYMBOL-CC-WS2000-MIB", "ccWlanQosMonitorDropped"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortPp10kDropped"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusProxyServerRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatOutboundEnable"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueIndex"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongPp10kDropped"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAccessV3User"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpV3EngineId"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqIndex"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqKeyId"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqSubject"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqDept"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqOrg"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqCity"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqState"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqPostal"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqCountry"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqEmail"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqDomain"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqIp"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqSigAlgo"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqKeyLen"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqGenReq"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqCertReqStr"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsReqRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedStr"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedImport"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedIndex"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedKeyId"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedIssuerName"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedSubject"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedExpiry"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsSignedDeleteRow"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsStr"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsImport"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsKeyId"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsIssuerName"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsSubject"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsSerialNumber"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsExpiry"), ("SYMBOL-CC-WS2000-MIB", "ccCACertsDeleteRow"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsLocation"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsAntenna"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsShortPreamble"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsUniSpread"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsRtsThresh"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsBeaconInt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDtimPrd"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsSecBeacon"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsPriWlan"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsBasicRates"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsSupportedRates"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsBGMode"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsAdoptedWlan"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDesPlacement")], [("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioPosChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDesChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioPosPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDesPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioPowerInMW"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioSet"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioReset"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioPlacement"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultAntenna"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultShortPreamble"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultUniSpread"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultRtsThresh"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultBeaconInt"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultDtimPrd"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultSecBeacon"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultPriWlan"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultBasicRates"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultSupportedRates"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultBGMode"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultDesPlacement"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultPosChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultDesChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultPosPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultDesPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultSet"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultReset"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultPlacement"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultPowerLevel"), ("SYMBOL-CC-WS2000-MIB", "cc802dt1xPortAuthLogin"), ("SYMBOL-CC-WS2000-MIB", "cc802dt1xPortAuthPass"), ("SYMBOL-CC-WS2000-MIB", "cc802dt1xPortAuthSetAp300"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDefaultIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRapPortalResultsIndex"), ("SYMBOL-CC-WS2000-MIB", "ccRapAuthCopyAllRogue"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSettingsDetector"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyHeartbeatInterface"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusCACertificate"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusServerCertificate"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerDomainName"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetDhcpServerWinsServer"), ("SYMBOL-CC-WS2000-MIB", "ccCertMgntSelfCertsIdName"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSystemStatsProbeRespRetries3OrMore"), ("SYMBOL-CC-WS2000-MIB", "ccPortalSumStatsLongPp10kTxMaxRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoFastRoamKeyCache"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoFastRoamPreAuth"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoAllowTkipClient"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoKey"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoPassphrase"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoKeyToUse"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoKeyRotationInterval"), ("SYMBOL-CC-WS2000-MIB", "ccWlanCryptoWpaTwoBcastKeyRotation"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvOverrideMode"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvImportRules"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapSyslogMode"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapSyslogSeverIp"), ("SYMBOL-CC-WS2000-MIB", "ccMgmtAccessHttpsTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccNtpSyncInterval"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccLoggingDeleteCoreFile"), ("SYMBOL-CC-WS2000-MIB", "ccLoggingTransferCoreFile"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadiusAcctMuRetries"), ("SYMBOL-CC-WS2000-MIB", "ccWanVpnKeyAutoIkeAuthType"), ("SYMBOL-CC-WS2000-MIB", "ccWanNatInboundTranslationPort"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyOperMode"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsApprovedChannel"), ("SYMBOL-CC-WS2000-MIB", "ccRapResultsRogueChannel"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultDesPowerInMW"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDesPowerInMW"), ("SYMBOL-CC-WS2000-MIB", "ccPortalCfgRadioDefaultPowerInMW"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadiusAcctMode"), ("SYMBOL-CC-WS2000-MIB", "ccWlanAuthEapRadiusAcctMuTimeout"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInReverseNatIp"), ("SYMBOL-CC-WS2000-MIB", "ccSubnetAccessAdvInReverseNatPort")]]:
    if getattr(mibBuilder, 'version', 0) < (4, 4, 2):
        # WARNING: leading objects get lost here!
        ccGroupsV2dot0variables = ccGroupsV2dot0variables.setObjects(*_ccGroupsV2dot0variables_obj)
    else:
        ccGroupsV2dot0variables = ccGroupsV2dot0variables.setObjects(*_ccGroupsV2dot0variables_obj, **dict(append=True))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV2dot0variables = ccGroupsV2dot0variables.setStatus('current')
if mibBuilder.loadTexts: ccGroupsV2dot0variables.setDescription('Description.')
ccGroupsV2dot0obsoleted = ObjectGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 3, 2)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsShortSkip1"), ("SYMBOL-CC-WS2000-MIB", "ccWlanSumStatsLongSkip1"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusAccessWlanPtrs"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroup"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroupRowStatus"), ("SYMBOL-CC-WS2000-MIB", "ccRadiusUsersGroupId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV2dot0obsoleted = ccGroupsV2dot0obsoleted.setStatus('obsolete')
if mibBuilder.loadTexts: ccGroupsV2dot0obsoleted.setDescription('Description.')
ccGroupsV2dot0notifications = NotificationGroup((1, 3, 6, 1, 4, 1, 388, 11, 2, 1000, 3, 3)).setObjects(("SYMBOL-CC-WS2000-MIB", "ccPortalAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalUnAdopted"), ("SYMBOL-CC-WS2000-MIB", "ccPortalDenied"), ("SYMBOL-CC-WS2000-MIB", "ccMuAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuUnAssociated"), ("SYMBOL-CC-WS2000-MIB", "ccMuDenied"), ("SYMBOL-CC-WS2000-MIB", "ccConfigChange"), ("SYMBOL-CC-WS2000-MIB", "ccSnmpAclViolation"), ("SYMBOL-CC-WS2000-MIB", "ccPortStatusChange"), ("SYMBOL-CC-WS2000-MIB", "ccCfAlmostFull"), ("SYMBOL-CC-WS2000-MIB", "ccFirewallUnderAttack"), ("SYMBOL-CC-WS2000-MIB", "ccRadarDetected"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsMu"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsPortal"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsWlan"), ("SYMBOL-CC-WS2000-MIB", "ccSumStatsSwitch"), ("SYMBOL-CC-WS2000-MIB", "ccLanVlanActivated"), ("SYMBOL-CC-WS2000-MIB", "ccDhcpOptionsFileTransferStatus"), ("SYMBOL-CC-WS2000-MIB", "ccRapNewApprovedAp"), ("SYMBOL-CC-WS2000-MIB", "ccRapNewRogueAp"), ("SYMBOL-CC-WS2000-MIB", "ccRedundancyStateChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccGroupsV2dot0notifications = ccGroupsV2dot0notifications.setStatus('current')
if mibBuilder.loadTexts: ccGroupsV2dot0notifications.setDescription('Description.')
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccWlanCrypto=ccWlanCrypto, ccWlanCryptoKeyguardKey3=ccWlanCryptoKeyguardKey3, ccMuTxPktsAt22Mb=ccMuTxPktsAt22Mb, ccIdHwVersion=ccIdHwVersion, ccSnmpTrapSinkV3SecurityLevel=ccSnmpTrapSinkV3SecurityLevel, ccWanVpnKeyAutoUsePerfectSecrecy=ccWanVpnKeyAutoUsePerfectSecrecy, ccPortalCfgRadioPosPowerLevel=ccPortalCfgRadioPosPowerLevel, ccMuSigStatsSignalSumSquares=ccMuSigStatsSignalSumSquares, ccWanVpnLocalWanIp=ccWanVpnLocalWanIp, ccWlanSumStatsLongTxAvgRetries100=ccWlanSumStatsLongTxAvgRetries100, ccWanVpnKeyAutoIkeDiffieHelmanGroup=ccWanVpnKeyAutoIkeDiffieHelmanGroup, ccPortalSumStatsShortPktsPerSecTx100=ccPortalSumStatsShortPktsPerSecTx100, ccWlanCryptoKeyguardKey4=ccWlanCryptoKeyguardKey4, ccWanVpnTable=ccWanVpnTable, ccPortalTxRetriesPkts11=ccPortalTxRetriesPkts11, ccRouterUserRoutesEntry=ccRouterUserRoutesEntry, ccPortalTxRetriesPktsTable=ccPortalTxRetriesPktsTable, ccMuWlanName=ccMuWlanName, ccPortalSigStatsSnrMostRecent=ccPortalSigStatsSnrMostRecent, ccCfgHistChangeCount=ccCfgHistChangeCount, ccWanNatInboundIndex=ccWanNatInboundIndex, ccMuRxRssiNumPkts=ccMuRxRssiNumPkts, ccRadiusProxyRetryCount=ccRadiusProxyRetryCount, ccWlanTxRetriesPkts15=ccWlanTxRetriesPkts15, ccRapResultsRogueClosestPortalPtr=ccRapResultsRogueClosestPortalPtr, ccRapResults=ccRapResults, ccPortalSigStatsSignalBest=ccPortalSigStatsSignalBest, ccWlanAuthEapMuTxPeriod=ccWlanAuthEapMuTxPeriod, ccWlanTxPktsAt6Mb=ccWlanTxPktsAt6Mb, ccMuTxOctetsAt22Mb=ccMuTxOctetsAt22Mb, ccWanVpnSaTable=ccWanVpnSaTable, ccWlanSumStatsShortThroughputRx=ccWlanSumStatsShortThroughputRx, ccWlanCryptoWepKey3=ccWlanCryptoWepKey3, ccSnmpAccessV3PrivacyAlgorithm=ccSnmpAccessV3PrivacyAlgorithm, RadioType=RadioType, ccWlanRxOctetsTable=ccWlanRxOctetsTable, ccRadiusLdapBaseDistinguishedName=ccRadiusLdapBaseDistinguishedName, ccCertMgntSelfCertsReqState=ccCertMgntSelfCertsReqState, ccPortalBackgroundNoiseBest=ccPortalBackgroundNoiseBest, ccCompactFlash=ccCompactFlash, ccPortalSettingsBGMode=ccPortalSettingsBGMode, ccCertMgntSelfCertsReqDomain=ccCertMgntSelfCertsReqDomain, ccSnmpAccessV12Access=ccSnmpAccessV12Access, ccDhcpOptionsUpdateFwFilename=ccDhcpOptionsUpdateFwFilename, ccMgmtAccess=ccMgmtAccess, ccWlanTxRetriesOctetsNone=ccWlanTxRetriesOctetsNone, ccSubnetDhcpServerDefaultGateway=ccSubnetDhcpServerDefaultGateway, ccWlanStatsEntry=ccWlanStatsEntry, ccWlanTxOctetsAt2Mb=ccWlanTxOctetsAt2Mb, ccMgmtAccessAdmin=ccMgmtAccessAdmin, ccRadiusClientAuthSharedSecret=ccRadiusClientAuthSharedSecret, ccMuSumStatsShortThroughputRx=ccMuSumStatsShortThroughputRx, ccWlanRxPktsAt18Mb=ccWlanRxPktsAt18Mb, ccMuTxRetriesOctetsEntry=ccMuTxRetriesOctetsEntry, ccPortalCfgRadioTable=ccPortalCfgRadioTable, ccPortalCfgRadioPowerInMW=ccPortalCfgRadioPowerInMW, ccWanPppoeEnable=ccWanPppoeEnable, ccWlanTxOctetsAt48Mb=ccWlanTxOctetsAt48Mb, ccWlanSumStatsLongTotalMus=ccWlanSumStatsLongTotalMus, ccGroupsV2dot0notifications=ccGroupsV2dot0notifications, ccMuSumStatsLongPp10kRxUndecrypt=ccMuSumStatsLongPp10kRxUndecrypt, ccPortalRxOctetsAt9Mb=ccPortalRxOctetsAt9Mb, ccMuTxOctetsUcast=ccMuTxOctetsUcast, ccPortalAdoptionEntry=ccPortalAdoptionEntry, ccMuSumStatsShortTable=ccMuSumStatsShortTable, ccPortalSumStatsShortPp10kRxUndecrypt=ccPortalSumStatsShortPp10kRxUndecrypt, ccMuTxOctetsAt12Mb=ccMuTxOctetsAt12Mb, ccSubnetDhcpServerStaticMapIpAddr=ccSubnetDhcpServerStaticMapIpAddr, ccWlanTxRetriesOctets05=ccWlanTxRetriesOctets05, ccMuTxRetriesFailed=ccMuTxRetriesFailed, ccWlanAuthEapServerMaxRetries=ccWlanAuthEapServerMaxRetries, ccMuRxPktsUcast=ccMuRxPktsUcast, ccWlanAuth=ccWlanAuth, ccMuTxRetriesOctets05=ccMuTxRetriesOctets05, ccSubnetAccessAdvInReverseNatIp=ccSubnetAccessAdvInReverseNatIp, ccMuRxPktsAt6Mb=ccMuRxPktsAt6Mb, ccApTable=ccApTable, ccPortalTxRetriesPkts12=ccPortalTxRetriesPkts12, ccSnmpAccessV3Enable=ccSnmpAccessV3Enable, ccWlanRxPktsAt12Mb=ccWlanRxPktsAt12Mb, ccWanContentBlock=ccWanContentBlock, ccWlanWeight=ccWlanWeight, ccWlanTxRetriesPkts04=ccWlanTxRetriesPkts04, ccRadiusLdapGroupFilter=ccRadiusLdapGroupFilter, ccMuTxPktsAt54Mb=ccMuTxPktsAt54Mb, ccMuTxRetries04=ccMuTxRetries04, ccCACertsSerialNumber=ccCACertsSerialNumber, ccWlanAuthEapRadiusAcctMode=ccWlanAuthEapRadiusAcctMode, ccPortalSigStatsSnrWorst=ccPortalSigStatsSnrWorst, ccWanNatInboundTransport=ccWanNatInboundTransport, ccTrapCtrlPortalAdopted=ccTrapCtrlPortalAdopted, ccRadiusUsers=ccRadiusUsers, ccRapResultsApprovedEssid=ccRapResultsApprovedEssid, ccPortalTxRetriesPkts08=ccPortalTxRetriesPkts08, ccMuMac=ccMuMac, ccPortalTxRetriesPkts06=ccPortalTxRetriesPkts06, ccInfoSerialNumber=ccInfoSerialNumber, ccMuTxRetries07=ccMuTxRetries07, ccPortalSystemStatsBeaconsTxOctets=ccPortalSystemStatsBeaconsTxOctets, ccWlanAuthEapServerTimeout=ccWlanAuthEapServerTimeout, ccWlanQosMonitorDropped=ccWlanQosMonitorDropped, ccPortalTxOctetsAt12Mb=ccPortalTxOctetsAt12Mb, ccPortalCfgRadioDefaultDesPlacement=ccPortalCfgRadioDefaultDesPlacement, symbol=symbol, ccRadiusServerCertificate=ccRadiusServerCertificate, ccWlanTxOctetsUcast=ccWlanTxOctetsUcast, ccRouterRoutesMetric=ccRouterRoutesMetric, ccPortalCfgRadioDefaultTable=ccPortalCfgRadioDefaultTable, ccWlanSumStatsLongPktsPerSec100=ccWlanSumStatsLongPktsPerSec100, ccSnmpAccessV12CustomOid=ccSnmpAccessV12CustomOid, ccRapControlPollSymbolMus=ccRapControlPollSymbolMus, ccPortalSettingsDefaultAntenna=ccPortalSettingsDefaultAntenna, ccSubnetAccessAdvOutDestPortEnd=ccSubnetAccessAdvOutDestPortEnd, ccMuTxRetries11=ccMuTxRetries11, ccWlanSumStatsLongAvgMuNoise=ccWlanSumStatsLongAvgMuNoise, ccMuTxRetriesNone=ccMuTxRetriesNone, ccPortalSumStatsShortAvgBitSpeed=ccPortalSumStatsShortAvgBitSpeed, ccWlanCryptoWepKey2=ccWlanCryptoWepKey2, ccWlanRxUndecryptablePkts=ccWlanRxUndecryptablePkts, ccSnmpTrapSinkV12Version=ccSnmpTrapSinkV12Version, ccWlanCryptoWpaTwoKey=ccWlanCryptoWpaTwoKey, ccPortalTxRetriesPkts01=ccPortalTxRetriesPkts01, ccPortalCfgRadioDefaultPowerInMW=ccPortalCfgRadioDefaultPowerInMW, ccPortEntry=ccPortEntry, ccMuTxPktsAt36Mb=ccMuTxPktsAt36Mb, ccPortalSumStatsShortTotalMus=ccPortalSumStatsShortTotalMus, ccCertMgntSelfCertsSignedIssuerName=ccCertMgntSelfCertsSignedIssuerName, ccMuTxRetriesOctets10=ccMuTxRetriesOctets10, ccMuPortalIndex=ccMuPortalIndex, ccPortalSigStatsSignalSum=ccPortalSigStatsSignalSum, ccRadiusProxyTimeout=ccRadiusProxyTimeout, ccWlanStatsTable=ccWlanStatsTable, ccPortalOptions=ccPortalOptions, ccWanVpnKeyManualEspAuthAlg=ccWanVpnKeyManualEspAuthAlg, ccSumStatsMu=ccSumStatsMu, ccMuRxPktsAt12Mb=ccMuRxPktsAt12Mb, ccWlanRxPktsAt5pt5Mb=ccWlanRxPktsAt5pt5Mb, ccPortalCfgRadioDefaultSet=ccPortalCfgRadioDefaultSet, ccPortalRxOctetsAt54Mb=ccPortalRxOctetsAt54Mb, ccLoadFwInterface=ccLoadFwInterface, ccWlanTxPktsUcast=ccWlanTxPktsUcast, ccSnmpTrapSinkV3Index=ccSnmpTrapSinkV3Index, ccSnmpTraps=ccSnmpTraps, ccTrapCtrlSumStatsWlan=ccTrapCtrlSumStatsWlan, ccRouterRoutesDest=ccRouterRoutesDest, ccWlanTxRetriesOctets03=ccWlanTxRetriesOctets03, ccMuRxPktsNUcast=ccMuRxPktsNUcast, ccRadiusUsersGroups=ccRadiusUsersGroups, ccLoadCfgServerFilename=ccLoadCfgServerFilename, ccWlanTxRetriesPkts06=ccWlanTxRetriesPkts06, ccPortalLastMac=ccPortalLastMac, ccWanNatOutboundEnable=ccWanNatOutboundEnable, ccWlanSumStatsShortAvgMuSignal=ccWlanSumStatsShortAvgMuSignal, ccTrapCtrlDhcpOptionsFileTransferStatusRequested=ccTrapCtrlDhcpOptionsFileTransferStatusRequested, ccMuTxRetriesOctets11=ccMuTxRetriesOctets11, ccMuTxRetriesOctetsTable=ccMuTxRetriesOctetsTable, ccWlanSigStatsNoiseBest=ccWlanSigStatsNoiseBest, ccWlanSigStatsNoiseSumSquares=ccWlanSigStatsNoiseSumSquares, ccRedundancyOperState=ccRedundancyOperState, ccTrapCtrlSumStatsPortal=ccTrapCtrlSumStatsPortal, ccWlanEnable=ccWlanEnable, ccApGroup=ccApGroup, ccWlanQosMonitorSent=ccWlanQosMonitorSent, ccWanVpnSaTxBytes=ccWanVpnSaTxBytes, ccPortalCfgRadioDesPlacement=ccPortalCfgRadioDesPlacement, ccRapResultsApprovedErase=ccRapResultsApprovedErase, ccMuTxRetries14=ccMuTxRetries14, ccPortalAdoptionTable=ccPortalAdoptionTable, ccSnmpAccessV3Table=ccSnmpAccessV3Table, ccResetMuCounters=ccResetMuCounters, ccRadiusUsersEntry=ccRadiusUsersEntry, ccWlanTxRetriesOctets02=ccWlanTxRetriesOctets02, ccWanContentBlockFtp=ccWanContentBlockFtp, ccCertMgntSelfCertsSignedExpiry=ccCertMgntSelfCertsSignedExpiry, ccPortalTxPktsAt1Mb=ccPortalTxPktsAt1Mb, ccRadiusLdapLoginAttribute=ccRadiusLdapLoginAttribute, ccResetStatCounters=ccResetStatCounters, ccRouterRip2Md5Key1Id=ccRouterRip2Md5Key1Id, ccAdmin=ccAdmin, ccTrapCtrlMuUnAssociated=ccTrapCtrlMuUnAssociated, ccMuSumStatsLongTxAvgRetries100=ccMuSumStatsLongTxAvgRetries100, ccRadiusServer=ccRadiusServer, ccPortalCfgRadioReset=ccPortalCfgRadioReset, ccPortalSettingsRtsThresh=ccPortalSettingsRtsThresh, ccWlanSumStatsLongThroughputRx=ccWlanSumStatsLongThroughputRx, ccMuSigStatsNoiseSumSquares=ccMuSigStatsNoiseSumSquares, ccWlanRxOctetsAt24Mb=ccWlanRxOctetsAt24Mb, ccWlanIndex=ccWlanIndex, MultiPointer63=MultiPointer63, ccWlanAuthentication=ccWlanAuthentication, ccPortalSystemStatsProbeReqRxOctets=ccPortalSystemStatsProbeReqRxOctets, ccWlanTxOctetsAt5pt5Mb=ccWlanTxOctetsAt5pt5Mb, ccWlanTxPktsTable=ccWlanTxPktsTable, ccWlanQosMonitorTable=ccWlanQosMonitorTable, ccSubnetAccessRuleName=ccSubnetAccessRuleName, ccRouterRoutesIndex=ccRouterRoutesIndex, ccTrapCtrlSnmpAclViolation=ccTrapCtrlSnmpAclViolation, ccTrapCtrlSumStatsTable=ccTrapCtrlSumStatsTable, ccPortalRxOctetsAt6Mb=ccPortalRxOctetsAt6Mb, ccWanNatInboundDefaultIp=ccWanNatInboundDefaultIp, ccRadiusUsersGroupTable=ccRadiusUsersGroupTable, ccCACertsEntry=ccCACertsEntry, ccSnmpAccessV3Index=ccSnmpAccessV3Index, ccMuTxRetriesOctets02=ccMuTxRetriesOctets02, ccLoggingDeleteCoreFile=ccLoggingDeleteCoreFile, ccWlanTxRetriesOctets08=ccWlanTxRetriesOctets08, ccRapAuthList=ccRapAuthList, ccWanContentBlockSmtp=ccWanContentBlockSmtp, ccWanPppoeIdleTime=ccWanPppoeIdleTime, ccWlanMuAclTable=ccWlanMuAclTable, ccSnmpLastDeniedIpAddr=ccSnmpLastDeniedIpAddr, ccMuTxOctetsTable=ccMuTxOctetsTable, ccLoadFwOperation=ccLoadFwOperation, ccPortalSumStatsLongTotalMus=ccPortalSumStatsLongTotalMus, ccWlanTxRetriesPktsTable=ccWlanTxRetriesPktsTable, ccWlanMuAclIndex=ccWlanMuAclIndex, ccRouterRoutesGateway=ccRouterRoutesGateway, ccWlanPortalsAdopted=ccWlanPortalsAdopted, ccPortalTxRetriesOctets02=ccPortalTxRetriesOctets02, ccWlanTxPktsAt2Mb=ccWlanTxPktsAt2Mb, ccWlanTxOctetsAt54Mb=ccWlanTxOctetsAt54Mb, ccRapAuthRowExists=ccRapAuthRowExists, ccWanNatType=ccWanNatType, ccRadiusUsersGroup=ccRadiusUsersGroup, ccPortalSigStatsNoiseWorst=ccPortalSigStatsNoiseWorst, ccWlanCryptoWpaTwoKeyToUse=ccWlanCryptoWpaTwoKeyToUse, ccMgmtAccessSshInactivityTimeout=ccMgmtAccessSshInactivityTimeout, ccLoadFwServerPath=ccLoadFwServerPath, ccPortalSettingsDefaultBeaconInt=ccPortalSettingsDefaultBeaconInt, ccSubnetAccessAdvInDestIp=ccSubnetAccessAdvInDestIp, ccPortalCfgRadioDefaultDesChannel=ccPortalCfgRadioDefaultDesChannel, ccPortalNumberOfEss=ccPortalNumberOfEss, ccMuSigStatsSnrSumSquares=ccMuSigStatsSnrSumSquares, ccPortalGroup=ccPortalGroup, ccRapResultsApprovedTable=ccRapResultsApprovedTable, ccWlanSumStatsLongAvgMuSnr=ccWlanSumStatsLongAvgMuSnr, ccMuRxPktsEntry=ccMuRxPktsEntry, ccRapPollOneMu=ccRapPollOneMu, ccRadiusLdapServerIp=ccRadiusLdapServerIp, ccTrapCtrlLanVlanActivatedVlanId=ccTrapCtrlLanVlanActivatedVlanId, ccMuInfoEntry=ccMuInfoEntry, ccMgmtAccessHttpsTimeout=ccMgmtAccessHttpsTimeout, ccApPointersToPortals=ccApPointersToPortals, ccTrapCtrlSumStatsThresholdPortals=ccTrapCtrlSumStatsThresholdPortals, ccWanVpnIkeState=ccWanVpnIkeState, ccMuSumStatsShortThroughput=ccMuSumStatsShortThroughput, ccSnmpAccessV3AuthAlgorithm=ccSnmpAccessV3AuthAlgorithm, ccWanVpnKeyManualTable=ccWanVpnKeyManualTable, ccRapPollOneMuResultsEssid=ccRapPollOneMuResultsEssid, ccPortalSumStatsLongPp10kRxUndecrypt=ccPortalSumStatsLongPp10kRxUndecrypt, ccRapResultsRogueChannel=ccRapResultsRogueChannel, ccWanVpnKeyManualInEspEncrypKey=ccWanVpnKeyManualInEspEncrypKey, ccPortalSettingsBeaconInt=ccPortalSettingsBeaconInt, ccPortalTxOctetsAt24Mb=ccPortalTxOctetsAt24Mb)
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccWlanRxPktsAt1Mb=ccWlanRxPktsAt1Mb, ccWanNatTimeout=ccWanNatTimeout, ccWlanRxPktsAt6Mb=ccWlanRxPktsAt6Mb, ccWlanAuthEapSyslogMode=ccWlanAuthEapSyslogMode, ccPortalSumStatsShortNumPkts=ccPortalSumStatsShortNumPkts, ccWanNat1to1IpAddr=ccWanNat1to1IpAddr, ccRapResultsApproved=ccRapResultsApproved, ccRadiusClientAuthIpAddr=ccRadiusClientAuthIpAddr, ccRapResultsApprovedLastHeard=ccRapResultsApprovedLastHeard, ccMuSigStatsSnrMostRecent=ccMuSigStatsSnrMostRecent, ccSnmpTrapSinkV3AuthAlgorithm=ccSnmpTrapSinkV3AuthAlgorithm, ccLoadFwSuccess=ccLoadFwSuccess, ccApNicMac=ccApNicMac, ccWanVpnSaStatus=ccWanVpnSaStatus, ccRapResultsRogueEntry=ccRapResultsRogueEntry, ccPortalCfgRadioDesChannel=ccPortalCfgRadioDesChannel, ccPortalSumStatsShortThroughput=ccPortalSumStatsShortThroughput, ccSnmpTrapSinkV12Enable=ccSnmpTrapSinkV12Enable, ccMuSigStatsNoiseWorst=ccMuSigStatsNoiseWorst, ccCertMgntSelfCertsReqRowStatus=ccCertMgntSelfCertsReqRowStatus, ccMuIpAddr=ccMuIpAddr, ccMuTxOctetsAt18Mb=ccMuTxOctetsAt18Mb, ccRapResultsApprovedAgeOut=ccRapResultsApprovedAgeOut, ccWlanTxRetriesPkts05=ccWlanTxRetriesPkts05, ccRadiusProxyServerRowStatus=ccRadiusProxyServerRowStatus, RowStatus=RowStatus, ccRapControl=ccRapControl, ccSnmpTrapSinkV12Community=ccSnmpTrapSinkV12Community, ccSubnetAccessRuleTransport=ccSubnetAccessRuleTransport, ccApBootLoaderRev=ccApBootLoaderRev, ccPortalTxRetriesPkts14=ccPortalTxRetriesPkts14, ccPortalSettingsDefaultIndex=ccPortalSettingsDefaultIndex, ccCertMgntSelfCertsReqOrg=ccCertMgntSelfCertsReqOrg, ccSubnetAccessEntry=ccSubnetAccessEntry, ccPortalRxOctetsAt36Mb=ccPortalRxOctetsAt36Mb, ccRedundancyAdminState=ccRedundancyAdminState, ccWlanCryptoWpaTwoBcastKeyRotation=ccWlanCryptoWpaTwoBcastKeyRotation, ccWlanTxRetriesOctets04=ccWlanTxRetriesOctets04, ccIdMibVersion=ccIdMibVersion, ccMuSumStatsLongPktsPerSecTx100=ccMuSumStatsLongPktsPerSecTx100, ccPortalTxPktsAt2Mb=ccPortalTxPktsAt2Mb, ccWanNatInboundRowStatus=ccWanNatInboundRowStatus, ccAssociationLastAssociate=ccAssociationLastAssociate, ccWanDefaultGateway=ccWanDefaultGateway, ccSubnetAccessAdvOutRowStatus=ccSubnetAccessAdvOutRowStatus, ccMuAuthenticationMethod=ccMuAuthenticationMethod, ccRedundancyStateChange=ccRedundancyStateChange, ccMuSumStatsLongTable=ccMuSumStatsLongTable, ccSnmpAccessV3Entry=ccSnmpAccessV3Entry, ccGroupsV2dot0=ccGroupsV2dot0, ccCACertsStr=ccCACertsStr, ccAssociationTable=ccAssociationTable, ccPortalRxPktsAt48Mb=ccPortalRxPktsAt48Mb, ccTrapCtrlSumStatsCanBeSetWlan=ccTrapCtrlSumStatsCanBeSetWlan, ccLoggingSyslogServer=ccLoggingSyslogServer, ccPortalTxRetriesPkts04=ccPortalTxRetriesPkts04, ccPortalTxRetriesPkts02=ccPortalTxRetriesPkts02, ccPortalSumStatsLongThroughputTx=ccPortalSumStatsLongThroughputTx, ccSubnetAccessAdvInSrcPortStart=ccSubnetAccessAdvInSrcPortStart, ccPortalSettingsUniSpread=ccPortalSettingsUniSpread, ccNtpCurrentDateTime=ccNtpCurrentDateTime, ccPortalTxRetriesPkts03=ccPortalTxRetriesPkts03, ccPortalRxOctetsAt1Mb=ccPortalRxOctetsAt1Mb, ccCertMgntSelfCertsReqCountry=ccCertMgntSelfCertsReqCountry, ccRapAuthErase=ccRapAuthErase, wsd=wsd, ccRapResultsRogueClosestPortalRssi=ccRapResultsRogueClosestPortalRssi, ccMuRxPktsAt9Mb=ccMuRxPktsAt9Mb, ccPortalSettingsDefaultEntry=ccPortalSettingsDefaultEntry, ccPortalSettingsEntry=ccPortalSettingsEntry, ccMuTxOctetsAt2Mb=ccMuTxOctetsAt2Mb, ccSubnetDhcpServerWinsServer=ccSubnetDhcpServerWinsServer, ccWlanTxRetriesOctets09=ccWlanTxRetriesOctets09, ccSubnetAccessRuleEntry=ccSubnetAccessRuleEntry, ccPortalName=ccPortalName, ccWlanTxRetriesPkts02=ccWlanTxRetriesPkts02, ccLoadCfg=ccLoadCfg, ccSubnetAccessAdvOutSrcIp=ccSubnetAccessAdvOutSrcIp, ccWlanSumStatsShortPp10kTxWithRetries=ccWlanSumStatsShortPp10kTxWithRetries, cc802dt1xPortAuthPass=cc802dt1xPortAuthPass, ccWlanTxRetriesOctets06=ccWlanTxRetriesOctets06, ccPortalTxPktsAt5pt5Mb=ccPortalTxPktsAt5pt5Mb, ccWanPppoePassword=ccWanPppoePassword, ccMuSumStatsShortPktsPerSecTx100=ccMuSumStatsShortPktsPerSecTx100, ccMuTxOctetsAt54Mb=ccMuTxOctetsAt54Mb, ccMuSumStatsLongTimestamp=ccMuSumStatsLongTimestamp, ccRapControlOnChannel=ccRapControlOnChannel, ccSubnetDhcpServerStaticMapMac=ccSubnetDhcpServerStaticMapMac, ccDhcpOptions=ccDhcpOptions, ccWlanTxRetriesOctets07=ccWlanTxRetriesOctets07, ccPortalTxRetriesPkts09=ccPortalTxRetriesPkts09, ccWanSecondaryDnsServer=ccWanSecondaryDnsServer, ccWlanCryptoWepKey1=ccWlanCryptoWepKey1, ccPortalSettingsDefaultSecBeacon=ccPortalSettingsDefaultSecBeacon, ccRapPortalResultsRssi=ccRapPortalResultsRssi, ccTrapCtrlFirewallUnderAttack=ccTrapCtrlFirewallUnderAttack, ccWlanTxOctetsAt24Mb=ccWlanTxOctetsAt24Mb, ccWlanSumStatsLongPp10kRxUndecrypt=ccWlanSumStatsLongPp10kRxUndecrypt, ccMuTxRetriesOctets04=ccMuTxRetriesOctets04, ccPortalTxPktsAt48Mb=ccPortalTxPktsAt48Mb, ccWlanRxOctetsAt1Mb=ccWlanRxOctetsAt1Mb, ccMuRxOctetsNUcast=ccMuRxOctetsNUcast, ccTrapCtrlSumStatsThresholdWlans=ccTrapCtrlSumStatsThresholdWlans, ccWlanTxOctetsAt9Mb=ccWlanTxOctetsAt9Mb, ccTrapCtrlDhcpOptionsFileTransferStatus=ccTrapCtrlDhcpOptionsFileTransferStatus, ccMuTxRetriesOctets03=ccMuTxRetriesOctets03, ccMuTxPktsTable=ccMuTxPktsTable, ccPortalSigStatsSnrBest=ccPortalSigStatsSnrBest, ccPortalSettingsName=ccPortalSettingsName, ccWlanSumStatsShortThroughputTx=ccWlanSumStatsShortThroughputTx, ccConfigChange=ccConfigChange, ccRadiusAccess=ccRadiusAccess, ccMuTxRetriesOctets12=ccMuTxRetriesOctets12, ccRouterRoutesEntry=ccRouterRoutesEntry, ccNtp1Server=ccNtp1Server, ccLanVlanTrunked=ccLanVlanTrunked, ccPortalSettingsDefaultUniSpread=ccPortalSettingsDefaultUniSpread, ccMuLastActivity=ccMuLastActivity, ccPortalRxPktsAt54Mb=ccPortalRxPktsAt54Mb, ccWlanSumStatsShortPp10kNUcastPkts=ccWlanSumStatsShortPp10kNUcastPkts, ccWanDhcpSubnetMask=ccWanDhcpSubnetMask, ccWanVpnKeyAutoTable=ccWanVpnKeyAutoTable, ccRadiusDefaultEapType=ccRadiusDefaultEapType, ccWlanTxRetriesPkts09=ccWlanTxRetriesPkts09, ccRouterUserRoutesDestMask=ccRouterUserRoutesDestMask, ccSubnetAccessRuleTable=ccSubnetAccessRuleTable, ccWlanEntry=ccWlanEntry, ccRf=ccRf, ccWanVpnRemoteGateway=ccWanVpnRemoteGateway, ccCertMgntSelfCertsReqSubject=ccCertMgntSelfCertsReqSubject, ccWlanAuthKerberosKdcServerIp2=ccWlanAuthKerberosKdcServerIp2, ccSubnetAccessAdvOutSrcPortStart=ccSubnetAccessAdvOutSrcPortStart, ccMuSumStatsShortNumPkts=ccMuSumStatsShortNumPkts, ccLoggingToSyslog=ccLoggingToSyslog, ccPortalRxPktsAt11Mb=ccPortalRxPktsAt11Mb, ccPortalRadioType=ccPortalRadioType, ccSubnetWlanMembers=ccSubnetWlanMembers, ccWanIndex=ccWanIndex, ccSubnetAccessRuleRowStatus=ccSubnetAccessRuleRowStatus, ccPortalTxPktsAt22Mb=ccPortalTxPktsAt22Mb, ccMuTxRetriesOctets08=ccMuTxRetriesOctets08, DoActionShowProgress=DoActionShowProgress, ccPortalSettingsSecBeacon=ccPortalSettingsSecBeacon, ccWlanRxPktsAt48Mb=ccWlanRxPktsAt48Mb, ccPortalTxRetriesOctetsFailed=ccPortalTxRetriesOctetsFailed, ccWanVpnSaOutSpi=ccWanVpnSaOutSpi, ccWlanTxRetriesOctets15=ccWlanTxRetriesOctets15, ccWanVpnIkeRemainingLife=ccWanVpnIkeRemainingLife, ccPortalRxPktsAt2Mb=ccPortalRxPktsAt2Mb, ccWlanTxPktsAt18Mb=ccWlanTxPktsAt18Mb, ccPortalTxRetriesOctets09=ccPortalTxRetriesOctets09, ccPortalRxPktsAt1Mb=ccPortalRxPktsAt1Mb, ccMuRxOctetsAt9Mb=ccMuRxOctetsAt9Mb, ccCACertsTable=ccCACertsTable, ccSubnetAccessRuleType=ccSubnetAccessRuleType, ccWlanAuthKerberosEntry=ccWlanAuthKerberosEntry, ccCertMgntSelfCertsReqCertReqStr=ccCertMgntSelfCertsReqCertReqStr, ccPortalRxPktsUcast=ccPortalRxPktsUcast, ccWlanRxPktsAt2Mb=ccWlanRxPktsAt2Mb, ccCertMgntSelfCertsReqGenReq=ccCertMgntSelfCertsReqGenReq, ccRapResultsRoguePortalPtr=ccRapResultsRoguePortalPtr, ccSnmpAccessV3SecurityLevel=ccSnmpAccessV3SecurityLevel, ccRapPortalResultsInProcess=ccRapPortalResultsInProcess, ccWlanCryptoKeyguardTable=ccWlanCryptoKeyguardTable, ccLoggingTransferCoreFile=ccLoggingTransferCoreFile, ccPortalSumStatsShortPktsPerSecRx100=ccPortalSumStatsShortPktsPerSecRx100, ccRadiusUsersGroupRowStatus=ccRadiusUsersGroupRowStatus, ccMuSymbolRogueApEna=ccMuSymbolRogueApEna, ccRouterRipDirection=ccRouterRipDirection, ccMuSumStatsLongPp10kTxWithRetries=ccMuSumStatsLongPp10kTxWithRetries, ccSubnetIndex=ccSubnetIndex, ccPortalCfgRadioChannel=ccPortalCfgRadioChannel, ccPortalSumStatsShortTxAvgRetries100=ccPortalSumStatsShortTxAvgRetries100, ccPortalSumStatsShortPp10kNUcastPkts=ccPortalSumStatsShortPp10kNUcastPkts, ccSubnetPortMembers=ccSubnetPortMembers, ccWanVpnTunnelStatus=ccWanVpnTunnelStatus, ccRouterRipType=ccRouterRipType, ccCertMgntSelfCertsReqDept=ccCertMgntSelfCertsReqDept, ccMgmtAccessSsh=ccMgmtAccessSsh, ccPortalTxRetriesOctets06=ccPortalTxRetriesOctets06, ccSnmpTrapSinkV3PrivacyAlgorithm=ccSnmpTrapSinkV3PrivacyAlgorithm, ccNtpGmtHourOffset=ccNtpGmtHourOffset, ccWanDhcpIpAddr=ccWanDhcpIpAddr, ccCfgHistChangeTime=ccCfgHistChangeTime, ccMuTxPktsAt11Mb=ccMuTxPktsAt11Mb, ccWlanSigStatsTable=ccWlanSigStatsTable, ccPortalRxPktsAt22Mb=ccPortalRxPktsAt22Mb, ccMuRxPktsAt48Mb=ccMuRxPktsAt48Mb, ccWanIpAddr=ccWanIpAddr, ccMuTxOctetsAt24Mb=ccMuTxOctetsAt24Mb, ccCertMgnt=ccCertMgnt, ccNtp2Server=ccNtp2Server, ccNtp0Server=ccNtp0Server, ccPortalTxRetriesOctets04=ccPortalTxRetriesOctets04, ccWlanTxOctetsAt12Mb=ccWlanTxOctetsAt12Mb, ccSnmpAccessV12Enable=ccSnmpAccessV12Enable, ccSubnetAccessAdvInSrcIpLength=ccSubnetAccessAdvInSrcIpLength, ccWanPppoeEntry=ccWanPppoeEntry, ccMuTxRetries05=ccMuTxRetries05, ccMuSumStatsLongAvgMuNoise=ccMuSumStatsLongAvgMuNoise, ccTrapCtrlMuAssociated=ccTrapCtrlMuAssociated, ccLoad=ccLoad, ccRadiusAuthTypePeap=ccRadiusAuthTypePeap, ccWlanTxRetriesOctets11=ccWlanTxRetriesOctets11, ccRadiusProxyServerPrefixOrSuffix=ccRadiusProxyServerPrefixOrSuffix, ccSubnetDhcpState=ccSubnetDhcpState, ccLoadFwResult=ccLoadFwResult, ccMuTxRetriesOctets01=ccMuTxRetriesOctets01, ccMuInfoTable=ccMuInfoTable, ccWanVpnKeyManualEntry=ccWanVpnKeyManualEntry, ccApNumPortals=ccApNumPortals, ccTrapCtrlSumStatsIndex=ccTrapCtrlSumStatsIndex, ccSubnetDhcpIpAddress=ccSubnetDhcpIpAddress, ccMuTxRetries02=ccMuTxRetries02, ccMuRxPktsAt5pt5Mb=ccMuRxPktsAt5pt5Mb, ccMuRxPktsAt2Mb=ccMuRxPktsAt2Mb, ccPortalTxRetriesOctetsTable=ccPortalTxRetriesOctetsTable, ccWlanTxRetriesPktsFailed=ccWlanTxRetriesPktsFailed, ccSubnetAccessPtrToRules=ccSubnetAccessPtrToRules, ccDhcpOptionsUpdateCfgEna=ccDhcpOptionsUpdateCfgEna, ccWanVpnIndex=ccWanVpnIndex, ccSubnetDhcpServerStaticMapEntry=ccSubnetDhcpServerStaticMapEntry, ccPortalSystemStatsProbeRespRetriesFailed=ccPortalSystemStatsProbeRespRetriesFailed, ccRedundancyHeartbeatInterface=ccRedundancyHeartbeatInterface, ccPortalTxOctetsTable=ccPortalTxOctetsTable, ccRadiusCACertificate=ccRadiusCACertificate, ccPortalRxOctetsEntry=ccPortalRxOctetsEntry, ccPortalSumStatsShortPp10kTxWithRetries=ccPortalSumStatsShortPp10kTxWithRetries, ccWan=ccWan, ccPortalSumStatsLongPp10kNUcastPkts=ccPortalSumStatsLongPp10kNUcastPkts, ccMuSumStatsLongPp10kNUcastPkts=ccMuSumStatsLongPp10kNUcastPkts, ccMuTxRetriesOctets13=ccMuTxRetriesOctets13, ccWanVpnKeyManualOutEspSpi=ccWanVpnKeyManualOutEspSpi, ccWanVpnKeyAutoAhAuth=ccWanVpnKeyAutoAhAuth, ccPortalTxRetriesOctets10=ccPortalTxRetriesOctets10, ccPortalRxPktsNUcast=ccPortalRxPktsNUcast, ccWlanCryptoWpaTwoFastRoamPreAuth=ccWlanCryptoWpaTwoFastRoamPreAuth, ccMgmtAccessAirbeamPassword=ccMgmtAccessAirbeamPassword, ccMuSumStatsShortPp10kRxUndecrypt=ccMuSumStatsShortPp10kRxUndecrypt, ccCertMgntSelfCertsReqTable=ccCertMgntSelfCertsReqTable, ccPortalAssociatedMus=ccPortalAssociatedMus, ccMuSumStatsLongThroughputTx=ccMuSumStatsLongThroughputTx, ccMgmtAccessAdminAuthRadiusServerPort=ccMgmtAccessAdminAuthRadiusServerPort, ccMuTxOctetsAt6Mb=ccMuTxOctetsAt6Mb, ccWlanSigStatsSnrWorst=ccWlanSigStatsSnrWorst, ccNtpSyncInterval=ccNtpSyncInterval, ccLanVlanEntry=ccLanVlanEntry, ccReset=ccReset, ccMgmtAccessAdminAuthRadiusServerIp=ccMgmtAccessAdminAuthRadiusServerIp, ccPortalRxPktsTable=ccPortalRxPktsTable, ccCACertsExpiry=ccCACertsExpiry, ccWlanRxPktsAt11Mb=ccWlanRxPktsAt11Mb, ccPortalUnAdopted=ccPortalUnAdopted, ccWlanCryptoWpaKeyRotationInterval=ccWlanCryptoWpaKeyRotationInterval)
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccCompactFlashUsed=ccCompactFlashUsed, ccPortalCfgRadioPosChannel=ccPortalCfgRadioPosChannel, ccRapPollOneMuInProcess=ccRapPollOneMuInProcess, ccRapResultsApprovedEntry=ccRapResultsApprovedEntry, ccSnmpTrapSinkV12DestinationIp=ccSnmpTrapSinkV12DestinationIp, ccMgmtAccessAdminPassword=ccMgmtAccessAdminPassword, ccSubnetAccessAdvOutDestIpLength=ccSubnetAccessAdvOutDestIpLength, ccWlanTxPktsAt9Mb=ccWlanTxPktsAt9Mb, ccMuTxOctetsAt1Mb=ccMuTxOctetsAt1Mb, ccPortalTxRetriesPkts05=ccPortalTxRetriesPkts05, ccWanNatWanIpAddress=ccWanNatWanIpAddress, ccRapAuthAllSymbolMac=ccRapAuthAllSymbolMac, ccSnmpAccessV12OidLimit=ccSnmpAccessV12OidLimit, ccWanNatInboundEntry=ccWanNatInboundEntry, ccMuSumStatsShortAvgMuSignal=ccMuSumStatsShortAvgMuSignal, ccRapDetectorsEnable=ccRapDetectorsEnable, ccRouterUserRoutesIndex=ccRouterUserRoutesIndex, ccAssociationFirstAssociate=ccAssociationFirstAssociate, ccRapPollOneMuResultsIndex=ccRapPollOneMuResultsIndex, ccWanFirewallIndex=ccWanFirewallIndex, ccCertMgntSelfCertsSignedIndex=ccCertMgntSelfCertsSignedIndex, ccRedundancyOperMode=ccRedundancyOperMode, ccMuRxPktsAt22Mb=ccMuRxPktsAt22Mb, ccPortalTxOctetsAt11Mb=ccPortalTxOctetsAt11Mb, ccPortalSigStatsTable=ccPortalSigStatsTable, ccMuRxOctetsUcast=ccMuRxOctetsUcast, ccCertMgntSelfCertsSignedStr=ccCertMgntSelfCertsSignedStr, ccPortalSettingsBasicRates=ccPortalSettingsBasicRates, ccSubnetDhcpServerPrimaryDns=ccSubnetDhcpServerPrimaryDns, ccSubnetAccessAdvOutEntry=ccSubnetAccessAdvOutEntry, ccWanVpnKeyManualOutEspEncrypKey=ccWanVpnKeyManualOutEspEncrypKey, ccPortalRxOctetsAt48Mb=ccPortalRxOctetsAt48Mb, ccPortalNumberOfBss=ccPortalNumberOfBss, ccRapResultsRogueFirstHeard=ccRapResultsRogueFirstHeard, ccWanFirewallMimeFloodMaxHeaders=ccWanFirewallMimeFloodMaxHeaders, ccSnmpAccessControlEndIp=ccSnmpAccessControlEndIp, ccCfgHist=ccCfgHist, ccMuTxRetriesOctets06=ccMuTxRetriesOctets06, ccSubnetAccessRuleStartPort=ccSubnetAccessRuleStartPort, ccPortalLocation=ccPortalLocation, ccMuTxRetriesOctetsNone=ccMuTxRetriesOctetsNone, ccPortalCfgRadioDefaultPowerLevel=ccPortalCfgRadioDefaultPowerLevel, ccMuSumStatsLongPp10kDropped=ccMuSumStatsLongPp10kDropped, ccTrapCtrlMuDenied=ccTrapCtrlMuDenied, ccNotificationsGroup=ccNotificationsGroup, ccMuDenied=ccMuDenied, ccRapPortalResultsEntry=ccRapPortalResultsEntry, ccSubnetAccessRuleDestPtr=ccSubnetAccessRuleDestPtr, ccWanEntry=ccWanEntry, ccWlanSumStatsShortTimestamp=ccWlanSumStatsShortTimestamp, ccWlanAuthKerberosRealmName=ccWlanAuthKerberosRealmName, ccMuTxOctetsAt36Mb=ccMuTxOctetsAt36Mb, ccCertMgntSelfCertsSignedTable=ccCertMgntSelfCertsSignedTable, ccSubnetAccessAdvInTable=ccSubnetAccessAdvInTable, ccPortalSigStatsEntry=ccPortalSigStatsEntry, ccMuRxPktsAt24Mb=ccMuRxPktsAt24Mb, ccWanVpnKeyAutoIkeRemoteIdData=ccWanVpnKeyAutoIkeRemoteIdData, ccMuRxOctetsAt18Mb=ccMuRxOctetsAt18Mb, ccTrapCtrlEnable=ccTrapCtrlEnable, ccPortalSumStatsLongPktsPerSecRx100=ccPortalSumStatsLongPktsPerSecRx100, ccTrapCtrlLanVlanActivated=ccTrapCtrlLanVlanActivated, ccTrapCtrlFirewallUnderAttackDescription=ccTrapCtrlFirewallUnderAttackDescription, ccWlanSumStatsLongPktsPerSecTx100=ccWlanSumStatsLongPktsPerSecTx100, ccPortalSumStatsLongNumPkts=ccPortalSumStatsLongNumPkts, ccPortalTxPowerLevel=ccPortalTxPowerLevel, ccPortalRxOctetsNUcast=ccPortalRxOctetsNUcast, ccPortalCfgRadioSet=ccPortalCfgRadioSet, ccRapResultsRogueErase=ccRapResultsRogueErase, ccMuTxPktsAt24Mb=ccMuTxPktsAt24Mb, ccPortalStatsEntry=ccPortalStatsEntry, ccPortalSettingsDefaultTable=ccPortalSettingsDefaultTable, ccPortalSettingsDefaultRtsThresh=ccPortalSettingsDefaultRtsThresh, PartsPer10k=PartsPer10k, ccWlanCryptoWpaKey=ccWlanCryptoWpaKey, ccMuRxOctetsAt48Mb=ccMuRxOctetsAt48Mb, ccWlanTxRetriesOctets10=ccWlanTxRetriesOctets10, ccGroupsV1dot5variables=ccGroupsV1dot5variables, ccPortalCfgRadioDesPowerLevel=ccPortalCfgRadioDesPowerLevel, ccCACertsIndex=ccCACertsIndex, ccPortalSettingsAdoptedWlan=ccPortalSettingsAdoptedWlan, ccWlanCryptoWpaTwoFastRoamKeyCache=ccWlanCryptoWpaTwoFastRoamKeyCache, ccLoadFwStart=ccLoadFwStart, ccWlanTxRetriesPktsEntry=ccWlanTxRetriesPktsEntry, ccWanVpnKeyAutoIkeRemoteIdType=ccWanVpnKeyAutoIkeRemoteIdType, ccRapPollOneMuResultsTable=ccRapPollOneMuResultsTable, ccPortalSigStatsSnrSumSquares=ccPortalSigStatsSnrSumSquares, ccRapDetectorsInterval=ccRapDetectorsInterval, ccWlanTxRetriesPkts13=ccWlanTxRetriesPkts13, ccLoadCfgStart=ccLoadCfgStart, ccRouterUserRoutesInterface=ccRouterUserRoutesInterface, ccSubnetTable=ccSubnetTable, ccRapAuthIndex=ccRapAuthIndex, ccPortTable=ccPortTable, ccWlanMulticastAddr2=ccWlanMulticastAddr2, ccMuTxRetries09=ccMuTxRetries09, ccPortalAdoptionIndex=ccPortalAdoptionIndex, ccSnmpAclViolations=ccSnmpAclViolations, ccSubnetIpAddress=ccSubnetIpAddress, ccRadiusProxyServerTable=ccRadiusProxyServerTable, ccMuTxRetriesTotal=ccMuTxRetriesTotal, ccPortalSettingsDefaultDtimPrd=ccPortalSettingsDefaultDtimPrd, ccPortalTxOctetsAt2Mb=ccPortalTxOctetsAt2Mb, ccWlanTxRetriesOctets12=ccWlanTxRetriesOctets12, ccWlanSumStatsShortPp10kDropped=ccWlanSumStatsShortPp10kDropped, ccLanVlanDefaultTag=ccLanVlanDefaultTag, ccSubnetAccess=ccSubnetAccess, ccTrapCtrlSumStatsThresholdSwitch=ccTrapCtrlSumStatsThresholdSwitch, ccTrapCtrl=ccTrapCtrl, ccWanContentBlockOutUrlTable=ccWanContentBlockOutUrlTable, ccSubnetDhcpServerPoolStart=ccSubnetDhcpServerPoolStart, ccWanTable=ccWanTable, ccWlanTxRetriesOctetsTable=ccWlanTxRetriesOctetsTable, ccWanVpnKeyManualInAhAuthKey=ccWanVpnKeyManualInAhAuthKey, ccRadarDetected=ccRadarDetected, ccCACerts=ccCACerts, ccWlanSigStatsSignalSum=ccWlanSigStatsSignalSum, ccPortalMac=ccPortalMac, ccMuTxPktsUcast=ccMuTxPktsUcast, ccPortalSumStatsShortTimestamp=ccPortalSumStatsShortTimestamp, ccWlanSumStatsShortTxAvgRetries100=ccWlanSumStatsShortTxAvgRetries100, ccPortalSumStatsLongThroughput=ccPortalSumStatsLongThroughput, ccPortalAdoptionWlanPointers=ccPortalAdoptionWlanPointers, ccWlanTxPktsAt22Mb=ccWlanTxPktsAt22Mb, ccPortalSumStatsShortAvgMuSnr=ccPortalSumStatsShortAvgMuSnr, ccSnmpTrapSinkV3Table=ccSnmpTrapSinkV3Table, ccSubnetAccessDestType=ccSubnetAccessDestType, ccRapPollSymbolMusInterval=ccRapPollSymbolMusInterval, ccPortalRxPktsAt6Mb=ccPortalRxPktsAt6Mb, ccWlanTxRetriesPkts14=ccWlanTxRetriesPkts14, ccPortalSumStatsShortThroughputTx=ccPortalSumStatsShortThroughputTx, ccSubnet=ccSubnet, ccTrapCtrlSumStatsUnits=ccTrapCtrlSumStatsUnits, ccWlanAuthKerberosPassword=ccWlanAuthKerberosPassword, ccLogging=ccLogging, ccRapPortalResultsIndex=ccRapPortalResultsIndex, ccRadiusProxyServerPort=ccRadiusProxyServerPort, ccWlanSumStatsShortAvgMuSnr=ccWlanSumStatsShortAvgMuSnr, ccPortSpeed=ccPortSpeed, ccMuSumStatsShortThroughputTx=ccMuSumStatsShortThroughputTx, ccTrapCtrlEnableEntry=ccTrapCtrlEnableEntry, ccSubnetAccessAdvInDestPortEnd=ccSubnetAccessAdvInDestPortEnd, ccRapPollOneMuStatus=ccRapPollOneMuStatus, ccGroupsV2dot0variables=ccGroupsV2dot0variables, ccWlanTxRetriesPktsNone=ccWlanTxRetriesPktsNone, ccMuSigStatsSignalSum=ccMuSigStatsSignalSum, ccApRuntimeFwVersion=ccApRuntimeFwVersion, ccMuTxRetriesEntry=ccMuTxRetriesEntry, ccPortalTxRetriesOctets12=ccPortalTxRetriesOctets12, ccPortalSigStatsSignalMostRecent=ccPortalSigStatsSignalMostRecent, ccWanVpnKeyAutoIkeLocalIdData=ccWanVpnKeyAutoIkeLocalIdData, ccPortalCfgRadioDefaultDesPowerInMW=ccPortalCfgRadioDefaultDesPowerInMW, ccWlanRxOctetsAt48Mb=ccWlanRxOctetsAt48Mb, ccSnmpAccessControlStartIp=ccSnmpAccessControlStartIp, ccMuTxRetries03=ccMuTxRetries03, ccWlanTxOctetsAt11Mb=ccWlanTxOctetsAt11Mb, ccRadiusUsersGroupEntry=ccRadiusUsersGroupEntry, ccMuSumStatsShortPktsPerSec100=ccMuSumStatsShortPktsPerSec100, ccMuTxRetriesOctetsFailed=ccMuTxRetriesOctetsFailed, ccWlanTxRetriesOctetsEntry=ccWlanTxRetriesOctetsEntry, ccMuTxRetries15=ccMuTxRetries15, ccPortalCfgRadioDefaultChannel=ccPortalCfgRadioDefaultChannel, ccWlanTxPktsAt36Mb=ccWlanTxPktsAt36Mb, ccSnmpAccessV3AuthPassword=ccSnmpAccessV3AuthPassword, ccWanVpnKeyManualOutAhSpi=ccWanVpnKeyManualOutAhSpi, ccWlanAuthEapRadius2SharedSecret=ccWlanAuthEapRadius2SharedSecret, ccWlanRxOctetsAt36Mb=ccWlanRxOctetsAt36Mb, ccMuTxRetriesTable=ccMuTxRetriesTable, ccLoadCfgSuccess=ccLoadCfgSuccess, ccWanVpnName=ccWanVpnName, ccRapResultsApprovedChannel=ccRapResultsApprovedChannel, ccWlanAuthEapReauthenticationPeriod=ccWlanAuthEapReauthenticationPeriod, ccWlanCryptoWpaEntry=ccWlanCryptoWpaEntry, ccSubnetAccessAdvOutSrcIpLength=ccSubnetAccessAdvOutSrcIpLength, ccTrapCtrlSumStats=ccTrapCtrlSumStats, ccMuTxRetriesOctets07=ccMuTxRetriesOctets07, ccMuSigStatsSignalBest=ccMuSigStatsSignalBest, ccMuTxPktsAt18Mb=ccMuTxPktsAt18Mb, ccSubnetAccessAdvOutDestIp=ccSubnetAccessAdvOutDestIp, ccWlanEncryption=ccWlanEncryption, ccPortalCfgRadioDefaultPosChannel=ccPortalCfgRadioDefaultPosChannel, ccPortalRxOctetsAt11Mb=ccPortalRxOctetsAt11Mb, ccPortalTxPktsAt9Mb=ccPortalTxPktsAt9Mb, ccMuRxPktsAt1Mb=ccMuRxPktsAt1Mb, ccRadiusProxy=ccRadiusProxy, ccRapAuthMacFilter=ccRapAuthMacFilter, ccInfo=ccInfo, ccSubnetAccessAdvInSrcPortEnd=ccSubnetAccessAdvInSrcPortEnd, ccWlanSigStatsNoiseWorst=ccWlanSigStatsNoiseWorst, ccSumStatsWlan=ccSumStatsWlan, ccMuTxPktsAt6Mb=ccMuTxPktsAt6Mb, ccWlanCryptoWpaBcastKeyRotation=ccWlanCryptoWpaBcastKeyRotation, ccWlanSumStatsShortThroughput=ccWlanSumStatsShortThroughput, ccRapLocate=ccRapLocate, ccNtp2Port=ccNtp2Port, ccInfoCountrySelection=ccInfoCountrySelection, ccMuSigStatsNoiseSum=ccMuSigStatsNoiseSum, ccSubnetAccessAdvInDestIpLength=ccSubnetAccessAdvInDestIpLength, ccMuSigStatsTable=ccMuSigStatsTable, ccRadiusUsersPassword=ccRadiusUsersPassword, ccWanVpnKeyManualInAhSpi=ccWanVpnKeyManualInAhSpi, ccWlanRxPktsAt9Mb=ccWlanRxPktsAt9Mb, ccCertMgntSelfCertsSignedImport=ccCertMgntSelfCertsSignedImport, ccWlanRxPktsTable=ccWlanRxPktsTable, ccWanVpnKeyAutoIkeAuthPassphrase=ccWanVpnKeyAutoIkeAuthPassphrase, ccIdentfication=ccIdentfication, ccPortalTxPktsAt12Mb=ccPortalTxPktsAt12Mb, ccWlanAuthEapRadius1Server=ccWlanAuthEapRadius1Server, ccLanVlanActivated=ccLanVlanActivated, ccMuSumStatsShortPp10kNUcastPkts=ccMuSumStatsShortPp10kNUcastPkts, ccPortalTxRetriesOctets14=ccPortalTxRetriesOctets14, ccWlanRxPktsAt24Mb=ccWlanRxPktsAt24Mb, ccResetSwitch=ccResetSwitch, ccWlanTxRetriesPkts11=ccWlanTxRetriesPkts11, ccTrapCtrlSumStatsEntry=ccTrapCtrlSumStatsEntry, ccLoadFtpUsername=ccLoadFtpUsername, ccPortalRxPktsAt9Mb=ccPortalRxPktsAt9Mb, ccPortalSettingsShortPreamble=ccPortalSettingsShortPreamble, ccWlanSumStatsLongPp10kTxWithRetries=ccWlanSumStatsLongPp10kTxWithRetries, ccRapResultsApprovedIndex=ccRapResultsApprovedIndex, ccWlanSumStatsShortTotalMus=ccWlanSumStatsShortTotalMus, ccWlanSumStatsLongEntry=ccWlanSumStatsLongEntry, ccPortalTxRetriesOctets08=ccPortalTxRetriesOctets08, ccMuSumStatsLongThroughput=ccMuSumStatsLongThroughput, ccWanNatInboundName=ccWanNatInboundName, ccWlanSumStatsLongNumPkts=ccWlanSumStatsLongNumPkts, ccPortalCfgRadioDefaultReset=ccPortalCfgRadioDefaultReset, ccWlanAuthKerberosUsername=ccWlanAuthKerberosUsername, ccSnmpTrapSinkV12Entry=ccSnmpTrapSinkV12Entry, ccMuRxOctetsAt22Mb=ccMuRxOctetsAt22Mb, ccSubnetAccessAdvInRowStatus=ccSubnetAccessAdvInRowStatus, ccRapNewApprovedAp=ccRapNewApprovedAp, ccWlanCryptoWepPassKey=ccWlanCryptoWepPassKey, ccPortalRxOctetsAt24Mb=ccPortalRxOctetsAt24Mb, ccWanVpnKeyAutoIkeXauthMode=ccWanVpnKeyAutoIkeXauthMode, ccCertMgntSelfCertsReqIp=ccCertMgntSelfCertsReqIp, ccWlanCryptoWpaTable=ccWlanCryptoWpaTable, ccWlanMuAclEndingMac=ccWlanMuAclEndingMac, ccApSerialNumber=ccApSerialNumber, ccPortalSumStatsLongAvgMuSignal=ccPortalSumStatsLongAvgMuSignal, ccWlanRxOctetsAt9Mb=ccWlanRxOctetsAt9Mb, ccMuSupportedRates=ccMuSupportedRates, ccPortalTxRetriesPkts07=ccPortalTxRetriesPkts07, ccPortalTxOctetsAt1Mb=ccPortalTxOctetsAt1Mb, ccLanVlan=ccLanVlan, ccWlanSumStatsLongThroughput=ccWlanSumStatsLongThroughput, ccRadiusUsersRowStatus=ccRadiusUsersRowStatus, ccSnmpAccessControlEntry=ccSnmpAccessControlEntry, TransmitRate=TransmitRate, ccCertMgntSelfCertsReqKeyId=ccCertMgntSelfCertsReqKeyId, ccWlanTxRetriesOctetsFailed=ccWlanTxRetriesOctetsFailed, ccSysDNSRelayMode=ccSysDNSRelayMode, ccMuRxRssiSum=ccMuRxRssiSum, ccMuRxPktsAt18Mb=ccMuRxPktsAt18Mb, ccTrapCtrlRedundancyPreviousOperState=ccTrapCtrlRedundancyPreviousOperState)
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccWlanAuthEapMuQuietPeriod=ccWlanAuthEapMuQuietPeriod, ccPortalSettingsDefaultSupportedRates=ccPortalSettingsDefaultSupportedRates, ccWlanCryptoWpaPassphrase=ccWlanCryptoWpaPassphrase, ccNtpEnable=ccNtpEnable, ccWanPppoeTable=ccWanPppoeTable, ccRedundancyRevertDelay=ccRedundancyRevertDelay, ccPortalTable=ccPortalTable, ccRapPollOneMuResultsApMac=ccRapPollOneMuResultsApMac, ccSubnetAccessAdvOutIndex=ccSubnetAccessAdvOutIndex, ccWanVpnKeyManualEspEncrypAlg=ccWanVpnKeyManualEspEncrypAlg, ccWanContentBlockHttp=ccWanContentBlockHttp, ccApEntry=ccApEntry, ccMuTxRetries10=ccMuTxRetries10, ccSubnetAccessAdvInAction=ccSubnetAccessAdvInAction, ccSnmpTrapSinkV3Entry=ccSnmpTrapSinkV3Entry, ccPortalTxOctetsEntry=ccPortalTxOctetsEntry, ccMuTxPktsAt5pt5Mb=ccMuTxPktsAt5pt5Mb, ccPortalSigStatsSignalSumSquares=ccPortalSigStatsSignalSumSquares, ccTrapCtrlSumStatsCanBeSetPortal=ccTrapCtrlSumStatsCanBeSetPortal, ccCACertsSubject=ccCACertsSubject, ccPortalRxPktsAt18Mb=ccPortalRxPktsAt18Mb, ccMuSumStatsLongAvgMuSnr=ccMuSumStatsLongAvgMuSnr, ccRapResultsRogueIndex=ccRapResultsRogueIndex, ccWanVpnKeyManualOutAhAuthKey=ccWanVpnKeyManualOutAhAuthKey, ccLoadFw=ccLoadFw, ccPortalCfgRadioDefaultPlacement=ccPortalCfgRadioDefaultPlacement, ccIdSerialNumber=ccIdSerialNumber, ccWanIpAddrTable=ccWanIpAddrTable, ccRapResultsRogueHowFound=ccRapResultsRogueHowFound, ccTrapCtrlRadarDetectedPortalMac=ccTrapCtrlRadarDetectedPortalMac, ccMuIsDataReady=ccMuIsDataReady, ccPortStatusChange=ccPortStatusChange, ccWanVpnKeyAutoEntry=ccWanVpnKeyAutoEntry, ccWlanAuthEapSyslogSeverIp=ccWlanAuthEapSyslogSeverIp, ccWlanAuthEapReauthenticationMaxRetries=ccWlanAuthEapReauthenticationMaxRetries, ccMuSumStatsLongNumPkts=ccMuSumStatsLongNumPkts, ccSubnetIpSubnetMask=ccSubnetIpSubnetMask, ccMuTxRetries06=ccMuTxRetries06, ccMuTxPktsAt12Mb=ccMuTxPktsAt12Mb, ccWlanSumStatsShortEntry=ccWlanSumStatsShortEntry, ccWlanSumStatsLongThroughputTx=ccWlanSumStatsLongThroughputTx, ccPortalStatsTable=ccPortalStatsTable, ccRapPortalResultsPortalMac=ccRapPortalResultsPortalMac, ccPortalSumStatsShortPktsPerSec100=ccPortalSumStatsShortPktsPerSec100, ccSumStatsLongUpdateInterval=ccSumStatsLongUpdateInterval, ccSnmpTrapSinkV3Enable=ccSnmpTrapSinkV3Enable, ccPortalTxRetriesPktsEntry=ccPortalTxRetriesPktsEntry, ccPortal=ccPortal, ccMuTxPktsAt9Mb=ccMuTxPktsAt9Mb, ccPortalCfgRadioEntry=ccPortalCfgRadioEntry, ccCertMgntSelfCertsReqEmail=ccCertMgntSelfCertsReqEmail, ccSnmpAccessV3CustomOid=ccSnmpAccessV3CustomOid, ccNotifications=ccNotifications, ccWanIpAddrIndex=ccWanIpAddrIndex, ccWlanRxOctetsUcast=ccWlanRxOctetsUcast, ccMuTxOctetsAt48Mb=ccMuTxOctetsAt48Mb, ccWanNatInboundStartPort=ccWanNatInboundStartPort, ccAssociationGroup=ccAssociationGroup, ccMuRxOctetsAt11Mb=ccMuRxOctetsAt11Mb, PYSNMP_MODULE_ID=moduleid, ccSubnetAccessAdvInIndex=ccSubnetAccessAdvInIndex, ccGroupsV2dot0obsoleted=ccGroupsV2dot0obsoleted, ccWlanSigStatsSnrSumSquares=ccWlanSigStatsSnrSumSquares, ccPortalSumStatsShortEntry=ccPortalSumStatsShortEntry, ccPortalSystemStatsProbeRespRetries1=ccPortalSystemStatsProbeRespRetries1, ccWlanAuthEapRadius1SharedSecret=ccWlanAuthEapRadius1SharedSecret, ccCertMgntSelfCertsSignedEntry=ccCertMgntSelfCertsSignedEntry, ccPortalRxPktsEntry=ccPortalRxPktsEntry, ccSubnetAccessTable=ccSubnetAccessTable, ccMuSigStatsNoiseMostRecent=ccMuSigStatsNoiseMostRecent, ccWanContentBlockOutUrlEntry=ccWanContentBlockOutUrlEntry, ccWlanCryptoWepTable=ccWlanCryptoWepTable, ccWlanTxRetriesOctets13=ccWlanTxRetriesOctets13, ccRapPortalResults=ccRapPortalResults, ccLoadCfgServerPath=ccLoadCfgServerPath, ccSnmpAccessV12Community=ccSnmpAccessV12Community, ccMuSigStatsSnrWorst=ccMuSigStatsSnrWorst, ccDhcpOptionsFileTransferStatus=ccDhcpOptionsFileTransferStatus, ccMuRxPktsAt11Mb=ccMuRxPktsAt11Mb, ccWlanSumStatsLongTimestamp=ccWlanSumStatsLongTimestamp, ccPortalDenied=ccPortalDenied, ccRouterRip2Md5Key2AuthKey=ccRouterRip2Md5Key2AuthKey, ccPortalTxRetriesOctets13=ccPortalTxRetriesOctets13, ccCertMgntSelfCertsReqSigAlgo=ccCertMgntSelfCertsReqSigAlgo, ccRadiusLdapGroupAttribute=ccRadiusLdapGroupAttribute, ccRouterRoutesInterface=ccRouterRoutesInterface, ccPortalLastAdoption=ccPortalLastAdoption, ccPortalSumStatsLongPp10kRfUtil=ccPortalSumStatsLongPp10kRfUtil, ccWanVpnEntry=ccWanVpnEntry, ccRouterRip2AuthType=ccRouterRip2AuthType, ccIdFwVersion=ccIdFwVersion, ccLan=ccLan, ccWanVpnSaRxBytes=ccWanVpnSaRxBytes, ccPortalSumStatsShortAvgMuNoise=ccPortalSumStatsShortAvgMuNoise, ccWanPrimaryDnsServer=ccWanPrimaryDnsServer, ccPortalSystemStatsProbeReqRx=ccPortalSystemStatsProbeReqRx, ccSumStatsShortUpdateInterval=ccSumStatsShortUpdateInterval, ccSnmpAccessV3PrivacyPassword=ccSnmpAccessV3PrivacyPassword, ccMuRxPktsTable=ccMuRxPktsTable, ccMuGroup=ccMuGroup, ccPortalRxOctetsAt22Mb=ccPortalRxOctetsAt22Mb, ccRapResultsRogueEssid=ccRapResultsRogueEssid, ccWanNatOutboundIpAddr=ccWanNatOutboundIpAddr, ccWanDhcpDefaultGateway=ccWanDhcpDefaultGateway, ccMuSigStatsSignalMostRecent=ccMuSigStatsSignalMostRecent, ccSubnetEnable=ccSubnetEnable, ccPortType=ccPortType, ccPortalTxRetriesPkts15=ccPortalTxRetriesPkts15, ccWlanSumStatsLongPktsPerSecRx100=ccWlanSumStatsLongPktsPerSecRx100, ccWlanTxPktsAt24Mb=ccWlanTxPktsAt24Mb, ccWlanRxOctetsAt6Mb=ccWlanRxOctetsAt6Mb, ccWanVpnKeyManualInEspSpi=ccWanVpnKeyManualInEspSpi, ccWlanRfSum=ccWlanRfSum, ccPortalSumStatsLongTxAvgRetries100=ccPortalSumStatsLongTxAvgRetries100, ccWlanVoicePrioritization=ccWlanVoicePrioritization, ccMuTxRetries13=ccMuTxRetries13, ccCfAlmostFull=ccCfAlmostFull, ccSubnetEntry=ccSubnetEntry, cc802dt1xPortAuthSetAp300=cc802dt1xPortAuthSetAp300, ccPortalRxOctetsUcast=ccPortalRxOctetsUcast, ccMuSumStatsShortTimestamp=ccMuSumStatsShortTimestamp, ccMuRxOctetsAt36Mb=ccMuRxOctetsAt36Mb, ccWanFirewallGlobalEnable=ccWanFirewallGlobalEnable, ccApPcbRevision=ccApPcbRevision, ccPortalSumStatsShortAvgMuSignal=ccPortalSumStatsShortAvgMuSignal, ccPortalSumStatsLongPp10kTxMaxRetries=ccPortalSumStatsLongPp10kTxMaxRetries, ccMuTxRetries12=ccMuTxRetries12, ccMuRxOctetsAt1Mb=ccMuRxOctetsAt1Mb, ccPortalSystemStatsTable=ccPortalSystemStatsTable, ccWlanTxPktsAt1Mb=ccWlanTxPktsAt1Mb, ccSubnetDhcpServerEnable=ccSubnetDhcpServerEnable, ccWlanAuthEapRadius2Port=ccWlanAuthEapRadius2Port, ccPortalSystemStatsProbeRespRetries2=ccPortalSystemStatsProbeRespRetries2, ccRouterUserRoutesGateway=ccRouterUserRoutesGateway, ccPortalSumStatsLongEntry=ccPortalSumStatsLongEntry, ccAssociationCountAssociates=ccAssociationCountAssociates, ccLoadCfgResult=ccLoadCfgResult, ccPortalSettingsDetector=ccPortalSettingsDetector, ccRapAuthCopyAllApproved=ccRapAuthCopyAllApproved, ccMuTxPktsAt2Mb=ccMuTxPktsAt2Mb, ccSumStatsShortWindow=ccSumStatsShortWindow, ccRadiusProxyServerIp=ccRadiusProxyServerIp, ccWanVpn=ccWanVpn, ccWanVpnRemoteSubnetMask=ccWanVpnRemoteSubnetMask, ccWlanAuthEapRadiusAcctMuTimeout=ccWlanAuthEapRadiusAcctMuTimeout, ccPortalSumStatsLongAvgMuSnr=ccPortalSumStatsLongAvgMuSnr, ccMuTxPktsEntry=ccMuTxPktsEntry, ccWanIpAddrEntry=ccWanIpAddrEntry, ccPortalRxOctetsAt12Mb=ccPortalRxOctetsAt12Mb, ccPortalTxRetriesPktsFailed=ccPortalTxRetriesPktsFailed, ccMuSigStatsNumPkts=ccMuSigStatsNumPkts, ccRadiusLdap=ccRadiusLdap, ccSubnetAccessAdvOutAction=ccSubnetAccessAdvOutAction, ccDhcpOptionsUpdateInterface=ccDhcpOptionsUpdateInterface, ccWlanCryptoWepKey4=ccWlanCryptoWepKey4, ccPortalRxUndecryptablePkts=ccPortalRxUndecryptablePkts, ccPortalTxPktsAt6Mb=ccPortalTxPktsAt6Mb, ccMgmtAccessAdminAuth=ccMgmtAccessAdminAuth, ccSubnetAccessAdvImportRules=ccSubnetAccessAdvImportRules, ccSnmpAccessV3Access=ccSnmpAccessV3Access, ccWanPppoeUsername=ccWanPppoeUsername, ccWanFirewallEntry=ccWanFirewallEntry, ccTrapCtrlRadarDetectedChannel=ccTrapCtrlRadarDetectedChannel, ScaleBy100=ScaleBy100, ccWlanSumStatsShortAvgMuNoise=ccWlanSumStatsShortAvgMuNoise, ccSubnetDhcpServerDomainName=ccSubnetDhcpServerDomainName, ccMuLastReason=ccMuLastReason, ccWlanSigStatsSignalWorst=ccWlanSigStatsSignalWorst, ccWanVpnIkeTable=ccWanVpnIkeTable, ccSwitch=ccSwitch, ccSnmpAccessControlIndex=ccSnmpAccessControlIndex, ccSnmpTrapSinkV12Index=ccSnmpTrapSinkV12Index, ccApIndex=ccApIndex, ccPortalTxOctetsAt54Mb=ccPortalTxOctetsAt54Mb, ccPortalLastActivity=ccPortalLastActivity, ccWlanSumStatsShortTable=ccWlanSumStatsShortTable, ccPortalSettingsAntenna=ccPortalSettingsAntenna, ccRadiusAccessEntry=ccRadiusAccessEntry, ccMuTxOctetsAt5pt5Mb=ccMuTxOctetsAt5pt5Mb, ccSubnetDhcpSubnetMask=ccSubnetDhcpSubnetMask, ccTrapCtrlSumStatsCanBeSetSwitch=ccTrapCtrlSumStatsCanBeSetSwitch, ccWlanTxPktsAt48Mb=ccWlanTxPktsAt48Mb, ccRapResultsRogueAgeOut=ccRapResultsRogueAgeOut, ccIdXmlVersion=ccIdXmlVersion, ccRapPollOneMuResultsEntry=ccRapPollOneMuResultsEntry, DoActionNow=DoActionNow, moduleid=moduleid, ccPortalSystemStatsProbeRespRetriesNone=ccPortalSystemStatsProbeRespRetriesNone, ccRapOnChannelInterval=ccRapOnChannelInterval, ccMuSumStatsShortEntry=ccMuSumStatsShortEntry, ccMuSumStatsLongEntry=ccMuSumStatsLongEntry, ccPortalTxOctetsAt22Mb=ccPortalTxOctetsAt22Mb, ccCACertsDeleteRow=ccCACertsDeleteRow, ccSumStats=ccSumStats, ccWlanTxOctetsAt6Mb=ccWlanTxOctetsAt6Mb, ccRadiusUsersGroupId=ccRadiusUsersGroupId, ccPortalTxPktsAt36Mb=ccPortalTxPktsAt36Mb, ccWlanTxOctetsAt36Mb=ccWlanTxOctetsAt36Mb, ccCACertsIssuerName=ccCACertsIssuerName, ccWlanAuthKerberosKdcPortR=ccWlanAuthKerberosKdcPortR, ccRapResultsApprovedCopyToAuthTable=ccRapResultsApprovedCopyToAuthTable, ccRadiusClientAuthRowStatus=ccRadiusClientAuthRowStatus, ccMuSumStatsShortTxAvgRetries100=ccMuSumStatsShortTxAvgRetries100, ccLanVlanTable=ccLanVlanTable, ccWlanTxPktsAt54Mb=ccWlanTxPktsAt54Mb, ccAssociationEntry=ccAssociationEntry, ccPortPoeEquipped=ccPortPoeEquipped, ccSnmpTrapSinkV3AuthPassword=ccSnmpTrapSinkV3AuthPassword, ccTrapCtrlPortStatusChange=ccTrapCtrlPortStatusChange, ccWlanAuthEapMuMaxRetries=ccWlanAuthEapMuMaxRetries, ccCompactFlashCapacity=ccCompactFlashCapacity, ccPortalSumStatsShortPp10kTxMaxRetries=ccPortalSumStatsShortPp10kTxMaxRetries, ccSnmpAccessV3User=ccSnmpAccessV3User, ccWanVpnKeyManualInEspAuthKey=ccWanVpnKeyManualInEspAuthKey, ccWlanTxOctetsAt1Mb=ccWlanTxOctetsAt1Mb, ccSnmpTrapSinkV3PrivacyPassword=ccSnmpTrapSinkV3PrivacyPassword, ccCACertsKeyId=ccCACertsKeyId, ccWlanTxRetriesOctets01=ccWlanTxRetriesOctets01, ccWanSubnetMask=ccWanSubnetMask, ccWanVpnSaLifetime=ccWanVpnSaLifetime, ccPortalSettingsDefaultPriWlan=ccPortalSettingsDefaultPriWlan, ccWlanTxPktsEntry=ccWlanTxPktsEntry, ccTrapCtrlDetails=ccTrapCtrlDetails, ccWlanSumStatsShortPktsPerSec100=ccWlanSumStatsShortPktsPerSec100, ccWlanSumStatsShortPp10kRxUndecrypt=ccWlanSumStatsShortPp10kRxUndecrypt, ccWlanSumStatsLongSkip1=ccWlanSumStatsLongSkip1, ccPortalSumStatsLongAvgBitSpeed=ccPortalSumStatsLongAvgBitSpeed, ccMuTxOctetsAt9Mb=ccMuTxOctetsAt9Mb, ccWlanSumStatsShortPktsPerSecTx100=ccWlanSumStatsShortPktsPerSecTx100, ccWlanCryptoKeyguardKey1=ccWlanCryptoKeyguardKey1, ccGroups=ccGroups, ccWlanSigStatsSignalSumSquares=ccWlanSigStatsSignalSumSquares, ccSubnetDhcpServerPoolEnd=ccSubnetDhcpServerPoolEnd, ccPortalAdoptionRowStatus=ccPortalAdoptionRowStatus, ccPortalTxRetriesOctets03=ccPortalTxRetriesOctets03, ccWlanCryptoWpaTwoPassphrase=ccWlanCryptoWpaTwoPassphrase, ccWlanSumStatsLongAvgBitSpeed=ccWlanSumStatsLongAvgBitSpeed, ccPortalSumStatsShortTable=ccPortalSumStatsShortTable, ccPortalRxOctetsAt5pt5Mb=ccPortalRxOctetsAt5pt5Mb, ccRouterUserRoutesMetric=ccRouterUserRoutesMetric, ccRapPollSymbolMusEnable=ccRapPollSymbolMusEnable, ccWlanTxRetriesPkts01=ccWlanTxRetriesPkts01, ccPortalBackgroundNoiseSum=ccPortalBackgroundNoiseSum, ccWlanRxPktsAt54Mb=ccWlanRxPktsAt54Mb, ccWlanSigStatsSnrBest=ccWlanSigStatsSnrBest, ccPortalRxPktsAt5pt5Mb=ccPortalRxPktsAt5pt5Mb, ccRadiusLdapBindDistinguishedName=ccRadiusLdapBindDistinguishedName, ccPortalTxPktsAt11Mb=ccPortalTxPktsAt11Mb, ccWlanCryptoWpaTwoTable=ccWlanCryptoWpaTwoTable, ccWanVpnLocalSubnet=ccWanVpnLocalSubnet, ccWanContentBlockOutUrlRowStatus=ccWanContentBlockOutUrlRowStatus, ccWanNatOutboundSubnetIndex=ccWanNatOutboundSubnetIndex, ccPortalSumStatsLongPktsPerSecTx100=ccPortalSumStatsLongPktsPerSecTx100, ccRedundancyHeartbeatInterval=ccRedundancyHeartbeatInterval)
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccMuAssociated=ccMuAssociated, ccWlanRxOctetsNUcast=ccWlanRxOctetsNUcast, ccWanVpnRemoteSubnet=ccWanVpnRemoteSubnet, ccPortalChannel=ccPortalChannel, ccSumStatsPortal=ccSumStatsPortal, ccWanVpnRowStatus=ccWanVpnRowStatus, ccMuRxOctetsTable=ccMuRxOctetsTable, ccWlanMuAclDefault=ccWlanMuAclDefault, ccDhcpOptionsUpdateCfgFilename=ccDhcpOptionsUpdateCfgFilename, ccMgmtAccessSshAuthTimeout=ccMgmtAccessSshAuthTimeout, ccWlanRxPktsAt36Mb=ccWlanRxPktsAt36Mb, ccMuStatsEntry=ccMuStatsEntry, ccMuTxRetriesMostRecent=ccMuTxRetriesMostRecent, ccSnmpTrapSinkV12Port=ccSnmpTrapSinkV12Port, ccRouterUserRoutesDest=ccRouterUserRoutesDest, ccPortalSettingsPriWlan=ccPortalSettingsPriWlan, ccMuTxRetries08=ccMuTxRetries08, ccRouterRip2Md5Key2Id=ccRouterRip2Md5Key2Id, ccSubnetAccessAdvInReverseNatPort=ccSubnetAccessAdvInReverseNatPort, ccPortalCfgRadioDefaultDesPowerLevel=ccPortalCfgRadioDefaultDesPowerLevel, ccRouterRip2SimplePassword=ccRouterRip2SimplePassword, ccWanVpnSaTunnelName=ccWanVpnSaTunnelName, ccRadiusUsersTable=ccRadiusUsersTable, ccRapAuthEssidFilter=ccRapAuthEssidFilter, ccPortalPointersToWlans=ccPortalPointersToWlans, ccPortalTxOctetsAt9Mb=ccPortalTxOctetsAt9Mb, ccLoadCfgOperation=ccLoadCfgOperation, ccWanVpnKeyAutoEspEncrypAlg=ccWanVpnKeyAutoEspEncrypAlg, ccPortalTxRetriesPkts13=ccPortalTxRetriesPkts13, ccWanVpnTunnelConfig=ccWanVpnTunnelConfig, ccTrapCtrlPortalUnAdopted=ccTrapCtrlPortalUnAdopted, StaticRowEnable=StaticRowEnable, ccDhcpOptionsUpdateFwEna=ccDhcpOptionsUpdateFwEna, ccWlanTxPktsAt11Mb=ccWlanTxPktsAt11Mb, ccWanVpnKeyAutoEspType=ccWanVpnKeyAutoEspType, ccSubnetAccessAdvOverrideMode=ccSubnetAccessAdvOverrideMode, ccWlanLastActivity=ccWlanLastActivity, ccPortalSystemStatsProbeRespRetries3OrMore=ccPortalSystemStatsProbeRespRetries3OrMore, ccRadiusDataSource=ccRadiusDataSource, HexPassword=HexPassword, ccPortalSettingsDtimPrd=ccPortalSettingsDtimPrd, ccMuRxOctetsAt24Mb=ccMuRxOctetsAt24Mb, ccWlanMuAclStartingMac=ccWlanMuAclStartingMac, ccMuType=ccMuType, ccRadiusLdapBindDistinguishedPassword=ccRadiusLdapBindDistinguishedPassword, ccWlanAuthEapRadiusAcctMuRetries=ccWlanAuthEapRadiusAcctMuRetries, ccWlanRxOctetsAt5pt5Mb=ccWlanRxOctetsAt5pt5Mb, ccPortalSettingsTable=ccPortalSettingsTable, ccPortalSumStatsLongThroughputRx=ccPortalSumStatsLongThroughputRx, ccPortDuplex=ccPortDuplex, ccPortalSumStatsLongTable=ccPortalSumStatsLongTable, ccWanFirewallEnable=ccWanFirewallEnable, ccWlan=ccWlan, ccRadiusLdapServerPort=ccRadiusLdapServerPort, ccWanContentBlockOutUrlIndex=ccWanContentBlockOutUrlIndex, Password=Password, ccWlanCryptoWpaTwoKeyRotationInterval=ccWlanCryptoWpaTwoKeyRotationInterval, ccRapPollOneMuResultsRssi=ccRapPollOneMuResultsRssi, ccSnmpAclViolation=ccSnmpAclViolation, ccTrapCtrlConfigChange=ccTrapCtrlConfigChange, MultiPointer255=MultiPointer255, ccRapResultsApprovedHowAuth=ccRapResultsApprovedHowAuth, ccPortalCfgRadioDesPowerInMW=ccPortalCfgRadioDesPowerInMW, ccPortalBackgroundNoiseNumSamples=ccPortalBackgroundNoiseNumSamples, ccNtp0Port=ccNtp0Port, ccWlanAnswerBroadcastEss=ccWlanAnswerBroadcastEss, ccMuRxOctetsAt5pt5Mb=ccMuRxOctetsAt5pt5Mb, ccCertMgntSelfCertsReqIndex=ccCertMgntSelfCertsReqIndex, ccSnmpAccessV12Index=ccSnmpAccessV12Index, ccMuSumStatsLongThroughputRx=ccMuSumStatsLongThroughputRx, ccApSshv1Mode=ccApSshv1Mode, ccPortalSystemStatsEntry=ccPortalSystemStatsEntry, ccPortStatus=ccPortStatus, ccMuRxOctetsAt6Mb=ccMuRxOctetsAt6Mb, ccMuTxOctetsAt11Mb=ccMuTxOctetsAt11Mb, ccWanNatIndex=ccWanNatIndex, ccWanNatInboundDefaultEna=ccWanNatInboundDefaultEna, ws2000=ws2000, ccSubnetAccessAdvInEntry=ccSubnetAccessAdvInEntry, ccWlanRxOctetsAt2Mb=ccWlanRxOctetsAt2Mb, ccAp=ccAp, ccPortalRfSum=ccPortalRfSum, ccWlanMuAclEntry=ccWlanMuAclEntry, ccWlanAuthEapRadius2Server=ccWlanAuthEapRadius2Server, ccPortalTxPktsUcast=ccPortalTxPktsUcast, ccPortalSumStatsShortThroughputRx=ccPortalSumStatsShortThroughputRx, ccWanVpnSaInSpi=ccWanVpnSaInSpi, ccWanVpnKeyAutoIkeKeyLifetime=ccWanVpnKeyAutoIkeKeyLifetime, ccSnmpTrapSinkV3Username=ccSnmpTrapSinkV3Username, ccNtpGmtMinuteOffset=ccNtpGmtMinuteOffset, ccWlanRxOctetsAt22Mb=ccWlanRxOctetsAt22Mb, ccWlanRxPktsUcast=ccWlanRxPktsUcast, ccMuTxRetriesOctets09=ccMuTxRetriesOctets09, ccAssociation=ccAssociation, ccSumStatsSwitch=ccSumStatsSwitch, ccSnmpTrapSinkV3DestinationIp=ccSnmpTrapSinkV3DestinationIp, ccTrapCtrlEnableName=ccTrapCtrlEnableName, ccWlanSigStatsSnrSum=ccWlanSigStatsSnrSum, ccWlanRxPktsNUcast=ccWlanRxPktsNUcast, ccWlanCryptoKeyguardKeyToUse=ccWlanCryptoKeyguardKeyToUse, ccWlanRxOctetsAt54Mb=ccWlanRxOctetsAt54Mb, ccWlanCryptoWepEntry=ccWlanCryptoWepEntry, ccMgmtAccessAdminAuthRadiusSharedSecret=ccMgmtAccessAdminAuthRadiusSharedSecret, ccWlanSigStatsSignalBest=ccWlanSigStatsSignalBest, ccSubnetAccessAdvInSrcIp=ccSubnetAccessAdvInSrcIp, ccWanDhcpSecondaryDnsServer=ccWanDhcpSecondaryDnsServer, ccResetFactory=ccResetFactory, ccWlanAuthEapReauthenticationEnable=ccWlanAuthEapReauthenticationEnable, ccTrapCtrlSumStatsSwitch=ccTrapCtrlSumStatsSwitch, ccRadiusAccessTable=ccRadiusAccessTable, ccSubnetAccessRuleIndex=ccSubnetAccessRuleIndex, ccWlanRxPktsEntry=ccWlanRxPktsEntry, ccMgmtAccessToAllow=ccMgmtAccessToAllow, ccWlanTxOctetsAt18Mb=ccWlanTxOctetsAt18Mb, ccWanFirewallDescription=ccWanFirewallDescription, ccWanFirewall=ccWanFirewall, ccSnmpV3EngineId=ccSnmpV3EngineId, ccMuSumStatsShortAvgMuSnr=ccMuSumStatsShortAvgMuSnr, ccMuSumStatsShortAvgMuNoise=ccMuSumStatsShortAvgMuNoise, ccWlanTxPktsAt5pt5Mb=ccWlanTxPktsAt5pt5Mb, ccCACertsImport=ccCACertsImport, ccPortalTxOctetsAt5pt5Mb=ccPortalTxOctetsAt5pt5Mb, ccWanVpnKeyAutoIkeAuthAlg=ccWanVpnKeyAutoIkeAuthAlg, ccPortalRxPktsAt24Mb=ccPortalRxPktsAt24Mb, ccPortalSystemStatsProbeRespTxOctets=ccPortalSystemStatsProbeRespTxOctets, ccCertMgntSelfCertsSignedKeyId=ccCertMgntSelfCertsSignedKeyId, ccWanVpnKeyAutoIkeXauthPassword=ccWanVpnKeyAutoIkeXauthPassword, ccPortalTxOctetsUcast=ccPortalTxOctetsUcast, ccRap=ccRap, ccRadiusProxyServerEntry=ccRadiusProxyServerEntry, ccMgmtAccessAirbeam=ccMgmtAccessAirbeam, ccWlanRxOctetsAt12Mb=ccWlanRxOctetsAt12Mb, ccMuEncryptionMethod=ccMuEncryptionMethod, ccWanVpnKeyAutoIkeEncrypAlg=ccWanVpnKeyAutoIkeEncrypAlg, ccWlanSumStatsLongTable=ccWlanSumStatsLongTable, ccIdCliVersion=ccIdCliVersion, ccPortalSigStatsNoiseSumSquares=ccPortalSigStatsNoiseSumSquares, ccMuSigStatsSnrSum=ccMuSigStatsSnrSum, ccPortalTxPktsAt18Mb=ccPortalTxPktsAt18Mb, ccLanVlanTrunkPort=ccLanVlanTrunkPort, ccWanVpnKeyManualAhAuth=ccWanVpnKeyManualAhAuth, ccWanVpnKeyAutoIkeXauthUsername=ccWanVpnKeyAutoIkeXauthUsername, ccApWispVersion=ccApWispVersion, ccPortalBackgroundNoiseWorst=ccPortalBackgroundNoiseWorst, ccMuRxOctetsAt2Mb=ccMuRxOctetsAt2Mb, ccWlanSumStatsShortSkip1=ccWlanSumStatsShortSkip1, ccWlanMulticastAddr1=ccWlanMulticastAddr1, cc802dt1xPortAuth=cc802dt1xPortAuth, ccWlanSumStatsLongAvgMuSignal=ccWlanSumStatsLongAvgMuSignal, ccResetFactoryExceptIpSnmp=ccResetFactoryExceptIpSnmp, ccWanVpnKeyAutoIkeOperationMode=ccWanVpnKeyAutoIkeOperationMode, ccWanNatEntry=ccWanNatEntry, ccRouter=ccRouter, ccTrapCtrlSumStatsCanBeSetMu=ccTrapCtrlSumStatsCanBeSetMu, ccSubnetDhcpServerStaticMapTable=ccSubnetDhcpServerStaticMapTable, ws2k=ws2k, AbbrevRowStatus=AbbrevRowStatus, ccSubnetAccessAdvInTransport=ccSubnetAccessAdvInTransport, ccWlanTable=ccWlanTable, ccRapPortalResultsTable=ccRapPortalResultsTable, ccPortalSettingsLocation=ccPortalSettingsLocation, ccMuRfSum=ccMuRfSum, ccPortalSettingsDefaultBGMode=ccPortalSettingsDefaultBGMode, ccMuSumStatsShortPp10kTxWithRetries=ccMuSumStatsShortPp10kTxWithRetries, ccWlanAuthKerberosTable=ccWlanAuthKerberosTable, ccWlanDisallowMuToMu=ccWlanDisallowMuToMu, ccWanDhcpPrimaryDnsServer=ccWanDhcpPrimaryDnsServer, ccWanContentBlockOutUrlExtension=ccWanContentBlockOutUrlExtension, ccWlanSumStatsShortNumPkts=ccWlanSumStatsShortNumPkts, ccIdSwVersion=ccIdSwVersion, ccRapResultsApprovedApMac=ccRapResultsApprovedApMac, ccGroupsV1dot0=ccGroupsV1dot0, ccTrapCtrlFirewallUnderAttackRateLimit=ccTrapCtrlFirewallUnderAttackRateLimit, ccMuSumStatsLongAvgBitSpeed=ccMuSumStatsLongAvgBitSpeed, ccWlanSumStatsLongPp10kNUcastPkts=ccWlanSumStatsLongPp10kNUcastPkts, ccWlanSumStatsShortAvgBitSpeed=ccWlanSumStatsShortAvgBitSpeed, ccRapNewRogueAp=ccRapNewRogueAp, ccPortalSigStatsNumPkts=ccPortalSigStatsNumPkts, ccMuRxRssiMostRecent=ccMuRxRssiMostRecent, ccTrapCtrlEnableTable=ccTrapCtrlEnableTable, ccRapAuthEntry=ccRapAuthEntry, ccPortalRxPktsAt12Mb=ccPortalRxPktsAt12Mb, ccRouterRip2Md5Key1AuthKey=ccRouterRip2Md5Key1AuthKey, ccCfgHistSemaphore=ccCfgHistSemaphore, ccPortalSigStatsNoiseBest=ccPortalSigStatsNoiseBest, ccWlanTxOctetsEntry=ccWlanTxOctetsEntry, ccRapResultsApprovedHowFound=ccRapResultsApprovedHowFound, ccRadiusProxyServerIndex=ccRadiusProxyServerIndex, ccMuWlanIndex=ccMuWlanIndex, ccSubnetAccessAdvOutTable=ccSubnetAccessAdvOutTable, ccPortalSigStatsSnrSum=ccPortalSigStatsSnrSum, ccWlanAuthEapRadius1Port=ccWlanAuthEapRadius1Port, ccMuSumStatsShortPktsPerSecRx100=ccMuSumStatsShortPktsPerSecRx100, ccMuSumStatsLongAvgMuSignal=ccMuSumStatsLongAvgMuSignal, ccMuSumStatsLongPktsPerSec100=ccMuSumStatsLongPktsPerSec100, ccWanIpAddrEnable=ccWanIpAddrEnable, ccMuRxPktsAt36Mb=ccMuRxPktsAt36Mb, ccRadiusAuthTypeTtls=ccRadiusAuthTypeTtls, ccSnmp=ccSnmp, ccApSslWeakCipherSupport=ccApSslWeakCipherSupport, ccTrapCtrlSumStatsDescr=ccTrapCtrlSumStatsDescr, ccWanNatLowestUnusedSlot=ccWanNatLowestUnusedSlot, ccRadiusClientAuthEntry=ccRadiusClientAuthEntry, ccWlanCryptoWpaTwoAllowTkipClient=ccWlanCryptoWpaTwoAllowTkipClient, ccPort=ccPort, ccWlanName=ccWlanName, ccWanNatOutboundPossibleIpAddr=ccWanNatOutboundPossibleIpAddr, ccPortalTxRetriesOctetsNone=ccPortalTxRetriesOctetsNone, ccMuVlanId=ccMuVlanId, ccCertMgntSelfCerts=ccCertMgntSelfCerts, ccMuSumStatsLongPktsPerSecRx100=ccMuSumStatsLongPktsPerSecRx100, ccCertMgntSelfCertsReqCity=ccCertMgntSelfCertsReqCity, ccPortalSigStatsNoiseMostRecent=ccPortalSigStatsNoiseMostRecent, DateAndTime=DateAndTime, ccGroupsV1dot5notifications=ccGroupsV1dot5notifications, ccSnmpAccessControlTable=ccSnmpAccessControlTable, ccMuRxOctetsAt54Mb=ccMuRxOctetsAt54Mb, ccWanVpnIkeTunnelName=ccWanVpnIkeTunnelName, ccMuSigStatsSnrBest=ccMuSigStatsSnrBest, cc802dt1xPortAuthLogin=cc802dt1xPortAuthLogin, ccCertMgntSelfCertsSignedDeleteRow=ccCertMgntSelfCertsSignedDeleteRow, ccRadiusAccessWlanPtrs=ccRadiusAccessWlanPtrs, ccWlanCryptoKeyguardEntry=ccWlanCryptoKeyguardEntry, ccWlanAuthKerberosKdcServerIpR=ccWlanAuthKerberosKdcServerIpR, ccPortalTxOctetsAt36Mb=ccPortalTxOctetsAt36Mb, ccWanVpnKeyManualEspType=ccWanVpnKeyManualEspType, ccCertMgntSelfCertsIdName=ccCertMgntSelfCertsIdName, ccSubnetAccessDestIndex=ccSubnetAccessDestIndex, ccPortalTxOctetsAt6Mb=ccPortalTxOctetsAt6Mb, ccPortalSumStatsLongTimestamp=ccPortalSumStatsLongTimestamp, ccSubnetDhcpServerStaticMapEnable=ccSubnetDhcpServerStaticMapEnable, ccRapResultsApprovedPortalPtr=ccRapResultsApprovedPortalPtr, ccPortalIndex=ccPortalIndex, ccWanVpnKeyAutoIkeAuthType=ccWanVpnKeyAutoIkeAuthType, ccPortalRxOctetsAt18Mb=ccPortalRxOctetsAt18Mb, ccRouterUserRoutesRowStatus=ccRouterUserRoutesRowStatus, ccLanVlanId=ccLanVlanId, ccWanNatTable=ccWanNatTable, ccMuRxOctetsEntry=ccMuRxOctetsEntry, ccTrapCtrlEnableIndex=ccTrapCtrlEnableIndex, ccMuLastPortal=ccMuLastPortal, ccPortalSumStatsLongPktsPerSec100=ccPortalSumStatsLongPktsPerSec100, ccPortalAdoptionEndMac=ccPortalAdoptionEndMac, ccPortalAdopted=ccPortalAdopted, ccPortalState=ccPortalState, ccSubnetDhcpServerTable=ccSubnetDhcpServerTable, ccLoadFtpPassword=ccLoadFtpPassword, ccRadiusLdapGroupMembershipAttribute=ccRadiusLdapGroupMembershipAttribute, ccWlanSigStatsNoiseSum=ccWlanSigStatsNoiseSum, ccNtp1Port=ccNtp1Port, ccRapOnChannelEnable=ccRapOnChannelEnable, ccMuRadioType=ccMuRadioType, ccMuTxRetries01=ccMuTxRetries01, ccRouterRoutesDestMask=ccRouterRoutesDestMask)
mibBuilder.exportSymbols("SYMBOL-CC-WS2000-MIB", ccWanNatInboundTranslationPort=ccWanNatInboundTranslationPort, ccSubnetDhcpServerLeaseTime=ccSubnetDhcpServerLeaseTime, ccMuTxPktsAt1Mb=ccMuTxPktsAt1Mb, ccPortalTxRetriesPkts10=ccPortalTxRetriesPkts10, ccPortalTxOctetsAt48Mb=ccPortalTxOctetsAt48Mb, ccSubnetAccessAdvOutSrcPortEnd=ccSubnetAccessAdvOutSrcPortEnd, ccWanFirewallMimeFloodMaxHeaderLength=ccWanFirewallMimeFloodMaxHeaderLength, ccWanVpnSaEntry=ccWanVpnSaEntry, ccRapAuthTable=ccRapAuthTable, ccSubnetDhcpServerEntry=ccSubnetDhcpServerEntry, ccCertMgntSelfCertsReqKeyLen=ccCertMgntSelfCertsReqKeyLen, ccWlanAuthKerberosKdcPort1=ccWlanAuthKerberosKdcPort1, ccWlanTxRetriesPkts10=ccWlanTxRetriesPkts10, ccMuPortalMac=ccMuPortalMac, ccTrapCtrlSumStatsMinPktsForTrap=ccTrapCtrlSumStatsMinPktsForTrap, ccWanVpnKeyManualOutEspAuthKey=ccWanVpnKeyManualOutEspAuthKey, ccSubnetDhcpServerSecondaryDns=ccSubnetDhcpServerSecondaryDns, ccPortalTxPktsAt54Mb=ccPortalTxPktsAt54Mb, ccRapResultsRogue=ccRapResultsRogue, ccWlanRxOctetsEntry=ccWlanRxOctetsEntry, ccSubnetAccessAdvOutTransport=ccSubnetAccessAdvOutTransport, ccSubnetAccessRuleSrcPtr=ccSubnetAccessRuleSrcPtr, ccGroupsV1dot5=ccGroupsV1dot5, ccWlanTxRetriesPkts03=ccWlanTxRetriesPkts03, ccPortIndex=ccPortIndex, ccPortalTxPktsEntry=ccPortalTxPktsEntry, ccMuRxRssiSumSquares=ccMuRxRssiSumSquares, ccMuTxPktsAt48Mb=ccMuTxPktsAt48Mb, ccWlanSigStatsEntry=ccWlanSigStatsEntry, ccWanFirewallAlwaysEnabled=ccWanFirewallAlwaysEnabled, ccTrapCtrlCfAlmostFull=ccTrapCtrlCfAlmostFull, ccTrapCtrlPortalDenied=ccTrapCtrlPortalDenied, ccTrapCtrlRadarDetected=ccTrapCtrlRadarDetected, ccLoadCfgOperationsDone=ccLoadCfgOperationsDone, ccWanVpnIkeEntry=ccWanVpnIkeEntry, ccWanNatInboundEndPort=ccWanNatInboundEndPort, ccRapResultsRogueTable=ccRapResultsRogueTable, ccWlanCryptoWpaTwoEntry=ccWlanCryptoWpaTwoEntry, ccWanPppoeAuthType=ccWanPppoeAuthType, ccPortalTxRetriesOctets05=ccPortalTxRetriesOctets05, ccPortalSumStatsLongPp10kTxWithRetries=ccPortalSumStatsLongPp10kTxWithRetries, ccLoadServerIpAddr=ccLoadServerIpAddr, ccSumStatsLongWindow=ccSumStatsLongWindow, ccWlanRxPktsAt22Mb=ccWlanRxPktsAt22Mb, ccNtp=ccNtp, ccWlanAuthEapEntry=ccWlanAuthEapEntry, ccWlanTxRetriesPkts12=ccWlanTxRetriesPkts12, ccPortalSettingsDefaultBasicRates=ccPortalSettingsDefaultBasicRates, ccWlanTxPktsAt12Mb=ccWlanTxPktsAt12Mb, ccWanNatInboundTable=ccWanNatInboundTable, ccWanVpnKeyAutoIkeLocalIdType=ccWanVpnKeyAutoIkeLocalIdType, ccMuPowerMode=ccMuPowerMode, ccSnmpAccessV3OidLimit=ccSnmpAccessV3OidLimit, ccTrapCtrlSumStatsThresholdMu=ccTrapCtrlSumStatsThresholdMu, ccRapAuthCopyAllRogue=ccRapAuthCopyAllRogue, ccWlanTxOctetsTable=ccWlanTxOctetsTable, ccSnmpAccessControlEnable=ccSnmpAccessControlEnable, ccRapControlDetectors=ccRapControlDetectors, ccPortalCfgRadioPlacement=ccPortalCfgRadioPlacement, ccWlanAuthEapMuTimeout=ccWlanAuthEapMuTimeout, ccPortalCfgRadioDefaultPosPowerLevel=ccPortalCfgRadioDefaultPosPowerLevel, ccRouterUserRoutesTable=ccRouterUserRoutesTable, ccPortalTxPktsAt24Mb=ccPortalTxPktsAt24Mb, ccPortalSystemStatsBeaconsTx=ccPortalSystemStatsBeaconsTx, SinglePointer=SinglePointer, ccMuTxOctetsEntry=ccMuTxOctetsEntry, ccAdminGroup=ccAdminGroup, ccWanDhcpEnable=ccWanDhcpEnable, ccPortalSigStatsSignalWorst=ccPortalSigStatsSignalWorst, ccLoggingLevel=ccLoggingLevel, ccRadiusLdapPasswordAttribute=ccRadiusLdapPasswordAttribute, ccMuRxUndecryptablePkts=ccMuRxUndecryptablePkts, ccPortalCfgRadioPowerLevel=ccPortalCfgRadioPowerLevel, ccWlanEssid=ccWlanEssid, ccSnmpAccess=ccSnmpAccess, ccSnmpTrapSinkV12Table=ccSnmpTrapSinkV12Table, ccWlanRxOctetsAt18Mb=ccWlanRxOctetsAt18Mb, ccPortalPointerToAp=ccPortalPointerToAp, sysoids=sysoids, ccRapResultsRogueCopyToAuthTable=ccRapResultsRogueCopyToAuthTable, ccWlanSubnet=ccWlanSubnet, ccWlanAuthKerberosKdcServerIp1=ccWlanAuthKerberosKdcServerIp1, ccRadiusClientAuthTable=ccRadiusClientAuthTable, ccWlanMuAclRowStatus=ccWlanMuAclRowStatus, ccPortalSettingsSupportedRates=ccPortalSettingsSupportedRates, ccRapResultsApprovedFirstHeard=ccRapResultsApprovedFirstHeard, ccWlanSigStatsNumPkts=ccWlanSigStatsNumPkts, ccMuTxRetriesOctets14=ccMuTxRetriesOctets14, ccPortalTxPktsTable=ccPortalTxPktsTable, ccCertMgntSelfCertsReqEntry=ccCertMgntSelfCertsReqEntry, ccRouterRip=ccRouterRip, ccWanPppoeKeepAlive=ccWanPppoeKeepAlive, ccPortalTxRetriesOctets01=ccPortalTxRetriesOctets01, ccLanVlanType=ccLanVlanType, ccRapPortalResultsApEssid=ccRapPortalResultsApEssid, ccWanNatOutboundTable=ccWanNatOutboundTable, ccPortalTxOctetsAt18Mb=ccPortalTxOctetsAt18Mb, ccLoadFwServerFilename=ccLoadFwServerFilename, ccWlanQosMonitorEntry=ccWlanQosMonitorEntry, ccPortalSettingsDefaultShortPreamble=ccPortalSettingsDefaultShortPreamble, ccTrapCtrlRedundancyStateChange=ccTrapCtrlRedundancyStateChange, ccRouterRip2=ccRouterRip2, ccWlanCryptoWepKeyToUse=ccWlanCryptoWepKeyToUse, ccWlanAuthKerberosKdcPort2=ccWlanAuthKerberosKdcPort2, ccApSslv2Mode=ccApSslv2Mode, ccWlanCryptoWpaKeyToUse=ccWlanCryptoWpaKeyToUse, ccWlanCryptoKeyguardPasskey=ccWlanCryptoKeyguardPasskey, ccRapAuth=ccRapAuth, ccRadiusProxyServerSharedSecret=ccRadiusProxyServerSharedSecret, ccRapPortalResultsApMac=ccRapPortalResultsApMac, ccMuRxOctetsAt12Mb=ccMuRxOctetsAt12Mb, ccPortalSumStatsShortPp10kRfUtil=ccPortalSumStatsShortPp10kRfUtil, ccMuUnAssociated=ccMuUnAssociated, ccMuLastMac=ccMuLastMac, ccSubnetAccessAdvInDestPortStart=ccSubnetAccessAdvInDestPortStart, ccCertMgntSelfCertsSignedSerialNumber=ccCertMgntSelfCertsSignedSerialNumber, ccWanVpnKeyExchange=ccWanVpnKeyExchange, ccPortalRxOctetsTable=ccPortalRxOctetsTable, ccWlanTxRetriesOctets14=ccWlanTxRetriesOctets14, ccMuRxPktsAt54Mb=ccMuRxPktsAt54Mb, ccGroupsV1dot5obsoleted=ccGroupsV1dot5obsoleted, ccPortalRxPktsAt36Mb=ccPortalRxPktsAt36Mb, ccMus=ccMus, ccFirewallUnderAttack=ccFirewallUnderAttack, ccCertMgntSelfCertsSignedSubject=ccCertMgntSelfCertsSignedSubject, ccPortalTxRetriesOctetsEntry=ccPortalTxRetriesOctetsEntry, ccRouterRoutesTable=ccRouterRoutesTable, ccRapResultsRogueLastHeard=ccRapResultsRogueLastHeard, ccSubnetAccessRuleEndPort=ccSubnetAccessRuleEndPort, ccPortalTxRetriesOctets15=ccPortalTxRetriesOctets15, ccWlanTxRetriesPkts07=ccWlanTxRetriesPkts07, ccPortalEntry=ccPortalEntry, ccRadiusUsersId=ccRadiusUsersId, ccWlanCryptoKeyguardKey2=ccWlanCryptoKeyguardKey2, ccSnmpTrapSinkV3Port=ccSnmpTrapSinkV3Port, ccMuSigStatsEntry=ccMuSigStatsEntry, ccMuSumStatsShortPp10kDropped=ccMuSumStatsShortPp10kDropped, ccSubnetAccessDestPtrToDest=ccSubnetAccessDestPtrToDest, ccRapResultsRogueApMac=ccRapResultsRogueApMac, ccPortalTxRetriesOctets11=ccPortalTxRetriesOctets11, ccCertMgntSelfCertsReqPostal=ccCertMgntSelfCertsReqPostal, ccWlanRxOctetsAt11Mb=ccWlanRxOctetsAt11Mb, ccWanNatOutboundEntry=ccWanNatOutboundEntry, ccPortalTxRetriesPktsNone=ccPortalTxRetriesPktsNone, ccPortalRxOctetsAt2Mb=ccPortalRxOctetsAt2Mb, ccWlanTxOctetsAt22Mb=ccWlanTxOctetsAt22Mb, ccMuTxRetriesOctets15=ccMuTxRetriesOctets15, ccMgmtAccessAirbeamAllow=ccMgmtAccessAirbeamAllow, ccWanNatInboundIpAddr=ccWanNatInboundIpAddr, ccApModelNumber=ccApModelNumber, ccMuSigStatsSignalWorst=ccMuSigStatsSignalWorst, ccWlanSumStatsShortPktsPerSecRx100=ccWlanSumStatsShortPktsPerSecRx100, ccRadiusClientAuthMask=ccRadiusClientAuthMask, ccSubnetName=ccSubnetName, ccPortalBackgroundNoiseSumSquares=ccPortalBackgroundNoiseSumSquares, ccMuSigStatsNoiseBest=ccMuSigStatsNoiseBest, ccWlanAuthEapTable=ccWlanAuthEapTable, ccTrapCtrlCfAlmostFullThreshold=ccTrapCtrlCfAlmostFullThreshold, ccWanVpnKeyAutoEspAuthAlg=ccWanVpnKeyAutoEspAuthAlg, ccPortalAdoptionStartMac=ccPortalAdoptionStartMac, ccWlanBwShareMode=ccWlanBwShareMode, ccPortalLastReason=ccPortalLastReason, ccRapPollOneMuMac=ccRapPollOneMuMac, ccRadius=ccRadius, ccSnmpAccessV12Table=ccSnmpAccessV12Table, ccPortalSumStatsLongAvgMuNoise=ccPortalSumStatsLongAvgMuNoise, ccMuStatsTable=ccMuStatsTable, ccSnmpAccessV12Entry=ccSnmpAccessV12Entry, ccSubnetAccessAdvOutReverseNat=ccSubnetAccessAdvOutReverseNat, ccPortalCfgRadioDefaultEntry=ccPortalCfgRadioDefaultEntry, ccPortalSigStatsNoiseSum=ccPortalSigStatsNoiseSum, ccPortalTxRetriesOctets07=ccPortalTxRetriesOctets07, ccWlanTxRetriesPkts08=ccWlanTxRetriesPkts08, ccSubnetAccessAdvOutDestPortStart=ccSubnetAccessAdvOutDestPortStart, ccRedundancy=ccRedundancy, ccWanNat=ccWanNat, ccRadiusClientAuthIndex=ccRadiusClientAuthIndex, ccWlanSumStatsLongPp10kDropped=ccWlanSumStatsLongPp10kDropped, ccMuSumStatsShortAvgBitSpeed=ccMuSumStatsShortAvgBitSpeed, ccWanFirewallTable=ccWanFirewallTable)

#
# PySNMP MIB module LAN-EMULATION-ELAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LAN-EMULATION-ELAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:47:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
LecDataFrameFormat, atmfLanEmulation, VpiInteger, LecDataFrameSize, VciInteger = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "LecDataFrameFormat", "atmfLanEmulation", "VpiInteger", "LecDataFrameSize", "VciInteger")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, MibIdentifier, Gauge32, Counter64, iso, ObjectIdentity, Counter32, TimeTicks, NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibIdentifier", "Gauge32", "Counter64", "iso", "ObjectIdentity", "Counter32", "TimeTicks", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ModuleIdentity", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
elanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2))
class Integer(Integer32):
    pass

class RowStatus(Integer32):
    pass

class AutonomousType(ObjectIdentifier):
    pass

class TIMESTAMP(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class AtmLaneAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class IfIndexOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class ElanLocalIndex(Integer32):
    pass

class AtmLaneMask(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class TlvSelectorIndexType(Integer32):
    pass

class PolicySelectorIndexType(Integer32):
    pass

class LecsErrLogIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

elanAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1))
elanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2))
elanLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3))
elanLecsConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1))
elanLecsFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2))
elanLecsStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3))
elanAdminPolicyVal = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1))
byAtmAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 1))
byMacAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 2))
byRouteDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 3))
byLanType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 4))
byPktSize = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 5))
byElanName = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 6))
elanConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elanConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfNextId.setDescription('The next available ELAN index provided by the agent. The value of this object can be used as the index to the elanConfTable during creation.')
elanConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2), )
if mibBuilder.loadTexts: elanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTable.setDescription('This table contains all Emulated LANs (ELANs) this agent manages. An ELAN is defined by the ELAN name, a set of TLVs, and other parameters. After an ELAN is created, members of the ELAN such as the LAN Emulation Server (LES) or Client (LEC) can be added to this ELAN entry in their repective tables. There are four memebers to an ELAN and they are LECS, LES, BUS (Broadcast and Unknown Server ) and LEC. The support of LECS is optional. The addition and deletion of LECS is done in the elanLecsConfGroup defined in this MIB. The addition and deletion of the LEC are done in the LEC Assignment tables defined in this ELAN Configuration group. The addition and deletion of the LES are also defined in this group. The addition and deletion of the BUS are done in the LES MIB due to the fact that LEC learns the BUS address only from the LES it corresponds to.')
elanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"))
if mibBuilder.loadTexts: elanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfEntry.setDescription('Each entry in this table represents an Emulated LAN. Objects elanConfIndex and elanConfRowStatus are required during row creation and deletion. ')
elanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 1), ElanLocalIndex())
if mibBuilder.loadTexts: elanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfIndex.setDescription('A value which uniquely identifies a conceptual row in the elanConfTable. If the conceptual row identified by this value of elanConfIndex is recreated following an agent restart, the same value of elanConfIndex must be used to identify the recreated row.')
elanConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfName.setReference('LAN Emulation Over ATM Specification - version 1.0. C5.')
if mibBuilder.loadTexts: elanConfName.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfName.setDescription('The name of this Emulated LAN entry. When this object length is zero then the ELAN name is not specified. The clients assigned to this ELAN will also have a zero length string as the ELAN name. The value of this object is used in the LE CONFIGURE response by the LECS if supported. Note that ELAN name may be used as cross reference to the LES MIB and BUS MIB though not required. Multiple ELANs with no ELAN name specified will cause conflicts in reference to LES and BUS MIBs.')
elanConfTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 3), TlvSelectorIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTlvIndex.setDescription('The value of this object identifies one or more rows in the lecsTlvTable which applies to this ELAN. This object is set to zero if 1) LECS is not supported. or 2) there is no TLV associated with this entry.')
elanConfLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 4), LecDataFrameFormat().clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfLanType.setReference('LAN Emulation Over ATM Specification - version 1.0. S2.')
if mibBuilder.loadTexts: elanConfLanType.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfLanType.setDescription('The LAN type of this ELAN entry.')
elanConfMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 5), LecDataFrameSize().clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfMaxFrameSize.setReference('LAN Emulation Over ATM Specification - version 1.0. S3.')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setDescription('The maximum data frame size of this ELAN entry. The maximum AAL-5 SDU size of a data frame that this ELAN can support. The value of this object is returned to the LEC in the LE CONFIGURE response.')
elanConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
elanLesTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3), )
if mibBuilder.loadTexts: elanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesTable.setDescription('This table contains all LESs for each ELAN specified in the elanConfTable. Each ELAN can have more than one LES providing LAN Emulation services. Each LES can service only one ELAN. The table is indexed by the elanConfIndex which points to the ELAN this LES is providing service to, and elanLesIndex which unquely identifies a LES. This table is used for configuration of an ELAN only, that is, creating a LES in this table does not instantiate a LES in the network. It is done in the LES MIB.')
elanLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"))
if mibBuilder.loadTexts: elanLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesEntry.setDescription('Each entry in this table represents a LES/Emulated LAN pair. Object elanLesAtmAddress besides elanLesRowStatus is also required during row creation.')
elanLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: elanLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesIndex.setDescription('An arbitrary number which uniquely identifies the LES this entry pertains to.')
elanLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesAtmAddress.setDescription('The ATM address of the LES entry. If LECS is supported, the value of this object is the LES ATM address LECS returns to the LEC in the CONFIGURE response. If LECS is not supported, the value of this object pertains to the LES ATM address network manager provides to the LEC.')
elanLesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesRowStatus.setDescription('This object is used to create or delete entries in the elanLesfTable.')
elanPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4), )
if mibBuilder.loadTexts: elanPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyTable.setDescription("This table contains all policies this agent supports for assigning a LEC to an ELAN. A set of policies with the same or different priorities can be selected by the entity which provides ELAN configuration service such as the LECS. The policy with the highest priority or with the smallest elanPolicyPriority , is evaluated first. The policies with the same elanPolicyPriority are evaluated at the same time with the AND operation. When LECS receives a configure request, it checks it's policies selected from this table to determine which ELAN and LES the LEC will join. This table is indexed by a selector index and a policy index. The policy index unquely identifies a policy and the selector index allows multiple policies be selected by one LECS or an entity that is providing ELAN configuration service.")
elanPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanPolicySelectorIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanPolicyIndex"))
if mibBuilder.loadTexts: elanPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyEntry.setDescription('Each entry in this table represents a policy supported by the entity which provides ELAN configuration services. Each policy can be used to evaluate the CONFIGURE request from the LEC in determining which ELAN it belongs to. ')
elanPolicySelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 1), PolicySelectorIndexType())
if mibBuilder.loadTexts: elanPolicySelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicySelectorIndex.setDescription('The value of this object indicates a group of policies that can be selected by the ELAN configuration service provider such as the LECS.')
elanPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000)))
if mibBuilder.loadTexts: elanPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyIndex.setDescription('The value of this object uniquely identifies a single policy entry in this table. ')
elanPolicyPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyPriority.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyPriority.setDescription('The priority of this policy entry. Policies are evaluated by the entity which provides ELAN configuration service (LECS) by their priorities. Policies with the same priority values should be evludated at the same time with an AND operation. That is, if one of the policy with the same priority is not met, the evluation should fail. The value 1 has the highest priority. ')
elanPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 4), AutonomousType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyType.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyType.setDescription(' The value of this object must reference a definition of a type of policy. Some of such definition exist within the elanAdminPolicyVal subtree. Others may be defined within enterprise specific subtrees. The agent is not required to support every types defined within the elanAdminPolicyVal subtree.')
elanPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanPolicyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyRowStatus.setDescription('This object is used to create or delete entries in the elanPolicyTable.')
elanLecAtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5), )
if mibBuilder.loadTexts: elanLecAtmAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrTable.setDescription("This table is used to assign a LEC to an ELAN by ATM address. When the by ATM address policy is used, this table is used to specify the LEC's ATM address or portion of an ATM address. The ATM address is used by the LECS or other entity which serves the LANE configuration function to determine the ELAN membership. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, the LEC's ATM address and an ATM address mask. Portions of ATM address can be used in dertermining ELAN membership by using both the ATM address and the mask.")
elanLecAtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecAtmAddress"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecAtmMask"))
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setDescription('Each entry represents a LEC to ELAN binding.')
elanLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 1), AtmLaneAddress())
if mibBuilder.loadTexts: elanLecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddress.setDescription('The value of this object is the ATM address of a LAN Emulation client. This object and the object elanLecAtmMask are used to form an ATM address or portion of an ATM address to be used by the LECS in determining the ELAN membership when the policy of this LECS is by ATM address.')
elanLecAtmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 2), AtmLaneAddress())
if mibBuilder.loadTexts: elanLecAtmMask.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmMask.setDescription("The ATM address mask associated with the object elanLecAtmAddress. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
elanLecAtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecAtmRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecMacAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6), )
if mibBuilder.loadTexts: elanLecMacAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrTable.setDescription("This table is used to assign a LEC to an ELAN by MAC address. When the byMacAddress policy is used, this table is used to specify the LEC's ELAN membership by ATM address. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's MAC address.")
elanLecMacAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecMacAddress"))
if mibBuilder.loadTexts: elanLecMacAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrEntry.setDescription('Each entry represents a LEC to ELAN binding.')
elanLecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 1), MacAddress())
if mibBuilder.loadTexts: elanLecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddress.setDescription('The value of this object is the MAC address of a LAN Emulation client. When a CONFIGURE request is received with this MAC address, it will be assigned to the ELAN which elanConfIndex is pointing to.')
elanLecMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecMacRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecMacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecRdTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7), )
if mibBuilder.loadTexts: elanLecRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdTable.setDescription("This table is used to assign a LEC to an ELAN by Route Descriptor. When the by Route Descriptor policy is used, this table is used to specify the LEC's ELAN membership by Route Descriptor. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's Route Descriptors.")
elanLecRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecRdSegId"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecRdBridgeNum"))
if mibBuilder.loadTexts: elanLecRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdEntry.setDescription('Each entry represents a LEC to ELAN binding. ')
elanLecRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: elanLecRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdSegId.setDescription('The LAN ID portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
elanLecRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: elanLecRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdBridgeNum.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
elanLecRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecRdRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecPktSizeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8), )
if mibBuilder.loadTexts: elanLecPktSizeTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeTable.setDescription("This table is used to assign a LEC to an ELAN by Packet Size. When the by Packet Size policy is used, this table is used to specifythe LEC's ELAN membership by Packet Size. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's Packet Size.")
elanLecPktSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecFrameSize"))
if mibBuilder.loadTexts: elanLecPktSizeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeEntry.setDescription('Each entry represents a LEC to ELAN binding. ')
elanLecFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1, 1), LecDataFrameSize())
if mibBuilder.loadTexts: elanLecFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecFrameSize.setDescription('The maximum AAL-5 SDU size this LEC can support. ')
elanLecPktSizeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecNameTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9), )
if mibBuilder.loadTexts: elanLecNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameTable.setDescription("This table is used to assign a LEC to an ELAN by ELAN name. When the by ELAN name policy is used, this table is used to specifythe LEC's ELAN membership by ELAN name. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's ELAN name.")
elanLecNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecElanName"))
if mibBuilder.loadTexts: elanLecNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameEntry.setDescription('Each entry represents a LEC to ELAN binding. ')
elanLecElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: elanLecElanName.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecElanName.setDescription('The name of the ELAN this LEC belongs.')
elanLecNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecNameRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecNameRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameRowStatus.setDescription('This object is used to create or destroy entries in this table.')
lecsConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfNextId.setDescription('The next available LECS index. The value of this object can be used as the index to the lecsTable during creation.')
lecsConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2), )
if mibBuilder.loadTexts: lecsConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfTable.setDescription('This table contains the configuration information of all LECS this agent manages. This table can also be used to create, delete or configure a LECS.')
lecsConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfEntry.setDescription('Each entry represents a LECS this agent maintains. Objects lecsAtmIfIndex, lecsAtmAddrSpec, and lecsAtmAddrMask cannot be modified unless the lecsAdminStatus is set to down(2). And the change does not take effect until the lecsAdminStatus is set to up(1).')
lecsConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: lecsConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfIndex.setDescription('An arbitrary integer which represents a LECS this agent manages. If the conceptual row identified by this value of lecsConfIndex is recreated following an agent restart, the same value of elanConfIndex must be used to identify the recreated row.')
lecsAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 2), IfIndexOrZero().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmIfIndex.setDescription('An ATM interface which the LECS receives CONFIGURE requests from. This value must match an existing value in the ifTable. This object is set to zero when the ATM interface is not specified or there is more than one ATM interface used by the LECS.')
lecsAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 3), AtmLaneAddress().clone(hexValue="4700790000000000000000000000A03E00000100")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrSpec.setDescription('An ATM address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the LECS on the designated ATM interface will use to derive the actual ATM address from the network or ILMI. The derived ATM address is specified in the object lecsAtmAddrActual, which is used to receive CONFIGURE requests. The value of this object, if not specified, is defaulted to the well-known LECS ATM address specified in the LAN Emulation Spec. 1.0.')
lecsAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 4), AtmLaneMask().clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrMask.setDescription("The ATM address mask associated with the object lecsAtmAddrSpec. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
lecsAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrActual.setDescription(" The resulting ATM address that the LECS is accepting CONFIGURE requests on the interface indicated by the object lecsAtmIfIndex. This address is the result of the specified ATM address, its mask and interaction through the ILMI with the switch. Note that this object is only valid when the corresponding lecsOperStatus is 'up'.")
lecsPolicySelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 6), PolicySelectorIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsPolicySelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsPolicySelIndex.setDescription('The set of policies used by this LECS in dertermining requesters ELAN membership. The policies are defined in the elanPolicyTable. The value of this object must exist in the elanPolicyTable.')
lecsLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLastInitialized.setDescription('The value of the sysUpTime since LECS has last entered the state indicated by the object lecsOperStatus.')
lecsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsOperStatus.setDescription(" This object reflects the actual state of the LECS which may differ from that of the lecsAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding lecsAdminStatus is 'up'.")
lecsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAdminStatus.setDescription('The desired state of the LECS on this interface as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lecsOperStatus.')
lecsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRowStatus.setDescription('This object is used to create or delete entries in this table.')
lecsElanTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3), )
if mibBuilder.loadTexts: lecsElanTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanTable.setDescription('This table contains the mapping between ELANs and LECS. When a LECS is deleted from the lecsConfTable, all entries associated with this entry will also be deleted.')
lecsElanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsElanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanEntry.setDescription('Each entry represents an ELAN to LECS mapping.')
lecsElanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsElanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanRowStatus.setDescription('This object is used to create or delete an entry from this table.')
lecsTlvTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4), )
if mibBuilder.loadTexts: lecsTlvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTable.setDescription('This table contains mandatoryly configured sets of TLVs in this LECS. These sets can include not only the standard TLVs specified in the LAN Emulation Spec. 1.0 [1] but also the additional parameters exchanged between the LECS and LEC. This table is indexed by a selector index, which allows more than one TLV to be selected by an ELAN; and the TLV tag, which specified the type of the TLV; and a TLV index which is used to distinguish between different entries with the same TLV tag. How does the LECS treat the TLVs that are not specified in this table in the CONFIGURE requests are not defined in this MIB.')
lecsTlvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsTlvSelectorIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsTlvTag"), (0, "LAN-EMULATION-ELAN-MIB", "lecsTlvIndex"))
if mibBuilder.loadTexts: lecsTlvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvEntry.setDescription('Each entry represents a set of TLV encodings for an ELAN represented by the elanConfIndex. Objects lecsTlvVal and lecsTlvRowStatus are required during row creation.')
lecsTlvSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 1), TlvSelectorIndexType())
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setDescription('The value of this object indicates a group of TLVs that can be selected.')
lecsTlvTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4))
if mibBuilder.loadTexts: lecsTlvTag.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTag.setDescription('The value of this object represents the type of the contents of the lecsTlvVal field in the entry. The OUI field in this object occupies the first ( or most significant )3 octets. The OUI value 00-A0-3E is used for the standard values defined by the ATM Forum specification.')
lecsTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lecsTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvIndex.setDescription('The index of this TLV encoding entry. The value of this object can be used to distinguish between different entries with the same lecsTlvTag value.')
lecsTlvVal = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvVal.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvVal.setDescription('The value of this TLV entry. Note that the length is implied by the length of the OCTET STRING.')
lecsTlvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsTlvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvRowStatus.setDescription('This object is used to create or destroy entries in this table. ')
lecsVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5), )
if mibBuilder.loadTexts: lecsVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccTable.setDescription('This table contains all the CONFIG VCCs of the LECS. The CONFIG VCC is used by the LEC to send/ receive ATM LE CONFIGURE request/response to/from the LECS. This table is writable if PVC is used and read only if SVC is used. ')
lecsVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccIfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccVpi"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccVci"))
if mibBuilder.loadTexts: lecsVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccEntry.setDescription('Each entry represents a CONFIG VCC between a pair of LEC and LECS.')
lecsVccIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 1), IfIndexOrZero())
if mibBuilder.loadTexts: lecsVccIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccIfIndex.setDescription('The ATM interface which the CONFIG VCC is established. This value must be an existing value in the ifTable. The value of this object is set to zero when the ATM interface is an internal connection.')
lecsVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 2), VpiInteger())
if mibBuilder.loadTexts: lecsVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccVpi.setDescription('The VPI value of the CONFIG VCC. The object lecsVccIfIndex, lecsVccVci and this object uniquely identifies a VCC within an ATM system.')
lecsVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 3), VciInteger())
if mibBuilder.loadTexts: lecsVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccVci.setDescription('The VCI value of the CONFIG VCC. The object lecsVccIfIndex, lecsVccVpi and this object uniquely identifies a VCC within an ATM system ')
lecsVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsVccRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccRowStatus.setDescription('This object is used to create or destroy entries in this table. ')
lecsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1), )
if mibBuilder.loadTexts: lecsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsTable.setDescription(' A (conceptual) table of statistics associated with all LECS instances on the device.')
lecsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsEntry.setDescription(' A (conceptual) row in the lecsStatsTable which corresponds to the statistics kept by a particular instance of a LECS.')
lecsStatSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatSuccessful.setDescription('The number of CONFIGURE requests successfully granted since the agent was last initialized.')
lecsStatInBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInBadFrames.setDescription('The number of mal formed CONFIGURE requests dropped by the LECS.')
lecsStatInvalidParam = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidParam.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidParam.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidParam.setDescription('The number of CONFIGURE requests rejected due to the invalid request parameters error.')
lecsStatInsufRes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufRes.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInsufRes.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufRes.setDescription('The number of CONFIGURE requests rejected due to the insufficent resources to grant request error.')
lecsStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatAccDenied.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatAccDenied.setDescription('The number of CONFIGURE requests rejected due to the access denied error.')
lecsStatInvalidReq = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidReq.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidReq.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidReq.setDescription('The number of CONFIGURE requests rejected due to the invalid requester-id error.')
lecsStatInvalidDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidDest.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidDest.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidDest.setDescription('The number of CONFIGURE requests rejected due to the invalid destination error.')
lecsStatInvalidAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidAddr.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setDescription('The number of CONFIGURE requests rejected due to the invalid ATM address error.')
lecsStatNoConf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatNoConf.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatNoConf.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatNoConf.setDescription('The number of CONFIGURE requests rejected due to the LE Client is not recognized error.')
lecsStatConfError = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatConfError.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatConfError.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatConfError.setDescription('The number of CONFIGURE requests rejected due to the LE_CONFIGURE error.')
lecsStatInsufInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufInfo.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInsufInfo.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufInfo.setDescription('The number of CONFIGURE requests rejected due to the insufficient information error.')
lecsErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1), )
if mibBuilder.loadTexts: lecsErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlTable.setDescription('This table contains error log control information of all LECS instances. This table is an extention to the lecsConfTable. It is used to enable or disable error logs for a particular LECS entry.')
lecsErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlEntry.setDescription('Each entry represents a LECS entry in the lecsConfTable.')
lecsErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setDescription('This object is used to enable/disable error logging for the LECS.')
lecsErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setDescription('This object is used to indicate the result of a set operation to the object lecsErrCtlAdminStatus. If the error log was successfully started, it is in active(2) mode. Otherwise, it is set to either outOfRes(3) or failed(4) for the respective reasons.')
lecsErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlClearLog.setDescription('This object is used to clear the error log entries associated with this LECS.')
lecsErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setDescription('The maximum entries of the error log a LECS can support.')
lecsErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 5), LecsErrLogIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setDescription('The index to the last entry in the error log table associated with this LECS.')
lecsErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2), )
if mibBuilder.loadTexts: lecsErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTable.setDescription('This table contains error logs of the LECS instances enabled in the lecsErrCtlTable. This table is indexed by the LECS instance index and an arbitrary integer uniquely identifies an error log.')
lecsErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsErrLogIndex"))
if mibBuilder.loadTexts: lecsErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogEntry.setDescription('Each entry represents a LEC that was rejected due to a violation against the policies or an error.')
lecsErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 1), LecsErrLogIndexType())
if mibBuilder.loadTexts: lecsErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogIndex.setDescription('An arbitrary integer which uniquely identifies an error log entry. The first entry after reset or clearing the error log is an assigned value (2^32-1). Succeding entries are assigned with descending values consecutively. Entries after 1 are discarded.The enabling/disabling of the error log capability is done in the lecsErrCtlTable.')
lecsErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setDescription('The ATM address of the requester which sends the CONFIGURE request and causes the error to occur. The corresponding error code is specified in the object lecsErrLogErrCode.')
lecsErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogErrCode.setDescription('The Error code which indicates the cause of the error triggered by the CONFIGURE request sent by the requester indicated by the value of the object lecsErrLogAtmAddr.')
lecsErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTime.setDescription('The sysUpTime when this entry was logged by the LECS.')
mibBuilder.exportSymbols("LAN-EMULATION-ELAN-MIB", lecsStatInvalidReq=lecsStatInvalidReq, elanLecMacAddrTable=elanLecMacAddrTable, lecsStatInsufRes=lecsStatInsufRes, elanLecMacRowStatus=elanLecMacRowStatus, lecsStatNoConf=lecsStatNoConf, elanLecRdBridgeNum=elanLecRdBridgeNum, TIMESTAMP=TIMESTAMP, elanConfGroup=elanConfGroup, lecsErrCtlMaxEntries=lecsErrCtlMaxEntries, lecsErrLogTime=lecsErrLogTime, lecsRowStatus=lecsRowStatus, lecsConfNextId=lecsConfNextId, elanMIB=elanMIB, elanLecsGroup=elanLecsGroup, elanLecPktSizeRowStatus=elanLecPktSizeRowStatus, elanConfName=elanConfName, elanLecAtmAddress=elanLecAtmAddress, lecsStatInBadFrames=lecsStatInBadFrames, lecsStatInsufInfo=lecsStatInsufInfo, lecsOperStatus=lecsOperStatus, elanConfMaxFrameSize=elanConfMaxFrameSize, lecsPolicySelIndex=lecsPolicySelIndex, lecsTlvEntry=lecsTlvEntry, lecsTlvTag=lecsTlvTag, lecsErrCtlOperStatus=lecsErrCtlOperStatus, elanLecMacAddrEntry=elanLecMacAddrEntry, elanConfNextId=elanConfNextId, elanConfTlvIndex=elanConfTlvIndex, lecsErrLogAtmAddr=lecsErrLogAtmAddr, lecsErrCtlEntry=lecsErrCtlEntry, lecsErrLogIndex=lecsErrLogIndex, elanLesRowStatus=elanLesRowStatus, AutonomousType=AutonomousType, elanLecsConfGroup=elanLecsConfGroup, lecsStatConfError=lecsStatConfError, byMacAddr=byMacAddr, lecsErrLogTable=lecsErrLogTable, lecsAtmAddrSpec=lecsAtmAddrSpec, byAtmAddr=byAtmAddr, byPktSize=byPktSize, lecsErrCtlClearLog=lecsErrCtlClearLog, lecsVccEntry=lecsVccEntry, lecsElanTable=lecsElanTable, LecsErrLogIndexType=LecsErrLogIndexType, byRouteDescriptor=byRouteDescriptor, lecsVccVci=lecsVccVci, elanPolicyIndex=elanPolicyIndex, elanLecAtmMask=elanLecAtmMask, lecsStatInvalidAddr=lecsStatInvalidAddr, lecsStatInvalidParam=lecsStatInvalidParam, elanLecsStatGroup=elanLecsStatGroup, elanPolicyTable=elanPolicyTable, PolicySelectorIndexType=PolicySelectorIndexType, lecsLastInitialized=lecsLastInitialized, lecsErrCtlTable=lecsErrCtlTable, elanLecNameTable=elanLecNameTable, elanLecRdTable=elanLecRdTable, lecsErrLogEntry=lecsErrLogEntry, elanAdminGroup=elanAdminGroup, MacAddress=MacAddress, byLanType=byLanType, lecsTlvSelectorIndex=lecsTlvSelectorIndex, elanLesAtmAddress=elanLesAtmAddress, AtmLaneAddress=AtmLaneAddress, ElanLocalIndex=ElanLocalIndex, elanAdminPolicyVal=elanAdminPolicyVal, elanLesTable=elanLesTable, elanLecPktSizeEntry=elanLecPktSizeEntry, lecsTlvTable=lecsTlvTable, lecsStatsTable=lecsStatsTable, RowStatus=RowStatus, lecsTlvRowStatus=lecsTlvRowStatus, elanPolicySelectorIndex=elanPolicySelectorIndex, Integer=Integer, lecsTlvIndex=lecsTlvIndex, elanConfLanType=elanConfLanType, elanLecFrameSize=elanLecFrameSize, elanLecNameRowStatus=elanLecNameRowStatus, lecsErrCtlLastEntry=lecsErrCtlLastEntry, lecsAtmIfIndex=lecsAtmIfIndex, lecsConfIndex=lecsConfIndex, lecsErrLogErrCode=lecsErrLogErrCode, elanLecsFaultGroup=elanLecsFaultGroup, lecsStatAccDenied=lecsStatAccDenied, elanLecRdEntry=elanLecRdEntry, elanLecMacAddress=elanLecMacAddress, lecsElanEntry=lecsElanEntry, elanLecNameEntry=elanLecNameEntry, elanLecRdRowStatus=elanLecRdRowStatus, elanConfTable=elanConfTable, AtmLaneMask=AtmLaneMask, lecsAtmAddrActual=lecsAtmAddrActual, byElanName=byElanName, TlvSelectorIndexType=TlvSelectorIndexType, elanLesIndex=elanLesIndex, elanPolicyPriority=elanPolicyPriority, lecsConfTable=lecsConfTable, elanConfEntry=elanConfEntry, lecsStatSuccessful=lecsStatSuccessful, lecsAtmAddrMask=lecsAtmAddrMask, elanConfRowStatus=elanConfRowStatus, lecsTlvVal=lecsTlvVal, lecsVccVpi=lecsVccVpi, elanPolicyEntry=elanPolicyEntry, IfIndexOrZero=IfIndexOrZero, elanConfIndex=elanConfIndex, elanLecAtmRowStatus=elanLecAtmRowStatus, elanPolicyRowStatus=elanPolicyRowStatus, elanLecElanName=elanLecElanName, lecsVccTable=lecsVccTable, lecsStatsEntry=lecsStatsEntry, elanPolicyType=elanPolicyType, lecsAdminStatus=lecsAdminStatus, elanLecRdSegId=elanLecRdSegId, lecsErrCtlAdminStatus=lecsErrCtlAdminStatus, lecsVccIfIndex=lecsVccIfIndex, lecsVccRowStatus=lecsVccRowStatus, elanLecAtmAddrTable=elanLecAtmAddrTable, elanLecPktSizeTable=elanLecPktSizeTable, lecsConfEntry=lecsConfEntry, elanLesEntry=elanLesEntry, lecsElanRowStatus=lecsElanRowStatus, elanLecAtmAddrEntry=elanLecAtmAddrEntry, lecsStatInvalidDest=lecsStatInvalidDest)

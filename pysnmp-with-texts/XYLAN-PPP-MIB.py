#
# PySNMP MIB module XYLAN-PPP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-PPP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, Counter64, ObjectIdentity, MibIdentifier, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType, Unsigned32, iso, Gauge32, Bits, Counter32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "ObjectIdentity", "MibIdentifier", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType", "Unsigned32", "iso", "Gauge32", "Bits", "Counter32", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xylanPppArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanPppArch")
pppxConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 17, 1))
pppxCpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 17, 2))
pppxStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 17, 3))
pppxIncomingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 17, 4))
pppxConfigTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1), )
if mibBuilder.loadTexts: pppxConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigTable.setDescription('A table of PPP protocol entity configuration information.')
pppxConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1), ).setIndexNames((0, "XYLAN-PPP-MIB", "pppxConfigPeerID"))
if mibBuilder.loadTexts: pppxConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigEntry.setDescription('An entry in the PPP Entity Configuration table, containing information about PPP protocol configuration.')
pppxConfigPeerID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxConfigPeerID.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigPeerID.setDescription("The PPP peer ID. This is used as a unique ID to identify a PPP entity and to associate PPP links to it. For 'normal' PPP, there is one entry in the link table. For Multilink PPP there are one or more multiple links. In either case the Link table is indexed by Link index (one per link) and by Peer ID. When one or more entrys in the link table has the same Peer ID, then these entries form a group for use either for Multilink PPP, or as a rotary group.")
pppxConfigDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigDescription.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigDescription.setDescription('A description for this PPP port or peer group.')
pppxConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigAdminStatus.setDescription('This object controls the Administrative Status of this PPP Entity. Enabled will allow the PPP Entity to operate. Disabled will disable the PPP Entity without deleting it. Delete will disable the PPP entity and delete the PPP configuration record.')
pppxConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("multilink", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigMode.setDescription('This object controls whether or not Multilink PPP will be used.')
pppxConfigBridgingVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigBridgingVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigBridgingVLAN.setDescription('The VLAN Group for PPP bridging. A value of zero(0) indicates that this PPP port will not perform a bridging service and will discard all bridged format packets received or transmitted. A non-zero value indicates the bridging VLAN to be used.')
pppxConfigRoutingVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigRoutingVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigRoutingVLAN.setDescription('The default VLAN for new PVCs that have not been configured for a routing Service. A value of zero(0) indicates that unconfigured VCs will not perform a routing service and will discard all routed format packets received or transmitted. A non-zero value indicates the routing VLAN to be used if the network informs the port of a new VC.')
pppxConfigCompressionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("lzsDcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigCompressionType.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigCompressionType.setDescription('This object controls whether or not PPP will not perform compression (none) or the type of compression to attempt to negotiate for.')
pppxConfigBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigBridgingMode.setDescription('The default Briding Mode, 0 = BRIDGE_ALL, 1 = ETHERNET ONLY 2 = Bridge All No FCS, 3 = Ethernet Only No FCS')
pppxConfigIpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigIpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigIpConfigAdminStatus.setDescription("The immediate desired status of the IP network protocol. Setting this object to open will inject an administrative open event into the IP network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxConfigBcpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigBcpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigBcpConfigAdminStatus.setDescription("The immediate desired status of the BCP network protocol. Setting this object to open will inject an administrative open event into the BCP network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxConfigIpxConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigIpxConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigIpxConfigAdminStatus.setDescription("The immediate desired status of the IPX network protocol. Setting this object to open will inject an administrative open event into the IPX network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxConfigCcpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigCcpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigCcpConfigAdminStatus.setDescription("The immediate desired status of the IPX network protocol. Setting this object to open will inject an administrative open event into the IPX network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxConfigRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigRemoteIpAddress.setDescription('The Remote IP address of the PPP connection. If set to 0.0.0.0 and IP routing is enabled then the IP address will be learned during the IP LCP negotiation. If set to a value then no IP address negotiation will occur.')
pppxConfigAuthenticationType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigAuthenticationType.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigAuthenticationType.setDescription('The desired Authentication protocol to use for this PPP connection.')
pppxConfigUserIdToRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigUserIdToRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigUserIdToRemote.setDescription('User ID sent to remote during PAP or CHAP Authentication. If this string is empty, then no local to remote authentication will occur.')
pppxConfigPasswordToRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigPasswordToRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigPasswordToRemote.setDescription('Password sent to remote during PAP or CHAP Authentication. If this string is empty, then no local to remote authentication will occur.')
pppxConfigUserIdFromRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigUserIdFromRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigUserIdFromRemote.setDescription('User ID expected to be received remote during PAP or CHAP Authentication. If this string is empty, then no remote to local authentication will be required.')
pppxConfigPasswordFromRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigPasswordFromRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigPasswordFromRemote.setDescription('Password expected to be received remote during PAP or CHAP Authentication. If this string is empty, then no remote to local authentication will be required.')
pppxConfigMaxFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigMaxFailureCount.setReference('RFC 1661 Section 4.6. Counters and Timers')
if mibBuilder.loadTexts: pppxConfigMaxFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigMaxFailureCount.setDescription('PPP LCP and NCP Negotiation Maximum Failure Count')
pppxConfigMaxConfigureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigMaxConfigureCount.setReference('RFC 1661 Section 4.6. Counters and Timers')
if mibBuilder.loadTexts: pppxConfigMaxConfigureCount.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigMaxConfigureCount.setDescription('PPP LCP Negotiation Maximum Configure Count')
pppxConfigMaxTerminateCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigMaxTerminateCount.setReference('RFC 1661 Section 4.6. Counters and Timers')
if mibBuilder.loadTexts: pppxConfigMaxTerminateCount.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigMaxTerminateCount.setDescription('PPP LCP Negotiation Maximum Terminate Count')
pppxConfigRetryTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxConfigRetryTimeout.setReference('RFC 1661 Section 4.6. Counters and Timers')
if mibBuilder.loadTexts: pppxConfigRetryTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: pppxConfigRetryTimeout.setDescription('PPP LCP Negotiation Retry Timeout')
pppxCpTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1), )
if mibBuilder.loadTexts: pppxCpTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTable.setDescription('A table of PPP connection Link Control and Network Control Protocol status and statistics information.')
pppxCpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1), ).setIndexNames((0, "XYLAN-PPP-MIB", "pppxCpPeerID"))
if mibBuilder.loadTexts: pppxCpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpEntry.setDescription('An entry in the table, containing information about the PPP LCP and NCP status and statistics.')
pppxCpPeerID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpPeerID.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpPeerID.setDescription('A unique ID which identifies this PPP Control Protocol entity.')
pppxCpSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpSlotIndex.setDescription('A unique value which identifies this WSM board slot that the PPP Control Protocol Entity is running on. A value of zero is returned when PPP is not currently assigned to a slot (e.g. for PPP for an incoming ISDN call.')
pppxCpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpPortIndex.setDescription('A unique value which identifies this WSM port that the PPP Control Protocol Entity is running on. A value of zero is returned when PPP is not currently assigned to a slot (e.g. for PPP for an incoming ISDN call.)')
pppxCpIpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opened", 1), ("not-opened", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpIpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpIpOperStatus.setDescription('The operational status of the IP network protocol. If the value of this object is up then the finite state machine for the IP network protocol has reached the Opened state.')
pppxCpIpxOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opened", 1), ("not-opened", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpIpxOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpIpxOperStatus.setDescription('The operational status of the IPX network protocol. If the value of this object is up then the finite state machine for the IP network protocol has reached the Opened state.')
pppxCpBcpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opened", 1), ("not-opened", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpBcpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpBcpOperStatus.setDescription('The operational status of the BCP network protocol. If the value of this object is up then the finite state machine for the IP network protocol has reached the Opened state.')
pppxCpCcpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opened", 1), ("not-opened", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpCcpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpCcpOperStatus.setDescription('The operational status of the CCP network protocol. If the value of this object is up then the finite state machine for the IP network protocol has reached the Opened state.')
pppxCpTxLcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpTxLcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTxLcpPackets.setDescription('The total number of transmitted Link Control Protocol packets on this PPP connection.')
pppxCpRxLcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpRxLcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpRxLcpPackets.setDescription('The total number of received Link Control Protocol packets on this PPP connection.')
pppxCpTxIpcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpTxIpcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTxIpcpPackets.setDescription('The total number of transmitted IP Control Protocol packets on this PPP connection.')
pppxCpRxIpcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpRxIpcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpRxIpcpPackets.setDescription('The total number of received IP Control Protocol packets on this PPP connection.')
pppxCpTxIpxcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpTxIpxcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTxIpxcpPackets.setDescription('The total number of transmitted IPX Control Protocol packets on this PPP connection.')
pppxCpRxIpxcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpRxIpxcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpRxIpxcpPackets.setDescription('The total number of received IPX Control Protocol packets on this PPP connection.')
pppxCpTxBcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpTxBcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTxBcpPackets.setDescription('The total number of transmitted Bridge Control Protocol packets on this PPP connection.')
pppxCpRxBcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpRxBcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpRxBcpPackets.setDescription('The total number of received Bridge Control Protocol packets on this PPP connection.')
pppxCpTxCcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpTxCcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpTxCcpPackets.setDescription('The total number of transmitted Compression Control Protocol packets on this PPP connection.')
pppxCpRxCcpPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxCpRxCcpPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxCpRxCcpPackets.setDescription('The total number of received Compression Control Protocol packets on this PPP connection.')
pppxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1), )
if mibBuilder.loadTexts: pppxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTable.setDescription('A table of PPP connection statistics information.')
pppxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1), ).setIndexNames((0, "XYLAN-PPP-MIB", "pppxStatsIfIndex"))
if mibBuilder.loadTexts: pppxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsEntry.setDescription('An entry in the table, containing information about the PPP PPP connection statistics.')
pppxStatsPeerID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsPeerID.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsPeerID.setDescription('A unique ID which identifies the PPP Control Protocol entity associated with this PPP link.')
pppxStatsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsIfIndex.setDescription('The ifindex that represents this PPP link.')
pppxStatsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsSlotIndex.setDescription('A unique value which identifies this HSM board slot that this PPP link is running on.')
pppxStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsPortIndex.setDescription('A unique value which identifies this WSM submodule port that this PPP link is running on.')
pppxStatsSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsSubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsSubIndex.setDescription('A unique value which identifies the sub-element of the WSM submodule port that this PPP link is running on. For Serial ports this will always return 0. For ISDN BRI ports, this will return 1 or 2 for B1 or B2 channel respectively.')
pppxStatsTxIPOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxIPOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxIPOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within routed IP format packets on this PPP connection.')
pppxStatsTxIPPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxIPPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxIPPackets.setDescription('The total number of transmitted routed IP format packets on this PPP connection.')
pppxStatsRxIPOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxIPOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxIPOctets.setDescription('The total number of received octets (including the PPP Header field) within routed IP format packets on this PPP connection.')
pppxStatsRxIPPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxIPPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxIPPackets.setDescription('The total number of received routed IP format packets on this PPP connection.')
pppxStatsTxIPXOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxIPXOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxIPXOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within routed IPX format packets on this PPP connection.')
pppxStatsTxIPXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxIPXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxIPXPackets.setDescription('The total number of transmitted routed IPX format packets on this PPP connection.')
pppxStatsRxIPXOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxIPXOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxIPXOctets.setDescription('The total number of received octets (including the PPP Header field) within routed IPX format packets on this PPP connection.')
pppxStatsRxIPXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxIPXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxIPXPackets.setDescription('The total number of received routed IPX format packets on this PPP connection.')
pppxStatsTxBPDUOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxBPDUOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxBPDUOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within BPDU packets on this PPP connection.')
pppxStatsTxBPDUPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxBPDUPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxBPDUPackets.setDescription('The total number of transmitted BPDU packets on this PPP connection.')
pppxStatsRxBPDUOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxBPDUOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxBPDUOctets.setDescription('The total number of received octets (including the PPP Header field) within BPDU packets on this PPP connection.')
pppxStatsRxBPDUPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxBPDUPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxBPDUPackets.setDescription('The total number of received BPDU packets on this PPP connection.')
pppxStatsTxEthernetOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxEthernetOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxEthernetOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within bridged 802.3 format packets on this PPP connection.')
pppxStatsTxEthernetPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxEthernetPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxEthernetPackets.setDescription('The total number of transmitted bridged 802.3 format packets on this PPP connection.')
pppxStatsRxEthernetOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxEthernetOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxEthernetOctets.setDescription('The total number of received octets (including the PPP Header field) within bridged 802.3 format packets on this PPP connection.')
pppxStatsRxEthernetPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxEthernetPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxEthernetPackets.setDescription('The total number of received bridged 802.3 format packets on this PPP connection.')
pppxStatsTx8025Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTx8025Octets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTx8025Octets.setDescription('The total number of transmitted octets (including the PPP Header field) within 8025 packets on this PPP connection.')
pppxStatsTx8025Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTx8025Packets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTx8025Packets.setDescription('The total number of transmitted 8025 packets on this PPP connection.')
pppxStatsRx8025Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRx8025Octets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRx8025Octets.setDescription('The total number of received octets (including the PPP Header field) within 8025 packets on this PPP connection.')
pppxStatsRx8025Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRx8025Packets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRx8025Packets.setDescription('The total number of received 8025 packets on this PPP connection.')
pppxStatsTxFDDIOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxFDDIOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxFDDIOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within FDDI packets on this PPP connection.')
pppxStatsTxFDDIPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxFDDIPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxFDDIPackets.setDescription('The total number of transmitted FDDI packets on this PPP connection.')
pppxStatsRxFDDIOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxFDDIOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxFDDIOctets.setDescription('The total number of received octets (including the PPP Header field) within FDDI packets on this PPP connection.')
pppxStatsRxFDDIPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxFDDIPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxFDDIPackets.setDescription('The total number of received FDDI packets on this PPP connection.')
pppxStatsTxCompressedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxCompressedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxCompressedOctets.setDescription('The total number of transmitted octets (including the PPP Header field) within compressed format packets on this PPP connection.')
pppxStatsTxCompressedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxCompressedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxCompressedPackets.setDescription('The total number of transmitted compressed format packets on this PPP connection.')
pppxStatsRxCompressedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxCompressedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxCompressedOctets.setDescription('The total number of received octets (including the PPP Header field) within compressed format packets on this PPP connection.')
pppxStatsRxCompressedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxCompressedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxCompressedPackets.setDescription('The total number of received compressed format packets on this PPP connection.')
pppxStatsTxPrecompressedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsTxPrecompressedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsTxPrecompressedOctets.setDescription('The total number of octets (including the PPP Header field) prior to compression of data for transmission within compressed format packets on this PPP connection.')
pppxStatsRxDecompressedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxDecompressedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxDecompressedOctets.setDescription('The total number of octets (including the PPP Header field) after decompression of data received within compressed format packets on this PPP connection.')
pppxStatsRxCompressedDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 3, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxStatsRxCompressedDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: pppxStatsRxCompressedDiscards.setDescription('The total number of received compressed format packets on this PPP connection that were discarded due to error or lost packets (e.g. out of sequence, decompression errors, etc.)')
pppxIncomingTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1), )
if mibBuilder.loadTexts: pppxIncomingTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingTable.setDescription('A table of PPP protocol entity Incoming configuration information.')
pppxIncomingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1), ).setIndexNames((0, "XYLAN-PPP-MIB", "pppxIncomingIndex"))
if mibBuilder.loadTexts: pppxIncomingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingEntry.setDescription('An entry in the PPP Entity Configuration table, containing information about PPP protocol configuration.')
pppxIncomingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppxIncomingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingIndex.setDescription('Index to uniquelly identify this entry .')
pppxIncomingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingAdminStatus.setDescription('This object controls the Administrative Status of this Incoming Entity. Enabled will allow the Incoming Entity to operate. Disabled will disable the Incoming Entity without deleting it. Delete will disable the Incoming entity and delete the PPP configuration record.')
pppxIncomingAuthenticationType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingAuthenticationType.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingAuthenticationType.setDescription('The desired Authentication protocol to use for this PPP connection.')
pppxIncomingUserIdToRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingUserIdToRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingUserIdToRemote.setDescription('User ID sent to remote during PAP or CHAP Authentication. If this string is empty, then no local to remote authentication will occur.')
pppxIncomingPasswordToRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingPasswordToRemote.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingPasswordToRemote.setDescription('Password sent to remote during PAP or CHAP Authentication. If this string is empty, then no local to remote authentication will occur.')
pppxIncomingBridgingVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingBridgingVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingBridgingVLAN.setDescription('The VLAN Group for PPP bridging. A value of zero(0) indicates that this PPP port will not perform a bridging service and will discard all bridged format packets received or transmitted. A non-zero value indicates the bridging VLAN to be used.')
pppxIncomingRoutingVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingRoutingVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingRoutingVLAN.setDescription('The default VLAN for new PVCs that have not been configured for a routing Service. A value of zero(0) indicates that unconfigured VCs will not perform a routing service and will discard all routed format packets received or transmitted. A non-zero value indicates the routing VLAN to be used if the network informs the port of a new VC.')
pppxIncomingCompressionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("lzsDcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingCompressionType.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingCompressionType.setDescription('This object controls whether or not PPP will not perform compression (none) or the type of compression to attempt to negotiate for.')
pppxIncomingIpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingIpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingIpConfigAdminStatus.setDescription("The immediate desired status of the IP network protocol. Setting this object to open will inject an administrative open event into the IP network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxIncomingBcpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingBcpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingBcpConfigAdminStatus.setDescription("The immediate desired status of the BCP network protocol. Setting this object to open will inject an administrative open event into the BCP network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxIncomingIpxConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingIpxConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingIpxConfigAdminStatus.setDescription("The immediate desired status of the IPX network protocol. Setting this object to open will inject an administrative open event into the IPX network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
pppxIncomingCcpConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 17, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppxIncomingCcpConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pppxIncomingCcpConfigAdminStatus.setDescription("The immediate desired status of the CCP network protocol. Setting this object to open will inject an administrative open event into the IPX network protocol's finite state machine. Setting this object to close will inject an administrative close event into the IP network protocol's finite state machine.")
mibBuilder.exportSymbols("XYLAN-PPP-MIB", pppxIncomingCompressionType=pppxIncomingCompressionType, pppxConfigDescription=pppxConfigDescription, pppxCpRxBcpPackets=pppxCpRxBcpPackets, pppxCpPortIndex=pppxCpPortIndex, pppxConfigCompressionType=pppxConfigCompressionType, pppxCpTxIpcpPackets=pppxCpTxIpcpPackets, pppxStatsTxCompressedPackets=pppxStatsTxCompressedPackets, pppxIncomingGroup=pppxIncomingGroup, pppxStatsTxBPDUPackets=pppxStatsTxBPDUPackets, pppxCpCcpOperStatus=pppxCpCcpOperStatus, pppxStatsTxEthernetOctets=pppxStatsTxEthernetOctets, pppxCpTxIpxcpPackets=pppxCpTxIpxcpPackets, pppxIncomingUserIdToRemote=pppxIncomingUserIdToRemote, pppxStatsEntry=pppxStatsEntry, pppxCpIpxOperStatus=pppxCpIpxOperStatus, pppxStatsRxIPXOctets=pppxStatsRxIPXOctets, pppxStatsRx8025Packets=pppxStatsRx8025Packets, pppxStatsTxPrecompressedOctets=pppxStatsTxPrecompressedOctets, pppxConfigRetryTimeout=pppxConfigRetryTimeout, pppxStatsTxCompressedOctets=pppxStatsTxCompressedOctets, pppxIncomingIpxConfigAdminStatus=pppxIncomingIpxConfigAdminStatus, pppxConfigRemoteIpAddress=pppxConfigRemoteIpAddress, pppxStatsTxIPPackets=pppxStatsTxIPPackets, pppxStatsRxFDDIPackets=pppxStatsRxFDDIPackets, pppxIncomingIpConfigAdminStatus=pppxIncomingIpConfigAdminStatus, pppxStatsRxCompressedDiscards=pppxStatsRxCompressedDiscards, pppxConfigIpxConfigAdminStatus=pppxConfigIpxConfigAdminStatus, pppxConfigAuthenticationType=pppxConfigAuthenticationType, pppxCpTxLcpPackets=pppxCpTxLcpPackets, pppxCpTable=pppxCpTable, pppxStatsRxEthernetPackets=pppxStatsRxEthernetPackets, pppxStatsTxFDDIPackets=pppxStatsTxFDDIPackets, pppxStatsRxEthernetOctets=pppxStatsRxEthernetOctets, pppxConfigMaxTerminateCount=pppxConfigMaxTerminateCount, pppxCpGroup=pppxCpGroup, pppxStatsTx8025Packets=pppxStatsTx8025Packets, pppxConfigEntry=pppxConfigEntry, pppxConfigGroup=pppxConfigGroup, pppxConfigMode=pppxConfigMode, pppxIncomingPasswordToRemote=pppxIncomingPasswordToRemote, pppxStatsRxCompressedPackets=pppxStatsRxCompressedPackets, pppxStatsRxIPPackets=pppxStatsRxIPPackets, pppxCpBcpOperStatus=pppxCpBcpOperStatus, pppxConfigAdminStatus=pppxConfigAdminStatus, pppxIncomingBridgingVLAN=pppxIncomingBridgingVLAN, pppxStatsSlotIndex=pppxStatsSlotIndex, pppxIncomingEntry=pppxIncomingEntry, pppxConfigCcpConfigAdminStatus=pppxConfigCcpConfigAdminStatus, pppxCpRxIpxcpPackets=pppxCpRxIpxcpPackets, pppxIncomingIndex=pppxIncomingIndex, pppxCpTxCcpPackets=pppxCpTxCcpPackets, pppxCpRxCcpPackets=pppxCpRxCcpPackets, pppxStatsTable=pppxStatsTable, pppxStatsRxIPOctets=pppxStatsRxIPOctets, pppxStatsTxBPDUOctets=pppxStatsTxBPDUOctets, pppxConfigIpConfigAdminStatus=pppxConfigIpConfigAdminStatus, pppxCpRxIpcpPackets=pppxCpRxIpcpPackets, pppxIncomingBcpConfigAdminStatus=pppxIncomingBcpConfigAdminStatus, pppxStatsRxBPDUOctets=pppxStatsRxBPDUOctets, pppxStatsPortIndex=pppxStatsPortIndex, pppxStatsRxCompressedOctets=pppxStatsRxCompressedOctets, pppxConfigPasswordToRemote=pppxConfigPasswordToRemote, pppxIncomingTable=pppxIncomingTable, pppxConfigPasswordFromRemote=pppxConfigPasswordFromRemote, pppxStatsIfIndex=pppxStatsIfIndex, pppxConfigUserIdFromRemote=pppxConfigUserIdFromRemote, pppxCpEntry=pppxCpEntry, pppxStatsRx8025Octets=pppxStatsRx8025Octets, pppxConfigBridgingMode=pppxConfigBridgingMode, pppxStatsTxIPXPackets=pppxStatsTxIPXPackets, pppxStatsRxBPDUPackets=pppxStatsRxBPDUPackets, pppxCpTxBcpPackets=pppxCpTxBcpPackets, pppxIncomingRoutingVLAN=pppxIncomingRoutingVLAN, pppxStatsRxIPXPackets=pppxStatsRxIPXPackets, pppxCpIpOperStatus=pppxCpIpOperStatus, pppxIncomingCcpConfigAdminStatus=pppxIncomingCcpConfigAdminStatus, pppxConfigPeerID=pppxConfigPeerID, pppxStatsTxIPXOctets=pppxStatsTxIPXOctets, pppxConfigUserIdToRemote=pppxConfigUserIdToRemote, pppxConfigBcpConfigAdminStatus=pppxConfigBcpConfigAdminStatus, pppxStatsTxIPOctets=pppxStatsTxIPOctets, pppxStatsTxEthernetPackets=pppxStatsTxEthernetPackets, pppxConfigMaxConfigureCount=pppxConfigMaxConfigureCount, pppxCpPeerID=pppxCpPeerID, pppxCpRxLcpPackets=pppxCpRxLcpPackets, pppxConfigTable=pppxConfigTable, pppxConfigBridgingVLAN=pppxConfigBridgingVLAN, pppxStatsPeerID=pppxStatsPeerID, pppxIncomingAdminStatus=pppxIncomingAdminStatus, pppxStatsTxFDDIOctets=pppxStatsTxFDDIOctets, pppxStatsTx8025Octets=pppxStatsTx8025Octets, pppxConfigRoutingVLAN=pppxConfigRoutingVLAN, pppxConfigMaxFailureCount=pppxConfigMaxFailureCount, pppxCpSlotIndex=pppxCpSlotIndex, pppxStatsRxDecompressedOctets=pppxStatsRxDecompressedOctets, pppxStatsSubIndex=pppxStatsSubIndex, pppxIncomingAuthenticationType=pppxIncomingAuthenticationType, pppxStatsRxFDDIOctets=pppxStatsRxFDDIOctets, pppxStatsGroup=pppxStatsGroup)

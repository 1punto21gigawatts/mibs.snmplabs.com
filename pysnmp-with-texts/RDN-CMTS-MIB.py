#
# PySNMP MIB module RDN-CMTS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RDN-CMTS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:54:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
docsIfCmtsCmStatusIpAddress, docsIfCmtsCmStatusMacAddress, docsIfDownChannelId, docsIfUpChannelId, docsIfCmtsCmStatusDocsisRegMode, DocsisUpstreamType, TenthdB, DocsisQosVersion, docsIfCmtsCmStatusEntry, TenthdBmV, docsIfCmtsCmStatusIndex = mibBuilder.importSymbols("DOCS-IF-MIB", "docsIfCmtsCmStatusIpAddress", "docsIfCmtsCmStatusMacAddress", "docsIfDownChannelId", "docsIfUpChannelId", "docsIfCmtsCmStatusDocsisRegMode", "DocsisUpstreamType", "TenthdB", "DocsisQosVersion", "docsIfCmtsCmStatusEntry", "TenthdBmV", "docsIfCmtsCmStatusIndex")
IfDirection, docsIf3CmtsCmRegStatusIPv6Addr = mibBuilder.importSymbols("DOCS-IF3-MIB", "IfDirection", "docsIf3CmtsCmRegStatusIPv6Addr")
docsQosServiceClassName, = mibBuilder.importSymbols("DOCS-QOS3-MIB", "docsQosServiceClassName")
IpV4orV6Addr, = mibBuilder.importSymbols("DOCS-SUBMGT-MIB", "IpV4orV6Addr")
InterfaceIndexOrZero, ifType, ifAdminStatus, InterfaceIndex, ifOperStatus, ifDescr, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifType", "ifAdminStatus", "InterfaceIndex", "ifOperStatus", "ifDescr", "ifIndex")
InetAddressType, InetAddressIPv6, InetAddress, InetPortNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddressIPv6", "InetAddress", "InetPortNumber")
rdnSpectrumGroupName, = mibBuilder.importSymbols("RDN-CABLE-SPECTRUM-GROUP-MIB", "rdnSpectrumGroupName")
riverdelta, = mibBuilder.importSymbols("RDN-MIB", "riverdelta")
rdnPktDQoSClassName, = mibBuilder.importSymbols("RDN-PKTCABLE-GROUP-MIB", "rdnPktDQoSClassName")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
IpAddress, Unsigned32, Counter64, ObjectIdentity, Bits, NotificationType, Counter32, iso, MibIdentifier, TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Unsigned32", "Counter64", "ObjectIdentity", "Bits", "NotificationType", "Counter32", "iso", "MibIdentifier", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ModuleIdentity")
RowStatus, TimeInterval, TextualConvention, MacAddress, DisplayString, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeInterval", "TextualConvention", "MacAddress", "DisplayString", "TimeStamp", "TruthValue")
rdnCmtsMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4981, 2))
rdnCmtsMib.setRevisions(('2011-03-08 00:00', '2011-02-23 00:00', '2009-11-20 00:00', '2008-08-08 00:00', '2007-06-21 00:00', '2006-05-25 00:00', '2006-05-24 00:00', '2006-04-17 00:00', '2006-01-25 00:00', '2006-01-23 00:00', '2006-01-13 00:00', '2005-03-18 00:00', '2005-02-22 00:00', '2004-08-17 00:00', '1904-04-14 00:00', '2003-12-16 00:00', '2003-11-05 00:00', '2003-11-03 00:00', '2003-07-20 00:00', '2003-05-01 00:00', '2000-04-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rdnCmtsMib.setRevisionsDescriptions(("Added scalar rdnCmtsCmResetByIpv6Addr to reset IPv6 CMs and rdnCmToCpeIPv6Addr member to rdnCmToCpeTable to display CPE IPv6 Addr. Added extra varbind docsIf3CmtsCmRegStatusIPv6Addr to rdnCmtsCmRegisteredNotification, to report CM's IPv6 Addr.", 'Update rdnServiceClassBondingStatsTable to support upstream channel bonding', 'Added rdnRQueryCmtsCmStatusExt Table to include rdnRQueryServerConfigFile', "Added Copyright Statement into MIB modules's description.", 'Added rdnIfCmtsCmStatusDSBondingGroupId and rdnServiceClassBondingStatsTable', 'Added AdmittedBwThreshold trap and reason mib object', 'Included rdnPktDQoSClassName to resolve reference.', 'Changed description for rdnIfCmtsCmStatusTxUnicastKbytes, rdnIfCmtsCmStatusRxUnicastKbytes, rdnIfCmtsCmStatusTxUnicastExtKbytes, and rdnIfCmtsCmStatusRxUnicastExtKbytes counters to indicate the correct direction. These counters are implemented from the CMTS perspective.', 'Added rdnRQueryCmtsCmStatusExt Table to include rdnRQuerySwCurrentVers', 'Added rdnUgsStatsWindow, rdnCableUgsStatsTable', 'Added rdnCmtsServiceClass', 'Added rdnRQueryCmtsCmStatusTable', 'clarifying descriptive text related to proprietary linkUp/Down traps', 'added rdnCmtsCardType', ' Bhupendra Singh-A15782, Modified the descriptions of rdnIfCmtsCmStatusTxUnicastKbytes and rdnIfCmtsCmStatusRxUnicastKbytes objects to fix CQBSR00012760', 'added rdnCmtsCmRegisteredTrapEnable', 'Updated the CONTACT-INFO.', 'Rename rdnLinkUpDownTrapEnable to rdnCmtsLinkUpDownTrapEnable', 'MIB compilation error where the next to last sub-identifier for the notifications is not zero. This can cause problem when notifications are translated to SMIv1 for SNMPv1. The previous versions of the notifications have been removed rather than obsoleting them because the MIB compilation errors would still have existed even with the notification in the obsolete status.', ' David Wang, Clean up rdnCmtsMib definitions.', 'Initial Version. 1/30/01 add rdnCmtsCpeToCmTable . XQ Updated by JP Brahma May-28-2002 add rdmIfCmtsCmStatusTable Add CMTS Upstream Average Utilization support. By David Wang',))
if mibBuilder.loadTexts: rdnCmtsMib.setLastUpdated('201103080000Z')
if mibBuilder.loadTexts: rdnCmtsMib.setOrganization('Motorola')
if mibBuilder.loadTexts: rdnCmtsMib.setContactInfo('Motorola Customer Service 101 Tournament Drive Horsham, PA 19044 US Tel: +1 888 944 4357 Int Tel: +1 215 323 0044 Fax: +1 215 323 1502 Email: CPSSupport@Motorola.com')
if mibBuilder.loadTexts: rdnCmtsMib.setDescription("This is the enterprise MIB Module for Motorola's Cable Modem Termination Systems (CMTS). Copyright (C) 2000, 2008 by Motorola, Inc. All rights reserved.")
rdnCmtsIfObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 1))
rdnCmtsMiscObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 2))
rdnCmtsDownstreamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 1, 1), )
if mibBuilder.loadTexts: rdnCmtsDownstreamChannelTable.setReference('Proprietary MIB.')
if mibBuilder.loadTexts: rdnCmtsDownstreamChannelTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsDownstreamChannelTable.setDescription('This table describes the attributes of downstream channel in addition to those specified by the docsIfMib.')
rdnCmtsDownstreamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rdnCmtsDownstreamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsDownstreamChannelEntry.setDescription('An entry provides a list of attributes for a single Downstream channel. An entry in this table exists for each ifEntry with an ifType of docsCableDownstream(128).')
rdnCmtsDSModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsDSModulation.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsDSModulation.setDescription('The attribute to control the down stream modulation. When this object is set to FALSE(2), the downstream transmitter will output a CW, or tonal signal at the tuned RF frequency.')
rdnCmtsUpstreamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2), )
if mibBuilder.loadTexts: rdnCmtsUpstreamChannelTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpstreamChannelTable.setDescription('This table describes the attributes of upstream channel in addition to those specified by the docsIfMib.')
rdnCmtsUpstreamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rdnCmtsUpstreamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpstreamChannelEntry.setDescription('List of attributes for a single upstream channel. An entry in this table exists for each ifEntry with an ifType of docsCableUpstreamInterface (129) for DOCSIS1.x CMTSs, and ifType of docsCableUpstreamChannel (205) for DOCSIS2.0 CMTSs.')
rdnCmtsUSNominalRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-160, 290))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsUSNominalRxPower.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSNominalRxPower.setDescription('The attribute to program the target, or nominal, receive power of each upstream RF port. The range is channel width dependent: Power Level Channel Width -160,+140 200 kHz -130,+170 400 kHz -100,+200 800 kHz -70,+230 1600 kHz -40,+260 3200 kHz -30,+290 6400 kHz')
rdnCmtsUSNominalRxPowerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("absolute", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsUSNominalRxPowerMode.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSNominalRxPowerMode.setDescription('This object describes the setting mode for rdnCmtsUSNomialRxPower. The default setting is the absolute mode.')
rdnCmtsUSInvitedRangingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsUSInvitedRangingInterval.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSInvitedRangingInterval.setDescription('To fix Invited(Periodic) Ranging Intervals as in input to the Bandwidth Allocator algorithm.')
rdnCmtsUSRangingResponseControl = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("override", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsUSRangingResponseControl.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSRangingResponseControl.setDescription("The attribute to force all RNG-Resp messages to issue a 'Continue' Ranging Status indefinitely regardless of timing, power, etc. accuracy of previous incoming Ranging Request. Value 0 means Normal Ranging Mode, value 1 means Status Override")
rdnCmtsUSRangingPowerOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsUSRangingPowerOverride.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSRangingPowerOverride.setDescription("The attribute overrides upstream power adjustments performed by the CMTS to CM's. When this object is set to TRUE(1), the override is activated, all Ranging Response message will be transmitted with ZERO power adjustment, regardless of received upstream power levels.")
rdnCmtsUSTotalModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmtsUSTotalModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSTotalModemCount.setDescription('When read, this object returns the total number of Cable Modems per upstream.')
rdnCmtsUSRegisteredModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmtsUSRegisteredModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSRegisteredModemCount.setDescription('When read, this object returns the number of registered Cable Modems per upstream.')
rdnCmtsUSUnregisteredModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmtsUSUnregisteredModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSUnregisteredModemCount.setDescription('When read, this object returns the number of unregistered Cable Modems per upstream. This count reflects modems that are in the process of attempting to join the network. Note that this does not include offline modems, see rdnCmtsUSOfflineModemCount for offline modems.')
rdnCmtsUSOfflineModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmtsUSOfflineModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUSOfflineModemCount.setDescription('When read, this object returns the number of offline Cable Modems per upstream.')
rdnCmtsStpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 1, 3))
rdnCmtsStpEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 1, 3, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsStpEnable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsStpEnable.setDescription('This object controls the activation of DOCSIS Spanning Tree Protocol Bridging functionality. The Spanning Tree Bridging is disabled/enabled by setting this object to FALSE/TRUE.')
rdnCmtsStpTCNEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 1, 3, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsStpTCNEnable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsStpTCNEnable.setDescription('This object controls the generation of Topology Change Notification messages for DOCSIS Spanning Tree Protocol Bridge. ')
rdnCmtsLinkUpDownTrapEnableTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 1, 4), )
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnableTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnableTable.setDescription('This table has the object to enable or disable the generation of proprietary CMTS LinkUp and Link Down traps')
rdnCmtsLinkUpDownTrapEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnableEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnableEntry.setDescription('An entry in this table exists for each ifEntry with an ifType of docsCableUpstream(129) or docsCableUpstreamChannel(205).')
rdnCmtsLinkUpDownTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsLinkUpDownTrapEnable.setDescription('Indicates whether rdnCmtsUpstreamIfLinkUpTrap and rdnCmtsUpstreamIfLinkDownTrap traps should be generated for this interface. By default, this object has the value disabled(2). These traps are convenient for knowing the Spectrum Group name whenever the link state changes, and are therefore related only to the upstream direction')
rdnCmtsSaveConfig = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsSaveConfig.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsSaveConfig.setDescription('This object when set to TRUE will save the current configuration of the CMTS. When this object is read it will return FALSE')
rdnCmtsCmResetByMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCmResetByMacAddr.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmResetByMacAddr.setDescription('The CM MAC address that the operator wants to reset. When this object is set, it will cause the CMTS to reset that CM. When this object is read it will return zero')
rdnCmtsCmResetByIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCmResetByIpAddr.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmResetByIpAddr.setDescription('The CM IP address that the operator wants to reset. When this object is set, it will cause the CMTS to reset that CM. When this object is read it will return zero')
rdnCmtsCmResetAll = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCmResetAll.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmResetAll.setDescription('This object when set to TRUE will cause the CMTS to reset all the CM that are registered with this CMTS. When this object is read it will return FALSE')
rdnCmtsHostAuthControl = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsHostAuthControl.setStatus('obsolete')
if mibBuilder.loadTexts: rdnCmtsHostAuthControl.setDescription('This object is used to add or delete entry in CMTS host authorization table. The first octet is for action, add (1) or delete (2), the rest are composed with CM MAC address (6 octets), CPE MAC address (6 octets), and the CPE IP address (4 octets). Zero is returned for read on this object')
rdnCmtsModemAgingTimer = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 30240), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsModemAgingTimer.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsModemAgingTimer.setDescription("The Time in minutes of modem inactivity after which the modem is deleted from the registration table. The minimum is 10 minutes and the maximum is 21 days. A value of '0' will disable the aging timer")
rdnCmtsCpeToCmObject = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 2, 7))
rdnCmtsCpeToCmTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 7, 1), )
if mibBuilder.loadTexts: rdnCmtsCpeToCmTable.setReference(' ')
if mibBuilder.loadTexts: rdnCmtsCpeToCmTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCpeToCmTable.setDescription("This table describes the mapping between CPE's MAC address and MAC address of the cable modem these CPEs are attached to. This table does not support the walk/getNext. It is not intended to use this mib to walk the list of cpe's in the system.")
rdnCmtsCpeToCmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 7, 1, 1), ).setIndexNames((0, "RDN-CMTS-MIB", "rdnCmtsCpeMac"))
if mibBuilder.loadTexts: rdnCmtsCpeToCmEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCpeToCmEntry.setDescription("An entry describes the mapping between one CPE's MAC address and MAC address of the cable modem this CPE is attached to.")
rdnCmtsCpeMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 7, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: rdnCmtsCpeMac.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCpeMac.setDescription('This object is the MAC address of the CPE (host) that a cable modem is attached to.')
rdnCmtsCmMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 7, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmtsCmMac.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmMac.setDescription('This object returns the MAC address of the cable modem that a CPE (host) is attached to. If the CPE is not found being attached to any cable modem registered on this CMTS, the read of this object will return zero.')
rdnIfCmtsCmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8), )
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTable.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTable.setDescription('This table is an extension of the docsIfCmtsCmStatusTable. It provides additional information about the CM.')
rdnIfCmtsCmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1), )
docsIfCmtsCmStatusEntry.registerAugmentions(("RDN-CMTS-MIB", "rdnIfCmtsCmStatusEntry"))
rdnIfCmtsCmStatusEntry.setIndexNames(*docsIfCmtsCmStatusEntry.getIndexNames())
if mibBuilder.loadTexts: rdnIfCmtsCmStatusEntry.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusEntry.setDescription('Each entry of the table rdnIfCmtsCmStatusTable. Each entry provides some additional information about the CM.')
rdnIfCmtsCmStatusRegistrationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRegistrationTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRegistrationTime.setDescription('When read, this object will return the time in seconds since the modem registered. If the modem is unregistered, it will return ZERO')
rdnIfCmtsCmStatusTxUnicastKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTxUnicastKbytes.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTxUnicastKbytes.setDescription('When read, this object will return the number of unicast KBytes (1024 bytes) the CMTS has transmitted to the modem (Downstream direction). For offline modems this value is the total number of unicast KBytes when it was online. This object is never reset as long as the CMTS is up. It does not need to be restored across reboots . However, when the CM reregisters into a new spectrum group, this data must be restored. This is 32-bit version of rdnIfCmtsCmStatusTxUnicastExtKbytes, included to provide back compatability with SNMPv1 managers')
rdnIfCmtsCmStatusRxUnicastKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRxUnicastKbytes.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRxUnicastKbytes.setDescription('When read, this object will return the number of unicast KBytes (1024 bytes) the CMTS has received from the modem (Upstream direction). For offline modems this value is the total number of unicast KBytes when it was online. This object is never reset as long as the CMTS is up. It does not need to be restored across reboots. However, when the CM reregisters into a new spectrum group, this data must be restored. This is 32-bit version of rdnIfCmtsCmStatusRxUnicastExtKbytes, included to provide back compatability with SNMPv1 managers.')
rdnIfCmtsCmStatusTxUnicastExtKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTxUnicastExtKbytes.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusTxUnicastExtKbytes.setDescription('When read, this object will return the number of unicast KBytes (1024 bytes) the CMTS has transmitted to the modem (Downstream direction). For offline modems this value is the the total number of unicast KBytes when it was online. This object is never reset as long as the CMTS is up. It does not need to be restored across reboots . However, when the CM reregisters into a new spectrum group, this data must be restored.')
rdnIfCmtsCmStatusRxUnicastExtKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRxUnicastExtKbytes.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusRxUnicastExtKbytes.setDescription('When read, this object will return the number of unicast KBytes (1024 bytes) the CMTS has received from the modem (Upstream Direction). For offline modems this value is the the total number of unicast KBytes when it was online. This object is never reset as long as the CMTS is up. It does not need to be restored across reboots. However, when the CM reregisters into a new spectrum group, this data must be restored.')
rdnIfCmtsCmStatusSpectrumGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusSpectrumGroupName.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusSpectrumGroupName.setDescription('When read, this object will return the spectrum group name. If data not available, return NULL string')
rdnIfCmtsCmStatusUpstreamPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusUpstreamPort.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusUpstreamPort.setDescription('The Upstream Port Number the modem is using. For offline modems this value is meaningless.')
rdnIfCmtsCmStatusDownStreamPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusDownStreamPort.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusDownStreamPort.setDescription('The downstream port number the modem is using, For offline modems this value is meaningless.')
rdnIfCmtsCmStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("init-o", 1), ("init-t", 2), ("init-r1", 3), ("init-r2", 4), ("init-rc", 5), ("dhcp-d", 6), ("dhcp-o", 7), ("dhcp-req", 8), ("dhcp-ack", 9), ("online", 10), ("online-d", 11), ("online-un", 12), ("online-pk", 13), ("online-pt", 14), ("reject-m", 15), ("reject-c", 16), ("reject-r", 17), ("reject-pk", 18), ("reject-pt", 19), ("offline", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusValue.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusValue.setDescription('Current Cable Modem connectivity state. Returned status information is the CM status as assumed by the CMTS, and indicates the following events: init-o(1) Option file transfer was started. init-t(2) Time-of-day (TOD) exchange was started. init-r1(3) CM sent initial ranging parameters. init-r2(4) CM is ranging. init-rc(5) Ranging is complete. dhcp-d (6) DHCP Discover was sent by CM. dhcp-o (7) DHCP Offer was received. dhcp-req(8) DHCP Request was sent by CM. dhcp-ack(9) DHCP Ack was received, IP address was assigned by DHCP server. online(10) CM registered; enabled for data. online-d(11) CM registered, but network access for the CM is disabled. online-un(12) CM registered, but not enabled data. Fail to verify modems Identity by BPI module. online-pk(13) CM registered; baseline privacy interface (BPI) enabled, and key encryption key (KEK)is assigned. online-pt(14) CM registered; BPI enabled, and traffic encryption key (TEK) is assigned. reject-m(15) CM did attempt to register; registration was refused due to bad mic. reject-c(16) CM did attempt to register; registration was refused due to bad COS. reject-r(17) CM did attempt to register, registration was refused due to unavailable resource. reject-pk(18) KEK modem key assignment is rejected. reject-pt(19) TEK modem key assignment is rejected. offline(20) CM is considered to be offline.')
rdnIfCmtsCmStatusDSBondingGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusDSBondingGroupId.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusDSBondingGroupId.setDescription('The downstream channel bonding group ID of primary service flow. This value is zero if not registered for channel bonding.')
rdnIfCmtsCmStatusOnlineTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusOnlineTimes.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusOnlineTimes.setDescription('Number of times a modem has gone from offline to online since the modem was first seen ranging.')
rdnIfCmtsCmStatusPercentOnline = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusPercentOnline.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusPercentOnline.setDescription('A percentage of time the modem has been in an online state since the modem was first seen ranging. This value is displayed as (percent value x 100) in order to show precision. i.e. 99.34% will be displayed as 9934.')
rdnIfCmtsCmStatusMinOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 13), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMinOnlineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMinOnlineTime.setDescription('Shortest period of time this modem has been online since the modem was first seen ranging.')
rdnIfCmtsCmStatusAvgOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 14), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusAvgOnlineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusAvgOnlineTime.setDescription('Average period of time this modem has been online since the modem was first seen ranging.')
rdnIfCmtsCmStatusMaxOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 15), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMaxOnlineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMaxOnlineTime.setDescription('Longest period of time this modem has been online since the modem was first seen ranging.')
rdnIfCmtsCmStatusMinOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 16), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMinOfflineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMinOfflineTime.setDescription('Shortest period of time this modem has been offline since the modem was first seen ranging.')
rdnIfCmtsCmStatusAvgOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 17), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusAvgOfflineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusAvgOfflineTime.setDescription('Average period of time this modem has been offline since the modem was first seen ranging.')
rdnIfCmtsCmStatusMaxOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 8, 1, 18), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMaxOfflineTime.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmStatusMaxOfflineTime.setDescription('Longest period of time this modem has been offline since the modem was first seen ranging.')
rdnModemDeregReason = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("normal", 1), ("operatorReset", 2), ("operatorDisabled", 3), ("operatorDeleted", 4), ("transmissionFailed", 5), ("transmissionDisabled", 6), ("transmissionDeleted", 7), ("servingGroupChanged", 8), ("receiverFailed", 9), ("receiverDisabled", 10), ("receiverDeleted", 11), ("channelDeleted", 12), ("channelErrors", 13), ("incompleteReg", 14), ("profileUpdateComplete", 15), ("skeyFailure", 16), ("dnChanChangeFailure", 17), ("noDeregReason", 18), ("powerTolerance", 19), ("freqTolerance", 20), ("timingTolerance", 21), ("rangingTolerance", 22), ("noResponseUCC", 23)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnModemDeregReason.setStatus('current')
if mibBuilder.loadTexts: rdnModemDeregReason.setDescription('Modem Deregistration Reason normal - the CMTS has lost contact with the modem. operatorReset - reset by the operator operatorDisabled - operator has disabled the modem operatorDeleted - was removed from the system transmissionFailed - the transmitter communicating to the modem has failed transmissionDisabled - the transmitter communicating to the modem has been disabled transmissionDeleted - the transmitter communicating to the modem has been deleted servingGroupChanged - the assignment of the serving groups for the modem has changed receiverFailed - the receiver communicating with the modem has failed receiverDisabled - the receiver communicating with the modem has been disabled receiverDeleted - the receiver communicating with the modem has beeb deleted channelDeleted - a channel has changed on the receiver that has caused the modem to deregister channelErrors - deregistered due to unacceptable amount of channel errors incompleteReg - deregistered due to incomplete registration profileUpdateComplete - deregistered after profile update skeyFailure - deregistered due to session key failure dnChanChangeFailure - due to downstream transmission channel change failure noDeregReason - no deregistration reason available powerTolerance - power ranging corrections were out of tolerance freqTolerance - frequency ranging corrections were out of tolerance timingTolerance - timing ranging correction were out of tolerance rangingTolerance - multiple ranging corrections were out of tolerance noResponseUCC - modem did not respond to the UCC request This is a place holder for the modem deregistration reason. This should return ZERO when read. This just allows us to include a deregistration reason in the modem deregistration trap varbind. ')
rdnModemRegIndex = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnModemRegIndex.setStatus('current')
if mibBuilder.loadTexts: rdnModemRegIndex.setDescription('This is place holder for CMId which is the index to the CM table. This table WILL contain the CM information. Right now the table is not implemented yet. When read it returns ZERO. But in future this should be part of the CM information table and this should be removed from here. This is required now to support the varbind in Registration and Deregistration Traps. ')
rdnCmToCpeTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12), )
if mibBuilder.loadTexts: rdnCmToCpeTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeTable.setDescription('This table provides the information about the CPEs attached to the CM.')
rdnCmToCpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12, 1), ).setIndexNames((0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"), (0, "RDN-CMTS-MIB", "rdnCmToCpeIndex"))
if mibBuilder.loadTexts: rdnCmToCpeEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeEntry.setDescription('An entry of the table rdnCmToCpeTable. Each entry provides the CPE Mac and IP addresses.')
rdnCmToCpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rdnCmToCpeIndex.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeIndex.setDescription('Index Value for an individual CPE, This index value is not guaranteed to remain same during CMTS uptime. ')
rdnCmToCpeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmToCpeMacAddress.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeMacAddress.setDescription('The Mac Address of the CPE attached to the CM')
rdnCmToCpeIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmToCpeIpAddress.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeIpAddress.setDescription('The IP Address of the CPE attached to the CM')
rdnCmToCpeIPv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 12, 1, 4), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCmToCpeIPv6Addr.setStatus('current')
if mibBuilder.loadTexts: rdnCmToCpeIPv6Addr.setDescription('This attribute represents the IPv6 address of the CPE. If the CPE has no IPv6 address assigned, or the Internet address is unknown, the value of this attribute is the all zeros address.')
rdnCmtsCmRegisteredTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCmRegisteredTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmRegisteredTrapEnable.setDescription('This object controls SNMP traps for CM registration and deregistration traps (rdnCmtsCmRegisteredNotification and rdnCmtsCmDeregisteredNotification). If its value is set to enabled(1), then traps are generated. If the value is disabled(2), then traps are not generated. By default, this object has the value enabled(1). ')
rdnCmtsCardType = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("domestic", 1), ("japan", 2))).clone('domestic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCardType.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCardType.setDescription('This object toggles the CMTS card type between Domestic and Japan. When set to Japan card type, upstream frequency range of the CMTS card will change from 10MHz to 55MHz. Downstream RF frequency will change from 555MHz to 557MHz. By default, this object has the value domestic(1). ')
rdnRQueryCmtsCmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15), )
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusTable.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusTable.setDescription(" The Remote Query feature allows the BSR to act as an SNMP Manager, periodically collecting statistics from cable modems, using SNMP get/next requests. The rdnRQueryCmtsCmStatusTable displays the collected statistics. Remote Query polling is enabled and configured using the BSR's command line interface. The frequency of polling should be selected with care, so as not to introduce excessive overhead that would degrade performance. ")
rdnRQueryCmtsCmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1), ).setIndexNames((0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"))
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusEntry.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusEntry.setDescription('An entry in the rdnRQueryCmtsCmStatusTable. Each entry represents a set physical-layer status values for a specific cable modem. The table is indexed by a DOCSIS cable modem index value (docsIfCmtsCmStatusIndex). ')
rdnRQueryCmtsCmDownChannelPower = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 1), TenthdBmV()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryCmtsCmDownChannelPower.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmtsCmDownChannelPower.setDescription("The last polled value of the CM's docsIfdownChannelPower MIB object, the received downstream power level at the CM, in TenthdbMv. DOCSIS specifies this to be between +5.0 and - 15.0 dBmv. ")
rdnRQueryCmStatusTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 2), TenthdBmV()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryCmStatusTxPower.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmStatusTxPower.setDescription("The last polled value of the CM's docsIfCmStatusTxPower MIB object, the CMs upstream transmit power level, in TenthdBmv. DOCSIS specifies this to be between 8.0 and 54.0 dbMv. ")
rdnRQueryUpChannelTxTimingOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryUpChannelTxTimingOffset.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryUpChannelTxTimingOffset.setDescription("The last polled value of the CM's docsIfUpChannelTxTimingOffset MIB object. This is the CM's estimate of the current round trip time obtained from the ranging offset (initial ranging offset + ranging offset adjustments). The CM uses this offset for timing upstream transmissions to ensure synchronized arrivals at the CMTS. Units are in terms of (6.25 microseconds/64). ")
rdnRQuerySigQSignalNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 4), TenthdB()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQuerySigQSignalNoise.setStatus('current')
if mibBuilder.loadTexts: rdnRQuerySigQSignalNoise.setDescription("The last polled value of the CM's docsIfSigQSignalNoise MIB object, the downstream signal to noise ratio in TenthdB. ")
rdnRQuerySigQMicroreflections = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('dBc').setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQuerySigQMicroreflections.setStatus('current')
if mibBuilder.loadTexts: rdnRQuerySigQMicroreflections.setDescription("The last polled value of the CM's docsIfSigQMicroreflections MIB object, which is its estimate of the total microreflections including in-channel responses perceived on the upstream interface, measured in dBc below the signal level. ")
rdnRQueryPollTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 15, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryPollTime.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryPollTime.setDescription('The value of sysUpTime at the time when the rdnRQueryCmtsCmStatusTable values for this CM were last polled. ')
rdnCmtsServiceClassObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19))
rdnCmtsServiceClassTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1), )
if mibBuilder.loadTexts: rdnCmtsServiceClassTable.setReference(' ')
if mibBuilder.loadTexts: rdnCmtsServiceClassTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassTable.setDescription('This table describes the set of Motorola-QoS Services in a CMTS')
rdnCmtsServiceClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1), ).setIndexNames((0, "RDN-CMTS-MIB", "rdnCmtsServiceClassName"))
if mibBuilder.loadTexts: rdnCmtsServiceClassEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassEntry.setDescription('List of attributes of private service class.')
rdnCmtsServiceClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: rdnCmtsServiceClassName.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassName.setDescription('This object is the Service Class Name. DOCSIS specifies that the maximum size is 15 printable ASCII characters with a terminating zero. The terminating Zero is not represented in this DisplayString syntax object.')
rdnCmtsServiceClassMab = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsServiceClassMab.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassMab.setDescription('This object is get/set Maximum Assigned Bandwidth(MAB) for specified ServiceClass.')
rdnCmtsServiceClassCap = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsServiceClassCap.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassCap.setDescription('This object is get/set Configured Active Percent(CAP) for specified ServiceClass.')
rdnCmtsServiceClassSchedulingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsServiceClassSchedulingPriority.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassSchedulingPriority.setDescription('This object is to get/set Scheduling Priority for specified ServiceClass.')
rdnCmtsServiceClassAdmittedBWThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsServiceClassAdmittedBWThreshold.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassAdmittedBWThreshold.setDescription('This object is to get/set Admitted Bandwidth Threshold for specified ServiceClass.')
rdnCmtsServiceClassAllowShare = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 19, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsServiceClassAllowShare.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsServiceClassAllowShare.setDescription('This object is to get/set allow bandwidth share with other class for specified ServiceClass.')
rdnUgsStatsWindow = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 120), )).clone(60)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnUgsStatsWindow.setStatus('current')
if mibBuilder.loadTexts: rdnUgsStatsWindow.setDescription('The sliding, sampling time window to collect statistics for the rdnServiceClassStatsTable. This timer interval is global, applying to all service classes and chassis slots. A value of zero disables the timer. ')
rdnCableUgsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17), )
if mibBuilder.loadTexts: rdnCableUgsStatsTable.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsStatsTable.setDescription('This table contains statistics summarizing UGS flows per CMTS slot/port on the BSR. ')
rdnCableUgsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rdnCableUgsStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsStatsEntry.setDescription('A row in the rdnCableUgsStatsTable. Each row contains a set of statistics, totaled for all UGS flows on a particular upstream port. The table is indexed by values of ifIndex that are associated with CMTS upstream ports (ifType = 129). This includes the DefUGS and DefUGSAD service classes, plus any other UGS classes that the operator may have configured. ')
rdnCableUgsStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsStatsSlot.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsStatsSlot.setDescription('The physical chasis slot number relative to the containing card or chassis, to which this row of UGS statistics is applying. ')
rdnCableUgsStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsStatsPort.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsStatsPort.setDescription('Chassis port number, on the associated card, to which this row of UGS statistics is applying. ')
rdnCableUgsCurrentTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsCurrentTotalFlows.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsCurrentTotalFlows.setDescription('Snap shot of the current, total number of UGS flows that are active, for the associated ifIndex. ')
rdnCableUgsMaxFlowsLastFiveMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsMaxFlowsLastFiveMinutes.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsMaxFlowsLastFiveMinutes.setDescription('Maximum number of UGS flows that were active, during the last 5 minutes, for the associated ifIndex. ')
rdnCableUgsAvFlowsLastFiveMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsAvFlowsLastFiveMinutes.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsAvFlowsLastFiveMinutes.setDescription('Average number of UGS flows that were active, during the last 5 minutes, for the associated ifIndex. ')
rdnCableUgsMinFlowsLastFiveMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsMinFlowsLastFiveMinutes.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsMinFlowsLastFiveMinutes.setDescription('Minimum number of UGS flows that were active, during the last 5 minutes, for the associated ifIndex. ')
rdnCableUgsMaxFlowsLastWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsMaxFlowsLastWindow.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsMaxFlowsLastWindow.setDescription('Maximum number of UGS flows that were active, during the rdnUgsStatsWindow, for the associated ifIndex. ')
rdnCableUgsAvFlowsLastWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsAvFlowsLastWindow.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsAvFlowsLastWindow.setDescription('Average number of UGS flows that were active, during the rdnUgsStatsWindow, for the associated ifIndex. ')
rdnCableUgsMinFlowsLastWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableUgsMinFlowsLastWindow.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsMinFlowsLastWindow.setDescription('Minimum number of UGS flows that were active, during the rdnUgsStatsWindow, for the associated ifIndex interface. ')
rdnCableUgsResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 17, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCableUgsResetStats.setStatus('current')
if mibBuilder.loadTexts: rdnCableUgsResetStats.setDescription("A 'set' of this object to TRUE(1) will cause all statistics in the row to be reset to zero. This object will always return FALSE(2) when read. ")
rdnServiceClassStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18), )
if mibBuilder.loadTexts: rdnServiceClassStatsTable.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsTable.setDescription('This table contains statistics summarizing non-bonded flows within Service Classes on the BSR. ')
rdnServiceClassStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DOCS-QOS3-MIB", "docsQosServiceClassName"))
if mibBuilder.loadTexts: rdnServiceClassStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsEntry.setDescription('A row in the rdnServiceClassStatsTable. Each row contains a set of statistics related to flows within a particular service class, and associated with a particular value of ifIndex. The table is indexed by: 1) ifIndex, associated with a CMTS upstream port (ifType = 129) or CMTS downstream port (ifType = 128). The rdnServiceClassStatsTable applies only to non-bonded downstream channels. For bonded downstreams, please refer to the rdnServiceClassBondingStatsTable 2) docsQosServiceClassName = Service Class Name. ')
rdnServiceClassStatsIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 1), IfDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassStatsIfDirection.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsIfDirection.setDescription('Specifies whether the associated service class template applies to upstream or downstream service flows. ')
rdnServiceClassStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassStatsSlot.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsSlot.setDescription('The physical chasis slot number relative to the containing card or chassis, to which this row of service class statistics is applying. ')
rdnServiceClassStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassStatsPort.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsPort.setDescription('Chassis port number, on the associated card, to which this row of service class statistics is applying. ')
rdnServiceClassStatsTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassStatsTotalPackets.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsTotalPackets.setDescription('Count of total packets that have been transmitted, for the associated ifIndex and service class. ')
rdnServiceClassStatsTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassStatsTotalBytes.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassStatsTotalBytes.setDescription('Count of total bytes that have been transmitted, for the associated ifIndex and service class. ')
rdnServiceClassCurrentTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassCurrentTotalFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassCurrentTotalFlows.setDescription('Snap shot of the current, total number of flows that are admitted and active, for the associated ifIndex and service class. ')
rdnServiceClassDeferredFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassDeferredFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassDeferredFlows.setDescription('Count of deferred flows for the associated ifIndex and service class. ')
rdnServiceClassRestrictedFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassRestrictedFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassRestrictedFlows.setDescription('Count of restricted flows for the associated ifIndex and service class. ')
rdnServiceClassRejectedFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassRejectedFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassRejectedFlows.setDescription('Count of rejected flows for the associated ifIndex and service class. ')
rdnServiceClassBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBandWidth.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBandWidth.setDescription('Admitted bandwidth, in bits per second, for this ifIndex and service class. ')
rdnServiceClassResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 18, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnServiceClassResetStats.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassResetStats.setDescription("A 'set' of this object to TRUE(1) will cause all statistics in the row to be reset to zero. This applies to BOTH non-bonded and bonded statistics for the specified ifIndex and service class.a This object will always return FALSE(2) when read. ")
rdnRQueryCmtsCmStatusExtTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 20), )
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusExtTable.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusExtTable.setDescription(' This is an extension of the rdnRQueryCmtsCmStatusTable. ')
rdnRQueryCmtsCmStatusExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 20, 1), )
rdnRQueryCmtsCmStatusEntry.registerAugmentions(("RDN-CMTS-MIB", "rdnRQueryCmtsCmStatusExtEntry"))
rdnRQueryCmtsCmStatusExtEntry.setIndexNames(*rdnRQueryCmtsCmStatusEntry.getIndexNames())
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusExtEntry.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryCmtsCmStatusExtEntry.setDescription('An entry in the rdnRQueryCmtsCmStatusExtTable. The table is indexed by a rdnRQueryCmtsCmStatusEntry. ')
rdnRQuerySwCurrentVers = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 20, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQuerySwCurrentVers.setStatus('current')
if mibBuilder.loadTexts: rdnRQuerySwCurrentVers.setDescription('The model and software version of this CM as parsed from its sysDescr. ')
rdnRQueryServerConfigFile = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 20, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryServerConfigFile.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryServerConfigFile.setDescription('The configuration file of the modem. ')
rdnIfCmtsCmTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 21), )
if mibBuilder.loadTexts: rdnIfCmtsCmTable.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmTable.setDescription('This table is an extension of the docsIfCmtsCmTable. It provides additional information about the CM.')
rdnIfCmtsCmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 21, 1), )
docsIfCmtsCmStatusEntry.registerAugmentions(("RDN-CMTS-MIB", "rdnIfCmtsCmEntry"))
rdnIfCmtsCmEntry.setIndexNames(*docsIfCmtsCmStatusEntry.getIndexNames())
if mibBuilder.loadTexts: rdnIfCmtsCmEntry.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmEntry.setDescription('Each entry of the table rdnIfCmtsCmTable. Each entry Provides some additional information about the CM.')
rdnIfCmtsCmMaxCpeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnIfCmtsCmMaxCpeNumber.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmMaxCpeNumber.setDescription(' The maximum number of permitted CPEs connecting to the modem. The value 0 means no maximum limit. By default maximum of 16 CPEs are allowed behind a single CM. Setting the value will not affect the already connected CPEs to the modem')
rdnIfCmtsCmCurrCpeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 21, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsCmCurrCpeNumber.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsCmCurrCpeNumber.setDescription(' The current number of CPEs connecting to the modem. The value 0 means no hosts connecting to the modem')
rdnIfCmtsMTAOnlyStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23), )
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusTable.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusTable.setDescription('A set of objects in the CMTS, maintained for each MTA ONLY connected to this CMTS.')
rdnIfCmtsMTAOnlyStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1), ).setIndexNames((0, "RDN-CMTS-MIB", "rdnIfCmtsMTAOnlyStatusIndex"))
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusEntry.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusEntry.setDescription('Status information for a single MTA. An entry in this table exists for each Cable Modem Only that is connected to the CMTS implementing this table.')
rdnIfCmtsMTAOnlyStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusIndex.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusIndex.setDescription('Index value to uniquely identify an entry in this table. For an individual MTA Only, this index value should not change during CMTS uptime.')
rdnIfCmtsMTAOnlyStatusMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMacAddress.setReference('Document [25] from References, Section 8.2.2.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMacAddress.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMacAddress.setDescription('MAC address of this MTA. If the MTA has multiple MAC addresses, this is the MAC address associated with the Cable interface.')
rdnIfCmtsMTAOnlyStatusIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusIpAddress.setDescription('IP address of this MTA. If the MTA has no IP address assigned, or the IP address is unknown, this object returns a value of 0.0.0.0. If the MTA has multiple IP addresses, this object returns the IP address associated with the Cable interface. This object has been deprecated and replaced by docsIfCmtsCmStatusInetAddressType and docsIfCmtsCmStatusInetAddress, to enable IPv6 addressing in the future.')
rdnIfCmtsMTAOnlyStatusDownChannelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusDownChannelIfIndex.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusDownChannelIfIndex.setDescription('IfIndex of the downstream channel this MTA is connected to. If the downstream channel is unknown, this object returns a value of zero.')
rdnIfCmtsMTAOnlyStatusUpChannelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUpChannelIfIndex.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUpChannelIfIndex.setDescription('IfIndex of the upstream channel this MTA is connected to. If the upstream channel is unknown, this object returns a value of zero.')
rdnIfCmtsMTAOnlyStatusRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 6), TenthdBmV()).setUnits('dBmV').setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusRxPower.setReference('Document [25] from References, Table 6-11.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusRxPower.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusRxPower.setDescription('The receive power as perceived for upstream data from this MTA. If the receive power is unknown, this object returns a value of zero.')
rdnIfCmtsMTAOnlyStatusTimingOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusTimingOffset.setReference('Document [25] from References, Section 6.2.18.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusTimingOffset.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusTimingOffset.setDescription('A measure of the current round trip time for this MTA. Used for timing of CM upstream transmissions to ensure synchronized arrivals at the CMTS. Units are in terms of 6.25 microseconds/(64*256). Returns zero if the value is unknown.')
rdnIfCmtsMTAOnlyStatusEqualizationData = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusEqualizationData.setReference('Document [25] from References, Figure 8-23.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusEqualizationData.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusEqualizationData.setDescription('Equalization data for this MTA. Returns an empty string if the value is unknown or if there is no equalization data available or defined.')
rdnIfCmtsMTAOnlyStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("ranging", 2), ("rangingAborted", 3), ("rangingComplete", 4), ("ipComplete", 5), ("registrationComplete", 6), ("accessDenied", 7), ("operational", 8), ("registeredBPIInitializing", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusValue.setReference('Document [25] from References, Section 11.2.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusValue.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusValue.setDescription('Current MTA connectivity state, as specified in the RF Interface Specification. Returned status information is the CM status as assumed by the CMTS, and indicates the following events: other(1) Any state other than below. ranging(2) The CMTS has received an Initial Ranging Request message from the CM, and the ranging process is not yet complete. rangingAborted(3) The CMTS has sent a Ranging Abort message to the CM. rangingComplete(4) The CMTS has sent a Ranging Complete message to the CM. ipComplete(5) The CMTS has received a DHCP reply message and forwarded it to the CM. registrationComplete(6) The CMTS has sent a Registration Response message to the CM. accessDenied(7) The CMTS has sent a Registration Aborted message to the CM. operational(8) -- deprecated value If Baseline Privacy is enabled for the CM, the CMTS has completed Baseline Privacy initialization. If Baseline Privacy is not enabled, equivalent to registrationComplete. registeredBPIInitializing(9) Baseline Privacy is enabled, CMTS is in the process of completing the Baseline Privacy initialization. This state can last for a significant time in the case of failures during The process. After Baseline Privacy initialization Complete, the CMTS will report back the value registrationComplete(6). The CMTS only needs to report states it is able to detect.')
rdnIfCmtsMTAOnlyStatusUnerroreds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUnerroreds.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUnerroreds.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUnerroreds.setDescription('Codewords received without error from this MTA.')
rdnIfCmtsMTAOnlyStatusCorrecteds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusCorrecteds.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusCorrecteds.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusCorrecteds.setDescription('Codewords received with correctable errors from this MTA.')
rdnIfCmtsMTAOnlyStatusUncorrectables = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUncorrectables.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUncorrectables.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusUncorrectables.setDescription('Codewords received with uncorrectable errors from this MTA.')
rdnIfCmtsMTAOnlyStatusSignalNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 13), TenthdB()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusSignalNoise.setReference('Document [25] from References, Tables 4-1 and 4-2.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusSignalNoise.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusSignalNoise.setDescription('Signal/Noise ratio as perceived for upstream data from this MTA. If the Signal/Noise is unknown, this object returns a value of zero.')
rdnIfCmtsMTAOnlyStatusMicroreflections = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('dBc').setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMicroreflections.setReference('Document [25] from References, Tables 4-1 and 4-2')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMicroreflections.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusMicroreflections.setDescription('Total microreflections including in-channel response as perceived on this interface, measured in dBc below the signal level. This object is not assumed to return an absolutely accurate value, but should give a rough indication of microreflections received on this interface. It is up to the implementer to provide information as accurate as possible.')
rdnIfCmtsMTAOnlyStatusExtUnerroreds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUnerroreds.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUnerroreds.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUnerroreds.setDescription('Codewords received without error from this MTA.')
rdnIfCmtsMTAOnlyStatusExtCorrecteds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtCorrecteds.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtCorrecteds.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtCorrecteds.setDescription('Codewords received with correctable errors from this MTA.')
rdnIfCmtsMTAOnlyStatusExtUncorrectables = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUncorrectables.setReference('Document [25] from References, Section 6.2.5.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUncorrectables.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusExtUncorrectables.setDescription('Codewords received with uncorrectable errors from this MTA.')
rdnIfCmtsMTAOnlyStatusDocsisRegMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 18), DocsisQosVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusDocsisRegMode.setReference('Document [25] from References, Annex G.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusDocsisRegMode.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusDocsisRegMode.setDescription('Indication whether the MTA has registered using 1.0 Class of Service or 1.1 Quality of Service. This object mirrors docsIfCmtsCmStatusDocsisMode from the docsIfExt mib.')
rdnIfCmtsMTAOnlyStatusModulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 19), DocsisUpstreamType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusModulationType.setReference('Document [25] from References, Table 8-19.')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusModulationType.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusModulationType.setDescription('Indicates modulation type currently used by the MTA. Since this object specifically identifies PHY mode, the shared type is not permitted. If the upstream channel is unknown, this object returns a value of zero.')
rdnIfCmtsMTAOnlyStatusInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 20), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusInetAddressType.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusInetAddressType.setDescription('The type of internet address of docsIfCmtsCmStatusInetAddress. If the MTA Internet address is unassigned or unknown, then the value of this object is unknown(0).')
rdnIfCmtsMTAOnlyStatusInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 21), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusInetAddress.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusInetAddress.setDescription('Internet address of this MTA. If the MTA has no Internet address assigned, or the Internet address is unknown, the value of this object is the empty string. If the MTA has multiple Internet addresses, this object returns the Internet address associated with the Cable (i.e. RF MAC) interface.')
rdnIfCmtsMTAOnlyStatusValueLastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 23, 1, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusValueLastUpdate.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsMTAOnlyStatusValueLastUpdate.setDescription('The value of sysUpTime when docsIfCmtsCmStatusValue was last updated.')
rdnServiceClassBondingStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24), )
if mibBuilder.loadTexts: rdnServiceClassBondingStatsTable.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsTable.setDescription('This table contains statistics summarizing flows within Service Classes for bonded upstreams and downstreams on the BSR. For non-bonded upstream/downstream stats, please refer to rdnServiceClassStatsTable')
rdnServiceClassBondingStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RDN-CMTS-MIB", "rdnServiceClassBondingStatsIfDirection"), (0, "DOCS-QOS3-MIB", "docsQosServiceClassName"), (0, "RDN-CMTS-MIB", "rdnServiceClassBondingStatsMacIfIndex"), (0, "RDN-CMTS-MIB", "rdnServiceClassBondingStatsGroupId"))
if mibBuilder.loadTexts: rdnServiceClassBondingStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsEntry.setDescription("A row in the rdnServiceClassBondingStatsTable. Each row contains a set of statistics related to flows within a particular service class, and associated with a particular value of ifIndex. The table is indexed by: 1) ifIndex, associated with a bonded CMTS downstream (ifType = 128) or upstream (ifType = 129) 2) rdnServiceClassBondingStatsIfDirection (upstream or downstream) 3) docsQosServiceClassName = Service Class Name. 4) rdnServiceClassBondingStatsMacIfIndex, the macIfIndex under which the downstream or upstream channel's bonding group is configured. 5) rdnServiceClassBondingStatsGroupId, the Motorola proprietary bonding group id. ")
rdnServiceClassBondingStatsMacIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rdnServiceClassBondingStatsMacIfIndex.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsMacIfIndex.setDescription("The MAC interface index under which this downstream channel's bonding group is configured. This will be an ifType of docsCableMaclayer(127). ")
rdnServiceClassBondingStatsGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: rdnServiceClassBondingStatsGroupId.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsGroupId.setDescription('The downstream or upstream bonding group identifier.')
rdnServiceClassBondingStatsIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 3), IfDirection())
if mibBuilder.loadTexts: rdnServiceClassBondingStatsIfDirection.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsIfDirection.setDescription('Specifies whether the associated service class template applies to downstream(1) or upstream(2) service flows. ')
rdnServiceClassBondingStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingStatsSlot.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsSlot.setDescription('The physical chasis slot number relative to the containing card or chassis, to which this row of service class statistics is applying. ')
rdnServiceClassBondingStatsChan = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingStatsChan.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingStatsChan.setDescription('Channel number on the associated card, to which this row of service class statistics is applying. ')
rdnServiceClassBondingCurrentTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingCurrentTotalFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingCurrentTotalFlows.setDescription('Snap shot of the current, total number of flows that are admitted and active, for the associated ifIndex and service class. ')
rdnServiceClassBondingDeferredFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingDeferredFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingDeferredFlows.setDescription('Count of deferred flows for the associated ifIndex and service class. ')
rdnServiceClassBondingRestrictedFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingRestrictedFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingRestrictedFlows.setDescription('Count of restricted flows for the associated ifIndex and service class. ')
rdnServiceClassBondingRejectedFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingRejectedFlows.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingRejectedFlows.setDescription('Count of rejected flows for the associated ifIndex and service class. ')
rdnServiceClassBondingBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 24, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnServiceClassBondingBandWidth.setStatus('current')
if mibBuilder.loadTexts: rdnServiceClassBondingBandWidth.setDescription('Admitted bandwidth, in bits per second, for this ifIndex and service class. ')
rdnCmtsCmResetByIpv6Addr = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 25), InetAddressIPv6()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCmtsCmResetByIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmResetByIpv6Addr.setDescription('The CM IPv6 address that the operator wants to reset. When this object Is set, it will cause the CMTS to reset that CM. When this object is Read it will return zero')
rdnCmtsMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 4))
rdnCmtsMibNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0))
rdnCmtsMibNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 4, 1))
rdnCmtsCmRegisteredNotification = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 1)).setObjects(("DOCS-IF-MIB", "docsIfCmtsCmStatusDocsisRegMode"), ("DOCS-IF-MIB", "docsIfCmtsCmStatusMacAddress"), ("DOCS-IF-MIB", "docsIfCmtsCmStatusIpAddress"), ("DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusIPv6Addr"), ("DOCS-IF-MIB", "docsIfUpChannelId"), ("DOCS-IF-MIB", "docsIfDownChannelId"), ("RDN-CMTS-MIB", "rdnModemRegIndex"), ("RDN-CABLE-SPECTRUM-GROUP-MIB", "rdnSpectrumGroupName"))
if mibBuilder.loadTexts: rdnCmtsCmRegisteredNotification.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmRegisteredNotification.setDescription('An event to report the registration of a modem. The values of docsDevEvLevel, docsDevId, and DocsDevEvText are from the entry which logs this event in the docsDevEventTable, DocsIfCmtsCmStatusDocsisMode and docsIfCmtsCmStatusMacAddress indicate the docsis version and the MAC address of the registered CM.The docsIfCmtsCmStatusIpAddress indicates the ip address of the registered modem docsIfDocsisCapability indicate the docsis version of the CMTS , docsIfUpChannelId, docsIfDownChannelId gives the upstream and downstream channel id respectively for the CM. rdnSpectrumGroupName gives the spectrum group name.')
rdnCmtsCmDeregisteredNotification = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 2)).setObjects(("DOCS-IF-MIB", "docsIfCmtsCmStatusDocsisRegMode"), ("DOCS-IF-MIB", "docsIfCmtsCmStatusMacAddress"), ("DOCS-IF-MIB", "docsIfUpChannelId"), ("DOCS-IF-MIB", "docsIfDownChannelId"), ("RDN-CMTS-MIB", "rdnModemRegIndex"), ("RDN-CMTS-MIB", "rdnModemDeregReason"), ("RDN-CABLE-SPECTRUM-GROUP-MIB", "rdnSpectrumGroupName"))
if mibBuilder.loadTexts: rdnCmtsCmDeregisteredNotification.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsCmDeregisteredNotification.setDescription('An event to report the registration of a modem. The values of docsDevEvLevel, docsDevId, and DocsDevEvText are from the entry which logs this event in the docsDevEventTable, DocsIfCntsCmStatusDocsisMode and docsIfCmtsCmStatusMacAddress indicate the docsis version and the MAC address of the registered CM. docsIfDocsisCapability indicate the docsis version of the CMTS , docsIfUpChannelId, docsIfDownChannelId gives the upstream and downstream channel id respectively for the CM. rdnSpectrumGroupId gives the spectrum group name.')
rdnCmtsUpstreamIfLinkUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 3)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"), ("IF-MIB", "ifType"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"), ("RDN-CABLE-SPECTRUM-GROUP-MIB", "rdnSpectrumGroupName"))
if mibBuilder.loadTexts: rdnCmtsUpstreamIfLinkUpTrap.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpstreamIfLinkUpTrap.setDescription('This trap provides more information than the standard linkUp trap, by adding varbinds to include the spectrum group name, ifDescr, and ifType. ')
rdnCmtsUpstreamIfLinkDownTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 4)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"), ("IF-MIB", "ifType"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"), ("RDN-CABLE-SPECTRUM-GROUP-MIB", "rdnSpectrumGroupName"))
if mibBuilder.loadTexts: rdnCmtsUpstreamIfLinkDownTrap.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpstreamIfLinkDownTrap.setDescription('This trap provides more information than the standard linkDown trap, by adding varbinds to include the spectrum group name, ifDescr, and ifType. ')
rdnRQueryPollDoneNotification = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 5)).setObjects(("RDN-CMTS-MIB", "rdnRQueryLastPollStartTime"), ("RDN-CMTS-MIB", "rdnRQueryLastPollStopTime"))
if mibBuilder.loadTexts: rdnRQueryPollDoneNotification.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryPollDoneNotification.setDescription('This notification indicates that the BSR has completed a Remote Query polling cycle, collect information for all objects in the rdnRQueryCmtsCmStatusTable, for all registered cable modems. The rdnRQueryLastPollStartTime and rdnRQueryLastPollStopTime respectively indicate the beginning and ending times for the polling cycle. ')
rdnPktDQoSAdmittedBwThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 2, 4, 0, 6)).setObjects(("RDN-CMTS-MIB", "rdnPktDQoSAdmittedBwThresholdReason"), ("RDN-PKTCABLE-GROUP-MIB", "rdnPktDQoSClassName"))
if mibBuilder.loadTexts: rdnPktDQoSAdmittedBwThresholdTrap.setStatus('current')
if mibBuilder.loadTexts: rdnPktDQoSAdmittedBwThresholdTrap.setDescription('This notification indicates that the admitted bandwidth has either exceeded the admitted bandwidth threshold or cleared of the condition since it is within the admitted bandwidth threshold. The reason code and the Service Class name provide detailed information regarding this trap.')
rdnRQueryLastPollStartTime = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 4, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryLastPollStartTime.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryLastPollStartTime.setDescription('The value of sysUpTime when the BSR last began a Remote Query polling cycle, to read values for the rdnRQueryCmtsCmStatusTable from registered cable modems. This object has an initial value of zero, if no polls have been sent. Once that it has been set to a nonzero value, it is never reset to zero again for any reason, unless the BSR reboots. If rdnRQueryLastPollStartTime is greater than rdnRQueryLastPollStopTime, it means that a new polling cycle is in progress. ')
rdnRQueryLastPollStopTime = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 4, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRQueryLastPollStopTime.setStatus('current')
if mibBuilder.loadTexts: rdnRQueryLastPollStopTime.setDescription('The value of sysUpTime when the BSR last began a Remote Query polling cycle, to read values for the rdnRQueryCmtsCmStatusTable from registered cable modems. This object has an initial value of zero, if no polls have been sent. Once that it has been set to a nonzero value, it is never reset to zero again for any reason, unless the BSR reboots. ')
rdnPktDQoSAdmittedBwThresholdReason = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("admittedBwExceedsThreshold", 1), ("admittedBwClearsOfThreshold", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rdnPktDQoSAdmittedBwThresholdReason.setStatus('current')
if mibBuilder.loadTexts: rdnPktDQoSAdmittedBwThresholdReason.setDescription('This entry contains the rdnPktDQosAdmittedBwThresholdTrap reason code 1 = Admitted BW exceeded the admitted BW Threshold. 2 = Admitted BW cleared within the admitted BW Threshold. ')
rdnCmtsMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 5))
rdnCmtsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 5, 1))
rdnCmtsMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 5, 2))
rdnCmtsMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4981, 2, 5, 1, 1)).setObjects(("RDN-CMTS-MIB", "rdnCmtsIfGroup"), ("RDN-CMTS-MIB", "rdnCmtsMiscGroup"), ("RDN-CMTS-MIB", "rdnCmtsNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rdnCmtsMibCompliance = rdnCmtsMibCompliance.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsMibCompliance.setDescription('The compliance statement for entities which implement the Motorola Cable Docsis Extension (CMTS) MIB.')
rdnCmtsIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4981, 2, 5, 2, 1)).setObjects(("RDN-CMTS-MIB", "rdnCmtsDSModulation"), ("RDN-CMTS-MIB", "rdnCmtsUSNominalRxPower"), ("RDN-CMTS-MIB", "rdnCmtsUSInvitedRangingInterval"), ("RDN-CMTS-MIB", "rdnCmtsUSRangingResponseControl"), ("RDN-CMTS-MIB", "rdnCmtsUSRangingPowerOverride"), ("RDN-CMTS-MIB", "rdnCmtsUSNominalRxPowerMode"), ("RDN-CMTS-MIB", "rdnCmtsStpTCNEnable"), ("RDN-CMTS-MIB", "rdnCmtsLinkUpDownTrapEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rdnCmtsIfGroup = rdnCmtsIfGroup.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsIfGroup.setDescription('A collection of objects providing Motorola CMTS interface related extensions.')
rdnCmtsMiscGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4981, 2, 5, 2, 2)).setObjects(("RDN-CMTS-MIB", "rdnCmtsSaveConfig"), ("RDN-CMTS-MIB", "rdnCmtsCmResetByMacAddr"), ("RDN-CMTS-MIB", "rdnCmtsCmResetByIpAddr"), ("RDN-CMTS-MIB", "rdnCmtsCmResetAll"), ("RDN-CMTS-MIB", "rdnCmtsModemAgingTimer"), ("RDN-CMTS-MIB", "rdnCmtsCmMac"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusRegistrationTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusTxUnicastKbytes"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusRxUnicastKbytes"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusTxUnicastExtKbytes"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusRxUnicastExtKbytes"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusSpectrumGroupName"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusUpstreamPort"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusDownStreamPort"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusValue"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusDSBondingGroupId"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusOnlineTimes"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusPercentOnline"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusMinOnlineTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusAvgOnlineTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusMaxOnlineTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusMinOfflineTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusAvgOfflineTime"), ("RDN-CMTS-MIB", "rdnIfCmtsCmStatusMaxOfflineTime"), ("RDN-CMTS-MIB", "rdnModemDeregReason"), ("RDN-CMTS-MIB", "rdnModemRegIndex"), ("RDN-CMTS-MIB", "rdnCmToCpeMacAddress"), ("RDN-CMTS-MIB", "rdnCmToCpeIpAddress"), ("RDN-CMTS-MIB", "rdnCmtsCmRegisteredTrapEnable"), ("RDN-CMTS-MIB", "rdnCmtsCardType"), ("RDN-CMTS-MIB", "rdnRQueryCmtsCmDownChannelPower"), ("RDN-CMTS-MIB", "rdnRQueryCmStatusTxPower"), ("RDN-CMTS-MIB", "rdnRQueryUpChannelTxTimingOffset"), ("RDN-CMTS-MIB", "rdnRQuerySigQSignalNoise"), ("RDN-CMTS-MIB", "rdnRQuerySigQMicroreflections"), ("RDN-CMTS-MIB", "rdnRQueryPollTime"), ("RDN-CMTS-MIB", "rdnUgsStatsWindow"), ("RDN-CMTS-MIB", "rdnCableUgsStatsSlot"), ("RDN-CMTS-MIB", "rdnCableUgsStatsPort"), ("RDN-CMTS-MIB", "rdnCableUgsCurrentTotalFlows"), ("RDN-CMTS-MIB", "rdnCableUgsMaxFlowsLastFiveMinutes"), ("RDN-CMTS-MIB", "rdnCableUgsAvFlowsLastFiveMinutes"), ("RDN-CMTS-MIB", "rdnCableUgsMinFlowsLastFiveMinutes"), ("RDN-CMTS-MIB", "rdnCableUgsMaxFlowsLastWindow"), ("RDN-CMTS-MIB", "rdnCableUgsAvFlowsLastWindow"), ("RDN-CMTS-MIB", "rdnCableUgsMinFlowsLastWindow"), ("RDN-CMTS-MIB", "rdnCableUgsResetStats"), ("RDN-CMTS-MIB", "rdnServiceClassStatsIfDirection"), ("RDN-CMTS-MIB", "rdnServiceClassStatsSlot"), ("RDN-CMTS-MIB", "rdnServiceClassStatsPort"), ("RDN-CMTS-MIB", "rdnServiceClassStatsTotalPackets"), ("RDN-CMTS-MIB", "rdnServiceClassStatsTotalBytes"), ("RDN-CMTS-MIB", "rdnServiceClassCurrentTotalFlows"), ("RDN-CMTS-MIB", "rdnServiceClassDeferredFlows"), ("RDN-CMTS-MIB", "rdnServiceClassRestrictedFlows"), ("RDN-CMTS-MIB", "rdnServiceClassRejectedFlows"), ("RDN-CMTS-MIB", "rdnServiceClassBandWidth"), ("RDN-CMTS-MIB", "rdnServiceClassResetStats"), ("RDN-CMTS-MIB", "rdnServiceClassBondingStatsSlot"), ("RDN-CMTS-MIB", "rdnServiceClassBondingStatsChan"), ("RDN-CMTS-MIB", "rdnServiceClassBondingCurrentTotalFlows"), ("RDN-CMTS-MIB", "rdnServiceClassBondingDeferredFlows"), ("RDN-CMTS-MIB", "rdnServiceClassBondingRestrictedFlows"), ("RDN-CMTS-MIB", "rdnServiceClassBondingRejectedFlows"), ("RDN-CMTS-MIB", "rdnServiceClassBondingBandWidth"), ("RDN-CMTS-MIB", "rdnRQuerySwCurrentVers"), ("RDN-CMTS-MIB", "rdnCmtsCmResetByIpv6Addr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rdnCmtsMiscGroup = rdnCmtsMiscGroup.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsMiscGroup.setDescription('A collection of objects providing Motorola CMTS misc option extensions.')
rdnCmtsNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 4981, 2, 5, 2, 3)).setObjects(("RDN-CMTS-MIB", "rdnCmtsCmRegisteredNotification"), ("RDN-CMTS-MIB", "rdnCmtsCmDeregisteredNotification"), ("RDN-CMTS-MIB", "rdnCmtsUpstreamIfLinkUpTrap"), ("RDN-CMTS-MIB", "rdnCmtsUpstreamIfLinkDownTrap"), ("RDN-CMTS-MIB", "rdnRQueryPollDoneNotification"), ("RDN-CMTS-MIB", "rdnPktDQoSAdmittedBwThresholdTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rdnCmtsNotificationsGroup = rdnCmtsNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsNotificationsGroup.setDescription('A collection of Motorola proprietary traps/notifications providing enhanced information concerning modem registration/deregistration, link up/down, and Remote Query polling of modems. ')
rdnCableInterceptScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 2, 2, 26))
rdnCableInterceptAccessPermitted = MibScalar((1, 3, 6, 1, 4, 1, 4981, 2, 2, 26, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableInterceptAccessPermitted.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptAccessPermitted.setDescription('This object provides indication whether the SNMP user or SNMP community who issued the SNMP request has access to the rdnCableInterceptTable.')
rdnCableInterceptTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27), )
if mibBuilder.loadTexts: rdnCableInterceptTable.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptTable.setDescription('This table provides the information about the configured cable intercepts')
rdnCableInterceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RDN-CMTS-MIB", "rdnCableInterceptCpeMac"))
if mibBuilder.loadTexts: rdnCableInterceptEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptEntry.setDescription('An entry of the table rdnCableInterceptTable. The table is indexed by ifIndex and CPE MAC address. For bridged cable intercept entries the ifIndex is 0. For routed cable intercept entries the ifIndex is the index of the cable mac-domain the cable intercept is configured on.')
rdnCableInterceptCpeMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 1), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptCpeMac.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptCpeMac.setDescription('The Mac Address of the CPE being intercepted. Also being used as index.')
rdnCableInterceptCmMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptCmMac.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptCmMac.setDescription("The Mac Address of the CM being intercepted. For bridged cable intercept entries, the MAC address of the bridged CM. For routed cable intercept entries, the octet string of '000000000000'")
rdnCableInterceptDestination1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination1Type.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination1Type.setDescription('Type of the address of the first lawful intercept collector. Currently only IPv4 is supported.')
rdnCableInterceptDestination1Ip = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination1Ip.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination1Ip.setDescription('Ip destination 1 of 3 for captured data.')
rdnCableInterceptDestination1Port = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 5), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination1Port.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination1Port.setDescription('Port destination 1 of 3 for captured data.')
rdnCableInterceptDestination2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 6), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination2Type.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination2Type.setDescription('Type of the address of the second lawful intercept collector. Currently only IPv4 is supported.')
rdnCableInterceptDestination2Ip = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination2Ip.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination2Ip.setDescription('Ip destination 2 of 3 for captured data.')
rdnCableInterceptDestination2Port = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 8), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination2Port.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination2Port.setDescription('Port destination 2 of 3 for captured data.')
rdnCableInterceptDestination3Type = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 9), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination3Type.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination3Type.setDescription('Type of the address of the third lawful intercept collector. Currently only IPv4 is supported.')
rdnCableInterceptDestination3Ip = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 10), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination3Ip.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination3Ip.setDescription('Ip destination 3 of 3 for captured data.')
rdnCableInterceptDestination3Port = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 11), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptDestination3Port.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptDestination3Port.setDescription('Port destination 3 of 3 for captured data.')
rdnCableInterceptSourceType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 12), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptSourceType.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptSourceType.setDescription('Type of the address of the source addr. Currently only IPv4 is supported')
rdnCableInterceptSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 13), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptSourceIp.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptSourceIp.setDescription('Source ip of intercepted data.')
rdnCableInterceptPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableInterceptPktCnt.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptPktCnt.setDescription('Number of packets intercepted.')
rdnCableInterceptByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCableInterceptByteCnt.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptByteCnt.setDescription('Number of bytes intercepted.')
rdnCableInterceptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 27, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdnCableInterceptRowStatus.setStatus('current')
if mibBuilder.loadTexts: rdnCableInterceptRowStatus.setDescription('Controls and reflects the status of rows in this table. This field is used to control the addition and deletion of a cable intercept entry.')
rdnCmtsUpChannelCounterTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28), )
if mibBuilder.loadTexts: rdnCmtsUpChannelCounterTable.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpChannelCounterTable.setDescription('This table contains 32 bit and 64 bit IUC-1 Noise and NoEnergy mini-slots counters for upstream channels.')
rdnCmtsUpChannelCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rdnCmtsUpChannelCounterEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCmtsUpChannelCounterEntry.setDescription('List of noise/collision statistics for a single upstream channel. For DOCSIS 3.0 or 2.0 CMTSs, an entry in this table exists for each ifEntry with an ifType of docsCableUpstreamChannel(205). For DOCSIS 1.x CMTSs, an entry in this table exists for each ifEntry with an ifType of docsCableUpstream (129).')
rdnIfCmtsUpChCtrReqNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrReqNoise.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrReqNoise.setDescription('Current count, from CMTS initialization, of contention request mini-slots subjected to Noise on this upstream logical channel. This includes all contention mini-slots for IUC1 applicable to bursts that the CMTS detected but found as noisy. Discontinuities in the value of this counter can occur at reinitialization of the managed system, and at other times as indicated by the value of ifCounterDiscontinuityTime for the associated ifIndex.')
rdnIfCmtsUpChCtrReqNoEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrReqNoEnergy.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrReqNoEnergy.setDescription('Current count, from CMTS initialization, of contention request mini-slots subjected to No Energy on this upstream logical channel. This includes all contention mini-slots for IUC1 applicable to bursts that the CMTS detected but found as no energy. Discontinuities in the value of this counter can occur at reinitialization of the managed system, and at other times as indicated by the value of ifCounterDiscontinuityTime for the associated ifIndex.')
rdnIfCmtsUpChCtrExtReqNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrExtReqNoise.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrExtReqNoise.setDescription('Current count, from CMTS initialization, of contention request mini-slots for which no energy was detected on this upstream logical channel.This includes all contention mini-slots for IUC1 applicable to bursts that the CMTS detected but found as noisy. This is a 64 bit version of rdnIfCmtsUpChCtrReqNoise and will not be accessible to SNMPv1 managers. Discontinuities in the value of this counter can occur at reinitialization of the managed system, and at other times as indicated by the value of ifCounterDiscontinuityTime for the associated ifIndex.')
rdnIfCmtsUpChCtrExtReqNoEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 2, 2, 28, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrExtReqNoEnergy.setStatus('current')
if mibBuilder.loadTexts: rdnIfCmtsUpChCtrExtReqNoEnergy.setDescription('Current count, from CMTS initialization, of contention request mini-slots for which no energy was detected on this upstream logical channel. This includes all contention mini-slots for IUC1 applicable to bursts that the CMTS detected but found as no energy. This is a 64 bit version of rdnIfCmtsUpChCtrReqNoEnergy and will not be accessible to SNMPv1 managers. Discontinuities in the value of this counter can occur at reinitialization of the managed system, and at other times as indicated by the value of ifCounterDiscontinuityTime for the associated ifIndex.')
mibBuilder.exportSymbols("RDN-CMTS-MIB", rdnCmtsUSRangingResponseControl=rdnCmtsUSRangingResponseControl, rdnCmtsCompliances=rdnCmtsCompliances, rdnIfCmtsMTAOnlyStatusCorrecteds=rdnIfCmtsMTAOnlyStatusCorrecteds, rdnCmtsCpeToCmEntry=rdnCmtsCpeToCmEntry, rdnIfCmtsCmStatusOnlineTimes=rdnIfCmtsCmStatusOnlineTimes, rdnCableUgsStatsSlot=rdnCableUgsStatsSlot, rdnServiceClassRejectedFlows=rdnServiceClassRejectedFlows, rdnCmtsMib=rdnCmtsMib, rdnCmtsCmResetAll=rdnCmtsCmResetAll, rdnCmtsCpeMac=rdnCmtsCpeMac, rdnIfCmtsMTAOnlyStatusUncorrectables=rdnIfCmtsMTAOnlyStatusUncorrectables, rdnCmtsServiceClassCap=rdnCmtsServiceClassCap, rdnCableInterceptDestination2Port=rdnCableInterceptDestination2Port, rdnCmToCpeEntry=rdnCmToCpeEntry, rdnCableInterceptDestination2Type=rdnCableInterceptDestination2Type, rdnCableInterceptSourceIp=rdnCableInterceptSourceIp, rdnCmtsMibNotificationObjects=rdnCmtsMibNotificationObjects, rdnRQueryCmtsCmDownChannelPower=rdnRQueryCmtsCmDownChannelPower, rdnIfCmtsCmStatusAvgOnlineTime=rdnIfCmtsCmStatusAvgOnlineTime, rdnServiceClassBondingStatsSlot=rdnServiceClassBondingStatsSlot, rdnIfCmtsMTAOnlyStatusTable=rdnIfCmtsMTAOnlyStatusTable, rdnRQueryPollDoneNotification=rdnRQueryPollDoneNotification, rdnIfCmtsCmStatusDSBondingGroupId=rdnIfCmtsCmStatusDSBondingGroupId, rdnIfCmtsCmStatusUpstreamPort=rdnIfCmtsCmStatusUpstreamPort, rdnCmtsServiceClassSchedulingPriority=rdnCmtsServiceClassSchedulingPriority, rdnCmtsCmResetByIpv6Addr=rdnCmtsCmResetByIpv6Addr, rdnCableInterceptRowStatus=rdnCableInterceptRowStatus, rdnServiceClassStatsIfDirection=rdnServiceClassStatsIfDirection, rdnCableInterceptDestination3Ip=rdnCableInterceptDestination3Ip, rdnCmtsUpstreamIfLinkUpTrap=rdnCmtsUpstreamIfLinkUpTrap, rdnCmtsDSModulation=rdnCmtsDSModulation, rdnIfCmtsMTAOnlyStatusMicroreflections=rdnIfCmtsMTAOnlyStatusMicroreflections, rdnIfCmtsCmStatusEntry=rdnIfCmtsCmStatusEntry, rdnCmtsStpObjects=rdnCmtsStpObjects, rdnCmtsLinkUpDownTrapEnable=rdnCmtsLinkUpDownTrapEnable, rdnIfCmtsMTAOnlyStatusInetAddress=rdnIfCmtsMTAOnlyStatusInetAddress, rdnCableInterceptEntry=rdnCableInterceptEntry, rdnIfCmtsMTAOnlyStatusExtUnerroreds=rdnIfCmtsMTAOnlyStatusExtUnerroreds, rdnRQueryCmtsCmStatusExtTable=rdnRQueryCmtsCmStatusExtTable, rdnPktDQoSAdmittedBwThresholdReason=rdnPktDQoSAdmittedBwThresholdReason, rdnServiceClassBondingCurrentTotalFlows=rdnServiceClassBondingCurrentTotalFlows, rdnCmtsCmDeregisteredNotification=rdnCmtsCmDeregisteredNotification, rdnIfCmtsUpChCtrReqNoEnergy=rdnIfCmtsUpChCtrReqNoEnergy, rdnRQueryCmtsCmStatusExtEntry=rdnRQueryCmtsCmStatusExtEntry, rdnCableInterceptDestination1Ip=rdnCableInterceptDestination1Ip, rdnCmtsServiceClassAdmittedBWThreshold=rdnCmtsServiceClassAdmittedBWThreshold, rdnCmToCpeMacAddress=rdnCmToCpeMacAddress, rdnRQueryPollTime=rdnRQueryPollTime, rdnCmToCpeIpAddress=rdnCmToCpeIpAddress, rdnIfCmtsCmStatusTxUnicastExtKbytes=rdnIfCmtsCmStatusTxUnicastExtKbytes, rdnIfCmtsCmStatusSpectrumGroupName=rdnIfCmtsCmStatusSpectrumGroupName, rdnCableInterceptCmMac=rdnCableInterceptCmMac, rdnIfCmtsCmStatusDownStreamPort=rdnIfCmtsCmStatusDownStreamPort, rdnServiceClassBondingRestrictedFlows=rdnServiceClassBondingRestrictedFlows, rdnCmtsUSRegisteredModemCount=rdnCmtsUSRegisteredModemCount, rdnIfCmtsMTAOnlyStatusExtUncorrectables=rdnIfCmtsMTAOnlyStatusExtUncorrectables, rdnCmtsMibConformance=rdnCmtsMibConformance, rdnServiceClassDeferredFlows=rdnServiceClassDeferredFlows, rdnCmtsUSInvitedRangingInterval=rdnCmtsUSInvitedRangingInterval, rdnCableUgsAvFlowsLastFiveMinutes=rdnCableUgsAvFlowsLastFiveMinutes, rdnIfCmtsCmStatusRxUnicastExtKbytes=rdnIfCmtsCmStatusRxUnicastExtKbytes, rdnCmtsUSNominalRxPower=rdnCmtsUSNominalRxPower, rdnCmtsCpeToCmTable=rdnCmtsCpeToCmTable, rdnCableInterceptAccessPermitted=rdnCableInterceptAccessPermitted, rdnCmtsDownstreamChannelEntry=rdnCmtsDownstreamChannelEntry, rdnCmtsMibCompliance=rdnCmtsMibCompliance, rdnIfCmtsMTAOnlyStatusIndex=rdnIfCmtsMTAOnlyStatusIndex, rdnCmtsMibNotificationPrefix=rdnCmtsMibNotificationPrefix, rdnCmtsNotificationsGroup=rdnCmtsNotificationsGroup, rdnIfCmtsMTAOnlyStatusEqualizationData=rdnIfCmtsMTAOnlyStatusEqualizationData, rdnCmtsUSRangingPowerOverride=rdnCmtsUSRangingPowerOverride, rdnCmtsCmResetByMacAddr=rdnCmtsCmResetByMacAddr, rdnIfCmtsCmStatusTable=rdnIfCmtsCmStatusTable, rdnCmtsStpEnable=rdnCmtsStpEnable, rdnCmtsServiceClassMab=rdnCmtsServiceClassMab, rdnCmtsModemAgingTimer=rdnCmtsModemAgingTimer, rdnCmtsUpstreamIfLinkDownTrap=rdnCmtsUpstreamIfLinkDownTrap, rdnCableInterceptDestination1Port=rdnCableInterceptDestination1Port, rdnCmtsServiceClassObjects=rdnCmtsServiceClassObjects, rdnIfCmtsCmMaxCpeNumber=rdnIfCmtsCmMaxCpeNumber, rdnIfCmtsMTAOnlyStatusTimingOffset=rdnIfCmtsMTAOnlyStatusTimingOffset, rdnIfCmtsCmEntry=rdnIfCmtsCmEntry, rdnIfCmtsUpChCtrReqNoise=rdnIfCmtsUpChCtrReqNoise, rdnCmtsMibNotifications=rdnCmtsMibNotifications, PYSNMP_MODULE_ID=rdnCmtsMib, rdnIfCmtsCmStatusMinOnlineTime=rdnIfCmtsCmStatusMinOnlineTime, rdnCmtsIfGroup=rdnCmtsIfGroup, rdnCmtsServiceClassName=rdnCmtsServiceClassName, rdnCableUgsStatsPort=rdnCableUgsStatsPort, rdnServiceClassBandWidth=rdnServiceClassBandWidth, rdnIfCmtsMTAOnlyStatusValue=rdnIfCmtsMTAOnlyStatusValue, rdnCmtsCmMac=rdnCmtsCmMac, rdnIfCmtsCmStatusMinOfflineTime=rdnIfCmtsCmStatusMinOfflineTime, rdnIfCmtsMTAOnlyStatusDownChannelIfIndex=rdnIfCmtsMTAOnlyStatusDownChannelIfIndex, rdnCableInterceptDestination1Type=rdnCableInterceptDestination1Type, rdnCableInterceptCpeMac=rdnCableInterceptCpeMac, rdnCmtsCpeToCmObject=rdnCmtsCpeToCmObject, rdnServiceClassRestrictedFlows=rdnServiceClassRestrictedFlows, rdnIfCmtsMTAOnlyStatusDocsisRegMode=rdnIfCmtsMTAOnlyStatusDocsisRegMode, rdnServiceClassBondingBandWidth=rdnServiceClassBondingBandWidth, rdnIfCmtsCmStatusAvgOfflineTime=rdnIfCmtsCmStatusAvgOfflineTime, rdnServiceClassStatsTable=rdnServiceClassStatsTable, rdnServiceClassCurrentTotalFlows=rdnServiceClassCurrentTotalFlows, rdnRQuerySigQMicroreflections=rdnRQuerySigQMicroreflections, rdnCmtsUpstreamChannelTable=rdnCmtsUpstreamChannelTable, rdnCmtsCardType=rdnCmtsCardType, rdnCmtsHostAuthControl=rdnCmtsHostAuthControl, rdnCmtsMibGroups=rdnCmtsMibGroups, rdnRQueryCmtsCmStatusEntry=rdnRQueryCmtsCmStatusEntry, rdnIfCmtsCmStatusTxUnicastKbytes=rdnIfCmtsCmStatusTxUnicastKbytes, rdnCableUgsAvFlowsLastWindow=rdnCableUgsAvFlowsLastWindow, rdnRQueryCmtsCmStatusTable=rdnRQueryCmtsCmStatusTable, rdnCmtsCmRegisteredNotification=rdnCmtsCmRegisteredNotification, rdnCmtsMiscGroup=rdnCmtsMiscGroup, rdnCmtsUSOfflineModemCount=rdnCmtsUSOfflineModemCount, rdnIfCmtsMTAOnlyStatusModulationType=rdnIfCmtsMTAOnlyStatusModulationType, rdnServiceClassBondingDeferredFlows=rdnServiceClassBondingDeferredFlows, rdnCmtsUSNominalRxPowerMode=rdnCmtsUSNominalRxPowerMode, rdnIfCmtsMTAOnlyStatusRxPower=rdnIfCmtsMTAOnlyStatusRxPower, rdnRQueryLastPollStopTime=rdnRQueryLastPollStopTime, rdnCmtsUpChannelCounterEntry=rdnCmtsUpChannelCounterEntry, rdnIfCmtsCmCurrCpeNumber=rdnIfCmtsCmCurrCpeNumber, rdnCmtsIfObjects=rdnCmtsIfObjects, rdnIfCmtsMTAOnlyStatusIpAddress=rdnIfCmtsMTAOnlyStatusIpAddress, rdnCableInterceptDestination2Ip=rdnCableInterceptDestination2Ip, rdnRQuerySigQSignalNoise=rdnRQuerySigQSignalNoise, rdnIfCmtsUpChCtrExtReqNoise=rdnIfCmtsUpChCtrExtReqNoise, rdnIfCmtsCmStatusRxUnicastKbytes=rdnIfCmtsCmStatusRxUnicastKbytes, rdnCmtsUpChannelCounterTable=rdnCmtsUpChannelCounterTable, rdnCmtsLinkUpDownTrapEnableEntry=rdnCmtsLinkUpDownTrapEnableEntry, rdnCmToCpeIndex=rdnCmToCpeIndex, rdnServiceClassBondingStatsGroupId=rdnServiceClassBondingStatsGroupId, rdnCmtsLinkUpDownTrapEnableTable=rdnCmtsLinkUpDownTrapEnableTable, rdnCmtsServiceClassAllowShare=rdnCmtsServiceClassAllowShare, rdnCableUgsMinFlowsLastWindow=rdnCableUgsMinFlowsLastWindow, rdnRQueryUpChannelTxTimingOffset=rdnRQueryUpChannelTxTimingOffset, rdnIfCmtsMTAOnlyStatusMacAddress=rdnIfCmtsMTAOnlyStatusMacAddress, rdnCmtsUSUnregisteredModemCount=rdnCmtsUSUnregisteredModemCount, rdnCableUgsStatsEntry=rdnCableUgsStatsEntry, rdnCmtsServiceClassTable=rdnCmtsServiceClassTable, rdnIfCmtsUpChCtrExtReqNoEnergy=rdnIfCmtsUpChCtrExtReqNoEnergy, rdnIfCmtsMTAOnlyStatusInetAddressType=rdnIfCmtsMTAOnlyStatusInetAddressType, rdnRQueryCmStatusTxPower=rdnRQueryCmStatusTxPower, rdnServiceClassStatsTotalBytes=rdnServiceClassStatsTotalBytes, rdnIfCmtsCmStatusMaxOnlineTime=rdnIfCmtsCmStatusMaxOnlineTime, rdnModemDeregReason=rdnModemDeregReason, rdnIfCmtsMTAOnlyStatusUnerroreds=rdnIfCmtsMTAOnlyStatusUnerroreds, rdnIfCmtsCmTable=rdnIfCmtsCmTable, rdnServiceClassBondingRejectedFlows=rdnServiceClassBondingRejectedFlows, rdnCmtsStpTCNEnable=rdnCmtsStpTCNEnable, rdnServiceClassStatsTotalPackets=rdnServiceClassStatsTotalPackets, rdnUgsStatsWindow=rdnUgsStatsWindow, rdnCableInterceptTable=rdnCableInterceptTable, rdnCableInterceptDestination3Type=rdnCableInterceptDestination3Type, rdnServiceClassBondingStatsMacIfIndex=rdnServiceClassBondingStatsMacIfIndex, rdnRQueryLastPollStartTime=rdnRQueryLastPollStartTime, rdnCmtsCmResetByIpAddr=rdnCmtsCmResetByIpAddr, rdnCmToCpeIPv6Addr=rdnCmToCpeIPv6Addr, rdnIfCmtsMTAOnlyStatusEntry=rdnIfCmtsMTAOnlyStatusEntry, rdnCableUgsCurrentTotalFlows=rdnCableUgsCurrentTotalFlows, rdnPktDQoSAdmittedBwThresholdTrap=rdnPktDQoSAdmittedBwThresholdTrap, rdnCableInterceptByteCnt=rdnCableInterceptByteCnt, rdnCmtsDownstreamChannelTable=rdnCmtsDownstreamChannelTable, rdnCmtsCmRegisteredTrapEnable=rdnCmtsCmRegisteredTrapEnable, rdnCmtsUpstreamChannelEntry=rdnCmtsUpstreamChannelEntry, rdnCableInterceptSourceType=rdnCableInterceptSourceType, rdnServiceClassBondingStatsIfDirection=rdnServiceClassBondingStatsIfDirection, rdnRQuerySwCurrentVers=rdnRQuerySwCurrentVers, rdnServiceClassStatsEntry=rdnServiceClassStatsEntry, rdnCableInterceptPktCnt=rdnCableInterceptPktCnt, rdnIfCmtsCmStatusValue=rdnIfCmtsCmStatusValue, rdnCmtsServiceClassEntry=rdnCmtsServiceClassEntry, rdnServiceClassStatsSlot=rdnServiceClassStatsSlot, rdnCableUgsResetStats=rdnCableUgsResetStats, rdnIfCmtsCmStatusPercentOnline=rdnIfCmtsCmStatusPercentOnline, rdnCmtsUSTotalModemCount=rdnCmtsUSTotalModemCount, rdnServiceClassBondingStatsEntry=rdnServiceClassBondingStatsEntry, rdnServiceClassBondingStatsChan=rdnServiceClassBondingStatsChan, rdnCmtsSaveConfig=rdnCmtsSaveConfig, rdnServiceClassBondingStatsTable=rdnServiceClassBondingStatsTable, rdnServiceClassResetStats=rdnServiceClassResetStats, rdnIfCmtsMTAOnlyStatusExtCorrecteds=rdnIfCmtsMTAOnlyStatusExtCorrecteds, rdnModemRegIndex=rdnModemRegIndex, rdnCableUgsMaxFlowsLastWindow=rdnCableUgsMaxFlowsLastWindow, rdnIfCmtsMTAOnlyStatusValueLastUpdate=rdnIfCmtsMTAOnlyStatusValueLastUpdate, rdnIfCmtsMTAOnlyStatusUpChannelIfIndex=rdnIfCmtsMTAOnlyStatusUpChannelIfIndex, rdnCableUgsMaxFlowsLastFiveMinutes=rdnCableUgsMaxFlowsLastFiveMinutes, rdnIfCmtsCmStatusMaxOfflineTime=rdnIfCmtsCmStatusMaxOfflineTime, rdnCableUgsMinFlowsLastFiveMinutes=rdnCableUgsMinFlowsLastFiveMinutes, rdnCmToCpeTable=rdnCmToCpeTable, rdnCableInterceptScalars=rdnCableInterceptScalars, rdnServiceClassStatsPort=rdnServiceClassStatsPort, rdnRQueryServerConfigFile=rdnRQueryServerConfigFile, rdnCableInterceptDestination3Port=rdnCableInterceptDestination3Port, rdnCmtsMiscObjects=rdnCmtsMiscObjects, rdnIfCmtsMTAOnlyStatusSignalNoise=rdnIfCmtsMTAOnlyStatusSignalNoise, rdnIfCmtsCmStatusRegistrationTime=rdnIfCmtsCmStatusRegistrationTime, rdnCableUgsStatsTable=rdnCableUgsStatsTable)

#
# PySNMP MIB module JNX-MPLS-TE-P2MP-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JNX-MPLS-TE-P2MP-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
IndexInteger, IndexIntegerNextFree = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexInteger", "IndexIntegerNextFree")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
jnxP2mpExperiment, = mibBuilder.importSymbols("JUNIPER-EXPERIMENT-MIB", "jnxP2mpExperiment")
MplsIndexType, = mibBuilder.importSymbols("MPLS-LSR-STD-MIB", "MplsIndexType")
mplsStdMIB, MplsPathIndexOrZero = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB", "MplsPathIndexOrZero")
mplsTunnelIngressLSRId, mplsTunnelEgressLSRId, mplsTunnelInstance, mplsTunnelIndex = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId", "mplsTunnelEgressLSRId", "mplsTunnelInstance", "mplsTunnelIndex")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ModuleIdentity, Counter32, TimeTicks, Bits, Gauge32, iso, Unsigned32, IpAddress, ObjectIdentity, Counter64, Integer32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Counter32", "TimeTicks", "Bits", "Gauge32", "iso", "Unsigned32", "IpAddress", "ObjectIdentity", "Counter64", "Integer32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
TimeStamp, TextualConvention, RowStatus, DisplayString, TruthValue, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "RowStatus", "DisplayString", "TruthValue", "StorageType")
jnxMplsTeP2mpStdMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1))
jnxMplsTeP2mpStdMIB.setRevisions(('2009-04-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setRevisionsDescriptions(('Initial version issued as part of RFC XXXX.',))
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setLastUpdated('200904170000Z')
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setContactInfo(' Adrian Farrel Old Dog Consulting Email: adrian@olddog.co.uk Seisho Yasukawa NTT Corporation Email: s.yasukawa@hco.ntt.co.jp Thomas D. Nadeau British Telecom Email: tom.nadeau@bt.com Comments about this document should be emailed directly to the MPLS working group mailing list at mpls@lists.ietf.org')
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setDescription("Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved. This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document. The initial version of this MIB module was published in RFC XXXX. For full legal notices see the RFC itself or see: http://www.ietf.org/copyrights/ianamib.html -- RFC Editor. Please replace XXXX with the RFC number for this -- document and remove this note. This MIB module contains managed object definitions for Point-to-Multipoint (P2MP) MPLS Traffic Engineering (TE) defined in: 1. Signaling Requirements for Point-to-Multipoint Traffic-Engineered MPLS Label Switched Paths (LSPs), S. Yasukawa, RFC 4461, April 2006. 2. Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), Aggarwal, R., Papadimitriou, D., and Yasukawa, S., RFC 4875, May 2007.")
jnxMplsTeP2mpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0))
jnxMplsTeP2mpScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1))
jnxMplsTeP2mpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2))
jnxMplsTeP2mpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3))
jnxMplsTeP2mpTunnelConfigured = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelConfigured.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelConfigured.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelConfigured.setDescription('The number of P2MP tunnels configured on this device. A tunnel is considered configured if the mplsTunnelRowStatus in MPLS-TE-STD-MIB is active(1).')
jnxMplsTeP2mpTunnelActive = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelActive.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelActive.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelActive.setDescription('The number of P2MP tunnels active on this device. A tunnel is considered active if the mplsTunnelOperStatus in MPLS-TE-STD-MIB is up(1).')
jnxMplsTeP2mpTunnelTotalMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTotalMaxHops.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTotalMaxHops.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTotalMaxHops.setDescription('The maximum number of hops that can be specified for an entire P2MP tunnel on this device. This object should be used in conjunction with mplsTunnelMaxHops in MPLS-TE-STD-MIB that is used in the context of P2MP tunnels to express the maximum number of hops to any individual destination of a P2MP tunnel that can be configured on this device. mplsTeP2mpTunnelTotalMaxHops would normally be set larger than or equal to mplsTunnelMaxHops.')
jnxMplsTeP2mpTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1), )
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTable.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTable.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTable.setDescription('The mplsTeP2mpTunnelTable allows new P2MP MPLS tunnels to be created between an LSR and one or more remote end-points, and existing P2MP tunnels to be reconfigured or removed. This table sparse augments mplsTunnelTable in MPLS-TE-STD-MIB such that entries in that table can be flagged as point-to-multipoint, and can be configured and monitored appropriately.')
jnxMplsTeP2mpTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelEntry.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelEntry.setDescription('An entry in this table represents a P2MP MPLS tunnel. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol. An entry in this table MUST correspond to an entry in the mplsTunnelTable in MPLS-TE-STD-MIB. This table shares index objects with that table and sparse augments that table. Thus, an entry in this table can only be created at the same time as or after a corresponding entry in mplsTunnelTable, and an entry in mplsTunnelTable cannot be deleted while a corresponding entry exists in this table. This table entry includes a row status object, but administrative and operational statuses should be taken from mplsTunnelAdminStatus and mplsTunnelOperStatus in the corresponding entry in mplsTunnelTable.')
jnxMplsTeP2mpTunnelP2mpIntegrity = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpIntegrity.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpIntegrity.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpIntegrity.setDescription('Denotes whether or not P2MP Integrity is required for this tunnel. If P2MP integrity is operational on a P2MP tunnel then the failure of the path to any of the tunnel destinations should cause the teardown of the entire P2MP tunnel.')
jnxMplsTeP2mpTunnelBranchRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notBranch", 1), ("branch", 2), ("bud", 3))).clone('notBranch')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchRole.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchRole.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchRole.setDescription('This value supplements the value in the object mplsTunnelRole in MPLS-TE-STD-MIB that indicates the role of this LSR in the tunnel represented by this entry in mplsTeP2mpTunnelTable. mplsTunnelRole may take any of the values: head(1), transit(2), tail(3), headTail(4) If this LSR is an ingress and there is exactly one out-segment, mplsTunnelRole should contain the value head(1), and mplsTeP2mpTunnelBranchRole should have the value notBranch(1). If this LSR is an ingress with more than one out segment, mplsTunnelRole should contain the value head(1), and mplsTeP2mpTunnelBranchRole should have the value branch(2). If this LSR is an ingress, an egress, and there is one or more out-segments, mplsTunnelRole should contain the value headTail(4), and mplsTeP2mpTunnelBranchRole should have the value bud(3). If this LSR is a transit with exactly one out-segment, mplsTunnelRole should contain the value transit(2), and mplsTeP2mpTunnelBranchRole should have the value notBranch(1). If this LSR is a transit with more than one out-segment, mplsTunnelRole should contain the value transit(2), and mplsTeP2mpTunnelBranchRole should have the value branch(2). If this LSR is a transit with one or more out-segments and is also an egress, mplsTunnelRole should contain the value transit(2), and mplsTeP2mpTunnelBranchRole should have the value bud(3). If this LSR is an egress with no out-segment and is not the ingress, mplsTunnelRole should contain the value tail(3), and mplsTeP2mpTunnelBranchRole should have the value notBranch(1). If this LSR is an egress and has one or more out-segments, mplsTunnelRole should contain the value transit(1), and mplsTeP2mpTunnelBranchRole should have the value bud(3).')
jnxMplsTeP2mpTunnelP2mpXcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 4), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpXcIndex.setReference('RFC 3813 - Multiprotocol Label Switching (MPLS) Label Switching (LSR) Router Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpXcIndex.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpXcIndex.setDescription('This object contains the value of mplsXCIndex, the primary index of the mplsXCTable for all cross-connect entries for this P2MP LSP. If no XC entries have been created yet, this object must return zero. The set of entries in the mplsXCTable for this P2MP LSP can be walked by reading Get-or-GetNext starting with the three indexes to mplsXCTable set as: mplsXCIndex = the value of this object mplsXCInSegmentIndex = 0x0 mplsXCOutSegmentIndex = 0x0')
jnxMplsTeP2mpTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelRowStatus.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table. When a row in this table is in active(1) state, no objects in that row can be modified by the agent except mplsTeP2mpTunnelRowStatus and mplsTeP2mpTunnelStorageType. This object and mplsTunnelRowStatus in the corresponding entry in mplsTunnelTable in MPLS-TE-STD-MIB should be managed together. No objects in a row in this table can be modified when the mplsTunnelRowStatus object in the corresponding row in mplsTunnelTable has value active(1). Note that no admin or oper status objects are provided in this table. The administrative and operational status of P2MP tunnels is taken from the values of mplsTunnelAdminStatus and mplsTunnelOperStatus in the corresponding row mplsTunnelTable.')
jnxMplsTeP2mpTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelStorageType.setDescription("The storage type for this tunnel entry. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
jnxMplsTeP2mpTunnelSubGroupIDNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 2), IndexIntegerNextFree().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelSubGroupIDNext.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelSubGroupIDNext.setDescription('This object contains an unused value for mplsTeP2mpTunnelDestSubGroupID, or a zero to indicate that none exists. Negative values are not allowed, as they do not correspond to valid values of mplsTeP2mpTunnelDestSubGroupID. Note that this object offers an unused value for an mplsTeP2mpTunnelDestSubGroupID value at the local LSR when it is a sub-group originator. In other cases, the value of mplsTeP2mpTunnelDestSubGroupID SHOULD be taken from the received value signaled by the signaling protocol and corresponds to the value in mplsTeP2mpTunnelDestSrcSubGroupID.')
jnxMplsTeP2mpTunnelDestTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3), )
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTable.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTable.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTable.setDescription('The mplsTeP2mpTunnelDestTable allows new destinations of P2MP MPLS tunnels to be added to and removed from P2MP tunnels.')
jnxMplsTeP2mpTunnelDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupID"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupOriginType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupOrigin"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupID"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDestinationType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDestination"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestEntry.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestEntry.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestEntry.setDescription('An entry in this table represents a destination of a P2MP MPLS tunnel. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol. Entries in this table share some index fields with the mplsTeP2mpTunnelTable and the mplsTunnelTable in MPLS-TE-STD-MIB. Entries in this table have no meaning unless there is a corresponding entry in mplsTeP2mpTunnelTable (which, itself, depends on a corresponding entry in mplsTunnelTable). Note that the same destination may be present more than once if it is in more than one sub-group as reflected by the mplsTeP2mpTunnelDestSrcSubGroupOriginType, mplsTeP2mpTunnelDestSrcSubGroupOrigin, mplsTeP2mpTunnelDestSrcSubGroupID, mplsTeP2mpTunnelDestSubGroupOriginType, mplsTeP2mpTunnelDestSubGroupOrigin, and mplsTeP2mpTunnelDestSubGroupID, index objects. Entries in this table may be created at any time. If created before an entry in the mplsTeP2mpTunnelTable the entries have no meaning, but may be kept ready for the creation of the P2MP tunnel. If created after the entry in mplsTeP2mpTunnelTable, entries in this table may reflect the addition of destinations to active P2MP tunnels. For this reason, entries in this table are equipped with row, admin, and oper status objects. ')
jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType.setDescription('This object identifies the type of address carried in mplsTeP2mpTunnelDestSrcSubGroupOrigin. Since the object mplsTeP2mpTunnelDestSrcSubGroupOrigin must conform to the protocol specification, this object must return either ipv4(1) or ipv6(2) at a transit or egress LSR. At an ingress LSR, there is no source sub-group and this object should return the value unknown(0).')
jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin.setDescription('The TE Router ID (reachable and stable IP address) of the originator of the P2MP sub-group as received on a Path message by a transit or egress LSR. This object is interpreted in the context of mplsTeP2mpTunnelDestSrcSubGroupOriginType. The value of the sub-group originator used on outgoing Path messages is found in mplsTeP2mpTunnelDestSubGroupOrigin and is copied from this object unless this LSR is responsible for changing the sub-group ID. At an ingress LSR there is no received Path message. mplsTeP2mpTunnelDestSrcSubGroupOriginType should return unknown(0), and this object should return a zero-length string.')
jnxMplsTeP2mpTunnelDestSrcSubGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 3), IndexInteger().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupID.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupID.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupID.setDescription('The unique identifier assigned by the sub-group originator for this sub-group of this P2MP tunnel as received on a Path message by a transit or egress LSR. The value of the sub-group identifier used on outgoing Path messages is found in mplsTeP2mpTunnelDestSubGroupID and is copied from this object unless this LSR is responsible for changing the sub-group ID. At an ingress LSR there is no received Path message, and this object should return zero.')
jnxMplsTeP2mpTunnelDestSubGroupOriginType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 4), InetAddressType())
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOriginType.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOriginType.setDescription('This object identifies the type of address carried in mplsTeP2mpTunnelDestSubGroupOrigin. This object must return either ipv4(1) or ipv6(2) in keeping with the protocol specification.')
jnxMplsTeP2mpTunnelDestSubGroupOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 5), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOrigin.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOrigin.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOrigin.setDescription('The TE Router ID (reachable and stable IP address) of the originator of the P2MP sub-group. In many cases, this will be the ingress LSR of the P2MP tunnel and will be the received signaled value as available in mplsTeP2mpTunnelDestSrcSubGroupOrigin. When a signaling protocol is used, this object corresponds to the Sub-Group Originator field in the SENDER_TEMPLATE object. This object is interpreted in the context of mplsTeP2mpTunnelDestSubGroupOriginType.')
jnxMplsTeP2mpTunnelDestSubGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 6), IndexInteger().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupID.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupID.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupID.setDescription('The unique identifier assigned by the sub-group originator for this sub-group of this P2MP tunnel. An appropriate value for this object during row creation when the sub-group origin in mplsTeP2mpTunnelDestSubGroupOrigin is the local LSR can be obtained by reading mplsTeP2mpTunnelSubGroupIDNext. At an egress, there is no downstream sub-group ID. This object should return the value received from upstream and reported in mplsTeP2mpTunnelDestSrcSubGroupID.')
jnxMplsTeP2mpTunnelDestDestinationType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 7), InetAddressType())
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestinationType.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestinationType.setDescription('This object identifies the type of address carried in mplsTeP2mpTunnelDestDestination. This object forms part of the index of this table and can, therefore, not return the value unknown(0). Similarly, since the object mplsTeP2mpTunnelDestDestination must conform to the protocol specification, this object must return either ipv4(1) or ipv6(2).')
jnxMplsTeP2mpTunnelDestDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestination.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestination.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestination.setDescription('A single destination of this P2MP tunnel. That is, a routable TE address of a leaf. This will often be the TE Router ID of the leaf, but can be any interface address. When a signaling protocol is used, this object corresponds to the S2L Sub-LSP destination address field in the S2L_SUB_LSP object. This object is interpreted in the context of mplsTeP2mpTunnelDestDestinationType.')
jnxMplsTeP2mpTunnelDestBranchOutSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 9), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestBranchOutSegment.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestBranchOutSegment.setDescription('This object identifies the outgoing branch from this LSR towards the destination represented by this table entry. It must be a unique identifier within the scope of this tunnel. If MPLS-LSR-STD-MIB is implemented, this object should contain an index into mplsOutSegmentTable. If MPLS-LSR-STD-MIB is not implemented, the LSR should assign a unique value to each branch of the tunnel. The value of this object is also used as an index into mplsTeP2mpTunnelBranchPerfTable.')
jnxMplsTeP2mpTunnelDestHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 10), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestHopTableIndex.setDescription('Index into the mplsTunnelHopTable entry that specifies the explicit route hops for this destination of the P2MP tunnel. This object represents the configured route for the branch of the P2MP tree to this destination and is meaningful only at the head-end (ingress or root) of the P2MP tunnel. Note that many such paths may be configured within the mplsTunnelHopTable for each destination, and that the object mplsTeP2mpTunnelDestPathInUse identifies which path has been selected for use.')
jnxMplsTeP2mpTunnelDestPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 11), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathInUse.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathInUse.setDescription('This value denotes the configured path that was chosen as the explicit path to this destination of this P2MP tunnel. This value reflects the secondary index into mplsTunnelHopTable where the primary index comes from mplsTeP2mpTunnelDestHopTableIndex. The path indicated by this object might not exactly match the one signaled and recorded in mplsTunnelCHopTable as specific details of the path might be computed locally. Similarly, the path might not match the actual path in use as recorded in mplsTunnelARHopTable due to the fact that some details of the path may have been resolved within the network. A value of zero denotes that no path is currently in use or available.')
jnxMplsTeP2mpTunnelDestCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 12), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCHopTableIndex.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCHopTableIndex.setDescription("Index into the mplsTunnelCHopTable that identifies the explicit path for this destination of the P2MP tunnel. This path is based on the chosen configured path identified by mplsTeP2mpTunnelDestHopTableIndex and mplsTeP2mpTunnelDestPathInUse, but may have been modified and automatically updated by the agent when computed hops become available or when computed hops get modified. If this destination is the destination of the 'first S2L sub-LSP' then this path will be signaled in the Explicit Route Object. If this destination is the destination of a 'subsequent S2L sub-LSP' then this path will be signaled in a Secondary Explicit Route Object.")
jnxMplsTeP2mpTunnelDestARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 13), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestARHopTableIndex.setReference('RFC 4875 - Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs), R. Aggarwal, D. Papadimitriou, and S. Yasukawa, May 2007.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestARHopTableIndex.setDescription("Index into the mplsTunnelARHopTable that identifies the actual hops traversed to this destination of the P2MP tunnel. This is automatically updated by the agent when the actual hops becomes available. If this destination is the destination of the 'first S2L sub-LSP' then this path will be signaled in the Recorded Route Object. If this destination is the destination of a 'subsequent S2L sub-LSP' then this path will be signaled in a Secondary Recorded Route Object.")
jnxMplsTeP2mpTunnelDestTotalUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTotalUpTime.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTotalUpTime.setDescription('This value represents the aggregate up time for all instances of this tunnel to this destination, if this information is available. If this information is not available, this object MUST return a value of 0.')
jnxMplsTeP2mpTunnelDestInstanceUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestInstanceUpTime.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestInstanceUpTime.setDescription('This value identifies the total time that the currently active tunnel instance to this destination has had its operational status (mplsTeP2mpTunnelDestOperStatus) set to up(1) since it was last previously not up(1).')
jnxMplsTeP2mpTunnelDestPathChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathChanges.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathChanges.setDescription('This object counts the number of times the actual path for this destination of this P2MP tunnel instance has changed. This object should be read in conjunction with mplsTeP2mpTunnelDestDiscontinuityTime.')
jnxMplsTeP2mpTunnelDestLastPathChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestLastPathChange.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestLastPathChange.setDescription('Specifies the time since the last change to the actual path for this destination of this P2MP tunnel instance.')
jnxMplsTeP2mpTunnelDestCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCreationTime.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCreationTime.setDescription('Specifies the value of sysUpTime when the first instance of this tunnel came into existence for this destination. That is, when the value of mplsTeP2mpTunnelDestOperStatus was first set to up(1).')
jnxMplsTeP2mpTunnelDestStateTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStateTransitions.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStateTransitions.setDescription('This object counts the number of times the status (mplsTeP2mpTunnelDestOperStatus) of this tunnel instance to this destination has changed. This object should be read in conjunction with mplsTeP2mpTunnelDestDiscontinuityTime.')
jnxMplsTeP2mpTunnelDestDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this row's Counter32 objects experienced a discontinuity. If no such discontinuity has occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
jnxMplsTeP2mpTunnelDestAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestAdminStatus.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestAdminStatus.setDescription('Indicates the desired operational status of this destination of this P2MP tunnel.')
jnxMplsTeP2mpTunnelDestOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestOperStatus.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestOperStatus.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestOperStatus.setDescription('Indicates the actual operational status of this destination of this P2MP tunnel. This object may be compared to mplsTunnelOperStatus that includes two other values: dormant(5) -- some component is missing notPresent(6) -- down due to the state of -- lower layer interfaces. These states do not apply to an individual destination of a P2MP MPLS-TE LSP and so are not included in this object.')
jnxMplsTeP2mpTunnelDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestRowStatus.setDescription('This object is used to create, modify, and/or delete a row in this table. When a row in this table is in active(1) state, no objects in that row can be modified by SET operations except mplsTeP2mpTunnelDestAdminStatus and mplsTeP2mpTunnelDestStorageType.')
jnxMplsTeP2mpTunnelDestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 24), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStorageType.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStorageType.setDescription("The storage type for this table entry. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
jnxMplsTeP2mpTunnelBranchPerfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4), )
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfTable.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfTable.setDescription('This table provides per-tunnel branch MPLS performance information. This table is not valid for switching types other than packet.')
jnxMplsTeP2mpTunnelBranchPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfBranch"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfEntry.setDescription('An entry in this table is created by the LSR for each downstream branch (out-segment) from this LSR for this P2MP tunnel. More than one destination as represented by an entry in the mplsTeP2mpTunnelDestTable may be reached through a single out-segment. More than one out-segment may belong to a single P2MP tunnel represented by an entry in mplsTeP2mpTunnelTable. Each entry in the table is indexed by the four identifiers of the P2MP tunnel, and the out-segment that identifies the outgoing branch.')
jnxMplsTeP2mpTunnelBranchPerfBranch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBranch.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBranch.setDescription('This object identifies an outgoing branch from this LSR for this tunnel. Its value is unique within the context of the tunnel. If MPLS-LSR-STD-MIB is implemented, this object should contain an index into mplsOutSegmentTable. Under all circumstances, this object should contain the same value as mplsTeP2mpTunnelDestBranchOutSegment for destinations reached on this branch.')
jnxMplsTeP2mpTunnelBranchPerfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfPackets.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfPackets.setDescription('Number of packets forwarded by the tunnel onto this branch. This object should represents the 32-bit value of the least significant part of the 64-bit value if both mplsTeP2mpTunnelBranchPerfHCPackets is returned. This object should be read in conjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.')
jnxMplsTeP2mpTunnelBranchPerfHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCPackets.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCPackets.setDescription('High capacity counter for number of packets forwarded by the tunnel onto this branch. This object should be read in conjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.')
jnxMplsTeP2mpTunnelBranchPerfErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfErrors.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfErrors.setDescription('Number of packets dropped because of errors or for other reasons, that were supposed to be forwarded onto this branch for this tunnel. This object should be read in conjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.')
jnxMplsTeP2mpTunnelBranchPerfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBytes.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBytes.setDescription('Number of bytes forwarded by the tunnel onto this branch. This object should represents the 32-bit value of the least significant part of the 64-bit value if both mplsTeP2mpTunnelBranchPerfHCBytes is returned. This object should be read in conjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.')
jnxMplsTeP2mpTunnelBranchPerfHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCBytes.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCBytes.setDescription('High capacity counter for number of bytes forwarded by the tunnel onto this branch. This object should be read in conjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.')
jnxMplsTeP2mpTunnelBranchDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this row's Counter32 or Counter64 objects experienced a discontinuity. If no such discontinuity has occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
jnxMplsTeP2mpTunnelNotificationEnable = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelNotificationEnable.setDescription('If this object is true(1), then it enables the generation of mplsTeP2mpTunnelDestUp and mplsTeP2mpTunnelDestDown notifications. Otherwise these notifications are not emitted. Note that when tunnels have large numbers of destinations, setting this object to true(1) may result in the generation of large numbers of notifications.')
jnxMplsTeP2mpTunnelDestUp = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0, 1)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestUp.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestUp.setDescription('This notification is generated when a mplsTeP2mpTunnelDestOperStatus object for one of the destinations of one of the configured tunnels is about to leave the down(2) state and transition into some other state. This other state is indicated by the included value of mplsTeP2mpTunnelDestOperStatus. This reporting of state transitions mirrors mplsTunnelUp.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestUp.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
jnxMplsTeP2mpTunnelDestDown = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0, 2)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDown.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDown.setDescription('This notification is generated when a mplsTeP2mpTunnelDestOperStatus object for one of the destinations of one of the configured tunnels is about to enter the down(2) state from some other state. This other state is indicated by the included value of mplsTeP2mpTunnelDestOperStatus. This reporting of state transitions mirrors mplsTunnelDown.')
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDown.setReference('RFC 3812 - Multiprotocol Label Switching (MPLS) Traffic Engineering (TE) Management Information Base (MIB), Srinivasan, C., Viswanathan, A., and T. Nadeau, June 2004.')
jnxMplsTeP2mpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1))
jnxMplsTeP2mpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2))
jnxMplsTeP2mpModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2, 1)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpGeneralGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpNotifGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpScalarGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxMplsTeP2mpModuleFullCompliance = jnxMplsTeP2mpModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for MPLS-TE-P2MP-STD-MIB. Such devices can be monitored and also be configured using this MIB module. The Module is implemented with support for read-create and read-write. In other words, both monitoring and configuration are available when using this MODULE-COMPLIANCE.')
jnxMplsTeP2mpModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2, 2)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpGeneralGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpScalarGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxMplsTeP2mpModuleReadOnlyCompliance = jnxMplsTeP2mpModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpModuleReadOnlyCompliance.setDescription('Compliance statement for agents that provide read-only support for MPLS-TE-P2MP-STD-MIB. Such devices can only be monitored using this MIB module. The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
jnxMplsTeP2mpGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 1)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelConfigured"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelActive"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelTotalMaxHops"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelP2mpIntegrity"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchRole"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelP2mpXcIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelRowStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelStorageType"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelSubGroupIDNext"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestBranchOutSegment"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestPathInUse"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestCHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestARHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestTotalUpTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestInstanceUpTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestPathChanges"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestLastPathChange"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestCreationTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestStateTransitions"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDiscontinuityTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestRowStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestStorageType"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfPackets"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfHCPackets"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfErrors"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfBytes"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfHCBytes"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchDiscontinuityTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelNotificationEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxMplsTeP2mpGeneralGroup = jnxMplsTeP2mpGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpGeneralGroup.setDescription('Collection of objects needed for MPLS P2MP.')
jnxMplsTeP2mpNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 2)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestUp"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxMplsTeP2mpNotifGroup = jnxMplsTeP2mpNotifGroup.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpNotifGroup.setDescription('Notifications implemented in this module.')
jnxMplsTeP2mpScalarGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 3)).setObjects(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelConfigured"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelActive"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelTotalMaxHops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxMplsTeP2mpScalarGroup = jnxMplsTeP2mpScalarGroup.setStatus('current')
if mibBuilder.loadTexts: jnxMplsTeP2mpScalarGroup.setDescription('Scalar objects needed to implement P2MP MPLS tunnels.')
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", jnxMplsTeP2mpStdMIB=jnxMplsTeP2mpStdMIB, jnxMplsTeP2mpTunnelSubGroupIDNext=jnxMplsTeP2mpTunnelSubGroupIDNext, jnxMplsTeP2mpTunnelDestDiscontinuityTime=jnxMplsTeP2mpTunnelDestDiscontinuityTime, jnxMplsTeP2mpTunnelDestRowStatus=jnxMplsTeP2mpTunnelDestRowStatus, jnxMplsTeP2mpTunnelBranchPerfBranch=jnxMplsTeP2mpTunnelBranchPerfBranch, jnxMplsTeP2mpTunnelEntry=jnxMplsTeP2mpTunnelEntry, jnxMplsTeP2mpTunnelP2mpIntegrity=jnxMplsTeP2mpTunnelP2mpIntegrity, jnxMplsTeP2mpTunnelTable=jnxMplsTeP2mpTunnelTable, jnxMplsTeP2mpTunnelDestHopTableIndex=jnxMplsTeP2mpTunnelDestHopTableIndex, jnxMplsTeP2mpTunnelDestSrcSubGroupID=jnxMplsTeP2mpTunnelDestSrcSubGroupID, jnxMplsTeP2mpTunnelDestCHopTableIndex=jnxMplsTeP2mpTunnelDestCHopTableIndex, jnxMplsTeP2mpTunnelDestLastPathChange=jnxMplsTeP2mpTunnelDestLastPathChange, jnxMplsTeP2mpNotifGroup=jnxMplsTeP2mpNotifGroup, jnxMplsTeP2mpScalarGroup=jnxMplsTeP2mpScalarGroup, jnxMplsTeP2mpTunnelBranchPerfHCPackets=jnxMplsTeP2mpTunnelBranchPerfHCPackets, jnxMplsTeP2mpTunnelDestDestination=jnxMplsTeP2mpTunnelDestDestination, jnxMplsTeP2mpGroups=jnxMplsTeP2mpGroups, jnxMplsTeP2mpNotifications=jnxMplsTeP2mpNotifications, jnxMplsTeP2mpTunnelDestBranchOutSegment=jnxMplsTeP2mpTunnelDestBranchOutSegment, jnxMplsTeP2mpTunnelTotalMaxHops=jnxMplsTeP2mpTunnelTotalMaxHops, jnxMplsTeP2mpTunnelDestSubGroupOrigin=jnxMplsTeP2mpTunnelDestSubGroupOrigin, jnxMplsTeP2mpTunnelDestStateTransitions=jnxMplsTeP2mpTunnelDestStateTransitions, jnxMplsTeP2mpTunnelDestTable=jnxMplsTeP2mpTunnelDestTable, PYSNMP_MODULE_ID=jnxMplsTeP2mpStdMIB, jnxMplsTeP2mpConformance=jnxMplsTeP2mpConformance, jnxMplsTeP2mpTunnelDestCreationTime=jnxMplsTeP2mpTunnelDestCreationTime, jnxMplsTeP2mpTunnelP2mpXcIndex=jnxMplsTeP2mpTunnelP2mpXcIndex, jnxMplsTeP2mpTunnelDestTotalUpTime=jnxMplsTeP2mpTunnelDestTotalUpTime, jnxMplsTeP2mpTunnelConfigured=jnxMplsTeP2mpTunnelConfigured, jnxMplsTeP2mpTunnelBranchPerfErrors=jnxMplsTeP2mpTunnelBranchPerfErrors, jnxMplsTeP2mpModuleReadOnlyCompliance=jnxMplsTeP2mpModuleReadOnlyCompliance, jnxMplsTeP2mpTunnelBranchPerfPackets=jnxMplsTeP2mpTunnelBranchPerfPackets, jnxMplsTeP2mpTunnelDestSubGroupID=jnxMplsTeP2mpTunnelDestSubGroupID, jnxMplsTeP2mpTunnelDestEntry=jnxMplsTeP2mpTunnelDestEntry, jnxMplsTeP2mpTunnelDestSubGroupOriginType=jnxMplsTeP2mpTunnelDestSubGroupOriginType, jnxMplsTeP2mpTunnelBranchDiscontinuityTime=jnxMplsTeP2mpTunnelBranchDiscontinuityTime, jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType=jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType, jnxMplsTeP2mpTunnelDestOperStatus=jnxMplsTeP2mpTunnelDestOperStatus, jnxMplsTeP2mpScalars=jnxMplsTeP2mpScalars, jnxMplsTeP2mpTunnelBranchPerfTable=jnxMplsTeP2mpTunnelBranchPerfTable, jnxMplsTeP2mpTunnelDestARHopTableIndex=jnxMplsTeP2mpTunnelDestARHopTableIndex, jnxMplsTeP2mpTunnelDestStorageType=jnxMplsTeP2mpTunnelDestStorageType, jnxMplsTeP2mpTunnelNotificationEnable=jnxMplsTeP2mpTunnelNotificationEnable, jnxMplsTeP2mpTunnelStorageType=jnxMplsTeP2mpTunnelStorageType, jnxMplsTeP2mpTunnelDestInstanceUpTime=jnxMplsTeP2mpTunnelDestInstanceUpTime, jnxMplsTeP2mpTunnelDestUp=jnxMplsTeP2mpTunnelDestUp, jnxMplsTeP2mpCompliances=jnxMplsTeP2mpCompliances, jnxMplsTeP2mpTunnelDestPathInUse=jnxMplsTeP2mpTunnelDestPathInUse, jnxMplsTeP2mpTunnelBranchPerfHCBytes=jnxMplsTeP2mpTunnelBranchPerfHCBytes, jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin=jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin, jnxMplsTeP2mpTunnelBranchPerfEntry=jnxMplsTeP2mpTunnelBranchPerfEntry, jnxMplsTeP2mpTunnelBranchRole=jnxMplsTeP2mpTunnelBranchRole, jnxMplsTeP2mpTunnelRowStatus=jnxMplsTeP2mpTunnelRowStatus, jnxMplsTeP2mpGeneralGroup=jnxMplsTeP2mpGeneralGroup, jnxMplsTeP2mpTunnelDestDown=jnxMplsTeP2mpTunnelDestDown, jnxMplsTeP2mpTunnelActive=jnxMplsTeP2mpTunnelActive, jnxMplsTeP2mpTunnelBranchPerfBytes=jnxMplsTeP2mpTunnelBranchPerfBytes, jnxMplsTeP2mpObjects=jnxMplsTeP2mpObjects, jnxMplsTeP2mpModuleFullCompliance=jnxMplsTeP2mpModuleFullCompliance, jnxMplsTeP2mpTunnelDestDestinationType=jnxMplsTeP2mpTunnelDestDestinationType, jnxMplsTeP2mpTunnelDestAdminStatus=jnxMplsTeP2mpTunnelDestAdminStatus, jnxMplsTeP2mpTunnelDestPathChanges=jnxMplsTeP2mpTunnelDestPathChanges)

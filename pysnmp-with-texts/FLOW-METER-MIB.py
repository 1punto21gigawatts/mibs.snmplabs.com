#
# PySNMP MIB module FLOW-METER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/FLOW-METER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:14:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
TimeFilter, = mibBuilder.importSymbols("RMON2-MIB", "TimeFilter")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
mib_2, Counter32, Unsigned32, Bits, NotificationType, IpAddress, MibIdentifier, Counter64, Integer32, Gauge32, iso, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "mib-2", "Counter32", "Unsigned32", "Bits", "NotificationType", "IpAddress", "MibIdentifier", "Counter64", "Integer32", "Gauge32", "iso", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "ObjectIdentity")
DisplayString, TextualConvention, TruthValue, TimeStamp, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue", "TimeStamp", "RowStatus")
flowMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 40))
flowMIB.setRevisions(('1999-10-25 00:00', '1999-08-30 12:50', '1999-08-19 10:10', '1997-12-23 09:37', '1997-07-07 17:15', '1996-03-08 02:08',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: flowMIB.setRevisionsDescriptions(('Initial Version, published as RFC 2720.', 'UTF8OwnerString Textual Convention added, and used to replace OwnerString. Conceptually the same as OwnerString, but facilitating internationalisation by using UTF-8 encoding for its characters rather than US-ASCII.', 'Changes to SIZE specification for two variables: - flowRuleInfoName SIZE specified as (0..127) - flowRuleIndex SIZE increased to (1..2147483647)', 'Two further variables deprecated: - flowRuleInfoRulesReady (use flowRuleInfoStatus intead) - flowDataStatus (contains no useful information)', 'Significant changes since RFC 2064 include: - flowDataPackageTable added - flowColumnActivityTable deprecated - flowManagerCounterWrap deprecated', 'Initial version of this MIB (RFC 2064)',))
if mibBuilder.loadTexts: flowMIB.setLastUpdated('9910250000Z')
if mibBuilder.loadTexts: flowMIB.setOrganization('IETF Realtime Traffic Flow Measurement Working Group')
if mibBuilder.loadTexts: flowMIB.setContactInfo('Nevil Brownlee, The University of Auckland Postal: Information Technology Sytems & Services The University of Auckland Private Bag 92-019 Auckland, New Zealand Phone: +64 9 373 7599 x8941 E-mail: n.brownlee@auckland.ac.nz')
if mibBuilder.loadTexts: flowMIB.setDescription('MIB for the RTFM Traffic Flow Meter.')
flowControl = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 1))
flowData = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 2))
flowRules = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 3))
flowMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 4))
class UTF8OwnerString(TextualConvention, OctetString):
    description = 'An administratively assigned name for the owner of a resource, conceptually the same as OwnerString in the RMON MIB [RMON-MIB]. To facilitate internationalisation, this name information is represented using the ISO/IEC IS 10646-1 character set, encoded as an octet string using the UTF-8 transformation format described in the UTF-8 standard [UTF-8].'
    status = 'current'
    displayHint = '127t'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 127)

class PeerType(TextualConvention, Integer32):
    description = "Indicates the type of a PeerAddress (see below). The values used are from the 'Address Family Numbers' section of the Assigned Numbers RFC [ASG-NBR]. Peer types from other address families may also be used, provided only that they are identified by their assigned Address Family numbers."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11, 12, 13))
    namedValues = NamedValues(("ipv4", 1), ("ipv6", 2), ("nsap", 3), ("ipx", 11), ("appletalk", 12), ("decnet", 13))

class PeerAddress(TextualConvention, OctetString):
    description = 'Specifies the value of a peer address for various network protocols. Address format depends on the actual protocol, as indicated below: IPv4: ipv4(1) 4-octet IpAddress (defined in the SNMPv2 SMI [RFC2578]) IPv6: ipv6(2) 16-octet IpAddress (defined in the IPv6 Addressing RFC [V6-ADDR]) CLNS: nsap(3) NsapAddress (defined in the SNMPv2 SMI [RFC2578]) Novell: ipx(11) 4-octet Network number, 6-octet Host number (MAC address) AppleTalk: appletalk(12) 2-octet Network number (sixteen bits), 1-octet Host number (eight bits) DECnet: decnet(13) 1-octet Area number (in low-order six bits), 2-octet Host number (in low-order ten bits) '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 20)

class AdjacentType(TextualConvention, Integer32):
    description = "Indicates the type of an adjacent address. May be a medium type or (if metering is taking place inside a tunnel) a PeerType (see above). The values used for IEEE 802 medium types are from the 'Network Management Parameters (ifType definitions)' section of the Assigned Numbers RFC [ASG-NBR]. Other medium types may also be used, provided only that they are identified by their assigned ifType numbers."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 3, 7, 9, 11, 12, 13, 15))
    namedValues = NamedValues(("ip", 1), ("nsap", 3), ("ethernet", 7), ("tokenring", 9), ("ipx", 11), ("appletalk", 12), ("decnet", 13), ("fddi", 15))

class AdjacentAddress(TextualConvention, OctetString):
    description = "Specifies the value of an adjacent address. May be a Medium Access Control (MAC) address or (if metering is taking place inside a tunnel) a PeerAddress (see above). MAC Address format depends on the actual medium, as follows: Ethernet: ethernet(7) 6-octet 802.3 MAC address in 'canonical' order Token Ring: tokenring(9) 6-octet 802.5 MAC address in 'canonical' order FDDI: fddi(15) FddiMACLongAddress, i.e. a 6-octet MAC address in 'canonical' order (defined in [FDDI-MIB]) "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 20)

class TransportType(TextualConvention, Integer32):
    description = "Indicates the type of a TransportAddress (see below). Values will depend on the actual protocol; for IP they will be those given in the 'Protocol Numbers' section of the Assigned Numbers RFC [ASG-NBR], including icmp(1), tcp(6) and udp(17)."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 255)

class TransportAddress(TextualConvention, OctetString):
    description = 'Specifies the value of a transport address for various network protocols. Format as follows: IP: 2-octet UDP or TCP port number Other protocols: 2-octet port number '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class RuleAddress(TextualConvention, OctetString):
    description = 'Specifies the value of an address. Is a superset of MediumAddress, PeerAddress and TransportAddress.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 20)

class FlowAttributeNumber(TextualConvention, Integer32):
    description = 'Uniquely identifies an attribute within a flow data record.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41))
    namedValues = NamedValues(("flowIndex", 1), ("flowStatus", 2), ("flowTimeMark", 3), ("sourceInterface", 4), ("sourceAdjacentType", 5), ("sourceAdjacentAddress", 6), ("sourceAdjacentMask", 7), ("sourcePeerType", 8), ("sourcePeerAddress", 9), ("sourcePeerMask", 10), ("sourceTransType", 11), ("sourceTransAddress", 12), ("sourceTransMask", 13), ("destInterface", 14), ("destAdjacentType", 15), ("destAdjacentAddress", 16), ("destAdjacentMask", 17), ("destPeerType", 18), ("destPeerAddress", 19), ("destPeerMask", 20), ("destTransType", 21), ("destTransAddress", 22), ("destTransMask", 23), ("pduScale", 24), ("octetScale", 25), ("ruleSet", 26), ("toOctets", 27), ("toPDUs", 28), ("fromOctets", 29), ("fromPDUs", 30), ("firstTime", 31), ("lastActiveTime", 32), ("sourceSubscriberID", 33), ("destSubscriberID", 34), ("sessionID", 35), ("sourceClass", 36), ("destClass", 37), ("flowClass", 38), ("sourceKind", 39), ("destKind", 40), ("flowKind", 41))

class RuleAttributeNumber(TextualConvention, Integer32):
    description = "Uniquely identifies an attribute which may be tested in a rule. These include attributes whose values come directly from (or are computed from) the flow's packets, and the five 'meter' variables used to hold an Attribute Number."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 8, 9, 11, 12, 14, 15, 16, 18, 19, 21, 22, 33, 34, 35, 36, 37, 38, 39, 40, 41, 50, 51, 52, 53, 54, 55))
    namedValues = NamedValues(("null", 0), ("sourceInterface", 4), ("sourceAdjacentType", 5), ("sourceAdjacentAddress", 6), ("sourcePeerType", 8), ("sourcePeerAddress", 9), ("sourceTransType", 11), ("sourceTransAddress", 12), ("destInterface", 14), ("destAdjacentType", 15), ("destAdjacentAddress", 16), ("destPeerType", 18), ("destPeerAddress", 19), ("destTransType", 21), ("destTransAddress", 22), ("sourceSubscriberID", 33), ("destSubscriberID", 34), ("sessionID", 35), ("sourceClass", 36), ("destClass", 37), ("flowClass", 38), ("sourceKind", 39), ("destKind", 40), ("flowKind", 41), ("matchingStoD", 50), ("v1", 51), ("v2", 52), ("v3", 53), ("v4", 54), ("v5", 55))

class ActionNumber(TextualConvention, Integer32):
    description = "Uniquely identifies the action of a rule, i.e. the Pattern Matching Engine's opcode number. Details of the opcodes are given in the 'Traffic Flow Measurement: Architecture' document [RTFM-ARC]."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))
    namedValues = NamedValues(("ignore", 1), ("noMatch", 2), ("count", 3), ("countPkt", 4), ("return", 5), ("gosub", 6), ("gosubAct", 7), ("assign", 8), ("assignAct", 9), ("goto", 10), ("gotoAct", 11), ("pushRuleTo", 12), ("pushRuleToAct", 13), ("pushPktTo", 14), ("pushPktToAct", 15), ("popTo", 16), ("popToAct", 17))

flowRuleSetInfoTable = MibTable((1, 3, 6, 1, 2, 1, 40, 1, 1), )
if mibBuilder.loadTexts: flowRuleSetInfoTable.setStatus('current')
if mibBuilder.loadTexts: flowRuleSetInfoTable.setDescription("An array of information about the RuleSets held in the meter. Any manager may configure a new RuleSet for the meter by creating a row in this table with status active(1), and setting values for all the objects in its rules. At this stage the new RuleSet is available but not 'running', i.e. it is not being used by the meter to produce entries in the flow table. To actually 'run' a RuleSet a manager must create a row in the flowManagerInfoTable, set it's flowManagerStatus to active(1), and set either its CurrentRuleSet or StandbyRuleSet to point to the RuleSet to be run. Once a RuleSet is running a manager may not change any of the objects within the RuleSet itself. Any attempt to do so should result in a notWritable(17) SNMP error-status for such objects. A manager may stop a RuleSet running by removing all references to it in the flowManagerInfoTable (i.e. by setting CurrentRuleSet and StandbyRuleSet values to 0). This provides a way to stop RuleSets left running if a manager fails. For example, when a manager is started, it could search the meter's flowManager table and stop all RuleSets having a specified value of flowRuleInfoOwner. To prevent a manager from interfering with variables belonging to another manager, the meter should use MIB views [RFC2575] so as to limit each manager's access to the meter's variables, effectively dividing the single meter into several virtual meters, one for each independent manager.")
flowRuleSetInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 1, 1, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowRuleInfoIndex"))
if mibBuilder.loadTexts: flowRuleSetInfoEntry.setStatus('current')
if mibBuilder.loadTexts: flowRuleSetInfoEntry.setDescription('Information about a particular RuleSet.')
flowRuleInfoIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowRuleInfoIndex.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoIndex.setDescription('An index which selects an entry in the flowRuleSetInfoTable. Each such entry contains control information for a particular RuleSet which the meter may run.')
flowRuleInfoSize = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowRuleInfoSize.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoSize.setDescription('Number of rules in this RuleSet. Setting this variable will cause the meter to allocate space for these rules.')
flowRuleInfoOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 3), UTF8OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowRuleInfoOwner.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoOwner.setDescription("Identifies the manager which 'owns' this RuleSet. A manager must set this variable when creating a row in this table.")
flowRuleInfoTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowRuleInfoTimeStamp.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoTimeStamp.setDescription("Time this row's associated RuleSet was last changed.")
flowRuleInfoStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowRuleInfoStatus.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoStatus.setDescription("The status of this flowRuleSetInfoEntry. If this value is not active(1) the meter must not attempt to use the row's associated RuleSet. Once its value has been set to active(1) a manager may not change any of the other variables in the row, nor the contents of the associated RuleSet. Any attempt to do so should result in a notWritable(17) SNMP error-status for such variables or objects. To download a RuleSet, a manger could: - Locate an open slot in the RuleSetInfoTable. - Create a RuleSetInfoEntry by setting the status for this open slot to createAndWait(5). - Set flowRuleInfoSize and flowRuleInfoName as required. - Download the rules into the row's rule table. - Set flowRuleInfoStatus to active(1). The RuleSet would then be ready to run. The manager is not allowed to change the value of flowRuleInfoStatus from active(1) if the associated RuleSet is being referenced by any of the entries in the flowManagerInfoTable. Setting RuleInfoStatus to destroy(6) destroys the associated RuleSet together with any flow data collected by it.")
flowRuleInfoName = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowRuleInfoName.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoName.setDescription('An alphanumeric identifier used by managers and readers to identify a RuleSet. For example, a manager wishing to run a RuleSet named WWW-FLOWS could search the flowRuleSetInfoTable to see whether the WWW-FLOWS RuleSet is already available on the meter. Note that references to RuleSets in the flowManagerInfoTable use indexes for their flowRuleSetInfoTable entries. These may be different each time the RuleSet is loaded into a meter.')
flowRuleInfoRulesReady = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowRuleInfoRulesReady.setStatus('deprecated')
if mibBuilder.loadTexts: flowRuleInfoRulesReady.setDescription("Indicates whether the rules for this row's associated RuleSet are ready for use. The meter will refuse to 'run' the RuleSet unless this variable has been set to true(1). While RulesReady is false(2), the manager may modify the RuleSet, for example by downloading rules into it.")
flowRuleInfoFlowRecords = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowRuleInfoFlowRecords.setStatus('current')
if mibBuilder.loadTexts: flowRuleInfoFlowRecords.setDescription('The number of entries in the flow table for this RuleSet. These may be current (waiting for collection by one or more meter readers) or idle (waiting for the meter to recover their memory).')
flowInterfaceTable = MibTable((1, 3, 6, 1, 2, 1, 40, 1, 2), )
if mibBuilder.loadTexts: flowInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: flowInterfaceTable.setDescription('An array of information specific to each meter interface.')
flowInterfaceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: flowInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: flowInterfaceEntry.setDescription('Information about a particular interface.')
flowInterfaceSampleRate = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 2, 1, 1), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowInterfaceSampleRate.setStatus('current')
if mibBuilder.loadTexts: flowInterfaceSampleRate.setDescription("The parameter N for statistical counting on this interface. Set to N to count 1/Nth of the packets appearing at this interface. A sampling rate of 1 counts all packets. A sampling rate of 0 results in the interface being ignored by the meter. A meter should choose its own algorithm to introduce variance into the sampling so that exactly every Nth packet is counted. The IPPM Working Group's RFC 'Framework for IP Performance Metrics' [IPPM-FRM] explains why this should be done, and sets out an algorithm for doing it.")
flowInterfaceLostPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowInterfaceLostPackets.setStatus('current')
if mibBuilder.loadTexts: flowInterfaceLostPackets.setDescription('The number of packets the meter has lost for this interface. Such losses may occur because the meter has been unable to keep up with the traffic volume.')
flowReaderInfoTable = MibTable((1, 3, 6, 1, 2, 1, 40, 1, 3), )
if mibBuilder.loadTexts: flowReaderInfoTable.setStatus('current')
if mibBuilder.loadTexts: flowReaderInfoTable.setDescription('An array of information about meter readers which have registered their intent to collect flow data from this meter.')
flowReaderInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 1, 3, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowReaderIndex"))
if mibBuilder.loadTexts: flowReaderInfoEntry.setStatus('current')
if mibBuilder.loadTexts: flowReaderInfoEntry.setDescription('Information about a particular meter reader.')
flowReaderIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowReaderIndex.setStatus('current')
if mibBuilder.loadTexts: flowReaderIndex.setDescription('An index which selects an entry in the flowReaderInfoTable.')
flowReaderTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowReaderTimeout.setStatus('current')
if mibBuilder.loadTexts: flowReaderTimeout.setDescription('Specifies the maximum time (in seconds) between flow data collections for this meter reader. If this time elapses without a collection, the meter should assume that this meter reader has stopped collecting, and delete this row from the table. A value of zero indicates that this row should not be timed out.')
flowReaderOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 3), UTF8OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowReaderOwner.setStatus('current')
if mibBuilder.loadTexts: flowReaderOwner.setDescription('Identifies the meter reader which created this row.')
flowReaderLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 4), TimeStamp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowReaderLastTime.setStatus('current')
if mibBuilder.loadTexts: flowReaderLastTime.setDescription('Time this meter reader began its most recent data collection. This variable should be written by a meter reader as its first step in reading flow data. The meter will set this LastTime value to its current Uptime, and set its PreviousTime value (below) to the old LastTime. This allows the meter to recover flows which have been inactive since PreviousTime, for these have been collected at least once. If the meter reader fails to write flowLastReadTime, collection may still proceed but the meter may not be able to recover inactive flows until the flowReaderTimeout has been reached for this entry.')
flowReaderPreviousTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowReaderPreviousTime.setStatus('current')
if mibBuilder.loadTexts: flowReaderPreviousTime.setDescription('Time this meter reader began the collection before last.')
flowReaderStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowReaderStatus.setStatus('current')
if mibBuilder.loadTexts: flowReaderStatus.setDescription("The status of this FlowReaderInfoEntry. A value of active(1) implies that the associated reader should be collecting data from the meter. Once this variable has been set to active(1) a manager may only change this row's flowReaderLastTime and flowReaderTimeout variables.")
flowReaderRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowReaderRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowReaderRuleSet.setDescription("An index to the array of RuleSets. Specifies a set of rules of interest to this meter reader. The reader will attempt to collect any data generated by the meter for this RuleSet, and the meter will not recover the memory of any of the RuleSet's flows until this collection has taken place. Note that a reader may have entries in this table for several RuleSets.")
flowManagerInfoTable = MibTable((1, 3, 6, 1, 2, 1, 40, 1, 4), )
if mibBuilder.loadTexts: flowManagerInfoTable.setStatus('current')
if mibBuilder.loadTexts: flowManagerInfoTable.setDescription('An array of information about managers which have registered their intent to run RuleSets on this meter.')
flowManagerInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 1, 4, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowManagerIndex"))
if mibBuilder.loadTexts: flowManagerInfoEntry.setStatus('current')
if mibBuilder.loadTexts: flowManagerInfoEntry.setDescription("Information about a particular meter 'task.' By creating an entry in this table and activating it, a manager requests that the meter 'run' the indicated RuleSet. The entry also specifies a HighWaterMark and a StandbyRuleSet. If the meter's flow table usage exceeds this task's HighWaterMark the meter will stop running the task's CurrentRuleSet and switch to its StandbyRuleSet. If the value of the task's StandbyRuleSet is 0 when its HighWaterMark is exceeded, the meter simply stops running the task's CurrentRuleSet. By careful selection of HighWaterMarks for the various tasks a manager can ensure that the most critical RuleSets are the last to stop running as the number of flows increases. When a manager has determined that the demand for flow table space has abated, it may cause the task to switch back to its CurrentRuleSet by setting its flowManagerRunningStandby variable to false(2).")
flowManagerIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowManagerIndex.setStatus('current')
if mibBuilder.loadTexts: flowManagerIndex.setDescription('An index which selects an entry in the flowManagerInfoTable.')
flowManagerCurrentRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerCurrentRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowManagerCurrentRuleSet.setDescription("Index to the array of RuleSets. Specifies which set of rules is the 'current' one for this task. The meter will be 'running' the current RuleSet if this row's flowManagerRunningStandby value is false(2). When the manager sets this variable the meter will stop using the task's old current RuleSet and start using the new one. Specifying RuleSet 0 (the empty set) stops flow measurement for this task.")
flowManagerStandbyRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerStandbyRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowManagerStandbyRuleSet.setDescription("Index to the array of RuleSets. After reaching HighWaterMark (see below) the manager will switch to using the task's StandbyRuleSet in place of its CurrentRuleSet. For this to be effective the designated StandbyRuleSet should have a coarser reporting granularity then the CurrentRuleSet. The manager may also need to decrease the meter reading interval so that the meter can recover flows measured by this task's CurrentRuleSet.")
flowManagerHighWaterMark = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerHighWaterMark.setStatus('current')
if mibBuilder.loadTexts: flowManagerHighWaterMark.setDescription('A value expressed as a percentage, interpreted by the meter as an indication of how full the flow table should be before it should switch to the standby RuleSet (if one has been specified) for this task. Values of 0% or 100% disable the checking represented by this variable.')
flowManagerCounterWrap = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wrap", 1), ("scale", 2))).clone('wrap')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerCounterWrap.setStatus('deprecated')
if mibBuilder.loadTexts: flowManagerCounterWrap.setDescription('Specifies whether PDU and octet counters should wrap when they reach the top of their range (normal behaviour for Counter64 objects), or whether their scale factors should be used instead. The combination of counter and scale factor allows counts to be returned as non-negative binary floating point numbers, with 64-bit mantissas and 8-bit exponents.')
flowManagerOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 6), UTF8OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerOwner.setStatus('current')
if mibBuilder.loadTexts: flowManagerOwner.setDescription('Identifies the manager which created this row.')
flowManagerTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowManagerTimeStamp.setStatus('current')
if mibBuilder.loadTexts: flowManagerTimeStamp.setDescription('Time this row was last changed by its manager.')
flowManagerStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerStatus.setStatus('current')
if mibBuilder.loadTexts: flowManagerStatus.setDescription('The status of this row in the flowManagerInfoTable. A value of active(1) implies that this task may be activated, by setting its CurrentRuleSet and StandbyRuleSet variables. Its HighWaterMark and RunningStandby variables may also be changed.')
flowManagerRunningStandby = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 1, 4, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowManagerRunningStandby.setStatus('current')
if mibBuilder.loadTexts: flowManagerRunningStandby.setDescription("Set to true(1) by the meter to indicate that it has switched to runnning this task's StandbyRuleSet in place of its CurrentRuleSet. To switch back to the CurrentRuleSet, the manager may simply set this variable to false(2).")
flowFloodMark = MibScalar((1, 3, 6, 1, 2, 1, 40, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(95)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowFloodMark.setStatus('current')
if mibBuilder.loadTexts: flowFloodMark.setDescription('A value expressed as a percentage, interpreted by the meter as an indication of how full the flow table should be before it should take some action to avoid running out of resources to handle new flows, as discussed in section 4.6 (Handling Increasing Traffic Levels) of the RTFM Architecture RFC [RTFM-ARC]. Values of 0% or 100% disable the checking represented by this variable.')
flowInactivityTimeout = MibScalar((1, 3, 6, 1, 2, 1, 40, 1, 6), Integer32().clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowInactivityTimeout.setStatus('current')
if mibBuilder.loadTexts: flowInactivityTimeout.setDescription("The time in seconds since the last packet seen, after which a flow becomes 'idle.' Note that although a flow may be idle, it will not be discarded (and its memory recovered) until after its data has been collected by all the meter readers registered for its RuleSet.")
flowActiveFlows = MibScalar((1, 3, 6, 1, 2, 1, 40, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowActiveFlows.setStatus('current')
if mibBuilder.loadTexts: flowActiveFlows.setDescription('The number of flows which are currently in use.')
flowMaxFlows = MibScalar((1, 3, 6, 1, 2, 1, 40, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowMaxFlows.setStatus('current')
if mibBuilder.loadTexts: flowMaxFlows.setDescription("The maximum number of flows allowed in the meter's flow table. At present this is determined when the meter is first started up.")
flowFloodMode = MibScalar((1, 3, 6, 1, 2, 1, 40, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowFloodMode.setStatus('current')
if mibBuilder.loadTexts: flowFloodMode.setDescription('Indicates that the meter has passed its FloodMark and is not running in its normal mode. When the manager notices this it should take action to remedy the problem which caused the flooding. It should then monitor flowActiveFlows so as to determine when the flood has receded. At that point the manager may set flowFloodMode to false(2) to resume normal operation.')
flowDataTable = MibTable((1, 3, 6, 1, 2, 1, 40, 2, 1), )
if mibBuilder.loadTexts: flowDataTable.setStatus('current')
if mibBuilder.loadTexts: flowDataTable.setDescription('The list of all flows being measured.')
flowDataEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 2, 1, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowDataRuleSet"), (0, "FLOW-METER-MIB", "flowDataTimeMark"), (0, "FLOW-METER-MIB", "flowDataIndex"))
if mibBuilder.loadTexts: flowDataEntry.setStatus('current')
if mibBuilder.loadTexts: flowDataEntry.setDescription('The flow data record for a particular flow.')
flowDataIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowDataIndex.setStatus('current')
if mibBuilder.loadTexts: flowDataIndex.setDescription("Value of this flow data record's index within the meter's flow table.")
flowDataTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 2), TimeFilter())
if mibBuilder.loadTexts: flowDataTimeMark.setStatus('current')
if mibBuilder.loadTexts: flowDataTimeMark.setDescription("A TimeFilter for this entry. Allows GetNext and GetBulk to find flow table rows which have changed since a specified value of the meter's Uptime.")
flowDataStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("current", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataStatus.setStatus('deprecated')
if mibBuilder.loadTexts: flowDataStatus.setDescription('Status of this flow data record.')
flowDataSourceInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceInterface.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceInterface.setDescription("Index of the interface associated with the source address for this flow. It's value is one of those contained in the ifIndex field of the meter's interfaces table.")
flowDataSourceAdjacentType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 5), AdjacentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceAdjacentType.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceAdjacentType.setDescription('Adjacent address type of the source for this flow. If metering is being performed at the network level, AdjacentType will indicate the medium for the interface on which the flow was observed and AdjacentAddress will be the MAC address for that interface. This is the usual case. If traffic is being metered inside a tunnel, AdjacentType will be the peer type of the host at the end of the tunnel and AdjacentAddress will be the peer address for that host.')
flowDataSourceAdjacentAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 6), AdjacentAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceAdjacentAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceAdjacentAddress.setDescription('Address of the adjacent device on the path for the source for this flow.')
flowDataSourceAdjacentMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 7), AdjacentAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceAdjacentMask.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceAdjacentMask.setDescription('1-bits in this mask indicate which bits must match when comparing the adjacent source address for this flow.')
flowDataSourcePeerType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 8), PeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourcePeerType.setStatus('current')
if mibBuilder.loadTexts: flowDataSourcePeerType.setDescription('Peer address type of the source for this flow.')
flowDataSourcePeerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 9), PeerAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourcePeerAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataSourcePeerAddress.setDescription('Address of the peer device for the source of this flow.')
flowDataSourcePeerMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 10), PeerAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourcePeerMask.setStatus('current')
if mibBuilder.loadTexts: flowDataSourcePeerMask.setDescription('1-bits in this mask indicate which bits must match when comparing the source peer address for this flow.')
flowDataSourceTransType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 11), TransportType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceTransType.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceTransType.setDescription('Transport address type of the source for this flow. The value of this attribute will depend on the peer address type.')
flowDataSourceTransAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 12), TransportAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceTransAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceTransAddress.setDescription('Transport address for the source of this flow.')
flowDataSourceTransMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 13), TransportAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceTransMask.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceTransMask.setDescription('1-bits in this mask indicate which bits must match when comparing the transport source address for this flow.')
flowDataDestInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestInterface.setStatus('current')
if mibBuilder.loadTexts: flowDataDestInterface.setDescription('Index of the interface associated with the dest address for this flow. This value is one of the values contained in the ifIndex field of the interfaces table.')
flowDataDestAdjacentType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 15), AdjacentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestAdjacentType.setStatus('current')
if mibBuilder.loadTexts: flowDataDestAdjacentType.setDescription('Adjacent address type of the destination for this flow.')
flowDataDestAdjacentAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 16), AdjacentAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestAdjacentAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataDestAdjacentAddress.setDescription('Address of the adjacent device on the path for the destination for this flow.')
flowDataDestAdjacentMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 17), AdjacentAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestAdjacentMask.setStatus('current')
if mibBuilder.loadTexts: flowDataDestAdjacentMask.setDescription('1-bits in this mask indicate which bits must match when comparing the adjacent destination address for this flow.')
flowDataDestPeerType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 18), PeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestPeerType.setStatus('current')
if mibBuilder.loadTexts: flowDataDestPeerType.setDescription('Peer address type of the destination for this flow.')
flowDataDestPeerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 19), PeerAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestPeerAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataDestPeerAddress.setDescription('Address of the peer device for the destination of this flow.')
flowDataDestPeerMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 20), PeerAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestPeerMask.setStatus('current')
if mibBuilder.loadTexts: flowDataDestPeerMask.setDescription('1-bits in this mask indicate which bits must match when comparing the destination peer type for this flow.')
flowDataDestTransType = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 21), TransportType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestTransType.setStatus('current')
if mibBuilder.loadTexts: flowDataDestTransType.setDescription('Transport address type of the destination for this flow. The value of this attribute will depend on the peer address type.')
flowDataDestTransAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 22), TransportAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestTransAddress.setStatus('current')
if mibBuilder.loadTexts: flowDataDestTransAddress.setDescription('Transport address for the destination of this flow.')
flowDataDestTransMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 23), TransportAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestTransMask.setStatus('current')
if mibBuilder.loadTexts: flowDataDestTransMask.setDescription('1-bits in this mask indicate which bits must match when comparing the transport destination address for this flow.')
flowDataPDUScale = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataPDUScale.setStatus('current')
if mibBuilder.loadTexts: flowDataPDUScale.setDescription('The scale factor applied to this particular flow. Indicates the number of bits the PDU counter values should be moved left to obtain the actual values.')
flowDataOctetScale = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataOctetScale.setStatus('current')
if mibBuilder.loadTexts: flowDataOctetScale.setDescription('The scale factor applied to this particular flow. Indicates the number of bits the octet counter values should be moved left to obtain the actual values.')
flowDataRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: flowDataRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowDataRuleSet.setDescription('The RuleSet number of the RuleSet which created this flow. Allows a manager to use GetNext or GetBulk requests to find flows belonging to a particular RuleSet.')
flowDataToOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataToOctets.setStatus('current')
if mibBuilder.loadTexts: flowDataToOctets.setDescription('The count of octets flowing from source to destination for this flow.')
flowDataToPDUs = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataToPDUs.setStatus('current')
if mibBuilder.loadTexts: flowDataToPDUs.setDescription('The count of packets flowing from source to destination for this flow.')
flowDataFromOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataFromOctets.setStatus('current')
if mibBuilder.loadTexts: flowDataFromOctets.setDescription('The count of octets flowing from destination to source for this flow.')
flowDataFromPDUs = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataFromPDUs.setStatus('current')
if mibBuilder.loadTexts: flowDataFromPDUs.setDescription('The count of packets flowing from destination to source for this flow.')
flowDataFirstTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 31), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataFirstTime.setStatus('current')
if mibBuilder.loadTexts: flowDataFirstTime.setDescription('The time at which this flow was first entered in the table')
flowDataLastActiveTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataLastActiveTime.setStatus('current')
if mibBuilder.loadTexts: flowDataLastActiveTime.setDescription('The last time this flow had activity, i.e. the time of arrival of the most recent PDU belonging to this flow.')
flowDataSourceSubscriberID = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 33), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceSubscriberID.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceSubscriberID.setDescription('Subscriber ID associated with the source address for this flow. A Subscriber ID is an unspecified text string, used to ascribe traffic flows to individual users. At this time the means by which a Subscriber ID may be associated with a flow is unspecified.')
flowDataDestSubscriberID = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 34), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestSubscriberID.setStatus('current')
if mibBuilder.loadTexts: flowDataDestSubscriberID.setDescription('Subscriber ID associated with the destination address for this flow. A Subscriber ID is an unspecified text string, used to ascribe traffic flows to individual users. At this time the means by which a Subscriber ID may be associated with a flow is unspecified.')
flowDataSessionID = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 35), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSessionID.setStatus('current')
if mibBuilder.loadTexts: flowDataSessionID.setDescription('Session ID for this flow. Such an ID might be allocated by a network access server to distinguish a series of sessions between the same pair of addresses, which would otherwise appear to be parts of the same accounting flow.')
flowDataSourceClass = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceClass.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceClass.setDescription('Source class for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowDataDestClass = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestClass.setStatus('current')
if mibBuilder.loadTexts: flowDataDestClass.setDescription('Destination class for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowDataClass = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataClass.setStatus('current')
if mibBuilder.loadTexts: flowDataClass.setDescription('Class for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowDataSourceKind = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataSourceKind.setStatus('current')
if mibBuilder.loadTexts: flowDataSourceKind.setDescription('Source kind for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowDataDestKind = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataDestKind.setStatus('current')
if mibBuilder.loadTexts: flowDataDestKind.setDescription('Destination kind for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowDataKind = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowDataKind.setStatus('current')
if mibBuilder.loadTexts: flowDataKind.setDescription('Class for this flow. Determined by the rules, set by a PushRule action when this flow was entered in the table.')
flowColumnActivityTable = MibTable((1, 3, 6, 1, 2, 1, 40, 2, 2), )
if mibBuilder.loadTexts: flowColumnActivityTable.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityTable.setDescription('Index into the Flow Table. Allows a meter reader to retrieve a list containing the flow table indexes of flows which were last active at or after a given time, together with the values of a specified attribute for each such flow.')
flowColumnActivityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 2, 2, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowColumnActivityAttribute"), (0, "FLOW-METER-MIB", "flowColumnActivityTime"), (0, "FLOW-METER-MIB", "flowColumnActivityIndex"))
if mibBuilder.loadTexts: flowColumnActivityEntry.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityEntry.setDescription('The Column Activity Entry for a particular attribute, activity time and flow.')
flowColumnActivityAttribute = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 2, 1, 1), FlowAttributeNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowColumnActivityAttribute.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityAttribute.setDescription('Specifies the attribute for which values are required from active flows.')
flowColumnActivityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 2, 1, 2), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowColumnActivityTime.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityTime.setDescription('This variable is a copy of flowDataLastActiveTime in the flow data record identified by the flowColumnActivityIndex value of this flowColumnActivityTable entry.')
flowColumnActivityIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowColumnActivityIndex.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityIndex.setDescription('Index of a flow table entry which was active at or after a specified flowColumnActivityTime.')
flowColumnActivityData = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowColumnActivityData.setStatus('deprecated')
if mibBuilder.loadTexts: flowColumnActivityData.setDescription('Collection of attribute data for flows active after flowColumnActivityTime. Within the OCTET STRING is a sequence of { flow index, attribute value } pairs, one for each active flow. The end of the sequence is marked by a flow index value of 0, indicating that there are no more rows in this column. The format of objects inside flowColumnFlowData is as follows. All numbers are unsigned. Numbers and strings appear with their high-order bytes leading. Numbers are fixed size, as specified by their SYNTAX in the flow table (above), i.e. one octet for flowAddressType and small constants, and four octets for Counter and TimeStamp. Strings are variable-length, with the length given in a single leading octet. The following is an attempt at an ASN.1 definition of flowColumnActivityData: flowColumnActivityData ::= SEQUENCE flowRowItemEntry flowRowItemEntry ::= SEQUENCE { flowRowNumber Integer32 (1..65535), -- 0 indicates the end of this column flowDataValue flowDataType -- Choice depends on attribute } flowDataType ::= CHOICE { flowByteValue Integer32 (1..255), flowShortValue Integer32 (1..65535), flowLongValue Integer32, flowStringValue OCTET STRING -- Length (n) in first byte, -- n+1 bytes total length, trailing zeroes truncated }')
flowDataPackageTable = MibTable((1, 3, 6, 1, 2, 1, 40, 2, 3), )
if mibBuilder.loadTexts: flowDataPackageTable.setStatus('current')
if mibBuilder.loadTexts: flowDataPackageTable.setDescription('Index into the Flow Table. Allows a meter reader to retrieve a sequence containing the values of a specified set of attributes for a flow which came from a specified RuleSet and which was last active at or after a given time.')
flowDataPackageEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 2, 3, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowPackageSelector"), (0, "FLOW-METER-MIB", "flowPackageRuleSet"), (0, "FLOW-METER-MIB", "flowPackageTime"), (0, "FLOW-METER-MIB", "flowPackageIndex"))
if mibBuilder.loadTexts: flowDataPackageEntry.setStatus('current')
if mibBuilder.loadTexts: flowDataPackageEntry.setDescription('The data package containing selected variables from active rows in the flow table.')
flowPackageSelector = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 3, 1, 1), OctetString())
if mibBuilder.loadTexts: flowPackageSelector.setStatus('current')
if mibBuilder.loadTexts: flowPackageSelector.setDescription('Specifies the attributes for which values are required from an active flow. These are encoded as a sequence of octets each containing a FlowAttribute number, preceded by an octet giving the length of the sequence (not including the length octet). For a flowPackageSelector to be valid, it must contain at least one attribute.')
flowPackageRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: flowPackageRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowPackageRuleSet.setDescription('Specifies the index (in the flowRuleSetInfoTable) of the rule set which produced the required flow.')
flowPackageTime = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 3, 1, 3), TimeFilter())
if mibBuilder.loadTexts: flowPackageTime.setStatus('current')
if mibBuilder.loadTexts: flowPackageTime.setDescription('This variable is a copy of flowDataLastActiveTime in the flow data record identified by the flowPackageIndex value of this flowPackageTable entry.')
flowPackageIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowPackageIndex.setStatus('current')
if mibBuilder.loadTexts: flowPackageIndex.setDescription('Index of a flow table entry which was active at or after a specified flowPackageTime.')
flowPackageData = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 2, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flowPackageData.setStatus('current')
if mibBuilder.loadTexts: flowPackageData.setDescription("A collection of attribute values for a single flow, as specified by this row's indexes. The attribute values are contained within a BER-encoded sequence [ASN-1, ASN-BER], in the order they appear in their flowPackageSelector. For example, to retrieve a flowPackage containing values for attributes 11, 18 and 29, for a flow in RuleSet 7, with flow index 3447, one would GET the package whose Object Identifier (OID) is flowPackageData . 3.11.18.29 . 7. 0 . 3447 To get a package for the next such flow which had been active since time 12345 one would GETNEXT the package whose Object Identifier (OID) is flowPackageData . 3.11.18.29 . 7. 12345 . 3447")
flowRuleTable = MibTable((1, 3, 6, 1, 2, 1, 40, 3, 1), )
if mibBuilder.loadTexts: flowRuleTable.setStatus('current')
if mibBuilder.loadTexts: flowRuleTable.setDescription('Contains all the RuleSets which may be used by the meter.')
flowRuleEntry = MibTableRow((1, 3, 6, 1, 2, 1, 40, 3, 1, 1), ).setIndexNames((0, "FLOW-METER-MIB", "flowRuleSet"), (0, "FLOW-METER-MIB", "flowRuleIndex"))
if mibBuilder.loadTexts: flowRuleEntry.setStatus('current')
if mibBuilder.loadTexts: flowRuleEntry.setDescription('The rule record itself.')
flowRuleSet = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowRuleSet.setStatus('current')
if mibBuilder.loadTexts: flowRuleSet.setDescription('Selects a RuleSet from the array of RuleSets.')
flowRuleIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: flowRuleIndex.setStatus('current')
if mibBuilder.loadTexts: flowRuleIndex.setDescription('The index into the Rule table. N.B: These values will normally be consecutive, given the fall-through semantics of processing the table.')
flowRuleSelector = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 3), RuleAttributeNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowRuleSelector.setStatus('current')
if mibBuilder.loadTexts: flowRuleSelector.setDescription("Indicates the attribute to be matched. null(0) is a special case; null rules always succeed. matchingStoD(50) is set by the meter's Packet Matching Engine. Its value is true(1) if the PME is attempting to match the packet with its addresses in Source-to-Destination order (i.e. as they appear in the packet), and false(2) otherwise. Details of how packets are matched are given in the 'Traffic Flow Measurement: Architecture' document [RTFM-ARC]. v1(51), v2(52), v3(53), v4(54) and v5(55) select meter variables, each of which can hold the name (i.e. selector value) of an address attribute. When one of these is used as a selector, its value specifies the attribute to be tested. Variable values are set by an Assign action.")
flowRuleMask = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 4), RuleAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowRuleMask.setStatus('current')
if mibBuilder.loadTexts: flowRuleMask.setDescription("The initial mask used to compute the desired value. If the mask is zero the rule's test will always succeed.")
flowRuleMatchedValue = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 5), RuleAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowRuleMatchedValue.setStatus('current')
if mibBuilder.loadTexts: flowRuleMatchedValue.setDescription('The resulting value to be matched for equality. Specifically, if the attribute chosen by the flowRuleSelector logically ANDed with the mask specified by the flowRuleMask equals the value specified in the flowRuleMatchedValue, then continue processing the table entry based on the action specified by the flowRuleAction entry. Otherwise, proceed to the next entry in the rule table.')
flowRuleAction = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 6), ActionNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowRuleAction.setStatus('current')
if mibBuilder.loadTexts: flowRuleAction.setDescription("The action to be taken if this rule's test succeeds, or if the meter's 'test' flag is off. Actions are opcodes for the meter's Packet Matching Engine; details are given in the 'Traffic Flow Measurement: Architecture' document [RTFM-ARC].")
flowRuleParameter = MibTableColumn((1, 3, 6, 1, 2, 1, 40, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flowRuleParameter.setStatus('current')
if mibBuilder.loadTexts: flowRuleParameter.setDescription("A parameter value providing extra information for this rule's action. Most of the actions use the parameter value to specify which rule to execute after this rule's test has failed; details are given in the 'Traffic Flow Measurement: Architecture' document [RTFM-ARC].")
flowMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 4, 1))
flowMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 40, 4, 2))
flowControlGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 1)).setObjects(("FLOW-METER-MIB", "flowRuleInfoSize"), ("FLOW-METER-MIB", "flowRuleInfoOwner"), ("FLOW-METER-MIB", "flowRuleInfoTimeStamp"), ("FLOW-METER-MIB", "flowRuleInfoStatus"), ("FLOW-METER-MIB", "flowRuleInfoName"), ("FLOW-METER-MIB", "flowRuleInfoRulesReady"), ("FLOW-METER-MIB", "flowRuleInfoFlowRecords"), ("FLOW-METER-MIB", "flowInterfaceSampleRate"), ("FLOW-METER-MIB", "flowInterfaceLostPackets"), ("FLOW-METER-MIB", "flowReaderTimeout"), ("FLOW-METER-MIB", "flowReaderOwner"), ("FLOW-METER-MIB", "flowReaderLastTime"), ("FLOW-METER-MIB", "flowReaderPreviousTime"), ("FLOW-METER-MIB", "flowReaderStatus"), ("FLOW-METER-MIB", "flowReaderRuleSet"), ("FLOW-METER-MIB", "flowManagerCurrentRuleSet"), ("FLOW-METER-MIB", "flowManagerStandbyRuleSet"), ("FLOW-METER-MIB", "flowManagerHighWaterMark"), ("FLOW-METER-MIB", "flowManagerCounterWrap"), ("FLOW-METER-MIB", "flowManagerOwner"), ("FLOW-METER-MIB", "flowManagerTimeStamp"), ("FLOW-METER-MIB", "flowManagerStatus"), ("FLOW-METER-MIB", "flowManagerRunningStandby"), ("FLOW-METER-MIB", "flowFloodMark"), ("FLOW-METER-MIB", "flowInactivityTimeout"), ("FLOW-METER-MIB", "flowActiveFlows"), ("FLOW-METER-MIB", "flowMaxFlows"), ("FLOW-METER-MIB", "flowFloodMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowControlGroup = flowControlGroup.setStatus('deprecated')
if mibBuilder.loadTexts: flowControlGroup.setDescription('The control group defines objects which are used to control an accounting meter.')
flowDataTableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 2)).setObjects(("FLOW-METER-MIB", "flowDataStatus"), ("FLOW-METER-MIB", "flowDataSourceInterface"), ("FLOW-METER-MIB", "flowDataSourceAdjacentType"), ("FLOW-METER-MIB", "flowDataSourceAdjacentAddress"), ("FLOW-METER-MIB", "flowDataSourceAdjacentMask"), ("FLOW-METER-MIB", "flowDataSourcePeerType"), ("FLOW-METER-MIB", "flowDataSourcePeerAddress"), ("FLOW-METER-MIB", "flowDataSourcePeerMask"), ("FLOW-METER-MIB", "flowDataSourceTransType"), ("FLOW-METER-MIB", "flowDataSourceTransAddress"), ("FLOW-METER-MIB", "flowDataSourceTransMask"), ("FLOW-METER-MIB", "flowDataDestInterface"), ("FLOW-METER-MIB", "flowDataDestAdjacentType"), ("FLOW-METER-MIB", "flowDataDestAdjacentAddress"), ("FLOW-METER-MIB", "flowDataDestAdjacentMask"), ("FLOW-METER-MIB", "flowDataDestPeerType"), ("FLOW-METER-MIB", "flowDataDestPeerAddress"), ("FLOW-METER-MIB", "flowDataDestPeerMask"), ("FLOW-METER-MIB", "flowDataDestTransType"), ("FLOW-METER-MIB", "flowDataDestTransAddress"), ("FLOW-METER-MIB", "flowDataDestTransMask"), ("FLOW-METER-MIB", "flowDataToOctets"), ("FLOW-METER-MIB", "flowDataToPDUs"), ("FLOW-METER-MIB", "flowDataFromOctets"), ("FLOW-METER-MIB", "flowDataFromPDUs"), ("FLOW-METER-MIB", "flowDataFirstTime"), ("FLOW-METER-MIB", "flowDataLastActiveTime"), ("FLOW-METER-MIB", "flowDataSourceClass"), ("FLOW-METER-MIB", "flowDataDestClass"), ("FLOW-METER-MIB", "flowDataClass"), ("FLOW-METER-MIB", "flowDataSourceKind"), ("FLOW-METER-MIB", "flowDataDestKind"), ("FLOW-METER-MIB", "flowDataKind"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataTableGroup = flowDataTableGroup.setStatus('deprecated')
if mibBuilder.loadTexts: flowDataTableGroup.setDescription("The flow table group defines objects which provide the structure for the flow table, including the creation time and activity time indexes into it. In addition it defines objects which provide a base set of flow attributes for the adjacent, peer and transport layers, together with a flow's counters and times. Finally it defines a flow's class and kind attributes, which are set by rule actions.")
flowDataScaleGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 3)).setObjects(("FLOW-METER-MIB", "flowManagerCounterWrap"), ("FLOW-METER-MIB", "flowDataPDUScale"), ("FLOW-METER-MIB", "flowDataOctetScale"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataScaleGroup = flowDataScaleGroup.setStatus('deprecated')
if mibBuilder.loadTexts: flowDataScaleGroup.setDescription('The flow scale group defines objects which specify scale factors for counters.')
flowDataSubscriberGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 4)).setObjects(("FLOW-METER-MIB", "flowDataSourceSubscriberID"), ("FLOW-METER-MIB", "flowDataDestSubscriberID"), ("FLOW-METER-MIB", "flowDataSessionID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataSubscriberGroup = flowDataSubscriberGroup.setStatus('current')
if mibBuilder.loadTexts: flowDataSubscriberGroup.setDescription('The flow subscriber group defines objects which may be used to identify the end point(s) of a flow.')
flowDataColumnTableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 5)).setObjects(("FLOW-METER-MIB", "flowColumnActivityAttribute"), ("FLOW-METER-MIB", "flowColumnActivityIndex"), ("FLOW-METER-MIB", "flowColumnActivityTime"), ("FLOW-METER-MIB", "flowColumnActivityData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataColumnTableGroup = flowDataColumnTableGroup.setStatus('deprecated')
if mibBuilder.loadTexts: flowDataColumnTableGroup.setDescription('The flow column table group defines objects which can be used to collect part of a column of attribute values from the flow table.')
flowDataPackageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 6)).setObjects(("FLOW-METER-MIB", "flowPackageData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataPackageGroup = flowDataPackageGroup.setStatus('current')
if mibBuilder.loadTexts: flowDataPackageGroup.setDescription('The data package group defines objects which can be used to collect a specified set of attribute values from a row of the flow table.')
flowRuleTableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 7)).setObjects(("FLOW-METER-MIB", "flowRuleSelector"), ("FLOW-METER-MIB", "flowRuleMask"), ("FLOW-METER-MIB", "flowRuleMatchedValue"), ("FLOW-METER-MIB", "flowRuleAction"), ("FLOW-METER-MIB", "flowRuleParameter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowRuleTableGroup = flowRuleTableGroup.setStatus('current')
if mibBuilder.loadTexts: flowRuleTableGroup.setDescription('The rule table group defines objects which hold the set(s) of rules specifying which traffic flows are to be accounted for.')
flowDataScaleGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 8)).setObjects(("FLOW-METER-MIB", "flowDataPDUScale"), ("FLOW-METER-MIB", "flowDataOctetScale"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowDataScaleGroup2 = flowDataScaleGroup2.setStatus('current')
if mibBuilder.loadTexts: flowDataScaleGroup2.setDescription('The flow scale group defines objects which specify scale factors for counters. This group replaces the earlier version of flowDataScaleGroup above (now deprecated).')
flowControlGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 40, 4, 2, 9)).setObjects(("FLOW-METER-MIB", "flowRuleInfoSize"), ("FLOW-METER-MIB", "flowRuleInfoOwner"), ("FLOW-METER-MIB", "flowRuleInfoTimeStamp"), ("FLOW-METER-MIB", "flowRuleInfoStatus"), ("FLOW-METER-MIB", "flowRuleInfoName"), ("FLOW-METER-MIB", "flowRuleInfoFlowRecords"), ("FLOW-METER-MIB", "flowInterfaceSampleRate"), ("FLOW-METER-MIB", "flowInterfaceLostPackets"), ("FLOW-METER-MIB", "flowReaderTimeout"), ("FLOW-METER-MIB", "flowReaderOwner"), ("FLOW-METER-MIB", "flowReaderLastTime"), ("FLOW-METER-MIB", "flowReaderPreviousTime"), ("FLOW-METER-MIB", "flowReaderStatus"), ("FLOW-METER-MIB", "flowReaderRuleSet"), ("FLOW-METER-MIB", "flowManagerCurrentRuleSet"), ("FLOW-METER-MIB", "flowManagerStandbyRuleSet"), ("FLOW-METER-MIB", "flowManagerHighWaterMark"), ("FLOW-METER-MIB", "flowManagerOwner"), ("FLOW-METER-MIB", "flowManagerTimeStamp"), ("FLOW-METER-MIB", "flowManagerStatus"), ("FLOW-METER-MIB", "flowManagerRunningStandby"), ("FLOW-METER-MIB", "flowFloodMark"), ("FLOW-METER-MIB", "flowInactivityTimeout"), ("FLOW-METER-MIB", "flowActiveFlows"), ("FLOW-METER-MIB", "flowMaxFlows"), ("FLOW-METER-MIB", "flowFloodMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowControlGroup2 = flowControlGroup2.setStatus('current')
if mibBuilder.loadTexts: flowControlGroup2.setDescription('The control group defines objects which are used to control an accounting meter. It replaces the earlier version of flowControlGroup above (now deprecated).')
flowMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 40, 4, 1, 1)).setObjects(("FLOW-METER-MIB", "flowControlGroup2"), ("FLOW-METER-MIB", "flowDataTableGroup"), ("FLOW-METER-MIB", "flowDataPackageGroup"), ("FLOW-METER-MIB", "flowRuleTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    flowMIBCompliance = flowMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: flowMIBCompliance.setDescription('The compliance statement for a Traffic Flow Meter.')
mibBuilder.exportSymbols("FLOW-METER-MIB", flowDataSourcePeerAddress=flowDataSourcePeerAddress, flowDataSourceKind=flowDataSourceKind, flowDataDestInterface=flowDataDestInterface, flowDataFromOctets=flowDataFromOctets, flowDataSourceAdjacentMask=flowDataSourceAdjacentMask, flowControlGroup=flowControlGroup, flowPackageRuleSet=flowPackageRuleSet, flowReaderRuleSet=flowReaderRuleSet, flowInterfaceTable=flowInterfaceTable, flowDataTable=flowDataTable, flowPackageTime=flowPackageTime, flowRuleInfoSize=flowRuleInfoSize, flowReaderLastTime=flowReaderLastTime, flowRuleSetInfoEntry=flowRuleSetInfoEntry, PYSNMP_MODULE_ID=flowMIB, flowRuleIndex=flowRuleIndex, flowMaxFlows=flowMaxFlows, flowMIBCompliances=flowMIBCompliances, flowControl=flowControl, flowRuleSelector=flowRuleSelector, flowDataScaleGroup=flowDataScaleGroup, flowRuleMask=flowRuleMask, flowDataKind=flowDataKind, flowDataStatus=flowDataStatus, flowReaderOwner=flowReaderOwner, FlowAttributeNumber=FlowAttributeNumber, flowDataDestSubscriberID=flowDataDestSubscriberID, flowInterfaceEntry=flowInterfaceEntry, flowDataPackageEntry=flowDataPackageEntry, flowRuleTable=flowRuleTable, RuleAttributeNumber=RuleAttributeNumber, flowControlGroup2=flowControlGroup2, flowInterfaceSampleRate=flowInterfaceSampleRate, flowManagerInfoTable=flowManagerInfoTable, flowDataDestKind=flowDataDestKind, flowDataEntry=flowDataEntry, flowManagerHighWaterMark=flowManagerHighWaterMark, flowDataSubscriberGroup=flowDataSubscriberGroup, TransportType=TransportType, ActionNumber=ActionNumber, flowDataDestPeerType=flowDataDestPeerType, flowRuleInfoTimeStamp=flowRuleInfoTimeStamp, flowMIBCompliance=flowMIBCompliance, flowRuleInfoStatus=flowRuleInfoStatus, flowDataColumnTableGroup=flowDataColumnTableGroup, flowDataSessionID=flowDataSessionID, flowDataDestPeerAddress=flowDataDestPeerAddress, flowDataDestClass=flowDataDestClass, flowRuleInfoName=flowRuleInfoName, flowDataSourceTransAddress=flowDataSourceTransAddress, flowPackageData=flowPackageData, UTF8OwnerString=UTF8OwnerString, flowDataLastActiveTime=flowDataLastActiveTime, flowManagerStatus=flowManagerStatus, flowReaderInfoEntry=flowReaderInfoEntry, flowManagerIndex=flowManagerIndex, flowInactivityTimeout=flowInactivityTimeout, flowManagerInfoEntry=flowManagerInfoEntry, flowRuleEntry=flowRuleEntry, flowDataSourcePeerMask=flowDataSourcePeerMask, flowReaderPreviousTime=flowReaderPreviousTime, flowDataScaleGroup2=flowDataScaleGroup2, flowManagerCounterWrap=flowManagerCounterWrap, flowDataSourceTransType=flowDataSourceTransType, flowDataPackageTable=flowDataPackageTable, flowDataSourcePeerType=flowDataSourcePeerType, flowDataTimeMark=flowDataTimeMark, flowDataSourceClass=flowDataSourceClass, flowDataFromPDUs=flowDataFromPDUs, flowDataTableGroup=flowDataTableGroup, flowDataSourceSubscriberID=flowDataSourceSubscriberID, flowRuleInfoRulesReady=flowRuleInfoRulesReady, flowInterfaceLostPackets=flowInterfaceLostPackets, flowReaderTimeout=flowReaderTimeout, flowDataDestAdjacentMask=flowDataDestAdjacentMask, flowColumnActivityAttribute=flowColumnActivityAttribute, flowFloodMode=flowFloodMode, flowDataSourceTransMask=flowDataSourceTransMask, flowFloodMark=flowFloodMark, flowReaderIndex=flowReaderIndex, flowDataToPDUs=flowDataToPDUs, flowDataOctetScale=flowDataOctetScale, flowColumnActivityTable=flowColumnActivityTable, flowRuleTableGroup=flowRuleTableGroup, flowColumnActivityIndex=flowColumnActivityIndex, AdjacentAddress=AdjacentAddress, flowColumnActivityEntry=flowColumnActivityEntry, flowDataSourceAdjacentType=flowDataSourceAdjacentType, flowDataPDUScale=flowDataPDUScale, flowDataClass=flowDataClass, PeerAddress=PeerAddress, flowDataDestTransMask=flowDataDestTransMask, flowDataPackageGroup=flowDataPackageGroup, flowData=flowData, flowRuleMatchedValue=flowRuleMatchedValue, flowDataRuleSet=flowDataRuleSet, flowMIBConformance=flowMIBConformance, flowReaderStatus=flowReaderStatus, flowDataDestTransAddress=flowDataDestTransAddress, flowColumnActivityData=flowColumnActivityData, flowDataSourceInterface=flowDataSourceInterface, flowRuleInfoIndex=flowRuleInfoIndex, flowManagerTimeStamp=flowManagerTimeStamp, flowReaderInfoTable=flowReaderInfoTable, flowRuleSetInfoTable=flowRuleSetInfoTable, flowPackageIndex=flowPackageIndex, flowMIB=flowMIB, flowDataDestAdjacentAddress=flowDataDestAdjacentAddress, flowDataFirstTime=flowDataFirstTime, flowManagerOwner=flowManagerOwner, flowPackageSelector=flowPackageSelector, flowMIBGroups=flowMIBGroups, flowRuleParameter=flowRuleParameter, flowManagerRunningStandby=flowManagerRunningStandby, flowRuleInfoFlowRecords=flowRuleInfoFlowRecords, TransportAddress=TransportAddress, RuleAddress=RuleAddress, flowDataDestTransType=flowDataDestTransType, flowManagerStandbyRuleSet=flowManagerStandbyRuleSet, flowDataDestAdjacentType=flowDataDestAdjacentType, flowDataToOctets=flowDataToOctets, flowDataSourceAdjacentAddress=flowDataSourceAdjacentAddress, AdjacentType=AdjacentType, flowDataDestPeerMask=flowDataDestPeerMask, PeerType=PeerType, flowActiveFlows=flowActiveFlows, flowRuleInfoOwner=flowRuleInfoOwner, flowManagerCurrentRuleSet=flowManagerCurrentRuleSet, flowRuleSet=flowRuleSet, flowRules=flowRules, flowDataIndex=flowDataIndex, flowRuleAction=flowRuleAction, flowColumnActivityTime=flowColumnActivityTime)

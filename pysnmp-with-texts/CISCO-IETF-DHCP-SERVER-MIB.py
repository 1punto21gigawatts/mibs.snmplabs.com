#
# PySNMP MIB module CISCO-IETF-DHCP-SERVER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-DHCP-SERVER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InetAddressIPv4, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddressPrefixLength")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter32, ModuleIdentity, MibIdentifier, ObjectIdentity, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, TimeTicks, Integer32, Unsigned32, IpAddress, Counter64, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "MibIdentifier", "ObjectIdentity", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "TimeTicks", "Integer32", "Unsigned32", "IpAddress", "Counter64", "iso")
TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "DateAndTime")
ciscoIetfDhcpSrvMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102))
ciscoIetfDhcpSrvMIB.setRevisions(('2007-03-27 00:00', '2007-02-14 12:00', '2004-03-01 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIetfDhcpSrvMIB.setRevisionsDescriptions(('Added cDhcpv4ServerSharedNetObjects, cDhcpv4ServerSubnetObjects, cDhcpv4ServerRangeObjects, cDhcpv4ServerClientObjects, cDhcpv4ServerNotifyObjects and cDhcpv4ServerNotificationsGroup. The data types of the OIDs below are modified so they can be retrieved. cDhcpv4ServerSharedNetFreeAddrLowThreshold (read-write) cDhcpv4ServerSharedNetFreeAddrHighThreshold (read-write) cDhcpv4ServerSharedNetFreeAddresses (read-only) cDhcpv4ServerSharedNetReservedAddresses (read-only) cDhcpv4ServerSharedNetTotalAddresses (read-only) cDhcpv4ServerSubnetFreeAddrLowThreshold (read-write) cDhcpv4ServerSubnetFreeAddrHighThreshold (read-write) cDhcpv4ServerSubnetFreeAddresses (read-only) Added cDhcpv4SrvComplianceRev1 MODULE-COMPLIANCE', 'Add BOOTP/DHCP high capacity counter.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoIetfDhcpSrvMIB.setLastUpdated('200703270000Z')
if mibBuilder.loadTexts: ciscoIetfDhcpSrvMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIetfDhcpSrvMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-dhcp-mib@cisco.com')
if mibBuilder.loadTexts: ciscoIetfDhcpSrvMIB.setDescription('The MIB module for entities implementing the server side of the Bootstrap Protocol (BOOTP) and the Dynamic Host Configuration protocol (DHCP) for Internet Protocol version 4(IPv4). This MIB does not include support for Dynamic DNS (DDNS) updating nor for the DHCP Failover Protocol.')
ciscoIetfDhcpv4SrvMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 0))
ciscoIetfDhcpv4SrvMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 1))
ciscoIetfDhcpv4SrvMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 2))
class CDhcpv4PhysicalAddress(TextualConvention, OctetString):
    reference = 'RFC 2131'
    description = "A DHCP-specific encoding of the physical address type and physical address, intended to mirror the representation of physical addresses in DHCP messages. The first octet of this object contains the hardware type from the 'htype' field of the DHCP message, the second octet of this object contains the hardware length from the 'hlen' field, and the remaining octets contain the hardware address from the 'chaddr' field."
    status = 'current'
    displayHint = '1d,1d,1x:1x:1x:1x:1x:1x'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(18, 18)
    fixedLength = 18

cDhcpv4SrvSystem = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 1))
if mibBuilder.loadTexts: cDhcpv4SrvSystem.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvSystem.setDescription('Group of objects that are related to the overall system.')
cBootpCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2))
if mibBuilder.loadTexts: cBootpCounters.setStatus('current')
if mibBuilder.loadTexts: cBootpCounters.setDescription('Group of objects that count various BOOTP events.')
cDhcpv4Counters = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3))
if mibBuilder.loadTexts: cDhcpv4Counters.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4Counters.setDescription('Group of objects that count various DHCPv4 events.')
cDhcpv4SrvConfiguration = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4))
if mibBuilder.loadTexts: cDhcpv4SrvConfiguration.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvConfiguration.setDescription('Objects that contain pre-configured and dynamic configuration information.')
cDhcpv4ServerNotifyObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7))
if mibBuilder.loadTexts: cDhcpv4ServerNotifyObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyObjects.setDescription('Objects that are used only in notifications.')
cBootpHCCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8))
if mibBuilder.loadTexts: cBootpHCCounters.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCounters.setDescription('Group of high capacity objects that count various BOOTP events.')
cDhcpv4HCCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9))
if mibBuilder.loadTexts: cDhcpv4HCCounters.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCounters.setDescription('Group of high capacity objects that count various DHCPv4 events.')
cDhcpv4SrvSystemDescr = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4SrvSystemDescr.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvSystemDescr.setDescription('A textual description of the server. This value should include the full name and version identification of the server.')
cDhcpv4SrvSystemObjectID = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4SrvSystemObjectID.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvSystemObjectID.setDescription("The vendor's authoritative identification of the network management subsystem contained in this entity. This value is allocated within the SMI enterprise subtree (1.3.6.1.4.1) and provides an easy and unambiguous means for determining what kind of server is being managed. For example, if vendor Ohso Soft, Inc. is assigned the subtree 1.3.6.1.4.1.4242, it may assign the identifier 1.3.6.1.4.1.4242.1.1 to its Ursa DHCP Server.")
cBootpCountRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpCountRequests.setReference('RFC-2131.')
if mibBuilder.loadTexts: cBootpCountRequests.setStatus('current')
if mibBuilder.loadTexts: cBootpCountRequests.setDescription('The number of packets received that contain a Message Type of 1 (BOOTREQUEST) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
cBootpCountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpCountInvalids.setStatus('current')
if mibBuilder.loadTexts: cBootpCountInvalids.setDescription('The number of packets received that do not contain a Message Type of 1 (BOOTREQUEST) in the first octet or are not valid BOOTP packets (e.g., too short, invalid field in packet header).')
cBootpCountReplies = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpCountReplies.setReference('RFC-2131.')
if mibBuilder.loadTexts: cBootpCountReplies.setStatus('current')
if mibBuilder.loadTexts: cBootpCountReplies.setDescription('The number of packets sent that contain a Message Type of 2 (BOOTREPLY) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
cBootpCountDropUnknownClients = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpCountDropUnknownClients.setStatus('current')
if mibBuilder.loadTexts: cBootpCountDropUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not recognizing or not providing service to the hardware address received in the incoming packet.')
cBootpCountDropNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpCountDropNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: cBootpCountDropNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
cDhcpv4CountDiscovers = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountDiscovers.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountDiscovers.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountDiscovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets received.')
cDhcpv4CountOffers = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountOffers.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountOffers.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountOffers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets sent.')
cDhcpv4CountRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountRequests.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountRequests.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountRequests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets received.')
cDhcpv4CountDeclines = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountDeclines.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountDeclines.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountDeclines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets received.')
cDhcpv4CountAcks = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountAcks.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountAcks.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountAcks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
cDhcpv4CountNaks = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountNaks.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountNaks.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountNaks.setDescription('The number of DHCPNACK (option 53 with value 6) packets sent.')
cDhcpv4CountReleases = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountReleases.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountReleases.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountReleases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets received.')
cDhcpv4CountInforms = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountInforms.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4CountInforms.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountInforms.setDescription('The number of DHCPINFORM (option 53 with value 8) packets received.')
cDhcpv4CountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountInvalids.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountInvalids.setDescription('The number of DHCP packets received whose DHCP message type (i.e., option number 53) is not understood or handled by the server.')
cDhcpv4CountDropUnknownClient = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountDropUnknownClient.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountDropUnknownClient.setDescription('The number of DHCP packets dropped due to the server not recognizing or not providing service to the client-id and/or hardware address received in the incoming packet.')
cDhcpv4CountDropNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4CountDropNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CountDropNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
cBootpHCCountRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpHCCountRequests.setReference('RFC-2131.')
if mibBuilder.loadTexts: cBootpHCCountRequests.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountRequests.setDescription('The number of packets received that contain a Message Type of 1 (BOOTREQUEST) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
cBootpHCCountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpHCCountInvalids.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountInvalids.setDescription('The number of packets received that do not contain a Message Type of 1 (BOOTREQUEST) in the first octet or are not valid BOOTP packets (e.g., too short, invalid field in packet header).')
cBootpHCCountReplies = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpHCCountReplies.setReference('RFC-2131.')
if mibBuilder.loadTexts: cBootpHCCountReplies.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountReplies.setDescription('The number of packets sent that contain a Message Type of 2 (BOOTREPLY) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
cBootpHCCountDropUnknownClients = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpHCCountDropUnknownClients.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountDropUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not recognizing or not providing service to the hardware address received in the incoming packet.')
cBootpHCCountDropNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 8, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBootpHCCountDropNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountDropNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
cDhcpv4HCCountDiscovers = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountDiscovers.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountDiscovers.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountDiscovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets received.')
cDhcpv4HCCountOffers = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountOffers.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountOffers.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountOffers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets sent.')
cDhcpv4HCCountRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountRequests.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountRequests.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountRequests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets received.')
cDhcpv4HCCountDeclines = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountDeclines.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountDeclines.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountDeclines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets received.')
cDhcpv4HCCountAcks = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountAcks.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountAcks.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountAcks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
cDhcpv4HCCountNaks = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountNaks.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountNaks.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountNaks.setDescription('The number of DHCPNACK (option 53 with value 6) packets sent.')
cDhcpv4HCCountReleases = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountReleases.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountReleases.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountReleases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets received.')
cDhcpv4HCCountInforms = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountInforms.setReference('RFC2131; RFC2132, section 9.6.')
if mibBuilder.loadTexts: cDhcpv4HCCountInforms.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountInforms.setDescription('The number of DHCPINFORM (option 53 with value 8) packets received.')
cDhcpv4HCCountForcedRenews = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountForcedRenews.setReference('RFC 3203, DHCP reconfigure extension.')
if mibBuilder.loadTexts: cDhcpv4HCCountForcedRenews.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountForcedRenews.setDescription('The number of DHCPFORCERENEW (option 53 with value 9) packets sent.')
cDhcpv4HCCountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountInvalids.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountInvalids.setDescription('The number of DHCP packets received whose DHCP message type (i.e., option number 53) is not understood or handled by the server.')
cDhcpv4HCCountDropUnknownClient = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountDropUnknownClient.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountDropUnknownClient.setDescription('The number of DHCP packets dropped due to the server not recognizing or not providing service to the client-id and/or hardware address received in the incoming packet.')
cDhcpv4HCCountDropNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 9, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4HCCountDropNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCountDropNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
cDhcpv4ServerSharedNetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1), )
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetTable.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetTable.setDescription("A list of shared networks that are configured in the server. A shared network is the logical aggregation of one or more subnets that share a common network segment (e.g., multi- tapped coaxial cable, wiring hub, or switch). This table is present ONLY for those servers that organize the ranges of addresses available for assignment where a higher-level grouping (i.e., the 'shared' network) exists above ranges and subnets.")
cDhcpv4ServerSharedNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetName"))
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetEntry.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetEntry.setDescription('A logical row in the cDhcpv4ServerSharedNetTable.')
cDhcpv4ServerSharedNetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 100)))
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetName.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetName.setDescription('The name of the shared network, which uniquely identifies an entry in the cDhcpv4ServerSharedNetTable.')
cDhcpv4ServerSharedNetFreeAddrLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddrLowThreshold.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddrLowThreshold.setDescription('The low threshold for available free addresses in this shared network. If the value for available free addresses in this shared network becomes equal to or less than this value, a cDhcpv4ServerFreeAddressLow event is generated for this shared network. No more cDhcpv4ServerFreeAddressLow events will be generated for this subnet during this execution of the DHCP server until the value for available free addresses has exceeded the value of cDhcpv4ServerSharedNetFreeAddrHighThreshold.')
cDhcpv4ServerSharedNetFreeAddrHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddrHighThreshold.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddrHighThreshold.setDescription('The high threshold for available free addresses in this shared network. If a cDhcpv4ServerFreeAddressLow event was generated for this subnet, and the value for available free addresses has exceeded the value of cDhcpv4ServerSubnetFreeAddrHighThreshold, then a cDhcpv4ServerFreeAddressHigh event will be generated. No more cDhcpv4ServerFreeAddressHigh events will be generated for this subnet during this execution of the DHCP server until the value for available free addresses becomes equal to or less than the value of cDhcpv4ServerSubnetFreeAddrLowThreshold.')
cDhcpv4ServerSharedNetFreeAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddresses.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetFreeAddresses.setDescription('The number of IPv4 addresses which are available within this shared network. If the server does not count free addresses by shared network segment, this value will be zero.')
cDhcpv4ServerSharedNetReservedAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetReservedAddresses.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetReservedAddresses.setDescription('The number of IPv4 addresses which are reserved (not available for assignment) within this shared network. If the server does not count reserved addresses by shared network segment, this value will be zero.')
cDhcpv4ServerSharedNetTotalAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetTotalAddresses.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetTotalAddresses.setDescription('The number of IPv4 addresses which are available within this shared network. If the server does not count total addresses by shared network segment, this value will be zero.')
cDhcpv4ServerSubnetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2), )
if mibBuilder.loadTexts: cDhcpv4ServerSubnetTable.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetTable.setDescription('A list of subnets that are configured in this server.')
cDhcpv4ServerSubnetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1), ).setIndexNames((0, "CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetAddress"))
if mibBuilder.loadTexts: cDhcpv4ServerSubnetEntry.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetEntry.setDescription('A logical row in the cDhcpv4ServerSubnetTable.')
cDhcpv4ServerSubnetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: cDhcpv4ServerSubnetAddress.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetAddress.setDescription('The IPv4 address of the subnet entry in the cDhcpv4ServerSubnetTable.')
cDhcpv4ServerSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 2), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetMask.setDescription('The subnet mask of the subnet. This MUST be the same as the value of DHCP option 1 offered to clients on this subnet.')
cDhcpv4ServerSubnetSharedNetworkName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSubnetSharedNetworkName.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetSharedNetworkName.setDescription('The shared subnet name (used as an index into the server shared subnet table) to which this subnet belongs. This value will be null for servers that do not organize or describe networks in this manner.')
cDhcpv4ServerSubnetFreeAddrLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddrLowThreshold.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddrLowThreshold.setDescription('The low threshold for available free addresses in this subnet. If the value for available free addresses in this subnet becomes equal to or less than this value, a cDhcpv4ServerSubnetFreeAddrLowThreshold event will be generated for this shared network. No more cDhcpv4ServerSubnetFreeAddrLowThreshold events will be generated for this subnet during this execution of the DHCP server until the value for available free addresses has exceeded the value of cDhcpv4ServerSubnetFreeAddrHighThreshold.')
cDhcpv4ServerSubnetFreeAddrHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddrHighThreshold.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddrHighThreshold.setDescription('The high threshold for available free addresses in this subnet. If a cDhcpv4ServerSubnetFreeAddrLowThreshold event has been generated for this subnet, and the value for available free addresses has exceeded the value of cDhcpv4ServerSubnetFreeAddrHighThreshold, then a cDhcpv4ServerFreeAddressHigh event will be generated. No more cDhcpv4ServerFreeAddressHigh events will be generated for this subnet during this execution of the DHCP server until the value for available free addresses becomes equal to or less than the value of cDhcpv4ServerSubnetFreeAddrLowThreshold.')
cDhcpv4ServerSubnetFreeAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddresses.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetFreeAddresses.setDescription('The number of free IPv4 addresses which are available in this subnet.')
cDhcpv4ServerRangeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3), )
if mibBuilder.loadTexts: cDhcpv4ServerRangeTable.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeTable.setDescription('A list of ranges that are configured on this server.')
cDhcpv4ServerRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1), ).setIndexNames((0, "CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeStartAddress"), (0, "CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeEndAddress"))
if mibBuilder.loadTexts: cDhcpv4ServerRangeEntry.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeEntry.setDescription('A logical row in the cDhcpv4ServerRangeTable.')
cDhcpv4ServerRangeStartAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: cDhcpv4ServerRangeStartAddress.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeStartAddress.setDescription('The IPv4 address of the first address in the range. The value of cDhcpv4ServerRangeStartAddress MUST be less than or equal to the value of cDhcpv4ServerRangeEndAddress.')
cDhcpv4ServerRangeEndAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1, 2), InetAddressIPv4())
if mibBuilder.loadTexts: cDhcpv4ServerRangeEndAddress.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeEndAddress.setDescription('The IPv4 address of the last address in the range. The value of cDhcpv4ServerRangeEndAddress MUST be greater than or equal to the value of cDhcpv4ServerRangeStartAddress.')
cDhcpv4ServerRangeSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1, 3), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerRangeSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeSubnetMask.setDescription('The subnet address mask for this range.')
cDhcpv4ServerRangeInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerRangeInUse.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeInUse.setDescription('The number of addresses in this range that are currently in use. This number includes those addresses whose lease has not expired and addresses which have been reserved (either by the server or through configuration).')
cDhcpv4ServerRangeOutstandingOffers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerRangeOutstandingOffers.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeOutstandingOffers.setDescription('The number of outstanding DHCPOFFER messages for this range is reported with this value. An offer is outstanding if the server has sent a DHCPOFFER message to a client, but has not yet received a DHCPREQUEST message from the client nor has the server-specific timeout (limiting the time in which a client can respond to the offer message) for the offer message expired.')
cDhcpv4ServerClientTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4), )
if mibBuilder.loadTexts: cDhcpv4ServerClientTable.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientTable.setDescription("An optional list of addresses that are known by this server. The list MUST contain addresses that have not expired. The list MUST NOT contain addresses that have never been assigned by the server UNLESS the lease is pre-configured in the server (e.g., a static lease for a host). Expired leases MAY appear during the time they are 'remembered' by the server for subsequent assignment to the same host.")
cDhcpv4ServerClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1), ).setIndexNames((0, "CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClient"))
if mibBuilder.loadTexts: cDhcpv4ServerClientEntry.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientEntry.setDescription('A logical row in the cDhcpv4ServerClientTable.')
cDhcpv4ServerClient = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: cDhcpv4ServerClient.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClient.setDescription('The IPv4 address of this entry in the cDhcpv4ServerClientTable.')
cDhcpv4ServerClientSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 2), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientSubnetMask.setDescription("The subnet mask (DHCP option 1) provided to the client offered this address. The subnet, resulting from logically ANDing the subnet mask with the entry's IPv4 address, MUST be configured on this server and appear as a row in the cDhcpSubnetTable.")
cDhcpv4ServerClientRange = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 3), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientRange.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientRange.setDescription('The starting IPv4 address (cDhcpv4ServerRangeStartAddress object) of the range to which this address belongs. If the address does not fall into one of the configured ranges (e.g., a statically configured address on a subnet) the range MAY be 0.0.0.0.')
cDhcpv4ServerClientLeaseType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("expired", 3), ("configurationReserved", 4), ("serverReserved", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientLeaseType.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientLeaseType.setDescription("The type of this address. Types are: (1) Static addresses defined by the server configuration. (2) Dynamic addresses defined by the server configuration AND actually assigned by the server. (3) Expired dynamic addresses, previously assigned by the server, and 'remembered' for subsequent assignment to the same host. (4) Addresses reserved (i.e., not assignable) by the server configuration. (5) Addresses previously assigned by the server, but temporarily or permanently removed from assignable state for some reason, e.g., the server received an ICMP ECHOREPLY for the IPv4 address or a DHCPDECLINE message has been received for the IPv4 address.")
cDhcpv4ServerClientTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientTimeRemaining.setDescription("The number of seconds until the lease expires. A value of 4294967295 (i.e., 0xFFFFFFFF) SHOULD be used for leases that have a lease time which is 'infinite' and for BOOTP leases.")
cDhcpv4ServerClientAllowedProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("bootp", 2), ("dhcp", 3), ("bootpOrDhcp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientAllowedProtocol.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientAllowedProtocol.setDescription('The type of protocol that is allowed to be used to serve this address. A type of none (1) indicates that the address is not available to be served (e.g., a reserved address). Type (2) is reserved for BOOTP only devices, while type (3) is reserved for DHCP only devices. A type of bootp-or-dhcp (4) can be offered to any type of client.')
cDhcpv4ServerClientServedProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bootp", 2), ("dhcp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientServedProtocol.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientServedProtocol.setDescription('The type of protocol that was used when this address was assigned. This object will have the value of none (1) if the address has not been served.')
cDhcpv4ServerClientPhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 8), CDhcpv4PhysicalAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientPhysicalAddress.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientPhysicalAddress.setDescription("The hardware type and hardware address of the client that has been assigned this lease. The first octet of this object contains the hardware type from the 'htype' field of the BOOTP packet and the remaining octets contain the hardware address from the 'chaddr' field of the BOOTP packet. This object MAY be empty if the address has not been previously served.")
cDhcpv4ServerClientClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientClientId.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientClientId.setDescription('The client-id of the client that has been assigned this lease. The client-id is the value specified in option 61 (client-id option) when the lease was assigned. This object MAY be empty if the lease has not been previously assigned or if the client-id option was not specified when the address was assigned.')
cDhcpv4ServerClientHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientHostName.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientHostName.setDescription('The host name (DHCP option 12) the client is configured to use, or if no host name was configured then the host name that the client supplied when requesting an address. While this object has a maximum size of 255 octets, a Fully-Qualified Domain Name (FQDN) consisting of a Host Name part and a Domain Name part is currently limited to 255 octets. Therefore, the sum of the string lengths for this object and the cDhcpv4ServerClientDomainName MUST be, in practice, less than 256 octets.')
cDhcpv4ServerClientDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 4, 4, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cDhcpv4ServerClientDomainName.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientDomainName.setDescription("The domain name (DHCP option 15) assigned to the client. While this object has a maximum size of 255 octets, a Fully- Qualified Domain Name (FQDN) consisting of a Host Name part and a Domain Name part is currently limited to 255 octets, less the separator ('.') character. Therefore, the sum of the string lengths for this object and the cDhcpv4ServerClientHostName MUST be, in practice, less than 256 octets.")
cDhcpv4ServerNotifyDuplicateIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7, 1), InetAddressIPv4()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cDhcpv4ServerNotifyDuplicateIpAddr.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyDuplicateIpAddr.setDescription('The IPv4 address found to be a duplicate. Duplicates are detected by servers, which issue an ICMP ECHOREQUEST prior to offering an IPv4 address lease, or by a client issuing a gratuitous ARP message and reported through a DHCPDECLINE message.')
cDhcpv4ServerNotifyDuplicateMac = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7, 2), CDhcpv4PhysicalAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cDhcpv4ServerNotifyDuplicateMac.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyDuplicateMac.setDescription('The offending MAC address which caused a duplicate IPv4 address to be detected, if captured by the server, else 00-00- 00-00-00-00.')
cDhcpv4ServerNotifyClientOrServerDetected = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("client", 1), ("server", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cDhcpv4ServerNotifyClientOrServerDetected.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyClientOrServerDetected.setDescription('Duplicate IPv4 addresses can be detected either by a server, using an ICMP ECHO message, or by a client using ARP. This object is set by the server to (1) if the client used DHCPDECLINE to mark the offered address as in-use, or to (2) if the server discovered the address in use by some client before offering it.')
cDhcpv4ServerNotifyServerStart = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7, 4), DateAndTime()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cDhcpv4ServerNotifyServerStart.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyServerStart.setDescription('The date and time when the server began operation.')
cDhcpv4ServerNotifyServerStop = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 102, 1, 7, 5), DateAndTime()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cDhcpv4ServerNotifyServerStop.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyServerStop.setDescription('The date and time when the server ceased operation.')
cDhcpv4ServerNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2))
cDhcpv4ServerNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0))
cDhcpv4ServerFreeAddressLow = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0, 1)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddrLowThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddresses"))
if mibBuilder.loadTexts: cDhcpv4ServerFreeAddressLow.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerFreeAddressLow.setDescription('This notification signifies that the number of available IPv4 addresses for a particular shared network has fallen below the value of cDhcpv4ServerSharedNetFreeAddrLowThreshold for that shared network.')
cDhcpv4ServerFreeAddressHigh = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0, 2)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddrHighThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddresses"))
if mibBuilder.loadTexts: cDhcpv4ServerFreeAddressHigh.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerFreeAddressHigh.setDescription('This notification signifies that the number of available IPv4 addresses for a particular shared network has risen above the value of cDhcpv4ServerSharedNetFreeAddrHighThreshold for that shared network.')
cDhcpv4ServerStartTime = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0, 3)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyServerStart"))
if mibBuilder.loadTexts: cDhcpv4ServerStartTime.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerStartTime.setDescription('This notification signifies that the server of the specified type has started on the host from which this notification has been sent.')
cDhcpv4ServerStopTime = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0, 4)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyServerStop"))
if mibBuilder.loadTexts: cDhcpv4ServerStopTime.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerStopTime.setDescription('This notification signifies that the server of the specified type has stopped normally on the host from which this notification has been sent.')
cDhcpv4ServerDuplicateAddress = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 102, 0, 2, 0, 5)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyDuplicateIpAddr"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyDuplicateMac"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyClientOrServerDetected"))
if mibBuilder.loadTexts: cDhcpv4ServerDuplicateAddress.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerDuplicateAddress.setDescription('This notification signifies that a duplicate IPv4 address has been detected. The DHCP server can detect this condition through the ping-before-offer mechanism. Alternatively, the client may have sent a DHCPDECLINE back to the server; this is assumed to be the result of the client detecting that the address was in use. In either case, the DHCP server marks the IPv4 address as unavailable for leasing to clients. The cDhcpv4ServerNotifyClientOrServerDetected object indicates whether the client or server detected this condition.')
cDhcpv4SrvCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 1))
cDhcpv4SrvGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2))
cDhcpv4SrvCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 1, 1)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4SrvSystemObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountersGroup"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CounterObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountersGroup"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCounterObjects"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4SrvCompliance = cDhcpv4SrvCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cDhcpv4SrvCompliance.setDescription('This group describes the requirements for conformance to the DHCP Server MIB. A DHCPv4 server implementation is only required to support IPv4 addresses.')
cDhcpv4SrvComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 1, 2)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4SrvSystemObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountersGroup"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CounterObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountersGroup"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCounterObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientObjects"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyObjectsGroup"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4SrvComplianceRev1 = cDhcpv4SrvComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvComplianceRev1.setDescription('This group describes the requirements for conformance to the DHCP Server MIB. A DHCPv4 server implementation is only required to support IPv4 addresses.')
cDhcpv4SrvSystemObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 1)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4SrvSystemDescr"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4SrvSystemObjectID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4SrvSystemObjects = cDhcpv4SrvSystemObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4SrvSystemObjects.setDescription('Objects belonging to the cDhcpv4SrvSystemObjects group.')
cBootpCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 2)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountRequests"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountInvalids"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountReplies"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountDropUnknownClients"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpCountDropNotServingSubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cBootpCountersGroup = cBootpCountersGroup.setStatus('current')
if mibBuilder.loadTexts: cBootpCountersGroup.setDescription('Objects belonging to the cBootpBountersGroup.')
cDhcpv4CounterObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 3)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountDiscovers"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountOffers"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountRequests"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountDeclines"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountAcks"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountNaks"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountReleases"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountInforms"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountInvalids"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountDropUnknownClient"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4CountDropNotServingSubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4CounterObjects = cDhcpv4CounterObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4CounterObjects.setDescription('Objects belonging to the cDhcpv4CounterObjects group.')
cBootpHCCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 4)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountRequests"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountInvalids"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountReplies"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountDropUnknownClients"), ("CISCO-IETF-DHCP-SERVER-MIB", "cBootpHCCountDropNotServingSubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cBootpHCCountersGroup = cBootpHCCountersGroup.setStatus('current')
if mibBuilder.loadTexts: cBootpHCCountersGroup.setDescription('Objects belonging to the cBootpHCCountersGroup.')
cDhcpv4HCCounterObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 5)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountDiscovers"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountOffers"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountRequests"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountDeclines"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountAcks"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountNaks"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountReleases"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountInforms"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountForcedRenews"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountInvalids"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountDropUnknownClient"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4HCCountDropNotServingSubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4HCCounterObjects = cDhcpv4HCCounterObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4HCCounterObjects.setDescription('Objects belonging to the cDhcpv4HCCounterObjects group.')
cDhcpv4ServerSharedNetObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 6)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddrLowThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddrHighThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetFreeAddresses"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetReservedAddresses"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSharedNetTotalAddresses"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerSharedNetObjects = cDhcpv4ServerSharedNetObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSharedNetObjects.setDescription('Objects belonging to the cDhcpv4ServerSharedNetObjects group.')
cDhcpv4ServerSubnetObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 7)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetMask"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetSharedNetworkName"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetFreeAddrLowThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetFreeAddrHighThreshold"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerSubnetFreeAddresses"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerSubnetObjects = cDhcpv4ServerSubnetObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerSubnetObjects.setDescription('Objects belonging to the cDhcpv4ServerSubnetObjects group.')
cDhcpv4ServerRangeObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 8)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeSubnetMask"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeInUse"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerRangeOutstandingOffers"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerRangeObjects = cDhcpv4ServerRangeObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerRangeObjects.setDescription('Objects belonging to the cDhcpv4ServerRangeObjects group.')
cDhcpv4ServerClientObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 9)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientSubnetMask"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientRange"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientLeaseType"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientTimeRemaining"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientAllowedProtocol"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientServedProtocol"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientPhysicalAddress"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientClientId"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientHostName"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerClientDomainName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerClientObjects = cDhcpv4ServerClientObjects.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerClientObjects.setDescription('Objects belonging to the cDhcpv4ServerClientObjects group.')
cDhcpv4ServerNotifyObjectsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 10)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyDuplicateIpAddr"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyDuplicateMac"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyClientOrServerDetected"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyServerStart"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerNotifyServerStop"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerNotifyObjectsGroup = cDhcpv4ServerNotifyObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotifyObjectsGroup.setDescription('Objects belonging to the cDhcpv4ServerNotifyObjects group.')
cDhcpv4ServerNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 10, 102, 2, 2, 11)).setObjects(("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerFreeAddressLow"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerFreeAddressHigh"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerStartTime"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerStopTime"), ("CISCO-IETF-DHCP-SERVER-MIB", "cDhcpv4ServerDuplicateAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cDhcpv4ServerNotificationsGroup = cDhcpv4ServerNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: cDhcpv4ServerNotificationsGroup.setDescription('Notifications belonging to the cDhcpv4ServerNotifications group.')
mibBuilder.exportSymbols("CISCO-IETF-DHCP-SERVER-MIB", cDhcpv4ServerClientObjects=cDhcpv4ServerClientObjects, cDhcpv4SrvComplianceRev1=cDhcpv4SrvComplianceRev1, cDhcpv4ServerSharedNetTotalAddresses=cDhcpv4ServerSharedNetTotalAddresses, cDhcpv4ServerClientServedProtocol=cDhcpv4ServerClientServedProtocol, cDhcpv4ServerSharedNetFreeAddrLowThreshold=cDhcpv4ServerSharedNetFreeAddrLowThreshold, cDhcpv4ServerRangeEndAddress=cDhcpv4ServerRangeEndAddress, cDhcpv4ServerDuplicateAddress=cDhcpv4ServerDuplicateAddress, cBootpCountDropUnknownClients=cBootpCountDropUnknownClients, cDhcpv4ServerClient=cDhcpv4ServerClient, cDhcpv4ServerSubnetObjects=cDhcpv4ServerSubnetObjects, cDhcpv4ServerRangeObjects=cDhcpv4ServerRangeObjects, cDhcpv4SrvSystem=cDhcpv4SrvSystem, ciscoIetfDhcpv4SrvMIBObjects=ciscoIetfDhcpv4SrvMIBObjects, PYSNMP_MODULE_ID=ciscoIetfDhcpSrvMIB, cDhcpv4ServerSubnetAddress=cDhcpv4ServerSubnetAddress, cDhcpv4HCCountDropUnknownClient=cDhcpv4HCCountDropUnknownClient, cDhcpv4ServerNotificationPrefix=cDhcpv4ServerNotificationPrefix, cDhcpv4HCCountDiscovers=cDhcpv4HCCountDiscovers, cDhcpv4SrvSystemObjectID=cDhcpv4SrvSystemObjectID, cBootpCountDropNotServingSubnet=cBootpCountDropNotServingSubnet, cDhcpv4ServerClientPhysicalAddress=cDhcpv4ServerClientPhysicalAddress, cDhcpv4HCCountAcks=cDhcpv4HCCountAcks, cDhcpv4ServerClientClientId=cDhcpv4ServerClientClientId, cDhcpv4ServerClientDomainName=cDhcpv4ServerClientDomainName, cDhcpv4SrvSystemDescr=cDhcpv4SrvSystemDescr, cDhcpv4ServerClientHostName=cDhcpv4ServerClientHostName, cDhcpv4HCCountOffers=cDhcpv4HCCountOffers, cDhcpv4HCCounters=cDhcpv4HCCounters, cDhcpv4HCCountNaks=cDhcpv4HCCountNaks, cDhcpv4ServerRangeSubnetMask=cDhcpv4ServerRangeSubnetMask, cDhcpv4ServerNotifyServerStart=cDhcpv4ServerNotifyServerStart, cDhcpv4CountDropUnknownClient=cDhcpv4CountDropUnknownClient, cDhcpv4ServerSharedNetFreeAddrHighThreshold=cDhcpv4ServerSharedNetFreeAddrHighThreshold, cDhcpv4ServerSubnetMask=cDhcpv4ServerSubnetMask, cDhcpv4ServerNotifyServerStop=cDhcpv4ServerNotifyServerStop, cDhcpv4SrvGroups=cDhcpv4SrvGroups, cDhcpv4HCCountDeclines=cDhcpv4HCCountDeclines, cBootpHCCountDropNotServingSubnet=cBootpHCCountDropNotServingSubnet, cDhcpv4ServerSubnetTable=cDhcpv4ServerSubnetTable, cDhcpv4CountInforms=cDhcpv4CountInforms, cDhcpv4ServerStartTime=cDhcpv4ServerStartTime, cDhcpv4ServerSharedNetEntry=cDhcpv4ServerSharedNetEntry, cDhcpv4CountDropNotServingSubnet=cDhcpv4CountDropNotServingSubnet, cDhcpv4ServerRangeEntry=cDhcpv4ServerRangeEntry, cDhcpv4SrvSystemObjects=cDhcpv4SrvSystemObjects, cBootpHCCountDropUnknownClients=cBootpHCCountDropUnknownClients, cDhcpv4HCCountRequests=cDhcpv4HCCountRequests, cDhcpv4ServerSharedNetName=cDhcpv4ServerSharedNetName, cDhcpv4ServerSharedNetObjects=cDhcpv4ServerSharedNetObjects, cDhcpv4HCCountForcedRenews=cDhcpv4HCCountForcedRenews, cDhcpv4ServerSharedNetTable=cDhcpv4ServerSharedNetTable, cDhcpv4ServerNotifyClientOrServerDetected=cDhcpv4ServerNotifyClientOrServerDetected, cDhcpv4HCCountReleases=cDhcpv4HCCountReleases, cDhcpv4CountNaks=cDhcpv4CountNaks, cDhcpv4ServerClientTable=cDhcpv4ServerClientTable, cDhcpv4ServerNotifyDuplicateMac=cDhcpv4ServerNotifyDuplicateMac, cDhcpv4CountOffers=cDhcpv4CountOffers, cBootpHCCountRequests=cBootpHCCountRequests, cBootpCountersGroup=cBootpCountersGroup, cDhcpv4CountAcks=cDhcpv4CountAcks, cDhcpv4CountInvalids=cDhcpv4CountInvalids, cDhcpv4ServerClientLeaseType=cDhcpv4ServerClientLeaseType, cDhcpv4ServerSubnetEntry=cDhcpv4ServerSubnetEntry, cDhcpv4HCCounterObjects=cDhcpv4HCCounterObjects, cDhcpv4ServerClientTimeRemaining=cDhcpv4ServerClientTimeRemaining, cDhcpv4ServerFreeAddressLow=cDhcpv4ServerFreeAddressLow, cBootpCountReplies=cBootpCountReplies, cDhcpv4ServerSubnetFreeAddrLowThreshold=cDhcpv4ServerSubnetFreeAddrLowThreshold, cDhcpv4ServerSubnetSharedNetworkName=cDhcpv4ServerSubnetSharedNetworkName, cDhcpv4ServerSubnetFreeAddrHighThreshold=cDhcpv4ServerSubnetFreeAddrHighThreshold, cDhcpv4ServerRangeOutstandingOffers=cDhcpv4ServerRangeOutstandingOffers, cDhcpv4SrvCompliance=cDhcpv4SrvCompliance, cBootpCountInvalids=cBootpCountInvalids, cDhcpv4ServerClientAllowedProtocol=cDhcpv4ServerClientAllowedProtocol, cBootpHCCountReplies=cBootpHCCountReplies, cDhcpv4SrvCompliances=cDhcpv4SrvCompliances, cDhcpv4CountRequests=cDhcpv4CountRequests, cDhcpv4ServerRangeInUse=cDhcpv4ServerRangeInUse, cDhcpv4CounterObjects=cDhcpv4CounterObjects, cDhcpv4ServerNotificationsGroup=cDhcpv4ServerNotificationsGroup, cDhcpv4ServerClientEntry=cDhcpv4ServerClientEntry, cBootpCounters=cBootpCounters, cDhcpv4SrvConfiguration=cDhcpv4SrvConfiguration, cDhcpv4HCCountInvalids=cDhcpv4HCCountInvalids, cDhcpv4ServerNotifyObjectsGroup=cDhcpv4ServerNotifyObjectsGroup, ciscoIetfDhcpv4SrvMIBNotifs=ciscoIetfDhcpv4SrvMIBNotifs, cDhcpv4ServerSharedNetFreeAddresses=cDhcpv4ServerSharedNetFreeAddresses, ciscoIetfDhcpSrvMIB=ciscoIetfDhcpSrvMIB, cDhcpv4ServerSubnetFreeAddresses=cDhcpv4ServerSubnetFreeAddresses, cDhcpv4Counters=cDhcpv4Counters, ciscoIetfDhcpv4SrvMIBConform=ciscoIetfDhcpv4SrvMIBConform, cDhcpv4CountReleases=cDhcpv4CountReleases, cDhcpv4HCCountInforms=cDhcpv4HCCountInforms, cDhcpv4ServerFreeAddressHigh=cDhcpv4ServerFreeAddressHigh, cDhcpv4CountDeclines=cDhcpv4CountDeclines, cDhcpv4ServerRangeTable=cDhcpv4ServerRangeTable, cBootpHCCountInvalids=cBootpHCCountInvalids, cDhcpv4ServerClientSubnetMask=cDhcpv4ServerClientSubnetMask, cBootpHCCounters=cBootpHCCounters, cDhcpv4HCCountDropNotServingSubnet=cDhcpv4HCCountDropNotServingSubnet, CDhcpv4PhysicalAddress=CDhcpv4PhysicalAddress, cDhcpv4ServerRangeStartAddress=cDhcpv4ServerRangeStartAddress, cDhcpv4ServerNotifyDuplicateIpAddr=cDhcpv4ServerNotifyDuplicateIpAddr, cBootpCountRequests=cBootpCountRequests, cDhcpv4ServerStopTime=cDhcpv4ServerStopTime, cDhcpv4ServerNotifications=cDhcpv4ServerNotifications, cDhcpv4CountDiscovers=cDhcpv4CountDiscovers, cDhcpv4ServerNotifyObjects=cDhcpv4ServerNotifyObjects, cBootpHCCountersGroup=cBootpHCCountersGroup, cDhcpv4ServerClientRange=cDhcpv4ServerClientRange, cDhcpv4ServerSharedNetReservedAddresses=cDhcpv4ServerSharedNetReservedAddresses)

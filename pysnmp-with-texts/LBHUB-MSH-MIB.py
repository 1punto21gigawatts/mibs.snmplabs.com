#
# PySNMP MIB module LBHUB-MSH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LBHUB-MSH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
mgmt, iso, Counter32, Integer32, Counter64, NotificationType, enterprises, NotificationType, Gauge32, ModuleIdentity, Bits, ObjectIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "mgmt", "iso", "Counter32", "Integer32", "Counter64", "NotificationType", "enterprises", "NotificationType", "Gauge32", "ModuleIdentity", "Bits", "ObjectIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Unsigned32")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

system = MibIdentifier((1, 3, 6, 1, 2, 1, 1))
interfaces = MibIdentifier((1, 3, 6, 1, 2, 1, 2))
at = MibIdentifier((1, 3, 6, 1, 2, 1, 3))
ip = MibIdentifier((1, 3, 6, 1, 2, 1, 4))
icmp = MibIdentifier((1, 3, 6, 1, 2, 1, 5))
tcp = MibIdentifier((1, 3, 6, 1, 2, 1, 6))
udp = MibIdentifier((1, 3, 6, 1, 2, 1, 7))
egp = MibIdentifier((1, 3, 6, 1, 2, 1, 8))
transmission = MibIdentifier((1, 3, 6, 1, 2, 1, 10))
snmp = MibIdentifier((1, 3, 6, 1, 2, 1, 11))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 2, 1, 17))
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1))
terminalServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 1))
dedicatedBridgeServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 2))
dedicatedRouteServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 3))
brouter = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 4))
genericMSWorkstation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 5))
genericMSServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 6))
genericUnixServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 7))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8))
cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9))
chipsets = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 10))
linkBuilder3GH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 1))
linkBuilder10BTi = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 2))
linkBuilderECS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 3))
linkBuilderMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4))
linkBuilderFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 5))
linkBuilderFddiWorkGroupHub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 6))
linkBuilderFMSII = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 7))
linkSwitchFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 8))
linkSwitchMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 9))
linkBuilderFMSLBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 10))
linkBuilderTP8i = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 11))
linkBuilder3GH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 1)).setLabel("linkBuilder3GH-cards")
linkBuilder10BTi_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2)).setLabel("linkBuilder10BTi-cards")
linkBuilderECS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 3)).setLabel("linkBuilderECS-cards")
linkBuilderMSH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 4)).setLabel("linkBuilderMSH-cards")
linkBuilderFMS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5)).setLabel("linkBuilderFMS-cards")
linkBuilderFMSII_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6)).setLabel("linkBuilderFMSII-cards")
a3C512 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 7))
linkBuilderTP8i_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 8)).setLabel("linkBuilderTP8i-cards")
linkBuilder10BTi_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 1)).setLabel("linkBuilder10BTi-cards-utp")
linkBuilder10BT_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 2)).setLabel("linkBuilder10BT-cards-utp")
linkBuilderFMS_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 1)).setLabel("linkBuilderFMS-cards-utp")
linkBuilderFMS_cards_coax = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 2)).setLabel("linkBuilderFMS-cards-coax")
linkBuilderFMS_cards_fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 3)).setLabel("linkBuilderFMS-cards-fiber")
linkBuilderFMS_cards_12fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 4)).setLabel("linkBuilderFMS-cards-12fiber")
linkBuilderFMS_cards_24utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 5)).setLabel("linkBuilderFMS-cards-24utp")
linkBuilderFMSII_cards_12tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 1)).setLabel("linkBuilderFMSII-cards-12tp-rj45")
linkBuilderFMSII_cards_10coax_bnc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 2)).setLabel("linkBuilderFMSII-cards-10coax-bnc")
linkBuilderFMSII_cards_6fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 3)).setLabel("linkBuilderFMSII-cards-6fiber-st")
linkBuilderFMSII_cards_12fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 4)).setLabel("linkBuilderFMSII-cards-12fiber-st")
linkBuilderFMSII_cards_24tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 5)).setLabel("linkBuilderFMSII-cards-24tp-rj45")
linkBuilderFMSII_cards_24tp_telco = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 6)).setLabel("linkBuilderFMSII-cards-24tp-telco")
linkBuilderTP8i_cards_8tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 8, 1)).setLabel("linkBuilderTP8i-cards-8tp-rj45")
amp_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 3)).setLabel("amp-mib")
genericTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 4))
viewBuilderApps = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 5))
specificTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 6))
linkBuilder3GH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 7)).setLabel("linkBuilder3GH-mib")
linkBuilder10BTi_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8)).setLabel("linkBuilder10BTi-mib")
linkBuilderECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 9)).setLabel("linkBuilderECS-mib")
generic = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10))
genExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1))
setup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2))
sysLoader = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 3))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 4))
gauges = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 5))
asciiAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 6))
serialIf = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 7))
repeaterMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8))
endStation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 9))
localSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 10))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 11))
unusedGeneric12 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 12))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14))
mrmResilience = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 15))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16))
multiRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17))
bridgeMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18))
fault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 19))
poll = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 20))
powerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 21))
testData = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 1))
ifExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 2))
netBuilder_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 11)).setLabel("netBuilder-mib")
lBridgeECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 12)).setLabel("lBridgeECS-mib")
deskMan_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 13)).setLabel("deskMan-mib")
linkBuilderMSH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14)).setLabel("linkBuilderMSH-mib")
linkBuilderFMS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 15)).setLabel("linkBuilderFMS-mib")
linkBuilderFDDI_wghub_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 16)).setLabel("linkBuilderFDDI-wghub-mib")
linkSwitch_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 17)).setLabel("linkSwitch-mib")
sysDescr = MibScalar((1, 3, 6, 1, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDescr.setStatus('mandatory')
if mibBuilder.loadTexts: sysDescr.setDescription("A textual description of the entity. This value should include the full name and version identification of the system's hardware type, software operating-system, and networking software. It is mandatory that this only contain printable ASCII characters.")
sysObjectID = MibScalar((1, 3, 6, 1, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: sysObjectID.setDescription("The vendor's authoritative identification of the network management subsystem contained in the entity. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides an easy and unambiguous means for determining `what kind of box' is being managed. For example, if vendor `Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, it could assign the identifier 1.3.6.1.4.1.4242.1.1 to its `Fred Router'.")
sysUpTime = MibScalar((1, 3, 6, 1, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysUpTime.setDescription('The time (in hundredths of a second) since the network management portion of the system was last re-initialized.')
sysContact = MibScalar((1, 3, 6, 1, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysContact.setStatus('mandatory')
if mibBuilder.loadTexts: sysContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person.')
sysName = MibScalar((1, 3, 6, 1, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysName.setStatus('mandatory')
if mibBuilder.loadTexts: sysName.setDescription("An administratively-assigned name for this managed node. By convention, this is the node's fully-qualified domain name.")
sysLocation = MibScalar((1, 3, 6, 1, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sysLocation.setDescription("The physical location of this node (e.g., `telephone closet, 3rd floor').")
sysServices = MibScalar((1, 3, 6, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysServices.setStatus('mandatory')
if mibBuilder.loadTexts: sysServices.setDescription('A value which indicates the set of services that this entity primarily offers. The value is a sum. This sum initially takes the value zero, Then, for each layer, L, in the range 1 through 7, that this node performs transactions for, 2 raised to (L - 1) is added to the sum. For example, a node which performs primarily routing functions would have a value of 4 (2^(3-1)). In contrast, a node which is a host offering application services would have a value of 72 (2^(4-1) + 2^(7-1)). Note that in the context of the Internet suite of protocols, values should be calculated accordingly: layer functionality 1 physical (e.g., repeaters) 2 datalink/subnetwork (e.g., bridges) 3 internet (e.g., IP gateways) 4 end-to-end (e.g., IP hosts) 7 applications (e.g., mail relays) For systems including OSI protocols, layers 5 and 6 may also be counted.')
ifNumber = MibScalar((1, 3, 6, 1, 2, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifNumber.setDescription('The number of network interfaces (regardless of their current state) present on this system.')
ifTable = MibTable((1, 3, 6, 1, 2, 1, 2, 2), )
if mibBuilder.loadTexts: ifTable.setStatus('mandatory')
if mibBuilder.loadTexts: ifTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
ifEntry = MibTableRow((1, 3, 6, 1, 2, 1, 2, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ifIndex"))
if mibBuilder.loadTexts: ifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ifEntry.setDescription('An interface entry containing objects at the subnetwork layer and below for a particular interface.')
ifIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ifIndex.setDescription("A unique value for each interface. Its value ranges between 1 and the value of ifNumber. The value for each interface must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
ifDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ifDescr.setDescription('A textual string containing information about the interface. This string should include the name of the manufacturer, the product name and the version of the hardware interface.')
ifType = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifType.setStatus('mandatory')
if mibBuilder.loadTexts: ifType.setDescription("The type of interface, distinguished according to the physical/link protocol(s) immediately `below' the network layer in the protocol stack.")
ifMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMtu.setStatus('mandatory')
if mibBuilder.loadTexts: ifMtu.setDescription('The size of the largest datagram which can be sent/received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
ifSpeed = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ifSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
ifPhysAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifPhysAddress.setDescription("The interface's address at the protocol layer immediately `below' the network layer in the protocol stack. For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.")
ifAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ifAdminStatus.setDescription('The desired state of the interface. The testing(3) state indicates that no operational packets can be passed.')
ifOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ifOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational packets can be passed.')
ifLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: ifLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re- initialization of the local network management subsystem, then this object contains a zero value.')
ifInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ifInOctets.setDescription('The total number of octets received on the interface, including framing characters.')
ifInUcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ifInUcastPkts.setDescription('The number of subnetwork-unicast packets delivered to a higher-layer protocol.')
ifInNUcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ifInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork- broadcast or subnetwork-multicast) packets delivered to a higher-layer protocol.')
ifInDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ifInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
ifInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ifInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
ifInUnknownProtos = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: ifInUnknownProtos.setDescription('The number of packets received via the interface which were discarded because of an unknown or unsupported protocol.')
ifOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters.')
ifOutUcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a subnetwork-unicast address, including those that were discarded or not sent.')
ifOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non- unicast (i.e., a subnetwork-broadcast or subnetwork-multicast) address, including those that were discarded or not sent.')
ifOutDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
ifOutErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
ifOutQLen = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: ifOutQLen.setDescription('The length of the output packet queue (in packets).')
ifSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 2, 2, 1, 22), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ifSpecific.setDescription('A reference to MIB definitions specific to the particular media being used to realize the interface. For example, if the interface is realized by an ethernet, then the value of this object refers to a document defining objects specific to ethernet. If this information is not present, its value should be set to the OBJECT object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
ipForwarding = MibScalar((1, 3, 6, 1, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("not-forwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwarding.setDescription("The indication of whether this entity is acting as an IP gateway in respect to the forwarding of datagrams received by, but not addressed to, this entity. IP gateways forward datagrams. IP hosts do not (except those source-routed via the host). Note that for some managed nodes, this object may take on only a subset of the values possible. Accordingly, it is appropriate for an agent to return a `badValue' response if a management station attempts to change this object to an inappropriate value.")
ipDefaultTTL = MibScalar((1, 3, 6, 1, 2, 1, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDefaultTTL.setStatus('mandatory')
if mibBuilder.loadTexts: ipDefaultTTL.setDescription('The default value inserted into the Time-To-Live field of the IP header of datagrams originated at this entity, whenever a TTL value is not supplied by the transport layer protocol.')
ipInReceives = MibScalar((1, 3, 6, 1, 2, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ipInReceives.setDescription('The total number of input datagrams received from interfaces, including those received in error.')
ipInHdrErrors = MibScalar((1, 3, 6, 1, 2, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipInHdrErrors.setDescription('The number of input datagrams discarded due to errors in their IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.')
ipInAddrErrors = MibScalar((1, 3, 6, 1, 2, 1, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipInAddrErrors.setDescription("The number of input datagrams discarded because the IP address in their IP header's destination field was not a valid address to be received at this entity. This count includes invalid addresses (e.g., 0.0.0.0) and addresses of unsupported Classes (e.g., Class E). For entities which are not IP Gateways and therefore do not forward datagrams, this counter includes datagrams discarded because the destination address was not a local address.")
ipForwDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwDatagrams.setDescription('The number of input datagrams for which this entity was not their final IP destination, as a result of which an attempt was made to find a route to forward them to that final destination. In entities which do not act as IP Gateways, this counter will include only those packets which were Source-Routed via this entity, and the Source- Route option processing was successful.')
ipInUnknownProtos = MibScalar((1, 3, 6, 1, 2, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: ipInUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol.')
ipInDiscards = MibScalar((1, 3, 6, 1, 2, 1, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipInDiscards.setDescription('The number of input IP datagrams for which no problems were encountered to prevent their continued processing, but which were discarded (e.g., for lack of buffer space). Note that this counter does not include any datagrams discarded while awaiting re-assembly.')
ipInDelivers = MibScalar((1, 3, 6, 1, 2, 1, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: ipInDelivers.setDescription('The total number of input datagrams successfully delivered to IP user-protocols (including ICMP).')
ipOutRequests = MibScalar((1, 3, 6, 1, 2, 1, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRequests.setDescription('The total number of IP datagrams which local IP user-protocols (including ICMP) supplied to IP in requests for transmission. Note that this counter does not include any datagrams counted in ipForwDatagrams.')
ipOutDiscards = MibScalar((1, 3, 6, 1, 2, 1, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutDiscards.setDescription('The number of output IP datagrams for which no problem was encountered to prevent their transmission to their destination, but which were discarded (e.g., for lack of buffer space). Note that this counter would include datagrams counted in ipForwDatagrams if any such packets met this (discretionary) discard criterion.')
ipOutNoRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutNoRoutes.setDescription("The number of IP datagrams discarded because no route could be found to transmit them to their destination. Note that this counter includes any packets counted in ipForwDatagrams which meet this `no-route' criterion. Note that this includes any datagrams which a host cannot route because all of its default gateways are down.")
ipReasmTimeout = MibScalar((1, 3, 6, 1, 2, 1, 4, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipReasmTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ipReasmTimeout.setDescription('The maximum number of seconds which received fragments are held while they are awaiting reassembly at this entity.')
ipReasmReqds = MibScalar((1, 3, 6, 1, 2, 1, 4, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipReasmReqds.setStatus('mandatory')
if mibBuilder.loadTexts: ipReasmReqds.setDescription('The number of IP fragments received which needed to be reassembled at this entity.')
ipReasmOKs = MibScalar((1, 3, 6, 1, 2, 1, 4, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipReasmOKs.setStatus('mandatory')
if mibBuilder.loadTexts: ipReasmOKs.setDescription('The number of IP datagrams successfully re- assembled.')
ipReasmFails = MibScalar((1, 3, 6, 1, 2, 1, 4, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipReasmFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipReasmFails.setDescription('The number of failures detected by the IP re- assembly algorithm (for whatever reason: timed out, errors, etc). Note that this is not necessarily a count of discarded IP fragments since some algorithms (notably the algorithm in RFC 815) can lose track of the number of fragments by combining them as they are received.')
ipFragOKs = MibScalar((1, 3, 6, 1, 2, 1, 4, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFragOKs.setStatus('mandatory')
if mibBuilder.loadTexts: ipFragOKs.setDescription('The number of IP datagrams that have been successfully fragmented at this entity.')
ipFragFails = MibScalar((1, 3, 6, 1, 2, 1, 4, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFragFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipFragFails.setDescription("The number of IP datagrams that have been discarded because they needed to be fragmented at this entity but could not be, e.g., because their Don't Fragment flag was set.")
ipFragCreates = MibScalar((1, 3, 6, 1, 2, 1, 4, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFragCreates.setStatus('mandatory')
if mibBuilder.loadTexts: ipFragCreates.setDescription('The number of IP datagram fragments that have been generated as a result of fragmentation at this entity.')
ipAddrTable = MibTable((1, 3, 6, 1, 2, 1, 4, 20), )
if mibBuilder.loadTexts: ipAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddrTable.setDescription("The table of addressing information relevant to this entity's IP addresses.")
ipAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 20, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ipAdEntAddr"))
if mibBuilder.loadTexts: ipAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddrEntry.setDescription("The addressing information for one of this entity's IP addresses.")
ipAdEntAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAdEntAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipAdEntAddr.setDescription("The IP address to which this entry's addressing information pertains.")
ipAdEntIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAdEntIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipAdEntIfIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ipAdEntNetMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 20, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAdEntNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipAdEntNetMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
ipAdEntBcastAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 20, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAdEntBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipAdEntBcastAddr.setDescription('The value of the least-significant bit in the IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry. For example, when the Internet standard all-ones broadcast address is used, the value will be 1. This value applies to both the subnet and network broadcasts addresses used by the entity on this (logical) interface.')
ipAdEntReasmMaxSize = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 20, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAdEntReasmMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: ipAdEntReasmMaxSize.setDescription('The size of the largest IP datagram which this entity can re-assemble from incoming IP fragmented datagrams received on this interface.')
ipRouteTable = MibTable((1, 3, 6, 1, 2, 1, 4, 21), )
if mibBuilder.loadTexts: ipRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteTable.setDescription("This entity's IP Routing table.")
ipRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 21, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ipRouteDest"))
if mibBuilder.loadTexts: ipRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteEntry.setDescription('A route to a particular destination.')
ipRouteDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteDest.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
ipRouteIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ipRouteMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric1.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric2.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric3.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric4.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteNextHop.setDescription("The IP address of the next hop of this route. (In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IP address on that interface.)")
ipRouteType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteType.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the IP architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively disassociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
ipRouteProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is-is", 9), ("es-is", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
ipRouteAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipRouteMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipRouteMask by determining whether the value of the correspondent ipRouteDest field belong to a class-A, B, or C network, and then using one of: mask network 255.0.0.0 class-A 255.255.0.0 class-B 255.255.255.0 class-C If the value of the ipRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0. It should be noted that all IP routing subsystems implicitly use this mechanism.')
ipRouteMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric5.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 21, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's ipRouteProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.")
ipNetToMediaTable = MibTable((1, 3, 6, 1, 2, 1, 4, 22), )
if mibBuilder.loadTexts: ipNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaTable.setDescription('The IP Address Translation table used for mapping from IP addresses to physical addresses.')
ipNetToMediaEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 22, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ipNetToMediaIfIndex"), (0, "LBHUB-MSH-MIB", "ipNetToMediaNetAddress"))
if mibBuilder.loadTexts: ipNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaEntry.setDescription("Each entry contains one IpAddress to `physical' address equivalence.")
ipNetToMediaIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 22, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNetToMediaIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaIfIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
ipNetToMediaPhysAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 22, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNetToMediaPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaPhysAddress.setDescription("The media-dependent `physical' address.")
ipNetToMediaNetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 22, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNetToMediaNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaNetAddress.setDescription("The IpAddress corresponding to the media- dependent `physical' address.")
ipNetToMediaType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 22, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNetToMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: ipNetToMediaType.setDescription('The type of mapping. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipNetToMediaTable. That is, it effectively disassociates the interface identified with said entry from the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipNetToMediaType object.')
ipRoutingDiscards = MibScalar((1, 3, 6, 1, 2, 1, 4, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipRoutingDiscards.setDescription('The number of routing entries which were chosen to be discarded even though they are valid. One possible reason for discarding such an entry could be to free-up buffer space for other routing entries.')
icmpInMsgs = MibScalar((1, 3, 6, 1, 2, 1, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInMsgs.setDescription('The total number of ICMP messages which the entity received. Note that this counter includes all those counted by icmpInErrors.')
icmpInErrors = MibScalar((1, 3, 6, 1, 2, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInErrors.setDescription('The number of ICMP messages which the entity received but determined as having ICMP-specific errors (bad ICMP checksums, bad length, etc.).')
icmpInDestUnreachs = MibScalar((1, 3, 6, 1, 2, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInDestUnreachs.setDescription('The number of ICMP Destination Unreachable messages received.')
icmpInTimeExcds = MibScalar((1, 3, 6, 1, 2, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInTimeExcds.setDescription('The number of ICMP Time Exceeded messages received.')
icmpInParmProbs = MibScalar((1, 3, 6, 1, 2, 1, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInParmProbs.setDescription('The number of ICMP Parameter Problem messages received.')
icmpInSrcQuenchs = MibScalar((1, 3, 6, 1, 2, 1, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInSrcQuenchs.setDescription('The number of ICMP Source Quench messages received.')
icmpInRedirects = MibScalar((1, 3, 6, 1, 2, 1, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInRedirects.setDescription('The number of ICMP Redirect messages received.')
icmpInEchos = MibScalar((1, 3, 6, 1, 2, 1, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInEchos.setDescription('The number of ICMP Echo (request) messages received.')
icmpInEchoReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInEchoReps.setDescription('The number of ICMP Echo Reply messages received.')
icmpInTimestamps = MibScalar((1, 3, 6, 1, 2, 1, 5, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInTimestamps.setDescription('The number of ICMP Timestamp (request) messages received.')
icmpInTimestampReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInTimestampReps.setDescription('The number of ICMP Timestamp Reply messages received.')
icmpInAddrMasks = MibScalar((1, 3, 6, 1, 2, 1, 5, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInAddrMasks.setDescription('The number of ICMP Address Mask Request messages received.')
icmpInAddrMaskReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInAddrMaskReps.setDescription('The number of ICMP Address Mask Reply messages received.')
icmpOutMsgs = MibScalar((1, 3, 6, 1, 2, 1, 5, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutMsgs.setDescription('The total number of ICMP messages which this entity attempted to send. Note that this counter includes all those counted by icmpOutErrors.')
icmpOutErrors = MibScalar((1, 3, 6, 1, 2, 1, 5, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutErrors.setDescription("The number of ICMP messages which this entity did not send due to problems discovered within ICMP such as a lack of buffers. This value should not include errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram. In some implementations there may be no types of error which contribute to this counter's value.")
icmpOutDestUnreachs = MibScalar((1, 3, 6, 1, 2, 1, 5, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutDestUnreachs.setDescription('The number of ICMP Destination Unreachable messages sent.')
icmpOutTimeExcds = MibScalar((1, 3, 6, 1, 2, 1, 5, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutTimeExcds.setDescription('The number of ICMP Time Exceeded messages sent.')
icmpOutParmProbs = MibScalar((1, 3, 6, 1, 2, 1, 5, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutParmProbs.setDescription('The number of ICMP Parameter Problem messages sent.')
icmpOutSrcQuenchs = MibScalar((1, 3, 6, 1, 2, 1, 5, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutSrcQuenchs.setDescription('The number of ICMP Source Quench Messages Sent.')
icmpOutRedirects = MibScalar((1, 3, 6, 1, 2, 1, 5, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutRedirects.setDescription('The number of ICMP Redirect messages sent. For a host, this object will always be zero, since hosts do not send redirects.')
icmpOutEchos = MibScalar((1, 3, 6, 1, 2, 1, 5, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutEchos.setDescription('The number of ICMP Echo (request) messages sent.')
icmpOutEchoReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutEchoReps.setDescription('The number of ICMP Echo Reply messages sent.')
icmpOutTimestamps = MibScalar((1, 3, 6, 1, 2, 1, 5, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutTimestamps.setDescription('The number of ICMP Timestamp (request) messages sent.')
icmpOutTimestampReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutTimestampReps.setDescription('The number of ICMP Timestamp Reply messages sent.')
icmpOutAddrMasks = MibScalar((1, 3, 6, 1, 2, 1, 5, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutAddrMasks.setDescription('The number of ICMP Address Mask Request messages sent.')
icmpOutAddrMaskReps = MibScalar((1, 3, 6, 1, 2, 1, 5, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutAddrMaskReps.setDescription('The number of ICMP Address Mask Reply messages sent.')
tcpRtoAlgorithm = MibScalar((1, 3, 6, 1, 2, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("constant", 2), ("rsre", 3), ("vanj", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpRtoAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: tcpRtoAlgorithm.setDescription('The algorithm used to determine the timeout value used for retransmitting unacknowledged octets.')
tcpRtoMin = MibScalar((1, 3, 6, 1, 2, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpRtoMin.setStatus('mandatory')
if mibBuilder.loadTexts: tcpRtoMin.setDescription('The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout. In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the LBOUND quantity described in RFC 793.')
tcpRtoMax = MibScalar((1, 3, 6, 1, 2, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpRtoMax.setStatus('mandatory')
if mibBuilder.loadTexts: tcpRtoMax.setDescription('The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout. In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the UBOUND quantity described in RFC 793.')
tcpMaxConn = MibScalar((1, 3, 6, 1, 2, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: tcpMaxConn.setDescription('The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1.')
tcpActiveOpens = MibScalar((1, 3, 6, 1, 2, 1, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: tcpActiveOpens.setDescription('The number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state.')
tcpPassiveOpens = MibScalar((1, 3, 6, 1, 2, 1, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: tcpPassiveOpens.setDescription('The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state.')
tcpAttemptFails = MibScalar((1, 3, 6, 1, 2, 1, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: tcpAttemptFails.setDescription('The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.')
tcpEstabResets = MibScalar((1, 3, 6, 1, 2, 1, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEstabResets.setStatus('mandatory')
if mibBuilder.loadTexts: tcpEstabResets.setDescription('The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.')
tcpCurrEstab = MibScalar((1, 3, 6, 1, 2, 1, 6, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: tcpCurrEstab.setDescription('The number of TCP connections for which the current state is either ESTABLISHED or CLOSE- WAIT.')
tcpInSegs = MibScalar((1, 3, 6, 1, 2, 1, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: tcpInSegs.setDescription('The total number of segments received, including those received in error. This count includes segments received on currently established connections.')
tcpOutSegs = MibScalar((1, 3, 6, 1, 2, 1, 6, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: tcpOutSegs.setDescription('The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets.')
tcpRetransSegs = MibScalar((1, 3, 6, 1, 2, 1, 6, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpRetransSegs.setStatus('mandatory')
if mibBuilder.loadTexts: tcpRetransSegs.setDescription('The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets.')
tcpConnTable = MibTable((1, 3, 6, 1, 2, 1, 6, 13), )
if mibBuilder.loadTexts: tcpConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnTable.setDescription('A table containing TCP connection-specific information.')
tcpConnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 6, 13, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "tcpConnLocalAddress"), (0, "LBHUB-MSH-MIB", "tcpConnLocalPort"), (0, "LBHUB-MSH-MIB", "tcpConnRemAddress"), (0, "LBHUB-MSH-MIB", "tcpConnRemPort"))
if mibBuilder.loadTexts: tcpConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnEntry.setDescription('Information about a particular current TCP connection. An object of this type is transient, in that it ceases to exist when (or soon after) the connection makes the transition to the CLOSED state.')
tcpConnState = MibTableColumn((1, 3, 6, 1, 2, 1, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("synSent", 3), ("synReceived", 4), ("established", 5), ("finWait1", 6), ("finWait2", 7), ("closeWait", 8), ("lastAck", 9), ("closing", 10), ("timeWait", 11), ("deleteTCB", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpConnState.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnState.setDescription("The state of this TCP connection. The only value which may be set by a management station is deleteTCB(12). Accordingly, it is appropriate for an agent to return a `badValue' response if a management station attempts to set this object to any other value. If a management station sets this object to the value deleteTCB(12), then this has the effect of deleting the TCB (as defined in RFC 793) of the corresponding connection on the managed node, resulting in immediate termination of the connection. As an implementation-specific option, a RST segment may be sent from the managed node to the other TCP endpoint (note however that RST segments are not sent reliably).")
tcpConnLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 6, 13, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpConnLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnLocalAddress.setDescription('The local IP address for this TCP connection. In the case of a connection in the listen state which is willing to accept connections for any IP interface associated with the node, the value 0.0.0.0 is used.')
tcpConnLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 6, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpConnLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnLocalPort.setDescription('The local port number for this TCP connection.')
tcpConnRemAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 6, 13, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpConnRemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnRemAddress.setDescription('The remote IP address for this TCP connection.')
tcpConnRemPort = MibTableColumn((1, 3, 6, 1, 2, 1, 6, 13, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpConnRemPort.setStatus('mandatory')
if mibBuilder.loadTexts: tcpConnRemPort.setDescription('The remote port number for this TCP connection.')
tcpInErrs = MibScalar((1, 3, 6, 1, 2, 1, 6, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: tcpInErrs.setDescription('The total number of segments received in error (e.g., bad TCP checksums).')
tcpOutRsts = MibScalar((1, 3, 6, 1, 2, 1, 6, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpOutRsts.setStatus('mandatory')
if mibBuilder.loadTexts: tcpOutRsts.setDescription('The number of TCP segments sent containing the RST flag.')
udpInDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: udpInDatagrams.setDescription('The total number of UDP datagrams delivered to UDP users.')
udpNoPorts = MibScalar((1, 3, 6, 1, 2, 1, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: udpNoPorts.setDescription('The total number of received UDP datagrams for which there was no application at the destination port.')
udpInErrors = MibScalar((1, 3, 6, 1, 2, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: udpInErrors.setDescription('The number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.')
udpOutDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: udpOutDatagrams.setDescription('The total number of UDP datagrams sent from this entity.')
udpTable = MibTable((1, 3, 6, 1, 2, 1, 7, 5), )
if mibBuilder.loadTexts: udpTable.setStatus('mandatory')
if mibBuilder.loadTexts: udpTable.setDescription('A table containing UDP listener information.')
udpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 7, 5, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "udpLocalAddress"), (0, "LBHUB-MSH-MIB", "udpLocalPort"))
if mibBuilder.loadTexts: udpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: udpEntry.setDescription('Information about a particular current UDP listener.')
udpLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 7, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: udpLocalAddress.setDescription('The local IP address for this UDP listener. In the case of a UDP listener which is willing to accept datagrams for any IP interface associated with the node, the value 0.0.0.0 is used.')
udpLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: udpLocalPort.setDescription('The local port number for this UDP listener.')
snmpInPkts = MibScalar((1, 3, 6, 1, 2, 1, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInPkts.setDescription('The total number of Messages delivered to the SNMP entity from the transport service.')
snmpOutPkts = MibScalar((1, 3, 6, 1, 2, 1, 11, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutPkts.setDescription('The total number of SNMP Messages which were passed from the SNMP protocol entity to the transport service.')
snmpInBadVersions = MibScalar((1, 3, 6, 1, 2, 1, 11, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInBadVersions.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInBadVersions.setDescription('The total number of SNMP Messages which were delivered to the SNMP protocol entity and were for an unsupported SNMP version.')
snmpInBadCommunityNames = MibScalar((1, 3, 6, 1, 2, 1, 11, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInBadCommunityNames.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInBadCommunityNames.setDescription('The total number of SNMP Messages delivered to the SNMP protocol entity which used a SNMP community name not known to said entity.')
snmpInBadCommunityUses = MibScalar((1, 3, 6, 1, 2, 1, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInBadCommunityUses.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInBadCommunityUses.setDescription('The total number of SNMP Messages delivered to the SNMP protocol entity which represented an SNMP operation which was not allowed by the SNMP community named in the Message.')
snmpInASNParseErrs = MibScalar((1, 3, 6, 1, 2, 1, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInASNParseErrs.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInASNParseErrs.setDescription('The total number of ASN.1 or BER errors encountered by the SNMP protocol entity when decoding received SNMP Messages.')
snmpInTooBigs = MibScalar((1, 3, 6, 1, 2, 1, 11, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInTooBigs.setDescription("The total number of SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the error-status field is `tooBig'.")
snmpInNoSuchNames = MibScalar((1, 3, 6, 1, 2, 1, 11, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInNoSuchNames.setDescription("The total number of SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the error-status field is `noSuchName'.")
snmpInBadValues = MibScalar((1, 3, 6, 1, 2, 1, 11, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInBadValues.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInBadValues.setDescription("The total number of SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the error-status field is `badValue'.")
snmpInReadOnlys = MibScalar((1, 3, 6, 1, 2, 1, 11, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInReadOnlys.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInReadOnlys.setDescription("The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the error-status field is `readOnly'. It should be noted that it is a protocol error to generate an SNMP PDU which contains the value `readOnly' in the error-status field, as such this object is provided as a means of detecting incorrect implementations of the SNMP.")
snmpInGenErrs = MibScalar((1, 3, 6, 1, 2, 1, 11, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInGenErrs.setDescription("The total number of SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the error-status field is `genErr'.")
snmpInTotalReqVars = MibScalar((1, 3, 6, 1, 2, 1, 11, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInTotalReqVars.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInTotalReqVars.setDescription('The total number of MIB objects which have been retrieved successfully by the SNMP protocol entity as the result of receiving valid SNMP Get-Request and Get-Next PDUs.')
snmpInTotalSetVars = MibScalar((1, 3, 6, 1, 2, 1, 11, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInTotalSetVars.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInTotalSetVars.setDescription('The total number of MIB objects which have been altered successfully by the SNMP protocol entity as the result of receiving valid SNMP Set-Request PDUs.')
snmpInGetRequests = MibScalar((1, 3, 6, 1, 2, 1, 11, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInGetRequests.setDescription('The total number of SNMP Get-Request PDUs which have been accepted and processed by the SNMP protocol entity.')
snmpInGetNexts = MibScalar((1, 3, 6, 1, 2, 1, 11, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInGetNexts.setDescription('The total number of SNMP Get-Next PDUs which have been accepted and processed by the SNMP protocol entity.')
snmpInSetRequests = MibScalar((1, 3, 6, 1, 2, 1, 11, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInSetRequests.setDescription('The total number of SNMP Set-Request PDUs which have been accepted and processed by the SNMP protocol entity.')
snmpInGetResponses = MibScalar((1, 3, 6, 1, 2, 1, 11, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInGetResponses.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInGetResponses.setDescription('The total number of SNMP Get-Response PDUs which have been accepted and processed by the SNMP protocol entity.')
snmpInTraps = MibScalar((1, 3, 6, 1, 2, 1, 11, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpInTraps.setStatus('mandatory')
if mibBuilder.loadTexts: snmpInTraps.setDescription('The total number of SNMP Trap PDUs which have been accepted and processed by the SNMP protocol entity.')
snmpOutTooBigs = MibScalar((1, 3, 6, 1, 2, 1, 11, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutTooBigs.setDescription("The total number of SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the error-status field is `tooBig.'")
snmpOutNoSuchNames = MibScalar((1, 3, 6, 1, 2, 1, 11, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutNoSuchNames.setDescription("The total number of SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the error-status is `noSuchName'.")
snmpOutBadValues = MibScalar((1, 3, 6, 1, 2, 1, 11, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutBadValues.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutBadValues.setDescription("The total number of SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the error-status field is `badValue'.")
snmpOutGenErrs = MibScalar((1, 3, 6, 1, 2, 1, 11, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutGenErrs.setDescription("The total number of SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the error-status field is `genErr'.")
snmpOutGetRequests = MibScalar((1, 3, 6, 1, 2, 1, 11, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutGetRequests.setDescription('The total number of SNMP Get-Request PDUs which have been generated by the SNMP protocol entity.')
snmpOutGetNexts = MibScalar((1, 3, 6, 1, 2, 1, 11, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutGetNexts.setDescription('The total number of SNMP Get-Next PDUs which have been generated by the SNMP protocol entity.')
snmpOutSetRequests = MibScalar((1, 3, 6, 1, 2, 1, 11, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutSetRequests.setDescription('The total number of SNMP Set-Request PDUs which have been generated by the SNMP protocol entity.')
snmpOutGetResponses = MibScalar((1, 3, 6, 1, 2, 1, 11, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutGetResponses.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutGetResponses.setDescription('The total number of SNMP Get-Response PDUs which have been generated by the SNMP protocol entity.')
snmpOutTraps = MibScalar((1, 3, 6, 1, 2, 1, 11, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpOutTraps.setStatus('mandatory')
if mibBuilder.loadTexts: snmpOutTraps.setDescription('The total number of SNMP Trap PDUs which have been generated by the SNMP protocol entity.')
snmpEnableAuthenTraps = MibScalar((1, 3, 6, 1, 2, 1, 11, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpEnableAuthenTraps.setStatus('mandatory')
if mibBuilder.loadTexts: snmpEnableAuthenTraps.setDescription('Indicates whether the SNMP agent process is permitted to generate authentication-failure traps. The value of this object overrides any configuration information; as such, it provides a means whereby all authentication-failure traps may be disabled. Note that it is strongly recommended that this object be stored in non-volatile memory so that it remains constant between re-initializations of the network management system.')
snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 22))
rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1))
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2))
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 1))
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 2))
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 3))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 1))
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 2))
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 1))
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 3))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription('The rptrGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to rptrGroupCapacity. Some groups may not be present in a given repeater instance, in which case the actual number of groups present will be less than rptrGroupCapacity. The number of groups present will never be greater than rptrGroupCapacity. Note: In practice, this will generally be the number of field-replaceable units (i.e., modules, cards, or boards) that can fit in the physical repeater enclosure, and the group numbers will correspond to numbers marked on the physical enclosure.')
rptrOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrOperStatus.setDescription("The rptrOperStatus object indicates the operational state of the repeater. The rptrHealthText object may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6)")
rptrHealthText = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rptrHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this mechanism to provide detailed failure information or instructions for problem resolution. The contents are agent-specific.')
rptrReset = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setStatus('mandatory')
if mibBuilder.loadTexts: rptrReset.setDescription('Setting this variable to reset(2) causes a transition to the START state of Fig 9-2 in section 9 [11]. Setting this variable to noReset(1) has no effect. The agent will always return the value noReset(1) when this variable is read. This action does not reset the management counters defined in this document nor does it affect the portAdminState parameters. Included in this action is the execution of a disruptive Self-Test. As a result of this action a rptrReset trap may be sent. Note: This action may result in the loss of packets.')
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription('Setting this variable to selfTest(2) causes the repeater to perform a agent-specific, non- disruptive self-test that has the following characteristics: (1) The nature of the tests is not specified. (2) The test does not change the state of the repeater or management information about the repeater. (3) The test does not inject packets onto any segment. (4) The test does not prevent the relay of any packets. (5) The test does not interfere with management functions. After performing this test the agent will update the repeater health information. If a change in the repeater health has occurred, the agent will send a rptrHealth trap. Setting this variable to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this variable is read.')
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription('This object returns the total number of ports in the repeater whose current state meets all three of the following criteria: rptrPortOperStatus does not have the value notPresent(3), rptrPortAdminStatus is enabled(1), and rptrPortAutoPartitionState is autoPartitioned(2).')
rptrGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 2, 1), )
if mibBuilder.loadTexts: rptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupTable.setDescription('Table of descriptive and status information about the groups of ports.')
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupEntry.setDescription('An entry in the table, containing information about a single group of ports.')
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupIndex.setDescription('This variable identifies the group within the repeater for which this entry contains information. This value is never greater than rptrGroupCapacity.')
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other groups in the repeater. 'Wilma Flintstone 6-Port FOIRL Plug-in Module, Rev A' or 'Barney Rubble 10BASE-T 4-port SIMM socket V. 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this variable could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port FOIRL Plug-in Module.'")
rptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group has been physically removed from the repeater. A status of operational(2) indicates that the group is functioning, and a status of malFunctioning(3) indicates that the group is malfunctioning in some way.')
rptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the rptrGroupOperStatus object for this group last changed. A value of zero indicates that the group's operational status has not changed since the agent last restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to rptrGroupPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
rptrPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 3, 1), )
if mibBuilder.loadTexts: rptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortTable.setDescription('Table of descriptive and status information about the ports.')
rptrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rptrPortGroupIndex"), (0, "LBHUB-MSH-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription('This variable identifies the group containing the port for which this entry contains information.')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIndex.setDescription('This variable identifies the port within the group within the repeater for which this entry contains management information. This value can never be greater than rptrGroupPortCapacity for the associated group.')
rptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. (In effect, when a port is disabled, the value of rptrPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the rptrPortAutoPartitionState becomes notAutoPartitioned(1), regardless of its pre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Sect. 9 [11]. They are not differentiated here.")
rptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortOperStatus.setDescription("This object indicates the port's operational state. The notPresent(3) state indicates the port is physically removed (note this may or may not be possible depending on the type of port.) The operational(1) state indicates that the port is enabled (see rptrPortAdminStatus) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState).")
rptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 2, 1, 22, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setDescription('This counter is incremented every time the repeater state machine enters the TRANSMIT COLLISION state from any state other than ONE PORT LEFT (Ref: Fig 9-2) [11]. Note: The approximate minimum time for counter rollover is 16 hours.')
rptrMonitorGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 2, 1), )
if mibBuilder.loadTexts: rptrMonitorGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTable.setDescription('Table of performance and error statistics for the groups.')
rptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rptrMonitorGroupIndex"))
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setDescription("An entry in the table, containing total performance and error statistics for a single group. Regular retrieval of the information in this table provides a means of tracking the performance and health of the networked devices attached to this group's ports. The counters in this table are redundant in the sense that they are the summations of information already available through other objects. However, these sums provide a considerable optimization of network management traffic over the otherwise necessary retrieval of the individual counters included in each sum.")
rptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information.')
rptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setDescription('The total number of frames of valid frame length that have been received on the ports in this group. This counter is the summation of the values of the rptrMonitorPortReadableFrames counters for all of the ports in the group. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the rptrMonitorPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
rptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this group. This counter is the summation of the values of the rptrMonitorPortTotalErrors counters for all of the ports in the group.')
rptrMonitorPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 1), )
if mibBuilder.loadTexts: rptrMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
rptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rptrMonitorPortGroupIndex"), (0, "LBHUB-MSH-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortEntry.setDescription('An entry in the table, containing performance and error statistics for a single port.')
rptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
rptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setDescription('This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
rptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If rptrMonitorPortAlignmentErrors is incremented then the rptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If rptrMonitorPortFrameTooLongs is incremented then neither the rptrMonitorPortAlignmentErrors nor the rptrMonitorPortFCSErrors counter shall be incremented for the frame. The approximate minimum time for rollover of this counter is 61 days.')
rptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of runts may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is asserted. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. The approximate minimum time for rollover of this counter is 81 hours.')
rptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate.')
rptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard.")
rptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.')
rptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: rptrMonitorPortFCSErrors, rptrMonitorPortAlignmentErrors, rptrMonitorPortFrameTooLongs, rptrMonitorPortShortEvents, rptrMonitorPortLateEvents, rptrMonitorPortVeryLongEvents, and rptrMonitorPortDataRateMismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
rptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 1), )
if mibBuilder.loadTexts: rptrAddrTrackTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackTable.setDescription('Table of address mapping information about the ports.')
rptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rptrAddrTrackGroupIndex"), (0, "LBHUB-MSH-MIB", "rptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: rptrAddrTrackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping information about a single port.')
rptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
rptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setDescription('This object is the SourceAddress of the last readable frame (i.e., counted by rptrMonitorPortReadableFrames) received by this port.')
rptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setDescription('This counter is incremented by one for each time that the rptrAddrTrackLastSourceAddress attribute for this port has changed. This may indicate whether a link is connected to a single DTE or another multi-user segment. The approximate minimum time for rollover of this counter is 81 hours.')
rptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 22) + (0,1)).setObjects(("LBHUB-MSH-MIB", "rptrOperStatus"))
if mibBuilder.loadTexts: rptrHealth.setDescription('The rptrHealth trap conveys information related to the operational state of the repeater. This trap is sent only when the operational status of the repeater changes. The rptrHealth trap must contain the rptrOperStatus variable. The agent may optionally include the rptrHealthText variable in the varBind list. See the rptrOperStatus and rptrHealthText objects for descriptions of the information that is sent. The agent must throttle the generation of consecutive rptrHealth traps so that there is at least a five-second gap between them.')
rptrGroupChange = NotificationType((1, 3, 6, 1, 2, 1, 22) + (0,2)).setObjects(("LBHUB-MSH-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupChange.setDescription('This trap is sent when a change occurs in the group structure of a repeater. This occurs only when a group is logically removed from or added to a repeater. The varBind list contains the identifier of the group that was removed or added. The agent must throttle the generation of consecutive rptrGroupChange traps for the same group so that there is at least a five-second gap between them.')
snmpDot3RpMauMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14, 2))
rpMauBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14, 2, 1))
rpMauTable = MibTable((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1), )
if mibBuilder.loadTexts: rpMauTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauTable.setDescription('Table of descriptive and status information about the groups of ports.')
rpMauEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rpMauGroupIndex"), (0, "LBHUB-MSH-MIB", "rpMauPortIndex"), (0, "LBHUB-MSH-MIB", "rpMauIndex"))
if mibBuilder.loadTexts: rpMauEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauEntry.setDescription('An entry in the table, containing information about a single group of ports.')
rpMauGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauGroupIndex.setDescription('This variable uniquely identifies the repeater group that contains the port to which is connected the MAU for which this entry contains information.')
rpMauPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauPortIndex.setDescription('This variable uniquely identifies the repeater port to which is connected the MAU for which this entry contains information.')
rpMauIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauIndex.setDescription('This variable uniquely identifies the MAU for which this entry contains information.')
rpMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7, 8, 9, 10, 14, 16, 17, 18))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("aui", 7), ("tenbase5", 8), ("foirl", 9), ("tenbase2", 10), ("tenbaseT", 14), ("tenbaseFP", 16), ("tenbaseFB", 17), ("tenbaseFL", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauType.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauType.setDescription('A value that identifies the 10 Mb/s baseband MAU type. The enumeration of the type is such that the value matches the section number of the IEEE 802.3 standard that specifies the particular MAU.')
rpMauAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpMauAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauAdminState.setDescription('The administrative state of the MAU. This object may be implemented as a read-only object by those agents and MAUs that do not implement software control of the administrative state. A MAU in the operational(3) state is fully functional, operates, and passes signals to its attached DTE or repeater port in accordance to its specification. A MAU in standby(4) state forces DI and CI and the media transmitter to idle. Standby(4) mode only applies to link type MAUs. The state of mauMediaAvailable is unaffected. A MAU in shutdown(5) state assumes the same condition on DI, CI, and the media transmitter as if it were powered down. The MAU may return other(1) state for the mauJabber and mauMediaAvailable objects when it is in this state. For an AUI, this state will remove power from the AUI. Setting this variable to the value reset(6) resets the MAU in the same manner as a power-off, power- on cycle would. Setting this variable to the value operational(3), standby(4), or shutdown(5) causes the MAU to assume the respective state except that setting a mixing-type MAU or an AUI to standby(4) will cause the MAU to enter the shutdown state.')
rpMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauMediaAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauMediaAvailable.setDescription('If the MAU is a link or fiber type (FOIRL, 10BASE-T, 10BASE-F) then this is equivalent to the link integrity/low light state. For an AUI or coax MAU this indicates whether or not loopback is detected on the DI circuit. The value of this attribute persists between packets for MAU types AUI, 10BASE5, 10BASE2, and 10BASE-FP. NOTE: IEEE 802.3 modified the following descriptive text at their meeting the week of 3/9/92. New text will be provided at the San Diego IETF plenary. At power-up or following a reset, the value of this attribute will be unknown for AUI, coax, and 10BASE-FP MAUs. For these MAUs loopback will be tested on each transmission during which no collision is detected. If DI receives input within startUpDelay of the start of output on DO, loopback will be detected. The value of startUpDelay shall be between 15 and 25 BT (bit times). Transition form input to output_idle on DI while output is present on DO may also be detected on loopback. The value of this attribute will only change during non-collided transmissions for AUI, coax, and 10BASE-FP MAUs.')
rpMauLostMedias = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauLostMedias.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauLostMedias.setDescription('A count of the number of times that rpMauMediaAvailable for this MAU instance leaves the state available(3). Implementation of this object is mandatory for MAU instances with rpMauType of AUI(7). It is recommended for all MAU types.')
rpMauJabberState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabberState.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauJabberState.setDescription('If the MAU is in jabber state the attribute is set to the jabbering(4) value. This object returns the value other(1) for MAU type AUI.')
rpMauJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauJabbers.setDescription('A count of the number of times that rpMauJabberState for this MAU instance enters the state jabbering(4).')
faultModifiedFlag = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean-read", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultModifiedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: faultModifiedFlag.setDescription('In order to ensure a clean read of the Fault table this flag should be set to clean_read when commencing to read the table and should be examined after reading the entire table. If still set to clean_read then the table read is okay, if not the table should be re-read as it has been modified during the read process.')
faultTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 19, 2), )
if mibBuilder.loadTexts: faultTable.setStatus('mandatory')
if mibBuilder.loadTexts: faultTable.setDescription('The Fault Table.')
faultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "faultIndex"))
if mibBuilder.loadTexts: faultEntry.setStatus('mandatory')
if mibBuilder.loadTexts: faultEntry.setDescription('Information relating to a single fault.')
faultIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultIndex.setStatus('mandatory')
if mibBuilder.loadTexts: faultIndex.setDescription('The index into the Fault table. The initial read from the table should be read as the next, from an index of 0; subsequent reads should read the next from the index returned by the previous read.')
faultErrorNumber = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultErrorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: faultErrorNumber.setDescription('This error number for this fault log entry.')
faultTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: faultTimeStamp.setDescription('The time since startup, in milliseconds, when the fault occurred.')
faultRestartCount = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: faultRestartCount.setDescription('The number of restarts at time of fault.')
setupGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 1))
heartbeatInterval = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: heartbeatInterval.setStatus('mandatory')
if mibBuilder.loadTexts: heartbeatInterval.setDescription('The time, in seconds, between successive heartbeat events sent to the management station. An interval of 0 indicates that no heartbeat events are to be generated.')
heartbeatEvent = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,13))
if mibBuilder.loadTexts: heartbeatEvent.setDescription('Generated at a regular interval to inform the manager this device is still operating and can be reached on the network.')
setupIp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 2))
setIpIfTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1), )
if mibBuilder.loadTexts: setIpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfTable.setDescription('This table shows the IP address and network mask to be used to initialise ipAddrTable on each network interface after the next system restart. There is one entry per network interface and the index is equivalent to the index for the ifTable in the MIB-II interfaces group.')
setIpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "setIpIfIndex"))
if mibBuilder.loadTexts: setIpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfEntry.setDescription('The default information relating to a single IP interface.')
setIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: setIpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex (for ifTable).')
setIpIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfAddr.setDescription('The IP address to be used for this interface.')
setIpIfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfMask.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfMask.setDescription('The IP network mask to be used for this interface.')
setIpIfRouter = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfRouter.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfRouter.setDescription("This is the IP address of the default router to be used for sending IP datagrams to remote destinations which have no suitable entry in the routing table. This corresponds to an entry in the MIB-II ipRouteTable with an ipRouteDest field of '0.0.0.0' (the default router) which is set up from this value after a system restart. Changes to this value do not affect the IP routing table until after the next system restart. (To change the default router without a restart, the IP routing table should be changed directly, with an equivalent change to setIpIfRouter only if the change is required to be made permanently.)")
setupStart = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 3))
startPROMSwVerNo = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: startPROMSwVerNo.setStatus('mandatory')
if mibBuilder.loadTexts: startPROMSwVerNo.setDescription('The PROM software version number.')
startRestartCount = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: startRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: startRestartCount.setDescription('The number of restarts the box has undergone, either power on or reset switch or watchdog expiries.')
startLastRestartType = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("command", 2), ("watchdog", 3), ("power-reset", 4), ("system-error", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: startLastRestartType.setStatus('mandatory')
if mibBuilder.loadTexts: startLastRestartType.setDescription('The reason for the last system restart. This may be due to management command; watchdog timeout expiry; power interruption; the reset switch was pressed or system error. It is not possible to differentiate between the latter two causes.')
startResetAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("manDefaultReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startResetAction.setStatus('mandatory')
if mibBuilder.loadTexts: startResetAction.setDescription('Reset the device with manufacturers default configuration if the manDefaultReset value is written to this item.')
startLastSystemError = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: startLastSystemError.setStatus('mandatory')
if mibBuilder.loadTexts: startLastSystemError.setDescription('The last System Error experienced by the system. This is set equal to the last system error code recorded in non-volatile memory on startup. When the system issues a TRAP indicating the last system error number, the value in non-volatile memory is set to zero. Hence after the next restart this attribute will also have the value zero.')
startRestartAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startRestartAction.setStatus('mandatory')
if mibBuilder.loadTexts: startRestartAction.setDescription("Restart the device with it's current configuration if the restart value is written to this item.")
systemConfigChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemConfigChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: systemConfigChangeTime.setDescription("This object contains the value of 'sysUpTime' for this agent at which the last configuration state change took place. For the purpose of this object the definition of a system configuration state change includes: 1) ANY change to the agent, or the device which the agent provides a management view affected through management (SNMP, telnet etc); 2) ANY internal change resulting in the attempt to generate a trap; 3) certain other device specific conditions which are significant but that which in themselves do not cause the generation of a trap.")
loadableDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 3, 1), )
if mibBuilder.loadTexts: loadableDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: loadableDeviceTable.setDescription('A table which is used to control the loading of new software images to the devices controlled by the management agent. By convention the first entry in the table (device type = system(1), instance = 1) controls the loading of the device containing the management agent itself. Agents which have no subsidiary devices will have only this one entry in the table. If the Agent does control subsidiary devices, the other entries control the loading of software into subsidiary devices.')
loadableDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "slDeviceType"), (0, "LBHUB-MSH-MIB", "slDeviceInstance"))
if mibBuilder.loadTexts: loadableDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loadableDeviceEntry.setDescription('An entry containing the objects for controlling the loading of a software image to a device controlled by the agent.')
slDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("system", 1), ("component", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: slDeviceType.setDescription("The type of the device to load. Simple agents only contain one device type, which is always `system'. More complex agents, probably containing multiple processors, may contain subsidiary devices denoted (for the purposes of the system loader) as `component'. In general, a `system' device is one which monitors and/or manages the operation of `component' devices.")
slDeviceInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slDeviceInstance.setStatus('mandatory')
if mibBuilder.loadTexts: slDeviceInstance.setDescription('The instance of the device type specified by slDeviceType. By convention instance 1 of the system devices is the one containing the management agent, and always exists. Many systems will contain only the one instance of the system device type.')
slLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 200, 201, 202, 203, 204, 205, 255))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("illegalOperation", 4), ("unknownTransferID", 5), ("noSuchUser", 7), ("noResponse", 8), ("noResource", 9), ("recLenMismatch", 10), ("invalidRecType", 11), ("checksumError", 12), ("wrongDevice", 13), ("wrongHardwareVersion", 14), ("noFileHeader", 15), ("byteCountError", 16), ("invalidProgAddress", 17), ("eraseFailed", 18), ("progFailed", 19), ("loadPending", 20), ("loadActive", 21), ("success", 22), ("paused", 23), ("modInvalidAdress", 200), ("modChecksumError", 201), ("modTimeout", 202), ("modBusy", 203), ("modRemoved", 204), ("modNoResource", 205), ("modFailure", 255))).clone('success')).setMaxAccess("readonly")
if mibBuilder.loadTexts: slLoadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slLoadStatus.setDescription('The status of the last system load operation requested for this device. If the value of this object is in the range 1 to 19 inclusive, or 200 or more, the download failed, and the value is an error code indicating the reason why. Codes 1 to 7 are a direct mapping from the TFTP error codes defined in RFC-783. The possible status values and their meanings are as follows:- fileNotFound(1) the server cannot find the requested file; accessViolation(2) the file system security mechanism does not permit TFTP to access the requested file; illegalOperation(4) TFTP protocol error; unknownTransferID(5) TFTP protocol error; noSuchUser(7) user number not recognised; noResponse(8) load server failed to respond; noResource(9) the download could not be started because of a lack of resources; recLenMismatch(10) the record length differs from that implied by the value of the record length field; invalidRecType(11) the record type is not recognised; checksumError(12) record checksum error; wrongDevice(13) the device type in the file is incorrect; wrongHardwareVersion(14) the software image is not suitable for this version of the hardware; noFileHeader(15) the first record in the file was not a file header; byteCountError(16) the byte count reported in the file trailer record differed from the number of bytes actually received; invalidProgAddress(17) the load file contained a load address which was outside the valid range of memory; eraseFailed(18) unable to erase the program memory; progFailed(19) hardware error programming the memory. The meanings of the remaining values are as follows:- loadPending(20) a load has been requested but has not yet begun; loadActive(21) the device is currently being downloaded; success(22) the device has been downloaded successfully; paused(23) the device could not complete the download at this time, it will request that the load be restarted when it is ready. The following status values may result from downloading a subsidiary module:- modInvalidAdress(200) the load file contained a load address which was outside the valid range of memory; modChecksumError(201) the load data was corrupted as it was transferred from the management agent to the subsidiary module; modTimeout(202) the management agent timed out while waiting for a response from the subsidiary module; modBusy(203) the subsidiary module was unable to accept a command from the management agent; modRemoved(204) the subsidiary module was removed during the download; modNoResource(205) the download could not continue because of a lack of resources; modFailure(255) the subsidiary module failed during the download.')
slSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: slSoftwareVersion.setDescription('The version identifier of the software running in the device.')
slHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slHardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: slHardwareVersion.setDescription('The version number identifying the revision level of the hardware of the device')
slFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slFilename.setStatus('mandatory')
if mibBuilder.loadTexts: slFilename.setDescription('The name of the file which contains the software image to load, or which was the last loaded to the device.')
slServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slServerIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: slServerIpAddress.setDescription('The IP address of the host containing the software image to load, or from which the last image loaded was read. This object has been deprecated in favour of writing the IP address into slServerAddress.')
slLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("startDownload", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: slLoad.setStatus('mandatory')
if mibBuilder.loadTexts: slLoad.setDescription('Writing 2 to this object causes the agent to attempt to load a new software image to the corresponding device. The file to load and the address of the server to load it from are specified in the other objects in the same row of the table.')
slServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slServerAddress.setDescription('The address of the server containing the software image to load, or from which the last image was loaded. This is either an IP address in standard dotted notation, or an IPX address in the format aabbccdd:112233445566. An error is returned if the agent does not support the download protocol implied by the address format.')
slServerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("tftp-ip", 2), ("tftp-ipx", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: slServerProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: slServerProtocol.setDescription('This is the protocol to use when downloading the software from the server specified in slServerAddress. At present, this value is determined by the value of slServerAddress which is currently un-ambiguous and so this object is read-only.')
slFailed = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,18)).setObjects(("LBHUB-MSH-MIB", "slLoadStatus"))
if mibBuilder.loadTexts: slFailed.setDescription('When a system load is requested, a response is returned immediately and the load proceeds in the background. If an error is detected this trap is generated indicating the reason why in the status, as follows:- (1) file not found; (2) access violation; (4) illegal TFTP operation; (5) unknown transfer ID; (7) no such user; (8) no response from the load server; (9) the download could not be started because of a lack of resources; (10) the length of a record differs from that implied by the value of the record length field; (11) the record type is not recognised; (12) record checksum error; (13) the device type in the file is incorrect; (14) the software image is not suitable for this version of the hardware; (15) the first record in the file was not a file header; (16) The byte count reported in the file trailer record differed from the number of bytes actually received; (200) the load file contained a load address which was outside the valid range of memory; (201) the load data was corrupted as it was transferred from the management agent to the subsidiary module; (202) the management agent timed out while waiting for a response from the subsidiary module; (203) the subsidiary module was unable to accept a command from the management agent; (204) the subsidiary module was removed during the download; (205) the download could not continue because of a lack of resources; (255) the subsidiary module failed during the download. When loading a new image into the device containing the agent itself, the agent first reads the beginning of the image file to test if it is accessible and contains a valid image. If there is anything wrong, this trap is generated, no download is performed and the device continues to run uninterrupted. If this check is successful the download proper is begun. Should that fail, it is simply retried continuously until either an attempt succeeds or the device is reset.')
securityEnableTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 1), )
if mibBuilder.loadTexts: securityEnableTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityEnableTable.setDescription('A table of permissions for access to the managed device from each of its interfaces, at each security access level. The table is fixed at 5 rows, indexed by the access level.')
securityEnableTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "securityLevel"))
if mibBuilder.loadTexts: securityEnableTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityEnableTableEntry.setDescription('This table allows individual interfaces to be enabled or disabled separately for each security level.')
securityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("monitor", 1), ("secureMonitor", 2), ("manager", 3), ("specialist", 4), ("security", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: securityLevel.setDescription('Index to the security enable table.')
securityCommunityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityCommunityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityCommunityEnable.setDescription('Community SNMP access permission')
securitySecureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securitySecureEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securitySecureEnable.setDescription('Secure SNMP access permission')
securityTermEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityTermEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityTermEnable.setDescription('Local Terminal access permission')
securityTelnetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityTelnetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityTelnetEnable.setDescription('Telnet access permission')
securityFrontPanelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityFrontPanelEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityFrontPanelEnable.setDescription('Front Panel access permission')
securityUserTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 2), )
if mibBuilder.loadTexts: securityUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserTable.setDescription('A table used to define Users. Users can be created/modified or deleted, with the exception of the default Users which cannot be deleted.')
securityUserTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "securityUserName"))
if mibBuilder.loadTexts: securityUserTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserTableEntry.setDescription("1. Creating a new user is done by using the username as a qualifier and SETting any of the items in the row - defaults will be used for the remaining values. 2. Deleting a user is by writing 'invalid' to the status column. 3. There must always be users called 'monitor', 'manager' and 'security' - these cannot be deleted.")
securityUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserStatus.setDescription("User Status. `invalid' is used to indicate this user is no longer allowed to access this device, and the table entry may subsequently be re-used. Note that the Status of default Users cannot be set to invalid.")
securityUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityUserName.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserName.setDescription('An ASCII string for the User Name. Empty strings are not allowed. The index column for the User Table.')
securityUserLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("monitor", 1), ("secureMonitor", 2), ("manager", 3), ("specialist", 4), ("security", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserLevel.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserLevel.setDescription('User Access Level defining the scope of management allowed for this user. Note that the access level of default Users cannot be changed.')
securityUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: securityUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserPassword.setDescription('The password required for user confirmation, when access is made via the local serial port, the front panel, or via Telnet.')
securityUserCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserCommunity.setDescription('The community string identifying this user, when access is made via the original community-based SNMP (RFC1157).')
securityUserLocParty = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 6), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserLocParty.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserLocParty.setDescription('The local party identity of this user, when access is made via secure SNMP.')
securityUserMgrParty = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 7), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserMgrParty.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserMgrParty.setDescription('The manager party identity for this user, when access is made via secure SNMP.')
securityAuditLogTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 3), )
if mibBuilder.loadTexts: securityAuditLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditLogTable.setDescription('The audit log is a circular table recording all updates to the managed database on the device. The log must be read regularly by a management device, to maintain a more permanent record of the management history.')
securityAuditLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "securityAuditIndex"))
if mibBuilder.loadTexts: securityAuditLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditLogEntry.setDescription('Each entry contains the time an update was made, by whom, the item referenced, the new value and the result of this request.')
securityAuditIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditIndex.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditIndex.setDescription('Audit Log Index. A monotonically increasing value to uniquely identify an entry in the audit log. This value wraps around (to 1) after reaching the maximum value (65535).')
securityAuditTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditTime.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditTime.setDescription('The time, in hundredths of a second since the last system restart, of the update request.')
securityAuditUser = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditUser.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditUser.setDescription('The name of the user making the request.')
securityAuditObject = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditObject.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditObject.setDescription('The object identifier of the item being updated. This includes any qualifier for the item.')
securityAuditValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditValue.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditValue.setDescription('The new value for the item.')
securityAuditResult = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("success", 255), ("pending", 1), ("too-big", 2), ("failed", 3), ("locked", 4), ("security-violation", 5), ("no-such-function", 6), ("no-such-item", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditResult.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditResult.setDescription('The result of the update request may indicate that it was applied successfully, that it failed (for one of a number of reasons) or that it is still in progress.')
gaugeTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 5, 1), )
if mibBuilder.loadTexts: gaugeTable.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTable.setDescription('A table used to define Alarms.')
gaugeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "gaugeIndex"))
if mibBuilder.loadTexts: gaugeTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableEntry.setDescription('This table allows Alarms to be set-up on items in the MIB.')
gaugeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeIndex.setDescription('Unique identifier for a row in the Alarm Table. Allocated by the Alarms Subsystem. An integer in the range 1..gaugeTableSize.')
gaugeItemId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeItemId.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeItemId.setDescription('The object Id and qualifier of the item to be monitored by this alarm. ')
gaugeItemType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("counter", 1), ("signedMeter", 2), ("unsignedMeter", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeItemType.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeItemType.setDescription("A 'counter', by definition will always be a positive number. 'Meters' can be signed or unsigned.")
gaugeSamplesPerAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nonAveraging", 1), ("twoSamples", 2), ("threeSamples", 3), ("maxSamples", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeSamplesPerAverage.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeSamplesPerAverage.setDescription('The number of samples used to calculate the Alarm Value. The default number of samples is four. If a SamplesPerAverage value of one is used, no average is calculated and the GaugeValue will be the most recent sample.')
gaugeSamplePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeSamplePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeSamplePeriod.setDescription('Number of seconds between samples. The total averaging period is given by (gaugeSamplesPerAverage * gaugeSamplePeiod) secs.')
gaugeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeValue.setDescription("The most recently computed average of the item being monitored. For a `meter' alarm, this is the simple average of the samples. For a 'counter' alarm, this is the average of the differences between successive samples. Counters and unsignedMeters are unsigned 32-bit values and have a maximum value of 4294967295. signedMeters are signed 32-bit values and have a maximum value of +-2147483647 divided by the value of gaugeSamplesPerAverage .")
gaugePeakValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugePeakValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugePeakValue.setDescription('The highest recorded Alarm Value. This will be either a signed or unsigned 32 bit value depending on the gaugeItemType')
gaugeThresholdLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdLevel.setDescription("The threshold value of the the Alarm which causes the ThresholdState to move from the 'ready' state to the 'fired' state and also causes the the ThresholdAction to be taken. It will be either a signed or unsigned 32-bit integer depending on the gaugeItemType.")
gaugeRecoveryLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryLevel.setDescription("The threshold value of the the Alarm which causes the ThresholdState to move from the `fired' state to the `ready' state and also causes the the RecoveryAction to be taken. This value will be either a signed or unsigned 32-bit integer depending on the gaugeItemType.")
gaugeThresholdAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 9, 12, 13, 14, 15, 18, 19, 20, 22, 23))).clone(namedValues=NamedValues(("noAction", 1), ("sendTrap", 2), ("disable", 3), ("enable", 4), ("notifyAndBlipPortOff", 5), ("notifyAndBlipCardOff", 6), ("notifyAndDisablePort", 8), ("notifyAndDisableCard", 9), ("blipPortOff", 12), ("blipCardOff", 13), ("disablePort", 14), ("disableCard", 15), ("notifyAndResilientSwitch", 18), ("notifyBandwidthExceeded", 19), ("notifyErrorsExceeded", 20), ("notifyPollFailed", 22), ("notifyFilterBridgePort", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdAction.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdAction.setDescription('This object identifies the action to be taken when an Alarm crosses the Threshold Level. The default action will be to send a trigger event (sendTrap). The other actions are device specific and may not be available on all devices. See the RMON Event Table for the actions supported by this device.')
gaugeRecoveryAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 10, 11, 16, 17, 21, 24))).clone(namedValues=NamedValues(("noAction", 1), ("sendTrap", 2), ("disable", 3), ("enable", 4), ("notifyAndEnablePort", 10), ("notifyAndEnableCard", 11), ("enablePort", 16), ("enableCard", 17), ("notifyPollSuccess", 21), ("notifyUnfilterBridgePort", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryAction.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryAction.setDescription("This object identifies the action to be taken when a 'fired' Alarm crosses the Recovery Level. The default action will be to send a recovery event (sendTrap). The actions for 'disable' and 'enable' are device specific.")
gaugeState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("onTriggersEnabled", 1), ("onTriggersDisabled", 2), ("off", 3), ("deleted", 4), ("autoCalibrate", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeState.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeState.setDescription(" onTriggersEnabled - This is the normal active state of a alarm. The gaugeValue is updated on every sample and if it crosses the Threshold or Recovery Levels, the corresponding Action will be taken. onTriggersDisabled - This is used when a new device, or alarm is set up and the Threshold and Recovery Levels have not been calibrated. The Alarm runs as normal and the gaugeValue and peakValue are updated. However, if the gaugeValue crosses the Threshold or Recovery Levels, no action is taken. off - This de-activates the alarm, allowing it to be configured safely . Before updating any of the Alarm fields the alarm SHOULD be turned off. Turning the alarm 'off' and then 'on' will not lose any of the sampling data, gaugeValue, peakValue, or thresholdStatus. Updates to the index fields will fail since they are read-only. deleted - An alarm is invalidated by setting it to 'deleted'. A 'deleted' alarm will not be returned by a 'GetNext' request. autoCalibrate - Updates the Threshold and Recovery values according to the current peak value. The gaugeState will then be set to 'onTriggersEnabled'. This can be done when the gaugeState is in states (1), (2), or (3). After this operation: thresholdLevel = peakValue * %gaugeThresholdLevelScaler recoveryLevel = peakValue * %gaugeRecoveryLevelScaler gaugeState = onTriggersEnabled When the gaugeState is set to either of the 'on' states, all the fields for the Alarm are validated. If any of the fields are invalid, the operation will fail. The sampling data, gaugeValue, peakValue and thresholdState can be reset by writing 'onTriggersEnabled', 'onTriggers- Disabled' , or 'autoCalibrate' to the gaugeState when it is already in either of the 'on' states.")
gaugeOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeOwner.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
gaugeTableSize = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableSize.setDescription('Number of entries in Alarm Table. The size of the Alarm Table depends on the requirements and available resources of the device. The actual maximum will probably be around 1000.')
gaugeThresholdLevelScaler = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdLevelScaler.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdLevelScaler.setDescription("The ThresholdLevel is set to this percentage of the peakValue when the Alarm is auto-calibrated. e.g gaugeThresholdLevelScaler = 120 gaugePeakValue = 360 After writing 'calibrateTriggers' to the gaugeState: ThresholdLevel = 120/100 * 360 = 432")
gaugeRecoveryLevelScaler = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryLevelScaler.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryLevelScaler.setDescription("The RecoveryLevel is set to this percentage of the peakValue when the Alarm is auto-calibrated. e.g gaugeRecoveryLevelScaler = 90 gaugePeakValue = 360 After writing 'calibrateTriggers' to the gaugeState: RecoveryLevel = 90/100 * 360 = 324")
gaugeTableUpdate = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("deleteAll", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeTableUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableUpdate.setDescription('Performs the specified operation on every Alarm in the table.')
gaugeConfigureObjId = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 6), ObjectIdentifier()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureObjId.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureObjId.setDescription('Object Id and qualifier of alarm(s) to be updated.')
gaugeConfigureColumn = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("itemType", 1), ("samplesPerAverage", 2), ("samplePeriod", 3), ("thresholdLevel", 4), ("recoveryLevel", 5), ("thresholdAction", 6), ("recoveryAction", 7), ("gaugeState", 8)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureColumn.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureColumn.setDescription('Alarm Table Column to be updated.')
gaugeConfigureValue = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureValue.setDescription("Value to be written to the 'gaugeConfigureColumn' of the Alarms which match the 'gaugeConfigureObjId'. Writing to this value initiates the operation.")
gaugeNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeNextFreeIndex.setDescription('Indicates the gaugeIndex which must be used to create the next alarm. Index is set to GAUGE_TABLE_FULL (zero) if there are no free rows in the table.')
gaugesThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,16)).setObjects(("LBHUB-MSH-MIB", "gaugeItemId"), ("LBHUB-MSH-MIB", "gaugeThresholdLevel"), ("LBHUB-MSH-MIB", "gaugeSamplePeriod"), ("LBHUB-MSH-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: gaugesThresholdTrap.setDescription(' Generated when the Alarm value for this Alarm crosses the Threshold Level.')
gaugesRecoveryTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,17)).setObjects(("LBHUB-MSH-MIB", "gaugeItemId"), ("LBHUB-MSH-MIB", "gaugeRecoveryLevel"), ("LBHUB-MSH-MIB", "gaugeSamplePeriod"), ("LBHUB-MSH-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: gaugesRecoveryTrap.setDescription(' Generated when the Alarm value for this Alarm crosses the Recovery Level.')
rmon = MibIdentifier((1, 3, 6, 1, 2, 1, 16))
statistics = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 1))
history = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 2))
alarm = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 3))
hosts = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 4))
hostTopN = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 5))
matrix = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 6))
filter = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 7))
capture = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 8))
event = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 9))
alarmTable = MibTable((1, 3, 6, 1, 2, 1, 16, 3, 1), )
if mibBuilder.loadTexts: alarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmTable.setDescription('A list of alarm entries.')
alarmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "alarmIndex"))
if mibBuilder.loadTexts: alarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alarmEntry.setDescription('A list of parameters that set up a periodic checking for alarm conditions.')
alarmIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmIndex.setDescription('An index that uniquely identifies an entry in the alarm table. Each such entry defines a diagnostic sample at a particular interval for an object on the device.')
alarmInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: alarmInterval.setDescription('The interval in seconds over which the data is sampled and compared with the rising and falling thresholds. When setting this variable, care should be given to ensure that the variable being monitored will not exceed 2^31 - 1 and roll over the alarmValue object during the interval. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmVariable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmVariable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmVariable.setDescription('The object identifier of the particular variable to be sampled. Only variables that resolve to an ASN.1 primitive type of INTEGER (INTEGER, Counter, Gauge, or TimeTicks) may be sampled. Because SNMP access control is articulated entirely in terms of the contents of MIB views, no access control mechanism exists that can restrict the value of this object to identify only those objects that exist in a particular MIB view. Because there is thus no acceptable means of restricting the read access that could be obtained through the alarm mechanism, the probe must only grant write access to this object in those views that have read access to all objects on the probe. During a set operation, if the supplied variable name is not available in the selected MIB view, a badValue error must be returned. If at any time the variable name of an established alarmEntry is no longer available in the selected MIB view, the probe must change the status of this alarmEntry to invalid(4). This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmSampleType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmSampleType.setStatus('mandatory')
if mibBuilder.loadTexts: alarmSampleType.setDescription('The method of sampling the selected variable and calculating the value to be compared against the thresholds. If the value of this object is absoluteValue(1), the value of the selected variable will be compared directly with the thresholds at the end of the sampling interval. If the value of this object is deltaValue(2), the value of the selected variable at the last sample will be subtracted from the current value, and the difference compared with the thresholds. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmValue.setStatus('mandatory')
if mibBuilder.loadTexts: alarmValue.setDescription('The value of the statistic during the last sampling period. The value during the current sampling period is not made available until the period is completed.')
alarmStartupAlarm = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("risingAlarm", 1), ("fallingAlarm", 2), ("risingOrFallingAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmStartupAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStartupAlarm.setDescription('The alarm that may be sent when this entry is first set to valid. If the first sample after this entry becomes valid is greater than or equal to the risingThreshold and alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3), then a single rising alarm will be generated. If the first sample after this entry becomes valid is less than or equal to the fallingThreshold and alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3), then a single falling alarm will be generated. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmRisingThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmRisingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: alarmRisingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is greater than or equal to this threshold, and the value at the last sampling interval was less than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is greater than or equal to this threshold and the associated alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3). After a rising event is generated, another such event will not be generated until the sampled value falls below this threshold and reaches the alarmFallingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmFallingThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmFallingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: alarmFallingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is less than or equal to this threshold, and the value at the last sampling interval was greater than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is less than or equal to this threshold and the associated alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3). After a falling event is generated, another such event will not be generated until the sampled value rises above this threshold and reaches the alarmRisingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmRisingEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmRisingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmRisingEventIndex.setDescription('The index of the eventEntry that is used when a rising threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmFallingEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmFallingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmFallingEventIndex.setDescription('The index of the eventEntry that is used when a falling threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmOwner.setStatus('mandatory')
if mibBuilder.loadTexts: alarmOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
alarmStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStatus.setDescription('The status of this alarm entry.')
eventTable = MibTable((1, 3, 6, 1, 2, 1, 16, 9, 1), )
if mibBuilder.loadTexts: eventTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventTable.setDescription('A list of events to be generated.')
eventEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 9, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "eventIndex"))
if mibBuilder.loadTexts: eventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventEntry.setDescription('A set of parameters that describe an event to be generated when certain conditions are met.')
eventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eventIndex.setDescription('An index that uniquely identifies an entry in the event table. Each such entry defines one event that is to be generated when the appropriate conditions occur.')
eventDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventDescription.setStatus('mandatory')
if mibBuilder.loadTexts: eventDescription.setDescription('A comment describing this event entry.')
eventType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmp-trap", 3), ("log-and-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventType.setStatus('mandatory')
if mibBuilder.loadTexts: eventType.setDescription('The type of notification that the probe will make about this event. In the case of log, an entry is made in the log table for each event. In the case of snmp-trap, an SNMP trap is sent to one or more management stations.')
eventCommunity = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: eventCommunity.setDescription('If an SNMP trap is to be sent, it will be sent to the SNMP community specified by this octet string. In the future this table will be extended to include the party security mechanism. This object shall be set to a string of length zero if it is intended that that mechanism be used to specify the destination of the trap.')
eventLastTimeSent = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLastTimeSent.setStatus('mandatory')
if mibBuilder.loadTexts: eventLastTimeSent.setDescription('The value of sysUpTime at the time this event entry last generated an event. If this entry has not generated any events, this value will be zero.')
eventOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventOwner.setStatus('mandatory')
if mibBuilder.loadTexts: eventOwner.setDescription("The entity that configured this entry and is therefore using the resources assigned to it. If this object contains a string starting with 'monitor' and has associated entries in the log table, all connected management stations should retrieve those log entries, as they may have significance to all management stations connected to this device")
eventStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eventStatus.setDescription('The status of this event entry. If this object is not equal to valid(1), all associated log entries shall be deleted by the agent.')
logTable = MibTable((1, 3, 6, 1, 2, 1, 16, 9, 2), )
if mibBuilder.loadTexts: logTable.setStatus('mandatory')
if mibBuilder.loadTexts: logTable.setDescription('A list of events that have been logged.')
logEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 9, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "logEventIndex"), (0, "LBHUB-MSH-MIB", "logIndex"))
if mibBuilder.loadTexts: logEntry.setStatus('mandatory')
if mibBuilder.loadTexts: logEntry.setDescription('A set of data describing an event that has been logged.')
logEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logEventIndex.setDescription('The event entry that generated this log entry. The log identified by a particular value of this index is associated with the same eventEntry as identified by the same value of eventIndex.')
logIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logIndex.setDescription('An index that uniquely identifies an entry in the log table amongst those generated by the same eventEntries. These indexes are assigned beginning with 1 and increase by one with each new log entry. The association between values of logIndex and logEntries is fixed for the lifetime of each logEntry. The agent may choose to delete the oldest instances of logEntry as required because of lack of memory. It is an implementation-specific matter as to when this deletion may occur.')
logTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logTime.setStatus('mandatory')
if mibBuilder.loadTexts: logTime.setDescription('The value of sysUpTime when this log entry was created.')
logDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logDescription.setStatus('mandatory')
if mibBuilder.loadTexts: logDescription.setDescription('An implementation dependent description of the event that activated this log entry.')
risingAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16) + (0,1)).setObjects(("LBHUB-MSH-MIB", "alarmIndex"), ("LBHUB-MSH-MIB", "alarmVariable"), ("LBHUB-MSH-MIB", "alarmSampleType"), ("LBHUB-MSH-MIB", "alarmValue"), ("LBHUB-MSH-MIB", "alarmRisingThreshold"))
if mibBuilder.loadTexts: risingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its rising threshold and generates an event that is configured for sending SNMP traps.')
fallingAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16) + (0,2)).setObjects(("LBHUB-MSH-MIB", "alarmIndex"), ("LBHUB-MSH-MIB", "alarmVariable"), ("LBHUB-MSH-MIB", "alarmSampleType"), ("LBHUB-MSH-MIB", "alarmValue"), ("LBHUB-MSH-MIB", "alarmFallingThreshold"))
if mibBuilder.loadTexts: fallingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its falling threshold and generates an event that is configured for sending SNMP traps.')
ascTimeAttemptedLogin = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 1), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascTimeAttemptedLogin.setStatus('mandatory')
if mibBuilder.loadTexts: ascTimeAttemptedLogin.setDescription('Time in hundredths of a second when the last Login was attempted. Note, that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR')
ascUserNameForLastAttemptedLogin = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascUserNameForLastAttemptedLogin.setStatus('mandatory')
if mibBuilder.loadTexts: ascUserNameForLastAttemptedLogin.setDescription('An ASCII string used when attempted login. Empty string is NOT valid. Note, that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR')
ascLoginStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("loginOKFromTelnet", 1), ("loginOKFromSerialPort", 2), ("deniedAccessFromTelnet", 3), ("deniedAccessFromSerialPort", 4), ("unknownUserFromTelnet", 5), ("unknownUserFromSerialPort", 6), ("incorrectPasswordFromTelnet", 7), ("incorrectPasswordFromSerialPort", 8), ("securityViolationFromTelnet", 9), ("securityViolationFromSerialPort", 10), ("nologin", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLoginStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ascLoginStatus.setDescription("Status of last attempted login. The value 'loginOKFromTelnet' or 'loginOKFromSerialPort' is used to show that the user was allowed access via Telnet or Serial Port. 'DeniedAccessFromTelnet' indicates that a user was denied access via Telnet. The value 'unknownUserFromTelnet' is used to show that a user attempted to login with an invalid user name from a Telnet session and 'incorrectPasswordFromTelnet' is used to show that an invalid password was entered having supplied a valid user name. The value 'securityViolationFromTelnet' is used to indicate that a user has entered the password incorrectly three time consecutively from a Telnet session. Note that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR")
ascLocalManagementBanner = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 490))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLocalManagementBanner.setStatus('mandatory')
if mibBuilder.loadTexts: ascLocalManagementBanner.setDescription('An ASCII string describing the Banner to appear on the FIRST screen of the Local Management Terminal. The string of 490 characters defines a region in the centre of the screen which is 7 Rows by 70 Columns')
localManagementUpdate = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,14))
if mibBuilder.loadTexts: localManagementUpdate.setDescription('A local management update trap indicates that the configuration of the device has been modified via the ascii agent. This may be through Telnet or the V24 port.')
securityViolation = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,15)).setObjects(("LBHUB-MSH-MIB", "ascUserNameForLastAttemptedLogin"), ("LBHUB-MSH-MIB", "ascLoginStatus"))
if mibBuilder.loadTexts: securityViolation.setDescription('A security violation trap indicates that a user has attempted to login and failed to enter the correct password Three times consecutively.')
siSlipPort = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siSlipPort.setStatus('mandatory')
if mibBuilder.loadTexts: siSlipPort.setDescription('This object identifies the serial port which SLIP can use to send/receive packets. If this object is set to 0xFFFF, then SLIP cannot send/receive packets.')
configV24Table = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 7, 2), )
if mibBuilder.loadTexts: configV24Table.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Table.setDescription('Configuration parameters for all the V.24 ports in a system.')
configV24Entry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "configV24PortID"))
if mibBuilder.loadTexts: configV24Entry.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Entry.setDescription('Configuration parameters for a V.24 port in the system.')
configV24PortID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configV24PortID.setStatus('mandatory')
if mibBuilder.loadTexts: configV24PortID.setDescription('This attribute uniquely identifies this V.24 port, it is the index for the V.24 table.')
configV24ConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24ConnType.setStatus('mandatory')
if mibBuilder.loadTexts: configV24ConnType.setDescription('This determines if the V.24 port is to be connected locally to a terminal or terminal emulator in which case no interface signals need to be asserted unless requested by other management options below or if the V.24 port is to be connected to a modem when at least DSR is required to be asserted.')
configV24AutoConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24AutoConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configV24AutoConfig.setDescription('This determines if the configuration parameters for the V.24 port, speed, parity, stop bits, character size, are to be determined automatically from an initial character sequence entered by the user or they will be defined by the management options below.')
configV24Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("speed1200", 4), ("speed2400", 5), ("speed4800", 6), ("speed9600", 7), ("speed19200", 8), ("speed38400", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Speed.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Speed.setDescription('This determines the receive and transmit speed of the V.24 port unless the autoconfigure attribute is enabled when the data rates are determined from the line. Split rx and tx speeds are not possible.')
configV24CharSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("size7", 3), ("size8", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24CharSize.setStatus('mandatory')
if mibBuilder.loadTexts: configV24CharSize.setDescription('This determines the character size, unless the autoconfigure attribute is enabled when character size is determined automatically from the line, it may be set to either 7 or 8 bits.')
configV24StopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopOne", 1), ("stopOneDotFive", 2), ("stopTwo", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24StopBits.setStatus('mandatory')
if mibBuilder.loadTexts: configV24StopBits.setDescription('This determines the number of stop bits.')
configV24Parity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noParity", 1), ("spaceParity", 2), ("markParity", 3), ("oddParity", 4), ("evenParity", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Parity.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Parity.setDescription('This determines the parity option to be used, unless the autoconfigure attribute is enabled when parity is determined automatically from the line, it may be set to either no parity, space (parity bit always 0), mark (parity bit always 1), odd or even.')
configV24DSRControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24DSRControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24DSRControl.setDescription('This attribute is only applicable to local connection types. It determines if DSR need be asserted for a local connection to be made and if the connection need be released if DSR is seen deasserted.')
configV24DCDControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24DCDControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24DCDControl.setDescription('This attribute is only applicable to local connection types. It determines if DCD need be asserted for a local connection to be made and if the connection should be release if DCD is seen deasserted.')
configV24FlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noFlowControl", 1), ("xonXoff", 2), ("rtsCtsFullDplx", 3), ("rtsCtsHalfDplx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24FlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24FlowControl.setDescription('This determines the flow control protocol to be used, either no flow control, xon-xoff, rts-cts full duplex or rts-cts. Full duplex rts/cts uses the rts and cts lines as two independent signals. The DTE signals to the DCE that it is prepared to accept more data by asserting RTS, the DCE signals to the DTE that is is prepared to accept more data by asserting CTS. Half duplex rts/cts (the conventional way) uses CTS as a response to RTS, the DCE flow controls the DTE by only returning CTS is response to a RTS from the DTE when the DCE can accept more data. The DTE can flow control the DCE by raising RTS when it does not want to receive any more input and dropping it when it is ready to receive more.')
configV24Update = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("update", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Update.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Update.setDescription('This attribute may be written to to force the operational V.24 port parameters to be updated.')
mrmSecurityPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 6))
mrmSecurePortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1), )
if mibBuilder.loadTexts: mrmSecurePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecurePortTable.setDescription('A table which allows management of the secure Repeater Ports.')
mrmSecurePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmSecRepIndex"), (0, "LBHUB-MSH-MIB", "mrmSecSlotIndex"), (0, "LBHUB-MSH-MIB", "mrmSecPortIndex"))
if mibBuilder.loadTexts: mrmSecurePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecurePortEntry.setDescription('This table allows repeater ports to be configured on a per port basis. It is index using the objects mrmSecRepIndex, mrmSecSlotIndex and mrmSecPortIndex.')
mrmSecRepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmSecRepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecRepIndex.setDescription('The secure port repeater index. This is the first of three indexes into the mrmSecurePortTable.')
mrmSecSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmSecSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecSlotIndex.setDescription('The secure port slot index. This is the second of three indexes into the mrmSecurePortTable.')
mrmSecPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmSecPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecPortIndex.setDescription('The secure port port index. This is the third of three indexes into the mrmSecurePortTable.')
mrmSecPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unauthorised-station-seen", 2), ("unauthorised-station-port-disabled", 3), ("authorised-station-learnt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmSecPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecPortState.setDescription('Attribute to determine the current security status of a port. This attribute is used by the security trap to identify the reason for the trap. The range of values returned by this object is 1 other 2 unauthorised-station-seen 3 unauthorised-station-port-disabled 4 authorised-station-learnt')
mrmSecNTKState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecNTKState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecNTKState.setDescription('Attribute to determine whether the Need to Know feature is enabled on the secure Repeater Line Card. The range of values that are valid for this object are 1 other 2 Need to Know is disabled 3 Need to know is enabled It is only valid to write the values 2 and 3.')
mrmSecBroadcastState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecBroadcastState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecBroadcastState.setDescription('Attribute to determine whether broadcasts are allowed or not allowed to be transmitted. 1 other 2 Broadcasts are not allowed 3 Broadcasts are allowed It is only valid to write the values 2 and 3.')
mrmSecMulticastState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecMulticastState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecMulticastState.setDescription('Attribute to determine whether multicasts are allowed or not allowed to be transmitted. 1 other 2 Multicasts are not allowed 3 Multicasts are allowed It is only valid to write the values 2 and 3.')
mrmSecLearnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("single", 2), ("continual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecLearnMode.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecLearnMode.setDescription('Attribute to determine the learning mode of the secure repeater line card. The range of values that are valid for this object are 1 no learning, the address is managed 2 the address of the first incoming packet is learnt 3 the address is continually learning ')
mrmSecReportMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("reportonly", 2), ("disconnectandreport", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecReportMode.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecReportMode.setDescription('Attribute to determine the reporting mode of the secure repeater port. The range of values that are valid for this object are 1 Not in applicable learn state 2 Report only 3 Disconnect and Report')
mrmSecMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecMACAddress.setDescription('The MAC address in use by the secure repeater port.')
mrmSecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("under-modification", 1), ("stable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmSecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mrmSecRowStatus.setDescription(' This parameter must be set to under-modification before any changes are made to an existing configuration. Changes are not applied until this parameter is set to stable. ')
mrmSecurityTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,37)).setObjects(("LBHUB-MSH-MIB", "mrmSecPortState"))
if mibBuilder.loadTexts: mrmSecurityTrap.setDescription(' This trap indicates that this port has detected a security violation.')
mrmStationLearnTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,36)).setObjects(("LBHUB-MSH-MIB", "mrmSecLearnMode"), ("LBHUB-MSH-MIB", "mrmSecMACAddress"))
if mibBuilder.loadTexts: mrmStationLearnTrap.setDescription(' This trap indicates that this port has autolearnt an end station address.')
esDatabaseState = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChange", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esDatabaseState.setStatus('mandatory')
if mibBuilder.loadTexts: esDatabaseState.setDescription(" This parameter is normally set to 'NO-CHANGE'. When any change is made to the database the value of this parameter becomes 'MODIFIED'. It will remain in this state until a manager sets it back to NO-CHANGE. ")
esDatabaseFlush = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("flush", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: esDatabaseFlush.setStatus('mandatory')
if mibBuilder.loadTexts: esDatabaseFlush.setDescription(' This parameter clears the End Station Database')
esTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 3), )
if mibBuilder.loadTexts: esTable.setStatus('mandatory')
if mibBuilder.loadTexts: esTable.setDescription('End Station Table')
esTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "esAddrType"), (0, "LBHUB-MSH-MIB", "esAddress"))
if mibBuilder.loadTexts: esTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esTableEntry.setDescription(" The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table is indexed firstly on address type and then on address and so can be used to read the entire contents of the database in end-station address order. Additionally one can read all addresses of a certain type from the database, e.g. all IP addresses known. There are some points to note when reading the contents of the end station table. Firstly the repeater number reported will change if a unit is moved from one repeater within a device to another or if a unit is isolated. Secondly an address will only appear in the table once. If an address which is already present in the database is found on another port then the original record is changed and the 'modified' flag set for that entry.")
esAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: esAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter allows access to the end station database indexed on address type. For example to read all IEE8021 addresses simply start with a get-next operation on IEEE8021.0 and read until the type changes.")
esAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: esAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
esSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esSlotNumber.setDescription(' Number of unit on which this address was learnt.')
esPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esPortNumber.setDescription(' Port number of unit on which this address was learnt.')
esModTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 4), )
if mibBuilder.loadTexts: esModTable.setStatus('mandatory')
if mibBuilder.loadTexts: esModTable.setDescription('End Station Table ( Modified )')
esModTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "esModAddrType"), (0, "LBHUB-MSH-MIB", "esModAddress"))
if mibBuilder.loadTexts: esModTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esModTableEntry.setDescription(" The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table is indexed firstly on address type and then on address. The view is restricted to include only those entries in the database which have the MODIFIED flag set, i.e. that have been changed since the database was last viewed by the manager. This table can be used to read all the modified entries in the table. This is the table generally used to update the contents of a station map in a management station. Note that it can take a reasonable time to read the contents of the table and in that time other changes may occur. To detect this an additional MIB parameter is specified 'esDatabaseState'. This parameter is normally set to 'NO-CHANGE'. When any change is made to the database the value of this parameter becomes 'MODIFIED'. It will remain in this state until a manager sets it back to NO-CHANGE. The recommended access for this table is as follows: do { write 'NO-CHANGE' to esDatabaseState read modified table read esDatabaseState } while esDatabaseState is MODIFIED There are some points to note when reading the contents of the end station table. Firstly the repeater number reported will change if a unit is moved from one repeater within a device to another or if a unit is isolated. Secondly an address will only appear in the table once. If an address which is already present in the database is found on another port then the original record is changed and the 'modified' flag set for that entry.")
esModAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: esModAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter allows access to the end station database indexed on address type. For example to read all IEE8021 addresses simply start with a get-next operation on IEEE8021.0 and read until the type changes.")
esModAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esModAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
esModSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esModSlotNumber.setDescription(' Unit number on which this address was learnt.')
esModPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esModPortNumber.setDescription(' Port number of unit on which this address was learnt.')
esPortAccessTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 5), )
if mibBuilder.loadTexts: esPortAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: esPortAccessTable.setDescription('End Station Table ( Port Access )')
esPortAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ecPortCardNo"), (0, "LBHUB-MSH-MIB", "ecPortPortNo"), (0, "LBHUB-MSH-MIB", "ecPortIndex"))
if mibBuilder.loadTexts: esPortAccessEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esPortAccessEntry.setDescription(' The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table allows one to determine the addresses learnt against a particular port.')
ecPortCardNo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortCardNo.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortCardNo.setDescription('Unit part of the identifier for this port.')
ecPortPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortPortNo.setDescription(' Port number on unit of port for which end station information is required.')
ecPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortIndex.setDescription(' Each port may have a number of addresses against it. This index allows these various addresses to be distinguished. The only stipulation on this number is that it will be unique for the any combination of unit and port. The numbers will be returned in numerically ascending order for a particular unit.port combination but will not be contiguous. For example the following sequence could be seen: Unit Port Index 1 1 211 1 1 231 1 1 438 1 1 672 1 2 120 etc')
ecPortAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter identifies the type of address in this entry of the table.")
ecPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
estStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,19))
if mibBuilder.loadTexts: estStateChange.setDescription(" When the end-station table moves from the noChange to modified state this trap is generated. The trap is sent once on this transition and not subsequently until the 'Database State' is changed back to 'noChange' by a manager.")
estTableFull = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,20))
if mibBuilder.loadTexts: estTableFull.setDescription(' When the end-station table becomes full this trap is generated.')
pollTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 20, 1), )
if mibBuilder.loadTexts: pollTable.setStatus('mandatory')
if mibBuilder.loadTexts: pollTable.setDescription('This table is used to provide remote device monitoring facilities. This table allows a list of network devices to be set up and polled regularly (or only once) by a variety of protocols. The table can be configured to inform the management station(s) of devices that are not responding to polls or that have started to respond after a period of silence. The minimum effort required to do a single poll is 1. In one packet, Write the address, rate=once-only(1) and RowStatus=CreateAndGo. 2. In the next packet, read the roundTripTime. The minimum effort required to monitor a device is 1. In one packet, Write the address, rate=every-30-seconds(1) and RowStatus=CreateAndGo. 2. Wait for traps to come in.')
pollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "pollIndex"))
if mibBuilder.loadTexts: pollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pollTableEntry.setDescription('A table used to define device monitoring.')
pollIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollIndex.setDescription('Unique identifier of a row in the Poll Table. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
pollAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pollAddress.setDescription('This DisplayString is the network address of the device to monitor. Typically this is an IP, MAC or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format IPX AABBCCDD:AABBCCDDEEFF - network : node')
pollProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3), ("learn", 4), ("llc", 5))).clone('unknown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: pollProtocol.setDescription('This defines the protocol to use with which to monitor the device. Writing an address to the pollAddress field causes a default pollProtocol value to be setup. The default value is derived from the format of the address - four bytes means ip(2), and 10 bytes means ipx(3) addresses. If the requested protocol is not supported or is not compatible with the pollAddress, then an error is returned when an attempt is made to set the RowStatus to active or notInService.')
pollRate = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("once-only", 1), ("every-30-seconds", 2), ("every-minute", 3), ("every-5-minutes", 4), ("every-30-minutes", 5), ("every-hour", 6))).clone('once-only')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollRate.setStatus('mandatory')
if mibBuilder.loadTexts: pollRate.setDescription('This defines how often a poll packet is sent to the device. If once-only(1) is chosen, then when the RowStatus is set to active, a single poll packet is to be sent. There are no re-transmissions and no traps are generated. The results of the operation can be read in the pollLastPollSent and pollRoundTripTime fields. When a reply to the poll is received, then the RowStatus is changed to notInService. For the other values, setting the RowStatus to active causes the device to be regularly polled. The operation of the poll can be monitored by reading the pollLastPollSent and pollRoundTripTime fields. After four un-successful polls a pollLostContact trap is generated. The next successful poll to the device causes a pollEstablishedContact trap to be generated. Changing RowStatus from the active state causes polling to stop - in particular changing RowStatus from active to notInService (and vice-versa) is a convenient way of stopping and starting the polls. A poll is said to have been un-successful, if no reply has been received by the time the device is due to be polled again - i.e. if the pollRoundTripTime is still zero. By convention, row 1 of the PollTable is only ever used for once-only(1) polls. The facilities of the RMON Alarm and RMON Event groups are used when regular polling is taking place. These groups perform the timing, threshold checking and trap generation.')
pollTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("file-server", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollTargetType.setStatus('mandatory')
if mibBuilder.loadTexts: pollTargetType.setDescription('This field is provided solely for the purpose of the Network Management station to allow extra information to be stored about this poll table entry. This value is not used by the device.')
pollLastPollSent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollLastPollSent.setStatus('mandatory')
if mibBuilder.loadTexts: pollLastPollSent.setDescription('Reading this variable returns the sysUpTime at which the last poll was sent to the device. A value of 0 means that no polls have been sent or that the poll could not be sent e.g. protocol error.')
pollRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: pollRoundTripTime.setDescription('This is the round trip time in milli-seconds of the most recent poll to the pollAddress device. A value of 0 means that no reply has been received from the last poll. Round trip times of less than one hundred of a second are reported with the value of 10 milli-seconds.')
pollInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollInformation.setStatus('mandatory')
if mibBuilder.loadTexts: pollInformation.setDescription('After each successful poll, this field is updated with some protocol specific information that was gleaned from the packet exchange. For the IPX protocol, this string contains the number of router hops made by the poll response packet. For the IP protocol, this string contains the value of Time-To-Live from the IP packet header.')
pollAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollAlarmIndex.setDescription('This is a value of alarmIndex from the RMON Alarm Table. The alarm indicated is being used by the PollTable to provide the timing and trap generation facilities. If this value is 0, then no alarm is associated with this PollTable entry.')
pollOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollOwner.setStatus('mandatory')
if mibBuilder.loadTexts: pollOwner.setDescription("The RMON OwnerString conventions are used here to help control the multi-manager situations. This data type is used to model an administratively assigned name of the owner of a resource. This information is taken from the NVT ASCII character set. It is suggested that this name contain one or more of the following: IP address, management station name, network manager's name, location, or phone number. In some cases the agent itself will be the owner of an entry. In these cases, this string shall be set to a string starting with 'monitor'. SNMP access control is articulated entirely in terms of the contents of MIB views; access to a particular SNMP object instance depends only upon its presence or absence in a particular MIB view and never upon its value or the value of related object instances. Thus, objects of this type afford resolution of resource contention only among cooperating managers; they realize no access control function with respect to uncooperative parties.")
pollRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pollRowStatus.setDescription('The SNMPv2 RowStatus convention. Notes: 1) Writing any data to a destroyed row, changes its state to notReady. 2) If the status is active or notInService and any of the configuration parameters are changed, then the polling stops and the status is set to notReady.')
pollNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 20, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollNextFreeIndex.setDescription('Indicates the the next value of pollIndex which can be used to create the next poll entry. This value is set to zero if there are no free rows in the table.')
pollTableSuccessTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,61)).setObjects(("LBHUB-MSH-MIB", "pollAddress"), ("LBHUB-MSH-MIB", "pollProtocol"), ("LBHUB-MSH-MIB", "pollTargetType"))
if mibBuilder.loadTexts: pollTableSuccessTrap.setDescription('This trap is generated when the PollTable in the managed agent receives a reply to a poll after a sequence of four or more un-successful polls.')
pollTableFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,62)).setObjects(("LBHUB-MSH-MIB", "pollAddress"), ("LBHUB-MSH-MIB", "pollProtocol"), ("LBHUB-MSH-MIB", "pollTargetType"))
if mibBuilder.loadTexts: pollTableFailedTrap.setDescription('This trap is generated when the PollTable in the managed agent fails to receive a reply to four successive polls.')
trapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 10, 1), )
if mibBuilder.loadTexts: trapTable.setStatus('deprecated')
if mibBuilder.loadTexts: trapTable.setDescription('The snmp Trap database ')
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "trapDestination"))
if mibBuilder.loadTexts: trapEntry.setStatus('deprecated')
if mibBuilder.loadTexts: trapEntry.setDescription('A single snmp Trap entry')
trapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapStatus.setStatus('deprecated')
if mibBuilder.loadTexts: trapStatus.setDescription('The Status of the Entry valid(1) or invalid(2), writing invalid(2) will delete the entry from the table')
trapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDestination.setStatus('deprecated')
if mibBuilder.loadTexts: trapDestination.setDescription('The Destination IP Address')
trapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapCommunity.setStatus('deprecated')
if mibBuilder.loadTexts: trapCommunity.setDescription('SNMP Community to be used to send traps to destination trapDestination')
trapSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapSubject.setStatus('deprecated')
if mibBuilder.loadTexts: trapSubject.setDescription('SNMP Subject Party used to generate traps to destination trapDestination')
trapCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapCategory.setStatus('deprecated')
if mibBuilder.loadTexts: trapCategory.setDescription("32 Bit Mask indicating which Trap categories that the snmpTrapDestination is interested in. '00000001'h - High Priority Configuration Traps '00000002'h - Low Priority Configuration Traps '00000004'h - High Priority Security Traps '00000008'h - Low Priority Security Traps '00000010'h - Alarms & Polling Traps '00000020'h - Regular Heartbeat Traps '00000040'h - End Station Table Traps '00000080'h - reserved '00000100'h - Physical Entity Traps '00000200'h - Facility Traps '00000400'h - Service Related Traps A value of 0xFFFFFFFF enables all traps.")
trapThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapThrottle.setStatus('deprecated')
if mibBuilder.loadTexts: trapThrottle.setDescription('The Maximum rate at which that trapDestination is willing to receive traps, specified as the minimum interval in milliseconds between traps. A value of zero indicates that no trap throttling is required.')
snmpTrapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 10, 2), )
if mibBuilder.loadTexts: snmpTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapTable.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "snmpTrapIndex"))
if mibBuilder.loadTexts: snmpTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapEntry.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapIndex.setDescription('This is the unique identifier for this row in the snmpTrapTable. When creating a new row, a manager can read the value of the snmpTrapNextFreeIndex object and (if non-zero) can use this value as the index of the new row to be created. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
snmpTrapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapDestination.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapDestination.setDescription('This DisplayString is the network address of the device to which SNMP traps will be sent. This is an IP or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format IPX AABBCCDD:AABBCCDDEEFF - network : node Destination addresses must be unique within this table. An error is returned if an attempt is made to add a duplicate address.')
snmpTrapProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapProtocol.setDescription('This defines the transport protocol to use when sending an SNMP trap. At present, this value is determined by the format/value of snmpTrapDestionation which is currently un-ambiguous and so this object is read-only.')
snmpTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunity.setDescription('SNMP Community String to be used when sending Traps to this destination.')
snmpTrapCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCategory.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCategory.setDescription("32 Bit Mask indicating which Trap categories that the snmpTrapDestination is interested in. '00000001'h - High Priority Configuration Traps '00000002'h - Low Priority Configuration Traps '00000004'h - High Priority Security Traps '00000008'h - Low Priority Security Traps '00000010'h - Alarms & Polling Traps '00000020'h - Regular Heartbeat Traps '00000040'h - End Station Table Traps '00000080'h - reserved '00000100'h - Physical Entity Traps '00000200'h - Facility Traps '00000400'h - Service Related Traps A value of 0xFFFFFFFF enables all traps.")
snmpTrapThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapThrottle.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapThrottle.setDescription('The maximum rate at which that snmpTrapDestination is willing to receive traps, specified as the minimum interval in milliseconds between traps. For example, a value of 2000 will limit traps sent to this destination to one trap every 2 seconds. A value of zero indicates that no trap throttling is required.')
snmpTrapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapRowStatus.setDescription('The SNMPv2 RowStatus convention. Notes: Because this is such a simple table:- 1) Writing any data to a destroyed row, changes its state to active. 2) There is no notReady or notInService state. Each row is either active or destroyed.')
snmpTrapNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setDescription('Indicates the the next value of snmpTrapIndex which can be used to create a new trap destination entry. This value is zero if there are no free rows in the table.')
enclosure = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14, 1))
physicalConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14, 2))
logicalConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14, 3))
enclosureName = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 14, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclosureName.setStatus('mandatory')
if mibBuilder.loadTexts: enclosureName.setDescription(' A text string describing the chassis that this MIB describes.')
enclosureObjId = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 14, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclosureObjId.setStatus('mandatory')
if mibBuilder.loadTexts: enclosureObjId.setDescription(' An OBJECT IDENTIFIER specific to this type of this chassis.')
enclosureHardwareVers = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclosureHardwareVers.setStatus('mandatory')
if mibBuilder.loadTexts: enclosureHardwareVers.setDescription(' The hardware version number of the chassis. This is a string which includes the major and minor revision levels of the hardware.')
phyConfigTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1), )
if mibBuilder.loadTexts: phyConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: phyConfigTable.setDescription(' This table specifies the current physical configuration of the chassis. This table defines a chassis to contain a number of physical entities. Each such entity has some position that distinguishes it from other potentially similar entities. Examples of entities are cards, power supplies etc. Note that this table only contains information on a location that is currently occupied by some entity.')
phyConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "phyLocationType"), (0, "LBHUB-MSH-MIB", "phyLocation"))
if mibBuilder.loadTexts: phyConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phyConfigEntry.setDescription(' This is one entry in the Physical Configuration Table. It is indexed by physical location.')
phyLocationType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("module", 1), ("power-supply", 2), ("fan", 3), ("backplane", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLocationType.setStatus('mandatory')
if mibBuilder.loadTexts: phyLocationType.setDescription(' A chassis contains a number of physical entities such as power supplies and cards. Each physical entity resides at some location. A chassis can contain a number of types of location. Each type of location is specialised to a different purpose. Currently there are four types of location defined. This list can be extended for a particular application: modular-slot: A location of this type can take a number of different entities. They are general purpose and are often the purpose of the device. power-supply-bay: Locations of this type can only contain an instance of a power supply. fan-position: This location can only hold a fan. backplane-position: A position of this type can only contain a backplane.')
phyLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLocation.setStatus('mandatory')
if mibBuilder.loadTexts: phyLocation.setDescription(" A chassis contains a number of physical entities such as power supplies and cards. Each physical entity resides at some location. Some locations are known and have special purposes, others are general and can contain one of a number of different physical entities. The location type defines a 'kind' of location. Within each category there may be one or more instances of that kind of location. For example in a 10 slot modular hub there are potentially 10 instances of card locations occupied at any time.")
phySysObjId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySysObjId.setStatus('mandatory')
if mibBuilder.loadTexts: phySysObjId.setDescription(' This object is the OBJECT ID of the entity at this location.')
phyServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 12, 13, 14, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("dumb8023Repeater", 1), ("ieee8023Repeater", 2), ("ieee8025MauModule", 3), ("ieee8025Ringbuilder", 4), ("fddiConcentrator", 5), ("managementModule", 6), ("standardBackplane", 12), ("extendedBackplane", 13), ("displayPanel", 14), ("fan", 17), ("powerSupply", 18), ("standardBridge", 19), ("bridgePerPort", 20), ("terminalServer", 21), ("remoteBridge", 22), ("fddiMIC", 23), ("notAllocated", 24), ("fddiLinkSwitch", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: phyServiceType.setDescription(" This object identifies what kind of entity is present at this location. The value represents a category of entity, for example '802.3 Repeater' or 'power supply'. It does not identify the specific kind of entity within that category, for this refer to the entity type.")
phyEntityType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyEntityType.setStatus('mandatory')
if mibBuilder.loadTexts: phyEntityType.setDescription(" This object is read in conjunction with service type to uniquely identify the specific physical entity. For example the service type may indicate '802.3 Repeater' while the entity type then says within this category this card is a 12 port UTP card. Below are the values currently allocated: smart8023Repeater 1: 4 Port RLC Coax (ECS Variant) 2: 8 Port UTP (ECS Variant) 3: 4 Port Fibre (ECS Variant) 4: 8 Port STP (ECS Variant) 6: 4 Port Fanout (ECS Variant) 7: 12 Port UTP (ECS Variant) 8: 12 Port STP (ECS Variant) 9: 12 Port Secure UTP (ECS Variant) 10: 12 Port Secure STP (ECS Variant) 11: 6 Port Fibre (ECS Variant) 12: 4 Port Coax (ECS Variant) 32: 6 Port Resilient Fibre (ECS Variant) 65: 12 Port UTP, RJ45 Connector 66: 12 Port UTP, RJ45 Connector (Expandable) 67: 13 Port UTP, Telco + Module 68: 24 Port UTP, 2xTelco 69: 6 Port fibre, ST Connector (Expandable) 70: 6 Port fibre, SMA Connector (Expandable) 71: 6 Port Coax (Expandable) 72: 4 Port Fanout ieee8025MauModule 1: 12 Port UTP, RJ45 Connector 2: 12 Port STP, RJ45 Connector 3: 12 Port UTP/STP Advanced MAU ieee8025Ringbuilder 1: Ring Builder. STP Rin/Rout. RJ45 Connectors 2: Ring Builder. Fiber (ST) and STP Rin/Rout. fddiConcentrator 1: FDDI RingBuilder managementModule 1: Standard Management Module 2: Enhanced Management Module standardBackplane 1: Standard Backplane extendedBackplane 1: High Speed Backplane displayPanel 1: First release front panel fan 1: Standard Fan Tray powerSupply 2: Standard Power Supply standardBridge 1: 2 Port Local Token Ring Bridge 2: 4 Port Local Ethernet Bridge fddiMIC 1: FDDI 4 Port MIC 2: FDDI 6 Port UTP/STP fddiLinkSwitch 1: LinkSwitch ")
phyHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: phyHwVersion.setDescription(' This string identifies the major and minor revision level of the entity at this location.')
phySwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: phySwVersion.setDescription(" If the entity at this location contains a processor there will be some programme code present. This parameter specifies the version number of that code. The version number is a string. If an entity has no software then the value of this parameter will be 'None'.")
phyServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: phyServiceId.setDescription(' Every chassis is considered as a collection of services. Each service is implemented using the resources of one or more physical entities within the rack. For example a repeater may be implemented using 2x12 port UTP cards. A power supply by 3 modular power supply entities. The service table contains an entry for each service present in the MSH at any point in time. This object provides a valid index into the service table. By reading the service table and specifying the value of this object one can determine to which service this card belongs.')
phyEntityName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyEntityName.setStatus('mandatory')
if mibBuilder.loadTexts: phyEntityName.setDescription(' This item is a text string describing the entity at this location.')
phyPowerReq = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPowerReq.setStatus('mandatory')
if mibBuilder.loadTexts: phyPowerReq.setDescription(' This item takes the +5V and +12V current requirements of the entity and uses the values to obtain a power consumption requirement for the entity. A power supply will specify a negative value indicating a source of power. The value is in Watts. Note that the value returned from this object is the simple arithmetic addition of the all power rail requirements. Note that a power supply may be overloaded even if this value is within the spec of the power supplies. Such a situation can occur if the power supplies can source, say X5 Watts at 5V and X12 Watts at 12V. The total power by this definition is X5 + X12. Now a card could draw Y5 and Y12 from the two supplies. If Y12 is X12+1 and Y5 is X5-2, total supply exceeds total consumption but the 12V rail is overloaded!')
phyNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: phyNumberOfPorts.setDescription(" This object contains the number of physical, external ports this entity is known to have. Note this value only applies to entities that communicate with the management card. For other cards a value of -1 indicates 'unknown'. A value of zero indicates that this entity has no external ports.")
phyLampTest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("test-off", 1), ("test-on", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: phyLampTest.setStatus('mandatory')
if mibBuilder.loadTexts: phyLampTest.setDescription(' This object allows a visual test to be performed on entities contained in the rack. The state will be recorded against the card even if that entity does not actually do anything different in this state.')
phyEntityState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("initialising", 2), ("operational", 3), ("failure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyEntityState.setStatus('mandatory')
if mibBuilder.loadTexts: phyEntityState.setDescription(" Each entity in the chassis has a basic state independent of what function that entity performs within the chassis. If the agent cannot determine the state of a particular entity then the value of this object is 'unknown'.")
phyAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: phyAction.setStatus('mandatory')
if mibBuilder.loadTexts: phyAction.setDescription(' This parameter allows a number of actions to be defined for cards in a chassis. Currently only one action is defined: reset. Invoking this operation will reset the specified card.')
phyLimits = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 2), )
if mibBuilder.loadTexts: phyLimits.setStatus('mandatory')
if mibBuilder.loadTexts: phyLimits.setDescription(' The physical config table describes the chassis as a number of physical entities, each of which has some physical location. This table defines the number of physical locations of each type that actually exists within an instance of the chassis.')
phyLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "phyLimLocationType"))
if mibBuilder.loadTexts: phyLimitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phyLimitEntry.setDescription(" This entry provides information on the number of physical locations present in this chassis for the specified type of location. Practically this is interpreted as the 'number of power supplies' or 'number of slots' etc.")
phyLimLocationType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("module", 1), ("power-supply", 2), ("fan", 3), ("backplane", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLimLocationType.setStatus('mandatory')
if mibBuilder.loadTexts: phyLimLocationType.setDescription(' A chassis contains a number of physical entities such as power supplies and cards. Each physical entity resides at some location. A chassis can contain a number of types of location. For each particular type of location there is a limit to the number that may be present in the chassis.')
phyLimLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLimLimit.setStatus('mandatory')
if mibBuilder.loadTexts: phyLimLimit.setDescription(" A chassis contains a number of physical entities such as power supplies and cards. Each physical entity resides at some location. A chassis can contain a number of types of location. For each particular type of location there is a limit to the number that may be present in the chassis. This object identifies the actual number of locations in this chassis that exist for the specified type. Practically this is interpreted as the 'number of power supplies' or 'number of slots' etc.")
frontPanelDisplayMessage = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 14, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frontPanelDisplayMessage.setStatus('mandatory')
if mibBuilder.loadTexts: frontPanelDisplayMessage.setDescription(' This is a string which may be user-defined for display on the lower line of the front panel display.')
serviceTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 1), )
if mibBuilder.loadTexts: serviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: serviceTable.setDescription(' An MSH chassis is logically comprised of a number of services, e.g. a repeater, bridge etc. Each service is implemented by one or more physical entities. This table contains an entry for each service, providing a name for that service type. Note that every entry in the physical configuration table MUST belong to a service. For example there may NOT be an entry in the phyConfigTable for which the value of phyServiceId does not provide an index into this table of an existent row.')
serviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "serviceId"))
if mibBuilder.loadTexts: serviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serviceEntry.setDescription(' This is an entry in the Service Table which is indexed by the Service Index for that service.')
serviceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceId.setStatus('mandatory')
if mibBuilder.loadTexts: serviceId.setDescription(' This is a number representing the service in the rack. This id can be used to reference the service elsewhere in the MIB. There are several conventions used to allocate a service Id. Firstly if a card forms a service by itself, for example a bridge card, which uses none of the backplane 802.3 or token ring lines, then the service id is the same as the slot position of that card within the rack. If a service is constructed using one of the backplane 802.3 facilities then the service id is 101, 102 or 103 for the three backplane 802.3 paths. If a service is a token ring fragment then the service id for that service is 200 plus the ring fragment id. For example if Ring Builder builder builds a ring from MAU cards with ring fragment id 7, the corresponding service will be 207.')
serviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceName.setStatus('mandatory')
if mibBuilder.loadTexts: serviceName.setDescription(' This is a text string describing the service at a particular Service Index.')
serviceReset = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: serviceReset.setStatus('mandatory')
if mibBuilder.loadTexts: serviceReset.setDescription(' This action will reset all the cards that belong to this service.')
addressTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2), )
if mibBuilder.loadTexts: addressTable.setStatus('mandatory')
if mibBuilder.loadTexts: addressTable.setDescription(" An MSH chassis contains a number of services. Each service is implemented by one or more cards. A number of services are 'intelligent' in that they communicate with the management station through their own communications stack. This table allows a manager to determine the addresses relevant to a particular service. The table will only have entries present for cards which have management addresses. The table is accessed by specifying a service Id and a sub-index value to distinguish between potentially multiple addresses for a service. NOTE: This table includes entries for the management card itself. The management card entries contain the physical address of the currently active MAC and the IP address of the SNMP stack.")
addressTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mgmtServiceId"), (0, "LBHUB-MSH-MIB", "mgmtSubIndex"))
if mibBuilder.loadTexts: addressTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: addressTableEntry.setDescription('text')
mgmtServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtServiceId.setDescription('Identifies the service for which this row provides address information.')
mgmtSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtSubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtSubIndex.setDescription(' Used to distinguish between multiple addresses for a service in the chassis.')
mgmtAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ieee8023address", 1), ("ieee8025address", 2), ("ipaddress", 3), ("slipaddress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtAddressType.setDescription(' A card in the chassis can have several addresses, either because of multiple stacks and/or for each relevant level in the stack(s). Each relevant address is represented in this table as a display string and a type. Note that ieee8023Address and ieee8025Address types differ from each other in the bit ordering of the physical address.')
mgmtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtAddress.setDescription(' The address as block of bytes. An IP address would occupy 4 bytes and a MAC address 6 bytes.')
facilityTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3), )
if mibBuilder.loadTexts: facilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: facilityTable.setDescription(" The MSH chassis can simultaneously maintain a number of different sub-networks. Examples of these are the independent repeaters and a number of Token Rings. These fundamental services are referred to as facilities. Each card in the chassis can either provide or be connected to one or more of these facilities. This table provides a means of determining and changing the facilities used by a particular card. The number of entries per card depends on the type of card. For example an 802.3 repeater card can be expected to have a single entry while an 'n' port bridge would have 'n'. The number of entries for a particular card is fixed (can't insert into or delete from this table).")
facilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "fcSlotNumber"), (0, "LBHUB-MSH-MIB", "fcFacilityIndex"))
if mibBuilder.loadTexts: facilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: facilityEntry.setDescription(' This is an entry in the Facility Table for a particular slot. There may be more than one entry per slot, each entry being distinguished by FacilityIndex.')
fcSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcSlotNumber.setDescription(' Allows access to the table for a particular card. One can use this in conjunction with get-next to read all the facility associations for a particular card.')
fcFacilityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFacilityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFacilityIndex.setDescription(' Each card may have multiple entries in the Facility Table. This object provides the means of uniquely identifying each of these entries. Note: It is a convention that the value of this index maps as closely as possible to the physical configuration of the entity represented. For example if a bridge has ports numbered 1, 2, 3 and 4 and all are switchable then this table will have four entries for that entity indexed 1, 2, 3 and 4. Entry with index 1 represents port 1 etc. Similarly if a bridge had two ports numbered, for some reason, 234 and 456 then these values would be used as the index to this table.')
fcType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ieee8023", 1), ("ieee8025", 2), ("fddi", 3), ("ieee8025rb", 4), ("ieee8023v3", 5), ("atm", 6), ("smds", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcType.setStatus('mandatory')
if mibBuilder.loadTexts: fcType.setDescription(' Each entry in the facility table represents an association between a physical module and one of the facilities provided by the particular configuration of this chassis. There are a number of different types of facilities the chassis can provide. This object identifies the particular type of the facility represented by this table entry. Note that the list of types in this object may be extended in future.')
fcConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 14, 3, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcConnection.setStatus('mandatory')
if mibBuilder.loadTexts: fcConnection.setDescription(' This object identifies the current assignment of this attachment point in this card. The legal values of this object depends on the type card. Writing an illegal value to this object will cause an error. Generally the table following identifies the possible values, depending on type. Each card type will support a subset of these values. Type Possible Values IEEE8023 0 Isolated (i.e. this interface is not connected to anything). 1,2,3 One of the backplane 802.3 networks. IEEE8025 0 Isolated 1..0x7f A ring number. This must match the value of one of he ring builder cards or the request will be rejected. FDDI Unknown at the moment. Probably similar to IEEE8025 Note: Values greater than 0x7f are reserved to be private values for a particular card. The meaning of these values depend on the card type. A possible use of this is in a multiport 802.3 bridge. Consider such a bridge being capable of bridging between three sources and having two external 802.3 connections. Such a bridge would have three entries in the facility table, one for each bridge source. Each entry could be assigned to one of the backplane 802.3 paths or to one of the two external connections. In this case the possible values for each table entry would be: 0x00 : Not used (isolated) 0x01, 0x02, 0x03 : One of the backplanes 0x81, 0x82 : One of the external connections. The MSH agent will not allow two different entries in this table for the same card to be assigned to the same facility!')
phyEntityInserted = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,27)).setObjects(("LBHUB-MSH-MIB", "phyServiceType"), ("LBHUB-MSH-MIB", "phyEntityType"), ("LBHUB-MSH-MIB", "phyServiceId"), ("LBHUB-MSH-MIB", "phyNumberOfPorts"), ("LBHUB-MSH-MIB", "phyEntityName"))
if mibBuilder.loadTexts: phyEntityInserted.setDescription(" This trap is sent when a new entity is detected in the chassis. The entity is identified both by its location in the chassis and it's type information. The display string is included to make event descriptions more understandable. The phyServiceId indicates to which service the new entity belongs or implements. If the entity belongs to more than one service then this parameter indicates one of the services.")
phyEntityRemoved = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,28)).setObjects(("LBHUB-MSH-MIB", "phyServiceId"), ("LBHUB-MSH-MIB", "phyEntityName"))
if mibBuilder.loadTexts: phyEntityRemoved.setDescription(' This trap is sent when an entity is removed. The qualifier information on the variables identify the location of the entity that has been removed while the entity name is the textual description of the card that was removed.')
phyFacilityChanged = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,29)).setObjects(("LBHUB-MSH-MIB", "phyServiceId"), ("LBHUB-MSH-MIB", "fcType"), ("LBHUB-MSH-MIB", "fcConnection"))
if mibBuilder.loadTexts: phyFacilityChanged.setDescription(' This trap is sent when the facility table is changed. This trap is only send when the change is made as the result of a local management request. The trap includes information about the type of the connection changed and the new connection value.')
serviceEntityAdded = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,30)).setObjects(("LBHUB-MSH-MIB", "phyServiceId"))
if mibBuilder.loadTexts: serviceEntityAdded.setDescription(' This trap is sent when a card is added to a service. This trap is always sent, regardless of how the card addition occurred. There are two situations in which a card is added to a service. The first is where a new card is inserted and is attached to a service. The second is where an existing card is removed from one service and added to another. Note that the transmission of this trap may imply the creation of a new service.')
serviceEntityRemoved = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,31)).setObjects(("LBHUB-MSH-MIB", "phyServiceId"))
if mibBuilder.loadTexts: serviceEntityRemoved.setDescription(' This trap is sent when an entity is removed from a service. This trap is always sent, regardless of how the card removal occurred. There are two situations in which a card is removed from a service. The first is where a card is removed from the chassis. The second is where an existing card is removed from one service and added to another. The service id in the variables list indicates the service to which to card did belong. Note that the transmission of this trap may imply that the service to which it belongs no longer exists. This is the case where the card was the only current member of the service.')
physicalStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,32)).setObjects(("LBHUB-MSH-MIB", "phyServiceId"), ("LBHUB-MSH-MIB", "phyEntityState"))
if mibBuilder.loadTexts: physicalStateChange.setDescription(' A physical entity in the rack has changed state. This can be the result of a failure or recovery. The variables accompanying this trap identify the entity which has changed state.')
psuCapacityExceeded = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,33))
if mibBuilder.loadTexts: psuCapacityExceeded.setDescription(' The combination of the power requirements of all the entities in the chassis has been calculated to exceed the power capacity of the power supplies present in the chassis.')
misc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1))
mshFault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2))
tempSensorOutput = MibScalar((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warm", 2), ("danger", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorOutput.setStatus('mandatory')
if mibBuilder.loadTexts: tempSensorOutput.setDescription(' Mounted on the Management card is a temperature sensing device. This device provides three output levels : OK, WARM and DANGER.')
statusInputTable = MibTable((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2), )
if mibBuilder.loadTexts: statusInputTable.setStatus('mandatory')
if mibBuilder.loadTexts: statusInputTable.setDescription(' This table provides information about and allows configuration of the 4 general purpose inputs provided by the MSH management card. ')
statusInputTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "statusInputIndex"))
if mibBuilder.loadTexts: statusInputTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statusInputTableEntry.setDescription(' This entry describes one of the status inputs provided by the MSH management card.')
statusInputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusInputIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusInputIndex.setDescription(' Identify one of the status inputs provided by the MSH card.')
statusInputState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusInputState.setStatus('mandatory')
if mibBuilder.loadTexts: statusInputState.setDescription(" Each of the MSH management general purpose input lines is actually a pair of wires. In order to use one of the lines the two wires of a particular pair must be connected to some kind of external switch. The switch could for example be a relay or micro-switch. If the two wires of a pair are shorted together by closing the switch the value of this object will be 'closed'. If the switch is open then the value of this object is 'open'. The MSH can be configured to generate an SNMP trap if the state of this object changes.")
statusTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statusTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: statusTrapEnable.setDescription(" By setting the value of this object to enable, the MSH will monitor the value of statusInputState for changes. If a change from open to close or from close to open occurs then an SNMP trap is generated. Note that the value of the object is de-bounced by the agent to prevent multiple closures of a 'bouncing' relay causing multiple SNMP traps!")
statusName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statusName.setStatus('mandatory')
if mibBuilder.loadTexts: statusName.setDescription(" This is a writable string associated with one of the status inputs. By default the string will initialise to 'Status Input #x' where x is 1, 2, 3 or 4. The user can choose to write a more descriptive string to this object that better describes the use of a particular input. For example if input line 2 is connected to a switch which changes state when a cabinet is opened or closed then the statusName may be set to 'Door Status ' The value of this object is sent to attached management stations in the state change trap.")
chassisMgmtMACTable = MibTable((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3), )
if mibBuilder.loadTexts: chassisMgmtMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: chassisMgmtMACTable.setDescription(' The chassis management card contains an 802.3 MAC and physical layer that can be used for management traffic. In some situations this interface may be inappropriate. For example in a Token Ring only environment it is appropriate to transmit management traffic directly onto the token ring network. The MSH chassis provides the ability for the management card to use either its own MAC or to share the MAC provided by another card in the chassis. There may be a number of MACs available at any particular time from which the management card can choose. This table provides a summary of the available MACs and allows the manager to select one of those for current use. Note: The table also includes the MAC actually present on the management card!')
chassisMgmtMACEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "macSlotNumber"), (0, "LBHUB-MSH-MIB", "macIndex"))
if mibBuilder.loadTexts: chassisMgmtMACEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chassisMgmtMACEntry.setDescription(' This entry describes the abilities and the state of one of the MACs available for management use in the chassis.')
macSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: macSlotNumber.setDescription(' Index into the table. This is identifies the card on which the MAC that this conceptual row describes.')
macIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macIndex.setStatus('mandatory')
if mibBuilder.loadTexts: macIndex.setDescription(' Index into the table. This object distinguishes the MAC described by this row in the conceptual table from the potentially many MACs supported by this card.')
macBroadcastAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: macBroadcastAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: macBroadcastAvailable.setDescription(" This is an informational field. It describes the capability of the MAC represented by this conceptual row to receive and transmit a 'broadcast' packet. Note that the shared MAC is currently used to transmit and receive SNMP frames. If an attempt is made to use a MAC with insufficient capability that request will be rejected.")
macLSAPFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: macLSAPFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: macLSAPFiltering.setDescription(' This is an informational field. It describes the capability of the MAC represented by this conceptual row to directly filter packets based on the contents of the LSAP field locally to that card. This can improve performance but is not required for protocol operation. The management card will automatically make best use of this feature if present.')
macTypeFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macTypeFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: macTypeFiltering.setDescription(' This is an informational field. It describes the capability of the MAC represented by this conceptual row to directly filter packets based on type field locally to that card. The type field is held in a SNAP header in IEEE networks or in the Ethernet type field. This can improve performance but is not required for protocol operation. The management card will automatically make best use of this feature if present.')
macMaxPDUsize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macMaxPDUsize.setStatus('mandatory')
if mibBuilder.loadTexts: macMaxPDUsize.setDescription(' This is an informational field. It indicates the maximum number of data octets that can be transmitted or received using the shared MAC. When used for SNMP it is likely that a larger PDU size will increase the performance of some management operations. Note that a minimum size of 474 octets is required for SNMPv1')
macPhyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macPhyAddress.setStatus('mandatory')
if mibBuilder.loadTexts: macPhyAddress.setDescription('The physical MAC address of this specific MAC.')
macStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("available", 1), ("unavailable", 2), ("snmpMac", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: macStatus.setStatus('mandatory')
if mibBuilder.loadTexts: macStatus.setDescription(' This object is used to enable or disable a shared MAC for SNMP protocol usage. Note that if a shared MAC has insufficient capabilities to run the SNMP stack then an attempt to set the status to active will fail. This object has three values: available, unavailable and snmpMac. The meaning of each of these is: available: This MAC is currently available to run SNMP on behalf of the management card. unavailable: MAC cannot be selected to carry SNMP on behalf of the management card. The MAC may be in this state for a number of reasons. Examples are insufficient resource on the card, shared MAC already in use for something other than SNMP. snmpMac: This MAC is currently being used as the physical interface for management card SNMP traffic. To select a MAC write snmpMac to this object. If the MAC is suitable and available then the current snmpMac will become unavailable and the selected MAC will become available.')
chassisLedTable = MibTable((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 4), )
if mibBuilder.loadTexts: chassisLedTable.setStatus('mandatory')
if mibBuilder.loadTexts: chassisLedTable.setDescription('This table contains configuration information for each of the card specific LEDs on the front panel module. There is one LED for each card location.')
chassisLedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 4, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "chassisSlotNumber"))
if mibBuilder.loadTexts: chassisLedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chassisLedEntry.setDescription(' This entry describes the abilities and the state of one of the MACs available for management use in the chassis.')
chassisSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSlotNumber.setDescription('Identifies which LED this row describes. ')
chassisLedColour = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("green", 2), ("red", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisLedColour.setStatus('mandatory')
if mibBuilder.loadTexts: chassisLedColour.setDescription('Read the current colour of the LED. This is intended for use by FullView type applications.')
chassisAttentionState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("attention", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisAttentionState.setStatus('mandatory')
if mibBuilder.loadTexts: chassisAttentionState.setDescription("Writing 'attention' to this object will cause the LED above that card to become RED. This is intended to be used to aid maintenance of a large system.")
mshFaultModifiedFlag = MibScalar((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean-read", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mshFaultModifiedFlag.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultModifiedFlag.setDescription('In order to ensure a clean read of the Fault table this flag should be set to clean_read when commencing to read the table and should be examined after reading the entire table. If still set to clean_read then the table read is okay, if not the table should be re-read as it has been modified during the read process.')
mshFaultTable = MibTable((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2), )
if mibBuilder.loadTexts: mshFaultTable.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultTable.setDescription('The Fault Table.')
mshFaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mshFaultIndex"))
if mibBuilder.loadTexts: mshFaultEntry.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultEntry.setDescription('Information relating to a single fault.')
mshFaultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mshFaultIndex.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultIndex.setDescription('The index into the Fault table. The initial read from the table should be read as the next, from an index of 0; subsequent reads should read the next from the index returned by the previous read.')
mshFaultErrorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mshFaultErrorNumber.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultErrorNumber.setDescription('This error number for this fault log entry.')
mshFaultTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mshFaultTimeStamp.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultTimeStamp.setDescription('The time since startup, in milliseconds, when the fault occurred.')
mshFaultRestartCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 1, 8, 4, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mshFaultRestartCount.setStatus('deprecated')
if mibBuilder.loadTexts: mshFaultRestartCount.setDescription('The number of restarts at time of fault.')
tempStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,34)).setObjects(("LBHUB-MSH-MIB", "tempSensorOutput"))
if mibBuilder.loadTexts: tempStateChange.setDescription(' Mounted on the Management card is a temperature sensing device. This device provides three output levels : OK, WARM and DANGER. DANGER causes a trap to be generated.')
statusInputStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,35)).setObjects(("LBHUB-MSH-MIB", "statusInputState"), ("LBHUB-MSH-MIB", "statusName"))
if mibBuilder.loadTexts: statusInputStateChange.setDescription(" Sent when the state of one of the management card status inputs changes from open to close or vice-versa and the value of statusTrapEnable is 'enable'")
novell = MibIdentifier((1, 3, 6, 1, 4, 1, 23))
mibDoc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5))
ipxSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 1))
ipxCircuit = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 2))
ipxForwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 3))
ipxServices = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 4))
ipxTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 5))
ipxBasicSysTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1), )
if mibBuilder.loadTexts: ipxBasicSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysTable.setDescription('The IPX System Table - basic information.')
ipxBasicSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ipxBasicSysInstance"))
if mibBuilder.loadTexts: ipxBasicSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysEntry.setDescription('Each entry corresponds to one instance of IPX running on the system.')
ipxBasicSysInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInstance.setDescription('The unique identifier of the instance of IPX to which this row corresponds. This value may be written only when creating a new entry in the table.')
ipxBasicSysExistState = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysExistState.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysExistState.setDescription("The validity of this entry in the IPX system table. Setting this field to off indicates that this entry may be deleted from the system table at the IPX implementation's discretion.")
ipxBasicSysNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNetNumber.setDescription('The network number portion of the IPX address of this system.')
ipxBasicSysNode = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNode.setDescription('The node number portion of the IPX address of this system.')
ipxBasicSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysName.setDescription('The readable name for this system.')
ipxBasicSysInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInReceives.setDescription('The total number of IPX packets received, including those received in error.')
ipxBasicSysInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInHdrErrors.setDescription('The number of IPX packets discarded due to errors in their headers, including any IPX packets with a size less than the minimum of 30 bytes.')
ipxBasicSysInUnknownSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInUnknownSockets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInUnknownSockets.setDescription('The number of IPX packets discarded because the destination socket was not open.')
ipxBasicSysInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInDiscards.setDescription('The number of IPX packets received but discarded due to reasons other than those accounted for by ipxBasicSysInHdrErrors, ipxBasicSysInUnknownSockets, ipxAdvSysInDiscards, and ipxAdvSysInCompressDiscards.')
ipxBasicSysInBadChecksums = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInBadChecksums.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInBadChecksums.setDescription('The number of IPX packets received with incorrect checksums.')
ipxBasicSysInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInDelivers.setDescription('The total number of IPX packets delivered locally, including packets from local applications.')
ipxBasicSysNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNoRoutes.setDescription('The number of times no route to a destination was found.')
ipxBasicSysOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutRequests.setDescription('The number of IPX packets supplied locally for transmission, not including any packets counted in ipxAdvForwPackets.')
ipxBasicSysOutMalformedRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutMalformedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutMalformedRequests.setDescription('The number of IPX packets supplied locally that contained errors in their structure.')
ipxBasicSysOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutDiscards.setDescription('The number of outgoing IPX packets discarded due to reasons other than those accounted for in ipxBasicSysOutMalformedDiscards, ipxAdvSysOutFiltered, and ipxAdvSysOutCompressDiscards.')
ipxBasicSysOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutPackets.setDescription('The total number of IPX packets transmitted.')
ipxBasicSysConfigSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysConfigSockets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysConfigSockets.setDescription('The configured maximum number of IPX sockets that may be open at one time.')
ipxBasicSysOpenSocketFails = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOpenSocketFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOpenSocketFails.setDescription('The number of IPX socket open calls which failed.')
ipxAdvSysTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2), )
if mibBuilder.loadTexts: ipxAdvSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysTable.setDescription('The IPX System Table - advanced information.')
ipxAdvSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "ipxAdvSysInstance"))
if mibBuilder.loadTexts: ipxAdvSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysEntry.setDescription('Each entry corresponds to one instance of IPX running on the system.')
ipxAdvSysInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysInstance.setDescription('The unique identifer of the instance of IPX to which this row corresponds. This value may be written only when creating a new entry in the table.')
ipxAdvSysMaxPathSplits = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysMaxPathSplits.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysMaxPathSplits.setDescription('The maximum number of paths with equal routing metric value which this instance of the IPX my split between when forwarding packets.')
ipxAdvSysMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 3), Integer32().clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysMaxHops.setDescription('The maximum number of hops a packet may take.')
ipxAdvSysTooManyHops = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysTooManyHops.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysTooManyHops.setDescription('The number of IPX packets discarded due to exceeding the maximum hop count.')
ipxAdvSysInFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysInFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysInFiltered.setDescription('The number of incoming IPX packets discarded due to filtering.')
ipxAdvSysCompressDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysCompressDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysCompressDiscards.setDescription('The number of incoming IPX packets discarded due to decompression errors.')
ipxAdvSysNETBIOSPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysNETBIOSPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysNETBIOSPackets.setDescription('The number of NETBIOS packets received.')
ipxAdvSysForwPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysForwPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysForwPackets.setDescription('The number of IPX packets forwarded.')
ipxAdvSysOutFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysOutFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysOutFiltered.setDescription('The number of outgoing IPX packets discarded due to filtering.')
ipxAdvSysOutCompressDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysOutCompressDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysOutCompressDiscards.setDescription('The number of outgoing IPX packets discarded due to compression errors.')
ipxAdvSysCircCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysCircCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysCircCount.setDescription('The number of circuits known to this instance of IPX.')
ipxAdvSysDestCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysDestCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysDestCount.setDescription('The number of currently reachable destinations known to this instance of IPX.')
ipxAdvSysServCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysServCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysServCount.setDescription('The number of services known to this instance of IPX.')
resTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 1), )
if mibBuilder.loadTexts: resTable.setStatus('mandatory')
if mibBuilder.loadTexts: resTable.setDescription('')
resTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "resRepeater"), (0, "LBHUB-MSH-MIB", "resMainSlot"), (0, "LBHUB-MSH-MIB", "resMainPort"))
if mibBuilder.loadTexts: resTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resTableEntry.setDescription(" An MSH may be configured to contain a number of 'resilient pairs'. These are 802.3 point to point connections, e.g. UTP, that allow two repeaters to be connected together in a resilient configuration. In such a configuration one of the two ports is nominated the 'main' port while the other is the 'standby' port. One of these two ports is enabled and is the current active port. The other is present in case of failure of the active port. Such a failure is detected by the MSH and a switch performed. There are a couple of rules that must apply to a resilient pair definition before that definition becomes a valid resilient pair. Firstly both ports must be on the same repeater. Secondly the standby port must be configured to be 'disabled on boot'. That is it must recover from a power failure in a disabled state. This prevents loops in the network. Several tables control the resilient repeater configuration for the MSH. This is the first. This is the main table and allows the creation and deletion of pairs and provides status control and information. The information in this table is indexed on the repeater number and the slot/port location of the main port. To create a new resilient pair simply write any writeable object indexed on the main port. This will create a new entry in the table which has the state 'invalid' (read resPairState). Having created the row, write to the other parameters specifying valid information. When all the parameters are valid the resPairState will become 'operational'. In this state the pair will correctly operate as a resilient pair. If any of the attributes in the table change so that the pair in no linger valid this will be reflected in the resPortState parameter. To delete a resilient pair, write 'delete' to resPairAction.")
resRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resRepeater.setDescription(' A resilient pair must be attached to one of the repeaters in the chassis. This is part of the index value required to access this table.')
resMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resMainSlot.setDescription(' This is the second key in the index to this table. This is the slot number of the main port in this pair.')
resMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resMainPort.setDescription(' This is the final, key used to index entries in this table. It is the port number of the main port in the pair.')
resMainState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainState.setStatus('mandatory')
if mibBuilder.loadTexts: resMainState.setDescription(' Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly OK. This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the OK and Active state. OK and Active means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resStandbySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbySlot.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbySlot.setDescription(' This is the slot number of the standby port for this pair. The port must be present on the same repeater as the main port and so this information is not duplicated.')
resStandbyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbyPort.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyPort.setDescription('This is the port number of the standby port.')
resStandbyState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resStandbyState.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyState.setDescription(' Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly OK. This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the OK and Active state. OK and Active means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resPairState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("operational", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resPairState.setStatus('mandatory')
if mibBuilder.loadTexts: resPairState.setDescription(" Each row in the table is in one of two states, 'invalid' or 'operational'. If the state is 'invalid', the resilient pair represented by this row is not active. There are several reasons why this may be the case. Firstly during the row creation process, not all information necessary may have been provided. Secondly an operational pair may become invalid because the resilient pair rules are no longer met because of a change in the MSH configuration. The rules are that both main and standby ports be on the same repeater and that the standby port be 'disable on boot'. Changing the standby card, moving one of the cards to a different repeater are two possible changes that can invalidate a pair configration. If the parameters in the row are all valid then the pair becomes 'operational'.")
resPairModificationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("under-modification", 1), ("stable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairModificationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: resPairModificationStatus.setDescription(' This parameter must be set to under-modification before any changes are made to an existing configuration. Changes are not applied until this parameter is set to stable. ')
resPairAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("togglePort", 3)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: resPairAction.setStatus('mandatory')
if mibBuilder.loadTexts: resPairAction.setDescription(" This is object allows the state of a resilient pair to be modified. The create operation configures the resilient port from this table entry. The delete operation removes the resilient definitions from this table and terminates operation of resilience on this pair of ports. The togglePort operation allows the current active port to be changed to the other port. This second operation will only take affect if the state of the currently non-active port is 'OK'.")
resPairEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairEnable.setStatus('mandatory')
if mibBuilder.loadTexts: resPairEnable.setDescription(' This parameter controls whether the resilient pair is enabled or not. In the disabled state , both ports of the resilient pair are disabled. The default value of this parameter is enable ')
resStandbyMapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 2), )
if mibBuilder.loadTexts: resStandbyMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTable.setDescription('')
resStandbyMapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "resSbRepeater"), (0, "LBHUB-MSH-MIB", "resSbSlot"), (0, "LBHUB-MSH-MIB", "resSbPort"))
if mibBuilder.loadTexts: resStandbyMapTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTableEntry.setDescription(' This table is read-only. If provides shortcut information to allow for the translation of a port number to a corresponding main port number. This value can then be used to access the main resilience table. Each resilient pair has two entries in this table, one for the main port and one for the standby port. The entry for the main port returns the same port, the entry for the standby port returns the corresponding main port.')
resSbRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resSbRepeater.setDescription(' The repeater index of the port being accessed. This is the first of three indices on this table.')
resSbSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbSlot.setDescription('Second index on this table.')
resSbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbPort.setDescription('Third index on this table.')
resSbType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("standby", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbType.setStatus('mandatory')
if mibBuilder.loadTexts: resSbType.setDescription(' This attribute specifies whether the port indexed is a main or standby port in the resilient pair table. If the port is neither then there will not be a row in this table indexed for that port.')
resSbMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainSlot.setDescription(" This is the slot number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resSbMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainPort.setDescription(" This is the port number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resFlushTable = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 15, 3), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: resFlushTable.setStatus('mandatory')
if mibBuilder.loadTexts: resFlushTable.setDescription(' This parameter causes all entries in the resilience table to be flushed. Flushing the resilience table does not affect the state of any of the resilient links or ports. Once the table has been flushed , NO resilient links are configured. This parameter is used to ensure that the resilient link table is empty , before new resilient links are configured.')
resResilienceSwitch = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,43)).setObjects(("LBHUB-MSH-MIB", "resMainState"), ("LBHUB-MSH-MIB", "resStandbyState"))
if mibBuilder.loadTexts: resResilienceSwitch.setDescription(" This trap is generated when a change of state of one of the ports in a resilient pair does not result in a switch of active port. If such a switch were to occur the resResilienceSwitch would be generated. Generation of this trap is summarised in the following table: ------------------------------------------------------------------------------ State | Event Main Backup |Main Fail |Main OK |StandBy Fail |Standby OK ------------------------------------------------------------------------------ Active OK | switch | ----- | state | ----- Active Fail | state | ----- | ----- | state OK Active | state | ----- | switch | ----- Fail Active | ----- | state | state | ----- Fail Fail | ----- | switch | ----- | state ----------------------------------------------------------------------------- In this table '-----' indicates no trap is sent. 'switch' indicates the resResilienceSwitch trap is sent and 'state' indicates resStateChange is sent. NOTE: The agent in the MSH does not suppress any traps that caused the state change. For example if the active link is lost then both a 'loss-of-link' trap AND a resilienceSwitch trap are generated.")
resStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,44)).setObjects(("LBHUB-MSH-MIB", "resMainState"), ("LBHUB-MSH-MIB", "resStandbyState"))
if mibBuilder.loadTexts: resStateChange.setDescription(" This trap is generated when a change of state of one of the ports in a resilient pair does not result in a switch of active port. If such a switch were to occur the resResilienceSwitch would be generated. Generation of this trap is summarised in the following table: ------------------------------------------------------------------------------ State | Event Main Backup |Main Fail |Main OK |StandBy Fail |Standby OK ------------------------------------------------------------------------------ Active OK | switch | ----- | state | ----- Active Fail | state | ----- | ----- | state OK Active | state | ----- | switch | ----- Fail Active | ----- | state | state | ----- Fail Fail | ----- | switch | ----- | state ----------------------------------------------------------------------------- In this table '-----' indicates no trap is sent. 'switch' indicates the resResilienceSwitch trap is sent and 'state' indicates resStateChange is sent. NOTE: The agent in the MSH does not suppress any traps that caused the state change. For example if the active link is lost then both a 'loss-of-link' trap AND a resilienceSwitch trap are generated.")
a3ComRingParams = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16, 1))
a3ComRingStationParams = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16, 2))
a3ComRingConfig = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1), )
if mibBuilder.loadTexts: a3ComRingConfig.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingConfig.setDescription('This table contains information about the ring configuration, such as ring speed and wrap state.')
a3ComRingConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "a3ComRingConfigServiceId"))
if mibBuilder.loadTexts: a3ComRingConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingConfigEntry.setDescription('This row contains information about a specific ring')
a3ComRingConfigServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingConfigServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingConfigServiceId.setDescription('This parameter is used to select information about the ring from one of a number of logical devices within the same chassis. For devices that only contain a single device this index will be one (1).')
a3ComRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingNumber.setDescription('Each ring has a ring number. This is only relevant in the case of a bridged network. When there are multiple bridged token ring segments the ring number is used to determine routing information through the network. If the device knows this information then it appears in this object. If the device is an active ring parameter server then this can be used to assign ring numbers to the ring. If the device is not a ring parameter server then a write request is ignored.')
a3ComRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("s1MegaBPS", 2), ("s4MegaBPS", 3), ("s16MegaBPS", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingSpeed.setDescription("Token ring standards currently exist for 4 Mbps and 16 Mbps operation. This parameter reports the actual speed of the ring to the parent. If a device cannot determine the speed of the ring the value of this parameter will be 'unknown'.")
a3ComRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notAvailable", 1), ("normal", 2), ("beacon", 3), ("soft-error", 4), ("fault", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingState.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingState.setDescription("This object reflects the operational mode of the main ring. The ring is either in 'normal' or some error state. In this list the highest numbered error 'wins'. The meaning of the various states is as follows: beacon: This is determined by listening for beacon frames on the network. soft-error: This indicates a high rate of soft errors with respect to the amount of traffic on the ring. For this state to appear requires that the device be able to monitor this error rate. fault: This device has detected a serious ring fault. The fault may have been patched by this device looping a main ring onto a backup ring. This state is used to indicate that the ring is in error and that the topology of the ring, as reported by any station on the ring, is NOT a reliable reflection of the normal topology. If a logical device is incapable of determining the state of the ring, this parameter will have value 'notAvailable'.")
a3ComRingBackupState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notAvailable", 1), ("normal", 2), ("beacon", 3), ("soft-error", 4), ("fault", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingBackupState.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingBackupState.setDescription("This object reflects the operational mode of the backup ring. The ring is either in 'normal' or some error state. In this list the highest numbered error 'wins'. The meaning of the various states is as follows: beacon: This can be determined by listening for beacon frames on the network. soft-error: This indicates a high rate of soft errors with respect to the amount of traffic on the ring. For this state to appear requires that the device be able to monitor this error rate. fault: This device has detected a serious ring fault. The fault may have been patched by this device looping a main ring onto a backup ring. This state is used to indicate that the ring is in error and that the topology of the ring, as reported by any station on the ring, is NOT a reliable reflection of the normal topology. If a logical device is incapable of determining the state of the ring, this parameter will have value 'notAvailable'.")
a3ComRingWrapState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ringNotWrapped", 1), ("ringWrapped", 2), ("notAvailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingWrapState.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingWrapState.setDescription("This object indicates whether or not the main and backup rings are wrapped together. If the ring is wrapped it does not necessarily mean that it is wrapped at this ring builder, but may be at some other ring builder, an IBM CAU, or some other device with dual ring capabilities. If a logical device is incapable of determining whether the main and backup rings are wrapped, this parameter will have value 'notAvailable'.")
a3ComRingMapChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComRingMapChanged.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingMapChanged.setDescription("If the ring topology changes, because end stations join or leave the ring, a trap is generated and this variable is set to `true'. If the topology changes again and this variable is already true, no further trap is generated. By examining a3ComRingMapChangeTime a management station can determine when the ring has become stable for a reasonable time and then set this variable back to `false' again, after which another topology change will generate a trap.")
a3ComRingMapChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingMapChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingMapChangeTime.setDescription('This is the value of sysUpTime when the ring topology changed last, irrespective of whether or not a trap was generated.')
a3ComRingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("clearRingCounters", 2), ("clearAllCounters", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComRingAction.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingAction.setDescription('Setting this object to clearRingCounters(2) causes all the counters in this table to be reset to zero. Alternatively, clearAllcounters(3) causes all the ring station statistics (table a3ComRingStat) to be cleared as well. Setting this variable to noAction(1) has no effect. The agent will always return the value noAction(1) when this variable is read.')
a3ComRingStdStats = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2), )
if mibBuilder.loadTexts: a3ComRingStdStats.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStdStats.setDescription('This table contains an entry per ring device within the physical device supporting this MIB. Two entries may refer to the same physical ring if two logical devices are on the same ring.')
a3ComRingStdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "a3ComRingStdStatsServiceId"))
if mibBuilder.loadTexts: a3ComRingStdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStdStatsEntry.setDescription('This row contains statistics about a ring')
a3ComRingStdStatsServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStdStatsServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStdStatsServiceId.setDescription('This parameter is used to select information about the ring from one of a number of logical devices within the same chassis. For devices that only contain a single device this index will be one (1).')
a3ComRingBeaconCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingBeaconCount.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingBeaconCount.setDescription('This object counts the number of ring state transitions from normal operation to beacon mode. The higher the rate of transitions the worse the reliability of the network. A gauge can be applied to this variable to measure the reliability of the ring.')
a3ComRingSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingSoftErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingSoftErrors.setDescription('This is the total number of isolating soft errors reported by stations on the ring. If the rate of soft errors becomes high this is a good indicator of a faulty ring.')
a3ComRingActiveMonitorChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingActiveMonitorChanges.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingActiveMonitorChanges.setDescription('Every operational ring has exactly one active monitor. Due to errors it is possible that one of the standby monitors may fail to hear from the active monitor and attempt to become the active monitor itself. If this happens frequently it indicates a problem with the network. It is recommended that a local gauge be attached to this parameter to allow local monitoring of error conditions.')
a3ComRingTop = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4), )
if mibBuilder.loadTexts: a3ComRingTop.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTop.setDescription('This table contains an ordered list of addresses currently present on the token ring. The table should start from some known MAC on the managed device.')
a3ComRingTopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "a3ComRingTopServiceId"), (0, "LBHUB-MSH-MIB", "a3ComRingTopIndex"))
if mibBuilder.loadTexts: a3ComRingTopEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTopEntry.setDescription('This row contains information about a specific station currently present on the token ring.')
a3ComRingTopServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingTopServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTopServiceId.setDescription('This parameter is used to select topology information from one of a number of logical devices within the same chassis. For devices that only contain a single device this index will be one (1).')
a3ComRingTopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingTopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTopIndex.setDescription("All token ring managed devices must learn the ring topology. Each logical token device has a concept of the ring topology from it's position within the ring. For example an MSH ring builder learns the ordering of all stations on the ring in which it's local ring section resides. This object provides a unique index within the ring topology.")
a3ComRingTopStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingTopStationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTopStationAddress.setDescription('This is the physical (MAC) address for the station at this position in the ring.')
a3ComRingTopMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active-monitor", 1), ("standby-monitor", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingTopMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingTopMonitor.setDescription('Each token ring segment contains an active monitor. Any station can become the active monitor, this is determined by a special active monitor protocol. The active monitor is responsible for checking the validity of tokens and general ring house keeping. All stations that are NOT the active monitor are standby monitors. Each standby monitor checks that an active monitor is present and is ready to become the active monitor if necessary.')
a3ComRingStatConfig = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1), )
if mibBuilder.loadTexts: a3ComRingStatConfig.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatConfig.setDescription("This table contains information about the configuration of stations on the ring. Stations are identified by their MAC address and the ring service identifier. NOTE: This table includes information about stations that have at some time been on the ring. The station need not be currently present on the ring. The only time entries should be automatically discarded from this table is to cope with insufficient resource for a new station. If a new station is detected that is not currently in this table and the table has reached it's capacity then some algorithm (e.g. least recently inserted) should be employed to remove a table row.")
a3ComRingStatConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "a3ComRingStatConfigServiceId"), (0, "LBHUB-MSH-MIB", "a3ComRingStatConfigAddress"))
if mibBuilder.loadTexts: a3ComRingStatConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatConfigEntry.setDescription('This entry contains information about a specific ring station.')
a3ComRingStatConfigServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatConfigServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatConfigServiceId.setDescription('This parameter is used to select topology information from one of a number of logical devices within the same chassis. For devices that only contain a single device this index will be one (1).')
a3ComRingStatConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatConfigAddress.setDescription('This is the physical (MAC) address of this station. Information in this table is keyed on the address.')
a3ComRingStatState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatState.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatState.setDescription('This table includes information about stations that have at some time been present on the ring. A new entry is created in this table when a new station appears on the ring. If that station is subsequently removed then the entry in this table remains. This object indicates whether or not the station represented by this table entry is currently present on the ring.')
a3ComRingStatLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatLocation.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatLocation.setDescription('This is the token ring physical location parameter for the station.')
a3ComRingStatAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noAction", 1), ("removeStation", 2), ("clearCounters", 3), ("deleteEntry", 4), ("forwardTest", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComRingStatAction.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatAction.setDescription('This object allows actions to be performed either on the station or the entry in this table representing that station. Not every managed device will be capable of supporting all commands. Setting this variable to noAction(1) has no effect. The agent will always return the value noAction(1) when this variable is read. removeStation: Send a remove station request to the management station. clearCounters: All counters in this table entry are reset to zero. deleteEntry: Remove this entry from the table. This operation is only successful if the station represented by this entry is NOT currently active. forwardTest: This request causes the managed device to test the transmit and receive paths of this station. This is accomplished using the Transmit Forward MAC frame request. When the station test completes the managed device sends a test-response trap. This action only has an effect if the a3ComRingStatState is present.')
a3ComRingStatStandardStats = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2), )
if mibBuilder.loadTexts: a3ComRingStatStandardStats.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatStandardStats.setDescription("This table contains station statistics. Stations are identified by their MAC address and the ring service identifier. NOTE: This table includes information about stations that have at some time been on the ring. The station need not be currently present on the ring. The only time entries should be automatically discarded from this table is to cope with insufficient resource for a new station. If a new station is detected that is not currently in this table and the table has reached it's capacity then some algorithm (e.g. least recently inserted) should be employed to remove a table row.")
a3ComRingStatStdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "a3ComRingStatStdStatsServiceId"), (0, "LBHUB-MSH-MIB", "a3ComRingStatStdStatsAddress"))
if mibBuilder.loadTexts: a3ComRingStatStdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatStdStatsEntry.setDescription('This entry contains information about a specific ring station.')
a3ComRingStatStdStatsServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatStdStatsServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatStdStatsServiceId.setDescription('This parameter is used to select topology information from one of a number of logical devices within the same chassis. For devices that only contain a single device this index will be one (1).')
a3ComRingStatStdStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatStdStatsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatStdStatsAddress.setDescription('This is the physical (MAC) address of this station. Information in this table is keyed on the address.')
a3ComRingStatLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatLineErrors.setDescription("This object is the sum of Line Errors reported by the station. This is an Isolating error. This counter is incremented by a station when a frame or token is repeated by the station and an error bit in the frame is clear, but one of the following tests fails: A code violation occurs between the start and end of the packet; The Frame Check Sequence for a frame is incorrect. A station noticing this error sets the error bit in the packet and forwards to the next station. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatInternalErrors.setDescription("This object is incremented when a station detects a recoverable internal error. This can be used to detect a ring station that may be error prone. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatBurstErrors.setDescription("The token ring receiver portion of the station expects to see continuous signal transitions on the input. This counter is incremented if the station fails to see a transition for 5 half bit times. To prevent this error being recorded on subsequent stations the detecting station transmits idle after failing to detect a transition after 4 half bit times. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatMonitorErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatMonitorErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatMonitorErrors.setDescription("A token ring always includes an active monitor station. Periodically this station initiates an active monitor poll by sending an Active Monitor Present MAC frame. Every frame on a token ring contains an Address Recognised bit and a Frame Copied bit. These are collectively known as the AC bits. When a station processes a frame it must set either or both of these bits. A station that simply forwards a frame to the next station sets neither bit. Valid combinations of the bits are: AC Meaning 00 Frame repeated to next station. 10 The station recognised the address. That station did not however copy the frame. Generally this indicates a lack of resource in the station that recognised the address. 11 The station recognised and managed to copy the frame. These bits are used in an active monitor poll sequence. Each station obeys two rules. 1) When a standby monitor station receives an active or standby monitor present frame with the AC field set to 00 it sets the bits to 11 and starts a timer. When the timer expires it sends a standby monitor present frame. 2) When the active monitor receives any monitor present frame the active poll is considered complete. The Monitor Error counter is increased by a station if it receives either and active or standby monitor present frame with AC=00, then receives a standby monitor present frame also with AC=00. If such a situation occurs there is some error on the ring. This may only be a reconfiguration because the active monitor station has been removed from the ring. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatLostFrames.setDescription("In the token ring architecture a station that transmits a frame will eventually receive that frame after it has gone all the way around the ring. The station that sent the frame then removes that frame from the ring. Whenever a station places a frame onto the ring it starts a timer. It is expected that the frame will return to the station before that timer expires. If this does not happen then this error counter is incremented. Note that this is a non-isolating error and so it is not possible to determine where on the network the fault occurred. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatFrameCopyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatFrameCopyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatFrameCopyErrors.setDescription("Every frame on a token ring contains an Address Recognised bit and a Frame Copied bit. These are collectively known as the AC bits. When a station processes a frame it must set either or both of these bits. A station that simply forwards a frame to the next station sets neither bit. Valid combinations of the bits are: AC Meaning 00 Frame repeated to next station. 10 The station recognised the address. That station did not however copy the frame. Generally this indicates a lack of resource in the station that recognised the address. 11 The station recognised and managed to copy the frame. If a station receives a packet in which the AC bits are set to '11' and which has that station as the destination of the frame then there are probably two stations on the ring with same address. When a station detects this condition it increases the Frame Copy error counter. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and it's upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatRxCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatRxCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatRxCongestion.setDescription("A station increases this counter when it detects a packet addressed to itself but cannot copy that frame due to lack of resource. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and its upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatTokenErrors.setDescription("This counter is incremented whenever a station recognises an error condition resulting in the need to generate a token. This counter will only be incremented by an active monitor station. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and its upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatFreqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatFreqErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatFreqErrors.setDescription("This counter is incremented whenever a station detects an error in the frequency of the received signal. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and its upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingStatSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 16, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComRingStatSoftErrors.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComRingStatSoftErrors.setDescription("This counter is the total of the isolating soft error counters in the station. The total does NOT include non- isolating errors because these do not localise an error condition on the ring. GENERAL: Soft Errors The token ring architecture includes an inherent error monitoring protocol. Each station records local errors. These errors are generically referred to as 'soft errors'. Soft errors represent intermittent faults that temporarily disrupt normal operation of the ring. Stations periodically transmit their soft error counters onto the ring where they can be received by any stations which have the ring error monitor functional address active. There are two categories of soft error. Isolating errors and Non-isolating errors. An isolating error will be reported by exactly one station on the ring and the error is known to have occurred between that station and its upstream neighbour. The second category are non-isolating. That is, errors of this nature may be seen and reported by more than one ring station. With these errors it is not possible to resolve the source of the error.")
a3ComRingTopologyChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,45)).setObjects(("LBHUB-MSH-MIB", "a3ComRingMapChangeTime"))
if mibBuilder.loadTexts: a3ComRingTopologyChange.setDescription('This trap is sent when a logical device detects a change in the topology of the ring. The var-bind list identifies which of the logical devices detected the change. Note that this trap is not generated if the value of a3ComRingMapChanged is non-zero.')
a3ComRingStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,46)).setObjects(("LBHUB-MSH-MIB", "a3ComRingState"))
if mibBuilder.loadTexts: a3ComRingStateChange.setDescription('This trap is sent when the state of the main ring is seen to change. The var-bind specifies the new state of the ring.')
a3ComRingBackupStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,47)).setObjects(("LBHUB-MSH-MIB", "a3ComRingBackupState"))
if mibBuilder.loadTexts: a3ComRingBackupStateChange.setDescription('This trap is sent when the state of the backup ring is seen to change. The var-bind specifies the new state of the ring.')
a3ComRingWrapChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,48)).setObjects(("LBHUB-MSH-MIB", "a3ComRingWrapState"))
if mibBuilder.loadTexts: a3ComRingWrapChange.setDescription('This trap indicates either that the main and backup rings have wrapped, or that the wrap condition has been removed. The var-bind indicates the new state.')
mrmBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1))
mrmMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2))
mrmBasCardPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1))
mrmBasPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2))
mrmMonRepeaterPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1))
mrmMonCardPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2))
mrmMonPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3))
mrmMonDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4))
mrmCardTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1), )
if mibBuilder.loadTexts: mrmCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardTable.setDescription(' Table of descriptive and status information about the groups of ports.')
mrmCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmCardServiceId"), (0, "LBHUB-MSH-MIB", "mrmCardIndex"))
if mibBuilder.loadTexts: mrmCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardEntry.setDescription(' An entry in the table, containing information about a single group of ports.')
mrmCardServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardServiceId.setDescription(' This identifies one of the repeaters within the chassis as the target of a request.')
mrmCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardIndex.setDescription(' This object identifies the card within the repeater for which this entry contains information.')
mrmCardPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardPortCapacity.setDescription(' The mrmCardPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to mrmCardPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
mrmCardTest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noTest", 1), ("test", 2), ("testing", 3), ("passed", 4), ("failed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmCardTest.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardTest.setDescription(' An object that allows the user to test the operation of a card. Writing test(2) to this object forces the card to perform a disruptive test to determine if the card is functioning properly. Reading this object while the card is under test return the value testing(3). When the test is completed, reading this value will return either passed(4) or failed(5).')
mrmCardDOBPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardDOBPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardDOBPorts.setDescription(' MSH Repeater Cards have the ability to disable ports at power up or reset. Ports configured in this way are useful for configuring resilient links because they prevent loops in the network from occurring at startup. The disable on boot feature is determined according to a hardware strap which cannot be changed via software. This parameter is a mask containing a single bit for each port on the card. Port 1 is represented by bit 0 and so-on. If a bit representing a particular port is 0 this port boots up disabled. If the bit is a 1 the port boots up enabled. This parameter allows the state of these parameters to be rapidly determined by a network management application.')
mrmCardMDIenable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("mdiDisabled", 2), ("mdiEnabled", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardMDIenable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardMDIenable.setDescription(' 10Base-T line cards are normally configured (mdi_disabled(2)) to link to an external network device ( internal crossover ). Port 1 may be configured ( mdi_enabled(3) ) to link to another 10Base-T line card ( with no internal crossover ). This parameter allows the configuration to be determined. Note ECS line cards show unknown(1) since the configuration cannot be accessed via the management interface.')
mrmPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1), )
if mibBuilder.loadTexts: mrmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortTable.setDescription(' Table of descriptive and status information about the ports.')
mrmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmPortServiceId"), (0, "LBHUB-MSH-MIB", "mrmPortCardIndex"), (0, "LBHUB-MSH-MIB", "mrmPortIndex"))
if mibBuilder.loadTexts: mrmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortEntry.setDescription(' An entry in the table, containing information about a single port.')
mrmPortServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortServiceId.setDescription(' This object identifies the repeater which this entry contains information.')
mrmPortCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortCardIndex.setDescription(' This object identifies the group containing the port for which this entry contains information.')
mrmPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,aPortID.')
if mibBuilder.loadTexts: mrmPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortIndex.setDescription(' This object identifies the port within the group for which this entry contains information. This value can never be greater than mrmCardPortCapacity for the associated group.')
mrmPortInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("maleAUI", 2), ("femaleAUI", 3), ("thinCoax", 4), ("twistedPair", 5), ("unshieldedTP", 6), ("fiber", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortInterfaceType.setDescription(' This object specifies the type of electrical interface made available at the interface to the card for this port. The interface does not necessarily specify what the actual media to end station is.')
mrmPortConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("rj45", 2), ("telco", 3), ("st", 4), ("sma", 5), ("dtype-15", 6), ("bnc", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortConnectorType.setDescription(' This specifies the type of the physical connector through which one would attach to this card. This is distinct from the media type. For example UTP may be connected to the port via either an RJ45 or a Telco connector.')
mrmPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortAdminStatus.setDescription(" Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. In effect, when a port is disabled, the value of mrmPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the mrmPortAutoPartitionState becomes notAutoPartitioned(2), regardless of its pre-disabling state.)")
mrmPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("partitioned", 1), ("unpartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aAutoPartitionState.')
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setDescription(" The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Section 9 IEEE 802.3 Std]. They are not differentiated here.")
mrmPortLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkState.setDescription(' This object reflects the presence or absence of signal on this port. The signal may be either light in the case of fiber, or general link present in the case of copper. The value of this parameter is correct regardless of the state the admin state or the partition state.')
mrmPortBootState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortBootState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortBootState.setDescription(' A repeater port may be enabled or disabled after a reset. This parameter indicates the default for this port.')
mrmPortESTFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 127, 128))).clone(namedValues=NamedValues(("forwardMAC", 1), ("forwardIP", 2), ("forwardAll", 127), ("forwardNone", 128)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortESTFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortESTFilter.setDescription(' This attribute determines whether and which address information is extracted from packets received on a port and forwarded to the end station database. It is recommended that this attribute be disabled for inter-repeater links to prevent the database being filled with remote information. To disable this feature for all address types write the value forwardNone (128) to this variable.')
mrmPortPartitionEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortPartitionEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortPartitionEvent.setDescription('Specifies whether a trap should be sent if the port partition state changes.')
mrmPortLinkStateEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortLinkStateEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkStateEvent.setDescription('Specifies whether a trap should be sent if the link state changes.')
mrmPortSecurityAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("available", 1), ("notAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortSecurityAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortSecurityAvailable.setDescription('Specifies whether security is an available feature on this port. Only ports that have this feature available can have an entry in the repeater security table.')
mrmPortLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortLinkPulse.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkPulse.setDescription(' This attribute determines if link pulse generating and monitoring is enabled or disabled for a 10BaseT port. The attribute may take the values of enabled (standard) or disabled (non standard).')
mrmMonitorRepTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1), )
if mibBuilder.loadTexts: mrmMonitorRepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorRepTable.setDescription('Table of performance and error statistics for the ports.')
mrmMonitorRepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmMonRepServiceId"))
if mibBuilder.loadTexts: mrmMonitorRepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorRepEntry.setDescription(' This table provides statistical and control information concerning the entire repeater.')
mrmMonRepServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepServiceId.setDescription(' This parameter is used as the index in this table. A modular chassis contains potentially many repeater services. Each repeater service contains a number of cards (or groups). This parameter allows one of those repeaters to be selected.')
mrmMonRepReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepReadableFrames.setDescription(' This counter is incremented by one for each frame whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize and for which FCSError is not asserted that is received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to a unicast (non Card) address.')
mrmMonRepMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to a multicast (non broadcast) address.')
mrmMonRepBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to the broadcast address ffffffffffff.')
mrmMonRepReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepReadableOctets.setDescription(' This counter is incremented by the octet count for each readable frame received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepFCSErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAlignmentErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepFrameTooLongs.setDescription(' This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepShortEvents.setDescription(' This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepRunts.setDescription(' This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision detected by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepTxCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepTxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepTxCollisions.setDescription(' This counter is incremented by one for any CarrierEvent signal on any port of this repeater for which the CollisionEvent signal on this port is asserted. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonRepLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepLateEvents.setDescription(' This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepVeryLongEvents.setDescription(' This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepDataRateMismatches.setDescription(' This counter is incremented by one each time a packet has been received by this repeater with the data rate detectably mismatched from the local frequency. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAutoPartitions.setDescription(' This counter is incremented by one each time the repeater has automatically partitioned any port. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepTotalErrors.setDescription(' The total number of errors which have occurred on all ports on all groups of this repeater. This counter is the summation of the values of the mrmMonCardTotalErrors counters for all of the cards in the repeater. It is the sum of the following: FCS, Alignment, Frames Too Long, Short Events, Late Events, Very Long Events and Data Rate Mismatches. As a general indicator the individual error counters are too detailed. This parameter gives a very good monitor type parameter.')
mrmMonRepBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound0.setDescription(' This object is a summation of the number of frames (including error frames) with a length of 64 octets which were received by each port on every card of this repeater.')
mrmMonRepBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound1.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound2.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound3.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound4.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound5.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clearCounters", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mrmMonRepAction.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAction.setDescription(" This object allows repeater stats specific actions to be implemented. There is only one action currently defined, 'clearCounters'. Writing this value to a repeater entry will clear ALL counters in this repeater. That include port stats, card and repeater totals.")
mrmMonitorCardTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1), )
if mibBuilder.loadTexts: mrmMonitorCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorCardTable.setDescription(" This table contains parameters about the various repeater cards within the chassis. The table is indexed using the 'serviceIndex' for the repeater and the slot number within that repeater.")
mrmMonitorCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmMonCardServiceId"), (0, "LBHUB-MSH-MIB", "mrmMonCardIndex"))
if mibBuilder.loadTexts: mrmMonitorCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorCardEntry.setDescription('Status information and control variables for the ports on a single card.')
mrmMonCardServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardServiceId.setDescription(' This parameter is used as the first of two indices in this table. A modular chassis contains potentially many repeater services. Each repeater service contains a number of cards (or groups). In order to uniquely identify a port it is necessary to specify both the repeater service and the card within that repeater.')
mrmMonCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardIndex.setDescription(' This is the second part of the key on this table. Having selected one of the repeaters within the chassis it is necessary to identify the card within that repeater.')
mrmMonCardReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardReadableFrames.setDescription(' This counter is incremented by one for each frame whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize and for which FCSError is not asserted that is received for any port on this card.')
mrmMonCardUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a unicast (non Card) address.')
mrmMonCardMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a multicast (non broadcast) address.')
mrmMonCardBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to the broadcast address ffffffffffff.')
mrmMonCardReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardReadableOctets.setDescription(' This counter is incremented by the octet count for each readable frame received by any port on this card.')
mrmMonCardUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardFCSErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size.')
mrmMonCardAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardAlignmentErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size .')
mrmMonCardFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardFrameTooLongs.setDescription(' This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater.')
mrmMonCardShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardShortEvents.setDescription(' This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected.')
mrmMonCardRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardRunts.setDescription(' This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision.')
mrmMonCardLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardLateEvents.setDescription(' This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event.')
mrmMonCardVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardVeryLongEvents.setDescription(' This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time.')
mrmMonCardDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardDataRateMismatches.setDescription(' This counter is incremented by one each time a packet has been received with the data rate detectably mismatched from the local frequency.')
mrmMonCardAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardAutoPartitions.setDescription(' This counter is incremented by one each time the repeater has automatically partitioned any port.')
mrmMonCardTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardTotalErrors.setDescription(' The total number of errors which have occurred on all ports of this card. This counter is the summation of the values of other error counters (for each port), namely: FCS Errors, Alignment Errors, Frames Too Long, Short Events, Late Events, Very Long Events, Data Rate Mismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
mrmMonCardBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound0.setDescription(' This object is a summation of the number of frames (including error frames) with a length of 64 octets which were received by each port on this card.')
mrmMonCardBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound1.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received by each port on this card.')
mrmMonCardBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound2.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received by each port on this card.')
mrmMonCardBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound3.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received by each port on this card.')
mrmMonCardBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound4.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received by each port on this card.')
mrmMonCardBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound5.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received by each port on this card.')
mrmMonCardClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mrmMonCardClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardClearCounters.setDescription(' This attribute allows all counters on this Card to be cleared.')
mrmMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1), )
if mibBuilder.loadTexts: mrmMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
mrmMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "mrmMonPortServiceId"), (0, "LBHUB-MSH-MIB", "mrmMonPortCardIndex"), (0, "LBHUB-MSH-MIB", "mrmMonPortIndex"))
if mibBuilder.loadTexts: mrmMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorPortEntry.setDescription(' Performance and error statistics for a single port.')
mrmMonPortServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortServiceId.setDescription(' This parameter selects one of the repeaters within the chassis. This forms the first, most significant index column. Having selected a repeater one must select a card then port within that repeater.')
mrmMonPortCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortCardIndex.setDescription(' This attribute uniquely identifies this Card within the repeater, it is part of the index for the port table.')
mrmMonPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortIndex.setDescription(' This attribute uniquely identifies this port within the Card, it is part of the index for the port table.')
mrmMonPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortReadableFrames.setDescription(' This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a unicast (non Card) address.')
mrmMonPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a multicast (non broadcast) address.')
mrmMonPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to the broadcast address.')
mrmMonPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortReadableOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortFCSErrors.setDescription(' This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAlignmentErrors.setDescription(' This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If rptrMonitorPortAlignmentErrors is incremented then the rptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortFrameTooLongs.setDescription(' This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If this parameter is incremented then neither the alignment error nor the FCS error counters shall be incremented for the frame. The approximate minimum time for rollover of this counter is 61 days.')
mrmMonPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortShortEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortRunts.setDescription(' This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of runts may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortCollisions.setDescription(' This counter is incremented by one each time a collision is detected on this port or when the CollisionEvent signal is asserted on this port. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortLateEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. The approximate minimum time for rollover of this counter is 81 hours.')
mrmMonPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortVeryLongEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate.')
mrmMonPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortDataRateMismatches.setDescription(" This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard.")
mrmMonPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAutoPartitions.setDescription(' This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.')
mrmMonPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortTotalErrors.setDescription(' The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: FCS Errors, Alignment Errors, Frames Too Long, Short Events, Late Events, Very Long Events, Data Rate Mismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
mrmMonPortBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound0.setDescription(' This object is the number of frames (including error frames) with a length of 64 octets which were received on this port.')
mrmMonPortBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound1.setDescription(' This object is the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received on this port.')
mrmMonPortBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound2.setDescription(' This object is the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received on this port.')
mrmMonPortBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound3.setDescription(' This object is the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received on this port.')
mrmMonPortBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound4.setDescription(' This object is the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received on this port.')
mrmMonPortBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound5.setDescription(' This object is the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received on this port.')
mrmMonPortBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBandwidthUsed.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: 1) The parameter will be recalculated at approx 15 second intervals 2) Every calculation period the device will read the value of mrmMonPortReadableOctets. 3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 100/4 i=1 Sample(i) is mrmMonPortReadableOctets(i)-mrmMonPortReadableOctets(i-1) time(i) is the time between sample(i-1) and sample(i) K is the max bytes per unit time (i.e. the available bandwidth K depends on the ring speed. The value is expressed as a percentage. A default threshold exists on this average so that if a calculated average exceeds 15% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 10%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
mrmMonPortErrorsPer10000Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortErrorsPer10000Packets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortErrorsPer10000Packets.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. The value of this value is calculated locally on the agent and so does not require processor bandwidth from a management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following behaviour: 1) The parameter will be recalculated at approx 15 second intervals. 2) Every calculation period the device will read the value of mrmMonPortTotalErrors and mrmMonPortReadableFrames. 3) The calculation will be performed on the most recent 4 samples as follows: 4 10000 * Sum(Errors(i)/Frames(i)) i=1 Errors(i) = mrmMonPortTotalErrors(i)-mrmMonPortTotalErrors(i-1) Frames(i) = mrmMonPortReadableFrames(i)-mrmMonPortReadableFrames(i-1) The value is an integer number of errors per 10,000 packets received by this repeater. A default threshold exists on this average so that if a calculated average exceeds 200 (i.e. 2% of frames are in error) a trap will be sent to the management station. Further traps will not be sent until the average drops to below 100 (i.e. 1% of frames are in error). A particular device may provide a means of changing the number of samples, the averaging period and threshold if it so wishes.")
mrmMonPortClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mrmMonPortClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortClearCounters.setDescription(' This attribute allows all counters on this Port to be cleared.')
mrmMonPortLastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 32), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortLastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortLastAddress.setDescription(' This is the last MAC address seen on this port.')
mrmMonPortAddressChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAddressChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAddressChanges.setDescription(' This is a count of the number of times the MAC address on this port has changed. A high number of changes indicates this is either an inter-repeater link or a multi-drop segment.')
trafficLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficLevel.setStatus('mandatory')
if mibBuilder.loadTexts: trafficLevel.setDescription(" This is a dummy 'smart MIB' object which is used internally by the agent to provide a running average of the bandwidth in use. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortBandwidthUsed'. See 'mrmMonPortBandwidthUsed' for a description of how the bandwidth used is calculated.")
errorFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: errorFrames.setDescription(" This is a dummy 'smart MIB' object which is used internally by the agent to provide a running average of the error rate. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortErrorsPer10000Packets'. See 'mrmMonPortErrorsPer10000Packets' for a description of how the error rate is calculated.")
repPartitionStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,38)).setObjects(("LBHUB-MSH-MIB", "mrmPortAutoPartitionState"))
if mibBuilder.loadTexts: repPartitionStateChange.setDescription(' This trap is sent when the partition state of a port changes. The trap is accompanied by the new partition state of the port.')
repLinkStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,39)).setObjects(("LBHUB-MSH-MIB", "mrmPortLinkState"))
if mibBuilder.loadTexts: repLinkStateChange.setDescription(' This trap is sent when the link state of a port changes. The var-bind identifies which port has changed state and what the new state of that port is.')
repAdminStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,40)).setObjects(("LBHUB-MSH-MIB", "mrmPortAdminStatus"))
if mibBuilder.loadTexts: repAdminStateChange.setDescription(' This trap is only sent when the administration state of a port is changed by a gauge. It is not sent if a user initiates a state change via SNMP, Telnet or the V.24 terminal interface.')
repPortTopUsage = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,41)).setObjects(("LBHUB-MSH-MIB", "mrmMonPortBandwidthUsed"), ("LBHUB-MSH-MIB", "gaugeThresholdLevel"), ("LBHUB-MSH-MIB", "gaugeSamplePeriod"), ("LBHUB-MSH-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repPortTopUsage.setDescription(' This trap is sent when the port bandwidth used exceeds the defined threshold. This threshold is by default 15%, although this may have been changed on a particular device.')
repPortErrors = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,42)).setObjects(("LBHUB-MSH-MIB", "mrmMonPortErrorsPer10000Packets"), ("LBHUB-MSH-MIB", "gaugeThresholdLevel"), ("LBHUB-MSH-MIB", "gaugeSamplePeriod"), ("LBHUB-MSH-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repPortErrors.setDescription(' This trap is sent when the errors per packet exceeds the the defined threshold.')
ringBuilder = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14, 3))
ringBuilderTable = MibTable((1, 3, 6, 1, 4, 1, 43, 14, 3, 1), )
if mibBuilder.loadTexts: ringBuilderTable.setStatus('mandatory')
if mibBuilder.loadTexts: ringBuilderTable.setDescription('This table contains information about the LinkBuilder MSH Ring Builder module.')
ringBuilderTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rbServiceId"))
if mibBuilder.loadTexts: ringBuilderTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ringBuilderTableEntry.setDescription('This table contains an entry for each ring builder in a chassis.')
rbServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: rbServiceId.setDescription('This identifies one of potentially several ring builders within the chassis.')
rbRingInMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("unshieldedTp", 2), ("shieldedTp", 3), ("fiber", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbRingInMedia.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingInMedia.setDescription('This object identifies the physical media to which the Ring In port of the Ring Builder is, or could be, connected.')
rbRingInMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("openRing", 1), ("wrapRing", 2), ("failSafe", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbRingInMode.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingInMode.setDescription('Each ring builder has two external trunk connections by which a ring builder may be connected to other token ring devices capable of supporting a backup path, e.g. another ring builder. Each external connection attaches to a dual ring cable. One of the rings is used to carry traffic in a fault free network. The other ring is used as a backup. If an error should be detected on the main ring then suitable stations can wrap the active path onto the backup. The ring builder is such a device. The fault recovery is handled at the ring in and ring out ports. Each of these two connections may be placed in one of the following states: openRing (1):- This external connection is configured to be connected to the external ring. NOTE: In this mode if there is no external ring the ring will be broken. wrapRing (2):- This external connection is configured to be isolated from the remote ring such that the external ring in/out port is looped from main to backup ring. failSafe (3):- In this mode the ring builder monitors the ring in signal for a phantom voltage. If this is present then the external connection is placed into OPEN state. If the phantom voltage is not present then the external connection is placed in WRAP state. In this mode the actual state of the connection can be obtained by reading the state parameter. Note that not all devices support the generation of a phantom voltage and so the failSafe mode may not be appropriate.')
rbRingInState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("wrap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbRingInState.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingInState.setDescription('Each ring builder has two external trunk connections by which a ring builder may be connected to other token ring devices capable of supporting a backup path, e.g. another ring builder. Each external connection attaches to a dual ring cable. One of the rings is used to carry traffic in a fault free network. The other ring is used as a backup. If an error should be detected on the main ring then suitable stations can wrap the active path onto the backup. The ring builder is such a device. The fault recovery is handled at the ring in and ring out ports. Control of the external connections is via the Ring In Mode parameter. If the connection is in FAIL-SAFE mode this parameter reflects the automatically determined state of the connection. If the mode is NOT FAIL-SAFE this parameter will read the same as the mode parameter.')
rbRingOutMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("unshieldedTp", 2), ("shieldedTp", 3), ("fiber", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbRingOutMedia.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingOutMedia.setDescription('This object identifies the physical media to which the Ring Out port of the Ring Builder is, or could be, connected.')
rbRingOutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("openRing", 1), ("wrapRing", 2), ("failSafe", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbRingOutMode.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingOutMode.setDescription('Each ring builder has two external trunk connections by which a ring builder may be connected to other token ring devices capable of supporting a backup path, e.g. another ring builder. Each external connection attaches to a dual ring cable. One of the rings is used to carry traffic in a fault free network. The other ring is used as a backup. If an error should be detected on the main ring then suitable stations can wrap the active path onto the backup. The ring builder is such a device. The fault recovery is handled at the ring in and ring out ports. Each of these two connections may be placed in one of the following states: openRing (1):- This external connection is configured to be connected to the external ring. NOTE: In this mode if there is no external ring the ring will be broken. wrapRing (2):- This external connection is configured to isolated from the remote ring such that the external ring in/out port is looped from main to backup ring. failSafe (3):- In this mode the ring builder monitors the ring in signal for a phantom voltage. If this is present then the external connection is placed into OPEN state. If the phantom voltage is not present then the external connection is placed in WRAP state. In this mode the actual state of the connection can be obtained by reading the state parameter. Note that not all devices support the generation of a phantom voltage and so the FAIL-SAFE mode may not be appropriate.')
rbRingOutState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("wrap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbRingOutState.setStatus('mandatory')
if mibBuilder.loadTexts: rbRingOutState.setDescription('Each ring builder has two external trunk connections by which a ring builder may be connected to other token ring devices capable of supporting a backup path, e.g. another ring builder. Each external connection attaches to a dual ring cable. One of the rings is used to carry traffic in a fault free network. The other ring is used as a backup. If an error should be detected on the main ring then suitable stations can wrap the active path onto the backup. The ring builder is such a device. The fault recovery is handled at the ring in and ring out ports. Control of the external connections is via the Ring In Mode parameter. If the connection is in FAIL-SAFE mode this parameter reflects the automatically determined state of the connection. If the mode is NOT FAIL-SAFE this parameter will read the same as the mode parameter.')
rbMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("repeater", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbMode.setStatus('mandatory')
if mibBuilder.loadTexts: rbMode.setDescription("As well as providing control over network connection at the ring in and ring out ports, the Ringbuilder has three modes that also control the interaction with the rest of the ring. Mode normal (1):- In this mode the ringbuilder's connections are determined by the states of the Ring In and Ring Out ports. Mode repeater (2):- In this mode, the Ring In port is connected directly to the Ring Out port internally in the Ringbuilder. The external rings (main and backup) are passed straight through, while the MAUs controlled by the Ringbuilder are maintained as a stand-alone ring. In this mode, if either the Ring In or the Ring Out port is wrapped then both are forced to wrap, and the internal ring is unaffected.")
rbTest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noTest", 1), ("test", 2), ("testing", 3), ("pass", 4), ("fail", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbTest.setStatus('mandatory')
if mibBuilder.loadTexts: rbTest.setDescription('Setting this object to test(2) causes the Ringbuilder to execute a test by transmitting a frame to itself and checking that it is properly received. The test does not disrupt the operation of the ring. Initially the value of this object is noTest(1), indicating that no test has yet been performed. After a test has been requested the value read is testing(3) if a test is in progress, or pass(4) or fail(5) depending on the result of the last test executed.')
rbDRIState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("enabledWithLock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbDRIState.setStatus('mandatory')
if mibBuilder.loadTexts: rbDRIState.setDescription('Distributive Recovery Interface ( DRI ) allows the Active MAU to determine which of its stations are beaconing or causing problems on the ring. MAU ports are disabled one at a time , until the faulty station has been removed from the ring. THe MAU port remains disabled until the station is removed , unless the is enabled with locking. If DRI lock is enabled the port will remain disabled until re-enabled by management.')
ringMauPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 14, 3, 2), )
if mibBuilder.loadTexts: ringMauPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ringMauPortTable.setDescription('This table contains an entry for every port on every MAU in the local ring section controlled by the ring builder.')
ringMauPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rbMauServiceId"), (0, "LBHUB-MSH-MIB", "rbMauSlot"), (0, "LBHUB-MSH-MIB", "rbMauPort"))
if mibBuilder.loadTexts: ringMauPortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ringMauPortTableEntry.setDescription('This table contains an entry for every MAU port in the local ring section.')
rbMauServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauServiceId.setDescription('This identifies one of potentially several ring builders within the chassis.')
rbMauSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauSlot.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauSlot.setDescription('Each ring service is implemented by a ring builder and a number of MAU cards. Each MAU card provides a number of ports to which Token Ring stations connect. This object identifies the card to which this row in the table applies.')
rbMauPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauPort.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauPort.setDescription('Each MAU card contains a number of ports. A row in this table represents one of those ports. This index identifies that port.')
rbMauMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("unshieldedTp", 2), ("shieldedTp", 3), ("fiber", 4), ("twistedPair", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauMedia.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauMedia.setDescription('This object identifies the physical media to which this MAU port is, or could be, connected.')
rbMauPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbMauPortAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauPortAdminState.setDescription('Each MAU port may be enabled or disabled for insertion. Enabling a port means that if some station should attempt to insert on that port then it will be connected into the ring. Disabled means that any station currently connected into the ring on this port will be removed and that subsequent insertion requests will be denied.')
rbMauPortAttachState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauPortAttachState.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauPortAttachState.setDescription('Each MAU port is capable of determining whether a station is currently asserting phantom voltage on that port. This indicates that a station is successfully attached to the ring or whether it is attempting to attach. Note that if this object is supported then must correctly reflect the phantom voltage driven by the station regardless of the admin state of the port. Note also that if the admin state is disabled and there is a change in this object a trap is sent to the management station.')
rbMauPortZDLState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbMauPortZDLState.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauPortZDLState.setDescription('Zero Delay Lock-out(ZDL) enables the Active MAU to lock-out any station which is transmitting poor quality data , or is set to the wrong ring speed. ZDL locks out a port instantly; there is no delay before the port is disabled. If a station which has been locked out de-asserts its phantom , the port is immediately re-enabled.')
rbMauPortDisableReason = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("disabledByMgmt", 2), ("disabledByZDL", 3), ("disabledByDRI", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMauPortDisableReason.setStatus('mandatory')
if mibBuilder.loadTexts: rbMauPortDisableReason.setDescription('This item indicates the reason for disabling a port. ')
ringBuilderMACTable = MibTable((1, 3, 6, 1, 4, 1, 43, 14, 3, 3), )
if mibBuilder.loadTexts: ringBuilderMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: ringBuilderMACTable.setDescription('This is a table of the MAC address(es) assigned to the Ringbuilder card.')
ringBuilderMACTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 14, 3, 3, 1), ).setIndexNames((0, "LBHUB-MSH-MIB", "rbMACServiceId"), (0, "LBHUB-MSH-MIB", "rbMACinstance"))
if mibBuilder.loadTexts: ringBuilderMACTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ringBuilderMACTableEntry.setDescription('This table contains an entry for each MAC on each ring builder in a chassis.')
rbMACServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMACServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: rbMACServiceId.setDescription('This identifies one of potentially several ring builders within the chassis.')
rbMACinstance = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMACinstance.setStatus('mandatory')
if mibBuilder.loadTexts: rbMACinstance.setDescription('A Ringbuilder has two MACs, one for the main ring and one for the backup ring. The main ring is MAC instance 1, and the backup ring MAC instance 2.')
rbMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 14, 3, 3, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rbMACAddress.setDescription('This is the MAC address for the specified Ringbuilder and MAC instance.')
a3ComAttachStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,49)).setObjects(("LBHUB-MSH-MIB", "rbMauPortAttachState"))
if mibBuilder.loadTexts: a3ComAttachStateChange.setDescription('This trap is sent if the value of the attach state for a particular port changes AND the admin state of that port is disabled.')
rbRingInStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,50)).setObjects(("LBHUB-MSH-MIB", "rbRingInState"))
if mibBuilder.loadTexts: rbRingInStateChange.setDescription("This trap is sent if the Ring In port changes state while the mode of the port is 'fail safe'.")
rbRingOutStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,51)).setObjects(("LBHUB-MSH-MIB", "rbRingOutState"))
if mibBuilder.loadTexts: rbRingOutStateChange.setDescription("This trap is sent if the Ring Out port changes state while the mode of the port is 'fail safe'.")
rbMauPortStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,60)).setObjects(("LBHUB-MSH-MIB", "rbMauPortAdminState"), ("LBHUB-MSH-MIB", "rbMauPortDisableReason"))
if mibBuilder.loadTexts: rbMauPortStateChange.setDescription('This trap is sent if the MAU port changes state due to operation of ZDL or DRI.')
mibBuilder.exportSymbols("LBHUB-MSH-MIB", linkBuilder3GH_mib=linkBuilder3GH_mib, mrmMonRepTotalErrors=mrmMonRepTotalErrors, novell=novell, mrmMonRepRunts=mrmMonRepRunts, ipxAdvSysMaxHops=ipxAdvSysMaxHops, macIndex=macIndex, esModTableEntry=esModTableEntry, rptrMonitorPackage=rptrMonitorPackage, esModAddress=esModAddress, linkBuilderFMS_cards_utp=linkBuilderFMS_cards_utp, genericUnixServer=genericUnixServer, tcpRtoMin=tcpRtoMin, ipxBasicSysOutRequests=ipxBasicSysOutRequests, generic=generic, mrmMonPortCardIndex=mrmMonPortCardIndex, localSnmp=localSnmp, gaugeRecoveryLevel=gaugeRecoveryLevel, asciiAgent=asciiAgent, setIpIfMask=setIpIfMask, mrmMonitorRepTable=mrmMonitorRepTable, ifOutErrors=ifOutErrors, slServerIpAddress=slServerIpAddress, ipInReceives=ipInReceives, a3ComRingStatSoftErrors=a3ComRingStatSoftErrors, mrmMonCardBound1=mrmMonCardBound1, linkBuilderFMS_cards_fiber=linkBuilderFMS_cards_fiber, pollProtocol=pollProtocol, snmpOutGetNexts=snmpOutGetNexts, phyAction=phyAction, tempSensorOutput=tempSensorOutput, tcpAttemptFails=tcpAttemptFails, eventOwner=eventOwner, resStandbyState=resStandbyState, a3ComRingSpeed=a3ComRingSpeed, mrmPortTable=mrmPortTable, rptrPortIndex=rptrPortIndex, eventDescription=eventDescription, mrmMonPortBound2=mrmMonPortBound2, mrmMonCardUnicastFrames=mrmMonCardUnicastFrames, faultErrorNumber=faultErrorNumber, statusInputState=statusInputState, tempStateChange=tempStateChange, a3ComAttachStateChange=a3ComAttachStateChange, securityUserStatus=securityUserStatus, phyServiceId=phyServiceId, ipxTraps=ipxTraps, mrmMonRepBound4=mrmMonRepBound4, rptrMonitorPortIndex=rptrMonitorPortIndex, ipNetToMediaNetAddress=ipNetToMediaNetAddress, ipxBasicSysNetNumber=ipxBasicSysNetNumber, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, icmpOutAddrMaskReps=icmpOutAddrMaskReps, icmpInMsgs=icmpInMsgs, ipInUnknownProtos=ipInUnknownProtos, ipRouteAge=ipRouteAge, rptrAddrTrackGroupIndex=rptrAddrTrackGroupIndex, rbRingInStateChange=rbRingInStateChange, alarmTable=alarmTable, ipxAdvSysDestCount=ipxAdvSysDestCount, ipFragFails=ipFragFails, startResetAction=startResetAction, resTable=resTable, mrmBasPortPackage=mrmBasPortPackage, tcpRetransSegs=tcpRetransSegs, ascTimeAttemptedLogin=ascTimeAttemptedLogin, ifOutOctets=ifOutOctets, setIpIfAddr=setIpIfAddr, fcType=fcType, snmpOutTraps=snmpOutTraps, slFailed=slFailed, resSbSlot=resSbSlot, a3ComRingStatBurstErrors=a3ComRingStatBurstErrors, ipxAdvSysForwPackets=ipxAdvSysForwPackets, mrmPortServiceId=mrmPortServiceId, icmpInTimeExcds=icmpInTimeExcds, mrmMonRepBound2=mrmMonRepBound2, icmpInEchoReps=icmpInEchoReps, ifEntry=ifEntry, ifInNUcastPkts=ifInNUcastPkts, snmpInTotalReqVars=snmpInTotalReqVars, icmpInTimestampReps=icmpInTimestampReps, mrmSecPortState=mrmSecPortState, estStateChange=estStateChange, enclosureName=enclosureName, mrmBasicPackage=mrmBasicPackage, logIndex=logIndex, mrmMonPortPackage=mrmMonPortPackage, icmpOutTimestamps=icmpOutTimestamps, ipxBasicSysName=ipxBasicSysName, snmpInSetRequests=snmpInSetRequests, securityLevel=securityLevel, eventStatus=eventStatus, a3ComRingStationParams=a3ComRingStationParams, icmpInSrcQuenchs=icmpInSrcQuenchs, rptrMonitorGroupTotalFrames=rptrMonitorGroupTotalFrames, linkBuilderMSH_cards=linkBuilderMSH_cards, securityUserPassword=securityUserPassword, rptrHealth=rptrHealth, resTableEntry=resTableEntry, icmpOutTimeExcds=icmpOutTimeExcds, multiRepeater=multiRepeater, dedicatedRouteServer=dedicatedRouteServer, ascLocalManagementBanner=ascLocalManagementBanner, a3ComRingStatConfig=a3ComRingStatConfig, tcpMaxConn=tcpMaxConn, rptrMonitorPortGroupIndex=rptrMonitorPortGroupIndex, rptrMonitorPortShortEvents=rptrMonitorPortShortEvents, securityUserLevel=securityUserLevel, mrmSecBroadcastState=mrmSecBroadcastState, resSbRepeater=resSbRepeater, rptrMonitorPortInfo=rptrMonitorPortInfo, rbRingOutState=rbRingOutState, linkBuilder10BT_cards_utp=linkBuilder10BT_cards_utp, linkBuilderFMS_cards_24utp=linkBuilderFMS_cards_24utp, a3ComRingStatMonitorErrors=a3ComRingStatMonitorErrors, a3ComRingStatLineErrors=a3ComRingStatLineErrors, mrmMonRepAlignmentErrors=mrmMonRepAlignmentErrors, a3ComRingStatFreqErrors=a3ComRingStatFreqErrors, chassisLedColour=chassisLedColour, rbMauSlot=rbMauSlot, mrmMonPortIndex=mrmMonPortIndex, phyConfigTable=phyConfigTable, rpMauTable=rpMauTable, slDeviceInstance=slDeviceInstance, ecPortPortNo=ecPortPortNo, rbRingInMedia=rbRingInMedia, ipRouteDest=ipRouteDest, chassisLedTable=chassisLedTable, gaugeTableUpdate=gaugeTableUpdate, mrmSecurityTrap=mrmSecurityTrap, mrmMonRepBroadcastOctets=mrmMonRepBroadcastOctets, mrmMonCardUnicastOctets=mrmMonCardUnicastOctets, esDatabaseFlush=esDatabaseFlush, mrmMonitorPortTable=mrmMonitorPortTable, ipInDiscards=ipInDiscards, mrmMonCardClearCounters=mrmMonCardClearCounters, rbServiceId=rbServiceId, startRestartAction=startRestartAction, physicalConfig=physicalConfig, securityEnableTableEntry=securityEnableTableEntry, mshFaultEntry=mshFaultEntry, eventTable=eventTable, pollAlarmIndex=pollAlarmIndex, serviceName=serviceName, cards=cards, at=at, ifIndex=ifIndex, phyLimits=phyLimits, a3ComRingConfigServiceId=a3ComRingConfigServiceId, mrmSecMulticastState=mrmSecMulticastState, pollTableFailedTrap=pollTableFailedTrap, phySysObjId=phySysObjId, mrmCardEntry=mrmCardEntry, slServerProtocol=slServerProtocol, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, ipRouteMetric1=ipRouteMetric1, snmpOutNoSuchNames=snmpOutNoSuchNames, snmpOutGetResponses=snmpOutGetResponses, mrmMonitorPortEntry=mrmMonitorPortEntry, a3ComRingStatConfigServiceId=a3ComRingStatConfigServiceId, rptrOperStatus=rptrOperStatus, ipNetToMediaTable=ipNetToMediaTable, alarm=alarm, esTableEntry=esTableEntry, ipxBasicSysNoRoutes=ipxBasicSysNoRoutes, alarmStartupAlarm=alarmStartupAlarm, gaugeRecoveryAction=gaugeRecoveryAction, rbMauPortStateChange=rbMauPortStateChange, ifPhysAddress=ifPhysAddress, linkBuilder3GH=linkBuilder3GH, rpMauGroupIndex=rpMauGroupIndex, ringBuilderMACTable=ringBuilderMACTable, egp=egp, logEntry=logEntry, esModAddrType=esModAddrType, snmpDot3RptrMgt=snmpDot3RptrMgt, mrmStationLearnTrap=mrmStationLearnTrap, ipxBasicSysInDiscards=ipxBasicSysInDiscards, resPairState=resPairState, mrmMonRepBound5=mrmMonRepBound5, rptrMonitorGroupTable=rptrMonitorGroupTable, phyFacilityChanged=phyFacilityChanged, enclosureHardwareVers=enclosureHardwareVers, mrmMonPortAlignmentErrors=mrmMonPortAlignmentErrors, ipxBasicSysInDelivers=ipxBasicSysInDelivers, securityAuditResult=securityAuditResult, rpMauBasicGroup=rpMauBasicGroup, a3ComRingStatFrameCopyErrors=a3ComRingStatFrameCopyErrors, ifInOctets=ifInOctets, linkBuilderECS=linkBuilderECS, ipxSystem=ipxSystem, resStandbyMapTableEntry=resStandbyMapTableEntry, configV24AutoConfig=configV24AutoConfig, macBroadcastAvailable=macBroadcastAvailable, logicalConfig=logicalConfig, mrmMonCardReadableFrames=mrmMonCardReadableFrames, mrmMonPortBound0=mrmMonPortBound0, ipxBasicSysEntry=ipxBasicSysEntry, rpMauPortIndex=rpMauPortIndex, serviceReset=serviceReset, rptrPortAutoPartitionState=rptrPortAutoPartitionState, a3Com=a3Com, ipxBasicSysExistState=ipxBasicSysExistState, trapDestination=trapDestination, icmpOutMsgs=icmpOutMsgs, snmpInBadCommunityUses=snmpInBadCommunityUses, snmpEnableAuthenTraps=snmpEnableAuthenTraps, a3ComRingStatConfigAddress=a3ComRingStatConfigAddress, linkBuilderTP8i_cards_8tp_rj45=linkBuilderTP8i_cards_8tp_rj45, rpMauAdminState=rpMauAdminState, securityTermEnable=securityTermEnable, capture=capture, configV24Entry=configV24Entry, snmpOutGetRequests=snmpOutGetRequests, mgmtAddressType=mgmtAddressType, gaugeTableEntry=gaugeTableEntry, snmpInASNParseErrs=snmpInASNParseErrs, phyServiceType=phyServiceType, ipNetToMediaType=ipNetToMediaType, snmpInGetNexts=snmpInGetNexts, rptrAddrTrackPackage=rptrAddrTrackPackage, setupGeneral=setupGeneral, phyConfigEntry=phyConfigEntry, alarmFallingEventIndex=alarmFallingEventIndex, mrmSecPortIndex=mrmSecPortIndex, mrmMonitorPackage=mrmMonitorPackage, ipAdEntAddr=ipAdEntAddr, mrmMonRepLateEvents=mrmMonRepLateEvents, mrmCardServiceId=mrmCardServiceId, mrmMonPortMulticastOctets=mrmMonPortMulticastOctets, ipAddrTable=ipAddrTable, gaugeSamplesPerAverage=gaugeSamplesPerAverage, tcpOutSegs=tcpOutSegs, ifOutUcastPkts=ifOutUcastPkts, rptrMonitorPortReadableFrames=rptrMonitorPortReadableFrames, alarmRisingEventIndex=alarmRisingEventIndex, mrmMonRepBound3=mrmMonRepBound3, siSlipPort=siSlipPort, linkBuilderMSH=linkBuilderMSH, psuCapacityExceeded=psuCapacityExceeded, mrmPortIndex=mrmPortIndex, mrmMonCardBound4=mrmMonCardBound4, mrmMonPortLastAddress=mrmMonPortLastAddress, rptrMonitorPortCollisions=rptrMonitorPortCollisions, securityUserName=securityUserName, linkSwitch_mib=linkSwitch_mib, rptrGroupObjectID=rptrGroupObjectID, phyPowerReq=phyPowerReq, estTableFull=estTableFull, a3ComRingStateChange=a3ComRingStateChange, rbMauPortDisableReason=rbMauPortDisableReason, pollTableEntry=pollTableEntry, hub=hub, snmpInBadCommunityNames=snmpInBadCommunityNames)
mibBuilder.exportSymbols("LBHUB-MSH-MIB", dot1dBridge=dot1dBridge, mrmMonCardReadableOctets=mrmMonCardReadableOctets, mrmMonCardAutoPartitions=mrmMonCardAutoPartitions, tcpCurrEstab=tcpCurrEstab, gaugeSamplePeriod=gaugeSamplePeriod, ifInUnknownProtos=ifInUnknownProtos, logDescription=logDescription, rptrReset=rptrReset, pollRate=pollRate, rptrAddrTrackEntry=rptrAddrTrackEntry, eventEntry=eventEntry, mrmMonPortUnicastOctets=mrmMonPortUnicastOctets, udpInDatagrams=udpInDatagrams, logTime=logTime, chassis=chassis, ipxAdvSysOutFiltered=ipxAdvSysOutFiltered, linkBuilderFMS_cards_12fiber=linkBuilderFMS_cards_12fiber, snmpInGenErrs=snmpInGenErrs, repPortErrors=repPortErrors, serialIf=serialIf, rptrMonitorGroupTotalErrors=rptrMonitorGroupTotalErrors, mshFaultTimeStamp=mshFaultTimeStamp, chassisSlotNumber=chassisSlotNumber, resSbMainSlot=resSbMainSlot, slLoadStatus=slLoadStatus, gaugeState=gaugeState, rptrAddrTrackPortIndex=rptrAddrTrackPortIndex, systemConfigChangeTime=systemConfigChangeTime, localManagementUpdate=localManagementUpdate, serviceEntityRemoved=serviceEntityRemoved, linkBuilderFMSII_cards_6fiber_st=linkBuilderFMSII_cards_6fiber_st, enclosureObjId=enclosureObjId, genericMSServer=genericMSServer, alarmSampleType=alarmSampleType, phyLimLimit=phyLimLimit, terminalServer=terminalServer, gaugeConfigureColumn=gaugeConfigureColumn, securityAuditLogTable=securityAuditLogTable, icmpOutDestUnreachs=icmpOutDestUnreachs, a3ComRingConfig=a3ComRingConfig, mrmMonCardRunts=mrmMonCardRunts, mrmPortSecurityAvailable=mrmPortSecurityAvailable, udpLocalAddress=udpLocalAddress, ipReasmReqds=ipReasmReqds, configV24Speed=configV24Speed, linkBuilderFMS=linkBuilderFMS, loadableDeviceTable=loadableDeviceTable, interfaces=interfaces, mrmSecRepIndex=mrmSecRepIndex, mrmSecLearnMode=mrmSecLearnMode, mrmMonRepFCSErrors=mrmMonRepFCSErrors, tcpOutRsts=tcpOutRsts, brouter=brouter, mrmMonCardBound5=mrmMonCardBound5, DisplayString=DisplayString, alarmOwner=alarmOwner, configV24Update=configV24Update, ringBuilder=ringBuilder, trapStatus=trapStatus, mrmSecSlotIndex=mrmSecSlotIndex, gaugeIndex=gaugeIndex, setupStart=setupStart, manager=manager, configV24FlowControl=configV24FlowControl, esPortAccessEntry=esPortAccessEntry, snmpOutBadValues=snmpOutBadValues, faultEntry=faultEntry, mshFaultRestartCount=mshFaultRestartCount, snmpTrapDestination=snmpTrapDestination, configV24DCDControl=configV24DCDControl, repPartitionStateChange=repPartitionStateChange, a3ComRingTopEntry=a3ComRingTopEntry, mrmMonRepUnicastFrames=mrmMonRepUnicastFrames, a3ComRingTop=a3ComRingTop, statusInputStateChange=statusInputStateChange, tcpConnRemAddress=tcpConnRemAddress, a3ComRingStdStatsEntry=a3ComRingStdStatsEntry, facilityEntry=facilityEntry, fcSlotNumber=fcSlotNumber, rptrAddrTrackSourceAddrChanges=rptrAddrTrackSourceAddrChanges, resStandbySlot=resStandbySlot, linkBuilderFMSII_cards=linkBuilderFMSII_cards, rbRingInState=rbRingInState, specificTrap=specificTrap, mrmSecurePortTable=mrmSecurePortTable, ipxBasicSysInBadChecksums=ipxBasicSysInBadChecksums, mrmMonPortAutoPartitions=mrmMonPortAutoPartitions, macPhyAddress=macPhyAddress, a3ComRingBackupState=a3ComRingBackupState, ipxAdvSysOutCompressDiscards=ipxAdvSysOutCompressDiscards, fault=fault, icmpOutParmProbs=icmpOutParmProbs, tcpConnTable=tcpConnTable, logEventIndex=logEventIndex, mrmPortCardIndex=mrmPortCardIndex, ecPortAddrType=ecPortAddrType, mrmMonRepFrameTooLongs=mrmMonRepFrameTooLongs, mrmCardIndex=mrmCardIndex, serviceEntry=serviceEntry, a3ComRingStatInternalErrors=a3ComRingStatInternalErrors, rbMauServiceId=rbMauServiceId, ipAdEntIfIndex=ipAdEntIfIndex, ipxBasicSysOutMalformedRequests=ipxBasicSysOutMalformedRequests, sysLocation=sysLocation, mrmMonPortBound3=mrmMonPortBound3, ipAdEntNetMask=ipAdEntNetMask, udpLocalPort=udpLocalPort, rptrMonitorPortAlignmentErrors=rptrMonitorPortAlignmentErrors, rptrMonitorGroupIndex=rptrMonitorGroupIndex, ifMtu=ifMtu, mrmMonPortDataRateMismatches=mrmMonPortDataRateMismatches, rptrGroupIndex=rptrGroupIndex, macStatus=macStatus, mrmPortAutoPartitionState=mrmPortAutoPartitionState, rptrPortInfo=rptrPortInfo, ipNetToMediaPhysAddress=ipNetToMediaPhysAddress, addressTable=addressTable, resPairAction=resPairAction, ifOutQLen=ifOutQLen, rpMauMediaAvailable=rpMauMediaAvailable, loadableDeviceEntry=loadableDeviceEntry, ipxBasicSysTable=ipxBasicSysTable, eventCommunity=eventCommunity, a3ComRingStdStatsServiceId=a3ComRingStdStatsServiceId, misc=misc, mrmPortAdminStatus=mrmPortAdminStatus, ipAdEntBcastAddr=ipAdEntBcastAddr, configV24PortID=configV24PortID, tcpRtoAlgorithm=tcpRtoAlgorithm, mrmMonRepAction=mrmMonRepAction, rptrMonitorPortEntry=rptrMonitorPortEntry, rptrPortOperStatus=rptrPortOperStatus, ifOutDiscards=ifOutDiscards, ipRouteMetric5=ipRouteMetric5, tcpPassiveOpens=tcpPassiveOpens, snmpInGetRequests=snmpInGetRequests, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, snmpInBadValues=snmpInBadValues, a3ComRingStatLostFrames=a3ComRingStatLostFrames, rptrMonitorRptrInfo=rptrMonitorRptrInfo, repLinkStateChange=repLinkStateChange, ringBuilderTable=ringBuilderTable, snmpInTraps=snmpInTraps, linkBuilderFMSII_cards_12fiber_st=linkBuilderFMSII_cards_12fiber_st, snmpInTotalSetVars=snmpInTotalSetVars, mrmPortLinkPulse=mrmPortLinkPulse, startLastRestartType=startLastRestartType, mrmMonCardDataRateMismatches=mrmMonCardDataRateMismatches, linkBuilderFDDI_wghub_mib=linkBuilderFDDI_wghub_mib, rbMauPortZDLState=rbMauPortZDLState, pollLastPollSent=pollLastPollSent, pollTable=pollTable, ifSpecific=ifSpecific, rbRingInMode=rbRingInMode, icmpOutErrors=icmpOutErrors, esPortNumber=esPortNumber, ipRouteMetric2=ipRouteMetric2, phyLimLocationType=phyLimLocationType, ipxAdvSysCompressDiscards=ipxAdvSysCompressDiscards, linkBuilderFMS_cards_coax=linkBuilderFMS_cards_coax, udpInErrors=udpInErrors, mrmMonitorRepEntry=mrmMonitorRepEntry, ifTable=ifTable, ipOutDiscards=ipOutDiscards, bridgeMgmt=bridgeMgmt, snmpTrapRowStatus=snmpTrapRowStatus, mrmMonCardBound3=mrmMonCardBound3, gaugeItemId=gaugeItemId, ringMauPortTableEntry=ringMauPortTableEntry, gaugeConfigureObjId=gaugeConfigureObjId, ipFragCreates=ipFragCreates, esDatabaseState=esDatabaseState, icmpOutEchos=icmpOutEchos, icmpOutEchoReps=icmpOutEchoReps, pollInformation=pollInformation, macSlotNumber=macSlotNumber, ipxAdvSysServCount=ipxAdvSysServCount, mrmCardTest=mrmCardTest, rptrAddrTrackLastSourceAddress=rptrAddrTrackLastSourceAddress, securityAuditIndex=securityAuditIndex, ipxBasicSysOutDiscards=ipxBasicSysOutDiscards, rbMauMedia=rbMauMedia, resSbType=resSbType, rptrGroupOperStatus=rptrGroupOperStatus, hostTopN=hostTopN, ascLoginStatus=ascLoginStatus, sysServices=sysServices, resPairModificationStatus=resPairModificationStatus, ipxCircuit=ipxCircuit, mrmPortPartitionEvent=mrmPortPartitionEvent, snmpOutSetRequests=snmpOutSetRequests, rpMauJabbers=rpMauJabbers, a3ComRingAction=a3ComRingAction, rpMauLostMedias=rpMauLostMedias, filter=filter, snmpOutGenErrs=snmpOutGenErrs, heartbeatEvent=heartbeatEvent, trapCategory=trapCategory, statistics=statistics, icmpInEchos=icmpInEchos, configV24DSRControl=configV24DSRControl, ipForwDatagrams=ipForwDatagrams, tcpInErrs=tcpInErrs, snmp=snmp, system=system, mrmMonRepReadableOctets=mrmMonRepReadableOctets, mrmCardDOBPorts=mrmCardDOBPorts, esAddrType=esAddrType, mgmtAddress=mgmtAddress, ipOutNoRoutes=ipOutNoRoutes, alarmVariable=alarmVariable, ipxBasicSysOpenSocketFails=ipxBasicSysOpenSocketFails, tcpConnState=tcpConnState, mrmMonRepReadableFrames=mrmMonRepReadableFrames, mrmMonCardVeryLongEvents=mrmMonCardVeryLongEvents, securityFrontPanelEnable=securityFrontPanelEnable, event=event, mrmMonCardBroadcastOctets=mrmMonCardBroadcastOctets, udp=udp, trafficLevel=trafficLevel, macLSAPFiltering=macLSAPFiltering, resRepeater=resRepeater, mshFaultIndex=mshFaultIndex, gauges=gauges, logTable=logTable, udpOutDatagrams=udpOutDatagrams, ipRouteMetric3=ipRouteMetric3, snmpInReadOnlys=snmpInReadOnlys, ipRouteEntry=ipRouteEntry, a3ComRingBackupStateChange=a3ComRingBackupStateChange, a3ComRingState=a3ComRingState, setIpIfEntry=setIpIfEntry, phyHwVersion=phyHwVersion, snmpTrapCommunity=snmpTrapCommunity, fcFacilityIndex=fcFacilityIndex, statusTrapEnable=statusTrapEnable, ipxForwarding=ipxForwarding, a3ComRingActiveMonitorChanges=a3ComRingActiveMonitorChanges, rpMauJabberState=rpMauJabberState, icmpInDestUnreachs=icmpInDestUnreachs, linkBuilderFMSLBridge=linkBuilderFMSLBridge, rbMauPortAttachState=rbMauPortAttachState, serviceId=serviceId, rbMACinstance=rbMACinstance, resStandbyMapTable=resStandbyMapTable, gaugeValue=gaugeValue, deskMan_mib=deskMan_mib, sysUpTime=sysUpTime, rptrMonitorPortRunts=rptrMonitorPortRunts, rbMauPort=rbMauPort, linkBuilderFMS_mib=linkBuilderFMS_mib, ipReasmFails=ipReasmFails, mrmMonPortBound1=mrmMonPortBound1, a3ComRingStatRxCongestion=a3ComRingStatRxCongestion)
mibBuilder.exportSymbols("LBHUB-MSH-MIB", ipInAddrErrors=ipInAddrErrors, linkSwitchFMS=linkSwitchFMS, tcpConnEntry=tcpConnEntry, genericMSWorkstation=genericMSWorkstation, pollIndex=pollIndex, resResilienceSwitch=resResilienceSwitch, eventLastTimeSent=eventLastTimeSent, chipsets=chipsets, unusedGeneric12=unusedGeneric12, serviceEntityAdded=serviceEntityAdded, enclosure=enclosure, esTable=esTable, endStation=endStation, resSbMainPort=resSbMainPort, icmpOutRedirects=icmpOutRedirects, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, ipRouteMask=ipRouteMask, a3ComRingMapChangeTime=a3ComRingMapChangeTime, mrmMonCardBound2=mrmMonCardBound2, mrmMonRepBound1=mrmMonRepBound1, rbMode=rbMode, ipRouteNextHop=ipRouteNextHop, mrmCardPortCapacity=mrmCardPortCapacity, ipInHdrErrors=ipInHdrErrors, ipxAdvSysTooManyHops=ipxAdvSysTooManyHops, a3ComRingStatStandardStats=a3ComRingStatStandardStats, ifOperStatus=ifOperStatus, tcpInSegs=tcpInSegs, ipxBasicSysOutPackets=ipxBasicSysOutPackets, sysDescr=sysDescr, icmpInAddrMaskReps=icmpInAddrMaskReps, ifInDiscards=ifInDiscards, phySwVersion=phySwVersion, statusName=statusName, slLoad=slLoad, securityAuditTime=securityAuditTime, ipxAdvSysInstance=ipxAdvSysInstance, sysName=sysName, mrmMonRepVeryLongEvents=mrmMonRepVeryLongEvents, sysObjectID=sysObjectID, linkBuilderFMSII=linkBuilderFMSII, ifSpeed=ifSpeed, gaugeConfigureValue=gaugeConfigureValue, rmon=rmon, snmpTrapCategory=snmpTrapCategory, rptrGroupDescr=rptrGroupDescr, a3ComRingStatTokenErrors=a3ComRingStatTokenErrors, a3ComRingTopMonitor=a3ComRingTopMonitor, a3ComRingTopServiceId=a3ComRingTopServiceId, trapEntry=trapEntry, setIpIfIndex=setIpIfIndex, trapCommunity=trapCommunity, ringMauPortTable=ringMauPortTable, pollOwner=pollOwner, trapTable=trapTable, statusInputIndex=statusInputIndex, snmpTrapNextFreeIndex=snmpTrapNextFreeIndex, tokenRing=tokenRing, ifDescr=ifDescr, rptrGroupChange=rptrGroupChange, a3ComRingStatConfigEntry=a3ComRingStatConfigEntry, ipxAdvSysNETBIOSPackets=ipxAdvSysNETBIOSPackets, resMainPort=resMainPort, esModPortNumber=esModPortNumber, dedicatedBridgeServer=dedicatedBridgeServer, mrmMonPortBandwidthUsed=mrmMonPortBandwidthUsed, rbMACAddress=rbMACAddress, testData=testData, matrix=matrix, gaugePeakValue=gaugePeakValue, alarmValue=alarmValue, gaugesThresholdTrap=gaugesThresholdTrap, sysContact=sysContact, rptrGroupPortCapacity=rptrGroupPortCapacity, statusInputTableEntry=statusInputTableEntry, icmpOutAddrMasks=icmpOutAddrMasks, ipRouteType=ipRouteType, rbMACServiceId=rbMACServiceId, ipRouteTable=ipRouteTable, linkBuilderTP8i_cards=linkBuilderTP8i_cards, linkBuilderFMSII_cards_10coax_bnc=linkBuilderFMSII_cards_10coax_bnc, powerSupply=powerSupply, ecPortCardNo=ecPortCardNo, icmpOutSrcQuenchs=icmpOutSrcQuenchs, slSoftwareVersion=slSoftwareVersion, configV24Table=configV24Table, ipForwarding=ipForwarding, trapThrottle=trapThrottle, mrmMonRepBroadcastFrames=mrmMonRepBroadcastFrames, products=products, transmission=transmission, rptrBasicPackage=rptrBasicPackage, startPROMSwVerNo=startPROMSwVerNo, a3ComRingStatAction=a3ComRingStatAction, a3ComRingStatLocation=a3ComRingStatLocation, risingAlarm=risingAlarm, genericTrap=genericTrap, rpMauType=rpMauType, linkBuilderFddiWorkGroupHub=linkBuilderFddiWorkGroupHub, alarmFallingThreshold=alarmFallingThreshold, eventIndex=eventIndex, ipRouteInfo=ipRouteInfo, ecPortIndex=ecPortIndex, a3ComRingStatStdStatsAddress=a3ComRingStatStdStatsAddress, mrmBasCardPackage=mrmBasCardPackage, linkBuilderMSH_mib=linkBuilderMSH_mib, mrmMonRepShortEvents=mrmMonRepShortEvents, rbRingOutStateChange=rbRingOutStateChange, ipRouteMetric4=ipRouteMetric4, startRestartCount=startRestartCount, linkBuilder10BTi_mib=linkBuilder10BTi_mib, securityUserTable=securityUserTable, mrmSecReportMode=mrmSecReportMode, phyLimitEntry=phyLimitEntry, linkSwitchMSH=linkSwitchMSH, resFlushTable=resFlushTable, mrmPortBootState=mrmPortBootState, mrmMonCardServiceId=mrmMonCardServiceId, udpTable=udpTable, resStandbyPort=resStandbyPort, chassisMgmtMACEntry=chassisMgmtMACEntry, tcp=tcp, snmpTrapTable=snmpTrapTable, repeaterMgmt=repeaterMgmt, alarmEntry=alarmEntry, tcpConnRemPort=tcpConnRemPort, ipxBasicSysNode=ipxBasicSysNode, mrmMonPortBound5=mrmMonPortBound5, rbRingOutMode=rbRingOutMode, mrmMonPortAddressChanges=mrmMonPortAddressChanges, PhysAddress=PhysAddress, esAddress=esAddress, a3ComRingBeaconCount=a3ComRingBeaconCount, mrmMonCardBound0=mrmMonCardBound0, securityAuditValue=securityAuditValue, mrmMonPortServiceId=mrmMonPortServiceId, mgmtSubIndex=mgmtSubIndex, tcpEstabResets=tcpEstabResets, phyLocationType=phyLocationType, mrmPortInterfaceType=mrmPortInterfaceType, phyEntityState=phyEntityState, snmpInNoSuchNames=snmpInNoSuchNames, linkBuilderECS_cards=linkBuilderECS_cards, mrmMonPortClearCounters=mrmMonPortClearCounters, icmpInTimestamps=icmpInTimestamps, mrmMonCardFCSErrors=mrmMonCardFCSErrors, a3ComRingTopIndex=a3ComRingTopIndex, ifInErrors=ifInErrors, alarmIndex=alarmIndex, netBuilder_mib=netBuilder_mib, rptrMonitorGroupInfo=rptrMonitorGroupInfo, ipxAdvSysCircCount=ipxAdvSysCircCount, gaugeItemType=gaugeItemType, mrmMonCardFrameTooLongs=mrmMonCardFrameTooLongs, fcConnection=fcConnection, chassisAttentionState=chassisAttentionState, mrmMonPortLateEvents=mrmMonPortLateEvents, ifExtensions=ifExtensions, rptrPortGroupIndex=rptrPortGroupIndex, faultRestartCount=faultRestartCount, faultTable=faultTable, ipOutRequests=ipOutRequests, slHardwareVersion=slHardwareVersion, mrmMonPortMulticastFrames=mrmMonPortMulticastFrames, securityUserCommunity=securityUserCommunity, linkBuilderFMS_cards=linkBuilderFMS_cards, gaugesRecoveryTrap=gaugesRecoveryTrap, snmpInGetResponses=snmpInGetResponses, snmpInTooBigs=snmpInTooBigs, gaugeRecoveryLevelScaler=gaugeRecoveryLevelScaler, configV24Parity=configV24Parity, startLastSystemError=startLastSystemError, ipxServices=ipxServices, configV24ConnType=configV24ConnType, mrmMonPortFrameTooLongs=mrmMonPortFrameTooLongs, mrmResilience=mrmResilience, ifType=ifType, rptrMonitorPortLateEvents=rptrMonitorPortLateEvents, mrmPortEntry=mrmPortEntry, securityUserLocParty=securityUserLocParty, gaugeTable=gaugeTable, phyLocation=phyLocation, tcpActiveOpens=tcpActiveOpens, mrmMonPortErrorsPer10000Packets=mrmMonPortErrorsPer10000Packets, setup=setup, securityUserMgrParty=securityUserMgrParty, rptrMonitorGroupEntry=rptrMonitorGroupEntry, phyLampTest=phyLampTest, mrmMonCardAlignmentErrors=mrmMonCardAlignmentErrors, gaugeOwner=gaugeOwner, ifOutNUcastPkts=ifOutNUcastPkts, gaugeNextFreeIndex=gaugeNextFreeIndex, a3ComRingMapChanged=a3ComRingMapChanged, mrmCardMDIenable=mrmCardMDIenable, mrmMonRepMulticastOctets=mrmMonRepMulticastOctets, mrmMonPortTotalErrors=mrmMonPortTotalErrors, eventType=eventType, a3ComRingConfigEntry=a3ComRingConfigEntry, ipRouteIfIndex=ipRouteIfIndex, phyEntityType=phyEntityType, pollTargetType=pollTargetType, ipxAdvSysTable=ipxAdvSysTable, pollNextFreeIndex=pollNextFreeIndex, configV24StopBits=configV24StopBits, ecPortAddress=ecPortAddress, mrmMonRepServiceId=mrmMonRepServiceId, ipRoutingDiscards=ipRoutingDiscards, esModTable=esModTable, ipxBasicSysInUnknownSockets=ipxBasicSysInUnknownSockets, rptrPortTable=rptrPortTable, rptrMonitorPortDataRateMismatches=rptrMonitorPortDataRateMismatches, mrmMonRepUnicastOctets=mrmMonRepUnicastOctets, mrmMonitorCardEntry=mrmMonitorCardEntry, mrmMonCardBroadcastFrames=mrmMonCardBroadcastFrames, ifInUcastPkts=ifInUcastPkts, mrmMonPortVeryLongEvents=mrmMonPortVeryLongEvents, slFilename=slFilename, esPortAccessTable=esPortAccessTable, mgmtServiceId=mgmtServiceId, mrmMonRepTxCollisions=mrmMonRepTxCollisions, pollAddress=pollAddress, mrmPortLinkStateEvent=mrmPortLinkStateEvent, ipx=ipx, pollRowStatus=pollRowStatus, a3ComRingStdStats=a3ComRingStdStats, tcpRtoMax=tcpRtoMax, mrmMonRepBound0=mrmMonRepBound0, ipxBasicSysInHdrErrors=ipxBasicSysInHdrErrors, setIpIfRouter=setIpIfRouter, mib_2=mib_2, udpNoPorts=udpNoPorts, tcpConnLocalPort=tcpConnLocalPort, snmpOutPkts=snmpOutPkts, icmp=icmp, rptrMonitorPortAutoPartitions=rptrMonitorPortAutoPartitions, macTypeFiltering=macTypeFiltering, esSlotNumber=esSlotNumber, faultModifiedFlag=faultModifiedFlag, securityAuditObject=securityAuditObject, ipxAdvSysInFiltered=ipxAdvSysInFiltered, setupIp=setupIp, phyEntityName=phyEntityName, ringBuilderMACTableEntry=ringBuilderMACTableEntry, mrmMonCardMulticastFrames=mrmMonCardMulticastFrames, mrmSecMACAddress=mrmSecMACAddress, facilityTable=facilityTable, mrmPortConnectorType=mrmPortConnectorType, slServerAddress=slServerAddress, rptrPortEntry=rptrPortEntry, ipReasmOKs=ipReasmOKs, a3C512=a3C512, frontPanelDisplayMessage=frontPanelDisplayMessage, faultTimeStamp=faultTimeStamp, ipxBasicSysInstance=ipxBasicSysInstance)
mibBuilder.exportSymbols("LBHUB-MSH-MIB", mrmMonCardShortEvents=mrmMonCardShortEvents, alarmRisingThreshold=alarmRisingThreshold, mrmMonRepAutoPartitions=mrmMonRepAutoPartitions, rbRingOutMedia=rbRingOutMedia, mrmMonRepMulticastFrames=mrmMonRepMulticastFrames, statusInputTable=statusInputTable, mrmCardTable=mrmCardTable, rptrMonitorGroupTotalOctets=rptrMonitorGroupTotalOctets, lBridgeECS_mib=lBridgeECS_mib, rptrGroupLastOperStatusChange=rptrGroupLastOperStatusChange, linkBuilder10BTi_cards=linkBuilder10BTi_cards, icmpInErrors=icmpInErrors, mrmSecurePortEntry=mrmSecurePortEntry, fallingAlarm=fallingAlarm, icmpInParmProbs=icmpInParmProbs, setIpIfTable=setIpIfTable, rptrAddrTrackTable=rptrAddrTrackTable, mrmMonPortCollisions=mrmMonPortCollisions, ifAdminStatus=ifAdminStatus, rpMauEntry=rpMauEntry, rptrPortAdminStatus=rptrPortAdminStatus, poll=poll, amp_mib=amp_mib, ipInDelivers=ipInDelivers, rptrMonitorPortVeryLongEvents=rptrMonitorPortVeryLongEvents, mshFaultModifiedFlag=mshFaultModifiedFlag, resPairEnable=resPairEnable, rptrMonitorPortFrameTooLongs=rptrMonitorPortFrameTooLongs, heartbeatInterval=heartbeatInterval, mrmMonCardMulticastOctets=mrmMonCardMulticastOctets, linkBuilderECS_mib=linkBuilderECS_mib, linkBuilder10BTi=linkBuilder10BTi, snmpTrapThrottle=snmpTrapThrottle, history=history, resSbPort=resSbPort, pollRoundTripTime=pollRoundTripTime, udpEntry=udpEntry, rptrHealthText=rptrHealthText, a3ComRingTopStationAddress=a3ComRingTopStationAddress, a3ComRingTopologyChange=a3ComRingTopologyChange, mrmMonCardPackage=mrmMonCardPackage, mrmMonPortFCSErrors=mrmMonPortFCSErrors, ipDefaultTTL=ipDefaultTTL, linkBuilderFMSII_cards_12tp_rj45=linkBuilderFMSII_cards_12tp_rj45, tcpConnLocalAddress=tcpConnLocalAddress, securitySecureEnable=securitySecureEnable, snmpInBadVersions=snmpInBadVersions, gaugeThresholdLevel=gaugeThresholdLevel, rptrMonitorPortFCSErrors=rptrMonitorPortFCSErrors, mrmMonCardTotalErrors=mrmMonCardTotalErrors, ipRouteProto=ipRouteProto, mshFaultTable=mshFaultTable, linkBuilderFMSII_cards_24tp_rj45=linkBuilderFMSII_cards_24tp_rj45, ipNetToMediaIfIndex=ipNetToMediaIfIndex, a3ComRingStatState=a3ComRingStatState, securityUserTableEntry=securityUserTableEntry, hosts=hosts, faultIndex=faultIndex, a3ComRingStatStdStatsEntry=a3ComRingStatStdStatsEntry, linkBuilderFMSII_cards_24tp_telco=linkBuilderFMSII_cards_24tp_telco, mrmSecRowStatus=mrmSecRowStatus, mibDoc=mibDoc, linkBuilder3GH_cards=linkBuilder3GH_cards, mrmMonRepeaterPackage=mrmMonRepeaterPackage, icmpInAddrMasks=icmpInAddrMasks, esModSlotNumber=esModSlotNumber, mrmMonRepDataRateMismatches=mrmMonRepDataRateMismatches, pollTableSuccessTrap=pollTableSuccessTrap, mrmSecurityPackage=mrmSecurityPackage, ringBuilderTableEntry=ringBuilderTableEntry, mrmMonitorCardTable=mrmMonitorCardTable, repAdminStateChange=repAdminStateChange, alarmStatus=alarmStatus, macMaxPDUsize=macMaxPDUsize, a3ComRingNumber=a3ComRingNumber, snmpTrapEntry=snmpTrapEntry, rptrMonitorPortTotalErrors=rptrMonitorPortTotalErrors, ipxAdvSysMaxPathSplits=ipxAdvSysMaxPathSplits, securityCommunityEnable=securityCommunityEnable, physicalStateChange=physicalStateChange, resMainState=resMainState, mrmMonPortBroadcastOctets=mrmMonPortBroadcastOctets, rptrGroupTable=rptrGroupTable, mrmMonDummyPackage=mrmMonDummyPackage, ifLastChange=ifLastChange, rptrGroupEntry=rptrGroupEntry, serviceTable=serviceTable, snmpOutTooBigs=snmpOutTooBigs, gaugeThresholdLevelScaler=gaugeThresholdLevelScaler, resMainSlot=resMainSlot, mrmMonPortReadableFrames=mrmMonPortReadableFrames, rbTest=rbTest, rbMauPortAdminState=rbMauPortAdminState, slDeviceType=slDeviceType, securityViolation=securityViolation, mshFault=mshFault, rbDRIState=rbDRIState, ipAdEntReasmMaxSize=ipAdEntReasmMaxSize, snmpDot3RpMauMgt=snmpDot3RpMauMgt, snmpTrapIndex=snmpTrapIndex, mrmMonPortShortEvents=mrmMonPortShortEvents, linkBuilder10BTi_cards_utp=linkBuilder10BTi_cards_utp, linkBuilderTP8i=linkBuilderTP8i, rptrMonitorPortReadableOctets=rptrMonitorPortReadableOctets, a3ComRingSoftErrors=a3ComRingSoftErrors, ipReasmTimeout=ipReasmTimeout, rptrMonitorTransmitCollisions=rptrMonitorTransmitCollisions, sysLoader=sysLoader, mrmMonPortRunts=mrmMonPortRunts, gaugeThresholdAction=gaugeThresholdAction, ifNumber=ifNumber, mrmMonPortUnicastFrames=mrmMonPortUnicastFrames, securityAuditLogEntry=securityAuditLogEntry, rptrRptrInfo=rptrRptrInfo, securityTelnetEnable=securityTelnetEnable, ipxBasicSysConfigSockets=ipxBasicSysConfigSockets, mrmMonPortReadableOctets=mrmMonPortReadableOctets, phyEntityInserted=phyEntityInserted, configV24CharSize=configV24CharSize, viewBuilderApps=viewBuilderApps, ascUserNameForLastAttemptedLogin=ascUserNameForLastAttemptedLogin, ipAddrEntry=ipAddrEntry, ipFragOKs=ipFragOKs, phyNumberOfPorts=phyNumberOfPorts, snmpTrapProtocol=snmpTrapProtocol, mrmMonPortBound4=mrmMonPortBound4, snmpInPkts=snmpInPkts, securityAuditUser=securityAuditUser, resStateChange=resStateChange, mrmPortESTFilter=mrmPortESTFilter, icmpOutTimestampReps=icmpOutTimestampReps, a3ComRingWrapChange=a3ComRingWrapChange, securityEnableTable=securityEnableTable, mrmSecNTKState=mrmSecNTKState, rptrMonitorPortTable=rptrMonitorPortTable, a3ComRingStatStdStatsServiceId=a3ComRingStatStdStatsServiceId, genExperimental=genExperimental, ipxAdvSysEntry=ipxAdvSysEntry, ipNetToMediaEntry=ipNetToMediaEntry, addressTableEntry=addressTableEntry, repPortTopUsage=repPortTopUsage, trapSubject=trapSubject, ip=ip, mrmPortLinkState=mrmPortLinkState, mrmMonCardIndex=mrmMonCardIndex, errorFrames=errorFrames, security=security, mshFaultErrorNumber=mshFaultErrorNumber, rptrNonDisruptTest=rptrNonDisruptTest, alarmInterval=alarmInterval, icmpInRedirects=icmpInRedirects, gaugeTableSize=gaugeTableSize, rptrGroupCapacity=rptrGroupCapacity, chassisMgmtMACTable=chassisMgmtMACTable, rpMauIndex=rpMauIndex, phyEntityRemoved=phyEntityRemoved, rptrGroupInfo=rptrGroupInfo, ipxBasicSysInReceives=ipxBasicSysInReceives, a3ComRingWrapState=a3ComRingWrapState, mrmMonPortBroadcastFrames=mrmMonPortBroadcastFrames, chassisLedEntry=chassisLedEntry, mrmMonCardLateEvents=mrmMonCardLateEvents, a3ComRingParams=a3ComRingParams)

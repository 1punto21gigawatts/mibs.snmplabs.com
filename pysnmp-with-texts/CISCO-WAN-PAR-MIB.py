#
# PySNMP MIB module CISCO-WAN-PAR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-PAR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
par, = mibBuilder.importSymbols("BASIS-MIB", "par")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ObjectIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, NotificationType, Unsigned32, Gauge32, IpAddress, Bits, MibIdentifier, Counter32, ModuleIdentity, Counter64, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "NotificationType", "Unsigned32", "Gauge32", "IpAddress", "Bits", "MibIdentifier", "Counter32", "ModuleIdentity", "Counter64", "TimeTicks")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
ciscoWanParMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 63))
ciscoWanParMIB.setRevisions(('2002-09-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanParMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanParMIB.setLastUpdated('200209100000Z')
if mibBuilder.loadTexts: ciscoWanParMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanParMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanParMIB.setDescription('The MIB module for configuring AutoRoute controller. The Portable AutoRoute(PAR) is a Controller providing routing capabilities in Network of Cisco MGX and BPX Switches. PAR controller performs following functions: - Connection Provisioning. Adding/Deleting/modifying connections - Connection Alarm Management. On receipt of a failure event, PAR sends messages to condition the connection. - Annex G functionality. Manages the LMI communication between feeder and routing node. - Clocking Control. PAR handles the clocking selection for the switch.')
parSelfNode = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 1))
parInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 2))
parConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 3))
parNetworkClock = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 4))
parConfigParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5))
parVsiConfigParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 1))
parCmParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 2))
parMnUpdt = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 3))
parSwFunc = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 4))
parOnOff = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 5))
parSysParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 6))
parNetworkingParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 7))
parSnNodeId = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 223)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeId.setStatus('current')
if mibBuilder.loadTexts: parSnNodeId.setDescription(' This object specifies the node number of the node. When the network manager tries to modify the value of this object, a message is sent node state machine which propagates this information and the value gets modified only if the new node number is successfully propagated. The node number uniquely identifies a routing node in a network.')
parSnNodeIP = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeIP.setStatus('current')
if mibBuilder.loadTexts: parSnNodeIP.setDescription('This object specifies the IP address for routing node and is used for communication with SNMP manager(for example Cisco Wan Manager:CWM).')
parSnNodeName = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeName.setStatus('current')
if mibBuilder.loadTexts: parSnNodeName.setDescription('This object specifies the name of the node and is unique among all the nodes in the network. Whenever the name of the node is changed, AutoRoute has to propagate the information to the other nodes in the network. It also specifies the name of a PAR Feeder node.')
parSnRevision = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnRevision.setStatus('current')
if mibBuilder.loadTexts: parSnRevision.setDescription('This object specifies the primary revision of the PAR running on the node. Format: cc.c.cc Where: c = one ascii character')
parSnNodeAlarmStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("unreach", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnNodeAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: parSnNodeAlarmStatus.setDescription('This object specifies the type of alarm on the node. clear(1) : No Alarm minor(2) : Minor Alarm major(3) : Major Alarm unreach(4) : Node is unreachable.')
parSnNumberOfTrunks = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnNumberOfTrunks.setStatus('current')
if mibBuilder.loadTexts: parSnNumberOfTrunks.setDescription('This object specifies the number of trunks attached to the node.')
parIfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 1), )
if mibBuilder.loadTexts: parIfTable.setStatus('current')
if mibBuilder.loadTexts: parIfTable.setDescription('Table of all logical interfaces supported by PAR')
parIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-PAR-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parIfEntry.setStatus('current')
if mibBuilder.loadTexts: parIfEntry.setDescription('Entries for logical interfaces.')
parIfLogicalInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLogicalInterface.setStatus('current')
if mibBuilder.loadTexts: parIfLogicalInterface.setDescription('This object specifies the logical interface number.')
parIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("userport", 1), ("routingtrunk", 2), ("feedertrunk", 3), ("clkport", 4), ("virtualtrunk", 5))).clone('userport')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parIfType.setStatus('current')
if mibBuilder.loadTexts: parIfType.setDescription('This object specifies the type of interface. User ports need to be UNI interface. The trunks can be either UNI or NNI. userport(1) : UNI interface. This is for user ports. routingtrunk(2) : NNI interface. This value can be set provided there are no connections on the interface. feedertrunk(3) : It is feeder trunk. clkport(4) : Clock port. virtualtrunk(5): Virtual Trunk. Type of interface can be changed from nni(2) to uni(1) if the trunk is not added.')
parIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("added", 2), ("failed", 3), ("added-failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: parIfOperStatus.setDescription('This object specifies the operation status of the interface. up(1) : Interface is up. This value is applicable for UNI as well as NNI interfaces. added(2) : Interface is added. This value is applicable for NNI interfaces. failed(3) : Interface is failed. This value is applicable for UNI as well as NNI interfaces. added-failed (4) : Interface is failed. This value is applicable for NNI interfaces. interfaces.')
parIfTxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 4), Integer32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfTxBw.setStatus('current')
if mibBuilder.loadTexts: parIfTxBw.setDescription('This object specifies the transmit bandwidth for the interface.')
parIfRxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 5), Integer32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfRxBw.setStatus('current')
if mibBuilder.loadTexts: parIfRxBw.setDescription('This object specifies the receive bandwidth for the interface.')
parIfMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfMaxConn.setStatus('current')
if mibBuilder.loadTexts: parIfMaxConn.setDescription('This object specifies the maximum number of connections that can be configured over the interface.')
parIfHiAddrMin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfHiAddrMin.setStatus('current')
if mibBuilder.loadTexts: parIfHiAddrMin.setDescription('This object specifies the minimum VPI that PAR can use for configuring connection in the interface.')
parIfHiAddrMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfHiAddrMax.setStatus('current')
if mibBuilder.loadTexts: parIfHiAddrMax.setDescription('This object specifies the maximum VPI that PAR can use for configuring connection in the interface.')
parIfLoAddrMin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLoAddrMin.setStatus('current')
if mibBuilder.loadTexts: parIfLoAddrMin.setDescription('This object specifies the minimum VCI that PAR can use for configuring connection in the interface.')
parIfLoAddrMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLoAddrMax.setStatus('current')
if mibBuilder.loadTexts: parIfLoAddrMax.setDescription('This object specifies the maximum VCI that PAR can use for configuring connection in the interface.')
parTrkTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 2), )
if mibBuilder.loadTexts: parTrkTable.setStatus('current')
if mibBuilder.loadTexts: parTrkTable.setDescription('The table containing trunk parameters.')
parTrkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1), ).setIndexNames((0, "CISCO-WAN-PAR-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parTrkEntry.setStatus('current')
if mibBuilder.loadTexts: parTrkEntry.setDescription('Entries for logical interfaces configured as trunks (parIfType nni).')
parTrkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkId.setStatus('current')
if mibBuilder.loadTexts: parTrkId.setDescription('This object specifies the logical trunk number associated with the trunk at the local node.')
parTrkStatReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 2), Integer32().clone(1000)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkStatReserve.setStatus('current')
if mibBuilder.loadTexts: parTrkStatReserve.setDescription('Specifies the bandwidth reserved as Statistical Reserve on the trunk in units of cells per second. This object cannot take a value beyond the bandwidth capacity of the trunk.')
parTrkCnfgCcRestrict = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgCcRestrict.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgCcRestrict.setDescription('This object specifies the operators preference for routing control plane traffic on the interface. If the object is set to False, then the interface may be chosen for control plane traffic. If it is True, then the interface is not chosen, unless there is no other trunk with parIfOperStatus added(2), in which case it is chosen regardless of the value of this object.')
parTrkCnfgLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("terrestrial", 1), ("satellite", 2))).clone('terrestrial')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgLineType.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgLineType.setDescription('This object specifies the type of interface terrestrial or satellite. The interfaces configured as terrestrial(1) are preferred over those configured as satellite(2) for routing control plane traffic. This information is also used for connections for which routing restrictions are specified.')
parTrkCnfgPassSync = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgPassSync.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgPassSync.setDescription('This object specifies whether the trunk can be used to pass clock sync. If the value of this object is True, clock can be synchronized through the trunk; otherwise not.')
parTrkCnfgDerouteDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 6), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgDerouteDelay.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgDerouteDelay.setDescription('This object specifies the value of deroute delay timer in seconds.')
parTrkCnfgTrafficClassFst = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFst.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFst.setDescription('This object indicates whether Foresight traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgTrafficClassFr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFr.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFr.setDescription('This object indicates whether Frame Relay traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgTrafficClassNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassNts.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassNts.setDescription('This object indicates whether Non-Time Stamped traffic can be routed over the trunk. If the value is true(1) it can be rerouted otherwise not.')
parTrkCnfgTrafficClassTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 10), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassTs.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassTs.setDescription('This object indicates whether Time Stamped traffic can be routed over the trunk. If the value is true(1) it can be rerouted otherwise not.')
parTrkCnfgTrafficClassVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVoice.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVoice.setDescription('This object indicates whether Voice traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgTrafficClassCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 12), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassCbr.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassCbr.setDescription('This object indicates whether Constant Bit Rate traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgTrafficClassVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVbr.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVbr.setDescription('This object indicates whether Variable Bit Rate traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgTrafficClassAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 14), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassAbr.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassAbr.setDescription('This object indicates whether Available Bit Rate traffic can be routed over the trunk. If the value is true(1), it can be rerouted otherwise not.')
parTrkCnfgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("add", 1), ("delete", 2))).clone('delete')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgAdminStatus.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgAdminStatus.setDescription('This object can be used to add or delete the trunk. The value of this object can be set to add(1) only if the parIfOperStatus is up(1). The value can be set to delete if parIfOperStatus is added or added-failed')
parTrkCnfgRoutingCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgRoutingCost.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgRoutingCost.setDescription('This object specifies the cost associated with the trunk for the purpose of routing the connections. This object has significance if cost based routing feature is enabled(parCmParmsCostBased)')
parTrkCnfgVccConids = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgVccConids.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgVccConids.setDescription('The maximum number of routing resource available on the trunk for VCC connections.')
parTrkCnfgVpcConids = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgVpcConids.setStatus('current')
if mibBuilder.loadTexts: parTrkCnfgVpcConids.setDescription('The maximum number of routing resource available on the trunk for VPC connections')
parTrkLocalSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalSlotNumber.setStatus('current')
if mibBuilder.loadTexts: parTrkLocalSlotNumber.setDescription('This object specifies the slot number of the interface card associated with the trunk at the local node.')
parTrkLocalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalPortNumber.setStatus('current')
if mibBuilder.loadTexts: parTrkLocalPortNumber.setDescription('This object specifies the port number of the interface card associated with the trunk at the local node.')
parTrkLocalVTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalVTrunkId.setStatus('current')
if mibBuilder.loadTexts: parTrkLocalVTrunkId.setDescription('This object specifies the Virtual trunk of the interface card associated with the trunk at the local node. The value of this object is between 1 and 254, inclusive for a virtual trunk and 255 for a physical trunk.')
parTrkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 223))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteNodeId.setDescription('This object specifies the node number of the node attached to the remote end of the trunk.')
parTrkRemoteTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteTrunkId.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteTrunkId.setDescription('This object specifies the logical trunk number at the node on the remote end of the trunk.')
parTrkRemoteSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteSlotNumber.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteSlotNumber.setDescription('This object specifies the slot number of the interface card to which the trunk is attached on the remote node.')
parTrkRemotePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemotePortNumber.setStatus('current')
if mibBuilder.loadTexts: parTrkRemotePortNumber.setDescription('This object specifies the port number of the interface card to which the trunk is attached on the remote node.')
parTrkRemoteVTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteVTrunkId.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteVTrunkId.setDescription('This object specifies the Virtual trunk of the interface card associated with the trunk at the remote node. The value of this object is between 1 and 254, inclusive for a virtual trunk and 255 for a physical trunk.')
parTrkRemoteNodeIP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 27), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeIP.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteNodeIP.setDescription('This object specifies the IP address for the Remote node, used for communication with NMS')
parTrkRemoteNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ipx", 1), ("igx", 2), ("bpx", 3), ("par", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeType.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteNodeType.setDescription('Specifies the type of the node.')
parTrkRemoteNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 29), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeName.setStatus('current')
if mibBuilder.loadTexts: parTrkRemoteNodeName.setDescription('This object specifies the name of the remote node and is unique among all the nodes in the network.')
parTrkAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: parTrkAlarmStatus.setDescription('This object specifies the severity of the alarm on the trunk. clear(1) : No Alarm minor(2) : Minor Alarm major(3) : Major Alarm.')
parTrkAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("rsrcunavail", 1), ("commfail", 2), ("unknown", 3), ("failed", 4), ("looped", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkAlarmType.setStatus('current')
if mibBuilder.loadTexts: parTrkAlarmType.setDescription('This object specifies the type of alarm on the trunk. The value of this object has no significance if parTrunkAlarmStatus indicates no alarm. rsrcunavail(1) : resources unavailable indicates that the platform has not provided the resources required to make this interface into a trunk. commfail(2) : communication failure indicates that message exchanged between neighboring nodes on this trunk has failed. unknown (3) : indicates that the alarm type is unknown to PAR, for example if the platform has declared the interface in alarm due to some physical problem with the interface.')
parTrkBwCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkBwCapacity.setStatus('current')
if mibBuilder.loadTexts: parTrkBwCapacity.setDescription('Specifies the bandwidth capacity of the trunk.')
parTrkLineLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLineLoad.setStatus('current')
if mibBuilder.loadTexts: parTrkLineLoad.setDescription('Specifies the bandwidth used by the connections routed over the trunk.')
parTrkLoadTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 3), )
if mibBuilder.loadTexts: parTrkLoadTable.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadTable.setDescription('Trunk Load Information')
parTrkLoadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1), ).setIndexNames((0, "CISCO-WAN-PAR-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parTrkLoadEntry.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadEntry.setDescription('Load info for logical interfaces configured as trunks (parIfType nni).')
parTrkLoadXmtUsedCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedCbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedCbr.setDescription('This object specifies the used bandwidth in the transmit direction for CBR traffic.')
parTrkLoadRcvUsedCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedCbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedCbr.setDescription('This object specifies the used bandwidth in the receive direction for CBR traffic')
parTrkLoadXmtUsedVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedVbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedVbr.setDescription('This object specifies the used bandwidth in the transmit direction for VBR traffic.')
parTrkLoadRcvUsedVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedVbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedVbr.setDescription('This object specifies the used bandwidth in the receive direction for VBR traffic.')
parTrkLoadXmtUsedAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedAbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedAbr.setDescription('This object specifies the used bandwidth in the transmit direction for ABR.')
parTrkLoadRcvUsedAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedAbr.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedAbr.setDescription('This object specifies the used bandwidth in the receive direction for ABR.')
parTrkLoadXmtUsedNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedNts.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedNts.setDescription('This object specifies the used bandwidth in the transmit direction for Non-Time Stamped.')
parTrkLoadRcvUsedNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedNts.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedNts.setDescription('This object specifies the used bandwidth in the receive direction for Non-Time Stamped.')
parTrkLoadXmtUsedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedTs.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedTs.setDescription('This object specifies the used bandwidth in the transmit direction for Time-Stamped.')
parTrkLoadRcvUsedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedTs.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedTs.setDescription('This object specifies the used bandwidth in the receive direction for Time-Stamped.')
parTrkLoadXmtUsedVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedVoice.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedVoice.setDescription('This object specifies the used bandwidth in the transmit direction for Voice.')
parTrkLoadRcvUsedVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedVoice.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedVoice.setDescription('This object specifies the used bandwidth in the receive direction for Voice.')
parTrkLoadXmtUsedBdataA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataA.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataA.setDescription('This object specifies the used bandwidth in the transmit direction for Busty Data A.')
parTrkLoadRcvUsedBdataA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataA.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataA.setDescription('This object specifies the used bandwidth in the receive direction for Bursty Data A.')
parTrkLoadXmtUsedBdataB = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataB.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataB.setDescription('This object specifies the used bandwidth in the transmit direction for Bursty Data B.')
parTrkLoadRcvUsedBdataB = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataB.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataB.setDescription('This object specifies the used bandwidth in the receive direction for Bursty Data B.')
parTrkLoadVccConidsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadVccConidsUsed.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadVccConidsUsed.setDescription('This object specifies the number of conids used for VCCs (not used) on the trunk.')
parTrkLoadVpcConidsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadVpcConidsUsed.setStatus('current')
if mibBuilder.loadTexts: parTrkLoadVpcConidsUsed.setDescription('This object specifies the number of conids Used for VPCs (not used) on the trunk.')
parConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 3, 1), )
if mibBuilder.loadTexts: parConnectionTable.setStatus('current')
if mibBuilder.loadTexts: parConnectionTable.setDescription('This table contains connections Mastered or slaved by the node.')
parConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-PAR-MIB", "parConnLocalSlot"), (0, "CISCO-WAN-PAR-MIB", "parConnLocalPort"), (0, "CISCO-WAN-PAR-MIB", "parConnLocalVpi"), (0, "CISCO-WAN-PAR-MIB", "parConnLocalVci"))
if mibBuilder.loadTexts: parConnectionEntry.setStatus('current')
if mibBuilder.loadTexts: parConnectionEntry.setDescription('Entries for connections mastered or slaved by the node. Each entry contains Local and remote end information.')
parConnLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalSlot.setStatus('current')
if mibBuilder.loadTexts: parConnLocalSlot.setDescription('This object specifies the slot number part of the local endpoint connection address.')
parConnLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalPort.setStatus('current')
if mibBuilder.loadTexts: parConnLocalPort.setDescription('This object specifies the port number part of the local endpoint connection address.')
parConnLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVpi.setStatus('current')
if mibBuilder.loadTexts: parConnLocalVpi.setDescription('This object specifies the Virtual Path Identifier part of the local endpoint connection address.')
parConnLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVci.setStatus('current')
if mibBuilder.loadTexts: parConnLocalVci.setDescription('This object specifies the Virtual Channel Identifier part of the local endpoint connection address.')
parConnMasterShip = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnMasterShip.setStatus('current')
if mibBuilder.loadTexts: parConnMasterShip.setDescription('This object specifies whether this end of the connection is the master or the slave of the connection. The value true(1) signifies the master end and false(2) signifies slave end.')
parConnLocalVcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVcIndx.setStatus('current')
if mibBuilder.loadTexts: parConnLocalVcIndx.setDescription('This object specifies the Virtual Connection Index at this node. It is used by Network Management to correlate this end of the connection with the remote end.')
parConnLocalEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalEndpt.setStatus('current')
if mibBuilder.loadTexts: parConnLocalEndpt.setDescription('This object specifies the actual physical connection endpoint at the local node.')
parConnRemoteNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteNodeName.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteNodeName.setDescription('This object specifies the node name of the remote endpoint. For a intra-switch connection or feeder connection this object would specify the self node name.')
parConnRemoteSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteSlot.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteSlot.setDescription('This object specifies the slot number part of the remote endpoint connection address.')
parConnRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemotePort.setStatus('current')
if mibBuilder.loadTexts: parConnRemotePort.setDescription('This object specifies the port number part of the remote endpoint connection address.')
parConnRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteVpi.setDescription('This object specifies the VPI part of the remote endpoint connection address.')
parConnRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVci.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteVci.setDescription('This object specifies the VCI part of the remote endpoint connection address.')
parConnRemoteVcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVcIndx.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteVcIndx.setDescription('This object specifies the Virtual Connection Index at the remote node. It is used by Network Management to correlate this end of the connection with the remote end..')
parConnOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("routed", 1), ("unrouted", 2), ("lmifail", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnOperStatus.setStatus('current')
if mibBuilder.loadTexts: parConnOperStatus.setDescription('This object specifies the status of connection as known and determined by PAR. The status shall be OK if there is an A-bit alarm on the connection.')
parConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("down", 1), ("up", 2), ("reroute", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parConnAdminStatus.setStatus('current')
if mibBuilder.loadTexts: parConnAdminStatus.setDescription("This object is used by the operator to reroute or down/up a connection. The value of this object is up(1) when the connection is created. If the value of the object is set to down(1) the connection is derouted (if it is routed) and parConnOperStatus object is set to not routed. If the value of the object is up (2) and it is set to reroute(3) the connection is derouted and attempt is made to reroute the connection. If the value of the object is down (1) and the it is set to reroute (3), no action is performed and the object's value does not changes. If the value of object is down(1) and is set to up(2), an attempt is made to reroute the connection.")
parConnRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRoute.setStatus('current')
if mibBuilder.loadTexts: parConnRoute.setDescription('This object specifies the current path on which the connection is routed. A value of this object is valid only if parConnOperStatus is routed. The Null string specifies that the connection is not routed. Format: Nodename {Trk--Trk Nodename} Where: Nodename = up to 8 characters, Trk = slot.port.vtrk, slot = 1 or 2 characters, port = 1 or two characters, and vtrk = 1 or two characters and is optional. The portion of the format shown in braces {like this} can be repeated up to 10 times.')
parConnRemoteEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteEndpt.setStatus('current')
if mibBuilder.loadTexts: parConnRemoteEndpt.setDescription('This object specifies the actual physical connection endpoint at the remote end of the connection. It shall be known only if the connection is a local(DAX) connection.')
parPrefRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parPrefRoute.setStatus('current')
if mibBuilder.loadTexts: parPrefRoute.setDescription('This object specifies the preferred path for the connection. The Null string specifies that the connection does not have a preferred route. Format: Nodename {Trk--Trk Nodename} Where: Nodename = up to 8 characters, Trk = slot.port.vtrk, slot = 1 or 2 characters, port = 1 or two characters, and vtrk = 1 or two characters and is optional. The portion of the format shown in braces {like this} can be repeated up to 10 times.')
parConnFailRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 1), ("hwalm", 2), ("abitalm", 3), ("lmifail", 4), ("rrtfail", 5), ("incomplete", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnFailRsn.setStatus('current')
if mibBuilder.loadTexts: parConnFailRsn.setDescription('This object specifies a reason code for the failure of the connection.')
parRrtFailRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parRrtFailRsn.setStatus('current')
if mibBuilder.loadTexts: parRrtFailRsn.setDescription('This object specifies the Reason of failure of a connection to route.')
parConnRstrTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("norestrict", 1), ("terrestrict", 2), ("satrestrict", 3), ("undefrestrict", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRstrTyp.setStatus('current')
if mibBuilder.loadTexts: parConnRstrTyp.setDescription('This object specifies the Route restriction of a connection.')
parConnRstrZcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRstrZcs.setStatus('current')
if mibBuilder.loadTexts: parConnRstrZcs.setDescription('This object specifies whether ZCS lines should be avoided or not.')
parConnCos = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnCos.setStatus('current')
if mibBuilder.loadTexts: parConnCos.setDescription('This object specifies the COS for the connection.')
parClockTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 4, 1), )
if mibBuilder.loadTexts: parClockTable.setStatus('current')
if mibBuilder.loadTexts: parClockTable.setDescription('Table of clock sources available to PAR')
parClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-PAR-MIB", "parClockIndex"))
if mibBuilder.loadTexts: parClockEntry.setStatus('current')
if mibBuilder.loadTexts: parClockEntry.setDescription('Each entry represent a clock source available to PAR')
parClockIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockIndex.setStatus('current')
if mibBuilder.loadTexts: parClockIndex.setDescription('This clock index is assigned by PAR.')
parClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("null", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parClockType.setStatus('current')
if mibBuilder.loadTexts: parClockType.setDescription('Specifies the type of clock.')
parClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("interface", 2), ("external", 3))).clone('internal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockSource.setStatus('current')
if mibBuilder.loadTexts: parClockSource.setDescription('Specifies source of the clock.')
parClockCurSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockCurSource.setStatus('current')
if mibBuilder.loadTexts: parClockCurSource.setDescription('Specifies whether clock source is a current clock source or not. The value is true if the cloock source is current and false otherwise')
parClockSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parClockSourceId.setStatus('current')
if mibBuilder.loadTexts: parClockSourceId.setDescription("Specifies identification of the clock - for example - if clock source is `Interface' then this field will carry logical interface number")
parClockPath = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockPath.setStatus('current')
if mibBuilder.loadTexts: parClockPath.setDescription('Describes the path used for clock synchronization')
parCmParmsMaxRoutingBundle = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 1), Integer32().clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxRoutingBundle.setStatus('current')
if mibBuilder.loadTexts: parCmParmsMaxRoutingBundle.setDescription('This object specifies the maximum number of connections that can be routed in one routing cycle.')
parCmParmsRerouteTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRerouteTimer.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRerouteTimer.setDescription('This object specifies the minimum time after which a connection is routed once it has been successfully routed.')
parCmParmsResetTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsResetTimer.setStatus('current')
if mibBuilder.loadTexts: parCmParmsResetTimer.setDescription('This object specifies whether the reroute timer should be reset if the path for routed connection failed. If the value of the object is true(1), the timer is reset on detecting path fail.')
parCmParmsDnUpPerPass = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 4), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsDnUpPerPass.setStatus('current')
if mibBuilder.loadTexts: parCmParmsDnUpPerPass.setDescription('This object specifies the maximum number of connections that are upped or down in one schedule of down connection state machine.')
parCmParmsDnUpTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 5), Integer32().clone(30000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsDnUpTimer.setStatus('current')
if mibBuilder.loadTexts: parCmParmsDnUpTimer.setDescription('This object specifies the minimum time interval (in milliseconds) between two schedules of the down connection state machine.')
parCmParmsRrtErrsPerCycle = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 6), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtErrsPerCycle.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRrtErrsPerCycle.setDescription('This object specifies the threshold for number of failures to route a connection before it is moved into the wait group. If the value of this object is zero, the feature is disabled.')
parCmParmsRrtCycleInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 7), Integer32().clone(5)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtCycleInterval.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRrtCycleInterval.setDescription('This object specifies the time (in minutes) for which no attempt is made to route a connection in the wait group.')
parCmParmsMaxRrtCycles = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 8), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxRrtCycles.setStatus('current')
if mibBuilder.loadTexts: parCmParmsMaxRrtCycles.setDescription('This object specifies the number of times a connection is added to the wait group before declaring it unroutable.')
parCmParmsRrtPauseTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 9), Integer32()).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtPauseTime.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRrtPauseTime.setDescription('This object specifies the time interval (in milliseconds) between two routing cycles.')
parCmParmsMaxUpdates = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 10), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxUpdates.setStatus('current')
if mibBuilder.loadTexts: parCmParmsMaxUpdates.setDescription('This object specifies the maximum number of connection management updates that are sent by the node in schedule..')
parCmParmsRerouteGroups = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 11), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRerouteGroups.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRerouteGroups.setDescription('This object specifies the total number of reroute groups.')
parCmParmsMinRrGroupSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMinRrGroupSize.setStatus('current')
if mibBuilder.loadTexts: parCmParmsMinRrGroupSize.setDescription('This object specifies the minimum size of reroute group in Cell Load Units.')
parCmParmsRrGroupInc = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 13), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrGroupInc.setStatus('current')
if mibBuilder.loadTexts: parCmParmsRrGroupInc.setDescription('This object specifies the increment of reroute group size (in Cell Load Units) between adjacent groups.')
parCmParmsCostBased = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsCostBased.setStatus('current')
if mibBuilder.loadTexts: parCmParmsCostBased.setDescription('This object can be configured to enable or disable cost based routing feature. If the value of this object is true(1), the feature is enabled else it is disabled.')
parCmParmsUseCache = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsUseCache.setStatus('current')
if mibBuilder.loadTexts: parCmParmsUseCache.setDescription('This object can be configured to enable or disable hop based route selection from using cache of precomputed routes. If the value of this object is true(1), the feature is enabled else it is disabled.')
parCmParmsUseDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsUseDelay.setStatus('current')
if mibBuilder.loadTexts: parCmParmsUseDelay.setDescription('This object can be configured to enable or disable cost based route selection from considering end-to-end delay associated with the routes. If the value of this object is true(1), the delay would be considered otherwise daley would not be considered during routing of connection.')
parCmParmMaxViaCons = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 80000)).clone(50000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmMaxViaCons.setStatus('current')
if mibBuilder.loadTexts: parCmParmMaxViaCons.setDescription('This object specifies the maximum number of via user connections that can be routed through the node.')
parMnUpdtInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 1), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtInterval.setStatus('current')
if mibBuilder.loadTexts: parMnUpdtInterval.setDescription('This object specifies the timer interval (in seconds) for the current update state machine.')
parMnUpdtNodesPerInt = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 2), Integer32().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtNodesPerInt.setStatus('current')
if mibBuilder.loadTexts: parMnUpdtNodesPerInt.setDescription('This object specifies the maximum number of nodes to which current updates can be sent per interval.')
parMnUpdtBatchSend = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtBatchSend.setStatus('current')
if mibBuilder.loadTexts: parMnUpdtBatchSend.setDescription('This object specifies whether current updates to any node are sent one at a time or all in one go. If the value of this object is true(1), all current updates are sent to the node simultaneously. If the value of this object is False, current updates are sent one at a time.')
parSwFuncAbrVsvd = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 4, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSwFuncAbrVsvd.setStatus('current')
if mibBuilder.loadTexts: parSwFuncAbrVsvd.setDescription('This object enables/disables the ABR standard with VSVD. The feature is enabled if the value of the object is true(1).')
parSwFuncNodeType = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("routing", 1), ("feeder", 2))).clone('routing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSwFuncNodeType.setStatus('current')
if mibBuilder.loadTexts: parSwFuncNodeType.setDescription('This object specifies whether the node is a routing node or a feeder node. To configure the node from a routing(1) node to feeder(2) node the node should be part of a single node network. To configure the node from feeder node to routing node, there should be no feeder trunk attached to the node.')
parOnOffBackgroundUpdt = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffBackgroundUpdt.setStatus('current')
if mibBuilder.loadTexts: parOnOffBackgroundUpdt.setDescription('This object can be used to enable or disable Background updates. If the value of the object is true(1), background updates are enabled; otherwise they are disabled.')
parOnOffDynamicBwAlloc = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffDynamicBwAlloc.setStatus('current')
if mibBuilder.loadTexts: parOnOffDynamicBwAlloc.setDescription('This object can be used to enable or disable Bandwidth state machine. If the value of the object is true(1), bandwidth state machine is enabled; otherwise it is disabled.')
parOnOffCmUpdts = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCmUpdts.setStatus('current')
if mibBuilder.loadTexts: parOnOffCmUpdts.setDescription('This object can be used to enable or disable connection management updates. If the value of the object is true(1), connection management updates are enabled; otherwise they are disabled.')
parOnOffRouting = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffRouting.setStatus('current')
if mibBuilder.loadTexts: parOnOffRouting.setDescription('This object can be used to enable or disable connection routing. If the value of the object is true(1), routing is enabled; otherwise it is disabled.')
parOnOffCommFailTest = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCommFailTest.setStatus('current')
if mibBuilder.loadTexts: parOnOffCommFailTest.setDescription('This object can be used to enable or disable Comm Fail Test. If the value of the object is true(1), Comm Fail test is enabled; otherwise it is disabled.')
parOnOffDrtDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffDrtDelay.setStatus('current')
if mibBuilder.loadTexts: parOnOffDrtDelay.setDescription('This object can be used to enable or disable Deroute Delay feature. If the value of the object is true(1) Derote delay feature is enabled; otherwise it is disabled.')
parOnOffRenumRec = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffRenumRec.setStatus('current')
if mibBuilder.loadTexts: parOnOffRenumRec.setDescription('This object can be used to enable or disable Renumber recovery feature. If the value of the object is true(1), renumber recovery feature is enabled; otherwise it is disabled.')
parOnOffCommBreak = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCommBreak.setStatus('current')
if mibBuilder.loadTexts: parOnOffCommBreak.setDescription('This object can be used to enable or disable Comm Break Test. If the value of the object is true(1), Comm Break Test feature is enabled; otherwise it is disabled.')
parSysParmsTsPacketAge = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(64)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsTsPacketAge.setStatus('current')
if mibBuilder.loadTexts: parSysParmsTsPacketAge.setDescription('Time Stamped packets older than this value (in milliseconds)are discarded. This is a network wide parameter.')
parSysParmsConnFail = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsConnFail.setStatus('current')
if mibBuilder.loadTexts: parSysParmsConnFail.setDescription('This object specifies whether the connections to a node should be failed when comm fail is declared with the node. If the value of this object is true(1), the connection will be failed. This is a network wide parameter.')
parSysParmsVcPollRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsVcPollRate.setStatus('current')
if mibBuilder.loadTexts: parSysParmsVcPollRate.setDescription('This object specifies the rate at which VC statistics are to be polled. This is a network wide parameter. For Portable AutoRoute statistic collections would be done by platform software.')
parSysParmsMaxVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 4), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxVDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxVDelay.setDescription('This object specifies the maximum delay for voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 5), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCDelay.setDescription('This object specifies the maximum delay for ADPCM compressed voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 6), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxDDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxDDelay.setDescription('This object specifies the maximum delay for data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 7), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxADelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxADelay.setDescription('This object specifies the maximum delay for ADPCM compressed voice connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 8), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxHsdDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxHsdDelay.setDescription('This object specifies the maximum delay for High Speed data connection in milli-seconds. This is a network wide parameter.')
parSysParmsDeEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsDeEnable.setStatus('current')
if mibBuilder.loadTexts: parSysParmsDeEnable.setDescription('This object specifies whether DE bit of Frame Relay frames can be modified. DE bit can be modified if the value of this object is true(1). This is a network wide parameter.')
parSysParmsFrStandard = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsFrStandard.setStatus('current')
if mibBuilder.loadTexts: parSysParmsFrStandard.setDescription('This object specifies whether standard Frame Relay parameters,Be and Bc, are to be used. If the value of this object is true(1), standard parameters are used. This is a network wide parameter.')
parSysParmsDrtDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsDrtDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsDrtDelay.setDescription('This object specifies whether Deroute Delay feature is enabled. If the value of this object is true(1), the feature is enabled. This is a network wide parameter.')
parSysParmsInvLogAlarmThres = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsInvLogAlarmThres.setStatus('current')
if mibBuilder.loadTexts: parSysParmsInvLogAlarmThres.setDescription('This object specifies the threshold for invalid login attempts before triggering an alarm. If the value of this object is zero, this feature is disabled. This is a network wide parameter.')
parSysParmsMaxCdpVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 13), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpVDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCdpVDelay.setDescription('This object specifies the maximum network delay for CDP to CDP voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCdpCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 14), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpCDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCdpCDelay.setDescription('This object specifies the maximum network delay for CDP to CDP ADPCM compressed voice connection with VAD enabled. This is a network wide parameter.')
parSysParmsMaxCdpDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 15), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpDDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCdpDDelay.setDescription('This object specifies the maximum network delay for CDP to CDP data connection. This is a network wide parameter.')
parSysParmsMaxCdpADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 16), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpADelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCdpADelay.setDescription('This object specifies the maximum network delay for CDP to CDP ADPCM compressed voice connection. This is a network wide parameter.')
parSysParmsMaxCdpHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 17), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpHsdDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxCdpHsdDelay.setDescription('This object specifies the maximum network delay for CDP to CDP High Speed data connection. This is a network wide parameter.')
parSysParmsMaxIpcdpVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 18), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpVDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpVDelay.setDescription('This object specifies the maximum local delay for CDP to CDP voice connection with VAD enabled. This is a network wide parameter.')
parSysParmsMaxIpcdpCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 19), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpCDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpCDelay.setDescription('This object specifies the maximum local delay for CDP to CDP ADPCM compressed voice connection with VAD enabled. This is a network wide parameter.')
parSysParmsMaxIpcdpDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 20), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpDDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpDDelay.setDescription('This object specifies the maximum local delay for CDP to CDP data connection. This is a network wide parameter.')
parSysParmsMaxIpcdpADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpADelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpADelay.setDescription('This object specifies the maximum local delay for CDP to CDP ADPCM compressed voice connection. This is a network wide parameter.')
parSysParmsMaxIpcdpHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpHsdDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpHsdDelay.setDescription('This object specifies the maximum local delay for CDP to CDP High Speed data connection. This is a network wide parameter.')
parSysParmsMaxIphsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 23), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIphsdDelay.setStatus('current')
if mibBuilder.loadTexts: parSysParmsMaxIphsdDelay.setDescription('This object specifies the maximum local delay for High Speed data connection. This is a network wide parameter.')
parSysParmsFpdDeJitter = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsFpdDeJitter.setStatus('current')
if mibBuilder.loadTexts: parSysParmsFpdDeJitter.setDescription('This object specifies the jitter delay for Fast Pad. This is a network wide parameter.')
parNetParmCondInitialStgr = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 1), Integer32().clone(5000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCondInitialStgr.setStatus('current')
if mibBuilder.loadTexts: parNetParmCondInitialStgr.setDescription('This object specifies the initial pause time (in milliseconds) per new node added on addition of node(s) in the network before initiating conditional updates.')
parNetParmCondPerNodeInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 2), Integer32().clone(30000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCondPerNodeInterval.setStatus('current')
if mibBuilder.loadTexts: parNetParmCondPerNodeInterval.setDescription('This object specifies the minimum interval (in milliseconds) between sending of conditional updates to any two nodes.')
parNetParmCbDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 3), Integer32().clone(30000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbDelay.setStatus('current')
if mibBuilder.loadTexts: parNetParmCbDelay.setDescription('This object specifies the minimum interval (in milliseconds) between initiating comm break tests between any two nodes.')
parNetParmCbOffset = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 4), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbOffset.setStatus('current')
if mibBuilder.loadTexts: parNetParmCbOffset.setDescription('Offset for CB.')
parNetParmMsgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 5), Integer32().clone(1700)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgTimeout.setStatus('current')
if mibBuilder.loadTexts: parNetParmMsgTimeout.setDescription('This object specifies the timeout (in milliseconds) for acknowledgment for control plane message sent to another node.')
parNetParmMsgMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 6), Integer32().clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: parNetParmMsgMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane message sent to another node reachable through all terrestrial trunks.')
parNetParmMsgMaxTimeoutSat = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 7), Integer32().clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgMaxTimeoutSat.setStatus('current')
if mibBuilder.loadTexts: parNetParmMsgMaxTimeoutSat.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane message sent to another node reachable through all satellite trunks.')
parNetParmBlindMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 8), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmBlindMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: parNetParmBlindMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane blind message sent to another node.')
parNetParmCbMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 9), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: parNetParmCbMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for comm break test message sent to another node.')
parNetParmCfTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 10), Integer32().clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfTestInterval.setStatus('current')
if mibBuilder.loadTexts: parNetParmCfTestInterval.setDescription('This object specifies the minimum time interval between the comm fail tests for a trunk.')
parNetParmCfTestMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 11), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfTestMultiplier.setStatus('current')
if mibBuilder.loadTexts: parNetParmCfTestMultiplier.setDescription('This object specifies the multiplier for the comm fail test interval for good trunks, that is, trunks not in comm fail.')
parNetParmNetwWindowSz = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 12), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmNetwWindowSz.setStatus('current')
if mibBuilder.loadTexts: parNetParmNetwWindowSz.setDescription('This object specifies the window size for the network handler for messages to any node. That is, the number of messages that the network handler can send simultaneous to a node without receiving the acknowledgment for them.')
parNetParmNetwLetWait = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 13), Integer32().clone(50)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmNetwLetWait.setStatus('current')
if mibBuilder.loadTexts: parNetParmNetwLetWait.setDescription('This object specifies the maximum interval (in milliseconds) network handler waits for the letter (message) from the processes running on its nodes before checking the received cells.')
parNetParmCfDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 14), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfDelay.setStatus('current')
if mibBuilder.loadTexts: parNetParmCfDelay.setDescription('TBD (in milliseconds).')
parNetParmHighTxRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 15), Integer32().clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmHighTxRate.setStatus('current')
if mibBuilder.loadTexts: parNetParmHighTxRate.setDescription('This object specifies the rate (in fast packets per second) at which the network handler sends control plane message cells to high performance nodes (High performance node are BPX and MGX).')
parNetParmLowTxRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 16), Integer32().clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmLowTxRate.setStatus('current')
if mibBuilder.loadTexts: parNetParmLowTxRate.setDescription('This object specifies the rate (in fast packets per second) at which the network handler sends control plane message cells to low capacity nodes (Low capacity node are IPX and IGX).')
parNetParmMaxNodeBlks = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 17), Integer32().clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMaxNodeBlks.setStatus('current')
if mibBuilder.loadTexts: parNetParmMaxNodeBlks.setDescription('This object specifies the maximum number of blocks of size 256 bytes, that should be queued up for transmission to a node.')
parNetParmTopoMsgSegSz = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 18), Integer32().clone(3570)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmTopoMsgSegSz.setStatus('current')
if mibBuilder.loadTexts: parNetParmTopoMsgSegSz.setDescription('This object specifies the maximum size (in bytes) of the segment into which the topology message, sent during network join, is divided.')
cwParMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 63, 2))
cwParMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1))
cwParMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 2))
cwParCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 2, 1)).setObjects(("CISCO-WAN-PAR-MIB", "cwParCmParamsGroup"), ("CISCO-WAN-PAR-MIB", "cwParCmParamsUpdateGroup"), ("CISCO-WAN-PAR-MIB", "cwParGeneralGroup"), ("CISCO-WAN-PAR-MIB", "cwParSysParamsGroup"), ("CISCO-WAN-PAR-MIB", "cwParNetParamsGroup"), ("CISCO-WAN-PAR-MIB", "cwParNodeGroup"), ("CISCO-WAN-PAR-MIB", "cwParInterfaceConfGroup"), ("CISCO-WAN-PAR-MIB", "cwParTrunkConfGroup"), ("CISCO-WAN-PAR-MIB", "cwParTrunkLoadConfGroup"), ("CISCO-WAN-PAR-MIB", "cwParConnConfGroup"), ("CISCO-WAN-PAR-MIB", "cwParClockConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParCompliance = cwParCompliance.setStatus('current')
if mibBuilder.loadTexts: cwParCompliance.setDescription('The compliance statement for objects related to AutoRoute MIB.')
cwParCmParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 1)).setObjects(("CISCO-WAN-PAR-MIB", "parCmParmsMaxRoutingBundle"), ("CISCO-WAN-PAR-MIB", "parCmParmsRerouteTimer"), ("CISCO-WAN-PAR-MIB", "parCmParmsResetTimer"), ("CISCO-WAN-PAR-MIB", "parCmParmsDnUpPerPass"), ("CISCO-WAN-PAR-MIB", "parCmParmsDnUpTimer"), ("CISCO-WAN-PAR-MIB", "parCmParmsRrtErrsPerCycle"), ("CISCO-WAN-PAR-MIB", "parCmParmsRrtCycleInterval"), ("CISCO-WAN-PAR-MIB", "parCmParmsMaxRrtCycles"), ("CISCO-WAN-PAR-MIB", "parCmParmsRrtPauseTime"), ("CISCO-WAN-PAR-MIB", "parCmParmsMaxUpdates"), ("CISCO-WAN-PAR-MIB", "parCmParmsRerouteGroups"), ("CISCO-WAN-PAR-MIB", "parCmParmsMinRrGroupSize"), ("CISCO-WAN-PAR-MIB", "parCmParmsRrGroupInc"), ("CISCO-WAN-PAR-MIB", "parCmParmsCostBased"), ("CISCO-WAN-PAR-MIB", "parCmParmsUseCache"), ("CISCO-WAN-PAR-MIB", "parCmParmsUseDelay"), ("CISCO-WAN-PAR-MIB", "parCmParmMaxViaCons"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParCmParamsGroup = cwParCmParamsGroup.setStatus('current')
if mibBuilder.loadTexts: cwParCmParamsGroup.setDescription('The collection of objects which are applicable for PAR connection management.')
cwParCmParamsUpdateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 2)).setObjects(("CISCO-WAN-PAR-MIB", "parMnUpdtInterval"), ("CISCO-WAN-PAR-MIB", "parMnUpdtNodesPerInt"), ("CISCO-WAN-PAR-MIB", "parMnUpdtBatchSend"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParCmParamsUpdateGroup = cwParCmParamsUpdateGroup.setStatus('current')
if mibBuilder.loadTexts: cwParCmParamsUpdateGroup.setDescription('The collection of objects which are applicable for PAR Connection Management parameters updates.')
cwParGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 3)).setObjects(("CISCO-WAN-PAR-MIB", "parSwFuncAbrVsvd"), ("CISCO-WAN-PAR-MIB", "parSwFuncNodeType"), ("CISCO-WAN-PAR-MIB", "parOnOffBackgroundUpdt"), ("CISCO-WAN-PAR-MIB", "parOnOffDynamicBwAlloc"), ("CISCO-WAN-PAR-MIB", "parOnOffCmUpdts"), ("CISCO-WAN-PAR-MIB", "parOnOffRouting"), ("CISCO-WAN-PAR-MIB", "parOnOffCommFailTest"), ("CISCO-WAN-PAR-MIB", "parOnOffDrtDelay"), ("CISCO-WAN-PAR-MIB", "parOnOffRenumRec"), ("CISCO-WAN-PAR-MIB", "parOnOffCommBreak"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParGeneralGroup = cwParGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: cwParGeneralGroup.setDescription('The collection of objects which are applicable for general PAR configuration.')
cwParSysParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 4)).setObjects(("CISCO-WAN-PAR-MIB", "parSysParmsTsPacketAge"), ("CISCO-WAN-PAR-MIB", "parSysParmsConnFail"), ("CISCO-WAN-PAR-MIB", "parSysParmsVcPollRate"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxVDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxDDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxADelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxHsdDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsDeEnable"), ("CISCO-WAN-PAR-MIB", "parSysParmsFrStandard"), ("CISCO-WAN-PAR-MIB", "parSysParmsDrtDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsInvLogAlarmThres"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCdpVDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCdpCDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCdpDDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCdpADelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxCdpHsdDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIpcdpVDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIpcdpCDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIpcdpDDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIpcdpADelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIpcdpHsdDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsMaxIphsdDelay"), ("CISCO-WAN-PAR-MIB", "parSysParmsFpdDeJitter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParSysParamsGroup = cwParSysParamsGroup.setStatus('current')
if mibBuilder.loadTexts: cwParSysParamsGroup.setDescription('The collection of objects which are applicable for PAR system parameters.')
cwParNetParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 5)).setObjects(("CISCO-WAN-PAR-MIB", "parNetParmCondInitialStgr"), ("CISCO-WAN-PAR-MIB", "parNetParmCondPerNodeInterval"), ("CISCO-WAN-PAR-MIB", "parNetParmCbDelay"), ("CISCO-WAN-PAR-MIB", "parNetParmCbOffset"), ("CISCO-WAN-PAR-MIB", "parNetParmMsgTimeout"), ("CISCO-WAN-PAR-MIB", "parNetParmMsgMaxTimeout"), ("CISCO-WAN-PAR-MIB", "parNetParmMsgMaxTimeoutSat"), ("CISCO-WAN-PAR-MIB", "parNetParmBlindMaxTimeout"), ("CISCO-WAN-PAR-MIB", "parNetParmCbMaxTimeout"), ("CISCO-WAN-PAR-MIB", "parNetParmCfTestInterval"), ("CISCO-WAN-PAR-MIB", "parNetParmCfTestMultiplier"), ("CISCO-WAN-PAR-MIB", "parNetParmNetwWindowSz"), ("CISCO-WAN-PAR-MIB", "parNetParmNetwLetWait"), ("CISCO-WAN-PAR-MIB", "parNetParmCfDelay"), ("CISCO-WAN-PAR-MIB", "parNetParmHighTxRate"), ("CISCO-WAN-PAR-MIB", "parNetParmLowTxRate"), ("CISCO-WAN-PAR-MIB", "parNetParmMaxNodeBlks"), ("CISCO-WAN-PAR-MIB", "parNetParmTopoMsgSegSz"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParNetParamsGroup = cwParNetParamsGroup.setStatus('current')
if mibBuilder.loadTexts: cwParNetParamsGroup.setDescription('The collection of objects which are applicable for parameters applicable network-wide.')
cwParNodeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 6)).setObjects(("CISCO-WAN-PAR-MIB", "parSnNodeId"), ("CISCO-WAN-PAR-MIB", "parSnNodeIP"), ("CISCO-WAN-PAR-MIB", "parSnNodeName"), ("CISCO-WAN-PAR-MIB", "parSnRevision"), ("CISCO-WAN-PAR-MIB", "parSnNodeAlarmStatus"), ("CISCO-WAN-PAR-MIB", "parSnNumberOfTrunks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParNodeGroup = cwParNodeGroup.setStatus('current')
if mibBuilder.loadTexts: cwParNodeGroup.setDescription('The collection of objects which are applicable for node level configuration of auto route controller.')
cwParInterfaceConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 7)).setObjects(("CISCO-WAN-PAR-MIB", "parIfLogicalInterface"), ("CISCO-WAN-PAR-MIB", "parIfType"), ("CISCO-WAN-PAR-MIB", "parIfOperStatus"), ("CISCO-WAN-PAR-MIB", "parIfTxBw"), ("CISCO-WAN-PAR-MIB", "parIfRxBw"), ("CISCO-WAN-PAR-MIB", "parIfMaxConn"), ("CISCO-WAN-PAR-MIB", "parIfHiAddrMin"), ("CISCO-WAN-PAR-MIB", "parIfHiAddrMax"), ("CISCO-WAN-PAR-MIB", "parIfLoAddrMin"), ("CISCO-WAN-PAR-MIB", "parIfLoAddrMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParInterfaceConfGroup = cwParInterfaceConfGroup.setStatus('current')
if mibBuilder.loadTexts: cwParInterfaceConfGroup.setDescription('The collection of objects which are used for configuring autoroute interfaces.')
cwParTrunkConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 8)).setObjects(("CISCO-WAN-PAR-MIB", "parTrkId"), ("CISCO-WAN-PAR-MIB", "parTrkStatReserve"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgCcRestrict"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgLineType"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgPassSync"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgDerouteDelay"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassFst"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassFr"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassNts"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassTs"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassVoice"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassCbr"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassVbr"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgTrafficClassAbr"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgAdminStatus"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgRoutingCost"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgVpcConids"), ("CISCO-WAN-PAR-MIB", "parTrkCnfgVccConids"), ("CISCO-WAN-PAR-MIB", "parTrkLocalSlotNumber"), ("CISCO-WAN-PAR-MIB", "parTrkLocalPortNumber"), ("CISCO-WAN-PAR-MIB", "parTrkLocalVTrunkId"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteNodeId"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteTrunkId"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteSlotNumber"), ("CISCO-WAN-PAR-MIB", "parTrkRemotePortNumber"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteVTrunkId"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteNodeIP"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteNodeType"), ("CISCO-WAN-PAR-MIB", "parTrkRemoteNodeName"), ("CISCO-WAN-PAR-MIB", "parTrkAlarmStatus"), ("CISCO-WAN-PAR-MIB", "parTrkAlarmType"), ("CISCO-WAN-PAR-MIB", "parTrkLineLoad"), ("CISCO-WAN-PAR-MIB", "parTrkBwCapacity"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParTrunkConfGroup = cwParTrunkConfGroup.setStatus('current')
if mibBuilder.loadTexts: cwParTrunkConfGroup.setDescription('The collection of objects which are used for configuring trunks in portable autoroute.')
cwParTrunkLoadConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 9)).setObjects(("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedCbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedCbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedVbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedVbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedAbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedAbr"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedNts"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedNts"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedTs"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedTs"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedVoice"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedVoice"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedBdataA"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedBdataA"), ("CISCO-WAN-PAR-MIB", "parTrkLoadXmtUsedBdataB"), ("CISCO-WAN-PAR-MIB", "parTrkLoadRcvUsedBdataB"), ("CISCO-WAN-PAR-MIB", "parTrkLoadVccConidsUsed"), ("CISCO-WAN-PAR-MIB", "parTrkLoadVpcConidsUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParTrunkLoadConfGroup = cwParTrunkLoadConfGroup.setStatus('current')
if mibBuilder.loadTexts: cwParTrunkLoadConfGroup.setDescription('The collection of objects which are used for configuring trunks in portable autoroute.')
cwParConnConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 10)).setObjects(("CISCO-WAN-PAR-MIB", "parConnLocalSlot"), ("CISCO-WAN-PAR-MIB", "parConnLocalPort"), ("CISCO-WAN-PAR-MIB", "parConnLocalVpi"), ("CISCO-WAN-PAR-MIB", "parConnLocalVci"), ("CISCO-WAN-PAR-MIB", "parConnMasterShip"), ("CISCO-WAN-PAR-MIB", "parConnLocalVcIndx"), ("CISCO-WAN-PAR-MIB", "parConnLocalEndpt"), ("CISCO-WAN-PAR-MIB", "parConnRemoteNodeName"), ("CISCO-WAN-PAR-MIB", "parConnRemoteSlot"), ("CISCO-WAN-PAR-MIB", "parConnRemotePort"), ("CISCO-WAN-PAR-MIB", "parConnRemoteVpi"), ("CISCO-WAN-PAR-MIB", "parConnRemoteVci"), ("CISCO-WAN-PAR-MIB", "parConnRemoteVcIndx"), ("CISCO-WAN-PAR-MIB", "parConnRemoteEndpt"), ("CISCO-WAN-PAR-MIB", "parConnOperStatus"), ("CISCO-WAN-PAR-MIB", "parConnAdminStatus"), ("CISCO-WAN-PAR-MIB", "parConnRoute"), ("CISCO-WAN-PAR-MIB", "parPrefRoute"), ("CISCO-WAN-PAR-MIB", "parConnFailRsn"), ("CISCO-WAN-PAR-MIB", "parRrtFailRsn"), ("CISCO-WAN-PAR-MIB", "parConnRstrTyp"), ("CISCO-WAN-PAR-MIB", "parConnRstrZcs"), ("CISCO-WAN-PAR-MIB", "parConnCos"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParConnConfGroup = cwParConnConfGroup.setStatus('current')
if mibBuilder.loadTexts: cwParConnConfGroup.setDescription('The collection of objects which are used for configuring trunks in portable autoroute.')
cwParClockConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 63, 2, 1, 11)).setObjects(("CISCO-WAN-PAR-MIB", "parClockIndex"), ("CISCO-WAN-PAR-MIB", "parClockType"), ("CISCO-WAN-PAR-MIB", "parClockCurSource"), ("CISCO-WAN-PAR-MIB", "parClockSource"), ("CISCO-WAN-PAR-MIB", "parClockSourceId"), ("CISCO-WAN-PAR-MIB", "parClockPath"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwParClockConfGroup = cwParClockConfGroup.setStatus('current')
if mibBuilder.loadTexts: cwParClockConfGroup.setDescription('The collection of objects which are used for configuring trunks in portable autoroute.')
mibBuilder.exportSymbols("CISCO-WAN-PAR-MIB", parSwFuncNodeType=parSwFuncNodeType, cwParTrunkConfGroup=cwParTrunkConfGroup, parNetParmTopoMsgSegSz=parNetParmTopoMsgSegSz, parOnOffRenumRec=parOnOffRenumRec, parTrkLineLoad=parTrkLineLoad, parSysParmsMaxCDelay=parSysParmsMaxCDelay, parSwFunc=parSwFunc, parIfLoAddrMin=parIfLoAddrMin, parTrkCnfgTrafficClassCbr=parTrkCnfgTrafficClassCbr, cwParMIBCompliances=cwParMIBCompliances, parTrkAlarmStatus=parTrkAlarmStatus, parTrkLoadRcvUsedBdataB=parTrkLoadRcvUsedBdataB, parTrkCnfgTrafficClassNts=parTrkCnfgTrafficClassNts, parClockTable=parClockTable, parTrkRemoteTrunkId=parTrkRemoteTrunkId, parSysParmsConnFail=parSysParmsConnFail, parPrefRoute=parPrefRoute, parCmParmsMinRrGroupSize=parCmParmsMinRrGroupSize, cwParCompliance=cwParCompliance, parSysParmsMaxCdpVDelay=parSysParmsMaxCdpVDelay, parNetParmNetwWindowSz=parNetParmNetwWindowSz, parTrkAlarmType=parTrkAlarmType, parClockCurSource=parClockCurSource, parCmParmsCostBased=parCmParmsCostBased, parNetParmLowTxRate=parNetParmLowTxRate, parCmParmsRrtPauseTime=parCmParmsRrtPauseTime, parConnRoute=parConnRoute, parIfLoAddrMax=parIfLoAddrMax, parTrkLoadXmtUsedAbr=parTrkLoadXmtUsedAbr, parSysParmsMaxIpcdpCDelay=parSysParmsMaxIpcdpCDelay, parConnRemoteNodeName=parConnRemoteNodeName, parSnNumberOfTrunks=parSnNumberOfTrunks, parConnLocalEndpt=parConnLocalEndpt, parSnRevision=parSnRevision, parConnection=parConnection, parTrkCnfgTrafficClassFst=parTrkCnfgTrafficClassFst, parNetParmHighTxRate=parNetParmHighTxRate, parConnRstrZcs=parConnRstrZcs, parCmParmsDnUpTimer=parCmParmsDnUpTimer, parCmParmMaxViaCons=parCmParmMaxViaCons, cwParConnConfGroup=cwParConnConfGroup, parNetParmCbOffset=parNetParmCbOffset, parNetParmCondInitialStgr=parNetParmCondInitialStgr, parNetParmCfDelay=parNetParmCfDelay, parIfRxBw=parIfRxBw, parTrkLoadRcvUsedVoice=parTrkLoadRcvUsedVoice, PYSNMP_MODULE_ID=ciscoWanParMIB, parNetParmNetwLetWait=parNetParmNetwLetWait, parCmParmsUseCache=parCmParmsUseCache, parTrkLoadRcvUsedCbr=parTrkLoadRcvUsedCbr, parTrkLoadXmtUsedVoice=parTrkLoadXmtUsedVoice, parNetParmCbMaxTimeout=parNetParmCbMaxTimeout, parNetParmBlindMaxTimeout=parNetParmBlindMaxTimeout, parConnMasterShip=parConnMasterShip, parTrkLoadVccConidsUsed=parTrkLoadVccConidsUsed, cwParClockConfGroup=cwParClockConfGroup, parOnOff=parOnOff, parTrkLoadTable=parTrkLoadTable, parOnOffDynamicBwAlloc=parOnOffDynamicBwAlloc, parCmParmsRrtCycleInterval=parCmParmsRrtCycleInterval, parSnNodeIP=parSnNodeIP, parClockSourceId=parClockSourceId, ciscoWanParMIB=ciscoWanParMIB, parSysParmsMaxIpcdpADelay=parSysParmsMaxIpcdpADelay, parTrkCnfgTrafficClassVbr=parTrkCnfgTrafficClassVbr, parMnUpdtNodesPerInt=parMnUpdtNodesPerInt, parTrkStatReserve=parTrkStatReserve, parConnAdminStatus=parConnAdminStatus, parTrkLocalVTrunkId=parTrkLocalVTrunkId, parCmParmsRerouteGroups=parCmParmsRerouteGroups, parSwFuncAbrVsvd=parSwFuncAbrVsvd, parNetworkingParms=parNetworkingParms, parSysParmsMaxCdpADelay=parSysParmsMaxCdpADelay, parClockType=parClockType, parNetParmMsgMaxTimeoutSat=parNetParmMsgMaxTimeoutSat, cwParSysParamsGroup=cwParSysParamsGroup, parConnRemoteVci=parConnRemoteVci, parConnFailRsn=parConnFailRsn, parSysParmsInvLogAlarmThres=parSysParmsInvLogAlarmThres, parSysParmsTsPacketAge=parSysParmsTsPacketAge, parConnLocalPort=parConnLocalPort, parTrkCnfgVccConids=parTrkCnfgVccConids, cwParTrunkLoadConfGroup=cwParTrunkLoadConfGroup, parTrkCnfgDerouteDelay=parTrkCnfgDerouteDelay, parTrkCnfgTrafficClassVoice=parTrkCnfgTrafficClassVoice, parOnOffCmUpdts=parOnOffCmUpdts, parSysParmsDrtDelay=parSysParmsDrtDelay, parSysParmsMaxIpcdpDDelay=parSysParmsMaxIpcdpDDelay, parOnOffBackgroundUpdt=parOnOffBackgroundUpdt, parSysParmsMaxIpcdpVDelay=parSysParmsMaxIpcdpVDelay, parSysParmsDeEnable=parSysParmsDeEnable, cwParMIBConformance=cwParMIBConformance, parCmParmsRrtErrsPerCycle=parCmParmsRrtErrsPerCycle, parSysParmsMaxCdpCDelay=parSysParmsMaxCdpCDelay, parConnLocalSlot=parConnLocalSlot, parTrkLoadXmtUsedBdataB=parTrkLoadXmtUsedBdataB, parIfMaxConn=parIfMaxConn, parNetworkClock=parNetworkClock, parSysParmsMaxDDelay=parSysParmsMaxDDelay, parNetParmCfTestMultiplier=parNetParmCfTestMultiplier, parTrkLocalSlotNumber=parTrkLocalSlotNumber, parTrkLoadRcvUsedBdataA=parTrkLoadRcvUsedBdataA, parTrkLocalPortNumber=parTrkLocalPortNumber, parTrkRemoteNodeName=parTrkRemoteNodeName, parSysParmsMaxIpcdpHsdDelay=parSysParmsMaxIpcdpHsdDelay, parClockEntry=parClockEntry, parCmParmsUseDelay=parCmParmsUseDelay, parConnLocalVpi=parConnLocalVpi, parSysParmsFrStandard=parSysParmsFrStandard, parTrkCnfgCcRestrict=parTrkCnfgCcRestrict, parConnectionEntry=parConnectionEntry, parSysParmsVcPollRate=parSysParmsVcPollRate, parIfHiAddrMax=parIfHiAddrMax, parNetParmMsgTimeout=parNetParmMsgTimeout, parTrkLoadXmtUsedCbr=parTrkLoadXmtUsedCbr, parTrkCnfgVpcConids=parTrkCnfgVpcConids, parConnRemoteVcIndx=parConnRemoteVcIndx, parTrkRemotePortNumber=parTrkRemotePortNumber, parTrkLoadXmtUsedNts=parTrkLoadXmtUsedNts, parSysParmsMaxHsdDelay=parSysParmsMaxHsdDelay, parCmParms=parCmParms, parTrkLoadRcvUsedAbr=parTrkLoadRcvUsedAbr, parSnNodeId=parSnNodeId, parTrkCnfgPassSync=parTrkCnfgPassSync, parTrkCnfgAdminStatus=parTrkCnfgAdminStatus, parMnUpdt=parMnUpdt, parTrkLoadRcvUsedNts=parTrkLoadRcvUsedNts, parConnLocalVcIndx=parConnLocalVcIndx, parConnCos=parConnCos, parOnOffCommFailTest=parOnOffCommFailTest, parOnOffCommBreak=parOnOffCommBreak, cwParInterfaceConfGroup=cwParInterfaceConfGroup, parSnNodeName=parSnNodeName, parOnOffDrtDelay=parOnOffDrtDelay, parTrkLoadXmtUsedVbr=parTrkLoadXmtUsedVbr, cwParCmParamsUpdateGroup=cwParCmParamsUpdateGroup, parCmParmsMaxRrtCycles=parCmParmsMaxRrtCycles, parTrkLoadVpcConidsUsed=parTrkLoadVpcConidsUsed, parConnOperStatus=parConnOperStatus, parTrkRemoteNodeIP=parTrkRemoteNodeIP, parClockPath=parClockPath, parCmParmsRerouteTimer=parCmParmsRerouteTimer, parConnectionTable=parConnectionTable, parTrkTable=parTrkTable, parMnUpdtInterval=parMnUpdtInterval, parIfHiAddrMin=parIfHiAddrMin, parSysParmsMaxCdpDDelay=parSysParmsMaxCdpDDelay, parNetParmCfTestInterval=parNetParmCfTestInterval, parOnOffRouting=parOnOffRouting, cwParNodeGroup=cwParNodeGroup, parCmParmsMaxRoutingBundle=parCmParmsMaxRoutingBundle, parConnRemotePort=parConnRemotePort, parIfLogicalInterface=parIfLogicalInterface, parIfTable=parIfTable, parSysParmsFpdDeJitter=parSysParmsFpdDeJitter, parTrkCnfgTrafficClassFr=parTrkCnfgTrafficClassFr, parSysParms=parSysParms, parIfTxBw=parIfTxBw, parTrkBwCapacity=parTrkBwCapacity, parTrkLoadXmtUsedTs=parTrkLoadXmtUsedTs, parConnRemoteEndpt=parConnRemoteEndpt, parCmParmsRrGroupInc=parCmParmsRrGroupInc, cwParCmParamsGroup=cwParCmParamsGroup, parSelfNode=parSelfNode, parIfOperStatus=parIfOperStatus, cwParNetParamsGroup=cwParNetParamsGroup, parTrkRemoteNodeId=parTrkRemoteNodeId, parMnUpdtBatchSend=parMnUpdtBatchSend, parConnLocalVci=parConnLocalVci, parTrkLoadEntry=parTrkLoadEntry, parVsiConfigParms=parVsiConfigParms, parNetParmCondPerNodeInterval=parNetParmCondPerNodeInterval, parNetParmMsgMaxTimeout=parNetParmMsgMaxTimeout, parInterfaces=parInterfaces, parClockSource=parClockSource, parTrkCnfgLineType=parTrkCnfgLineType, parSysParmsMaxVDelay=parSysParmsMaxVDelay, parTrkRemoteNodeType=parTrkRemoteNodeType, parSnNodeAlarmStatus=parSnNodeAlarmStatus, cwParGeneralGroup=cwParGeneralGroup, parConnRstrTyp=parConnRstrTyp, parTrkRemoteSlotNumber=parTrkRemoteSlotNumber, parTrkCnfgRoutingCost=parTrkCnfgRoutingCost, parIfEntry=parIfEntry, parTrkCnfgTrafficClassTs=parTrkCnfgTrafficClassTs, parIfType=parIfType, parTrkRemoteVTrunkId=parTrkRemoteVTrunkId, parConnRemoteVpi=parConnRemoteVpi, parClockIndex=parClockIndex, parCmParmsDnUpPerPass=parCmParmsDnUpPerPass, parTrkId=parTrkId, parConnRemoteSlot=parConnRemoteSlot, parRrtFailRsn=parRrtFailRsn, parSysParmsMaxCdpHsdDelay=parSysParmsMaxCdpHsdDelay, parSysParmsMaxADelay=parSysParmsMaxADelay, parTrkLoadXmtUsedBdataA=parTrkLoadXmtUsedBdataA, parTrkEntry=parTrkEntry, parTrkLoadRcvUsedVbr=parTrkLoadRcvUsedVbr, cwParMIBGroups=cwParMIBGroups, parNetParmMaxNodeBlks=parNetParmMaxNodeBlks, parTrkCnfgTrafficClassAbr=parTrkCnfgTrafficClassAbr, parNetParmCbDelay=parNetParmCbDelay, parCmParmsMaxUpdates=parCmParmsMaxUpdates, parSysParmsMaxIphsdDelay=parSysParmsMaxIphsdDelay, parTrkLoadRcvUsedTs=parTrkLoadRcvUsedTs, parConfigParms=parConfigParms, parCmParmsResetTimer=parCmParmsResetTimer)

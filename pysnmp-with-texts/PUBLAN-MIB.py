#
# PySNMP MIB module PUBLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PUBLAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, ObjectIdentity, MibIdentifier, Unsigned32, NotificationType, mgmt, IpAddress, TimeTicks, NotificationType, ModuleIdentity, Counter64, Counter32, Gauge32, enterprises, Bits, private, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ObjectIdentity", "MibIdentifier", "Unsigned32", "NotificationType", "mgmt", "IpAddress", "TimeTicks", "NotificationType", "ModuleIdentity", "Counter64", "Counter32", "Gauge32", "enterprises", "Bits", "private", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

lucent = MibIdentifier((1, 3, 6, 1, 4, 1, 1751))
lucent_MIB = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2)).setLabel("lucent-MIB")
publan = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51))
pubStation = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 1))
pubClient = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 2))
publanInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3))
publanSNMPSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4))
publanPPPSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5))
publanAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6))
radius = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7))
publanShimECPSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 8))
pubStationTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15))
publanPHY = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2))
publanDriver = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 4))
pliSystemName = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliSystemName.setStatus('mandatory')
if mibBuilder.loadTexts: pliSystemName.setDescription('The sysName of the PubStation. This may be used for diagnostic purposes. This name will be the same as the sysName of the system group of MIB II')
pliNetworkName = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliNetworkName.setStatus('mandatory')
if mibBuilder.loadTexts: pliNetworkName.setDescription('The network name of this interface')
pliMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pliMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pliMACAddress.setDescription('The MAC address of this PubStation.')
pliMediumReservation = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2347))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliMediumReservation.setStatus('mandatory')
if mibBuilder.loadTexts: pliMediumReservation.setDescription('The medium reservation value. The range is 0 - 2347. Default is 2347 - means disabled. Medium reservation specifies the number of octets in a message above which a RTS/CTS handshake is performed.')
pliTransmitRate = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliTransmitRate.setStatus('mandatory')
if mibBuilder.loadTexts: pliTransmitRate.setDescription('The transmit rate of this interface.')
pliOperatingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliOperatingFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: pliOperatingFrequency.setDescription('The RF channel that the PubStation is working on.')
pliAPDensity = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pliAPDensity.setStatus('mandatory')
if mibBuilder.loadTexts: pliAPDensity.setDescription('The AP density in the region.')
pliClosedSystem = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pliClosedSystem.setStatus('mandatory')
if mibBuilder.loadTexts: pliClosedSystem.setDescription("This flag identifies whether the PubStation will accept associate requests from PubClients having a network name of 'ANY'. The PubStation should always be a closed station and such requests should always be rejected. This flag is provided for diagnostic purposes.")
pliAllowedDataRates = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pliAllowedDataRates.setStatus('mandatory')
if mibBuilder.loadTexts: pliAllowedDataRates.setDescription('this identifies the allowed data rates of the Wavelan Card')
pliDriverName = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 4, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pliDriverName.setStatus('mandatory')
if mibBuilder.loadTexts: pliDriverName.setDescription('The driver name.')
pliDriverVersion = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 3, 4, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pliDriverVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pliDriverVersion.setDescription("The driver's version number. This is a text string including the major and minor release number, and, optionally, the patch level: 'mm.nn.pp', where mm = major release number nn = point release number pp = optional patch number.")
psSNMPReadPassword = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 1), DisplayString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: psSNMPReadPassword.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPReadPassword.setDescription('The password for reading object values from the agent.')
psSNMPReadWritePassword = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 2), DisplayString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: psSNMPReadWritePassword.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPReadWritePassword.setDescription('The password for reading and modifying object values from the agent.')
psSNMPTrapHostIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psSNMPTrapHostIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPTrapHostIPAddress.setDescription('The IP address of the host to which traps should be sent.')
psSNMPTrapHostPassword = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psSNMPTrapHostPassword.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPTrapHostPassword.setDescription('The password sent with the trap to enable the management station to ignore unsolicited traps.')
psSNMPManagerCount = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psSNMPManagerCount.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPManagerCount.setDescription('The number of management stations that have been authorised to manage this PubStation.')
psSNMPAccessTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6), )
if mibBuilder.loadTexts: psSNMPAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPAccessTable.setDescription('The table containing the information about the managers authorised to manage this PubStation.')
psSNMPAccessTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6, 1), ).setIndexNames((0, "PUBLAN-MIB", "psSNMPManagerIndex"))
if mibBuilder.loadTexts: psSNMPAccessTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPAccessTableEntry.setDescription('The entry in the SNMP access table. Described next.')
index = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: index.setStatus('mandatory')
if mibBuilder.loadTexts: index.setDescription('Management station identification number. Is the index for the table.')
managerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: managerIPAddress.setDescription('IP address of the management station.')
managerIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerIPMask.setStatus('mandatory')
if mibBuilder.loadTexts: managerIPMask.setDescription('The IP subnet mask. Used to grant access to a complete subnet.')
managerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: managerStatus.setDescription('Whether the manager is enabled or disabled. Used to delete the unwanted entries.')
psSNMPInBadManagers = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psSNMPInBadManagers.setStatus('mandatory')
if mibBuilder.loadTexts: psSNMPInBadManagers.setDescription('The no of attempts to manage this PubStation by unauthorised managers.')
psPPPIPAddressAssignmentType = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPIPAddressAssignmentType.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPIPAddressAssignmentType.setDescription('This identifies whether the IP addresses assigned to the PubClients are obtained through APM (address pool manager), through DHCP or through the RADIUS server.')
psPPPStartIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPStartIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPStartIPAddress.setDescription('The start IP address that the PPP can use for assignment to clients.')
psPPPEndIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPEndIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPEndIPAddress.setDescription('The last IP address that the PPP can use for assignment to clients. Combined with the psPPPStartIPAddress, this specifies the range of addresses to be used.')
psPPPNoOfMACIPMappingEntries = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psPPPNoOfMACIPMappingEntries.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPNoOfMACIPMappingEntries.setDescription('The number of static mapping entries.')
psPPPMACIPMappingTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5), )
if mibBuilder.loadTexts: psPPPMACIPMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPMACIPMappingTable.setDescription('This table contains the static mapping of MAC addresses to IP addresses.')
psPPPMACIPMappingTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1), ).setIndexNames((0, "PUBLAN-MIB", "psPPPMACIPTableIndex"))
if mibBuilder.loadTexts: psPPPMACIPMappingTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPMACIPMappingTableEntry.setDescription('The entry of the psPPPMACIPMappingTable. Described below.')
index3 = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: index3.setStatus('mandatory')
if mibBuilder.loadTexts: index3.setDescription(' This is the index for the mappping table.')
macaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: macaddress.setStatus('mandatory')
if mibBuilder.loadTexts: macaddress.setDescription('This is the MAC address.')
ipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddress.setDescription('The IP address corresponding to the MAC address.')
comment = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comment.setStatus('mandatory')
if mibBuilder.loadTexts: comment.setDescription("The comment for thi entry, maybe the PC's owner.")
entrystatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("delete", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: entrystatus.setStatus('mandatory')
if mibBuilder.loadTexts: entrystatus.setDescription('Whether the entry is enabled or disabled. Used to delete the unwanted entries.')
psPPPKeepAliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPKeepAliveInterval.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPKeepAliveInterval.setDescription('The keep alive interval to be notified to the PPP layer.')
psPPPNoOfKeepAliveTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPNoOfKeepAliveTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPNoOfKeepAliveTimeouts.setDescription('The maximum number of timeouts before the session is torn down.')
psPPPDNSIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psPPPDNSIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPDNSIPAddress.setDescription('The IP address of the DNS server in the network.')
psPPPIPRangeTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20), )
if mibBuilder.loadTexts: psPPPIPRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPIPRangeTable.setDescription('This table contains the static mapping of MAC addresses to IP addresses.')
psPPPIPRangeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1), ).setIndexNames((0, "PUBLAN-MIB", "psPPPIPRangeTableIndex"))
if mibBuilder.loadTexts: psPPPIPRangeTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPIPRangeTableEntry.setDescription('The entry of the psPPPIPRangeTable. Described below.')
psPPPIPRangeTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 1), Integer32())
if mibBuilder.loadTexts: psPPPIPRangeTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psPPPIPRangeTableIndex.setDescription(' This is the index for the IP range table.')
poolStartIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: poolStartIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: poolStartIPAddress.setDescription('This is the staring IP address of this range.')
poolEndIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: poolEndIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: poolEndIPAddress.setDescription('This is the ending IP address of this range.')
numOfIPAddresss = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numOfIPAddresss.setStatus('mandatory')
if mibBuilder.loadTexts: numOfIPAddresss.setDescription('This is the withd of the range (no of addresses).')
comments = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comments.setStatus('mandatory')
if mibBuilder.loadTexts: comments.setDescription('Comment on the entry that is added')
status = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 5, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("enable", 1), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: status.setStatus('mandatory')
if mibBuilder.loadTexts: status.setDescription('The status of the entry, whether to be used or not used. Setting this to delete will remove this entry.')
psVersion = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psVersion.setStatus('mandatory')
if mibBuilder.loadTexts: psVersion.setDescription("The version of the PubStation software currently execuing. Would be text string including the major and minor release number, and, optionally, the patch level: 'mm.nn.pp', where mm = major release number nn = point release number pp = optional patch number.")
psIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psIPAddress.setDescription('The IP address to be assigned to the PubStation (to change from factory fitted IP address).')
psSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: psSubnetMask.setDescription('The subnet mask of the PubStation.')
psDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: psDefaultGateway.setDescription('The default gateway for the PubStation.')
psIPAddressType = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psIPAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: psIPAddressType.setDescription('This can be DHCP or static. The IP address of the PubStation will be assigned based on this.')
psAdministrativeState = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psAdministrativeState.setStatus('mandatory')
if mibBuilder.loadTexts: psAdministrativeState.setDescription('The administrative state of the substation, can be Up or Down.')
psTFTPIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psTFTPIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: psTFTPIPAddress.setDescription('The IP address of the TFTP server.')
psTFTPFilename = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psTFTPFilename.setStatus('mandatory')
if mibBuilder.loadTexts: psTFTPFilename.setDescription('The filename of the image in the TFTP server.')
psTFTPOperation = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: psTFTPOperation.setStatus('mandatory')
if mibBuilder.loadTexts: psTFTPOperation.setDescription('The operation to be done, can be upload or download.')
psReboot = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 6, 10), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: psReboot.setStatus('mandatory')
if mibBuilder.loadTexts: psReboot.setDescription('This variable must be set to reboot the PubStation. The value is the number of seconds to wait to do a reboot.')
radiusClientMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2))
radiusClientMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1))
radiusClient = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1))
radiusClientInvalidServerAddresses = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radiusClientInvalidServerAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: radiusClientInvalidServerAddresses.setDescription('The total number of RADIUS Access-Response messages received from unknown addresses since client start-up')
radiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2), )
if mibBuilder.loadTexts: radiusServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: radiusServerTable.setDescription('The (conceptual) table listing the RADIUS servers with which the client shares a secret.')
radiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1), ).setIndexNames((0, "PUBLAN-MIB", "radiusServerIndex"))
if mibBuilder.loadTexts: radiusServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: radiusServerEntry.setDescription('An entry (conceptual row) representing a RADIUS server with which the client shares a secret.')
index4 = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: index4.setStatus('mandatory')
if mibBuilder.loadTexts: index4.setDescription('The RADIUS server with whom the client interacts.')
type = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auth", 1), ("acct", 2), ("auth-and-acct", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: type.setStatus('mandatory')
if mibBuilder.loadTexts: type.setDescription('The RADIUS server type (Authentication or Accounting or Both). For creating a server entry Server Type should be set')
serverIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serverIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: serverIPAddress.setDescription('The IP address of the RADIUS server referred to in this table entry.')
destPortAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destPortAuth.setStatus('mandatory')
if mibBuilder.loadTexts: destPortAuth.setDescription(' The Authentication port of the RADIUS Server.')
destPortAcct = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destPortAcct.setStatus('mandatory')
if mibBuilder.loadTexts: destPortAcct.setDescription(' The Accounting port of the RADIUS Server.')
accessRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessRequests.setStatus('mandatory')
if mibBuilder.loadTexts: accessRequests.setDescription('The total number of RADIUS Access-Request messages sent since client start-up')
accessRetransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessRetransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: accessRetransmissions.setDescription('The total number of RADIUS Access-Request messages retransmitted since client start-up')
accessAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessAccepts.setStatus('mandatory')
if mibBuilder.loadTexts: accessAccepts.setDescription('The total number of RADIUS Access-Accept messages received since client start-up')
accessChallenges = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessChallenges.setStatus('mandatory')
if mibBuilder.loadTexts: accessChallenges.setDescription('The total number of RADIUS Access-Challenge messages received since client start-up')
malformedAccessResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: malformedAccessResponses.setStatus('mandatory')
if mibBuilder.loadTexts: malformedAccessResponses.setDescription('The total number of malformed RADIUS Access-Response messages received since client start-up')
authenticationBadAuthenticators = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticationBadAuthenticators.setStatus('mandatory')
if mibBuilder.loadTexts: authenticationBadAuthenticators.setDescription('The total number of RADIUS Access-Response messages containing invalid authenticators received since client start-up')
accessRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessRejects.setStatus('mandatory')
if mibBuilder.loadTexts: accessRejects.setDescription('The total number of RADIUS Access-Reject messages sent since client start-up')
timeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeouts.setStatus('mandatory')
if mibBuilder.loadTexts: timeouts.setDescription('The total number of timeouts since client startup')
accountingRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accountingRequests.setStatus('mandatory')
if mibBuilder.loadTexts: accountingRequests.setDescription('The total number of RADIUS Accounting-Request messages sent since client start-up')
accountingRetransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accountingRetransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: accountingRetransmissions.setDescription('The total number of RADIUS Accounting-Request messages retransmitted since client start-up')
accountingResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accountingResponses.setStatus('mandatory')
if mibBuilder.loadTexts: accountingResponses.setDescription('The total number of RADIUS Accounting-Response messages received since client start-up')
accountingBadAuthenticators = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accountingBadAuthenticators.setStatus('mandatory')
if mibBuilder.loadTexts: accountingBadAuthenticators.setDescription('The total number of RADIUS Accounting-Response messages which contained invalid authenticators received since client start-up')
sharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedSecret.setStatus('mandatory')
if mibBuilder.loadTexts: sharedSecret.setDescription('The secret string which is shared between Server and Client')
enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabled.setStatus('mandatory')
if mibBuilder.loadTexts: enabled.setDescription('Flag to tell whether the server is active or Inactive')
responseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("one-sec", 1), ("two-secs", 2), ("three-secs", 3), ("four-secs", 4), ("five-secs", 5), ("six-secs", 6), ("seven-secs", 7), ("eight-secs", 8), ("nine-secs", 9), ("ten-secs", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: responseTime.setStatus('mandatory')
if mibBuilder.loadTexts: responseTime.setDescription('The maximum time within which the server has to respond for a request from the client')
maximumRetransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 1, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maximumRetransmission.setStatus('mandatory')
if mibBuilder.loadTexts: maximumRetransmission.setDescription('The allowed maximum no. of trials to be tried by a client to get response from the server for a request')
radiusClientMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 2))
radiusClientMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 2, 1))
radiusClientMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 7, 2, 2, 2))
psShimECPRetransmissionCount = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 8, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psShimECPRetransmissionCount.setStatus('mandatory')
if mibBuilder.loadTexts: psShimECPRetransmissionCount.setDescription('The number of retransmissions when responses are not received with the timeout period.')
psShimECPRepeatResponseCount = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psShimECPRepeatResponseCount.setStatus('mandatory')
if mibBuilder.loadTexts: psShimECPRepeatResponseCount.setDescription('The number of time the transmitted response can be retransmitted.')
psShimECPRetransmissionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 8, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psShimECPRetransmissionTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: psShimECPRetransmissionTimeout.setDescription('The timeout interval for a response to be received.')
pubStationTrapVariables = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 1))
pubStationMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 1, 1), PhysAddress())
if mibBuilder.loadTexts: pubStationMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pubStationMacAddress.setDescription('The MAC address that is sent with the traps to identify which PubStation has the problem ')
pubStationFlashRelatedTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 2))
pubStationFlashNotPresent = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 2) + (0,1))
if mibBuilder.loadTexts: pubStationFlashNotPresent.setDescription('This trap is sent when the FLASH is missing.')
pubStationFlashEmpty = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 2) + (0,2))
if mibBuilder.loadTexts: pubStationFlashEmpty.setDescription('This trap is sent when the FLASH is empty.')
pubStationFlashCorrupted = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 2) + (0,3))
if mibBuilder.loadTexts: pubStationFlashCorrupted.setDescription('This trap is sent when the data in the FLASH is corrupted.')
pubStationConfigurationRelatedTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 3))
pubStationInvalidKey = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 3) + (0,1))
if mibBuilder.loadTexts: pubStationInvalidKey.setDescription('This trap is sent when an invalid key is detected at the PubStation.')
pubStationAPMNotConfigured = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 3) + (0,2))
if mibBuilder.loadTexts: pubStationAPMNotConfigured.setDescription('This trap is sent when the APM information is not configured in the PubStation.')
pubStationIncompatibleWavelanCard = NotificationType((1, 3, 6, 1, 4, 1, 1751, 2, 51, 15, 3) + (0,3))
if mibBuilder.loadTexts: pubStationIncompatibleWavelanCard.setDescription('This trap is sent when the wavelan card plugged in the PubStation is not compatible with the firmware versions supported.')
mibBuilder.exportSymbols("PUBLAN-MIB", status=status, psPPPMACIPMappingTableEntry=psPPPMACIPMappingTableEntry, enabled=enabled, psShimECPRetransmissionTimeout=psShimECPRetransmissionTimeout, pubStationTrapVariables=pubStationTrapVariables, pliClosedSystem=pliClosedSystem, pubClient=pubClient, publanSNMPSetup=publanSNMPSetup, accountingRetransmissions=accountingRetransmissions, numOfIPAddresss=numOfIPAddresss, pubStationFlashCorrupted=pubStationFlashCorrupted, index4=index4, pubStationInvalidKey=pubStationInvalidKey, psDefaultGateway=psDefaultGateway, radiusClientInvalidServerAddresses=radiusClientInvalidServerAddresses, lucent_MIB=lucent_MIB, psSNMPAccessTable=psSNMPAccessTable, ipAddress=ipAddress, maximumRetransmission=maximumRetransmission, poolStartIPAddress=poolStartIPAddress, psShimECPRetransmissionCount=psShimECPRetransmissionCount, publanDriver=publanDriver, psPPPEndIPAddress=psPPPEndIPAddress, pubStationFlashRelatedTraps=pubStationFlashRelatedTraps, accessRejects=accessRejects, psPPPNoOfMACIPMappingEntries=psPPPNoOfMACIPMappingEntries, pubStationMacAddress=pubStationMacAddress, publanAgent=publanAgent, pubStation=pubStation, radiusClientMIBGroups=radiusClientMIBGroups, pubStationIncompatibleWavelanCard=pubStationIncompatibleWavelanCard, psShimECPRepeatResponseCount=psShimECPRepeatResponseCount, pliOperatingFrequency=pliOperatingFrequency, psTFTPOperation=psTFTPOperation, accessAccepts=accessAccepts, timeouts=timeouts, psSNMPManagerCount=psSNMPManagerCount, destPortAcct=destPortAcct, psPPPDNSIPAddress=psPPPDNSIPAddress, publanShimECPSetup=publanShimECPSetup, accessChallenges=accessChallenges, psPPPIPAddressAssignmentType=psPPPIPAddressAssignmentType, pliAllowedDataRates=pliAllowedDataRates, publanPPPSetup=publanPPPSetup, index3=index3, psSubnetMask=psSubnetMask, psSNMPReadPassword=psSNMPReadPassword, pliAPDensity=pliAPDensity, psIPAddress=psIPAddress, pliTransmitRate=pliTransmitRate, psIPAddressType=psIPAddressType, pubStationFlashNotPresent=pubStationFlashNotPresent, publan=publan, pliMACAddress=pliMACAddress, pliDriverName=pliDriverName, psVersion=psVersion, radiusClientMIBConformance=radiusClientMIBConformance, poolEndIPAddress=poolEndIPAddress, pliNetworkName=pliNetworkName, pubStationTraps=pubStationTraps, malformedAccessResponses=malformedAccessResponses, pliSystemName=pliSystemName, radiusServerTable=radiusServerTable, managerStatus=managerStatus, pubStationFlashEmpty=pubStationFlashEmpty, DisplayString=DisplayString, type=type, psSNMPTrapHostPassword=psSNMPTrapHostPassword, radiusClientMIBCompliances=radiusClientMIBCompliances, pubStationConfigurationRelatedTraps=pubStationConfigurationRelatedTraps, psPPPMACIPMappingTable=psPPPMACIPMappingTable, psPPPKeepAliveInterval=psPPPKeepAliveInterval, accessRetransmissions=accessRetransmissions, accountingRequests=accountingRequests, destPortAuth=destPortAuth, radius=radius, PhysAddress=PhysAddress, psTFTPFilename=psTFTPFilename, psAdministrativeState=psAdministrativeState, radiusClientMIB=radiusClientMIB, psSNMPAccessTableEntry=psSNMPAccessTableEntry, psPPPIPRangeTableIndex=psPPPIPRangeTableIndex, accountingResponses=accountingResponses, accessRequests=accessRequests, sharedSecret=sharedSecret, psReboot=psReboot, pubStationAPMNotConfigured=pubStationAPMNotConfigured, responseTime=responseTime, radiusClientMIBObjects=radiusClientMIBObjects, accountingBadAuthenticators=accountingBadAuthenticators, macaddress=macaddress, pliMediumReservation=pliMediumReservation, authenticationBadAuthenticators=authenticationBadAuthenticators, psSNMPReadWritePassword=psSNMPReadWritePassword, psSNMPInBadManagers=psSNMPInBadManagers, comment=comment, psSNMPTrapHostIPAddress=psSNMPTrapHostIPAddress, serverIPAddress=serverIPAddress, lucent=lucent, psTFTPIPAddress=psTFTPIPAddress, managerIPAddress=managerIPAddress, pliDriverVersion=pliDriverVersion, radiusClient=radiusClient, managerIPMask=managerIPMask, entrystatus=entrystatus, psPPPNoOfKeepAliveTimeouts=psPPPNoOfKeepAliveTimeouts, index=index, comments=comments, publanPHY=publanPHY, radiusServerEntry=radiusServerEntry, psPPPIPRangeTable=psPPPIPRangeTable, psPPPIPRangeTableEntry=psPPPIPRangeTableEntry, publanInterface=publanInterface, psPPPStartIPAddress=psPPPStartIPAddress)

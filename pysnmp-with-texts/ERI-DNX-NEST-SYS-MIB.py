#
# PySNMP MIB module ERI-DNX-NEST-SYS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ERI-DNX-NEST-SYS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:05:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
devices, dnxTrapEnterprise, dnx, database, NestSlotAddress, DecisionType, UnsignedInt, trapSequence, sysMgr = mibBuilder.importSymbols("ERI-DNX-SMC-MIB", "devices", "dnxTrapEnterprise", "dnx", "database", "NestSlotAddress", "DecisionType", "UnsignedInt", "trapSequence", "sysMgr")
eriMibs, = mibBuilder.importSymbols("ERI-ROOT-SMI", "eriMibs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, iso, TimeTicks, ModuleIdentity, IpAddress, Counter64, Gauge32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Unsigned32, NotificationType, ObjectIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "iso", "TimeTicks", "ModuleIdentity", "IpAddress", "Counter64", "Gauge32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Unsigned32", "NotificationType", "ObjectIdentity", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
eriDNXNestSysMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 644, 3, 14))
eriDNXNestSysMIB.setRevisions(('2003-07-17 00:00', '2002-05-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: eriDNXNestSysMIB.setRevisionsDescriptions(('Nevio Poljak - eri_DnxNest MIB Rev 01.4 (SW Rel. 16.0) Added new Configuration Error Device States for display in the slot tables to support bug #6447.', 'Nevio Poljak - eri_DnxNest MIB Rev 01.0 Initial Release of this MIB.',))
if mibBuilder.loadTexts: eriDNXNestSysMIB.setLastUpdated('200307170000Z')
if mibBuilder.loadTexts: eriDNXNestSysMIB.setOrganization('Eastern Research, Inc.')
if mibBuilder.loadTexts: eriDNXNestSysMIB.setContactInfo('Customer Service Postal: Eastern Research, Inc. 225 Executive Drive Moorestown, NJ 08057 Phone: +1-800-337-4374 Email: support@erinc.com')
if mibBuilder.loadTexts: eriDNXNestSysMIB.setDescription('The ERI Enterprise MIB Module for the DNX Nest System Admistration.')
class DnxSlotDeviceType(TextualConvention, Integer32):
    description = 'Determines the Device Card type in the slot.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 26, 27, 28, 29, 30, 31))
    namedValues = NamedValues(("slot", 0), ("octal-t1e1", 1), ("quadHighSpeed", 2), ("octalHighSpeed", 3), ("quadOcu", 4), ("smc", 5), ("quad-t1", 6), ("ds3", 7), ("testAccess", 8), ("octalVoice", 9), ("powerSupply", 14), ("psx", 15), ("router", 16), ("sts1", 17), ("hds3", 18), ("gr303", 19), ("xcc", 20), ("xlc", 21), ("xnm", 22), ("ds0dp", 25), ("stm1", 26), ("oc3", 27), ("e3", 28), ("xlc-ot1e1", 29), ("stm1X", 30), ("oc3X", 31))

class DnxSlotDeviceState(TextualConvention, Integer32):
    description = 'Determines state of the Device Card in the configured slot.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))
    namedValues = NamedValues(("not-present", 0), ("online", 1), ("offline", 2), ("disabled", 3), ("standby", 4), ("defective", 5), ("busError", 6), ("outOfService", 7), ("configError", 8), ("online-online", 11), ("online-offline", 12), ("online-standby", 13), ("online-defective", 14), ("online-busError", 15), ("online-oos", 16), ("standby-online", 17), ("standby-offline", 18), ("standby-standby", 19), ("standby-defective", 20), ("standby-busError", 21), ("standby-oos", 22), ("online-cfgError", 23), ("standby-cfgError", 24))

slotConfigTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3), )
if mibBuilder.loadTexts: slotConfigTable.setStatus('current')
if mibBuilder.loadTexts: slotConfigTable.setDescription('A list of the device cards in this node with the static and dynamic type information. The maximum number of entries depends on the number of slots in the system plus 3 default entries for the system manager cards and the Protection Switch.')
slotConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "slotNbr"))
if mibBuilder.loadTexts: slotConfigEntry.setStatus('current')
if mibBuilder.loadTexts: slotConfigEntry.setDescription("The conceptual row of the Slot Configuration table. A row in this table can not be created or deleted. A row in this table can be modified by providing valid values for either the Slot Name, Configured Device Type, Device Redundancy, or Slot Command Status. Deleting the Slot Configuration using the Slot Command Status value of 'delete-slot-config' will result in the removal of all configured connections associated with that slot number. The slotConfigCmdStatus field must be included as a variable in a SET PDU for the action to take effect. If the slotConfigCmdStatus is missing from the SET PDU, the GET RESPONSE will contain the SNMP error status of 'genErr' for and an error index equal to the last variable.")
slotNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotNbr.setStatus('current')
if mibBuilder.loadTexts: slotNbr.setDescription(' The slot number in the node.')
slotConfigDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 2), DnxSlotDeviceType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotConfigDeviceType.setStatus('current')
if mibBuilder.loadTexts: slotConfigDeviceType.setDescription(" This is the slot type configured by the user. The value, slot(0) is the default type for an unconfigured device. If slot(0) is used in a Set Request, the agent will return an error status of 'badValue'. The slot entries representing the System Manager Cards and the Protection Switch device cannot be used in a Set Request since their device type is static.")
slotActualDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 3), DnxSlotDeviceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotActualDeviceType.setStatus('current')
if mibBuilder.loadTexts: slotActualDeviceType.setDescription(' This is the actual slot type sent back by the card. ')
slotDeviceState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 4), DnxSlotDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotDeviceState.setStatus('current')
if mibBuilder.loadTexts: slotDeviceState.setDescription(' The current machine state of the device. not-present (0) Indicates no hardware detected in the slot. online (1) Device is present and is considered primary operational. offline (2) Device is present but currently not operational. disabled (3) Applies to the Protection Switch box if system cannot support redundancy. standby (4) Device is present but considered as secondary. defective (5) Device is present but could not be activated. bus-error (6) Device is present and reporting a bus connection error. out-of-serv (7) Operator has placed device in Out of Service mode.')
slotAlarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("no-alarm", 0), ("minor-level", 1), ("major-level", 2), ("major-minor", 3), ("critical-level", 4), ("critical-minor", 5), ("critical-major", 6), ("critical-major-minor", 7), ("unknown", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: slotAlarmLevel.setDescription(" The current slot device alarm condition level that indicates it's severity. ")
slotDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotDeviceName.setStatus('current')
if mibBuilder.loadTexts: slotDeviceName.setDescription('The user defined name for this slot/device.')
slotDeviceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotDeviceVersion.setStatus('current')
if mibBuilder.loadTexts: slotDeviceVersion.setDescription('The software version release identification number for this device. ')
slotDeviceRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1), ("notApplicable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotDeviceRedundancy.setStatus('current')
if mibBuilder.loadTexts: slotDeviceRedundancy.setDescription('The configured N+1 Redundancy state of the device. The slot entries representing the System Manager Cards and the Protection Switch device cannot be used in a Set Request since N+1 Redundancy does not apply to them. disable (0) Device is not configured as part of the Redundancy Group. enable (1) Device is configured as part of the Redundancy Group. n/a (2) Device does not support Redundancy.')
slotMiscState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("errors", 1), ("test", 2), ("errors-test", 3), ("clockSrc", 4), ("errors-clockSrc", 5), ("test-clockSrc", 6), ("errors-test-clockSrc", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotMiscState.setStatus('current')
if mibBuilder.loadTexts: slotMiscState.setDescription('The current slot/device miscellaneous state conditions. none (0) no misc condition errors (1) errors reported on device test (2) device is in test mode errors-test (3) errors reported on device while in test mode clockSrc (4) device is the source for the system clock errors-clockSrc (5) device is the source for the system clock and errors found test-clockSrc (6) device is the source for the system clock and is in test mode errors-test-clockSrc (7) device is the source for the system clock and is in test mode and errors were found')
slotConfigCmdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 10, 11, 101, 102, 110, 111, 200, 201, 202, 203, 204, 205, 207, 208, 450, 500, 501, 502))).clone(namedValues=NamedValues(("ready-for-command", 0), ("update-slot-config", 1), ("delete-slot-config", 2), ("ndr-switchover", 10), ("ndr-restore", 11), ("update-successful", 101), ("delete-successful", 102), ("switch-successful", 110), ("restore-successful", 111), ("err-general-slot-config-error", 200), ("err-invalid-slot-type", 201), ("err-invalid-slot-command", 202), ("err-invalid-slot-name", 203), ("err-redundancy-disabled", 204), ("err-cannot-chg-sys-device", 205), ("err-invalid-redundancy-state", 207), ("err-cannot-delete-online-device", 208), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotConfigCmdStatus.setStatus('current')
if mibBuilder.loadTexts: slotConfigCmdStatus.setDescription('The command status for this slot configuration row/record. The value used in a SET will be replaced by a response value in the GET RESPONSE indicating success or failure. Default Response State used in GET RESPONSE Command ready-for-command (0) initial default status for a row Slot Device Commands used in SET Command (1..99) update-slot-config (1) change an aspect of current slot configuration delete-slot-config (2) remove existing Slot Configuration. Deleting the Slot Configuration using the Slot Command Status will result in the removal of all configured connections associated with that slot number. ndr-switchover (10) force a switchover to the Standby device ndr-restore (11) force a restore back to the original device Response States used in GET RESPONSE Command (100..199) update-successful (101) slot data has been successfully changed delete-successful (102) slot data has been successfully removed switch-successful (110) Slot N+1 Redundancy device has been successfully switched over to Standby device restore-successful (111) Slot N+1 Redundancy device has been successfully restored back to Primary device Slot Config Error Codes used in GET RESPONSE Command (200..799) err-general-slot-config-error (200) Unknown slot configuration error occurred. err-invalid-slot-type (201) Configured slot type not in valid range err-invalid-slot-command (202) Unrecognized slot command-action err-invalid-slot-name (203) Configured slot name too long err-redundancy-disabled (204) Redundancy disabled on this system or does not apply to device type err-cannot-chg-sys-device (205) System Device type does not support configuration change err-invalid-redundancy-state (207) Redundancy state does not apply or invalid err-cannot-delete-online-device (208) Device cannot be present when deleting configuration err-data-locked-by-another-user (450) Another administrative user is making changes to this part of the system via a terminal session. Check Event Log for user name err-snmp-parse-failed (500) Agent could not parse variable err-invalid-snmp-type (501) Variable ASN type does not match Agent defined type err-invalid-snmp-var-size (502) Variable size is too big')
numberSlots = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSlots.setStatus('obsolete')
if mibBuilder.loadTexts: numberSlots.setDescription(' This is the number of slots in the node.')
softwareRelease = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareRelease.setStatus('obsolete')
if mibBuilder.loadTexts: softwareRelease.setDescription('In the form Release x.xx where x.xx is the release number.')
redundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9))
ndrEnabled = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 1), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrEnabled.setStatus('current')
if mibBuilder.loadTexts: ndrEnabled.setDescription("Indicates the system's capability of supporting the N+1 Device Redundancy functionality. The user should configure this variable based on the existence of the Protection Switch Box (PSX) Device. The ndrState will reflect the actual status of N+1 Redundancy. no (0) No PSX attached, N+1 Redundancy disabled. yes (1) PSX attached, N+1 Redundancy enabled.")
ndrState = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("frozen", 2), ("delayed", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrState.setStatus('current')
if mibBuilder.loadTexts: ndrState.setDescription('This is the current N+1 Device Redundancy state. disabled (1) N+1 Redundancy disabled by the user. frozen (2) N+1 Redundancy is not active due to missing hardware components. delayed (3) N+1 Redundancy is delayed due to switchover. enabled (4) N+1 Redundancy enabled and ready.')
ndrAutoSwitchover = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 0), ("automatic", 1), ("narrowband-auto", 2), ("broadband-1-auto", 3), ("broadband-2-auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrAutoSwitchover.setStatus('current')
if mibBuilder.loadTexts: ndrAutoSwitchover.setDescription("Indicates the user's desired N+1 Device Redundancy automatic Switchover setting when a primary card fails. manual (0) Failed cards will not be switched automatically by the system. User is required to go to Node Summary Console screen and force a manual switchover of the failed card to the Redundant. automatic (1) The system will automatically switch out failed cards for either NDR Group with the Redundant card. narrowband-auto (2) The system will automatically switch out a failed card for the NDR Narrowband Group with the Redundant. broadband-1-auto(3) The system will automatically switch out a failed card for the NDR Broadband Group 1 with the Redundant. broadband-2-auto(4) The system will automatically switch out a failed card for the NDR Broadband Group 2 with the Redundant.")
ndrAutoRestore = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 0), ("automatic", 1), ("narrowband-auto", 2), ("broadband-1-auto", 3), ("broadband-2-auto", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrAutoRestore.setStatus('current')
if mibBuilder.loadTexts: ndrAutoRestore.setDescription("Indicates the system's N+1 Device Redundancy automatic Restore setting when a protected card becomes operational. manual (0) Protected cards that become operational will not be restored automatically by the system. User is required to go to Node Summary Console screen and force a manual switchover of the Redundant card back to the Primary card. automatic (1) The system will automatically restore protected cards that become operational for either NDR Group. narrowband-auto (2) The system will automatically restore protected cards that become operational for the NDR Narrowband Group. broadband-1-auto(3) The system will automatically restore protected cards that become operational for the NDR Broadband Group 1. broadband-2-auto(4) The system will automatically restore protected cards that become operational for the NDR Broadband Group 2.")
ndrBroadbandGroup1 = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrBroadbandGroup1.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup1.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Broadband Group 1. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Group 1 N+1 Redundancy Group.')
ndrNarrowbandGroup = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrNarrowbandGroup.setStatus('current')
if mibBuilder.loadTexts: ndrNarrowbandGroup.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Narrowband Group. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Narrowband N+1 Redundancy Group.')
ndrBroadbandGroup1Protected = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(8, 10), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrBroadbandGroup1Protected.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup1Protected.setDescription('This is a slot number that indicates which device card from the active NDR Broadband Group 1 has been currently switched over. Valid Protected slots for NDR Broadband Group1 are 8 through 10. If a zero value is returned, no device card is currently protected.')
ndrNarrowbandProtected = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 11), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrNarrowbandProtected.setStatus('current')
if mibBuilder.loadTexts: ndrNarrowbandProtected.setDescription('This is a slot number that indicates which device card from the active NDR Narrowband Group has been currently switched over. Valid Protected slots for NDR Narrowband Group are 2 through 11. If a zero value is returned, no device card is currently protected.')
ndrBroadbandGroup1Type = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 18, 21, 31))).clone(namedValues=NamedValues(("ds3", 8), ("sts1", 18), ("hds3", 21), ("e3", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrBroadbandGroup1Type.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup1Type.setDescription('This indicates which type of device is currently occupying the status of active NDR Broadband Group 1. Only one type of broadband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Broadband Group 1 type should match the device type of the card in Slot 11, which is the designated Broadband Group 1 NDR Redundant slot.')
ndrNarrowbandType = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13, 22))).clone(namedValues=NamedValues(("octalT1E1", 13), ("gr303", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrNarrowbandType.setStatus('current')
if mibBuilder.loadTexts: ndrNarrowbandType.setDescription('This indicates which type of device is currently occupying the status of active NDR Narrowband Group. Only one type of Narrowband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Narrowband type should match the device type of the card in Slot 1, which is the designated Narrowband NDR Redundant slot.')
ndrDualBroadbandEnabled = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 11), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrDualBroadbandEnabled.setStatus('current')
if mibBuilder.loadTexts: ndrDualBroadbandEnabled.setDescription("Indicates the system's capability of supporting the N+1 Device Redundancy Dual Broadband Group functionality. The user should configure this variable based on the existence of the Upgraded PSX Hardware. no (0) PSX Dual Broadband Groups disabled or not supported. yes (1) PSX Dual Broadband Groups enabled.")
ndrBroadbandGroup2 = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrBroadbandGroup2.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup2.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Broadband Group 2. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Group 2 N+1 Redundancy Group.')
ndrBroadbandGroup2Protected = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndrBroadbandGroup2Protected.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup2Protected.setDescription('This is a slot number that indicates which device card from the active NDR Broadband Group 2 has been currently switched over. Valid Protected slots for NDR Broadband Group2 are 1 through 6. If a zero value is returned, no device card is currently protected.')
ndrBroadbandGroup2Type = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 18, 21, 31))).clone(namedValues=NamedValues(("ds3", 8), ("sts1", 18), ("hds3", 21), ("e3", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrBroadbandGroup2Type.setStatus('current')
if mibBuilder.loadTexts: ndrBroadbandGroup2Type.setDescription('This indicates which type of device is currently occupying the status of active NDR Broadband Group 2. Only one type of broadband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Broadband Group 2 type should match the device type of the card in Slot 7, which is the designated Broadband Group 2 NDR Redundant slot.')
ndrPsxChassisType = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 9, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("psx5200", 0), ("psx5300", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndrPsxChassisType.setStatus('current')
if mibBuilder.loadTexts: ndrPsxChassisType.setDescription('This indicates which type of Protection Switch Chassis Hardware has been detected. In order to run with Dual Broadband Group configuration, this value should be set to psx5300.')
upgradeSw = MibIdentifier((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10))
devDownloadTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1), )
if mibBuilder.loadTexts: devDownloadTable.setStatus('current')
if mibBuilder.loadTexts: devDownloadTable.setDescription('A Table listing the files one could download from smc to a device card using TFTP')
devDownloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "programFileIndex"))
if mibBuilder.loadTexts: devDownloadEntry.setStatus('current')
if mibBuilder.loadTexts: devDownloadEntry.setDescription('An entry in the Device Download Table')
programFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: programFileIndex.setStatus('current')
if mibBuilder.loadTexts: programFileIndex.setDescription('The index of the program file available for download')
programFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: programFileName.setStatus('current')
if mibBuilder.loadTexts: programFileName.setDescription('The name of the program file available for download')
programFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: programFileSize.setStatus('current')
if mibBuilder.loadTexts: programFileSize.setDescription('The size in bytes of the program file available for download')
programLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loadingProgramFile", 1), ("readyForProgramLoad", 2), ("swDownloadNotReady", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: programLoadStatus.setStatus('current')
if mibBuilder.loadTexts: programLoadStatus.setDescription('The load status of the program file')
programLoadInitiator = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: programLoadInitiator.setStatus('current')
if mibBuilder.loadTexts: programLoadInitiator.setDescription('The name of the user who initiated the program file download')
programBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: programBytesSent.setStatus('current')
if mibBuilder.loadTexts: programBytesSent.setDescription('The number of bytes sent in the current program file download')
programSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: programSlotNumber.setStatus('current')
if mibBuilder.loadTexts: programSlotNumber.setDescription('The slot number to which a program file is to be downloaded')
programFileCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 9, 10, 12, 13, 414, 450, 500, 501, 502))).clone(namedValues=NamedValues(("loadProgramFile", 1), ("loadProgramToAll", 2), ("deleteProgramFile", 4), ("readyForCommand", 5), ("err-invalid-slot-nbr", 6), ("noProgramFile", 7), ("programFileBusy", 8), ("noError", 9), ("slotNotReady", 10), ("programFileIdle", 12), ("err-invalid-nest-nbr", 13), ("err-invalid-command", 414), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: programFileCommand.setStatus('current')
if mibBuilder.loadTexts: programFileCommand.setDescription('The command to change the load status of the program file, or an error returned from a command.')
programNestNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 10))).clone(namedValues=NamedValues(("nest1", 0), ("nest2", 1), ("nest3", 2), ("nest4", 3), ("nest5", 4), ("nest6", 5), ("nest7", 6), ("nest8", 7), ("allNests", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: programNestNumber.setStatus('current')
if mibBuilder.loadTexts: programNestNumber.setDescription('The Nest number to which a program file is to be downloaded. If this field is not included in the SET PDU, the file will be downloaded to the specified slot in the First Nest (nest1).')
eXpansionNestAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11))
xNestCfgTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1), )
if mibBuilder.loadTexts: xNestCfgTable.setStatus('current')
if mibBuilder.loadTexts: xNestCfgTable.setDescription('A list of the Configured and Unconfigured Nests in this node with the static and dynamic type information. The maximum number of entries is 8 nests but if this is an Stand-Alone DNX-11 system, only 1 nest entry will be returned.')
xNestCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "xNestIndex"))
if mibBuilder.loadTexts: xNestCfgEntry.setStatus('current')
if mibBuilder.loadTexts: xNestCfgEntry.setDescription("The conceptual row of the Nest Configuration table. A row in this table can not be created or deleted. A row in this table can be modified by providing valid values for either the Nest Name, Configured Nest Type, NDR Capability, Alarm Contacts, Dual SMCs, Dual XLCs or XCCs, or Nest Command Status. Deleting the Nest Configuration using the Nest Command Status value of 'delete-nest-config' will result in the removal of all configured slots, ports, & connections associated with that nest number. The xNestCmdStatus field must be included as a variable in a SET PDU for the action to take effect. If the xNestCmdStatus is missing from the SET PDU, the GET RESPONSE will contain the SNMP error status of 'genErr' for and an error index equal to the last variable.")
xNestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNestIndex.setStatus('current')
if mibBuilder.loadTexts: xNestIndex.setDescription(' The nest index number in the node. Nests are indexed 0 through 7 but correspond to Nests 1 to 8.')
xNestUnitName = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestUnitName.setStatus('current')
if mibBuilder.loadTexts: xNestUnitName.setDescription('The user defined name for this nest.')
xNestType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notConfig", 0), ("dnx4", 1), ("dnx11", 2), ("stm1X-oc3X", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestType.setStatus('current')
if mibBuilder.loadTexts: xNestType.setDescription("This is the nest type configured by the user. The value, notConfig(0), is the default type for an unconfigured device. Note, if notConfig(0) or stm1X-oc3X(3) is used in a Set Request, the agent will return an error status of 'badValue'. Virtual stm1X-oc3X Nests are configured automatically by the system whenever the user Assigns an available Nest to an STM1X or OC3X Device pair. This can be done via the opticalDevConfigTable after a STM1X or OC3X card has been configured in a Even numbered slot.")
xNestState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 8, 12, 16, 32))).clone(namedValues=NamedValues(("mismatch", 2), ("notPresent", 8), ("missing", 12), ("online", 16), ("offline", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNestState.setStatus('current')
if mibBuilder.loadTexts: xNestState.setDescription(' The current machine state of the Nests. mismatch (2) Nest is configured as wrong type. notPresent (8) Nest is unconfigured. missing (12) Nest is configured but communications are down. online (16) Nest is present and operational. offline (32) Nest is present but currently not operational.')
xNestAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("no-alarm", 0), ("minor-level", 1), ("major-level", 2), ("major-minor", 3), ("critical-level", 4), ("critical-minor", 5), ("critical-major", 6), ("critical-major-minor", 7), ("unknown", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNestAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: xNestAlarmStatus.setDescription(" The current nest device alarm condition level that indicates it's severity. ")
xNestDeviceCards = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNestDeviceCards.setStatus('current')
if mibBuilder.loadTexts: xNestDeviceCards.setDescription('The number of device cards presently active in the nest.')
xNestNDRCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 7), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestNDRCapable.setStatus('current')
if mibBuilder.loadTexts: xNestNDRCapable.setDescription('The configured N+1 Redundancy state of the Nest. no (0) N+1 Redundancy is not available in the Nest. yes (1) N+1 Redundancy is available in the Nest.')
xNestAlarmContacts = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("standard", 0), ("localAudio1", 1), ("localAudio2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestAlarmContacts.setStatus('current')
if mibBuilder.loadTexts: xNestAlarmContacts.setDescription('Determines the type of desired response from the rear SMC/XNM Alarm Contact switches during an alarm event.')
xNestDualSMCs = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 9), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestDualSMCs.setStatus('current')
if mibBuilder.loadTexts: xNestDualSMCs.setDescription("The number of SMCs configured for the Nest. If running with only a single SMC, this should be set to 'no' in order to suppress unecessary alarms. no (0) Only 1 SMC resides in the Nest. yes (1) Both SMCs reside in the Nest.")
xNestDualXccXlc = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 10), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestDualXccXlc.setStatus('current')
if mibBuilder.loadTexts: xNestDualXccXlc.setDescription("The number of XCC devices configured for the Node Manager or number of XLC devices configured for the Nest Manager depending on Type of Nest. Nest #1 is considered the Node Manager and all other Nests are considered as Nest Managers. If running with only a single XCC or XLC, this should be set to 'no' in order to suppress unecessary alarms. no (0) Only 1 XCC/XLC resides in the Nest. yes (1) Both XCCs/XLCs reside in the Nest.")
xNestCmdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 101, 102, 103, 104, 105, 106, 107, 200, 201, 202, 203, 204, 205, 206, 207, 208, 450, 500, 501, 502))).clone(namedValues=NamedValues(("ready-for-command", 0), ("update-nest-config", 1), ("delete-nest-config", 2), ("switch-mgr-cards", 3), ("reset-device-cards", 4), ("clear-device-errors", 5), ("switch-xcc-cards", 6), ("switch-xlink-cards", 7), ("update-successful", 101), ("delete-successful", 102), ("switch-mgr-successful", 103), ("reset-successful", 104), ("clear-successful", 105), ("switch-xcc-successful", 106), ("switch-xlink-successful", 107), ("err-general-nest-config-error", 200), ("err-invalid-nest-type", 201), ("err-invalid-nest-command", 202), ("err-invalid-nest-name", 203), ("err-invalid-nest-alrm", 204), ("err-invalid-nest-ndr", 205), ("err-invalid-nest-option", 206), ("err-cannot-delete-online-nest", 207), ("err-nest-not-present", 208), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestCmdStatus.setStatus('current')
if mibBuilder.loadTexts: xNestCmdStatus.setDescription("The command status for this nest configuration row/record. The value used in a SET will be replaced by a response value in the GET RESPONSE indicating success or failure. Default Response State used in GET RESPONSE Command ready-for-command (0) initial default status for a row Nest Device Commands used in SET Command (1..99) update-nest-config (1) change an aspect of current nest configuration delete-nest-config (2) remove existing Nest Configuration. Deleting the Nest Configuration using the Nest Command Status will result in the removal of all configured connections associated with that nest number. switch-mgr-cards (3) Perform Switchover to Standby SMC/XNM card in associated Nest reset-device-cards (4) Reset all device cards in associated Nest clear-device-errors (5) Clear error counters for all channel cards in associated Nest switch-xcc-cards (6) Perform Switchover to Standby XCC card in associated Nest switch-xlink-cards (7) Perform Switchover to Standby XLC card in associated Nest. Response States used in GET RESPONSE Command (100..199) update-successful (101) nest data has been successfully changed delete-successful (102) nest data has been successfully removed switch-mgr-successful (103) nest system managers has been successfully switched reset-successful (104) nest device cards have been issued reset requests clear-successful (105) nest device cards have been issued clear error requests switch-xcc-successful (106) nest xcc's has been successfully switched switch-xlink-successful (107) nest xlink cards has been successfully switched Nest Config Error Codes used in GET RESPONSE Command (200..799) err-general-nest-config-error (200) Unknown nest configuration error occurred. err-invalid-nest-type (201) Configured nest type not in valid range err-invalid-nest-command (202) Unrecognized nest command-action err-invalid-nest-name (203) Configured nest name too long err-invalid-nest-alrm (204) Configured nest alarm contacts not in valid range err-invalid-nest-ndr (205) N+1 Redundancy not supported for nest err-invalid-nest-option (206) Dual XCC/XLC or Dual SMC option not valid err-cannot-delete-online-nest (207) Nest cannot be online when deleting configuration err-nest-not-present (208) Nest not ready for command err-data-locked-by-another-user (450) Another administrative user is making changes to this part of the system via a terminal session. Check Event Log for user name err-snmp-parse-failed (500) Agent could not parse variable err-invalid-snmp-type (501) Variable ASN type does not match Agent defined type err-invalid-snmp-var-size (502) Variable size is too big")
xNestDualPower = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 1, 1, 12), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNestDualPower.setStatus('current')
if mibBuilder.loadTexts: xNestDualPower.setDescription("The number of DNX Power Supplies configured for the Nest. If running with only a single Power Supply, this should be set to 'no' in order to suppress unecessary alarms. no (0) Only 1 Power Supply resides in the Nest. yes (1) Both Power Supplies reside in the Nest.")
xSlotTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2), )
if mibBuilder.loadTexts: xSlotTable.setStatus('current')
if mibBuilder.loadTexts: xSlotTable.setDescription('A list of the Configured device cards in this node with the static and dynamic type information. The maximum number of entries depends on the number of nests times the number of slots in the system plus 3 default entries for the system manager cards and the Protection Switch.')
xSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "xSlotNestAddr"))
if mibBuilder.loadTexts: xSlotEntry.setStatus('current')
if mibBuilder.loadTexts: xSlotEntry.setDescription("The conceptual row of the Slot Configuration table. A row in this table can not be created or deleted. A row in this table can be modified by providing valid values for either the Slot Name, Configured Device Type, Device Redundancy, or Slot Command Status. Deleting the Slot Configuration using the Slot Command Status value of 'delete-slot-config' will result in the removal of all configured connections associated with that slot number. The xnmSlotCfgCmdStatus field must be included as a variable in a SET PDU for the action to take effect. If the xnmSlotCfgCmdStatus is missing from the SET PDU, the GET RESPONSE will contain the SNMP error status of 'genErr' for and an error index equal to the last variable.")
xSlotNestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 1), NestSlotAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotNestAddr.setStatus('current')
if mibBuilder.loadTexts: xSlotNestAddr.setDescription("This number uniquely identifies an Device's Nest-Slot Address. This number will be used throughout the system to identify a unique slot. The format is represented using an IP address syntax (4 byte string). The 1st byte represents the Nest Number (0..7) The 2nd byte represents the Slot Number (1..11) The 3rd byte unused The 4th byte unused")
xSlotDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 2), DnxSlotDeviceType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xSlotDeviceType.setStatus('current')
if mibBuilder.loadTexts: xSlotDeviceType.setDescription(" This is the slot type configured by the user. The value, slot(0) is the default type for an unconfigured device. If slot(0) is used in a Set Request, the agent will return an error status of 'badValue'. The slot entries representing the System Manager Cards and the Protection Switch device cannot be used in a Set Request since their device type is static.")
xSlotActualDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 3), DnxSlotDeviceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotActualDeviceType.setStatus('current')
if mibBuilder.loadTexts: xSlotActualDeviceType.setDescription(' This is the actual slot type sent back by the card. ')
xSlotDeviceState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 4), DnxSlotDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotDeviceState.setStatus('current')
if mibBuilder.loadTexts: xSlotDeviceState.setDescription(' The current machine state of the device. not-present (0) Indicates no hardware detected in the slot. online (1) Device is present and is considered primary operational. offline (2) Device is present but currently not operational. disabled (3) Applies to the Protection Switch box if system cannot support redundancy. standby (4) Device is present but considered as secondary. defective (5) Device is present but could not be activated. bus-error (6) Device is present and reporting a bus connection error. out-of-serv (7) Operator has placed device in Out of Service mode.')
xSlotAlarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("no-alarm", 0), ("minor-level", 1), ("major-level", 2), ("major-minor", 3), ("critical-level", 4), ("critical-minor", 5), ("critical-major", 6), ("critical-major-minor", 7), ("unknown", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: xSlotAlarmLevel.setDescription(" The current slot device alarm condition level that indicates it's severity. ")
xSlotDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xSlotDeviceName.setStatus('current')
if mibBuilder.loadTexts: xSlotDeviceName.setDescription('The user defined name for this slot/device.')
xSlotDeviceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotDeviceVersion.setStatus('current')
if mibBuilder.loadTexts: xSlotDeviceVersion.setDescription('The software version release identification number for this device. ')
xSlotDeviceRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1), ("notApplicable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xSlotDeviceRedundancy.setStatus('current')
if mibBuilder.loadTexts: xSlotDeviceRedundancy.setDescription('The configured N+1 Redundancy state of the device. The slot entries representing the System Manager Cards and the Protection Switch device cannot be used in a Set Request since N+1 Redundancy does not apply to them. disable (0) Device is not configured as part of the Redundancy Group. enable (1) Device is configured as part of the Redundancy Group. n/a (2) Device does not support Redundancy.')
xSlotMiscState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("errors", 1), ("test", 2), ("errors-test", 3), ("clockSrc", 4), ("errors-clockSrc", 5), ("test-clockSrc", 6), ("errors-test-clockSrc", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotMiscState.setStatus('current')
if mibBuilder.loadTexts: xSlotMiscState.setDescription('The current slot/device miscellaneous state conditions. none (0) no misc condition errors (1) errors reported on device test (2) device is in test mode errors-test (3) errors reported on device while in test mode clockSrc (4) device is the source for the system clock errors-clockSrc (5) device is the source for the system clock and errors found test-clockSrc (6) device is the source for the system clock and is in test mode errors-test-clockSrc (7) device is the source for the system clock and is in test mode and errors were found')
xSlotCmdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 10, 11, 101, 102, 110, 111, 200, 201, 202, 203, 204, 205, 207, 208, 450, 500, 501, 502))).clone(namedValues=NamedValues(("ready-for-command", 0), ("update-slot-config", 1), ("delete-slot-config", 2), ("ndr-switchover", 10), ("ndr-restore", 11), ("update-successful", 101), ("delete-successful", 102), ("switch-successful", 110), ("restore-successful", 111), ("err-general-slot-config-error", 200), ("err-invalid-slot-type", 201), ("err-invalid-slot-command", 202), ("err-invalid-slot-name", 203), ("err-redundancy-disabled", 204), ("err-cannot-chg-sys-device", 205), ("err-invalid-redundancy-state", 207), ("err-cannot-delete-online-device", 208), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xSlotCmdStatus.setStatus('current')
if mibBuilder.loadTexts: xSlotCmdStatus.setDescription('The command status for this slot configuration row/record. The value used in a SET will be replaced by a response value in the GET RESPONSE indicating success or failure. Default Response State used in GET RESPONSE Command ready-for-command (0) initial default status for a row Slot Device Commands used in SET Command (1..99) update-slot-config (1) change an aspect of current slot configuration delete-slot-config (2) remove existing Slot Configuration. Deleting the Slot Configuration using the Slot Command Status will result in the removal of all configured connections associated with that slot number. ndr-switchover (10) force a switchover to the Standby device ndr-restore (11) force a restore back to the original device Response States used in GET RESPONSE Command (100..199) update-successful (101) slot data has been successfully changed delete-successful (102) slot data has been successfully removed switch-successful (110) Slot N+1 Redundancy device has been successfully switched over to Standby device restore-successful (111) Slot N+1 Redundancy device has been successfully restored back to Primary device Slot Config Error Codes used in GET RESPONSE Command (200..799) err-general-slot-config-error (200) Unknown slot configuration error occurred. err-invalid-slot-type (201) Configured slot type not in valid range err-invalid-slot-command (202) Unrecognized slot command-action err-invalid-slot-name (203) Configured slot name too long err-redundancy-disabled (204) Redundancy disabled on this system or does not apply to device type err-cannot-chg-sys-device (205) System Device type does not support configuration change err-invalid-redundancy-state (207) Redundancy state does not apply or invalid err-cannot-delete-online-device (208) Device cannot be present when deleting configuration err-data-locked-by-another-user (450) Another administrative user is making changes to this part of the system via a terminal session. Check Event Log for user name err-snmp-parse-failed (500) Agent could not parse variable err-invalid-snmp-type (501) Variable ASN type does not match Agent defined type err-invalid-snmp-var-size (502) Variable size is too big')
xSlotRawDeviceState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 2, 1, 11), UnsignedInt()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xSlotRawDeviceState.setStatus('current')
if mibBuilder.loadTexts: xSlotRawDeviceState.setDescription('The current raw bitmask form of the state of the slot/device.')
xNdrTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3), )
if mibBuilder.loadTexts: xNdrTable.setStatus('current')
if mibBuilder.loadTexts: xNdrTable.setDescription('A list of the Nests with N+1 Redundancy capability in this node. The maximum number of entries depends on the number of nests that have a Protection Switch Device.')
xNdrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "xNdrNestIndex"))
if mibBuilder.loadTexts: xNdrEntry.setStatus('current')
if mibBuilder.loadTexts: xNdrEntry.setDescription("The conceptual row of the N+1 Redundancy table. A row in this table can not be created or deleted. A row in this table can be modified by providing valid values for any of the configurable N+1 Redundancy fields. The xNdrCmdStatus field must be included as a variable in a SET PDU for the action to take effect. If the xNdrCmdStatus is missing from the SET PDU, the GET RESPONSE will contain the SNMP error status of 'genErr' for and an error index equal to the last variable.")
xNdrNestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrNestIndex.setStatus('current')
if mibBuilder.loadTexts: xNdrNestIndex.setDescription(' The nest index number in the node. Nests are indexed 0 through 7 but correspond to Nests 1 to 8.')
xNdrState = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("frozen", 2), ("delayed", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrState.setStatus('current')
if mibBuilder.loadTexts: xNdrState.setDescription('This is the current N+1 Device Redundancy state. disabled (1) N+1 Redundancy disabled by the user. frozen (2) N+1 Redundancy is not active due to missing hardware components. delayed (3) N+1 Redundancy is delayed due to switchover. enabled (4) N+1 Redundancy enabled and ready.')
xNdrAutoSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 0), ("automatic", 1), ("narrowband-auto", 2), ("broadband-1-auto", 3), ("broadband-2-auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrAutoSwitchover.setStatus('current')
if mibBuilder.loadTexts: xNdrAutoSwitchover.setDescription("Indicates the user's desired N+1 Device Redundancy automatic Switchover setting when a primary card fails. manual (0) Failed cards will not be switched automatically by the system. User is required to go to Node Summary Console screen and force a manual switchover of the failed card to the Redundant. automatic (1) The system will automatically switch out failed cards for either NDR Group with the Redundant card. narrowband-auto (2) The system will automatically switch out a failed card for the NDR Narrowband Group with the Redundant. broadband-1-auto(3) The system will automatically switch out a failed card for the NDR Broadband Group 1 with the Redundant. broadband-2-auto(4) The system will automatically switch out a failed card for the NDR Broadband Group 2 with the Redundant.")
xNdrAutoRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 0), ("automatic", 1), ("narrowband-auto", 2), ("broadband-1-auto", 3), ("broadband-2-auto", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrAutoRestore.setStatus('current')
if mibBuilder.loadTexts: xNdrAutoRestore.setDescription("Indicates the system's N+1 Device Redundancy automatic Restore setting when a protected card becomes operational. manual (0) Protected cards that become operational will not be restored automatically by the system. User is required to go to Node Summary Console screen and force a manual switchover of the Redundant card back to the Primary card. automatic (1) The system will automatically restore protected cards that become operational for either NDR Group. narrowband-auto (2) The system will automatically restore protected cards that become operational for the NDR Narrowband Group. broadband-1-auto(3) The system will automatically restore protected cards that become operational for the NDR Broadband Group 1. broadband-2-auto(4) The system will automatically restore protected cards that become operational for the NDR Broadband Group 2.")
xNdrBroadbandGroup1 = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrBroadbandGroup1.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup1.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Broadband Group 1. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Group 1 N+1 Redundancy Group.')
xNdrNarrowbandGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrNarrowbandGroup.setStatus('current')
if mibBuilder.loadTexts: xNdrNarrowbandGroup.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Narrowband Group. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Narrowband N+1 Redundancy Group.')
xNdrBroadbandGroup1Protected = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(8, 10), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrBroadbandGroup1Protected.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup1Protected.setDescription('This is a slot number that indicates which device card from the active NDR Broadband Group 1 has been currently switched over. Valid Protected slots for NDR Broadband Group1 are 8 through 10. If a zero value is returned, no device card is currently protected.')
xNdrNarrowbandProtected = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 11), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrNarrowbandProtected.setStatus('current')
if mibBuilder.loadTexts: xNdrNarrowbandProtected.setDescription('This is a slot number that indicates which device card from the active NDR Narrowband Group has been currently switched over. Valid Protected slots for NDR Narrowband Group are 2 through 11. If a zero value is returned, no device card is currently protected.')
xNdrBroadbandGroup1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 18, 21, 31))).clone(namedValues=NamedValues(("ds3", 8), ("sts1", 18), ("hds3", 21), ("e3", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrBroadbandGroup1Type.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup1Type.setDescription('This indicates which type of device is currently occupying the status of active NDR Broadband Group 1. Only one type of broadband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Broadband Group 1 type should match the device type of the card in Slot 11, which is the designated Broadband Group 1 NDR Redundant slot.')
xNdrNarrowbandType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13, 22))).clone(namedValues=NamedValues(("octalT1E1", 13), ("gr303", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrNarrowbandType.setStatus('current')
if mibBuilder.loadTexts: xNdrNarrowbandType.setDescription('This indicates which type of device is currently occupying the status of active NDR Narrowband Group. Only one type of Narrowband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Narrowband type should match the device type of the card in Slot 1, which is the designated Narrowband NDR Redundant slot.')
xNdrDualBroadbandEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 11), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrDualBroadbandEnabled.setStatus('current')
if mibBuilder.loadTexts: xNdrDualBroadbandEnabled.setDescription("Indicates the system's capability of supporting the N+1 Device Redundancy Dual Broadband Group functionality. The user should configure this variable based on the existence of the Upgraded PSX Hardware. no (0) PSX Dual Broadband Groups disabled or not supported. yes (1) PSX Dual Broadband Groups enabled.")
xNdrBroadbandGroup2 = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrBroadbandGroup2.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup2.setDescription('This is a 2 byte bit field reflecting the slots that are part of the current active NDR Broadband Group 2. The first 11 bits represent each of the slot numbers. If any of the bits are set, those slots are currently part of the Group 2 N+1 Redundancy Group.')
xNdrBroadbandGroup2Protected = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xNdrBroadbandGroup2Protected.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup2Protected.setDescription('This is a slot number that indicates which device card from the active NDR Broadband Group 2 has been currently switched over. Valid Protected slots for NDR Broadband Group2 are 1 through 6. If a zero value is returned, no device card is currently protected.')
xNdrBroadbandGroup2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 18, 21, 31))).clone(namedValues=NamedValues(("ds3", 8), ("sts1", 18), ("hds3", 21), ("e3", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrBroadbandGroup2Type.setStatus('current')
if mibBuilder.loadTexts: xNdrBroadbandGroup2Type.setDescription('This indicates which type of device is currently occupying the status of active NDR Broadband Group 2. Only one type of broadband device can be supported by N+1 Redundancy at one time. Whichever type is selected as the active Broadband Group 2 type should match the device type of the card in Slot 7, which is the designated Broadband Group 2 NDR Redundant slot.')
xNdrPsxChassisType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("psx5200", 0), ("psx5300", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrPsxChassisType.setStatus('current')
if mibBuilder.loadTexts: xNdrPsxChassisType.setDescription('This indicates which type of Protection Switch Chassis Hardware has been detected. In order to run with Dual Broadband Group configuration, this value should be set to psx5300.')
xNdrCmdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 101, 200, 201, 202, 203, 204, 205, 206, 450, 500, 501, 502))).clone(namedValues=NamedValues(("ready-for-command", 0), ("update-ndr", 1), ("update-successful", 101), ("err-general-ndr-config-error", 200), ("err-invalid-ndr-group-type", 201), ("err-invalid-ndr-command", 202), ("err-invalid-ndr-autoswitch", 203), ("err-invalid-ndr-chassis", 204), ("err-invalid-ndr-dual-bb", 205), ("err-invalid-ndr-dual-psx", 206), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrCmdStatus.setStatus('current')
if mibBuilder.loadTexts: xNdrCmdStatus.setDescription('The command status for this ndr configuration row/record. The value used in a SET will be replaced by a response value in the GET RESPONSE indicating success or failure. Default Response State used in GET RESPONSE Command ready-for-command (0) initial default status for a row NDR Device Commands used in SET Command (1..99) update-ndr (1) change an aspect of current nest N+1 Redundancy Response States used in GET RESPONSE Command (100..199) update-successful (101) ndr data has been successfully changed NDR Config Error Codes used in GET RESPONSE Command (200..799) err-general-ndr-config-error (200) Unknown ndr configuration error occurred. err-invalid-ndr-group-type (201) Configured NDR Group type not in valid range err-invalid-ndr-command (202) Unrecognized NDR command-action err-invalid-ndr-autoswitch (203) NDR Auto Switchover value not in valid range err-invalid-ndr-chassis (204) NDR Chassis Type value not in valid range err-invalid-ndr-dual-bb (205) NDR Dual Broadband Group value not in valid err-invalid-ndr-dual-psx (206) NDR Dual PSX Power Supply value not in valid err-data-locked-by-another-user (450) Another administrative user is making changes to this part of the system via a terminal session. Check Event Log for user name err-snmp-parse-failed (500) Agent could not parse variable err-invalid-snmp-type (501) Variable ASN type does not match Agent defined type err-invalid-snmp-var-size (502) Variable size is too big')
xNdrDualPowerSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 11, 3, 1, 17), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xNdrDualPowerSupply.setStatus('current')
if mibBuilder.loadTexts: xNdrDualPowerSupply.setDescription("The number of N+1 Protection Switch Power Supplies configured for the Nest. If running with only a single PSX Power Supply, this should be set to 'no' in order to suppress unecessary alarms. no (0) Only 1 Power Supply resides in the PSX. yes (1) Both Power Supplies reside in the PSX.")
dbSyncronize = MibIdentifier((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 12, 1, 2))
dbAutoSyncMode = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 12, 1, 2, 1), DecisionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dbAutoSyncMode.setStatus('current')
if mibBuilder.loadTexts: dbAutoSyncMode.setDescription('Enables or disables the Automatic Database Synchronization.')
dbSyncStatus = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 12, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inSync", 1), ("notInSync", 2), ("syncInProgress", 3), ("autoSyncOff", 4), ("standByNotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbSyncStatus.setStatus('current')
if mibBuilder.loadTexts: dbSyncStatus.setDescription('The current status of the System DB Synchronization.')
dbSyncProgressTime = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 12, 1, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbSyncProgressTime.setStatus('current')
if mibBuilder.loadTexts: dbSyncProgressTime.setDescription('The number of seconds elapsed since the DB Synchronization has been started.')
dbSyncCmdStatus = MibScalar((1, 3, 6, 1, 4, 1, 644, 2, 4, 1, 12, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 101, 102, 120, 200, 201, 202, 203, 204, 450, 500, 501, 502))).clone(namedValues=NamedValues(("ready-for-command", 0), ("update", 1), ("startDBSync", 2), ("update-successful", 101), ("sync-start-successful", 102), ("sync-completed-successful", 120), ("err-gen-dbsync-cfg-error", 200), ("err-standby-not-present", 201), ("err-dbsync-failed", 202), ("err-invalid-dbsync-command", 203), ("err-invalid-dbsync-mode", 204), ("err-data-locked-by-another-user", 450), ("err-snmp-parse-failed", 500), ("err-invalid-snmp-type", 501), ("err-invalid-snmp-var-size", 502)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dbSyncCmdStatus.setStatus('current')
if mibBuilder.loadTexts: dbSyncCmdStatus.setDescription('The command status for this DB Synchronization. The value used in a SET will be replaced by a response value in the GET RESPONSE indicating success or failure. Default Response State used in GET RESPONSE Command ready-for-command (0) initial default status for a row DB Sync Commands used in SET Command (1..99) update (1) Change the auto sync mode startDBSync (2) Starts the DB synchronization process Response States used in GET RESPONSE Command (100..199) update-successful (101) Auto Sync data has been successfully changed sync-start-successful (102) DB Sync process has been successfully started sync-completed-successful (120) DB Sync process has been successfully finished DB Sync Error Codes used in GET RESPONSE Command (200..799) err-gen-dbsync-cfg-error (200) Unknown DB Sync configuration error occurred. err-standby-not-present (201) DB Synchronization cannot be started without standby systemManager Device. err-dbsync-failed (202) DB Synchronization process has failed err-invalid-dbsync-command (203, Unrecognized DB Sync command action err-invalid-dbsync-mode (204) Unrecognized auto sync setting err-data-locked-by-another-user (450) Another administrative user is making changes to this part of the system via a terminal session. Check Event Log for user name err-snmp-parse-failed (500) Agent could not parse variable err-invalid-snmp-type (501) Variable ASN type does not match Agent defined type err-invalid-snmp-var-size (502) Variable size is too big')
deviceAboutTable = MibTable((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225), )
if mibBuilder.loadTexts: deviceAboutTable.setStatus('current')
if mibBuilder.loadTexts: deviceAboutTable.setDescription('This is the Device About Information table which consists of an entry for each of the Actual device cards in this node with the module, board, revision and software release information. The maximum number of entries depends on the number of nests times the number of slots in each nest.')
deviceAboutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1), ).setIndexNames((0, "ERI-DNX-NEST-SYS-MIB", "devCardAddress"))
if mibBuilder.loadTexts: deviceAboutEntry.setStatus('current')
if mibBuilder.loadTexts: deviceAboutEntry.setDescription('The conceptual row of the Device About Information table. A row in this table cannot be added or deleted, only modified.')
devCardAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 1), NestSlotAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devCardAddress.setStatus('current')
if mibBuilder.loadTexts: devCardAddress.setDescription("This number uniquely identifies an Device's Nest-Slot Address. This number will be used throughout the system to identify a unique slot. The format is represented using an IP address syntax (4 byte string). The 1st byte represents the Nest Number (0..7) The 2nd byte represents the Slot Number (1..11) The 3rd byte unused The 4th byte unused")
devSwReleaseDate = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devSwReleaseDate.setStatus('current')
if mibBuilder.loadTexts: devSwReleaseDate.setDescription('The release date of the software resident on the device card.')
devSwChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devSwChecksum.setStatus('current')
if mibBuilder.loadTexts: devSwChecksum.setDescription('The checksum of the software resident on the device card.')
devFrontCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devFrontCardType.setStatus('current')
if mibBuilder.loadTexts: devFrontCardType.setDescription('The Hardware type of Front card for the device.')
devFrontCardRev = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devFrontCardRev.setStatus('current')
if mibBuilder.loadTexts: devFrontCardRev.setDescription('The Hardware revision number of the Front card.')
devXilinxVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devXilinxVersion.setStatus('current')
if mibBuilder.loadTexts: devXilinxVersion.setDescription('The version of Xilinx Hardware on the device card.')
devRearCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devRearCardType.setStatus('current')
if mibBuilder.loadTexts: devRearCardType.setDescription('The Hardware type of Rear card reported by the device.')
devRearCardRev = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devRearCardRev.setStatus('current')
if mibBuilder.loadTexts: devRearCardRev.setDescription('The Hardware revision number of the Rear card.')
devSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 644, 2, 4, 2, 225, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devSwVersion.setStatus('current')
if mibBuilder.loadTexts: devSwVersion.setDescription('The software version release identification number for this device. ')
slotConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 644, 2, 4, 0, 5)).setObjects(("ERI-DNX-SMC-MIB", "trapSequence"), ("ERI-DNX-NEST-SYS-MIB", "slotNbr"), ("ERI-DNX-NEST-SYS-MIB", "slotConfigCmdStatus"), ("ERI-DNX-NEST-SYS-MIB", "xNestIndex"))
if mibBuilder.loadTexts: slotConfigTrap.setStatus('current')
if mibBuilder.loadTexts: slotConfigTrap.setDescription('This trap is used to notify a NMS that a user has updated the configuration for a given slot entry.')
ndrGroupStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 644, 2, 4, 0, 8)).setObjects(("ERI-DNX-SMC-MIB", "trapSequence"), ("ERI-DNX-NEST-SYS-MIB", "ndrState"), ("ERI-DNX-NEST-SYS-MIB", "ndrBroadbandGroup1"), ("ERI-DNX-NEST-SYS-MIB", "ndrNarrowbandGroup"), ("ERI-DNX-NEST-SYS-MIB", "ndrBroadbandGroup2"), ("ERI-DNX-NEST-SYS-MIB", "xNdrNestIndex"))
if mibBuilder.loadTexts: ndrGroupStatusTrap.setStatus('current')
if mibBuilder.loadTexts: ndrGroupStatusTrap.setDescription('This trap is used to notify a NMS that due to an alarm condition or system state change, the N+1 Redundancy Groups have been modified. This means the one or more devices have been removed or added to the actual N+1 Redundancy Groups and this will affect which cards will be protected (switched) in the event of a failure.')
nestConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 644, 2, 4, 0, 9)).setObjects(("ERI-DNX-SMC-MIB", "trapSequence"), ("ERI-DNX-NEST-SYS-MIB", "xNestIndex"), ("ERI-DNX-NEST-SYS-MIB", "xNestType"), ("ERI-DNX-NEST-SYS-MIB", "xNestCmdStatus"), ("ERI-DNX-NEST-SYS-MIB", "xNestUnitName"))
if mibBuilder.loadTexts: nestConfigTrap.setStatus('current')
if mibBuilder.loadTexts: nestConfigTrap.setDescription('This trap is used to notify a NMS that a user has updated the configuration for a given nest entry.')
dbSyncProgressTrap = NotificationType((1, 3, 6, 1, 4, 1, 644, 2, 4, 0, 12)).setObjects(("ERI-DNX-SMC-MIB", "trapSequence"), ("ERI-DNX-NEST-SYS-MIB", "dbSyncStatus"), ("ERI-DNX-NEST-SYS-MIB", "dbSyncCmdStatus"))
if mibBuilder.loadTexts: dbSyncProgressTrap.setStatus('current')
if mibBuilder.loadTexts: dbSyncProgressTrap.setDescription('This trap is used to notify a NMS that the system has either started or just completed the Database synchronization process.')
mibBuilder.exportSymbols("ERI-DNX-NEST-SYS-MIB", xNdrAutoSwitchover=xNdrAutoSwitchover, xNdrAutoRestore=xNdrAutoRestore, xNestCfgTable=xNestCfgTable, programFileName=programFileName, xNdrEntry=xNdrEntry, slotMiscState=slotMiscState, devDownloadEntry=devDownloadEntry, ndrPsxChassisType=ndrPsxChassisType, xNdrBroadbandGroup2Type=xNdrBroadbandGroup2Type, devSwChecksum=devSwChecksum, xNdrBroadbandGroup1=xNdrBroadbandGroup1, ndrNarrowbandProtected=ndrNarrowbandProtected, xSlotMiscState=xSlotMiscState, programFileSize=programFileSize, xNdrNarrowbandType=xNdrNarrowbandType, deviceAboutTable=deviceAboutTable, xNestDeviceCards=xNestDeviceCards, slotConfigDeviceType=slotConfigDeviceType, xSlotCmdStatus=xSlotCmdStatus, xSlotDeviceState=xSlotDeviceState, slotDeviceVersion=slotDeviceVersion, programFileCommand=programFileCommand, devFrontCardType=devFrontCardType, xNestState=xNestState, DnxSlotDeviceState=DnxSlotDeviceState, softwareRelease=softwareRelease, xNestType=xNestType, programSlotNumber=programSlotNumber, dbSyncronize=dbSyncronize, nestConfigTrap=nestConfigTrap, ndrGroupStatusTrap=ndrGroupStatusTrap, xSlotDeviceName=xSlotDeviceName, dbAutoSyncMode=dbAutoSyncMode, PYSNMP_MODULE_ID=eriDNXNestSysMIB, slotDeviceRedundancy=slotDeviceRedundancy, xNdrNestIndex=xNdrNestIndex, ndrBroadbandGroup2=ndrBroadbandGroup2, programNestNumber=programNestNumber, eXpansionNestAdmin=eXpansionNestAdmin, xSlotActualDeviceType=xSlotActualDeviceType, slotConfigCmdStatus=slotConfigCmdStatus, slotAlarmLevel=slotAlarmLevel, xNdrBroadbandGroup2=xNdrBroadbandGroup2, ndrAutoRestore=ndrAutoRestore, xNestCfgEntry=xNestCfgEntry, devSwVersion=devSwVersion, xSlotNestAddr=xSlotNestAddr, xNestCmdStatus=xNestCmdStatus, xNdrBroadbandGroup1Type=xNdrBroadbandGroup1Type, redundancy=redundancy, xNdrDualBroadbandEnabled=xNdrDualBroadbandEnabled, ndrBroadbandGroup2Type=ndrBroadbandGroup2Type, xNestAlarmContacts=xNestAlarmContacts, dbSyncCmdStatus=dbSyncCmdStatus, xNestAlarmStatus=xNestAlarmStatus, xNdrState=xNdrState, xNestDualSMCs=xNestDualSMCs, slotDeviceName=slotDeviceName, xSlotAlarmLevel=xSlotAlarmLevel, devFrontCardRev=devFrontCardRev, programLoadStatus=programLoadStatus, xNdrNarrowbandGroup=xNdrNarrowbandGroup, ndrDualBroadbandEnabled=ndrDualBroadbandEnabled, numberSlots=numberSlots, xNdrDualPowerSupply=xNdrDualPowerSupply, xNestDualXccXlc=xNestDualXccXlc, dbSyncProgressTrap=dbSyncProgressTrap, slotConfigEntry=slotConfigEntry, ndrNarrowbandGroup=ndrNarrowbandGroup, slotActualDeviceType=slotActualDeviceType, xNdrCmdStatus=xNdrCmdStatus, dbSyncStatus=dbSyncStatus, ndrBroadbandGroup1Type=ndrBroadbandGroup1Type, xNestIndex=xNestIndex, slotNbr=slotNbr, ndrBroadbandGroup2Protected=ndrBroadbandGroup2Protected, xSlotDeviceRedundancy=xSlotDeviceRedundancy, programFileIndex=programFileIndex, programBytesSent=programBytesSent, upgradeSw=upgradeSw, xSlotEntry=xSlotEntry, xSlotRawDeviceState=xSlotRawDeviceState, xNdrNarrowbandProtected=xNdrNarrowbandProtected, ndrAutoSwitchover=ndrAutoSwitchover, programLoadInitiator=programLoadInitiator, xNdrTable=xNdrTable, slotConfigTrap=slotConfigTrap, xSlotDeviceType=xSlotDeviceType, slotDeviceState=slotDeviceState, xNdrPsxChassisType=xNdrPsxChassisType, xNestDualPower=xNestDualPower, ndrBroadbandGroup1Protected=ndrBroadbandGroup1Protected, xNdrBroadbandGroup2Protected=xNdrBroadbandGroup2Protected, ndrEnabled=ndrEnabled, devRearCardType=devRearCardType, devXilinxVersion=devXilinxVersion, devDownloadTable=devDownloadTable, devRearCardRev=devRearCardRev, devSwReleaseDate=devSwReleaseDate, DnxSlotDeviceType=DnxSlotDeviceType, slotConfigTable=slotConfigTable, ndrBroadbandGroup1=ndrBroadbandGroup1, xNestUnitName=xNestUnitName, xNestNDRCapable=xNestNDRCapable, xSlotTable=xSlotTable, dbSyncProgressTime=dbSyncProgressTime, devCardAddress=devCardAddress, ndrNarrowbandType=ndrNarrowbandType, xSlotDeviceVersion=xSlotDeviceVersion, deviceAboutEntry=deviceAboutEntry, ndrState=ndrState, eriDNXNestSysMIB=eriDNXNestSysMIB, xNdrBroadbandGroup1Protected=xNdrBroadbandGroup1Protected)

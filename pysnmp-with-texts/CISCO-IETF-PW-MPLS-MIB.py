#
# PySNMP MIB module CISCO-IETF-PW-MPLS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-PW-MPLS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
cpwVcIndex, = mibBuilder.importSymbols("CISCO-IETF-PW-MIB", "cpwVcIndex")
CpwVcIndexType, = mibBuilder.importSymbols("CISCO-IETF-PW-TC-MIB", "CpwVcIndexType")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
MplsLsrIdentifier, MplsLdpIdentifier, MplsTunnelInstanceIndex, MplsTunnelIndex = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsLsrIdentifier", "MplsLdpIdentifier", "MplsTunnelInstanceIndex", "MplsTunnelIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, Unsigned32, ObjectIdentity, Gauge32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, Integer32, Counter64, iso, ModuleIdentity, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Unsigned32", "ObjectIdentity", "Gauge32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "Integer32", "Counter64", "iso", "ModuleIdentity", "IpAddress", "TimeTicks")
StorageType, TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "DisplayString", "RowStatus")
cpwVcMplsMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 107))
cpwVcMplsMIB.setRevisions(('2003-02-26 12:00', '2002-06-02 12:00', '2002-01-29 12:00', '2001-07-11 12:00', '2001-07-11 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cpwVcMplsMIB.setRevisionsDescriptions(('Made Cisco proprietary based on the PW-MPLS-MIB.my file extracted from draft-ietf-pwe3-pw-mpls-mib-00.txt ', 'Draft-ietf-pwe3-pw-mpls-mib-00 version. Changes from previous version: 1) Spliting the mapping table into two tables, one for Non TE application and one for TE application. 2) Object types alignment with MPLS MIBs. ', 'Changes from previous version: 1) Add LDP entity association. 2) Clarify inbound/outbound directions. 3) Simplify indexing of outbound and inbound tables and providing get next variables. ', 'Changes from previous version: 1) Remove Vc instance from table indexing. 2) Update descriptions of indexing and protection. 3) Remove the need for MPLS-LSR in case of VC only. 4) Change pwVcMplsMplsType to BITS in order to enable multiple types of outer tunnel. 5) Add ifindex to outer tunnel tables to support vcOnly option. 6) change naming of outbound, inbound and mapping tables to reflect addition of VC only port ifindexes. 7) Adapt order of items in mapping table to SNMP convention. ', 'draft-zelig-pw-mib-00.txt - initial version',))
if mibBuilder.loadTexts: cpwVcMplsMIB.setLastUpdated('200302261200Z')
if mibBuilder.loadTexts: cpwVcMplsMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: cpwVcMplsMIB.setContactInfo(' Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-497-3051 Email: tnadeau@cisco.com MPLS MIB Development Team Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01924 Tel: +1-978-497-3989 Email: ch-mpls-mib-dev@cisco.com ')
if mibBuilder.loadTexts: cpwVcMplsMIB.setDescription('This MIB complements the CISCO-IETF-PW-MIB for PW operation over MPLS. ')
cpwVcMplsNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 0))
cpwVcMplsNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 0, 0))
cpwVcMplsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 1))
cpwVcMplsConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 2))
cpwVcMplsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1), )
if mibBuilder.loadTexts: cpwVcMplsTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTable.setDescription('This table specifies information for VC to be carried over MPLS PSN.')
cpwVcMplsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"))
if mibBuilder.loadTexts: cpwVcMplsEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsEntry.setDescription('A row in this table represents parameters specific to MPLS PSN for a pseudo wire connection (VC). The row is created automatically by the local agent if the cpwVcPsnType is MPLS. It is indexed by cpwVcIndex, which uniquely identifying a singular connection. ')
cpwVcMplsMplsType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 1), Bits().clone(namedValues=NamedValues(("mplsTe", 0), ("mplsNonTe", 1), ("vcOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsMplsType.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsMplsType.setDescription('Set by the operator to indicate the outer tunnel types, if exists. mplsTe is used if the outer tunnel was set-up by MPLS-TE, and mplsNonTe is used the outer tunnel was set up by LDP or manually. Combination of mplsTe and mplsNonTe may exist in case of outer tunnel protection. vcOnly is used if there is no outer tunnel label. vcOnly cannot be combined with mplsNonTe or mplsTe.')
cpwVcMplsExpBitsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("outerTunnel", 1), ("specifiedValue", 2), ("serviceDependant", 3))).clone('outerTunnel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsExpBitsMode.setReference('martini et al, <draft-martini-l2circuit-encap-mpls.txt>')
if mibBuilder.loadTexts: cpwVcMplsExpBitsMode.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsExpBitsMode.setDescription('Set by the operator to indicate the way the VC shim label EXP bits are to be determined. The value of outerTunnel(1) is used where there is an outer tunnel - cpwVcMplsMplsType is mplsTe or mplsNonTe. Note that in this case there is no need to mark the VC label with the EXP bits since the VC label is not visible to the intermediate nodes. If there is no outer tunnel, specifiedValue(2) indicate that the value is specified by cpwVcMplsExpBits, and serviceDependant(3) indicate that the EXP bits are setup based on a rule specified in the emulated service specific tables, for example when the EXP bits are a function of 802.1p marking for Ethernet emulated service.')
cpwVcMplsExpBits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsExpBits.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsExpBits.setDescription('Set by the operator to indicate the MPLS EXP bits to be used on the VC shim label if cpwVcMplsExpBitsMode is specifiedValue(2), zero otherwise.')
cpwVcMplsTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsTtl.setReference('martini et al, <draft-martini-l2circuit-encap-mpls> ')
if mibBuilder.loadTexts: cpwVcMplsTtl.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTtl.setDescription('Set by the operator to indicate the VC TTL bits to be used on the VC shim label.')
cpwVcMplsLocalLdpID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 5), MplsLdpIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsLocalLdpID.setReference('<draft-ietf-ldp-mib>, <draft-martini-l2circuit-encap-mpls>. ')
if mibBuilder.loadTexts: cpwVcMplsLocalLdpID.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsLocalLdpID.setDescription('The local LDP identifier of the LDP entity creating this VC in the local node. As the VC labels are always set from the per platform label space, the last two octets in the LDP ID MUST be always both zeros.')
cpwVcMplsLocalLdpEntityID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsLocalLdpEntityID.setReference('<draft-ietf-ldp-mib> ')
if mibBuilder.loadTexts: cpwVcMplsLocalLdpEntityID.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsLocalLdpEntityID.setDescription('The local LDP Entity index of the LDP entity to be used for this VC on the local node. Should be set to all zeros if not used.')
cpwVcMplsPeerLdpID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 7), MplsLdpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcMplsPeerLdpID.setReference('<draft-ietf-ldp-mib>, <draft-martini-l2circuit-encap-mpls>. ')
if mibBuilder.loadTexts: cpwVcMplsPeerLdpID.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsPeerLdpID.setDescription('The peer LDP identifier as identified from the LDP session. Should be zero if not relevant or not known yet.')
cpwVcMplsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 1, 1, 8), StorageType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcMplsStorageType.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsStorageType.setDescription('This variable indicates the storage type for this row.')
cpwVcMplsOutboundIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcMplsOutboundIndexNext.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundIndexNext.setDescription('This object contains an appropriate value to be used for cpwVcMplsOutboundIndex when creating entries in the cpwVcMplsOutboundTable. The value 0 indicates that no unassigned entries are available. To obtain the cpwVcMplsOutboundIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index, however the agent MUST NOT assume such retrieval will be done for each row created.')
cpwVcMplsOutboundTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3), )
if mibBuilder.loadTexts: cpwVcMplsOutboundTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundTable.setDescription('This table associates VCs using MPLS PSN with the outbound MPLS tunnels (i.e. toward the PSN) or the physical interface in case of VC only.')
cpwVcMplsOutboundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundIndex"))
if mibBuilder.loadTexts: cpwVcMplsOutboundEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundEntry.setDescription('A row in this table represents a link between PW VC (that require MPLS tunnels) and MPLS tunnel toward the PSN. In the case of VC only, it associate the VC with the interface that shall carry the VC. This table is indexed by the pwVcIndex and an additional index enabling multiple rows for the same VC index. At least one entry is created in this table by the operator for each PW VC that requires MPLS PSN. Note that the first entry for each VC can be indexed by cpwVcMplsOutboundIndex equal zero without a need for retrieval of cpwVcMplsOutboundIndexNext. This table points to the appropriate MPLS MIB. In the case of MPLS-TE, the 4 variables relevant to the indexing of a TE MPLS tunnel are set as in Srinivasan, et al, <draft- ietf-mpls-te-mib>. In case of Non-TE MPLS (an outer tunnel label assigned by LDP or manually) the table points to the XC entry in the LSR MIB as in Srinivasan, et al, <draft-ietf-mpls-lsr-mib>. In case of VC only (no outer tunnel) the ifIndex of the port to carry the VC is configured. Each VC may have multiple rows in this tables if protection is available at the outer tunnel level, each row may be of different type except for VC only, on which only rows with ifIndex of the port are allowed. ')
cpwVcMplsOutboundIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: cpwVcMplsOutboundIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundIndex.setDescription('Arbitrary index for enabling multiple rows per VC in this table. Next available free index can be retrieved using cpwVcMplsOutboundIndexNext. ')
cpwVcMplsOutboundLsrXcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundLsrXcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundLsrXcIndex.setDescription('This object will be set by the operator. If the outer label is defined in the MPL-LSR-MIB, i.e. set by LDP or manually, this object points to the XC index of the outer tunnel. Otherwise, it is set to zero.')
cpwVcMplsOutboundTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 3), MplsTunnelIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelIndex.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsOutboundTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 4), MplsTunnelInstanceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelInstance.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsOutboundTunnelLclLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 5), MplsLsrIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelLclLSR.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelLclLSR.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsOutboundTunnelPeerLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 6), MplsLsrIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelPeerLSR.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundTunnelPeerLSR.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsOutboundIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundIfIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundIfIndex.setDescription('In case of VC only (no outer tunnel), this object holds the ifIndex of the outbound port, otherwise set to zero.')
cpwVcMplsOutboundRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundRowStatus.setDescription('For creating, modifying, and deleting this row.')
cpwVcMplsOutboundStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 3, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsOutboundStorageType.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundStorageType.setDescription('This variable indicates the storage type for this object.')
cpwVcMplsInboundIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcMplsInboundIndexNext.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundIndexNext.setDescription('This object contains an appropriate value to be used for cpwVcMplsInboundIndex when creating entries in the cpwVcMplsInboundTable. The value 0 indicates that no unassigned entries are available. To obtain the cpwVcMplsInboundIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index, however the agent MUST NOT assume such retrieval will be done for each row created.')
cpwVcMplsInboundTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5), )
if mibBuilder.loadTexts: cpwVcMplsInboundTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundTable.setDescription('This table associates VCs using MPLS PSN with the inbound MPLS tunnels (i.e. for packets coming from the PSN), if such association is desired (mainly for security reasons).')
cpwVcMplsInboundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundIndex"))
if mibBuilder.loadTexts: cpwVcMplsInboundEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundEntry.setDescription('A row in this table represents a link between PW VCs (that require MPLS tunnels) and MPLS tunnel for packets arriving from the PSN. This table is indexed by the set of indexes used to identify the VC - cpwVcIndex and an additional index enabling multiple rows for the same VC index. Note that the first entry for each VC can be indexed by cpwVcMplsOutboundIndex equal zero without a need for retrieval of cpwVcMplsInboundIndexNext. An entry is created in this table either automatically by the local agent or created manually by the operator in cases that strict mode is required. Note that the control messages contain VC ID and VC type, which together with the remote IP address identify the cpwVcIndex in the local node. This table points to the appropriate MPLS MIB. In the case of MPLS-TE, the 4 variables relevant to the indexing of a TE MPLS tunnel are set as in Srinivasan, et al, <draft- ietf-mpls-te-mib>. In case of non-TE MPLS tunnel (an outer tunnel label assigned by LDP or manually) the table points to the XC entry in the MPLS-LSR-MIB as in Srinivasan, et al, <draft- ietf-mpls-lsr-mib>. Each VC may have multiple rows in this tables if protection is available at the outer tunnel level, each row may be of different type except for VC only, on which only rows with ifIndex of the port are allowed. ')
cpwVcMplsInboundIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: cpwVcMplsInboundIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundIndex.setDescription('Arbitrary index for enabling multiple rows per VC in this table. Next available free index can be retrieved using cpwVcMplsInboundIndexNext. ')
cpwVcMplsInboundLsrXcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundLsrXcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundLsrXcIndex.setDescription('If the outer label is defined in the MPL-LSR-MIB, i.e. set by LDP or manually, this object points to the XC index of the outer tunnel. Otherwise, it is set to zero.')
cpwVcMplsInboundTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 3), MplsTunnelIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelIndex.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsInboundTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 4), MplsTunnelInstanceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelInstance.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsInboundTunnelLclLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 5), MplsLsrIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelLclLSR.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelLclLSR.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsInboundTunnelPeerLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 6), MplsLsrIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelPeerLSR.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundTunnelPeerLSR.setDescription('Part of set of indexes for outbound tunnel in the case of MPLS-TE outer tunnel, otherwise set to zero.')
cpwVcMplsInboundIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundIfIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundIfIndex.setDescription('In case of VC only (no outer tunnel), this object holds the ifIndex of the inbound port, otherwise set to zero.')
cpwVcMplsInboundRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundRowStatus.setDescription('For creating, modifying, and deleting this row.')
cpwVcMplsInboundStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 5, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcMplsInboundStorageType.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundStorageType.setDescription('This variable indicates the storage type for this row.')
cpwVcMplsNonTeMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6), )
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingTable.setDescription('This table maps an inbound/outbound Tunnel to a VC in non- TE applications.')
cpwVcMplsNonTeMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6, 1), ).setIndexNames((0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsNonTeMappingTunnelDirection"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsNonTeMappingXcTunnelIndex"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsNonTeMappingIfIndex"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsNonTeMappingVcIndex"))
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingEntry.setDescription("A row in this table represents the association between the PW VC and it's non TE MPLS outer Tunnel it's physical interface if there is no outer tunnel (VC only). An application can use this table to quickly retrieve the PW carried over specific non-TE MPLS outer tunnel or physical interface. The table in indexed by the XC index for MPLS Non-TE tunnel, or ifIndex of the port in VC only case, the direction of the VC in the specific entry and the VCIndex. The same table is used in both inbound and outbound directions, but in a different row for each direction. If the inbound association is not known, no rows should exist for it. Rows are created by the local agent when all the association data is available for display.")
cpwVcMplsNonTeMappingTunnelDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("outbound", 1), ("inbound", 2))))
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingTunnelDirection.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingTunnelDirection.setDescription('Identifies if the row represent an outbound or inbound mapping.')
cpwVcMplsNonTeMappingXcTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingXcTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingXcTunnelIndex.setDescription('Index for the conceptual XC row identifying Tunnel to VC mappings when the outer tunnel is created by the MPLS-LSR- MIB, Zero otherwise.')
cpwVcMplsNonTeMappingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6, 1, 3), InterfaceIndexOrZero())
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingIfIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingIfIndex.setDescription('Identify the port on which the VC is carried for VC only case.')
cpwVcMplsNonTeMappingVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 6, 1, 4), CpwVcIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingVcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsNonTeMappingVcIndex.setDescription('The value that represent the VC in the cpwVcTable.')
cpwVcMplsTeMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7), )
if mibBuilder.loadTexts: cpwVcMplsTeMappingTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTable.setDescription('This table maps an inbound/outbound Tunnel to a VC in MPLS-TE applications.')
cpwVcMplsTeMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1), ).setIndexNames((0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingTunnelDirection"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingTunnelIndex"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingTunnelInstance"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingTunnelPeerLsrID"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingTunnelLocalLsrID"), (0, "CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingVcIndex"))
if mibBuilder.loadTexts: cpwVcMplsTeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingEntry.setDescription("A row in this table represents the association between a PW VC and it's MPLS-TE outer Tunnel. An application can use this table to quickly retrieve the PW carried over specific TE MPLS outer tunnel. The table in indexed by the 4 indexes of a TE tunnel, the direction of the VC specific entry and the VcIndex. The same table is used in both inbound and outbound directions, a different row for each direction. If the inbound association is not known, no rows should exist for it. Rows are created by the local agent when all the association data is available for display.")
cpwVcMplsTeMappingTunnelDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("outbound", 1), ("inbound", 2))))
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelDirection.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelDirection.setDescription('Identifies if the row represent an outbound or inbound mapping.')
cpwVcMplsTeMappingTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 2), MplsTunnelIndex())
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelIndex.setDescription('Primary index for the conceptual row identifying the MPLS-TE tunnel.')
cpwVcMplsTeMappingTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 3), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelInstance.setDescription('Identifies an instance of the MPLS-TE tunnel.')
cpwVcMplsTeMappingTunnelPeerLsrID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 4), MplsLsrIdentifier())
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelPeerLsrID.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelPeerLsrID.setDescription('Identifies an Peer LSR when the outer tunnel is MPLS-TE based.')
cpwVcMplsTeMappingTunnelLocalLsrID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 5), MplsLsrIdentifier())
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelLocalLsrID.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingTunnelLocalLsrID.setDescription('Identifies the local LSR.')
cpwVcMplsTeMappingVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 107, 1, 7, 1, 6), CpwVcIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcMplsTeMappingVcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsTeMappingVcIndex.setDescription('The value that represent the VC in the cpwVcTable.')
cpwVcMplsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 1))
cpwVcMplsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 2))
cpwMplsModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 2, 1)).setObjects(("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsGroup"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundGroup"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsMappingGroup"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwMplsModuleCompliance = cpwMplsModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: cpwMplsModuleCompliance.setDescription('The compliance statement for agent that support PW over MPLS PSN operation.')
cpwVcMplsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 1, 1)).setObjects(("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsMplsType"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsExpBitsMode"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsExpBits"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTtl"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsLocalLdpID"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsLocalLdpEntityID"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsPeerLdpID"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcMplsGroup = cpwVcMplsGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsGroup.setDescription('Collection of objects needed for PW VC over MPLS PSN configuration.')
cpwVcMplsOutboundGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 1, 2)).setObjects(("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundIndexNext"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundLsrXcIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundTunnelIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundTunnelInstance"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundTunnelLclLSR"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundTunnelPeerLSR"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundIfIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundRowStatus"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsOutboundStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcMplsOutboundGroup = cpwVcMplsOutboundGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsOutboundGroup.setDescription('Collection of objects needed for outbound association of VC and MPLS tunnel.')
cpwVcMplsInboundGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 1, 3)).setObjects(("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundIndexNext"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundLsrXcIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundTunnelIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundTunnelInstance"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundTunnelLclLSR"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundTunnelPeerLSR"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundIfIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundRowStatus"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsInboundStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcMplsInboundGroup = cpwVcMplsInboundGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsInboundGroup.setDescription('Collection of objects needed for inbound association of VC and MPLS tunnel. This group is mandatory if strict mode is implemented.')
cpwVcMplsMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 107, 2, 1, 4)).setObjects(("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsNonTeMappingVcIndex"), ("CISCO-IETF-PW-MPLS-MIB", "cpwVcMplsTeMappingVcIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcMplsMappingGroup = cpwVcMplsMappingGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcMplsMappingGroup.setDescription('Collection of objects used for mapping of tunnels and VC labels to VC index.')
mibBuilder.exportSymbols("CISCO-IETF-PW-MPLS-MIB", cpwVcMplsInboundRowStatus=cpwVcMplsInboundRowStatus, cpwVcMplsNonTeMappingVcIndex=cpwVcMplsNonTeMappingVcIndex, cpwVcMplsLocalLdpID=cpwVcMplsLocalLdpID, cpwVcMplsTeMappingEntry=cpwVcMplsTeMappingEntry, cpwVcMplsOutboundTunnelIndex=cpwVcMplsOutboundTunnelIndex, cpwVcMplsTable=cpwVcMplsTable, cpwVcMplsCompliances=cpwVcMplsCompliances, cpwVcMplsOutboundIndex=cpwVcMplsOutboundIndex, cpwVcMplsTeMappingTunnelDirection=cpwVcMplsTeMappingTunnelDirection, cpwVcMplsOutboundRowStatus=cpwVcMplsOutboundRowStatus, cpwVcMplsInboundTunnelPeerLSR=cpwVcMplsInboundTunnelPeerLSR, cpwVcMplsConformance=cpwVcMplsConformance, cpwVcMplsStorageType=cpwVcMplsStorageType, cpwMplsModuleCompliance=cpwMplsModuleCompliance, cpwVcMplsMIB=cpwVcMplsMIB, cpwVcMplsInboundIndex=cpwVcMplsInboundIndex, cpwVcMplsTeMappingTunnelPeerLsrID=cpwVcMplsTeMappingTunnelPeerLsrID, cpwVcMplsOutboundTunnelPeerLSR=cpwVcMplsOutboundTunnelPeerLSR, cpwVcMplsGroups=cpwVcMplsGroups, cpwVcMplsMappingGroup=cpwVcMplsMappingGroup, cpwVcMplsInboundStorageType=cpwVcMplsInboundStorageType, cpwVcMplsOutboundIndexNext=cpwVcMplsOutboundIndexNext, cpwVcMplsPeerLdpID=cpwVcMplsPeerLdpID, cpwVcMplsOutboundEntry=cpwVcMplsOutboundEntry, cpwVcMplsNonTeMappingEntry=cpwVcMplsNonTeMappingEntry, cpwVcMplsInboundTunnelInstance=cpwVcMplsInboundTunnelInstance, cpwVcMplsInboundGroup=cpwVcMplsInboundGroup, cpwVcMplsTeMappingVcIndex=cpwVcMplsTeMappingVcIndex, cpwVcMplsNonTeMappingXcTunnelIndex=cpwVcMplsNonTeMappingXcTunnelIndex, cpwVcMplsOutboundStorageType=cpwVcMplsOutboundStorageType, cpwVcMplsOutboundTunnelLclLSR=cpwVcMplsOutboundTunnelLclLSR, cpwVcMplsInboundEntry=cpwVcMplsInboundEntry, cpwVcMplsObjects=cpwVcMplsObjects, cpwVcMplsMplsType=cpwVcMplsMplsType, cpwVcMplsInboundTable=cpwVcMplsInboundTable, cpwVcMplsTeMappingTunnelIndex=cpwVcMplsTeMappingTunnelIndex, cpwVcMplsOutboundIfIndex=cpwVcMplsOutboundIfIndex, cpwVcMplsNotifications=cpwVcMplsNotifications, cpwVcMplsInboundIndexNext=cpwVcMplsInboundIndexNext, cpwVcMplsInboundLsrXcIndex=cpwVcMplsInboundLsrXcIndex, cpwVcMplsTeMappingTunnelInstance=cpwVcMplsTeMappingTunnelInstance, cpwVcMplsNonTeMappingTable=cpwVcMplsNonTeMappingTable, cpwVcMplsGroup=cpwVcMplsGroup, cpwVcMplsInboundTunnelIndex=cpwVcMplsInboundTunnelIndex, cpwVcMplsTtl=cpwVcMplsTtl, cpwVcMplsInboundIfIndex=cpwVcMplsInboundIfIndex, cpwVcMplsTeMappingTunnelLocalLsrID=cpwVcMplsTeMappingTunnelLocalLsrID, cpwVcMplsExpBits=cpwVcMplsExpBits, cpwVcMplsNotifyPrefix=cpwVcMplsNotifyPrefix, cpwVcMplsLocalLdpEntityID=cpwVcMplsLocalLdpEntityID, PYSNMP_MODULE_ID=cpwVcMplsMIB, cpwVcMplsExpBitsMode=cpwVcMplsExpBitsMode, cpwVcMplsNonTeMappingTunnelDirection=cpwVcMplsNonTeMappingTunnelDirection, cpwVcMplsOutboundLsrXcIndex=cpwVcMplsOutboundLsrXcIndex, cpwVcMplsNonTeMappingIfIndex=cpwVcMplsNonTeMappingIfIndex, cpwVcMplsOutboundTable=cpwVcMplsOutboundTable, cpwVcMplsTeMappingTable=cpwVcMplsTeMappingTable, cpwVcMplsOutboundGroup=cpwVcMplsOutboundGroup, cpwVcMplsInboundTunnelLclLSR=cpwVcMplsInboundTunnelLclLSR, cpwVcMplsEntry=cpwVcMplsEntry, cpwVcMplsOutboundTunnelInstance=cpwVcMplsOutboundTunnelInstance)

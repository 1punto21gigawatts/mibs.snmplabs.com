#
# PySNMP MIB module STRATACOM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/STRATACOM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:11:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, MibIdentifier, Bits, NotificationType, TimeTicks, ModuleIdentity, ObjectIdentity, NotificationType, IpAddress, iso, Counter32, enterprises, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "MibIdentifier", "Bits", "NotificationType", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "NotificationType", "IpAddress", "iso", "Counter32", "enterprises", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class DisplayString(OctetString):
    pass

stratacom = MibIdentifier((1, 3, 6, 1, 4, 1, 351))
strmErrors = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 910))
snmpAgents = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100))
strmSwitchMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4))
switchInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 1))
switchServiceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 2))
switchConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 3))
switchShelf = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 4))
frServiceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1))
atmServiceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2))
voiceServiceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3))
trunkServiceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4))
shelfCnfgObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1))
switchIfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1), )
if mibBuilder.loadTexts: switchIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfTable.setDescription('A list of ports and subports, and their interfaces')
switchIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "switchIfIndex"))
if mibBuilder.loadTexts: switchIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfEntry.setDescription('A slot-port-subport entry')
switchIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfIndex.setDescription('The interface number is the index for the switchIfTable, as well as the switchMedia tables and the Trunk Service tables. The switchIFIndex will be an INTEGER with the value related to the slot, port, and subport as follows: switchIFIndex = (slot x 1000000)+(port x 10000)+(subport);')
switchIfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchIfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfSlot.setDescription('The slot number.')
switchIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchIfPort.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfPort.setDescription('The port number.')
switchIfSubPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchIfSubPort.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfSubPort.setDescription('The subport number, used to identify virtual trunks.')
switchIfMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 18, 22, 30, 39))).clone(namedValues=NamedValues(("other", 1), ("ds1", 18), ("serialPort", 22), ("ds3", 30), ("sonet", 39)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchIfMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfMediaType.setDescription('The type of interface. This object is normally used to provide information about a media layer, such as ds1, ds3, or sonet.')
switchIfService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("frameRelay", 2), ("atmAccessPort", 3), ("voiceData", 4), ("fpRoutingTrk", 5), ("atmRoutingTrk", 6), ("atmAxisIntfTrk", 7), ("atmIPXAFIntfTrk", 8), ("atmFdrIntfTrk", 9), ("atmAPSIntfTrk", 10), ("imaRoutingTrunk", 11), ("physicalMedia", 12), ("atmVsiIntfTrk", 13), ("atmParIntfTrk", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfService.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfService.setDescription('User requested service for logical interface table row. atmVsiIntfTrk is only available for BXM resource on BPX. IPX cannot support the service.')
switchIfAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("added", 6), ("deleted", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfAdmStatus.setDescription('User requested state for logical interface table row. A user may up, down, add, or delete an interface. The set-request PDU should contain values for both switchIFService and switchAdmStatus. A logical row can be created in the switchIfTable by combining an appropriate switchIFService and switchAdmStatus up(1). switchIFService and switchAdmStatus. A logical row can be deleted from the switchIfTable by combining an appropriate switchIFService and switchAdmStatus down(2). The values for added(6) and deleted(7) can be used only with a valid Trunk switchIfService (5..8).')
switchIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("added", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfOperStatus.setDescription('The current state for logical interface table row.')
switchIfPhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfPhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfPhysPort.setDescription('This Integer is a Bit map specifying which physical ports are used by the IMA trunk. Bits corresponding to the physical ports forming this IMA trunk will be set to 1. Using this Integer we can represent maximum 32 ports. For regular ATM Routing trunk bit related to that port will be set. For access lines this field is unused and will return -1. For example: Value Ports used Trunk Type ----------------------------------------------- 0 Invalid Invalid 1 1 ATM RoutingTrk 2 2 ATM RoutingTrk 3 1 & 2 IMA RoutingTrk 4 3 ATM RoutingTrk 5 1 & 3 IMA RoutingTrk 15 1,2,3 & 4 IMA RoutingTrk ')
switchIfPartiId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfPartiId.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfPartiId.setDescription('The partition ID for logical interface table row. A partition in the BXM resource is dedicated for control by the corresponding VSI Master. The partition is not available for any other cards. 0 indicates non-existent partition for all non-VSI controllers. ')
switchIfCtrlerId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchIfCtrlerId.setStatus('mandatory')
if mibBuilder.loadTexts: switchIfCtrlerId.setDescription('The controller ID for logical interface table row. The ID in the BXM resource is used to identify a VSI mster. No other card can have a VSI controller. -1 indicates an invalid controller ID')
frLportCnfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1), )
if mibBuilder.loadTexts: frLportCnfTable.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCnfTable.setDescription('The Frame Relay Logical Port Configuration table. This table provides the following areas of information on per port basis: * Port identification * Current admin & operation status * Port-specific configuration * LMI-related configuration * Port error status * Pointer(s) to other tables')
frLportCnfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "frLportSlotIndex"), (0, "STRATACOM-MIB", "frLportPortIndex"))
if mibBuilder.loadTexts: frLportCnfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCnfEntry.setDescription('An entry in the Frame Relay Logical Port Configuration table. Some entries that are applicable to a specific FRI interface are indicated in the parenthesis, such as (FRI subrate/ T1/E1 interface only). Otherwise, they are used for both interfaces.')
frLportSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSlotIndex.setDescription('The slot number')
frLportPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPortIndex.setDescription('The port number')
frLportPortDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportPortDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPortDLCI.setDescription('Port DLCI for Frame Forwarding (FRI subrate interface only). - Get Operation: If the network manager attempts to GET this object from a T1/E1 port, SNMP-OBJ-NA (Object Not Applicable -1) is returned.')
frLportAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("modify", 3), ("writeOnly", 4), ("add", 5), ("delete", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frLportAdminStatus.setDescription('User requested state for logical port table row. A user may up, down, configure, add and delete a FR Logical port.')
frLportOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inActive", 1), ("active", 2), ("looped", 3), ("failed", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frLportOperStatus.setDescription('Actual state of the logical port.')
frLportPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPortSpeed.setDescription('The baud rate of the port. For FRI T1/E1 interface, this object is determined when this port is added by the number of channels aggregated under it. Therefore, it can be configured only if the port is subrated. - Get Operation: OK for both T1/E1 and subrate interface. - Set Operation: If the network manager attempts to SET this object on a T1/E1 port, an error is reported.')
frLportClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("looped", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportClockType.setStatus('mandatory')
if mibBuilder.loadTexts: frLportClockType.setDescription('The type of port clock (FRI subrate interface only). For T1/E1 interface this object should be none. - Get Operation: If the network manager attempts to get this object from a T1/E1 port, none (3) is returned. - Set Operation: If the network manager attempts to set this object on a T1/E1 port wit, none, oror none, looped type, an error is returned.')
frLportPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fr", 1), ("atm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportPortType.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPortType.setDescription('The type of FRP subrate port. This object is not used in switch software release 8.1 It is retained for historical reasons, and possible future enhancement.')
frLportVcCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: frLportVcCount.setDescription('The number of virtual connections that terminate on this port. Note that there can be up to 252 connections per FRP cards shared among the ports. A port may have up to 252 connections allocated.')
frLportFirstVcPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportFirstVcPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frLportFirstVcPtr.setDescription('The object identifier denoting the first endpoint associated with this port. For current implementation, this OID points to the first frame relay connection on the port. It has a NULL OID value (i.e. { 0 0 }) if there is no frame relay connection on this port. The management station can retrieve all the information about the first connection by reading from row pointed to by this OID. Specifically, this OID specifies the first column of the appropriate row in the frEndptTable.')
frLportAggrChCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportAggrChCnt.setStatus('mandatory')
if mibBuilder.loadTexts: frLportAggrChCnt.setDescription('The number of aggregate channels assigned to this logical port (FRI T1/E1 interface only) when the port is added. For subrate ports, this object is always 1.')
frLportChSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s56k", 1), ("s64k", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportChSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frLportChSpeed.setDescription('The channel speed (FRI T1/E1 interface only). For FRI subrate interface this object should be set as na.')
frLportMaxTxQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportMaxTxQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: frLportMaxTxQDepth.setDescription('The maximum bytes queued for transmission from the FRP port')
frLportECNQThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportECNQThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frLportECNQThresh.setDescription('Port explicit congestion notification threshold. This is the point at which the BECN and FECN bits will be set in the communications to the user device.')
frLportDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frLportDEThresh.setDescription('The percentage of the queue depth above which frames with the Discard Eligibility bit set will be discarded. An entry of 100% effectively disables DE for the port.')
frLportIDEMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportIDEMap.setStatus('mandatory')
if mibBuilder.loadTexts: frLportIDEMap.setDescription('The flag indicating whether IDE to DE mapping should be performed.')
frLportSigProt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("xdisabled", 1), ("lmi-asyn", 2), ("disabled", 3), ("lmi-noasyn", 4), ("uni-annexA", 5), ("uni-annexD", 6), ("nni-annexA", 7), ("nni-annexD", 8), ("auto-det", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportSigProt.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSigProt.setDescription('The specified LMI operation mode. The options can be 1 - (UNI)LMI disabled 2 - (UNI)LMI and asynchronous update enabled 3 - (UNI)LMI disabled 4 - (UNI)LMI enabled but asynchronous update disabled 5 - (UNI)LMI enabled using CCITT O.933 Annex A parameters 6 - (UNI)LMI enabled using ANSI T1.617 parameters 7 - (NNI)LMI enabled using CCITT O.933 Annex A parameters 8 - (NNI)LMI enabled using ANSI T1.617 parameters Note that option 7 and 8 are both bidirectional protocols defined by FRF.2 and available only if Frame Relay NNI feature is enabled.')
frLportNNIStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportNNIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frLportNNIStatus.setDescription('The flag indicating whether NNI is active on the specified slot.port. - Get Operation only: This object is always NO if the network manager attempts to GET frLportNNIStatus from a disabled, LMI or LMI no update port. In other cases, the value of this object is determined by whether the port is configured as NNI or not.')
frLportAsynStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportAsynStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frLportAsynStatus.setDescription('The flag indicating whether the IPX should send unsolicited LMI update messages as they appear or wait for the polling from the user device. This object is applicable to only Annex A/D UNI and Annex A/D NNI protocols for write and LMI, Annex A/D UNI and Annex A/D NNI for read. - Get Operation: This object is always NO for ports without protocols; otherwise, its value is determined by the asynchronous status of the port. - Set Operation: If the network manager attempts to SET this object of a port with none or LMI protocol, an error is reported.')
frLportPolVerTmr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportPolVerTmr.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPolVerTmr.setDescription('The link integrity verification timer heartbeat (keep-alive) period. It should be set to 5 seconds more than the heartbeat time in the user device. Default is 15 seconds. - Get Operation: Since this object is not applicable to disabled protocol, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frLportErrThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportErrThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frLportErrThresh.setDescription('The number of the failures in the monitored events that cause the keep-alive process to report an alarm. - Get Operation: Since this object is not applicable to disabled protocol, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frLportMonEveCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportMonEveCnt.setStatus('mandatory')
if mibBuilder.loadTexts: frLportMonEveCnt.setDescription('The number of monitored events for the keep-alive process. A port communication fail condition is cleared after this number of successful polling cycles. - Get Operation: Since this object is not applicable to disabled protocol, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frLportCommPri = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportCommPri.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCommPri.setDescription('The flag specifying if the connection SNA priority should be communicated to the user device attached to the port. - Get Operation: Since this object is specific to LMI protocols, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported.')
frLportUpRNR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportUpRNR.setStatus('mandatory')
if mibBuilder.loadTexts: frLportUpRNR.setDescription('The upper Receiver-Not-Ready threshold. This threshold specifies the number of receiver not ready indications from the user equipment before an alarm is generated for this connection. The default is 75. - Get Operation: Since this object is specific to LMI protocols, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported.')
frLportLowRNR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportLowRNR.setStatus('mandatory')
if mibBuilder.loadTexts: frLportLowRNR.setDescription('The Lower Receiver-Not-Ready threshold. This threshold specifies the number of receiver not ready indications from the user equipment before an alarm is cleared for this connection. The default is 75. - Get Operation: Since this object is specific to LMI protocols, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported.')
frLportMinFrmFlgs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportMinFrmFlgs.setStatus('mandatory')
if mibBuilder.loadTexts: frLportMinFrmFlgs.setDescription('The minimum number of flags between frames. All values in the range 1 to 255 are valid and the default is 1.')
frLportOamThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportOamThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frLportOamThresh.setDescription('The alarm threshold for number of OAM heartbeat FastPackets missed before propagating A-bit=0. This threshold is applicable to both UNI and NNI Frame Relay ports when the node has FR NNI feature enabled and this FRP firmware supports it. - Get Operation: Since this object is not applicable to disabled protocol, SNMP-OBJ-NA (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frLportLinkTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportLinkTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frLportLinkTimer.setDescription('T391 - Link Integrity Timer (applicable to NNI FR port only), indicating the interval at which a Status Enquiry message is sent. This interval should be between 5 and 30 seconds with a default of 6 seconds. - Get Operation: the network manager attempts to GET this object from a port with a protocol other than NNIs, SNMP-OBJ-NA (-1) is returned. - Set Operation: If the network manager attempts to SET this object of a port with a protocol other than NNIs, an error is reported.')
frLportPollCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportPollCycle.setStatus('mandatory')
if mibBuilder.loadTexts: frLportPollCycle.setDescription('N391 - Full Status Polling Cycle (applicable to NNI FR port only), indicating the interval (in terms of polling cycles) at which a Full Status Report of all PVCs is requested. The exact time duration is N391*T391. This interval should be between 1 and 255 polling cycles with a default of 6. - Get Operation: If the network manager attempts to GET this object from a port with a protocol other than NNIs, SNMP-OBJ-NA (-1) is returned. - Set Operation: If the network manager attempts to SET this object of a port with a protocol other than NNIs, an error is reported.')
frLportCLLMTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportCLLMTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCLLMTimer.setDescription('The timer for CLLM messages in CLLM intervals. No CLLM if 0 is configured. If a user configures this value to be greater than 0 then it should be in the range 4 to 35. The unit is hundredth of a sec. Note that ForeSight (CLLM) is available only if the firmware supports it. - Get Operation: If the network manager attempts to GET this object from a port where ForeSight is not supported, SNMP-OBJ-NA (-1) is returned. - Set Operation: If the network manager attempts to SET this object of a port where ForeSight is not supported, an error is reported.')
frLportEFCItoBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLportEFCItoBECN.setStatus('mandatory')
if mibBuilder.loadTexts: frLportEFCItoBECN.setDescription('This object indicates whether EFCI to BECN mapping is enabled.')
frLportSrRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSrRTS.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSrRTS.setDescription('The current status of the RTS lead (subrated FRI only). Na is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DTE. Otherwise, na is returned.')
frLportSrDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSrDTR.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSrDTR.setDescription('The current status of the DTR lead (subrated FRI only). Na is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DTE. Otherwise, na is returned.')
frLportSrDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSrDCD.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSrDCD.setDescription('The current status of the DCD lead (subrated FRI only). Na is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, na is returned.')
frLportSrCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSrCTS.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSrCTS.setDescription('The current status of the CTS lead (subrated FRI only). Na is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, na is returned.')
frLportSrDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSrDSR.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSrDSR.setDescription('The current status of the DSR lead (subrated FRI only). Na is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, na is returned.')
frLportLoopBack = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("local", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportLoopBack.setStatus('mandatory')
if mibBuilder.loadTexts: frLportLoopBack.setDescription('The loopback mode')
frLportExtConFail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportExtConFail.setStatus('mandatory')
if mibBuilder.loadTexts: frLportExtConFail.setDescription('The flag indicating if the connection with the external device is lost.')
frLportStatTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2), )
if mibBuilder.loadTexts: frLportStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatTable.setDescription('The Frame Relay Logical Port Statistics table. This table ....')
frLportStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "frLportSlotIndex"), (0, "STRATACOM-MIB", "frLportPortIndex"))
if mibBuilder.loadTexts: frLportStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatEntry.setDescription('An entry in the Frame Relay Logical Port Statistics table.')
frLportRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportRxBytes.setDescription('Frame Relay Logical Port Rx bytes')
frLportRxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportRxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportRxFrms.setDescription('Frame Relay Logical Port Rx frames')
frLportTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportTxBytes.setDescription('Frame Relay Logical Port Tx bytes')
frLportTxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportTxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportTxFrms.setDescription('Frame Relay Logical Port Tx frames')
frLportTxFrmsFecns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportTxFrmsFecns.setStatus('mandatory')
if mibBuilder.loadTexts: frLportTxFrmsFecns.setDescription('Frame Relay Logical Port Tx FECN frames')
frLportTxFrmsBecns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportTxFrmsBecns.setStatus('mandatory')
if mibBuilder.loadTexts: frLportTxFrmsBecns.setDescription('Frame Relay Logical Port Tx BECN frames')
frLportCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCrcErrors.setDescription('Frame Relay Logical Port CRC errors on received frames')
frLportBadFmts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportBadFmts.setStatus('mandatory')
if mibBuilder.loadTexts: frLportBadFmts.setDescription('Frame Relay Logical Port frames with illegal formats')
frLportAlgnErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportAlgnErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frLportAlgnErrors.setDescription('Frame Relay Logical Port Alignment errors on received frames')
frLportIllegLengths = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportIllegLengths.setStatus('mandatory')
if mibBuilder.loadTexts: frLportIllegLengths.setDescription('Frame Relay Logical Port Illegal length on received frames')
frLportDmaOvruns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportDmaOvruns.setStatus('mandatory')
if mibBuilder.loadTexts: frLportDmaOvruns.setDescription('Frame Relay Logical Port number of DMA overruns')
frLportStatEnqUnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportStatEnqUnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatEnqUnis.setDescription('Frame Relay Logical Port status enquiry count. Transmit protocol LMI UNI.')
frLportStatTxUnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportStatTxUnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatTxUnis.setDescription('Frame Relay Logical Port status transmit count. Transmit protocol LMI UNI.')
frLportUpdtTxUnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportUpdtTxUnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportUpdtTxUnis.setDescription('Frame Relay Logical Port update transmit count. Transmit protocol LMI UNI.')
frLportInvldReqCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportInvldReqCnts.setStatus('mandatory')
if mibBuilder.loadTexts: frLportInvldReqCnts.setDescription('Frame Relay Logical Port invalid request count. UNI and NNI.')
frLportToutCntUnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportToutCntUnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportToutCntUnis.setDescription('Frame Relay Logical Port timeout count. Transmit protocol LMI UNI.')
frLportSeqnmErrUnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSeqnmErrUnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSeqnmErrUnis.setDescription('Frame Relay Logical Port sequence number error. Transmit protocol UNI.')
frLportUnknDlcis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportUnknDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportUnknDlcis.setDescription("Frame Relay Logical Port number of unknown DLCI's on received frames.")
frLportDeFrmsDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportDeFrmsDrops.setStatus('mandatory')
if mibBuilder.loadTexts: frLportDeFrmsDrops.setDescription('Frame Relay Logical Port number of DE dropped frames.')
frLportStatEnqNnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportStatEnqNnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatEnqNnis.setDescription('Frame Relay Logical Port status enquiry count. Transmit protocol LMI NNIs.')
frLportStatRxNnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportStatRxNnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportStatRxNnis.setDescription('Frame Relay Logical Port status transmit count. Transmit protocol LMI NNIs.')
frLportUpdtRxNnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportUpdtRxNnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportUpdtRxNnis.setDescription('Frame Relay Logical Port update transmit count. Transmit protocol LMI NNIs.')
frLportToutCntNnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportToutCntNnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportToutCntNnis.setDescription('Frame Relay Logical Port timeout count. Transmit protocol LMI NNIs.')
frLportSeqnmErrNnis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportSeqnmErrNnis.setStatus('mandatory')
if mibBuilder.loadTexts: frLportSeqnmErrNnis.setDescription('Frame Relay Logical Port sequence number error. Transmit protocol NNIs.')
frLportCllmTxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCllmTxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCllmTxFrms.setDescription('Frame Relay Logical Port CLLM (Foresight) Tx frames')
frLportCllmTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCllmTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCllmTxBytes.setDescription('Frame Relay Logical Port CLLM (Foresight) Tx bytes')
frLportCllmRxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCllmRxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCllmRxFrms.setDescription('Frame Relay Logical Port CLLM (Foresight) Rx frames')
frLportCllmRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCllmRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCllmRxBytes.setDescription('Frame Relay Logical Port CLLM (Foresight) Rx bytes')
frLportCllmFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportCllmFailures.setStatus('mandatory')
if mibBuilder.loadTexts: frLportCllmFailures.setDescription('Frame Relay Logical Port CLLM (Foresight) failures')
frLportDscdQTxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportDscdQTxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportDscdQTxFrms.setDescription('Frame Relay Logical Port discard queue Tx frames')
frLportDscdQTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportDscdQTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportDscdQTxBytes.setDescription('Frame Relay Logical Port discard queue Tx bytes')
frLportLmiFailFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportLmiFailFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frLportLmiFailFrms.setDescription('Frame Relay Logical Port LMI failure frames')
frLportLmiFailBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 1, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportLmiFailBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frLportLmiFailBytes.setDescription('Frame Relay Logical Port LMI failure bytes')
atmPortTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1), )
if mibBuilder.loadTexts: atmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortTable.setDescription('The ATM Port Configuration table.')
atmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmPortSlot"), (0, "STRATACOM-MIB", "atmPortPort"))
if mibBuilder.loadTexts: atmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortEntry.setDescription('An entry in the ATM Port Configuration table.')
atmPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortSlot.setDescription('The slot number')
atmPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortPort.setDescription('The port number')
atmPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("modify", 3), ("writeOnly", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortAdminStatus.setDescription('User requested state for port table row. A user may Up or Down an existing port. The user may also modify the characteristics of the port.')
atmPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("looped", 3), ("failed", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortOperStatus.setDescription('Actual state of the port.')
atmPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortType.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortType.setDescription('Indicates whether this is a UNI or NNI port. The switch supports this operation only on a per-card level, so changing one port changes the other also. The value of this object cannot be changed if there are active connections on the card.')
atmPortIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("t3", 2), ("e3", 3), ("oc3-smf", 4), ("oc3-mmf", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortIfType.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIfType.setDescription('The type of interface for this port.')
atmPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortSpeed.setDescription('The speed of the port in cells per seconds.')
atmPortAxis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("t1", 2), ("e1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortAxis.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortAxis.setDescription("Indicates port support for BASIS shelf. The value of this object cannot be changed if there are active connections on the port. For ASI-2 the value of this object is 'none'. An attempt to change the value of this object on an ASI-2 will return a BadValue error.")
atmPortVcCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortVcCount.setDescription('The number of virtual connections that terminate on this port. A port may have up to 1024 connections allocated.')
atmPortFirstVcPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortFirstVcPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortFirstVcPtr.setDescription('The object identifier denoting the first connection endpoint associated with this port. For current implementation, this OID points to the first connection on the port. It has a NULL OID value (i.e. { 0 0 }) if there is no connection on this port. The management station can retrieve all the information about the first connection by reading from row pointed to by this OID. Specifically, this OID specifies the first column of the appropriate row in the atmEndptTable.')
atmPortMetro = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortMetro.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortMetro.setDescription("Metro Data Cell Header Format. This object applies to T3 non-axis ports. The value of this object is set to disable by the switch every time that the value of the object atmPortAxis changes to or from 'none'.")
atmPortMgmtProto = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lmi", 2), ("ilmi", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortMgmtProto.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortMgmtProto.setDescription('Indicates the port management protocol used for this port.')
atmPortIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiVpi.setDescription('The virtual path identifier for the ILMI protocol.')
atmPortIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiVci.setDescription('The virtual channel identifier for the ILMI protocol.')
atmPortIlmiPollEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiPollEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiPollEnable.setDescription('Enable ILMI keep alive polling procedure.')
atmPortIlmiTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiTrapEnable.setDescription('if enabled the ILMI agent will send unsolicited Trap PDUs.')
atmPortIlmiPollIntrvl = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiPollIntrvl.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiPollIntrvl.setDescription('The number of seconds between each keep alive poll transmitted by the port (T491).')
atmPortIlmiErrorThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiErrorThresh.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiErrorThresh.setDescription('The number of keep alive polls that must fail within a window of N492 polls, before the port is placed in the failed state (N491).')
atmPortIlmiEventThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortIlmiEventThresh.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortIlmiEventThresh.setDescription('It specifies the number of keep alive polls within which if N491 polls fail the port is placed in the failed state (N492).')
atmPortLmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiVpi.setDescription('The virtual path identifier for the LMI protocol.')
atmPortLmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiVci.setDescription('The virtual channel identifier for the ILMI protocol.')
atmPortLmiPollEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiPollEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiPollEnable.setDescription('if enable an Status Enquiry message is sent when the polling timer expires.')
atmPortLmiStatEnqTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiStatEnqTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiStatEnqTimer.setDescription('Link integrity timer for the port (T393).')
atmPortLmiUpdStatTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiUpdStatTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiUpdStatTimer.setDescription('Update status timer for the port (T394).')
atmPortLmiStatEnqRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiStatEnqRetry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiStatEnqRetry.setDescription('The maximum number of times a Status Enquiry message is retransmitted. A Status Enquiry message is retransmitted when timer T393 expires (N394).')
atmPortLmiUpdStatRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiUpdStatRetry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiUpdStatRetry.setDescription('The maximum number of times an Update Status message is retransmitted. An Update Status message is retransmitted when timer T394 expires (N395).')
atmPortLmiPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortLmiPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortLmiPollTimer.setDescription('Polling timer (T396). If polling is enabled a Status Enquiry message is sent when this timer expires.')
atmPortPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortPercUtil.setDescription('Percentage Utilization can be disabled or enabled. If the use of percent utilization is disabled, the bandwidth for the connections terminating on the port will be used to determine the port load. If the use of percent utilization is enabled, the bandwidth for the connection is multiplied by the percent utilization for the connection to determine the port load.')
atmPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2), )
if mibBuilder.loadTexts: atmPortQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueTable.setDescription('The ATM port egress queue table.')
atmPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmPortSlot"), (0, "STRATACOM-MIB", "atmPortPort"), (0, "STRATACOM-MIB", "atmPortQueueIndex"))
if mibBuilder.loadTexts: atmPortQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueEntry.setDescription('An entry in the ATM port queue table.')
atmPortQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueIndex.setDescription("Index into the port egress queue array of the given port that uniquely identifies this queue. if the value of the atmPortQueueType object is 'axis', then the value of this object also specifies the Axis slot associated with this queue.")
atmPortQueueAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modify", 1), ("writeOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortQueueAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueAdminStatus.setDescription('User requested state for this port queue table row. The only operation supported in this table is modify.')
atmPortQueueType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("unused", 2), ("cbr", 3), ("abr", 4), ("vbr", 5), ("axis", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortQueueType.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueType.setDescription("The type of the queue. If the type is 'axis', then the atmPortQueueIndex specifes the Axis slot associated with this queue.")
atmPortQueueDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortQueueDepth.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueDepth.setDescription('The storage depth allocated to this queue in block of cells. The block size is one cell for T3/E3 and 64 cells for OC3. The aggregate of the queue depths for all queues cannot exceed the maximum storage available for the port.')
atmPortQueueClpHi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortQueueClpHi.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueClpHi.setDescription('The CLP tagging activation threshold for this queue expressed as a percentage of queue depth.')
atmPortQueueClpLo = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortQueueClpLo.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueClpLo.setDescription('The CLP tagging deactivation threshold for this queue expressed as a percentage of queue depth.')
atmPortQueueEfciTh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPortQueueEfciTh.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueEfciTh.setDescription('The EFCI threshold for this queue expressed as a percentage of queue depth.')
atmPortQueueAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("off", 1), ("always", 2), ("ok", 3), ("minGuar", 4), ("minSmooth", 5), ("minDelay", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortQueueAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortQueueAlgorithm.setDescription('The queue service algorithm: off: never serve always: always serve ok: ok to serve, not minimum guaranteed min-guar: minimum guaranteed bw, no limit min-smooth: minimum guaranteed bw, smoothed min-delay: minimum guaranteed bw, delay limited ')
atmPortStatTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3), )
if mibBuilder.loadTexts: atmPortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatTable.setDescription('The ATM Port Statistics table.')
atmPortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmPortSlot"), (0, "STRATACOM-MIB", "atmPortPort"))
if mibBuilder.loadTexts: atmPortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatEntry.setDescription('An entry in the ATM Port Statistics table.')
atmPortStatUnknVpiVcis = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatUnknVpiVcis.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatUnknVpiVcis.setDescription('The number of cells discarded due to unknown address.')
atmPortStatBufferOvfls = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatBufferOvfls.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatBufferOvfls.setDescription('The number of times the port has incurred a cell buffer overflow.')
atmPortStatNonZeroGfcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatNonZeroGfcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatNonZeroGfcs.setDescription('The number of non-zero GFC cells for a UNI port. For a NNI port this value is 0.')
atmPortStatIsuDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIsuDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIsuDiscards.setDescription('The count of cells discarded by the Ingress Control Service Unit.')
atmPortStatIsuEmptys = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIsuEmptys.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIsuEmptys.setDescription('The Ingress Control Service Unit free list empty count.')
atmPortStatAisRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatAisRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatAisRxs.setDescription('Total numbers of cells received with AIS.')
atmPortStatFerfRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatFerfRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatFerfRxs.setDescription('Total numbers of cells received with FERF.')
atmPortStatCellsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatCellsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatCellsRxs.setDescription('Total numbers of cells received.')
atmPortStatClpRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatClpRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatClpRxs.setDescription('numbers of cells received with CLP set.')
atmPortStatEfciRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatEfciRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatEfciRxs.setDescription('Total numbers of cells received with EFCI set.')
atmPortStatBcmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatBcmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatBcmRxs.setDescription('Total numbers of BCM cells received.')
atmPortStatCellsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatCellsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatCellsTxs.setDescription('Total numbers of cells transmitted.')
atmPortStatOamRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatOamRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatOamRxs.setDescription('Total numbers of OAM cells received.')
atmPortStatPayldErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatPayldErrs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatPayldErrs.setDescription('Total numbers of cells discarded due to BIP-16.')
atmPortStatClpTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatClpTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatClpTxs.setDescription('Total numbers of cells transmitted with CLP set.')
atmPortStatEfciTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatEfciTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatEfciTxs.setDescription('Total numbers of cells transmitted with EFCI set.')
atmPortStatHdrDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatHdrDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatHdrDiscards.setDescription('Total numbers of cells discarded due to parity error.')
atmPortStatIlmiGetRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetRxs.setDescription('ILMI Get requests received.')
atmPortStatIlmiGetNextRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetNextRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetNextRxs.setDescription('ILMI Get Next requests received.')
atmPortStatIlmiGetNextTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetNextTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetNextTxs.setDescription('ILMI Get Next requests transmitted.')
atmPortStatIlmiSetRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiSetRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiSetRxs.setDescription('ILMI Set requests received.')
atmPortStatIlmiTrapRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiTrapRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiTrapRxs.setDescription('ILMI Trap received.')
atmPortStatIlmiGetRspRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetRspRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetRspRxs.setDescription('ILMI Get Response messages received.')
atmPortStatIlmiGetTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetTxs.setDescription('ILMI Get requests transmitted.')
atmPortStatIlmiGetRspTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiGetRspTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiGetRspTxs.setDescription('ILMI Get Response messages transmitted.')
atmPortStatIlmiTrapTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiTrapTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiTrapTxs.setDescription('ILMI Traps transmitted.')
atmPortStatIlmiUnkRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatIlmiUnkRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatIlmiUnkRxs.setDescription('Unknown PDU type received.')
atmPortStatLmiStatTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatTxs.setDescription('LMI Status messages transmitted.')
atmPortStatLmiUpdtStatTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiUpdtStatTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiUpdtStatTxs.setDescription('LMI Update Status messages transmitted.')
atmPortStatLmiStatAckTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatAckTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatAckTxs.setDescription('LMI Status Acknowledge messages transmitted.')
atmPortStatLmiStatEnqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatEnqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatEnqTxs.setDescription('LMI Status Enquiry messages transmitted.')
atmPortStatLmiStatEnqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatEnqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatEnqRxs.setDescription('LMI Status Enquiry messages received.')
atmPortStatLmiStatRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatRxs.setDescription('LMI Status messages received.')
atmPortStatLmiUpdStatRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiUpdStatRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiUpdStatRxs.setDescription('LMI Update Status messages received.')
atmPortStatLmiStatAckRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 2, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPortStatLmiStatAckRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPortStatLmiStatAckRxs.setDescription('LMI Status Acknowledge messages received.')
voiceChannelTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1), )
if mibBuilder.loadTexts: voiceChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelTable.setDescription('The voice channel table has channel specific configuration information. This is available for each of the voice channel.')
voiceChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "voiceChannelSlotIndex"), (0, "STRATACOM-MIB", "voiceChannelChannelIndex"))
if mibBuilder.loadTexts: voiceChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEntry.setDescription('An entry in the voice Channel information table.')
voiceChannelSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceChannelSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelSlotIndex.setDescription(' The Slot Number.')
voiceChannelChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceChannelChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelChannelIndex.setDescription('The channel number. This shall serve as the index to this table')
voiceChannelAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("writeOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelAdminStatus.setDescription('User requested operation for this table. The operations supported on this table are modify and create The existing interfaceTypes cannot be changed (Please refer to voiceChannelIfTypeName variable definition). For associating a channel with a new interfaceType, all the values of the columns specified in the Description clause of voiceChannelIfTypeName should be provided.')
voiceChannelEndptPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceChannelEndptPtr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEndptPtr.setDescription('Pointer to channel End point table. This may not necessarily have a value. In the case that there is no corresponding voiceChannelEntry in the endpoint table, this would be 0.')
voiceChannelIf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("t1", 2), ("e1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceChannelIf.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIf.setDescription('The type of the line interface associated with this channel')
voiceChannelAdapVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelAdapVoice.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelAdapVoice.setDescription("Determines whether the channel is configured for Adaptive voice. This feature must be configured at both ends of the channel. The adaptive voice feature must also be equipped at each node terminating the connection. If the adaptive voice feature is enabled for a channel connection which is used for a 'c' or 'v' connection, VAD is automatically disabled on that channel when trunk bandwidth is available, and it is enabled when trunk bandwidth is needed. By DEFAULT this is True. This variable is not applicable, if the channel is used for signalling.")
voiceChannelDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inband", 1), ("pulse", 2), ("userConfigured", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelDialType.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelDialType.setDescription('Information about dail type used on the channel. By default Inband dail type is used. In case it is of type userConfigured, the related objects for which values need to be provided are : voiceChannelSignallingDelay voiceChannelMinWink voiceChannelPlayOutDelay. If the values for any of the above variables are not provided for User Configured Dial type, the current values in the Database shall be retained. Each of the variables can be set independently. These hold good for the CDP and CIP cards. By default every voice connection is configured with Inband signalling. When the dialType is Inband or Pulse, these are the values which are allowed : SignallingType Inband Pulse voiceChannelSignallingDelay 96 96 voiceChannelMinWink 20 20 voiceChannelPlayOutDelay 200 200. When the dial type is INBAND or PULSE SET on the related objects mentioned above are not allowed')
voiceChannelDtSignallingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelDtSignallingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelDtSignallingDelay.setDescription('It is the signalling delay, in milliseconds (ms), to assign the user configurable dail type. The value specified is rounded to the closest multiple of 1.5 ms. The default value for inband - 96 pulse - 96. When the dial type is Inband or Pulse value for this object should not be provided.')
voiceChannelDtMinWink = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(120, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelDtMinWink.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelDtMinWink.setDescription('It is the minimum wink, in milliseconds, to assign to the user configurable dial type. The value specified is rounded off to the nearest whole multiple of 3ms. The default value for inband - 20 pulse - 20. When the dial type is Inband or Pulse value for this object should not be provided.')
voiceChannelDtPlayOutDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelDtPlayOutDelay.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelDtPlayOutDelay.setDescription('It is the playout delay, in milliseconds, assigned to the user configurable dial type. The value specified is rounded to the closest multiple of 1.5 second. The default value for inband - 200 pulse - 200. When the dial type is Inband or Pulse value for this object should not be provided.')
voiceChannelRecvSigABit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelRecvSigABit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelRecvSigABit.setDescription("It represents the configuration of bit conversion to received signalling on a channel. The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently noXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization value is xmitTransparent(3)")
voiceChannelRecvSigBBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelRecvSigBBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelRecvSigBBit.setDescription("It represents the configuration of bit conversion to received signalling on a channel. The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization value is xmitTransparent(3).")
voiceChannelRecvSigCBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelRecvSigCBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelRecvSigCBit.setDescription("It represents the configuration of bit conversion to received signalling on a channel. The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is zero. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization value is xmitTransparent(3)")
voiceChannelRecvSigDBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelRecvSigDBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelRecvSigDBit.setDescription("It represents the configuration of bit conversion to received signalling on a channel. The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donoXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization values is xmitTransparent(3)")
voiceChannelXmitSigABit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelXmitSigABit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelXmitSigABit.setDescription("This allows the node to pass A channel signalling bits through unchanged, or to invert / hold them at a given value for a CDP/CIP circuit line. It affects signalling bits in the transmit direction (eg. to the CPE / PABX). The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization values is xmitTransparent(3).")
voiceChannelXmitSigBBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelXmitSigBBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelXmitSigBBit.setDescription("This allows the node to pass B channel signalling bits through unchanged, or to invert / hold them at a given value for a CDP/CIP circuit line. It affects signalling bits in the transmit direction (eg. to the CPE / PABX). The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization values is xmitTransparent(3)")
voiceChannelXmitSigCBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelXmitSigCBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelXmitSigCBit.setDescription("This allows the node to pass C channel signalling bits through unchanged, or to invert / hold them at a given value for a CDP/CIP circuit line. It affects signalling bits in the transmit direction (eg. to the CPE / PABX). The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization values is xmitTransparent(3)")
voiceChannelXmitSigDBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("xmitTransparent", 3), ("donotXmit", 4), ("revSigBit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelXmitSigDBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelXmitSigDBit.setDescription("This allows the node to pass D channel signalling bits through unchanged, or to invert / hold them at a given value for a CDP/CIP circuit line. It affects signalling bits in the transmit direction (eg. to the CPE / PABX). The value is given as one of the enumeration above which have following meaning: one(1) : Signalling bit is 1 zero(2) : Signalling bit is 0 xmitTransparent(3) : Transmit signalling bit transparently donotXmit(4) : Don't transmit signalling bit revSigBit(5) : Reverse/Inverse signalling bit. The default value is one. If the signalling is not used at all, the A B C and D bits have 1 1 0 1 values respectively. The initialization values is xmitTransparent(3)")
voiceChannelIfTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("userConfig", 1), ("unConfig", 2), ("noSig", 3), ("forceSig", 4), ("twoWireENM", 5), ("fourWireENM", 6), ("fXO", 7), ("fXSGS", 8), ("fXSLS", 9), ("dP0", 10), ("dPT", 11), ("rP0", 12), ("rPT", 13), ("sDP0", 14), ("dX", 15), ("eT0", 16), ("pLAR", 17), ("pLR", 18), ("rD", 19), ("r1", 20), ("sSDC5A", 21), ("r2Backward", 22), ("r2Forward", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfTypeName.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfTypeName.setDescription("It represents the interface type assigned to a channel. The following different types of interfaces are possbile: Number InterfaceType A B C D CondName 1 {User Config, U, U, N, N, a}, 2 {Unconfig, U, U, N, N, a}, 3 {No Sig, U, U, U, U, a}, 4 {Force Sig, U, U, N, N, a}, 5 {2W E&M, 0, X, N, N, a}, 6 {4W E&M, 0, X, N, N, a}, 7 {FXO, 1, 1, N, N, b}, 8 {FXS G/S, 0, 1, N, N, c}, 9 {FXS L/S, 0, X, N, N, d}, 10 {DPO, 0, X, N, N, a}, 11 {DPT, 0, X, N, N, a}, 12 {RPO, 0, X, N, N, a}, 13 {RPT, 0, X, N, N, a}, 14 {SDPO, 0, X, N, N, a}, 15 {DX, 0, X, N, N, a}, 16 {ETO, U, U, N, N, e}, 17 {PLAR, U, U, N, N, d}, 18 {PLR, 0, X, N, N, a}, 19 {RD, U, U, N, N, a}, 20 {R1 (SOCOTEL), 0, N, N, N, e}, 21 {SSDC5A, 1, 1, 0, 1, f}, 22 {R2 (backward), 1, 1, N, N, e}, 23 {R2 (forward), 1, 0, N, N, d} Where A B C D are the signalling bits corresponding to Onhook values having the following meanings: 0 meaning 0 1 meaning 1 X meaning donot Care U meaning unknown N meaning not used and the Conditioning templates can be any of a b c d e f types. If the IPX receives A B C D bits corresponding to the on-hook values, that channel is known to be on-hook. Otherwise that channel is known to be offhook. Each interface except for UserConfigured type has a pre-determined conditioning template associated with it which are of 5 different types apart from user configurable conditioning templates. Examples of valid values are any of the above interface number given above. If it is a userConfigured OR Forced Signalling (FCDSIG = 4) interface type then the following variables need to be supplied: voiceChannelIfOnhkABit voiceChannelIfOnhkBBit voiceChannelIfOnhkCBit voiceChannelIfOnhkDBit voiceChannelIfCondName. If any of the above variables are not provided with values then, the current values in the data base is retained.In all other cases the values are as shown in the table above. The interface type is ignored for 'D' type connections. The default values for a channel: InterfaceType A B C D CondName UnConfigured U U N N a. If a pre-defined Interface type is chosen in a SET, values for the other related objects should not be provided.")
voiceChannelIfOnhkABit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("donotCare", 3), ("unKnown", 4), ("notUsed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfOnhkABit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfOnhkABit.setDescription("It represents the value of A signalling bit, for which the IPX shall recognize a on-hook condition. The default value is unKnown(4). The value corresponding to pre-defined Interface types have been given in the table in the 'Description' clause of the object voiceChannelIfTypeName. If the interface type is pre-defined type, value is not provided for this object.")
voiceChannelIfOnhkBBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("donotCare", 3), ("unKnown", 4), ("notUsed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfOnhkBBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfOnhkBBit.setDescription("It represents the value of B signalling bit, for which the IPX shall recognize a on-hook condition. The default value is unKnown(4). The value corresponding to pre-defined Interface types have been given in the table in the 'Description' clause of the object voiceChannelIfTypeName. If the interface type is pre-defined type, value is not provided for this object.")
voiceChannelIfOnhkCBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("donotCare", 3), ("unKnown", 4), ("notUsed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfOnhkCBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfOnhkCBit.setDescription("It represents the value of C signalling bit, for which the IPX shall recognize a on-hook condition. The default value is unKnown(4). The value corresponding to pre-defined Interface types have been given in the table in the 'Description' clause of the object voiceChannelIfTypeName. If the interface type is pre-defined type, value is not provided for this object.")
voiceChannelIfOnhkDBit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("one", 2), ("donotCare", 3), ("unKnown", 4), ("notUsed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfOnhkDBit.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfOnhkDBit.setDescription("It represents the value of D signalling bit, for which the IPX shall recognize a on-hook condition. The default value is unKnown(4). The value corresponding to pre-defined Interface types have been given in the table in the 'Description' clause of the object voiceChannelIfTypeName. If the interface type is pre-defined type, value is not provided for this object.")
voiceChannelIfCondIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelIfCondIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelIfCondIndex.setDescription("It represents the name of one of the condition criterion templates defined in the voiceConditioningTable. The value corresponding to pre-defined interface Types have been given in the table in the 'Description' clause of the object voiceChannelIfTypeName. Currentely, only the pre-defined conditioning templates are supported. If the interface type is pre-defined type, value is not provided for this object.")
voiceChannelEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEchoCancel.setDescription('This represents the integrated echo canceller channel parameters associated with the specified voice channel. By default it is disabled. If it has to be enabled from a disabled state then valued for following variables have to be supplied: Name Value Description voiceChannelEchoRtnLoss High/Low Set the echo return loss to High / Low. voiceChannelEchoTone Enable/ Enables or disables the Disable tone disabler. voiceChannelEchoConv Enable/ Enables or disables Disable convergence. voiceChannelEchoNlp Enable/ Enables or disables Disable non-linear processing. If any one of the variables are not specified, the previous value of that variable shall be retained. If the Echo Cancel is to be SET to disable, values for the related parameters are not allowed in the SET.')
voiceChannelEchoRtnLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelEchoRtnLoss.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEchoRtnLoss.setDescription('This represents the Echo Return Loss if the echo canceller is enabled. The default value is High(2). If the Echo Cancel is to be SET to disable, values for the related parameters are not allowed in the SET.')
voiceChannelEchoTone = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelEchoTone.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEchoTone.setDescription('This represents whether the Tone disabler is enabled. The default value is Enable(1). If the Echo Cancel is to be SET to disable, values for the related parameters are not allowed in the SET.')
voiceChannelEchoConv = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelEchoConv.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEchoConv.setDescription('This represents whether the Echo Convergence is enabled. The default value is Enable(1). If the Echo Cancel is to be SET to disable, values for the related parameters are not allowed in the SET.')
voiceChannelEchoNlp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelEchoNlp.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelEchoNlp.setDescription('This represents whether the NonLinear processing is enabled. The default value is Enable(1). If the Echo Cancel is to be SET to disable, values for the related parameters are not allowed in the SET.')
voiceChannelInGain = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelInGain.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelInGain.setDescription('This variable represents the amount of gain inserted at the receiver side of a CDP / CIP circuit line on voice connections. The gain is specified in decibels to be assigned to the channel. The gain can be configured between +6 dB and -8 dB. By default it is zero.')
voiceChannelOutGain = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelOutGain.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelOutGain.setDescription('This variable represents the amount of gain inserted at the transmit side of a CDP / CIP circuit line on voice connections. The gain is specified in decibels to be assigned to the channel. The gain can be configured between +6 dB and -8 dB. By default it is zero.')
voiceChannelUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceChannelUtil.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelUtil.setDescription('Represents the percentage of utilization of this channel. This object informs the system software of the expected utilization rate of connections with traffic depdendent compression algorithm. For voice connections with VAD. Acceptable values are in the range of 0 to 100. The default value for voice is 40.')
connNextEndptIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connNextEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connNextEndptIndex.setDescription('This object contains an appropriate value to be used when creating entries in the connection specific end-point tables (e.g. frEndptTable). A value of minus one (-1) indicates that no unassigned entries are available. To obtain the connNextEndptIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
errStatusLastIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errStatusLastIndex.setStatus('obsolete')
if mibBuilder.loadTexts: errStatusLastIndex.setDescription('If at least one entry exists in the error status table for the given manager, the value of this object contains the index corresponding to the last entry. If no entry exists in the error status table for the given manager the value of this object is -1.')
errStatusTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 3), )
if mibBuilder.loadTexts: errStatusTable.setStatus('deprecated')
if mibBuilder.loadTexts: errStatusTable.setDescription('A List of Error Statuses for a given SNMP Manager')
errStatusTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 3, 1), ).setIndexNames((0, "STRATACOM-MIB", "errReqId"))
if mibBuilder.loadTexts: errStatusTableEntry.setStatus('deprecated')
if mibBuilder.loadTexts: errStatusTableEntry.setDescription('A General Error Status Entry.')
errReqId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errReqId.setStatus('mandatory')
if mibBuilder.loadTexts: errReqId.setDescription('This object contains the PDU request ID associated with the error.')
errCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34))).clone(namedValues=NamedValues(("success", 1), ("existErr", 2), ("syntaxErr", 3), ("resourceErr", 4), ("databaseLocked", 5), ("otherErr", 6), ("wrongType", 7), ("wrongLength", 8), ("wrongEncoding", 9), ("wrongValue", 10), ("noCreation", 11), ("inconsistentValue", 12), ("resourceUnavailable", 13), ("commitFailed", 14), ("undoFailed", 15), ("authorizationError", 16), ("notWritable", 17), ("inconsistentName", 18), ("featureDisabled", 19), ("m32Problem", 20), ("sarProblem", 21), ("bnmProblem", 22), ("ascUpdFailed", 23), ("lineEnabled", 24), ("lineDisabled", 25), ("lmMismatch", 26), ("lineHasPorts", 27), ("portEnabled", 28), ("portDisable", 29), ("portHasChan", 30), ("chanEnabled", 31), ("chanDisabled", 32), ("dlciEnabled", 33), ("dlciDisabled", 34)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: errCode.setStatus('mandatory')
if mibBuilder.loadTexts: errCode.setDescription('This object contains an error status code used by the manager to take automated corrective actions when requests encounter failures. If no error is encountered, a successful status is provided.')
errStatusDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errStatusDesc.setStatus('mandatory')
if mibBuilder.loadTexts: errStatusDesc.setDescription('This object contains error status information for failed SETS to one or more objects in frEndptTable and/or vcTable. This object is updated only on failed SETS. Since the SNMP standard allows only limited number of error status returns, the managers can retrieve this variable to get additional information on a failed SET. Typically this object will contain information specifiying date, type of operation (SET or GET), current SNMP table (connTable, frEndptTable,... etc) and additional error information.')
connTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4), )
if mibBuilder.loadTexts: connTable.setStatus('mandatory')
if mibBuilder.loadTexts: connTable.setDescription('A List of Connection Virtual Circuit Entries')
connTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1), ).setIndexNames((0, "STRATACOM-MIB", "connIndex"))
if mibBuilder.loadTexts: connTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connTableEntry.setDescription('A General Connection Entry')
connIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connIndex.setDescription('Connection Table Index for this connection.')
connLclEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connLclEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connLclEndptDesc.setDescription('Description for Local VC end-point. Contains information about the domain, nodename, slot, port, and address value for the end-point. For example, D1.Node1.12.1.100.200, is a valid description. For Frame Relay groups, the domain, remote nodename, and groupid are given, for example D1.Node2.1 is valid.')
connType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("frameRelay", 1), ("atf", 2), ("atm", 3), ("voice", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connType.setStatus('mandatory')
if mibBuilder.loadTexts: connType.setDescription('Connection type')
connOeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connOeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connOeIndex.setDescription("Index into remote node's connTable for this connection end-point.")
connRmtEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connRmtEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connRmtEndptDesc.setDescription('Description for Remote VC end-point. Contains information about the domain, nodename, slot, port, and address value for the end-point. For example, D2.Node2.10.1.100.200, is a valid description. This object contains no information for Frame Relay connection groups.')
connMasterFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMasterFlag.setStatus('mandatory')
if mibBuilder.loadTexts: connMasterFlag.setDescription('Specifies whether this end-point is the owner of the connection.')
connClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connClassOfService.setStatus('mandatory')
if mibBuilder.loadTexts: connClassOfService.setDescription('A class of service for this connection. The lower the class value, the higher the routing priority of the connection.')
connGroupFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connGroupFlag.setStatus('mandatory')
if mibBuilder.loadTexts: connGroupFlag.setDescription('Specifies whether this is a grouped connection. In the grouped connection case, the connFirstEndptPtr object is a pointer to a list of end-points in this group.')
connAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("modify", 3), ("writeOnly", 4), ("createGroup", 5), ("deleteGroup", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connAdminStatus.setDescription('User requested state for connection. A user can change the state of the connection to up or down. The user is also allowed to modify the connections class of service or preferred route. The connOperStatus object maintains the current status of the connection.')
connOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("okPendingDown", 2), ("down", 3), ("failed", 4), ("okPendingRoute", 5), ("unknown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connOperStatus.setDescription('Actual state of the connection. If the state is failed, then look to the objects connNoRouteFoundFailure, and connBumpFailure to determine reason for failure.')
connNoRouteFoundFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connNoRouteFoundFailure.setStatus('mandatory')
if mibBuilder.loadTexts: connNoRouteFoundFailure.setDescription('Connection is failed is because no route to the remote end-point could be found.')
connBumpFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connBumpFailure.setStatus('mandatory')
if mibBuilder.loadTexts: connBumpFailure.setDescription('Connection is failed because of insufficient bandwidth to route to the remote end-point. This may have also been caused because a higher priority connection took this connections bandwidth. A higher priority connection is one with the lowest class of service (COS).')
connFirstEndptPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connFirstEndptPtr.setStatus('mandatory')
if mibBuilder.loadTexts: connFirstEndptPtr.setDescription('Pointer to end-point specific information. Using this pointer the user can obtain configuration and statistical information about the connection. Specifically, this object identifier specifies the MIB tree identification of the first column of the appropriate end-point table row.')
connCurrRouteDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connCurrRouteDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connCurrRouteDesc.setDescription("Descriptor of the current route (all hops specified). Descriptor gives information about the domain, nodename, slot, and possibly a port for each hop in the route. For example, Node1 15--15Node2 is a valid route specifying a terrestrial link between Node1 slot 15 and Node2 slot 15. Inter-domain connection's routes will append the remote domain and nodename of the terminating endpoint.")
connPrefRouteDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPrefRouteDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connPrefRouteDesc.setDescription('Descriptor of the preferred route (all hops specified). Descriptor gives information about the domain, nodename, slot, and possibly a port for each hop in the route. For example, Node1 15--15Node2 is a valid route specifying a terrestrial link between Node1 slot 15 and Node2 slot 15. While doing a SET operation the following general format for specifying a preferred route should be used: (<node-name>.<TRK>[.0])* - <node-name> (<node-name>.<slot.port>)* - <node-name> Some more valid descriptions are: 1) Node1.15.1 - Node2.13.1 - Node3 2) Node1.15.1-Node2.13.1-Node3 3) Node1.15 - Node2.12 - Node3.15 - Node4 4) Node1.15.0 - Node2.12.0 - Node3.15.0 - Node4 NOTE: a> (...)* notation means the description inside parenthesis may repeat any number of times, only limited by the total length which is 255 and the [...] notation signifies that it is optional. b> 1) & 2) are equivalent so are 3) & 4). c> Even GET preferred route description will be made consistent with that of SET operation in the future releases. d> An empty string (null or string of blank spaces) will clear the pref route description equivalent to delete pref route.')
connMstOSpacePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMstOSpacePkts.setStatus('mandatory')
if mibBuilder.loadTexts: connMstOSpacePkts.setDescription('This variable provides the minimum packet load available on the current path of this connection in master->slave direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is currently routed and reporting the minimum available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. These values are returned in packets per second.')
connMstOSpaceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMstOSpaceCells.setStatus('mandatory')
if mibBuilder.loadTexts: connMstOSpaceCells.setDescription('This variable provides the minimum cell load available on the current path of this connection in master->slave direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is currently routed and reporting the minimum available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. These values are returned in cells per second.')
connMstOSpaceBdaCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMstOSpaceBdaCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connMstOSpaceBdaCmax.setDescription('This variable provides the minimum BData A Cmax available on the current path of this connection in master->slave direction. This variable is determined by comparing available BData A Cmax on every trunk on which the connection is currently routed and reporting the minumim available. For interdomain connections this value represents available BData A Cmax through all domains. This variable is meaningful for routed connections only. These values are returned in bytes.')
connMstOSpaceBdbCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMstOSpaceBdbCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connMstOSpaceBdbCmax.setDescription('This variable provides the minimum BData B Cmax available on the current path of this connection in master->slave direction. This variable is determined by comparing available BData B Cmax on every trunk on which the connection is currently routed and reporting the minumim available. For interdomain connections this value represents available BData B Cmax through all domains. This variable is meaningful for routed connections only. These values are returned in bytes.')
connSlvOSpacePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connSlvOSpacePkts.setStatus('mandatory')
if mibBuilder.loadTexts: connSlvOSpacePkts.setDescription('This variable provides the minimum packet load available on the current path of this connection in slave->master direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is currently routed and reporting the minumim available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. These values are returned in packets per second.')
connSlvOSpaceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connSlvOSpaceCells.setStatus('mandatory')
if mibBuilder.loadTexts: connSlvOSpaceCells.setDescription('This variable provides the minimum cell load available on the current path of this connection in slave->master direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is currently routed and reporting the minumim available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. These values are returned in cells per second.')
connSlvOSpaceBdaCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connSlvOSpaceBdaCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connSlvOSpaceBdaCmax.setDescription('This variable provides the minimum BData A Cmax available on the current path of this connection in slave->master direction. This variable is determined by comparing available BData A Cmax on every trunk on which the connection is currently routed and reporting the minumim available. For interdomain connections this value represents available BData A Cmax through all domains. This variable is meaningful for routed connections only. These values are returned in bytes.')
connSlvOSpaceBdbCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connSlvOSpaceBdbCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connSlvOSpaceBdbCmax.setDescription('This variable provides the minimum BData B Cmax available on the current path of this connection in slave->master direction. This variable is determined by comparing available BData B Cmax on every trunk on which the connection is currently routed and reporting the minumim available. For interdomain connections this value represents available BData B Cmax through all domains. This variable is meaningful for routed connections only. These values are returned in bytes.')
connIcaRTD = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connIcaRTD.setStatus('mandatory')
if mibBuilder.loadTexts: connIcaRTD.setDescription('The value of this object is the calculated round trip delay (measured in milliseconds) of this connection. This object is calculated for Foresight connections only. (xxEndptEnableFST object value is true).')
connGroupDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 4, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connGroupDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connGroupDesc.setDescription('Description for Group identifier. This string describes the connection group name. The format of the group name is domain.node-name.grp-number (Example, D1.node1.1). The varaible connIndex needs to have a special value of 65535 when creating a group. The group number and the domain are optional.')
frEndptTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5), )
if mibBuilder.loadTexts: frEndptTable.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTable.setDescription('The Frame Relay End-Point Configuration table. This table is used to model a Frame Relay end-point. The table contains the configuration parameters required to create and configure a Frame Relay end-point.')
frEndptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1), ).setIndexNames((0, "STRATACOM-MIB", "frEndptIndex"))
if mibBuilder.loadTexts: frEndptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptEntry.setDescription('An entry in the Frame Relay End-point Configuration table.')
frEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptIndex.setDescription('Index into table for this end-point. Although only 1024 endpoints may exist on a node, 2048 possible index values exist to support DAX (intra-node) connections.')
frEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptDesc.setDescription('String describing this end-point. Contains information about the domain, nodename, slot, port, and DLCI for the end-point. For example, D1.Node1.12.1.100, is a valid description. Domain and nodename need not be given but slot, port, and DLCI values must exist; 12.1.100 is valid.')
frOtherEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frOtherEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frOtherEndptIndex.setDescription("Index into remote node's frEndptTable for this PVC end-point. For DAX (intra-node) connections, this index is associated with the local node and will be in the range of 1024 to 2047.")
frOtherEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frOtherEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: frOtherEndptDesc.setDescription('String describing the remote end-point. Contains information about the domain, nodename, slot, port, and DLCI for the end-point. For example, D2.Node2.10.1.100, is a valid description. Nodename, slot, port, and DLCI values must exist; Node2.10.1.100 is valid.')
frEndptAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("modify", 3), ("test", 4), ("writeOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptAdminStatus.setDescription('User requested state for end-point table row. A user can create this VC or delete this VC by setting this object appropriately. If the end-point is to be modified, set this object identifier to be modify. The user also has the capability to test a particular object. For this capability, the user must set this value to test.')
frEndptOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ok", 1), ("okPendingDown", 2), ("down", 3), ("failed", 4), ("inTest", 5), ("okPendingRoute", 6), ("okPendingDelete", 7), ("looped", 8), ("unknown", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOperStatus.setDescription('Actual state of the end-point. If the state is failed, then look to the objects frNoRouteFoundFailure, frBumpFailure, frEndPointFailure, and frTestFailure to determine reason for failure.')
frNoRouteFoundFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frNoRouteFoundFailure.setStatus('mandatory')
if mibBuilder.loadTexts: frNoRouteFoundFailure.setDescription('End-point is failed is because no route to the remote end-point could be found.')
frBumpFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBumpFailure.setStatus('mandatory')
if mibBuilder.loadTexts: frBumpFailure.setDescription("End-point is failed because of insufficient bandwidth to route to the remote end-point. This may have also been caused because a higher priority connection took this end-point's bandwidth. A higher priority connection is one with the lowest class of service (COS).")
frEndPointFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndPointFailure.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPointFailure.setDescription('End-point is failed because of a remote end-point failure. The remote end-point is on a node that resides in another domain making the connection an inter-domain connection.')
frTestFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frTestFailure.setStatus('mandatory')
if mibBuilder.loadTexts: frTestFailure.setDescription('End-point is failed because of the failure of a connection test.')
frConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frConnPtr.setDescription('Pointer to general connection information. Using this pointer the user can obtain connection status, and routing information. Specifically, this is an object identifier specifying the first column of the appropriate row in the connTable.')
frNextPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 12), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frNextPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frNextPtr.setDescription('Pointer to next end-point information. This allows logical sets of end-points to be linked up. For example, the end-points associated with a bundle or group. Specifically, this is an object identifier specifying the first column of the appropriate row in the frEndptTable.')
frNextOnPortPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frNextOnPortPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frNextOnPortPtr.setDescription('Pointer to next end-point information for the port associated with this end-point. For example, using this pointer all frame relay end-points on a given slot.port can be determined. Specifically, this is an object identifier specifying the first column of the appropriate row in the frEndptTable.')
frEndptConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptConnDesc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptConnDesc.setDescription('A string that has been defined for the connection to give a more descriptive name. Connections can be given clear text names in order to make them more human readable.')
frEndptTrkAvoidType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("satellite", 2), ("terrestrial", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptTrkAvoidType.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTrkAvoidType.setDescription('User selectable types of trunks to avoid for the transfer of FRP data. Current choices are to avoid satellite links, terrestrial links, or to not avoid any specific type of link. This object is optional during the creation of the endpoint.')
frEndptTrkAvoidZCS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptTrkAvoidZCS.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTrkAvoidZCS.setDescription('Flag to force the connection to avoid trunks with zero code suppression (ZCS). This object is optional during the creation of the endpoint.')
frEndptSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameRelay", 1), ("atf", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptSubType.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptSubType.setDescription('Frame Relay endpoint subtype object.')
frEndptBWClass = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptBWClass.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptBWClass.setDescription('User selectable connection class which defines the operating parameters for the connection. Any or all of these parameters can be overridden by specifying the bandwidth parameters directly. This object is required during the creation of an endpoint.')
frEndptMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptMIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in 100s of bits per second) for this end-point. During creation of an endpoint, this object is required if no class index is provided. This is because the default values of bandwidth parameters not provided are derived from this object.')
frEndptCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptCIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in 100s of bits per second) for this end-point. This value will be defaulted to the provided MIR during an endpoint create.')
frEndptBc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptBc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (in bytes) for this end-point. This parameter is entered instead of the frEndptVcQSize parameter. If both the Bc and VcQSize are provided, the values are tested for compatibility.')
frEndptBe = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptBe.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (in bytes) for this end-point. This parameter is entered instead of the frEndptPIR parameter. If both the Be and the PIR are provided, the values are tested for compatibility.')
frEndptVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point. This parameter is entered instead of the frEndptBc parameter. If both the VcQSize and the Bc are provided, the values are tested for compatibility.')
frEndptPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptPIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in 100s of bits per second) for this end-point. This parameter is entered instead of the frEndptBe parameter. This value defaults to the current port speed of the associated interface.')
frEndptCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptCMAX.setDescription('The maximum credits that can be accrued for this end-point.')
frEndptEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is specified in bytes. When the frEndptVcQSize value exceeds this value then the FECN bit will be set in all frames transmitted to the remote end-point.")
frEndptQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptQIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in 100s of bits per second) for this end-point. This value can range between the MIR and PIR values and must be between 2400 and 2048000. This parameter has meaning only if the frEndptEnableFST parameter is set to true.')
frEndptPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
frEndptOeMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeMIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeMIR.setDescription('The minimum receive bandwidth (MIR) parameter (in 100s of bits per second) for the other end-point. This parameter is actually the frEndptMIR parameter for the remote end-point. During creation of an endpoint, this object is required if no class index is provided. This is because the default values of bandwidth parameters not provided are derived from this object.')
frEndptOeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeCIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in 100s of bits per second) for the other end-point. This parameter is actually the frEndptCIR parameter for the remote end-point.')
frEndptOeBc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeBc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (in bytes) for the end-point. This parameter is entered instead of the frEndptOeVcQSize parameter. This parameter is actually the frEndptBc parameter for the remote end-point. Since this value is calculated at the remote end based on the BW parameters unaccessible by the local agent during the varbind validation, the value specifed in the success SET response MAY NOT be its end value. The NMS is advised to GET this parameter again to confirm its actual value. Note: While modifying the value of this object it should be in the range 1..65535.')
frEndptOeBe = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeBe.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (in bytes) for the other end-point This parameter is entered instead of the frEndptOePIR parameter. This parameter is actually the frEndptBe parameter for the remote end-point. Since this value is calculated at the remote end based on the BW parameters unaccessible by the local agent during the varbind validation, the value specifed in the success SET response MAY NOT be its end value. The NMS is advised to GET this parameter again to confirm its actual value.')
frEndptOeVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3072000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point. This parameter is entered instead of the frEndptOeBc parameter. This parameter is actually the frEndptVcQSize parameter for the remote end-point. Since this value is calculated at the remote end based on the BW parameters unaccessible by the local agent during the varbind validation, the value specifed in the success SET response MAY NOT be its end value. The NMS is advised to GET this parameter again to confirm its actual value.')
frEndptOePIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOePIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOePIR.setDescription('The peak receive bandwidth (PIR) parameter (in 100s of bits per second) for the other end-point This parameter is entered instead of the frEndptOeBe parameter. This parameter is actually the frEndptPIR parameter for the remote end-point. This value defaults to the current port speed of the associated interface. Since this value is calculated at the remote end based on the BW parameters unaccessible by the local agent during the varbind validation, the value specifed in the success SET response MAY NOT be its end value. The NMS is advised to GET this parameter again to confirm its actual value.')
frEndptOeCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 57600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeCMAX.setDescription('The maximum credits that can be accrued for the other end-point. This parameter is actually the frEndptCMAX parameter for the remote end-point.')
frEndptOeEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for the other end-point's receive queue. This value is specified in bytes. When the frpVCEndptOeVcQSize value exceeds this value then the BECN bit will be set in all frames transmitted to Frame Relay Service User. This parameter is actually the frEndptEcnQSize parameter for the remote end-point.")
frEndptOeQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOeQIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOeQIR.setDescription('The receive quiescent information rate (QIR) parameter (in 100s of bits per second) for the other end-point. This value can range between the MIR and PIR values and must be between 2400 and 2048000. This parameter has meaning only if the frEndptEnableFST parameter is set to true. This parameter is actually the frEndptQIR parameter for the remote end-point.')
frEndptOePercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptOePercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptOePercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for the other end-point. This is the expected long-term utilization of the channel by the other end-point. This parameter is actually the frEndptPercUtil parameter for the remote end-point.')
frEndptEnableFST = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptEnableFST.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptEnableFST.setDescription('The value of this object determines whether or not the ForeSight option is being used for this . If set to false, then ForeSight is not used, and if true then ForeSight will be used.')
frEndptConnPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptConnPrio.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptConnPrio.setDescription("The value of this object determines the priority that is given to the data carried by this . If set to low, then the data is given the standard priority, and if set to high, the data will be given a higher priority. Higher priority data is placed at the beginning of the port's queues.")
frEndptGroupFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptGroupFlag.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptGroupFlag.setDescription('Specifies whether this is a grouped connection. Note that MIB object connGroupFlag provides grouping information about all the connections using that connTable entry whereas this object provides same information for this end point.')
frEndptLocLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptLocLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptLocLpbkState.setDescription('Specifies the Local Loopback State the user would like to set for the endpoint.')
frEndptLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptLocRmtLpbkState.setDescription('Specifies the Local-Remote Loopback State the user would like to set for the endpoint.')
frEndptLpbkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptLpbkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptLpbkStatus.setDescription('Specifies the current Loopback State of the endpoint. The value returned from this object is a bitmap of the current loopback states which the endpoint has configured. There currently are 16 loopback states an endpoint may have configured. If NO LOOPBACK is configured, the agent will return -1. The bitmap is defined as follows: LP-RMT-RMT 0 /* Remote nodes remote muxbus loopback */ LP-RMT-TST 1 /* Remote nodes tstcon loopback */ LP-LOC-RMT 2 /* Local nodes remoet muxbus loopback */ LP-LOC-TST 3 /* Local nodes tstcon loopback */ LP-LOC-LOC 4 /* Local nodes local muxbus loopback */ LP-LOC-PORT 5 /* Local nodes port loopback */ LP-LOC-TPORT 6 /* Local nodes port test loopback */ LP-RMT-LOC 7 /* Remote nodes local muxbus loopback */ LP-RMT-PORT 8 /* Remote nodes port loopback */ LP-RMT-TPORT 9 /* Remote nodes port test looback */ LP-LOC-CSU 10 /* Local DDS network requested CSU loopback */ LP-RMT-CSU 11 /* Remote DDS network requested CSU loopback */ LP-LOC-DSU 12 /* Local DDS network requested DSU loopback */ LP-RMT-DSU 13 /* Remote DDS network requested DSU loopback */ LP-LOC-EXT 14 /* Local DDS external loopback */ LP-RMT-EXT 15 /* Remote DDS external loopback */ ')
frEndptTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("test", 1), ("testDelay", 2), ("testNoLoop", 3), ("testDelayNoLoop", 4), ("writeOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptTestType.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTestType.setDescription('Specifies the type of test the user would like to conduct on this endpoint. There are currently two types of tests. Test will exercise continuity, while TestDelay will calculate the delay incurred on the connection. The result of the TestDelay may then be accessed through the frEndptRtdTestDelay object. To invoke a test, the frEndptAdminStatus is required to be set to test(4). The NoLoop options provide the user the capability to execute the tests without automatically invoking a loopback at the remote endpoint.')
frEndptRtdTestDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRtdTestDelay.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRtdTestDelay.setDescription('The value of this object is the calculated round trip delay (measured in milliseconds) of this Frame Relay endpoint. A delay test is invoked through setting the frEndptTestType object to TestDelay.')
frEndptGroupDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 5, 1, 47), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndptGroupDesc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptGroupDesc.setDescription('String describing the group this endpoint is associated with. The format of the group text description is domain.node.grp-number (Example, D2.node1.1).')
frEndptStatTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6), )
if mibBuilder.loadTexts: frEndptStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptStatTable.setDescription('The Frame Relay End-Point Statistics table.')
frEndptStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1), ).setIndexNames((0, "STRATACOM-MIB", "frEndptIndex"))
if mibBuilder.loadTexts: frEndptStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptStatEntry.setDescription('An entry in the Frame Relay End-point Statistics table.')
frEndptRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxBytes.setDescription('Frame Relay Endpoint Statistic, the number of frame bytes received from the local frame relay port.')
frEndptRxBytesDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxBytesDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxBytesDscds.setDescription('Frame Relay Endpoint Statistic, the number of frame bytes received from the local frame relay port but discarded before being transmitted onto the Muxbus, due to the age of the frame in the IPX system or lack of buffer space.')
frEndptRxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxFrms.setDescription('Frame Relay Endpoint Statistic, the number of frames received from the local frame relay port.')
frEndptRxFrmsDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxFrmsDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxFrmsDscds.setDescription('Frame Relay Endpoint Statistic, the number of frames received from the local frame relay port but discarded before being transmitted onto the Muxbus, due to the age of the frame in the IPX system or lack of buffer space ')
frEndptRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxPkts.setDescription('Frame Relay Endpoint Statistic, the number of packets received from the Muxbus by the local port card.')
frEndptRxPktsDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxPktsDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxPktsDscds.setDescription('Frame Relay Endpoint Statistic, the number of packets received from the Muxbus by the local port card but discarded before being transmitted.')
frEndptTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxBytes.setDescription('Frame Relay Endpoint Statistic, the number of frame bytes received from the Muxbus and transmitted out the frame relay port.')
frEndptTxBytesDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxBytesDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxBytesDscds.setDescription('Frame Relay Endpoint Statistic, the number of frame bytes received from the Muxbus but discarded before being transmitted out the frame relay port, due to the age of the frame in the IPX system, CRC error, or lack of buffer space.')
frEndptTxFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrms.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrms.setDescription('Frame Relay Endpoint Statistic, the number of frames transmitted out the frame relay port.')
frEndptTxFrmsDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrmsDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrmsDscds.setDescription('Frame Relay Endpoint Statistic, the number of frames, which are discarded by the local frame relay card before being transmitted out the local port, due to the age of the frame in the IPX system, a CRC error, or lack of buffer space.')
frEndptTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxPkts.setDescription('Frame Relay Endpoint Statistic, the number of packets tranmitted to the Muxbus by the local port card.')
frEndptTxFrmsFecns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrmsFecns.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrmsFecns.setDescription('Frame Relay Endpoint Statistic, the number of frames transmitted out the local frame relay port with FECN bit set.')
frEndptTxFrmsBecns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrmsBecns.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrmsBecns.setDescription('Frame Relay Endpoint Statistic, the number of frames transmitted out the local frame relay port with BECN bit set.')
frEndptSecInServices = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptSecInServices.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptSecInServices.setDescription('Frame Relay Endpoint Statistic, the number of seconds in which a connection is in service. A connection is considered to be in service if its end point is not in alarm, the cards required to support the connection are present and the connection is routed.')
frEndptCongestMins = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptCongestMins.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptCongestMins.setDescription('Frame Relay Endpoint Statistic, number of minutes in which 50% or more frames are tagged FECN by the FRP.')
frEndptRxFrmsDes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxFrmsDes.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxFrmsDes.setDescription('Frame Relay Endpoint Statistic, the number of frames received from the local frame relay port with their DE bit set. DE bits are only counted by model D frame relay firmware or later.')
frEndptRxBytesDes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxBytesDes.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxBytesDes.setDescription('Frame Relay Endpoint Statistic, the number of frames received from the local frame relay port with their DE bit set. DE bits are only counted by model D frame relay firmware or later.')
frEndptTxFrmsDes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrmsDes.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrmsDes.setDescription('Frame Relay Endpoint Statistic, the number of frames transmitted out the local frame relay port with their DE bit set. DE bits are only counted by model D frame relay firmware or later.')
frEndptRxFrmsDeDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxFrmsDeDscds.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxFrmsDeDscds.setDescription('Frame Relay Endpoint Statistic, the number of frame received from the local frame relay port with their DE bit set, which are discarded before being transmitted onto the Muxbus. DE bits are only counted by model D frame relay firmware or later.')
frEndptRxFrmsCirs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxFrmsCirs.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxFrmsCirs.setDescription('Frame Relay Endpoint Rx frames from port in excess of CIR.')
frEndptRxBytesCirs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptRxBytesCirs.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptRxBytesCirs.setDescription('Frame Relay Endpoint Rx bytes from port in excess of CIR.')
frEndptTxFrmsCirs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxFrmsCirs.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxFrmsCirs.setDescription('Frame Relay Endpoint Tx frames from port in excess of CIR.')
frEndptTxBytesCirs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptTxBytesCirs.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptTxBytesCirs.setDescription('Frame Relay Endpoint Tx bytes from port in excess of CIR.')
frBwClassTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7), )
if mibBuilder.loadTexts: frBwClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassTable.setDescription('The Frame Relay Bandwidth Class table.')
frBwClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1), ).setIndexNames((0, "STRATACOM-MIB", "frBwClassIndex"))
if mibBuilder.loadTexts: frBwClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassEntry.setDescription('An entry in the Frame Relay Bandwidth Class table.')
frBwClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassIndex.setDescription('Index into FrBwClassTable. This index identifies the frame relay bandwidth class.')
frBwClassMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassMIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in 100s of bits per second) for this end-point.')
frBwClassCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassCIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in 100s of bits per second) for this end-point.')
frBwClassVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point.')
frBwClassBc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassBc.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (in bytes) for this end-point.')
frBwClassPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassPIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in 100s of bits per second) for this end-point.')
frBwClassBe = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassBe.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (in bytes) for this end-point.')
frBwClassCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassCMAX.setDescription('The maximum credits that can be accrued for this end-point.')
frBwClassEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is specified in bytes.")
frBwClassQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassQIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in 100s of bits per second) for this end-point. This value can range between the MIR and PIR values and must be between 2400 and 2048000. This parameter has meaning only if the frEndptEnableFST parameter is set to true.')
frBwClassPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
frBwClassOeMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeMIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeMIR.setDescription('The minimum receive bandwidth (MIR) parameter (in 100s of bits per second) for the other end-point.')
frBwClassOeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeCIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in 100s of bits per second) for the other end-point.')
frBwClassOeVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3072000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point.')
frBwClassOeBc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeBc.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (in bytes) for the end-point.')
frBwClassOePIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOePIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOePIR.setDescription('The peak receive bandwidth (PIR) parameter (in 100s of bits per second) for the other end-point.')
frBwClassOeBe = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeBe.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (in bytes) for the other end-point.')
frBwClassOeCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 57600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeCMAX.setDescription('The maximum credits that can be accrued for the other end-point.')
frBwClassOeEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for the other end-point's receive queue. This value is specified in bytes.")
frBwClassOeQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOeQIR.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOeQIR.setDescription('The receive quiescent information rate (QIR) parameter (in 100s of bits per second) for the other end-point.')
frBwClassOePercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassOePercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassOePercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for the other end-point.')
frBwClassEnableFST = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassEnableFST.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassEnableFST.setDescription('The value of this object determines whether or not the ForeSight option is being used for this . If set to false, then ForeSight is not used, and if true then ForeSight will be used.')
frBwClassDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 7, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frBwClassDescription.setStatus('mandatory')
if mibBuilder.loadTexts: frBwClassDescription.setDescription('This MIB object contains a textual description of this frame relay bandwidth class.')
atmEndptTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8), )
if mibBuilder.loadTexts: atmEndptTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptTable.setDescription('The ATM End-Point table. This table is used to model a PVC end-point. This table contains the traffic parameters for ATM end-point.')
atmEndptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmEndptIndex"))
if mibBuilder.loadTexts: atmEndptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptEntry.setDescription('An entry in the ATM End-point table.')
atmEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptIndex.setDescription('Index into table for this end-point. Although only 5000 endpoints may exist on a node, 10000 possible index values exist to support DAX (intra-node) connections.')
atmEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptDesc.setDescription('String describing this end-point. Contains information about the domain, nodename, slot, port, vpi, and vci for the end-point. For example, D1.Node1.12.1.100.200, is a valid description. Domain and nodename need not be given but slot, port, VPI and VCI values must exist; 12.1.100.200 is valid. A virtual path connection endpoint of the form 12.1.100.* is also valid. For a basis port the last 4 bits of the VPI must be between 3 and 14.')
atmOtherEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOtherEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmOtherEndptIndex.setDescription("Index into remote node's atmEndptTable for this end-point. For DAX (intra-node) connections, this index is associated with the local node and will be in the range of 5000 to 9999.")
atmOtherEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOtherEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: atmOtherEndptDesc.setDescription('String describing the remote PVC end-point. Contains information about the domain, nodename, slot, port, vpi, and vci for the end-point. For example, D2.Node2.10.1.100.200, is a valid description. Nodename, slot, port, VPI and VCI values must exist. A virtual path connection endpoint of the form D2.Node2.10.1.100.* is also valid. For a basis port the last 4 bits of the VPI must be between 3 and 14.')
atmEndptAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("modify", 3), ("test", 4), ("writeOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptAdminStatus.setDescription('User requested state for end-point table row. A user can create this VC or delete this VC by setting this object appropriately. If the end-point is to be modified, set this object identifier to be modify.')
atmEndptOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ok", 1), ("okPendingDown", 2), ("down", 3), ("failed", 4), ("inTest", 5), ("okPendingRoute", 6), ("okPendingDelete", 7), ("looped", 8), ("unknown", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOperStatus.setDescription('Actual state of the end-point. If the state is failed, then look to the objects atmNoRouteFoundFailure, atmBumpFailure, atmEndPointFailure, and atmTestFailure to determine reason for failure.')
atmNoRouteFoundFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNoRouteFoundFailure.setStatus('mandatory')
if mibBuilder.loadTexts: atmNoRouteFoundFailure.setDescription('End-point is failed is because no route to the remote end-point could be found.')
atmBumpFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBumpFailure.setStatus('mandatory')
if mibBuilder.loadTexts: atmBumpFailure.setDescription("End-point is failed because of insufficient bandwidth to route to the remote end-point. This may have also been caused because a higher priority connection took this end-point's bandwidth. A higher priority connection is one with the lowest class of service (COS).")
atmEndPointFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndPointFailure.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPointFailure.setDescription('End-point is failed because of a remote end-point failure. The remote end-point is on a node that resides in another domain making the connection an inter-domain connection.')
atmTestFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTestFailure.setStatus('mandatory')
if mibBuilder.loadTexts: atmTestFailure.setDescription('End-point is failed because of the failure of a connection test.')
atmConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmConnPtr.setDescription('Pointer to general connection information. Using this pointer the user can obtain connection status, and routing information. Specifically, this is an object identifier specifying the first column of the appropriate row in the connTable.')
atmNextPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 12), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNextPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmNextPtr.setDescription('Pointer to next end-point information. This allows logical sets of end-points to be linked up. For example, the end-points associated with a bundle or group. Specifically, this is an object identifier specifying the first column of the appropriate row in the atmEndptTable.')
atmNextOnPortPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNextOnPortPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmNextOnPortPtr.setDescription('Pointer to next end-point information for the port associated with this end-point. For example, using this pointer all atm end-points on a given slot.port can be determined. Specifically, this is an object identifier specifying the first column of the appropriate row in the atmEndptTable.')
atmEndptConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptConnDesc.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptConnDesc.setDescription('A string that has been defined for the connection to give a more descriptive name. Connections can be given clear text names in order to make them more human readable.')
atmEndptTrkAvoidType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("satellite", 2), ("terrestrial", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptTrkAvoidType.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptTrkAvoidType.setDescription('User selectable types of trunks to avoid for the transfer of ATM data. Current choices are to avoid satellite links, terrestrial links, or to not avoid any specific type of link. This object is optional during the creation of an endpoint.')
atmEndptTrkAvoidZCS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptTrkAvoidZCS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptTrkAvoidZCS.setDescription('Flag to force the connection to avoid trunks with zero code suppression (ZCS). This object is optional during the creation of an endpoint.')
atmEndptSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("atf", 1), ("vbr", 2), ("cbr", 3), ("unknown", 4), ("abr", 5), ("atfst", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptSubType.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptSubType.setDescription('ATM endpoint subtype object. atf - Interworking conn (without Foresight) vbr - Variable Bit Rate Conn (No ForeSight) cbr - Constant Bit Rate Conn (No ForeSight) abr - Available Bit Rte Conn (With ForeSight) atfst - Interworking Conn (with ForeSight).')
atmEndptBWClass = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptBWClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptBWClass.setDescription('User selectable connection class which defines the operating parameters for the connection. Any or all of these parameters can be overridden by specifying the bandwidth parameters directly. This object is required during the creation of an endpoint.')
atmEndptMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptMIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in cells per second) for this end-point. The maximum value for this object is the port speed of the associated interface. This object does not apply to CBR connections. For VBR and ATF without Foresight connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For ABR and ATF with Foresight connections this object corresponds to the Minimum Cell Rate (MCR).')
atmEndptCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptCIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in cells per second) for this end-point. For CBR connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For VBR, ABR, and ATF connections this object corresponds to the Sustainable Cell Rate (SCR) defined by ATM standard documents. The maximum value for this object is the port speed of the associated interface. For T3 and E3 interfaces only multiples of 10 are used internally. For OC3 interfaces only values in the following set are used internally: 11, 17, 23, 34, 45, 68, 90, 136, 181, 271, 362, 543, 723, 1085, 1447, 2170, 2894, 4340, 5787, 8681, 11574, 17361, 23148, 34722, 46296, 69444, 92593, 138889, 185185, 277778. Values between 277778 and 353208 are all valid for OC3 interfaces. All values in the valid range for a given interface will be accepted, but they will be internally rounded up to the closest higher value valid for that interface.')
atmEndptVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptVcQSize.setDescription('The value of this object is the maximum queue depth (in cells) for this end-point. This object does not apply to vbr or cbr connections.')
atmEndptPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptPIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in cells per second) for this end-point. The maximum value for this object is the port speed of the associated interface. This object applies only to ABR and ATF with Foresight connections and corresponds to the PCR(0+1) parameter defined by ATM standard documents.')
atmEndptEfciQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptEfciQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptEfciQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is a percentage. This object does not apply to vbr or cbr connections.")
atmEndptQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in cells per second) for this end-point. This value can range between the MIR and PIR values and must be between 0 and 96000. This parameter has meaning only for Foresight connections. This object corresponds to the Initial Cell Rate (ICR).')
atmEndptPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
atmEndptCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptCBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptCBS.setDescription('The value of this object is equal to the Compliant Burst Size in cells for this end-point. The maximum value for this object on OC3 end points is 1000. This object corresponds to the Maximum Burst Size (MBS) defined by ATM standard documents. This object can be set if atmEndptUPC is enabled.')
atmEndptIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptIBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptIBS.setDescription('The value of this object is equal to the Initial Burst Size in cells for this end-point. The maximum value for this object on OC3 end points is 1000. This object does not apply to vbr or cbr connections.')
atmEndptMFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptMFS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMFS.setDescription('This object is not used by the new UPC algorithm, and its value is meaningless. Any attempt to write to this object will fail.')
atmEndptCCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptCCDV.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptCCDV.setDescription('The value of this object is equal to the Compliant Cell Delay Variation for this end-point. It corresponds to the CDVT(0+1) parameter defined by the ATM standard documents. This object can be set if atmEndptUPC is enabled. The maximum value for this object on OC3 end points is 10000.')
atmEndptHiCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptHiCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptHiCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging activation threshold for this end-point. This object only applies to Foresight connections.')
atmEndptLoCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptLoCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptLoCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging deactivation threshold for this end-point. This object only applies to Foresight connections.')
atmEndptOeMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeMIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeMIR.setDescription('The minimum receive bandwidth (MIR) parameter (in cells per second) for the other end-point. The maximum value for this object is the port speed of the associated interface. This object does not apply to CBR connections. For VBR and ATF without Foresight connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For ABR and ATF with Foresight connections this object corresponds to the Minimum Cell Rate (MCR).')
atmEndptOeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeCIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in cells per second) for the other end-point. For CBR connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For VBR, ABR, and ATF connections this object corresponds to the Sustainable Cell Rate (SCR) defined by ATM standard documents. The maximum value for this object is the port speed of the associated interface. For T3 and E3 interfaces only multiples of 10 are used internally. For OC3 interfaces only values in the following set are used internally: 11, 17, 23, 34, 45, 68, 90, 136, 181, 271, 362, 543, 723, 1085, 1447, 2170, 2894, 4340, 5787, 8681, 11574, 17361, 23148, 34722, 46296, 69444, 92593, 138889, 185185, 277778. Values between 277778 and 353208 are all valid for OC3 interfaces. All values in the valid range for a given interface will be accepted, but they will be internally rounded up to the closest higher value valid for that interface.')
atmEndptOeVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeVcQSize.setDescription('The value of this object is the maximum queue depth (in cells) for the other end-point. This object does not apply to vbr or cbr connections.')
atmEndptOePIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOePIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOePIR.setDescription('The peak receive bandwidth (PIR) parameter (in cells per second) for the other end-point. The maximum value for this object is the port speed of the associated interface. This object applies only to ABR and ATF with Foresight connections and corresponds to the PCR(0+1) parameter defined by ATM standard documents.')
atmEndptOeEfciQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeEfciQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeEfciQSize.setDescription("The threshold setting used by the explicit congestion notification feature for the other end-point's transmit queue. This object does not apply to vbr or cbr connections.")
atmEndptOeQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in cells bits per second) for the other end-point. This value can range between the MIR and PIR values and must be between 0 and 96000. This parameter has meaning only for Foresight connections. This object corresponds to the Initial Cell Rate (ICR).')
atmEndptOePercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOePercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOePercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for the other end-point. This is the expected long-term utilization of the channel by the other end-point.')
atmEndptOeCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeCBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeCBS.setDescription('The value of this object is equal to the Compliant Burst Size in cells for the other end-point. The maximum value for this object on OC3 end points is 1000. This object corresponds to the Maximum Burst Size (MBS) defined by ATM standard documents. This object can be set if atmEndptUPC is enabled.')
atmEndptOeIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeIBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeIBS.setDescription('The value of this object is equal to the Initial Burst Size in cells for the other end-point. The maximum value for this object on OC3 end points is 1000. This object does not apply to vbr or cbr connections.')
atmEndptOeMFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeMFS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeMFS.setDescription('This object is not used by the new UPC algorithm, and its value is meaningless. Any attempt to write to this object will fail.')
atmEndptOeCCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeCCDV.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeCCDV.setDescription('The value of this object is equal to the Compliant Cell Delay Variation for this end-point. It corresponds to the CDVT(0+1) parameter defined by the ATM standard documents. This object can be set if atmEndptUPC is enabled. The maximum value for this object on OC3 end points is 10000.')
atmEndptOeHiCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeHiCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeHiCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging activation threshold for the other end-point. This object only applies to Foresight connections.')
atmEndptOeLoCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeLoCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeLoCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging deactivation threshold for the other end-point. This object only applies to Foresight connections.')
atmEndptCLPTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptCLPTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptCLPTagging.setDescription('The value of this object enables the CLP (Cell Loss Priority) tagging for handling non-compliant cells. When enabled the CLP bit is set on non- compliant cells. When disabled non-compliant cells are discarded. This object can be set if atmEndptUPC is enabled.')
atmEndptUPC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptUPC.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptUPC.setDescription('The value of this object enables the UPC algorithm.')
atmEndptEnableFST = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptEnableFST.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptEnableFST.setDescription('The value of this object determines whether or not the ForeSight option is being used for this . If set to false, then ForeSight is not used, and if true then ForeSight will be used. Foresight option is not supported on OC3 interfaces.')
atmEndptRateUpICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 96000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptRateUpICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptRateUpICA.setDescription('The value of this object is equal to the ForeSight Rate Up value in cells per second per adjust for this end point.')
atmEndptRateDnICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptRateDnICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptRateDnICA.setDescription('The value of this object is equal to the ForeSight Rate Down value expressed as percentage of MCR.')
atmEndptFastDnICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptFastDnICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptFastDnICA.setDescription('The value of this object is equal to the ForeSight Fast Down value expressed as percentage of MCR.')
atmEndptToQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptToQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptToQIR.setDescription('The value of this object is equal to the QIR timeout value. This object corresponds to the Initial Cell Rate (ICR) timeout.')
atmEndptMinAdjustICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptMinAdjustICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMinAdjustICA.setDescription('The value of this object is equal to the ForeSight minimum adjustment period.')
atmEndptGroupFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptGroupFlag.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptGroupFlag.setDescription('Specifies whether this is a grouped connection. Note that MIB object connGroupFlag provides grouping information about all the connections using that connTable entry whereas this object provides same information for this end point.')
atmEndptOamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("clear", 2), ("aisDetected", 3), ("ferfDetected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptOamStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOamStatus.setDescription('The end to end OAM state.')
atmEndptBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptBCM.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptBCM.setDescription('The value of this object enables the generation of RM cells when congestion is detected in this connection.')
atmEndptFGCRA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptFGCRA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptFGCRA.setDescription('The value of this object enables FGCRA. FGCRA (Frame-based Generic Rate Control Algorithm) is applicable with AAL-5 traffic only. This object can be set if atmEndptUPC is enabled.')
atmEndptLocLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptLocLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptLocLpbkState.setDescription('Specifies the Local Loopback State the user would like to set for the endpoint.')
atmEndptLpbkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptLpbkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptLpbkStatus.setDescription('Specifies the current Loopback State of the endpoint. The value returned from this object is a bitmap of the current loopback states which the endpoint has configured. There currently are 16 loopback states an endpoint may have configured. The bitmap is defined as follows from LSB to MSB: Remote nodes remote muxbus loopback Remote nodes tstcon loopback Local nodes remoet muxbus loopback Local nodes tstcon loopback Local nodes local muxbus loopback Local nodes port loopback Local nodes port test loopback Remote nodes local muxbus loopback Remote nodes port loopback Remote nodes port test looback Local DDS network requested CSU loopback Remote DDS network requested CSU loopback Local DDS network requested DSU loopback Remote DDS network requested DSU loopback Local DDS external loopback Remote DDS external loopback ')
atmEndptTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("testDelay", 1), ("writeOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptTestType.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptTestType.setDescription('Specifies the type of test the user would like to conduct on this endpoint. Only testDelay is currently defined. TestDelay calculates the delay incurred on the connection. The result of the TestDelay may then be accessed through the atmEndptRtdTestDelay object. This is a non-disruptive test.')
atmEndptRtdTestDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptRtdTestDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptRtdTestDelay.setDescription('The value of this object is the calculated round trip delay (measured in milliseconds) for an OAM cell that is sent across the network to the remote node where it is looped back and returned to this node. A delay test is invoked through setting the the atmEndptTestType object to TestDelay.')
atmEndptOeBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeBCM.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeBCM.setDescription('The value of this object enables the generation of RM cells when congestion is detected in this connection. This is the other endpoint view.')
atmEndptOeFGCRA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeFGCRA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeFGCRA.setDescription('The value of this object enables FGCRA. FGCRA (Frame-based Generic Rate Control Algorithm) is applicable with AAL-5 traffic only. This object can be set if atmEndptUPC is enabled. This is the other endpoint view.')
atmEndptGroupDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 63), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptGroupDesc.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptGroupDesc.setDescription('String describing the group this endpoint is associated with. The format of the group text description is domain.node.grp-number (Example, D2.node1.1).')
atmEndptLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptLocRmtLpbkState.setDescription('Specifies the Local-Remote Loopback State the user would like to set for the endpoint.')
atmEndptScrPlc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptScrPlc.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptScrPlc.setDescription('Specifies the traffic policing for this end point This object can be set only if atmEndptUPC is enabled.')
atmEndptOeScrPlc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeScrPlc.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeScrPlc.setDescription('Specifies the traffic policing for the other end point. This object can be set only if atmEndptUPC is enabled.')
atmEndptPCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptPCR0.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptPCR0.setDescription('The peak cell rate (in cells per second) for the second bucket for this end point. This object corresponds to the parameter PCR(0) in standard ATM documents and applies only to CBR connections. This object can be set only if atmEndptUPC is enabled. PCR(0) must be less or equal than PCR(0+1).')
atmEndptOePCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOePCR0.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOePCR0.setDescription('The peak cell rate (in cells per second) for the second bucket for the other end point. This object corresponds to the parameter PCR(0) in standard ATM documents and applies only to CBR connections. This object can be set only if atmEndptUPC is enabled. PCR(0) must be less or equal than PCR(0+1).')
atmEndptCDVT0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptCDVT0.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptCDVT0.setDescription('The cell delay variation tolerance for the second bucket for this end point. This object corresponds to the parameter CDVT(0) in standard ATM documents, and applies only to CBR connections. This object can be set only if atmEndptUPC is enabled.')
atmEndptOeCDVT0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeCDVT0.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeCDVT0.setDescription('The cell delay variation tolerance for the second bucket for the other end point. This object corresponds to the parameter CDVT(0) in standard ATM documents, and applies only to CBR connections. This object can be set only if atmEndptUPC is enabled.')
atmEndptOeRateUpICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 96000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptOeRateUpICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptOeRateUpICA.setDescription('The value of this object is equal to the ForeSight Rate Up value in cells per second per adjust for the other end point.')
atmEndptFRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptFRTT.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptFRTT.setDescription('The Fixed Round-Trip Time (FRTT) is the sum of the fixed and propagation delays from the source to a destination and back. . Units: milliseconds. . Applicable connection types: standard ABR only . Default: 0 . Dependency: VSVD = enable(1) ')
atmEndptTBE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048320))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptTBE.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptTBE.setDescription('Transient Buffer Exposure (TBE) is the negotiated number of cells that the network would like to limit the source to sending during startup periods, before the first RM-cell returns. . Units: cells . Applicable connection types: standard ABR only . Default: 1048320 . Dependency: VSVD = enable(1) ')
atmEndptVSVD = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptVSVD.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptVSVD.setDescription('Virtual Source/Virtual Destination (VS/VD) is used to divide an ABR connection into two or more separately controlled ABR segment. This flag indicates whether the ATM end points (both ends) will serve as VS/VD or not. . Applicable connection types: . standard ABR . ABRFST: Cannot be set, but always enable(1). . ATFST : Cannot be set, but always enable(1). . Dependency: . The object CANNOT be MODIFIED after the first set! All Subsequent sets will be rejected! The object can be set when only add ABRSTD connection. ============================================ ABRSTD VSVD option ABRSTD ABRFST ATFST ============================================= available Both (Yes) (Yes) unavalable No (Yes) (Yes) Note: . Yes = Has to be set to enable(1) No = Has to be set to disable(2) Both = can be set to either enable(1) or disable(2) (Yes) = Always enabled and cannot be set. (No) = Always disabled and cannot be set. . Default: disable(2) ')
atmEndptPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vbr1", 1), ("vbr2", 2), ("vbr3", 3), ("pcrplc", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptPolicing.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptPolicing.setDescription('Specifies the traffic policing for this end point. --------------- ---------- ---------- Policing Type 1st Bucket 2nd Bucket --------------- ---------- ---------- vbr.1 CLP(0+1) CLP(0+1) vbr.2 CLP(0+1) CLP(0) vbr.3 CLP(0+1) CLP(0) with CLP Tagging pcrplc CLP(0+1) none none none none . Applicable connection types: . CBR (only pcrplc(4) or none(5)), VBR, ATFR, . standard ABR, ABR FST, ATFST: VSVD = enable(1) . Default: vbr3(3) . Dependency: Not allowed for standard ABR without VSVD. In this case, it is set to pcrplc(4). ')
atmEndptPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 8, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndptPCR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptPCR.setDescription('PCR(0+1), Peak Cell Rate, specifies an upper bound on rate at which traffic can be submitted on an ATM connection. This object applies to the First Leaky Bucket for leaving cells with Cell Loss Priority of 0 or 1. . Units: cells per second. . Applicable connection types: UBR, CBR, VBR, ATFR, standard ABR, ABR FST, ATFST . Default: 50 or MCR . Ranges: T3 : MCR-96000 E3 : MCR-80000 OC3 : MCR-353208 OC12: MCR-1412832 ')
atmBwClassTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9), )
if mibBuilder.loadTexts: atmBwClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassTable.setDescription('The ATM Bandwidth Class table.')
atmBwClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmBwClassIndex"))
if mibBuilder.loadTexts: atmBwClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassEntry.setDescription('An entry in the ATM Bandwidth Class table.')
atmBwClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassIndex.setDescription('Index into atmBwClassTable. This index identifies the ATM bandwidth class.')
atmBwClassMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassMIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in cells per second) for this end-point. For VBR and ATF without Foresight connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For ABR and ATF with Foresight connections this object corresponds to the Minimum Cell Rate (MCR).')
atmBwClassCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassCIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in cells per second) for this end-point. For CBR connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For VBR, ABR, and ATF connections this object corresponds to the Sustainable Cell Rate (SCR) defined by ATM standard documents.')
atmBwClassVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassVcQSize.setDescription('The value of this object is the maximum queue depth (in cells) for this end-point.')
atmBwClassPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassPIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in cells per second) for this end-point. This object applies only to ABR and ATF with Foresight connections and corresponds to the PCR(0+1) parameter defined by ATM standard documents.')
atmBwClassEfciQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassEfciQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassEfciQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is a percentage.")
atmBwClassQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in cells per second) for this end-point. This value can range between the MIR and PIR values and must be between 0 and 96000. This parameter has meaning only for Foresight connections. This object corresponds to the Initial Cell Rate (ICR).')
atmBwClassPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
atmBwClassCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassCBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassCBS.setDescription('The value of this object is equal to the Compliant Burst Size in cells for this end-point. This object corresponds to the Maximum Burst Size (MBS) defined by ATM standard documents.')
atmBwClassIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassIBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassIBS.setDescription('The value of this object is equal to the Initial Burst Size in cells for this end-point.')
atmBwClassMFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassMFS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassMFS.setDescription('This object is not used by the new UPC algorithm, and its value is meaningless.')
atmBwClassCCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassCCDV.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassCCDV.setDescription('The value of this object is equal to the Compliant Cell Delay Variation for this end-point. It corresponds to the CDVT(0+1) parameter defined by the ATM standard documents.')
atmBwClassHiCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassHiCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassHiCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging activation threshold for this end-point.')
atmBwClassLoCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassLoCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassLoCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging deactivation threshold for this end-point.')
atmBwClassOeMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeMIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeMIR.setDescription('The minimum receive bandwidth (MIR) parameter (in cells per second) for the other end-point. For VBR and ATF without Foresight connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For ABR and ATF with Foresight connections this object corresponds to the Minimum Cell Rate (MCR).')
atmBwClassOeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeCIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in cells per second) for the other end-point. For CBR connections this object corresponds to the PCR(0+1) parameter defined by ATM standard documents. For VBR, ABR, and ATF connections this object corresponds to the Sustainable Cell Rate (SCR) defined by ATM standard documents.')
atmBwClassOeVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeVcQSize.setDescription('The value of this object is the maximum queue depth (in cells) for the other end-point.')
atmBwClassOePIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOePIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOePIR.setDescription('The peak receive bandwidth (PIR) parameter (in cells per second) for the other end-point. This object applies only to ABR and ATF with Foresight connections and corresponds to the PCR(0+1) parameter defined by ATM standard documents.')
atmBwClassOeEfciQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeEfciQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeEfciQSize.setDescription("The threshold setting used by the explicit congestion notification feature for the other end-point's transmit queue.")
atmBwClassOeQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in cells bits per second) for the other end-point. This value can range between the MIR and PIR values and must be between 0 and 96000. This parameter has meaning only for Foresight connections. This object corresponds to the Initial Cell Rate (ICR).')
atmBwClassOePercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOePercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOePercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for the other end-point. This is the expected long-term utilization of the channel by the other end-point.')
atmBwClassOeCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeCBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeCBS.setDescription('The value of this object is equal to the Compliant Burst Size in cells for the other end-point. This object corresponds to the Maximum Burst Size (MBS) defined by ATM standard documents.')
atmBwClassOeIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeIBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeIBS.setDescription('The value of this object is equal to the Initial Burst Size in cells for the other end-point.')
atmBwClassOeMFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeMFS.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeMFS.setDescription('This object is not used by the new UPC algorithm, and its value is meaningless.')
atmBwClassOeCCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeCCDV.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeCCDV.setDescription('The value of this object is equal to the Compliant Cell Delay Variation for the other end-point. It corresponds to the CDVT(0+1) parameter defined by the ATM standard documents.')
atmBwClassOeHiCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeHiCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeHiCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging activation threshold for the other end-point.')
atmBwClassOeLoCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeLoCLP.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeLoCLP.setDescription('The value of this object is equal to the CLP (Cell Loss Priority) tagging deactivation threshold for the other end-point.')
atmBwClassCLPTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassCLPTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassCLPTagging.setDescription('The value of this object enables the CLP (Cell Loss Priority) tagging for handling non-compliant cells. When enabled the CLP bit is set on non- compliant cells. When disabled non-compliant cells are discarded.')
atmBwClassUPC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassUPC.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassUPC.setDescription('The value of this object enables the UPC algorithm.')
atmBwClassEnableFST = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassEnableFST.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassEnableFST.setDescription('The value of this object determines whether or not the ForeSight option is being used for this . If set to false, then ForeSight is not used, and if true then ForeSight will be used.')
atmBwClassRateUpICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassRateUpICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassRateUpICA.setDescription('The value of this object is equal to the ForeSight Rate Up value in cells per second per adjust for this end point.')
atmBwClassRateDnICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassRateDnICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassRateDnICA.setDescription('The value of this object is equal to the ForeSight Rate Down value expressed as percentage of MCR.')
atmBwClassFastDnICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassFastDnICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassFastDnICA.setDescription('The value of this object is equal to the ForeSight Fast Down value expressed as percentage of MCR.')
atmBwClassToQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassToQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassToQIR.setDescription('The value of this object is equal to the QIR timeout value. This object corresponds to the Initial Cell Rate (ICR) timeout.')
atmBwClassMinAdjustICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassMinAdjustICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassMinAdjustICA.setDescription('The value of this object is equal to the ForeSight minimum adjustment period.')
atmBwClassDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassDescription.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassDescription.setDescription('This MIB object contains a textual description of this frame relay bandwidth class.')
atmBwClassBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassBCM.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassBCM.setDescription('The value of this object enables the generation of RM cells when congestion is detected in the connection.')
atmBwClassFGCRA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassFGCRA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassFGCRA.setDescription('The value of this object enables FGCRA. FGCRA (Frame-based Generic Rate Control Algorithm) is applicable with AAL-5 traffic only.')
atmBwClassOeBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeBCM.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeBCM.setDescription('The value of this object enables the generation of RM cells when congestion is detected in the connection. This is the other endpoint view.')
atmBwClassOeFGCRA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeFGCRA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeFGCRA.setDescription('The value of this object enables FGCRA. FGCRA (Frame-based Generic Rate Control Algorithm) is applicable with AAL-5 traffic only. This is the other endpoint view.')
atmBwClassConType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("atf", 1), ("vbr", 2), ("cbr", 3), ("unknown", 4), ("abr", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassConType.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassConType.setDescription('The value of this object defines the connection type associated with this class.')
atmBwClassScrPlc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassScrPlc.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassScrPlc.setDescription('Specifies the traffic policing for this end point.')
atmBwClassOeScrPlc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeScrPlc.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeScrPlc.setDescription('Specifies the traffic policing for the other end point.')
atmBwClassPCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassPCR0.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassPCR0.setDescription('The peak cell rate (in cells per second) for the second bucket for this end point. This object corresponds to the parameter PCR(0) in standard ATM documents.')
atmBwClassOePCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOePCR0.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOePCR0.setDescription('The peak cell rate (in cells per second) for the second bucket for the other end point. This object corresponds to the parameter PCR(0) in standard ATM documents.')
atmBwClassCDVT0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassCDVT0.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassCDVT0.setDescription('The cell delay variation tolerance for the second bucket for this end point. This object corresponds to the parameter CDVT(0) in standard ATM documents.')
atmBwClassOeCDVT0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeCDVT0.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeCDVT0.setDescription('The cell delay variation tolerance for the second bucket for the other end point. This object corresponds to the parameter CDVT(0) in standard ATM documents.')
atmBwClassOeRateUpICA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 9, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 96000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBwClassOeRateUpICA.setStatus('mandatory')
if mibBuilder.loadTexts: atmBwClassOeRateUpICA.setDescription('The value of this object is equal to the ForeSight Rate Up value in cells per second per adjust for the other end point.')
frEndptMapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10), )
if mibBuilder.loadTexts: frEndptMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapTable.setDescription('The Frame Relay Endpoint-Connection Mapping table.')
frEndptMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1), ).setIndexNames((0, "STRATACOM-MIB", "frEndptMapSlot"), (0, "STRATACOM-MIB", "frEndptMapPort"), (0, "STRATACOM-MIB", "frEndptMapDlci"))
if mibBuilder.loadTexts: frEndptMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapEntry.setDescription('An entry in the Frame Relay Endpoint Connection Mapping table.')
frEndptMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapSlot.setDescription('This MIB object contains the slot number associated with the requested connection endpoint.')
frEndptMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptMapPort.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapPort.setDescription('This MIB object contains the port number associated with the requested connection endpoint.')
frEndptMapDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptMapDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapDlci.setDescription('This MIB object contains the Frame Relay DLCI associated with the requested connection endpoint.')
frEndptMapEndptPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptMapEndptPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapEndptPtr.setDescription('This MIB object contains a pointer to first column of row in the service specific EndptTable which corresponds to the slot, port, and dlci specified in the columns above.')
frEndptMapConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 10, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndptMapConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frEndptMapConnPtr.setDescription('This MIB object contains a pointer to first column of row in connTable which corresponds to the slot, port, and dlci specified in the columns above.')
atmEndptMapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11), )
if mibBuilder.loadTexts: atmEndptMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapTable.setDescription('The ATM Endpoint-Connection Mapping table.')
atmEndptMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmEndptMapSlot"), (0, "STRATACOM-MIB", "atmEndptMapPort"), (0, "STRATACOM-MIB", "atmEndptMapVpi"), (0, "STRATACOM-MIB", "atmEndptMapVci"))
if mibBuilder.loadTexts: atmEndptMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapEntry.setDescription('An entry in the ATM Endpoint Connection Mapping table.')
atmEndptMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapSlot.setDescription('This MIB object contains the slot number associated with the requested connection endpoint.')
atmEndptMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapPort.setDescription('This MIB object contains the port number associated with the requested connection endpoint.')
atmEndptMapVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapVpi.setDescription('This MIB object contains the ATM endpoint VPI associated with the requested connection endpoint.')
atmEndptMapVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapVci.setDescription('This MIB object contains the ATM endpoint VCI associated with the requested connection endpoint.')
atmEndptMapEndptPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapEndptPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapEndptPtr.setDescription('This MIB object contains a pointer to first column of row in the service specific EndptTable which corresponds to the slot, port, vpi, and vci specified in the columns above.')
atmEndptMapConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 11, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndptMapConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptMapConnPtr.setDescription('This MIB object contains a pointer to first column of row in connTable which corresponds to the slot, port, vpi, and vci specified in the columns above.')
atmEndptStatTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12), )
if mibBuilder.loadTexts: atmEndptStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptStatTable.setDescription('The ATM End-Point Statistics table.')
atmEndptStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmEndptIndex"))
if mibBuilder.loadTexts: atmEndptStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndptStatEntry.setDescription('An entry in the ATM End-point Statistics table.')
atmCellsRxPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCellsRxPorts.setStatus('mandatory')
if mibBuilder.loadTexts: atmCellsRxPorts.setDescription('The number of cells delivered to the port from the line interface.')
atmFramesRxPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmFramesRxPorts.setStatus('mandatory')
if mibBuilder.loadTexts: atmFramesRxPorts.setDescription('The number of frames delivered to the port from the line interface.')
atmCellsTxNets = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCellsTxNets.setStatus('mandatory')
if mibBuilder.loadTexts: atmCellsTxNets.setDescription('The number of received cells delivered to the network.')
atmClpRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmClpRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmClpRxs.setDescription('The number of cells delivered to the port from the line interface which had their CLP bit set.')
atmViolRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmViolRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmViolRxs.setDescription('The number of cells that violated UPC.')
atmDiscardVcqClpThs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardVcqClpThs.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardVcqClpThs.setDescription('The number of cells with CLP set that were discarded due to VC queue exceeding CLP thresholds.')
atmDiscardVcqFulls = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardVcqFulls.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardVcqFulls.setDescription('The number of received cells that were discarded due to the VC queue being full.')
atmEfciRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEfciRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmEfciRxs.setDescription('The number of cells received with EFCI set.')
atmNonCompRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNonCompRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmNonCompRxs.setDescription('The number of non-compliant cells received.')
atmDiscardFails = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardFails.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardFails.setDescription('The number of received cells discarded due to the connection being in failed state.')
atmAvgVcqDepths = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAvgVcqDepths.setStatus('mandatory')
if mibBuilder.loadTexts: atmAvgVcqDepths.setDescription('The average queue depth of the VC queue.')
atmDiscardRsrcOflows = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardRsrcOflows.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardRsrcOflows.setDescription('The number of received cells discarded due to a resource overflow (e.g. cell buffer full).')
atmDiscardSbinFulls = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardSbinFulls.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardSbinFulls.setDescription('The number of cells discarded on receipt from from the port due to Sbin full.')
atmBcmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBcmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmBcmRxs.setDescription('The number of BCM cells received from the port. This object only applies to NNI ports. For UNI ports returns 0.')
atmBcmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmBcmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmBcmTxs.setDescription('The number of BCM cells transmitted to the network. This object only applies to NNI ports. For UNI ports returns 0.')
atmOamTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamTxs.setDescription('The number of OAM cells transmitted to the network.')
atmDiscardQbinFulls = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardQbinFulls.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardQbinFulls.setDescription('The number of cells discarded due to the egress Qbin being full.')
atmDiscardQbinClpThs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDiscardQbinClpThs.setStatus('mandatory')
if mibBuilder.loadTexts: atmDiscardQbinClpThs.setDescription('The number of cells with CLP set that are discarded due to the egress Qbin exceeding CLP thresholds.')
atmCellsRxNets = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCellsRxNets.setStatus('mandatory')
if mibBuilder.loadTexts: atmCellsRxNets.setDescription('The number of cells received from the network.')
atmClpTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmClpTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmClpTxs.setDescription('The number of cells transmitted to the port that had their CLP bit set.')
atmEfciTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEfciTxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmEfciTxs.setDescription('The number of cells transmitted by the port to the line interface that had EFCI set.')
atmCellsTxPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCellsTxPorts.setStatus('mandatory')
if mibBuilder.loadTexts: atmCellsTxPorts.setDescription('The number of cells transmitted to the port interface.')
atmAisRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAisRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAisRxs.setDescription('The number of received AIS cells.')
atmFerfRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 12, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmFerfRxs.setStatus('mandatory')
if mibBuilder.loadTexts: atmFerfRxs.setDescription('The number of received FERF cells.')
voiceEndptTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13), )
if mibBuilder.loadTexts: voiceEndptTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptTable.setDescription('The voice channel connection table has Channel Connection information. This table is used to model a specific Voice Channel connection. This table contains parameters which are requrired to create a Voice conneciton and configure the channel.')
voiceEndptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1), ).setIndexNames((0, "STRATACOM-MIB", "voiceEndptIndex"))
if mibBuilder.loadTexts: voiceEndptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptEntry.setDescription('An entry in the voice Endpoint Channel Connection table.')
voiceEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptIndex.setDescription('The index for this Voice Connection. This is the index to this table.')
voiceOtherEndptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceOtherEndptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceOtherEndptIndex.setDescription("Index into remote node's voiceEndptTable for this channel end-point. For local (intra-node) connections, this index is associated with the local node and will be in the range of 1024 to 2047.")
voiceEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptDesc.setDescription('String describing this voice Channel. Contains information about the domain, nodename, slot, channel, for the connection. For example, D1.Node1.12.1, is a valid description. Domain and nodename need not be given but slot, channel values must exist; 12.1 is valid. This variable value has to specified for a Creating an voiceEndptEntry.')
voiceOtherEndptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceOtherEndptDesc.setStatus('mandatory')
if mibBuilder.loadTexts: voiceOtherEndptDesc.setDescription('String describing the remote channel. Contains information about the domain, nodename, slot, channel, for the connection. For example, D2.Node2.10.5, is a valid description. Nodename, slot, channel values must exist; Node2.10.5 is valid. This variable value has to be specified for creating an voiceEndptEntry.')
voiceEndptConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptConnDesc.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptConnDesc.setDescription('A string that has been defined for the connection to give a more descriptive name. Connections can be given clear text names in order to make them more human readable.')
voiceEndptAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("modify", 3), ("test", 4), ("writeOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptAdminStatus.setDescription('User requested state for voice endpoint table row. A user can create / delete / modify this voice channel connection by setting this object appropriately. The user also has the capability to test a particular object. For this capability, the user must set this value to test. If a Get operation is performed on this variable, -1 shall be returned to the NMS.')
voiceEndptOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ok", 1), ("okPendingDown", 2), ("down", 3), ("failed", 4), ("inTest", 5), ("okPendingRoute", 6), ("okPendingDelete", 7), ("looped", 8), ("unknown", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptOperStatus.setDescription('Actual state of the voice channel.If the state is failed, then look to the objects voiceNoRouteFoundFailure, voiceBumpFailure, and voiceTestFailure to determine reason for failure.')
voiceEndptRateType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("a32", 1), ("a24", 2), ("a16", 3), ("a16z", 4), ("a32d", 5), ("c32", 6), ("c24", 7), ("c16", 8), ("c16z", 9), ("c32d", 10), ("p", 11), ("t", 12), ("v", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptRateType.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptRateType.setDescription('Represents the type of voice connection. Each of them has been described below briefly. Type Description a32 Uses ADPCM only. Can select 32/24/16 Kbps a24 compression. a16 a16z Standard 16Kbps ADPCM only. compressed code can have strings of zeros and should be used on lines that have other zero code supression c32 Uses both ADPCM and Voice Activity detection (VAD). c24 Can select 32/24/16 Kbps ADPCM compression. c16 c16z Standard 16Kbps ADPCM and Voice Activity detection. Similar to 16z. Use on ZCS trunks only. p 64Kbps connection. No compression t Transparent. Clean 64Kbps connection. No Compression. This variable value has to be specified for creating an voiceEndptEntry.')
voiceEndPointFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndPointFailure.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndPointFailure.setDescription('End-point is failed because of a remote end-point failure. The remote end-point is on a node that resides in another domain making the connection an inter-domain connection.')
voiceNoRouteFoundFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceNoRouteFoundFailure.setStatus('mandatory')
if mibBuilder.loadTexts: voiceNoRouteFoundFailure.setDescription('Channel connection is failed is because no route to the remote Channel could be found.')
voiceBumpFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceBumpFailure.setStatus('mandatory')
if mibBuilder.loadTexts: voiceBumpFailure.setDescription("Channel Connection is failed because of insufficient bandwidth to route to the remote Channel. This may have also been caused because a higher priority connection took this channel's bandwidth. A higher priority connection is one with the lowest class of service (COS).")
voiceTestFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceTestFailure.setStatus('mandatory')
if mibBuilder.loadTexts: voiceTestFailure.setDescription('Channel is failed because of the failure of a connection test.')
voiceEndptTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("testCon", 1), ("writeOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptTestType.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptTestType.setDescription('Specifies the type of test the user would like to conduct on this endpoint. Only testCon is currently defined. TestCon performs a test of voice path integrity in the connection. Only write is allowed on this object. A -1 is returned to the NMS if a GET is recevied on this object')
voiceEndptLpbkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptLpbkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptLpbkStatus.setDescription('Specifies the current Loopback State of the endpoint. The value returned from this object is a bitmap of the current loopback states associated with this end point. The bitmap is defined below: LP-RMT-RMT 0 /* Remote nodes remote muxbus loopback */ LP-RMT-TST 1 /* Remote nodes tstcon loopback */ LP-LOC-RMT 2 /* Local nodes remote muxbus loopback */ LP-LOC-TST 3 /* Local nodes tstcon loopback */ LP-LOC-LOC 4 /* Local nodes local muxbus loopback */ LP-LOC-PORT 5 /* Local nodes port loopback */ LP-LOC-TPORT 6 /* Local nodes port test loopback */ LP-RMT-LOC 7 /* Remote nodes local muxbus loopback */ LP-RMT-PORT 8 /* Remote nodes port loopback */ LP-RMT-TPORT 9 /* Remote nodes port test looback */ LP-LOC-CSU 10 /* Local DDS network requested CSU loopback */ LP-RMT-CSU 11 /* Remote DDS network requested CSU loopback */ LP-LOC-DSU 12 /* Local DDS network requested DSU loopback */ LP-RMT-DSU 13 /* Remote DDS network requested DSU loopback */ LP-LOC-EXT 14 /* Local DDS external loopback */ LP-RMT-EXT 15 /* Remote DDS external loopback */ ')
voiceConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 15), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceConnPtr.setDescription('Pointer to general connection information. Using this pointer the user can obtain connection status, and routing information. Specifically, this is an object identifier specifying the first column of the appropriate row in the connTable.')
voiceChannelPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 16), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceChannelPtr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceChannelPtr.setDescription('Pointer to channel configuration information. Using this pointer the user can obtain all channel configuration information. Specifically, this is an object identifier specifying the first column of the appropriate row in the voiceChannelTable. ')
voiceEndptTrkAvoidType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("satellite", 2), ("terrestrial", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptTrkAvoidType.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptTrkAvoidType.setDescription('User selectable types of trunks to avoid for the transfer of voice channel data. Current choices are to avoid satellite links, terrestrial links, or to not avoid any specific type of link. This object is optional during the creation of the endpoint.')
voiceEndptAvoidZCS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptAvoidZCS.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptAvoidZCS.setDescription('Flag to force the connection to avoid trunks with zero code suppression (ZCS). This object is optional during the creation of the endpoint.')
voiceEndptState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("offhook", 1), ("onhook", 2), ("slowmodem", 3), ("fastmodem", 4), ("notConnected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptState.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptState.setDescription('It gives the state of the connection end point.')
voiceEndptAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptAdv.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptAdv.setDescription('It represents if the endpoint supports Adaptve voice capability.')
voiceOtherEndptAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceOtherEndptAdv.setStatus('mandatory')
if mibBuilder.loadTexts: voiceOtherEndptAdv.setDescription('It represents if the other endpoint supports Adaptve voice capability.')
voiceEndptEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alaw", 1), ("ulaw", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptEncoding.setDescription('It represents the type of Encoding used at this this Endpoint.')
voiceOtherEndptEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alaw", 1), ("ulaw", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceOtherEndptEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: voiceOtherEndptEncoding.setDescription('It represents the type of Encoding used at the other Endpoint.')
voiceEndptEndptType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pcm", 1), ("adpcm", 2), ("adpno", 3), ("transp", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptEndptType.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptEndptType.setDescription('It represents the end point type')
voiceEndptLocLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 13, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("writeOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceEndptLocLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptLocLpbkState.setDescription('Specifies the Local Loopback State the user would like to set for the endpoint.')
voiceStatTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14), )
if mibBuilder.loadTexts: voiceStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatTable.setDescription('The voice Statistics Table.')
voiceStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1), ).setIndexNames((0, "STRATACOM-MIB", "voiceEndptIndex"))
if mibBuilder.loadTexts: voiceStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatEntry.setDescription('An entry in the voice channel statistics table.')
voiceStatPktsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatPktsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatPktsRxs.setDescription('The number of packets received from the muxbus by the local port card.')
voiceStatPktsXmits = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatPktsXmits.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatPktsXmits.setDescription('The number of packets transmitted from the local port card onto the Mux Bus.')
voiceStatRxPktsDscds = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatRxPktsDscds.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatRxPktsDscds.setDescription('The number of packets received from the muxbus by the local port card which are discarded before being transmitted out to the port.')
voiceStatSprvPktsXmits = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatSprvPktsXmits.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatSprvPktsXmits.setDescription('The number of supervisory packets transmitted from the local port onto the Muxbus. Supervisory packets reflect signalling bit transitions for voice connections.')
voiceStatSprvPktsRcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatSprvPktsRcvs.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatSprvPktsRcvs.setDescription('The number of supervisory packets received from Muxbus associated with a connection.')
voiceStatV25ModemOns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatV25ModemOns.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatV25ModemOns.setDescription('The number of seconds the V.25 modem is detected and the connection is upgraded to PCM.')
voiceStatDsiOns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatDsiOns.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatDsiOns.setDescription('The number of seconds that a connection is performing Digital speech interpolation (DSI).')
voiceStatOffhks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatOffhks.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatOffhks.setDescription('The number of seconds that a connection is offhook. The onhook state is determined by onhook A/B/C/D bits defined by variables in the voiceEndpttable. A connection which is not onhook is treated as offhook.')
voiceStatInservices = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatInservices.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatInservices.setDescription('The number of seconds a connection is inservice. A connection is said to be in-service if its endpoints are not in alarm, the cards required to support this connection are present, and the connection is routed.')
voiceEndptMapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15), )
if mibBuilder.loadTexts: voiceEndptMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapTable.setDescription('The Voice Endpoint-Connection Mapping table.')
voiceEndptMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15, 1), ).setIndexNames((0, "STRATACOM-MIB", "voiceEndptMapSlot"), (0, "STRATACOM-MIB", "voiceEndptMapChannel"))
if mibBuilder.loadTexts: voiceEndptMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapEntry.setDescription('An entry in the Voice Endpoint Connection Mapping table.')
voiceEndptMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapSlot.setDescription('This MIB object contains the slot number associated with the requested connection endpoint.')
voiceEndptMapChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptMapChannel.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapChannel.setDescription('This MIB object contains the channel number associated with the requested connection endpoint.')
voiceEndptMapEndptPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptMapEndptPtr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapEndptPtr.setDescription('This MIB object contains a pointer to first column of row in the service specific EndptTable which corresponds to the slot and channel specified in the columns above.')
voiceEndptMapConnPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 3, 15, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceEndptMapConnPtr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceEndptMapConnPtr.setDescription('This MIB object contains a pointer to first column of row in connTable which corresponds to the slot and channel specified in the columns above.')
shelfCnfgStatMaster = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgStatMaster.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgStatMaster.setDescription('This object provides the network manager the IP address of the master statistics collection management workstation.')
shelfCnfgStatCollIntvl = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgStatCollIntvl.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgStatCollIntvl.setDescription('This object provides the network manager the current TFTP statistics collection file interval configured on the switch in minutes.')
shelfCnfgStatBcktIntvl = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgStatBcktIntvl.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgStatBcktIntvl.setDescription('This object provides the network manager the current TFTP statistics collection bucket interval configured on the switch in minutes.')
shelfCnfgStatTimeSync = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgStatTimeSync.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgStatTimeSync.setDescription('This object provides the network manager the current time for TFTP statistics collection. This object replaces the functionality originally supplied by the daytime handler application.')
shelfCnfgSwError = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgSwError.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgSwError.setDescription('This object notifies the network manager that a switch software error has has been logged on this shelf.')
shelfCnfgCardError = MibScalar((1, 3, 6, 1, 4, 1, 351, 100, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCnfgCardError.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCnfgCardError.setDescription('This object notifies the network manager that a switch card error has has been logged on this shelf.')
svplus = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1))
svnode = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2))
rtm = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 120))
controlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1, 11))
logGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1, 12))
networkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1, 13))
nodeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1, 14))
svNodeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 1))
packetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 2))
circuitGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 3))
frpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 4))
connGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 5))
realTimeCountersGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 2, 6))
trapsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 120, 1))
class Active(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("inactive", 1), ("active", 2))

class Severity(DisplayString):
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(0, 5)

nodeGrpName = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpName.setDescription('IPX node name.')
nodeGrpNetName = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpNetName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpNetName.setDescription('IPX network name.')
nodeGrpAlarmState = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("unreachable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpAlarmState.setDescription('Node Alarm State. Only low 6 bits are valid.')
nodeGrpGateway = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-a-gateway", 1), ("gateway", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpGateway.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpGateway.setDescription('Is this node acting as a gateway?')
nodeGrpActive = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 5), Active()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpActive.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpActive.setDescription('Active state of this Node.')
nodeGrpPlatform = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipx-platform", 1), ("bpx-platform", 2), ("axis-platform", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpPlatform.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpPlatform.setDescription('Platform type.')
nodeGrpRelease = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeGrpRelease.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGrpRelease.setDescription('StrataView Plus release revison.')
nodeFsIncRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeFsIncRate.setStatus('mandatory')
if mibBuilder.loadTexts: nodeFsIncRate.setDescription('FRP Foresight increase rate.')
nodeFsDecRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeFsDecRate.setStatus('mandatory')
if mibBuilder.loadTexts: nodeFsDecRate.setDescription('FRP forsight normal decrease rate.')
nodeFsFastRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeFsFastRate.setStatus('mandatory')
if mibBuilder.loadTexts: nodeFsFastRate.setDescription('FRP forsight fast decrease rate.')
nodeRstTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeRstTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: nodeRstTimeout.setDescription('Timeout for resetting PVC rate to QIR.')
alarmTrapSequenceNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmTrapSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: alarmTrapSequenceNumber.setDescription('The Sequence Number of the last trap generated on the SNMP Proxy')
trunkTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 2, 2), )
if mibBuilder.loadTexts: trunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: trunkTable.setDescription('The table of Trunk Lines.')
trunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "trunkLocalSlot"), (0, "STRATACOM-MIB", "trunkLocalPort"))
if mibBuilder.loadTexts: trunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trunkEntry.setDescription('An entry in the Trunk table.')
trunkLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLocalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: trunkLocalSlot.setDescription('Local Slot Number. These are numbered starting at 1.')
trunkLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: trunkLocalPort.setDescription('Local Port Number. These are numbered starting at 1.')
trunkLocalLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLocalLine.setStatus('mandatory')
if mibBuilder.loadTexts: trunkLocalLine.setDescription('Local Line Number. These are numbered starting at 1.')
trunkCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 22, 31, 34, 103, 104, 110))).clone(namedValues=NamedValues(("txr", 3), ("bni", 4), ("ntc", 22), ("atm", 31), ("ait", 34), ("bni-t3", 103), ("bni-e3", 104), ("bni-oc3", 110)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkCardType.setStatus('mandatory')
if mibBuilder.loadTexts: trunkCardType.setDescription('Type of the card supporting the trunk line. The card type is dependant on the value of nodePlatform. Additional types may exist with future hardware.')
trunkInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("t1-d4", 2), ("t1-esf", 3), ("e1-30", 4), ("e1-31", 5), ("e1-32", 6), ("subrate", 7), ("atm", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkInterface.setStatus('mandatory')
if mibBuilder.loadTexts: trunkInterface.setDescription('Trunk Line Interface Type. Indicates the format of the packet line.')
trunkLineLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLineLoad.setStatus('mandatory')
if mibBuilder.loadTexts: trunkLineLoad.setDescription('Line Load in packets per second.')
trunkRemNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRemNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRemNodeId.setDescription('Remote StrataView Node ID.')
trunkRemLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRemLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRemLineNumber.setDescription('Remote Line Number.')
trunkRemSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRemSlot.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRemSlot.setDescription('Remote Slot Number.')
trunkRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRemPort.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRemPort.setDescription('Remote Port Number.')
trunkAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: trunkAlarmState.setDescription('Trunk Line Alarm State.')
trunkComment = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkComment.setStatus('mandatory')
if mibBuilder.loadTexts: trunkComment.setDescription('StrataView user entered comment field used to further qualify the trunk line.')
trunkActive = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 13), Active()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkActive.setStatus('mandatory')
if mibBuilder.loadTexts: trunkActive.setDescription('Active State.')
trunkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trunkStatus.setDescription('Trunk line status.')
trunkStatReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkStatReserve.setStatus('mandatory')
if mibBuilder.loadTexts: trunkStatReserve.setDescription('Trunk Line statistical reserve field.')
trunkBurstyDataBQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkBurstyDataBQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: trunkBurstyDataBQDepth.setDescription('Trunk Line bursty data B queue depth.')
trunkBurstyDataBQEfcnThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkBurstyDataBQEfcnThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trunkBurstyDataBQEfcnThreshold.setDescription('Trunk Line bursty data B queue EFCN/FFCI threshold.')
trunkClpHighDropThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkClpHighDropThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trunkClpHighDropThreshold.setDescription('Trunk Line CLP high dropping threshold.')
trunkClpLowDropThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 2, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkClpLowDropThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trunkClpLowDropThreshold.setDescription('Trunk Line CLP low dropping threshold.')
cirLineTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 3, 1), )
if mibBuilder.loadTexts: cirLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineTable.setDescription('The table of Circuit Lines.')
cirLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "cirLineLineNumber"), (0, "STRATACOM-MIB", "cirLinePortNumber"))
if mibBuilder.loadTexts: cirLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineEntry.setDescription('An entry in the Circuit Line table.')
cirLineLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineLineNumber.setDescription('Circuit Line Number.')
cirLineCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 21, 25, 29))).clone(namedValues=NamedValues(("txr", 3), ("cip", 21), ("frp", 25), ("cdp", 29)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineCardType.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineCardType.setDescription('Circuit Card Type.')
cirLineInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("t1", 2), ("e1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineInterface.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineInterface.setDescription('Circuit Line Interface Type. Indicates the format of the circuit line.')
cirLineComment = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineComment.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineComment.setDescription('Comment entered by StrataView user to further qualify the Circuit Line.')
cirLineActive = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 7), Active()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineActive.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineActive.setDescription('Circuit Line Active State.')
cirLineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineStatus.setDescription('Circuit Line Status.')
cirLinePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLinePortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cirLinePortNumber.setDescription('Always returned as 0 for GET requests. ASI port number is filled-in for TRAPs.')
frpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 4, 1), )
if mibBuilder.loadTexts: frpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frpTable.setDescription('The table of Frame Relay Ports.')
frpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "frpLocalSlot"), (0, "STRATACOM-MIB", "frpLocalLine"), (0, "STRATACOM-MIB", "frpLocalPort"))
if mibBuilder.loadTexts: frpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frpEntry.setDescription('An entry in the Frame Relay Ports table.')
frpLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpLocalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: frpLocalSlot.setDescription('Local Slot Number.')
frpLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: frpLocalPort.setDescription('Local Port Number. These are numbered starting at 1.')
frpPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frpPortSpeed.setDescription('Port Speed in bits per second.')
frpComment = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpComment.setStatus('mandatory')
if mibBuilder.loadTexts: frpComment.setDescription('StrataView User comment used to further qualify the Frame Relay Port.')
frpActive = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 7), Active()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpActive.setStatus('mandatory')
if mibBuilder.loadTexts: frpActive.setDescription('Frame Relay Port Active State.')
frpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frpStatus.setDescription('Frame Relay Port Status.')
frpQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: frpQDepth.setDescription('Frame Relay Port queue depth.')
frpEcnThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpEcnThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frpEcnThreshold.setDescription('Frame Relay Port ECN queue threshold.')
frpDeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpDeThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frpDeThreshold.setDescription('Frame Relay Port DE threshold.')
frpPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2), ("aip", 3), ("not-defined", 4), ("frsm", 5), ("portConcent", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpPortType.setStatus('mandatory')
if mibBuilder.loadTexts: frpPortType.setDescription('Frame relay port type. ')
frpLocalLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpLocalLine.setStatus('mandatory')
if mibBuilder.loadTexts: frpLocalLine.setDescription('Local Line Number.')
connServerTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 5, 1), )
if mibBuilder.loadTexts: connServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: connServerTable.setDescription('The table of Connections.')
connEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "connLocalSlot"), (0, "STRATACOM-MIB", "connLocalLine"), (0, "STRATACOM-MIB", "connLocalChannel"), (0, "STRATACOM-MIB", "connLocalDLCI"))
if mibBuilder.loadTexts: connEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connEntry.setDescription('An entry in the Connections table.')
connLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: connLocalSlot.setDescription('Local Slot Number.')
connLocalChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalChannel.setStatus('mandatory')
if mibBuilder.loadTexts: connLocalChannel.setDescription('Local Channel Number. These are numbered starting at 1.')
connLocalDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: connLocalDLCI.setDescription('Local DLCI Number.')
connRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: connRemoteNodeId.setDescription('Remote StrataView Node ID.')
connRemoteSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteSlot.setStatus('mandatory')
if mibBuilder.loadTexts: connRemoteSlot.setDescription('Remote Slot Number.')
connRemoteChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteChannel.setStatus('mandatory')
if mibBuilder.loadTexts: connRemoteChannel.setDescription('Remote Channel Number. These are numbered starting at 1.')
connRemoteDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: connRemoteDLCI.setDescription('Remote DLCI Number.')
connServerType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("voice-dsi-adpcm", 1), ("voice-dsi", 2), ("voice", 3), ("voice-adpcm", 4), ("data", 5), ("frame-relay", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connServerType.setStatus('mandatory')
if mibBuilder.loadTexts: connServerType.setDescription('Connection Type.')
connRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRate.setStatus('mandatory')
if mibBuilder.loadTexts: connRate.setDescription('Combination Field of Rate Info. The value for this variable is generated by ORing together the following: 0x80 -> Fast Eia Enabled 0x40 -> DFM Enabled 0x08 -> 7/8 Encoding 0x10 -> 8/8 Encoding 0x18 -> 8/8 Inverted Encoding 0x20 -> 7/8 Inverted Encoding 0x01 -> Voice 0x02 -> Non-Time Stamped 0x03 -> Time Stamped 0x04 -> bursty data 0x05 -> multicast These form four fields: bit 7, bit 6, bits 3-5, and bits 0-2.')
connLocalMaxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalMaxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: connLocalMaxPkts.setDescription('Local maximum number of packets per second allocated.')
connRemoteMaxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteMaxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: connRemoteMaxPkts.setDescription('Remote maximum number of packets per second allocated.')
connMinBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMinBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: connMinBandwidth.setDescription('Minimum guaranteed bandwidth in bits per second. Zero if not meaningful.')
connDAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("non-dax", 1), ("dax", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connDAX.setStatus('mandatory')
if mibBuilder.loadTexts: connDAX.setDescription('Flag to identify DAX connection.')
connTXR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("non-txr", 1), ("txr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connTXR.setStatus('mandatory')
if mibBuilder.loadTexts: connTXR.setDescription('Flag to identify voice connection end point card is TXR card type.')
connComment = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connComment.setStatus('mandatory')
if mibBuilder.loadTexts: connComment.setDescription('StrataView user entered comment field used to further qualify the connection.')
connActive = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 18), Active()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connActive.setStatus('mandatory')
if mibBuilder.loadTexts: connActive.setDescription('Connection Active State.')
connStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connStatus.setDescription('Connection Status.')
connQir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connQir.setStatus('mandatory')
if mibBuilder.loadTexts: connQir.setDescription('Connection QIR.(bits per sec)')
connPir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPir.setStatus('mandatory')
if mibBuilder.loadTexts: connPir.setDescription('Connection PIR.(bits per sec)')
connVcQueDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connVcQueDepth.setStatus('mandatory')
if mibBuilder.loadTexts: connVcQueDepth.setDescription('Connection VcQueDepth.')
connVcQueThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connVcQueThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: connVcQueThreshold.setDescription('Connection VcQueThreshold.')
connCMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connCMax.setStatus('mandatory')
if mibBuilder.loadTexts: connCMax.setDescription('Connection maximum threshold for FRP credit manager.')
connPerUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPerUtil.setStatus('mandatory')
if mibBuilder.loadTexts: connPerUtil.setDescription('Connection Percent utilization.')
connConnInfoFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connConnInfoFlag.setStatus('mandatory')
if mibBuilder.loadTexts: connConnInfoFlag.setDescription('Connection information flags. The flags are define as: bit 6 snaPriorityHigh - decimal 64 bit 7 forsightEnabled - decimal 128 A value of 0 indicates no bits are set.')
connCir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connCir.setStatus('mandatory')
if mibBuilder.loadTexts: connCir.setDescription('Connection CIR.(bits per sec)')
connABitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connABitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connABitStatus.setDescription('Connection Bit status field. The fields defined are: bit 6 remotePacketLine - decimal 64 bit 7 aBitOk - decimal 128. A value of 0 indicates no bits are set.')
connLocalLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 5, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalLine.setStatus('mandatory')
if mibBuilder.loadTexts: connLocalLine.setDescription('Local Line Number. Valid only for AXIS')
cirLineRTCTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 6, 2), )
if mibBuilder.loadTexts: cirLineRTCTable.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCTable.setDescription('The table of Circuit Line statistics.')
cirLineRTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "cirLineRTCLineNumber"))
if mibBuilder.loadTexts: cirLineRTCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCEntry.setDescription('An entry in the Circuit Line statistics table. Each row may be sparse.')
cirLineRTCLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCLineNumber.setDescription('Circuit Line Line Number.')
cirLineRTCBipolarViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCBipolarViolations.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCBipolarViolations.setDescription('The number of bipolar violations which have occurred on the line. This statistic is valid for T1 circuits only.')
cirLineRTCFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCFrameSlips.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCFrameSlips.setDescription('The number of frame slips which have occurred on the receive side of the line. This statistic is valid for TXR lines only. CIP and CDP cards do not support this statistic.')
cirLineRTCOutOfFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCOutOfFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCOutOfFrames.setDescription('The number of 0 -> 1 transitions of the out of frame conditions as detected by the hardware.')
cirLineRTCLossesOfSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCLossesOfSignal.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCLossesOfSignal.setDescription('The number of 0 -> 1 transitions of the loss of signal condition as detected by the hardware. This statistic is valid on CIP and CDP lines only. TXR lines do not support this statistic.')
cirLineRTCFrameBitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCFrameBitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCFrameBitErrors.setDescription('The number of frame alignment signal errors which are detected on a line. This statistic is valid only on lines supported by CIP and CDP cards. TXR cards do not support this statistic.')
cirLineRTCCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCCrcErrors.setDescription('The number of CRC errors detected on the line. This statistic is valid on lines supported by CIP and CDP cards. TXR cards do no support this statistic.')
cirLineRTCOutOfMultiFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCOutOfMultiFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCOutOfMultiFrames.setDescription('The number of 0 -> 1 transitions into out of multi-frame as detected by the hardware. This statistic is valid only on E1 lines. T1 lines do not support this statistic.')
cirLineRTCAllOnesInTimeslot16 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cirLineRTCAllOnesInTimeslot16.setStatus('mandatory')
if mibBuilder.loadTexts: cirLineRTCAllOnesInTimeslot16.setDescription('The number of 0 -> 1 transitions of AIS-16. This statistic is valid only for CIP and CDP E1 format lines.')
frpRTCTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 6, 3), )
if mibBuilder.loadTexts: frpRTCTable.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCTable.setDescription('The table of frame relay statistics.')
frpRTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1), ).setIndexNames((0, "STRATACOM-MIB", "frpRTCSlot"), (0, "STRATACOM-MIB", "frpRTCLine"), (0, "STRATACOM-MIB", "frpRTCPort"))
if mibBuilder.loadTexts: frpRTCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCEntry.setDescription('An entry in the frame relay statistics table. Each row may be sparse.')
frpRTCSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCSlot.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCSlot.setDescription('Local Slot Number.')
frpRTCPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCPort.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCPort.setDescription('Local Port Number. These are numbered starting at 1.')
frpRTCFramesRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvd.setDescription('The number of frames received by the FRP port.')
frpRTCFramesXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesXmitted.setDescription('The number of frames transmitted out the FRP port.')
frpRTCBytesRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCBytesRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCBytesRcvd.setDescription('The number of frame bytes received from the FRP port.')
frpRTCBytesXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCBytesXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCBytesXmitted.setDescription('The number of frame bytes transmitted out the FRP port.')
frpRTCFramesXmittedWithFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesXmittedWithFECN.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesXmittedWithFECN.setDescription('The number of frames transmitted out the FRP port with the FECN bit set.')
frpRTCFramesXmittedWithBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesXmittedWithBECN.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesXmittedWithBECN.setDescription('The number of frames transmitted out the FRP port with the BECN bit set.')
frpRTCFramesRcvdCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvdCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvdCrcErrors.setDescription('The number of CRC errors on received frames for the FRP port.')
frpRTCFramesRcvdInvalidFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvdInvalidFormat.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvdInvalidFormat.setDescription('The number of frames received by the FRP port which contain incorrect EA bit settings (1 in the first byte and/or 0 in the second byte).')
frpRTCFramesRcvdAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvdAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvdAlignmentErrors.setDescription('The number of bit alignment errors on received frames for the FRP port.')
frpRTCFramesRcvdIllegalLen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvdIllegalLen.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvdIllegalLen.setDescription('The number of frames received by the FRP port which exceed the maximum allowed frame length.')
frpRTCDmaOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCDmaOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCDmaOverruns.setDescription('The number of DMA overruns on the FRP port.')
frpRTCLmiStatusEnquires = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiStatusEnquires.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiStatusEnquires.setDescription('The number of LMI status enquires received from the user device by the FRP port.')
frpRTCLmiStatusXmitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiStatusXmitRate.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiStatusXmitRate.setDescription('The number of LMI status messages transmitted to the user device from the FRP port per ??.')
frpRTCLmiStatusUpdateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiStatusUpdateRate.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiStatusUpdateRate.setDescription('The number of LMI update messages transmitted to the user device from the FRP port per ??.')
frpRTCLmiInvalidStatusEnquires = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiInvalidStatusEnquires.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiInvalidStatusEnquires.setDescription('The number of invalid LMI status enquires received from the user device by the FRP port.')
frpRTCLmiLinkTimeoutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiLinkTimeoutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiLinkTimeoutErrors.setDescription('The number of LMI link timeout errors.')
frpRTCLmiKeepaliveSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLmiKeepaliveSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLmiKeepaliveSequenceErrors.setDescription('The number of LMI keepalive sequence number errors.')
frpRTCFramesRcvdUndefDlciErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCFramesRcvdUndefDlciErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCFramesRcvdUndefDlciErrors.setDescription('The number of frames received by the FRP port which contain undefined DLCIs.')
frpRTCXmitStatusEnquirey = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCXmitStatusEnquirey.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCXmitStatusEnquirey.setDescription('Transmit Status Enquirey.')
frpRTCRxStatusCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCRxStatusCounter.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCRxStatusCounter.setDescription('Received Status counter.')
frpRTCAsyncStatusCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCAsyncStatusCounter.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCAsyncStatusCounter.setDescription('Asynchronous Status Counter.')
frpRTCBadSequenceNumberCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCBadSequenceNumberCount.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCBadSequenceNumberCount.setDescription('Invalid Sequence number count.')
frpRTCTxProtocolTimeOutCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCTxProtocolTimeOutCount.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCTxProtocolTimeOutCount.setDescription('Transmit Protocol timeout count.')
frpRTCCLLMFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCCLLMFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCCLLMFramesTx.setDescription('CLLM message frames transmited.')
frpRTCCLLMBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCCLLMBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCCLLMBytesTx.setDescription('CLLM message bytes transmitted.')
frpRTCCLLMFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCCLLMFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCCLLMFramesRx.setDescription('CLLM Frames received.')
frpRTCCLLMBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCCLLMBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCCLLMBytesRx.setDescription('CLLM bytes received.')
frpRTCCLLMFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCCLLMFailures.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCCLLMFailures.setDescription('CLLM failures.')
frpRTCRxDEFramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCRxDEFramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCRxDEFramesDiscarded.setDescription('The number of frames with the DE bit set which have been dropped by the frame relay port. IPX software versions earlier than IPX 6.1 will report a count of zero.')
frpRTCLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 3, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frpRTCLine.setStatus('mandatory')
if mibBuilder.loadTexts: frpRTCLine.setDescription('Local Slot Number.')
connRTCTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 6, 4), )
if mibBuilder.loadTexts: connRTCTable.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCTable.setDescription('The table of Connection statistics.')
connRTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1), ).setIndexNames((0, "STRATACOM-MIB", "connRTCSlot"), (0, "STRATACOM-MIB", "connRTCLine"), (0, "STRATACOM-MIB", "connRTCChannel"), (0, "STRATACOM-MIB", "connRTCDLCI"))
if mibBuilder.loadTexts: connRTCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCEntry.setDescription('An entry in the Connection statistics table.')
connRTCSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCSlot.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCSlot.setDescription('Local Slot Number.')
connRTCChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCChannel.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCChannel.setDescription('Local Channel Number. These are numbered starting at 1.')
connRTCDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCDLCI.setDescription('Local DLCI Number.')
connRTCRcvdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdFrames.setDescription('The number of frames received from the FRP port associated with the connection. This statistic is valid for Frame Relay Connections only.')
connRTCRcvdFramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdFramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdFramesDiscarded.setDescription('The number of frames received from the FRP port which are associated with the connection, but were discarded before being transmitted onto the Muxbus due to the age of the frame in the IPX system or the lack of buffer space. This statistic is valid for Frame Relay Connections only.')
connRTCXmitFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitFrames.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitFrames.setDescription('The number of frames transmitted out the FRP port which were received from the other endpoint of the connection. This statistic is valid for Frame Relay connections only.')
connRTCXmitFramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitFramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitFramesDiscarded.setDescription('The number of frames to be transmitted out the FRP port which were received from the other endpoint of the connection, but were discarded due to the age of the frame in the IPX system, a CRC error, or lack of buffer space. This statistic is valid for Frame Relay Connections only.')
connRTCRcvdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdPkts.setDescription('The number of packets received from the Muxbus by the FRP port associated with the connection endpoint. This statistic is valid for Frame Relay Connections only.')
connRTCRcvdPktsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdPktsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdPktsDiscarded.setDescription('The number of packets received from the Muxbus at the FRP port associated with the connection endpoint, but were discarded before being ssembled into frames and transmitted on the FRP port. This statistic is valid for Frame Relay Connections only.')
connRTCXmitPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitPkts.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitPkts.setDescription('The number of packets transmitted from one connection endpoint onto the Muxbus towards the other connection endpoint. This statistic is valid for all types of inter-node connections, and for CDP Data, FRP, LDP and SDP terminated DAX connections.')
connRTCXmitPktsProjected = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitPktsProjected.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitPktsProjected.setDescription('The estimated number of packets which would be used if DSI or DFM were enabled for the connection. This statistic is valid for inter-node voice connections and with all types of data connections. It is not valid for DAX voice connections or Frame Relay connections.')
connRTCXmitPktsSupervisory = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitPktsSupervisory.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitPktsSupervisory.setDescription("The number of supervisory packets transmitted from one connection endpoint to another. Supervisory packets reflect signaling bit transitions for voice connections, and EIA lead transitions for data channels. This statistic is valid on all inter-node 'a', 'c', and 'v' voice connections, all inter-node data connections, all 'd' type voice connection endpoints which are supported by CIP or CDP cards, and all DAX data connections. This statistic is not valid for Frame Relay connections.")
connRTCRcvdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdBytes.setDescription('The number of frame bytes received from the FRP port associated with the connection endpoint. This statistic is valid for Frame Relay connections only.')
connRTCRcvdBytesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRcvdBytesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRcvdBytesDiscarded.setDescription('The number of frame bytes received from the FRP port associated with the connection endpoint, but were discarded due to the age of the frame in the IPX system or the lack of buffer space before being transmitted onto the Muxbus. This statistic is valid for Frame Relay connections only.')
connRTCXmitBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitBytes.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitBytes.setDescription('The number of frame bytes to be received from the Muxbus from the remote end of the connection, which were actually transmitted out the FRP port as frames. This statistic is valid for Frame Relay connections only.')
connRTCXmitBytesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitBytesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitBytesDiscarded.setDescription('The number of frame bytes to be received from the Muxbus from the remote end of the connection, but were discarded due to the age of the frame in the IPX system, a CRC error, or lack of buffer space. This statistic is valid for Frame Relay connections only.')
connRTCSecondsV25ModemOn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCSecondsV25ModemOn.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCSecondsV25ModemOn.setDescription("The number of seconds the V.25 modem has been detected and a connection upgraded from ADPCM to PCM. The status of the V.25 modem detect is checked every 3 seconds, so the granularity of the data which makes up this statistic is 3 seconds. This statistic is valid for inter- node type 'a', 'c' and 'v' voice connections only.")
connRTCSecondsDsiEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCSecondsDsiEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCSecondsDsiEnabled.setDescription("The number of seconds that a connection has been performing Digital Speech Interpolation (DSI). The status of DSI is checked every 3 seconds, so the granularity of the data which makes up this statistic is 3 seconds. This statistic is valid for inter-node type 'c' and 'v' voice connections only.")
connRTCSecondsOffHook = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCSecondsOffHook.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCSecondsOffHook.setDescription("The number of seconds that a voice connection has been off-hook. The on-hook state is determined by the signaling bits, as defined by the 'cnfchtp' command. A connection which is not on-hook is treated as off-hook for this statistic. The status of the off-hook condition is checked every 3 seconds, so the granularity of the data which makes up this statistic is 3 seconds. This statistic is valid for all 'a', 'c' and 'v' voice connections, and for 'd' type voice connection endpoints supported by CIP or CDP cards.")
connRTCSecondsInService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCSecondsInService.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCSecondsInService.setDescription('The number of seconds that a connection has been in service. A conection is considered to be in service if its end points are not in alarm, that cards required to support the connection are present, and the connection is routed.')
connRTCXmitFramesWithFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitFramesWithFECN.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitFramesWithFECN.setDescription('The number of frames transmitted out the FRP port with the FECN bit set. This statistic is valid for Frame Relay connections only.')
connRTCXmitFramesWithBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCXmitFramesWithBECN.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCXmitFramesWithBECN.setDescription('The number of frames transmitted out the FRP port with the BECN bit set. This statistic is valid for Frame Relay connections only.')
connRTCRxSupervisoryPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCRxSupervisoryPkts.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCRxSupervisoryPkts.setDescription('The number of of supervisory packets received.')
connRTCCongestedMinuites = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCCongestedMinuites.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCCongestedMinuites.setDescription('The number of minuites in which 50%or more frames are tagged FECN by the FRP.')
connRTCFramesRxWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCFramesRxWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCFramesRxWithDE.setDescription('The number of frames received from the FRP with the DE bit set.')
connRTCFramesTxWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCFramesTxWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCFramesTxWithDE.setDescription('The number of frames transmitted from the FRP with the DE bit set. ')
connRTCFramesDiscardedWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCFramesDiscardedWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCFramesDiscardedWithDE.setDescription('The number of frames received from the local frame relay port with their DE bit set which are discarded before being transmitted onto the Muxbus.')
connRTCBytesRxWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCBytesRxWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCBytesRxWithDE.setDescription('The number of bytes received from the FRP for frames with the DE bit set.')
connRTCFramesRxExcessCir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCFramesRxExcessCir.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCFramesRxExcessCir.setDescription('The number of frames received in excess of CIR.')
connRTCBytesRxExcessCir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCBytesRxExcessCir.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCBytesRxExcessCir.setDescription('The number of frames received in excess of CIR.')
connRTCFramesTxExcessCir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCFramesTxExcessCir.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCFramesTxExcessCir.setDescription('The number of frames transmitted in excess of CIR.')
connRTCBytesTxExcessCir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCBytesTxExcessCir.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCBytesTxExcessCir.setDescription('The number of frames transmitted in excess of CIR.')
connRTCLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 4, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRTCLine.setStatus('mandatory')
if mibBuilder.loadTexts: connRTCLine.setDescription('Line Number, for IPX it is always 0.')
trunkRTCTable = MibTable((1, 3, 6, 1, 4, 1, 351, 2, 6, 5), )
if mibBuilder.loadTexts: trunkRTCTable.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTable.setDescription('The table of Trunk Line statistics.')
trunkRTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1), ).setIndexNames((0, "STRATACOM-MIB", "trunkRTCLocalSlot"), (0, "STRATACOM-MIB", "trunkRTCLocalPort"))
if mibBuilder.loadTexts: trunkRTCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCEntry.setDescription('An entry in the Trunk Line statistics table. Each row may be sparse.')
trunkRTCLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCLocalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCLocalSlot.setDescription('Local Slot Number. These are numbered starting at 1')
trunkRTCLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCLocalPort.setDescription('Local Port Number. These are numbered starting at 1.')
trunkRTCBipolarViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBipolarViolations.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBipolarViolations.setDescription("The signal level for a '1' bit should alternate between a positive and a negative signal. If two positive or two negative signals are received in a row, a bipolar violation has occurred.")
trunkRTCFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCFrameSlips.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCFrameSlips.setDescription('The number of frame slips which have occurred on the receive side of the line. This statistic is valid for TXR lines only. NTC cards do not support this statistic.')
trunkRTCOutOfFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCOutOfFrames.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCOutOfFrames.setDescription('The number of 0 -> 1 transitions of the out of frame condition as detected by the hardware. This statistic is valid for T1 and E1 lines only.')
trunkRTCLossOfSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCLossOfSignal.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCLossOfSignal.setDescription('The number of 0 -> 1 transitions of the loss of signal condition as detected by the hardware. This statistic is valid for NTC lines only.')
trunkRTCFrameBitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCFrameBitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCFrameBitErrors.setDescription('The number of frame alignment signal errors which have been detected on this line. This statistic is valid only on lines supported by NTC cards. TXR and Sub-rate lines do not support this statistic. This statistic is also not supported by NTC-T1 in ESF framing mode.')
trunkRTCCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCCrcErrors.setDescription('The number of CRC errors detected on the line. This statistic is valid only on lines supported by NTC cards. TXR cards and Sub-rate lines do not support this statistic. This statistic is also not supported by NTC-T1 in D4 framing mode.')
trunkRTCPktOutOfFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCPktOutOfFrames.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCPktOutOfFrames.setDescription('The number of packets out of frames on this line. This statistic is only valid on lines supported by NTC cards. TXR cards do not support this statistic.')
trunkRTCPktCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCPktCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCPktCrcErrors.setDescription('The number of packets received with detected CRC errors in the packet headers.')
trunkRTCBadClockErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBadClockErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBadClockErrors.setDescription('The number of 0 -> 1 transitions of the loss of clock condition as detected by the hardware. This statistic is valid on NTC Sub-rate lines only. T1 and E1 lines do not support this statistic.')
trunkRTCVoicePktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCVoicePktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCVoicePktsDropped.setDescription('The number of voice packets dropped on a line.')
trunkRTCTimeStampedPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTimeStampedPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTimeStampedPktsDropped.setDescription('The number of time stamped data packets dropped on the line.')
trunkRTCNonTimeStampedPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCNonTimeStampedPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCNonTimeStampedPktsDropped.setDescription('The number of non-time stamped data packets dropped on the line.')
trunkRTCHighPriorityPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCHighPriorityPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCHighPriorityPktsDropped.setDescription('The number of high priority (PCC) packets dropped on the line.')
trunkRTCBurstyDataPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataPktsDropped.setDescription('The number of bursty data packets dropped on the line.')
trunkRTCMulticastPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCMulticastPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCMulticastPktsDropped.setDescription('The number of Multicast packets dropped on the line.')
trunkRTCVoicePktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCVoicePktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCVoicePktsXmitted.setDescription('The number of voice packets transmitted onto the line.')
trunkRTCTimeStampedPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTimeStampedPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTimeStampedPktsXmitted.setDescription('The number of time stamped packets transmitted onto the line.')
trunkRTCNonTimeStampedPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCNonTimeStampedPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCNonTimeStampedPktsXmitted.setDescription('The number of non-time stamped packets transmitted onto the line.')
trunkRTCHighPriorityPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCHighPriorityPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCHighPriorityPktsXmitted.setDescription('The number of high priority packets transmitted onto the line.')
trunkRTCBurstyDataPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataPktsXmitted.setDescription('The number of bursty data packets transmitted onto the line.')
trunkRTCMulticastPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCMulticastPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCMulticastPktsXmitted.setDescription('The number of Multicast packets transmitted onto the line.')
trunkRTCPktsXmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCPktsXmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCPktsXmitted.setDescription('The total number of packets transmitted onto the line.')
trunkRTCTxBurstyDataAClpPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataAClpPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataAClpPktsDropped.setDescription('The number of packets with the CLP bit set that are dropped from the bursty data A queue.')
trunkRTCTxBurstyDataBClpPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBClpPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBClpPktsDropped.setDescription('The number of packets with the CLP bit set that are dropped from the bursty data B queue.')
trunkRTCBurstyDataAEfcnPktsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataAEfcnPktsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataAEfcnPktsTx2Line.setDescription('The number of packets with the EFCN bit set which have been transmitted onto the line from the bursty data A queue.')
trunkRTCBurstyDataBEfcnPktsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataBEfcnPktsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataBEfcnPktsTx2Line.setDescription('The number of packets with the EFCN bit set which have been transmitted onto the line from the bursty data B queue.')
trunkRTCBurstyDataAClpPktsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataAClpPktsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataAClpPktsTx2Line.setDescription('The number of packets with the CLP bit set which have been transmitted onto the line from the bursty data A queue.')
trunkRTCBurstyDataBClpPktsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataBClpPktsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataBClpPktsTx2Line.setDescription('The number of packets with the CLP bit set which have been transmitted onto the line from the bursty data B queue.')
trunkRTCAtmCellHeaderHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCAtmCellHeaderHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCAtmCellHeaderHecErrors.setDescription('The number of ATM cell headers with HEC errors.')
trunkRTCTxVoiceCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxVoiceCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxVoiceCellsDropped.setDescription('The number of transmit voice cells dropped.')
trunkRTCTxTimeStampCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxTimeStampCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxTimeStampCellsDropped.setDescription('The number of transmit time stamped cells dropped.')
trunkRTCTxNonTStampCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxNonTStampCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxNonTStampCellsDropped.setDescription('The number of transmit non time stamped cells dropped.')
trunkRTCTxHighPriorityCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxHighPriorityCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxHighPriorityCellsDropped.setDescription('The number of transmit high priority cells dropped.')
trunkRTCTxBurstyDataACellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataACellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataACellsDropped.setDescription('The number of cells dropped from the bursty data A queue.')
trunkRTCTxBurstyDataBCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBCellsDropped.setDescription('The number of cells dropped from the bursty data B queue.')
trunkRTCVoiceCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCVoiceCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCVoiceCellsTx2Line.setDescription('The number of voice cells transmitted onto the line.')
trunkRTCTimeStampCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTimeStampCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTimeStampCellsTx2Line.setDescription('The number of time stamped cells tranmsitted onto the line.')
trunkRTCNonTimeStampCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCNonTimeStampCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCNonTimeStampCellsTx2Line.setDescription('The number of non time stamped cells tranmsitted onto the line.')
trunkRTCHighPriorityCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCHighPriorityCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCHighPriorityCellsTx2Line.setDescription('The number of high priority cells transmitted onto the line.')
trunkRTCBurstyDataACellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataACellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataACellsTx2Line.setDescription('The number of cells which have been transmitted onto the line from the bursty data A queue.')
trunkRTCBurstyDataBCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataBCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataBCellsTx2Line.setDescription('The number of cells which have been transmitted onto the line from the bursty data B queue.')
trunkRTCTotalCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTotalCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTotalCellsTx2Line.setDescription('The number of cells transmitted onto the line.')
trunkRTCTxBurstyDataAClpCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataAClpCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataAClpCellsDropped.setDescription('The number of cells with the CLP bit set which have been dropped from the bursty data A queue.')
trunkRTCTxBurstyDataBClpCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBClpCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCTxBurstyDataBClpCellsDropped.setDescription('The number of cells with the CLP bit set which have been dropped from the bursty data B queue.')
trunkRTCBurstyDataAEfcnCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataAEfcnCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataAEfcnCellsTx2Line.setDescription('The number of cells with the EFCN bit set which have been transmitted onto the line from the bursty data A queue.')
trunkRTCBurstyDataBEfcnCellsTx2Line = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCBurstyDataBEfcnCellsTx2Line.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCBurstyDataBEfcnCellsTx2Line.setDescription('The number of cells with the EFCN bit set which have been transmitted onto the line from the bursty data B queue.')
trunkRTCPlcpOutOfFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 2, 6, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkRTCPlcpOutOfFrames.setStatus('mandatory')
if mibBuilder.loadTexts: trunkRTCPlcpOutOfFrames.setDescription('The number of out of frame conditions.')
trapConfigTable = MibTable((1, 3, 6, 1, 4, 1, 351, 120, 1, 1), )
if mibBuilder.loadTexts: trapConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapConfigTable.setDescription('The table has the information about the manager receiving traps')
trapConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "managerIPaddress"))
if mibBuilder.loadTexts: trapConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapConfigEntry.setDescription('An entry of the manager table.')
managerIPaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerIPaddress.setStatus('mandatory')
if mibBuilder.loadTexts: managerIPaddress.setDescription(' ')
managerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: managerPortNumber.setDescription(' ')
managerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("addRow", 1), ("delRow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: managerRowStatus.setDescription('When RowStatus is set to addRow(1), the mgr is registered with the Proxy to receive the new traps generated.')
readingTrapFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readingTrapFlag.setStatus('mandatory')
if mibBuilder.loadTexts: readingTrapFlag.setDescription(' ')
nextTrapSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nextTrapSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: nextTrapSeqNum.setDescription(' ')
managerNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 120, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managerNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: managerNumOfValidEntries.setDescription('The number of managers in the table that are programmed to receive traps')
lastSequenceNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 120, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lastSequenceNumber.setDescription('The Sequence Number of the last trap generated on the SNMP Proxy')
trapUploadTable = MibTable((1, 3, 6, 1, 4, 1, 351, 120, 1, 4), )
if mibBuilder.loadTexts: trapUploadTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapUploadTable.setDescription('The table has the information about the manager receiving traps')
trapUploadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1), ).setIndexNames((0, "STRATACOM-MIB", "mgrIpAddress"))
if mibBuilder.loadTexts: trapUploadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapUploadEntry.setDescription('An entry of the manager table.')
mgrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mgrIpAddress.setDescription(' ')
trapSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapSequenceNum.setStatus('mandatory')
if mibBuilder.loadTexts: trapSequenceNum.setDescription('The sequence number associated with tthe trap')
trapPduString = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapPduString.setStatus('mandatory')
if mibBuilder.loadTexts: trapPduString.setDescription('The sequence number associated with tthe trap')
endOfQueueFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endOfQueueFlag.setStatus('mandatory')
if mibBuilder.loadTexts: endOfQueueFlag.setDescription('The sequence number associated with tthe trap')
databaseSampleFreq = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 11, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: databaseSampleFreq.setStatus('mandatory')
if mibBuilder.loadTexts: databaseSampleFreq.setDescription('The desired rate (in seconds) at which the database should be queried for new log records that match any of the filter criteria from the Event Filter Table. The agent may optionally poll more or less frequently then specified by this variable. The value of this variable is only a suggestion to the agent.')
currentMaxLogIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentMaxLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: currentMaxLogIndex.setDescription('The current max value of logIndex. This value may change with time.')
maintLogTable = MibTable((1, 3, 6, 1, 4, 1, 351, 1, 12, 2), )
if mibBuilder.loadTexts: maintLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogTable.setDescription('The table of log entries.')
maintLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "logIndex"))
if mibBuilder.loadTexts: maintLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogEntry.setDescription('An entry in the log table.')
logIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1073741824))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logIndex.setDescription('Unique index of the Log record.')
logNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: logNetwork.setDescription('Name of the network for which this log entry was generated.')
logNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: logNodeName.setDescription('Name of the IPX node for this this log entry was generated.')
logGmtDate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19)).setMaxAccess("readonly")
if mibBuilder.loadTexts: logGmtDate.setStatus('mandatory')
if mibBuilder.loadTexts: logGmtDate.setDescription('ASCII formatted string indicating the GMT date and time for this log record in the format (yyyy-mm-dd hh:mm:ss). This is the time reported by the IPX which generated the event.')
logSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 5), Severity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: logSeverity.setDescription('The severity of this log record.')
logMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logMsg.setStatus('mandatory')
if mibBuilder.loadTexts: logMsg.setDescription('An ASCII message associated with this log record.')
eventFilterTable = MibTable((1, 3, 6, 1, 4, 1, 351, 1, 12, 3), )
if mibBuilder.loadTexts: eventFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterTable.setDescription('The table of Event Filters.')
eventFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 1, 12, 3, 1), ).setIndexNames((0, "STRATACOM-MIB", "eventFilterIndex"))
if mibBuilder.loadTexts: eventFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterEntry.setDescription('An entry in the Event Filter table. Each entry in this table describes a set of log entry criteria, and entries in the log that match these criteria will be forwarded as SNMP TRAPS.')
eventFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterIndex.setDescription('The unique index for each entry of this table. This entry can only be written with the first SET command to create a new row of this table.')
eventFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterStatus.setDescription("'active' indicates that this row of the table is currently generating filtered TRAPs. When in this state, any entry added to the log table with logSeverity matching eventFilterSeverity and logMsg containing the eventFilterSubstring text, this information will be forwarded as a TRAP. 'invalid' indicates that this row of the table is no longer generating filtered TRAPs. A conforming agent may either leave the row with the 'invalid' value in the table, or may delete the row from the table.")
eventFilterSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 3, 1, 3), Severity().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventFilterSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterSeverity.setDescription('The eventFilterSeverity specifies the severity of log records to be forwarded on as SNMP TRAPS by this event filter entry. The value of eventFilterSeverty must exactly match the value of logSeverity for there to be a chance that a new log record will be forwarded as a TRAP. An eventFilterSeverity of length 0 matches all severity levels.')
eventFilterSubstring = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 12, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventFilterSubstring.setStatus('mandatory')
if mibBuilder.loadTexts: eventFilterSubstring.setDescription('The eventFilterSubstring variable specifies an ASCII substring that must appear in the logMsg field of a log record in order for there to be a chance that for the log record to forwarded as a TRAP. If this variable contains a zero length string, the substring comparison will always SUCCEED for this event filter entry.')
maintLogFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 1, 12, 4))
maintLogFilterTimeMin = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterTimeMin.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterTimeMin.setDescription('When maintLogFilterTimeMin has a value other than a 0 length string, the value is used as a minimum value for maintLogFilterGmtDate to qualify entries in the maintLogTable. The string is formated as yyyy-mm-dd hh:mm:ss')
maintLogFilterTimeMax = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterTimeMax.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterTimeMax.setDescription('When maintLogFilterTimeMax has a value other than a 0 length string, the value is used as a maximum value for maintLogFilterGmtDate to qualify entries in the maintLogTable. The string is formated as yyyy-mm-dd hh:mm:ss')
maintLogFilterWindow = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 3), Integer32().clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterWindow.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterWindow.setDescription('When maintLogFilterWindow has a value other than 0, the value is used to qualify entries in the maintLogTable. This attribute has the effect of limiting the view in the maintLogTable to the number specified by the value of this attribute. If after applying the other maintLogFilter attributes, the remaining set exceeds the value of maintLogFilterWindow then, the set of entries which can be viewed is limited to the top N based on the logIndex value.')
maintLogFilterNetworkName = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterNetworkName.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterNetworkName.setDescription('When maintLogFilterNetworkName has a value other than a 0 length string, then the value of this attribute is used to qualify entries in the maintLogTable. This value must match logNetwork exactly to pass the filter.')
maintLogFilterNodeName = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterNodeName.setDescription('When maintLogFilterNodeName has a value other than a 0 length string, then the value of this attribute is used to qualify entries in the maintLogTable. This value must match logNodeName exactly to pass the filter.')
maintLogFilterSeverity = MibScalar((1, 3, 6, 1, 4, 1, 351, 1, 12, 4, 6), Severity().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maintLogFilterSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: maintLogFilterSeverity.setDescription('When maintLogFilterSeverity has a value other than a 0 length string, then the value is used to qualify entries in the maintLogTable. The value must match the logSeverity exactly to pass the filter.')
networkTable = MibTable((1, 3, 6, 1, 4, 1, 351, 1, 13, 1), )
if mibBuilder.loadTexts: networkTable.setStatus('mandatory')
if mibBuilder.loadTexts: networkTable.setDescription('The table of Networks.')
networkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 1, 13, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "networkName"))
if mibBuilder.loadTexts: networkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: networkEntry.setDescription('An entry in the Network table.')
networkName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 13, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: networkName.setStatus('mandatory')
if mibBuilder.loadTexts: networkName.setDescription('The name of the network as assigned by the StrataView User.')
networkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 13, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: networkId.setStatus('mandatory')
if mibBuilder.loadTexts: networkId.setDescription('The unique ID of the network as assigned by the StrataView system.')
networkIpxId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 13, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: networkIpxId.setStatus('mandatory')
if mibBuilder.loadTexts: networkIpxId.setDescription('The IPX network ID.')
nodeTable = MibTable((1, 3, 6, 1, 4, 1, 351, 1, 14, 1), )
if mibBuilder.loadTexts: nodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: nodeTable.setDescription('The table of Nodes.')
nodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 1, 14, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "nodeNetworkName"), (0, "STRATACOM-MIB", "nodeName"))
if mibBuilder.loadTexts: nodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nodeEntry.setDescription('An entry in the Node table.')
nodeNetworkName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 14, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNetworkName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeNetworkName.setDescription('The name of the network to which this node is attached.')
nodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 1, 14, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeName.setDescription('IPX node name.')
trunkStatusAlarm = NotificationType((1, 3, 6, 1, 4, 1, 351, 2) + (0,0)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "nodeGrpName"), ("STRATACOM-MIB", "nodeGrpNetName"), ("STRATACOM-MIB", "trunkStatus"))
if mibBuilder.loadTexts: trunkStatusAlarm.setDescription('This trap is generated whenever an ObjectAlarm Status message is received containing the trunk status.')
cirLineStatusAlarm = NotificationType((1, 3, 6, 1, 4, 1, 351, 2) + (0,1)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "nodeGrpName"), ("STRATACOM-MIB", "nodeGrpNetName"), ("STRATACOM-MIB", "cirLineStatus"))
if mibBuilder.loadTexts: cirLineStatusAlarm.setDescription('This trap is generated whenever an ObjectAlarm Status message is received containing the cirLineStatus.')
frpStatusAlarm = NotificationType((1, 3, 6, 1, 4, 1, 351, 2) + (0,2)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "nodeGrpName"), ("STRATACOM-MIB", "nodeGrpNetName"), ("STRATACOM-MIB", "frpStatus"))
if mibBuilder.loadTexts: frpStatusAlarm.setDescription('This trap is generated whenever an ObjectAlarm Status message is received containing the frpStatus.')
connStatusAlarm = NotificationType((1, 3, 6, 1, 4, 1, 351, 2) + (0,3)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "nodeGrpName"), ("STRATACOM-MIB", "nodeGrpNetName"), ("STRATACOM-MIB", "connStatus"), ("STRATACOM-MIB", "connABitStatus"))
if mibBuilder.loadTexts: connStatusAlarm.setDescription('This trap is generated whenever an ObjectAlarm Status message is received containing the connStatus.')
filteredLogRecord = NotificationType((1, 3, 6, 1, 4, 1, 351, 1) + (0,4)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "logIndex"), ("STRATACOM-MIB", "logNetwork"), ("STRATACOM-MIB", "logNodeName"), ("STRATACOM-MIB", "logGmtDate"), ("STRATACOM-MIB", "logSeverity"), ("STRATACOM-MIB", "logMsg"))
if mibBuilder.loadTexts: filteredLogRecord.setDescription("The 'filteredLogRecord' trap is generated by the StrataView system whenever an entry in the eventFilterTable matches a log record that is added to the StrataView database.")
connSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 3))
portSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 4))
connMibUpTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMibUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: connMibUpTime.setDescription('the equivalent of sysUpTime for this MIB, its the elapsed time since the management entity supporting this mib is started. If the entity is the same as that supporting MIB II sysUpTime than this attribute is the same as sysUpTime.')
connAvailIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connAvailIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connAvailIndex.setDescription('This object is not required any more because now connectionIndex is internally generated by the Proxy itself. User is required to use connectionIndex=0 for adding connections. This object is kept for the backward compatibilty. GET on this object always returns 0')
connectionTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 3), )
if mibBuilder.loadTexts: connectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTable.setDescription('A List of Connection Virtual Circuit Entries')
connectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 3, 1), ).setIndexNames((0, "STRATACOM-MIB", "connectionIndex"))
if mibBuilder.loadTexts: connectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connectionEntry.setDescription('A General Connection Entry')
connectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connectionIndex.setDescription('A unique value greater than 0 for each entry in the table. The value assigned must remain constant at least from one reinitialization of the managment entity and the next. Special value 0 must be used for adding new rows in the table. The actual index will be generated internally by the Proxy.')
connectionLocalEndPt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionLocalEndPt.setStatus('mandatory')
if mibBuilder.loadTexts: connectionLocalEndPt.setDescription('The object identifier of the 1st attribute of the end point in the associated protocol specific end point table.')
connectionRemoteEndPt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionRemoteEndPt.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRemoteEndPt.setDescription('The object identifier of the 1st attribute of the end point in the associated protocol specific end point table. ')
connectionAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connectionAdminStatus.setDescription(" Administrative status of the connection. This attribute may be set to 'testing' only when connectionOpStatus has the value 'clear'.")
connectionOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4), ("incomplete", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionOpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connectionOpStatus.setDescription("A operation status of the connection. 'incomplete' indicates that the some segments of the connection exist but others may be in an unknown or non-existant state.")
connectionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRowStatus.setDescription("To create an entry in this table, set the value of this object to 'createAndGo'. To delete the connection and the corresponding end points set the value to 'destroy'. setting the value to active will result in bad value. Other required parameters can also be set in the same request")
connectionTrkAvoidType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("satellite", 2), ("terrestrial", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionTrkAvoidType.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTrkAvoidType.setDescription('User selectable types of trunks to avoid for the transfer of data. Current choices are to avoid satellite links, terrestrial links, or to not avoid any specific type of link.')
connectionTrkAvoidZCS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionTrkAvoidZCS.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTrkAvoidZCS.setDescription('Flag to force the connection to avoid trunks with zero code suppression (ZCS). ')
connectionForesight = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionForesight.setStatus('mandatory')
if mibBuilder.loadTexts: connectionForesight.setDescription('Flag to enable/disable foresight.')
connectionClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionClassOfService.setStatus('mandatory')
if mibBuilder.loadTexts: connectionClassOfService.setDescription('A class of service for this connection. The lower the class value, the higher the routing priority of the connection.')
connectionCurrRouteDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionCurrRouteDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connectionCurrRouteDesc.setDescription('A description of the current route. Descriptor gives information about the domain, nodename, slot, and possibly a port for each hop in the route. For example, Node1 15 - 15Node2 is a valid route specifying a terrestrial link between Node1 slot 15 and Node2 slot 15. The following describes the general format for connectionCurrRouteDesc: (<node-name>.<TRK>[.0])* - <node-name> (<node-name>.<slot.port>)* - <node-name> Some more valid descriptions are: 1) Node1.15.1 - Node2.13.1 - Node3 2) Node1.15.1-Node2.13.1-Node3 3) Node1.15 - Node2.12 - Node3.15 - Node4 4) Node1.15.0 - Node2.12.0 - Node3.15.0 - Node4 5) Node2 NOTE: a> (...)* notation means the description inside parenthesis may repeat any number of times, only limited by the total length which is 255 and the [...] notation signifies that it is optional. b> 1) & 2) are equivalent so are 3) & 4). ')
connectionPrefRouteDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionPrefRouteDesc.setStatus('mandatory')
if mibBuilder.loadTexts: connectionPrefRouteDesc.setDescription('Descriptor of the preferred route (all hops specified). Descriptor gives information about the domain, nodename, slot, and possibly a port for each hop in the route. For example, Node1.15 - Node2 is a valid route specifying a terrestrial link between Node1 slot 15 and Node2. The following describes the general format for connectionPrefRouteDesc: (<node-name>.<TRK>[.0])* - <node-name> (<node-name>.<slot.port>)* - <node-name> Some more valid descriptions are: 1) Node1.15.1 - Node2.13.1 - Node3 2) Node1.15.1-Node2.13.1-Node3 3) Node1.15 - Node2.12 - Node3.15 - Node4 4) Node1.15.0 - Node2.12.0 - Node3.15.0 - Node4 5) Node2 NOTE: a> (...)* notation means the description inside parenthesis may repeat any number of times, only limited by the total length which is 255 and the [...] notation signifies that it is optional. b> 1) & 2) are equivalent so are 3) & 4). ')
connRouteMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRouteMaster.setStatus('mandatory')
if mibBuilder.loadTexts: connRouteMaster.setDescription('The node name of the route master.')
connectionLocOSpacePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionLocOSpacePkts.setStatus('mandatory')
if mibBuilder.loadTexts: connectionLocOSpacePkts.setDescription('This variable provides the minimum packet load available on the mandatory path of this connection in local->remote direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is mandatoryly routed and reporting the minimum available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in packets per second.')
connectionLocOSpaceBdaCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionLocOSpaceBdaCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connectionLocOSpaceBdaCmax.setDescription('This variable provides the minimum BData A Cmax available on the mandatory path of this connection in local->remote direction. This variable is determined by comparing available BData A Cmax on every trunk on which the connection is mandatoryly routed and reporting the minumim available. For interdomain connections this value represents available BData A Cmax through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in bytes.')
connectionLocOSpaceBdbCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionLocOSpaceBdbCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connectionLocOSpaceBdbCmax.setDescription('This variable provides the minimum BData B Cmax available on the mandatory path of this connection in local->remote direction. This variable is determined by comparing available BData B Cmax on every trunk on which the connection is mandatoryly routed and reporting the minumim available. For interdomain connections this value represents available BData B Cmax through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in bytes.')
connectionRemOSpacePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionRemOSpacePkts.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRemOSpacePkts.setDescription('This variable provides the minimum packet load available on the mandatory path of this connection in remote->local direction. This variable is determined by comparing available bandwidth on every trunk on which the connection is mandatoryly routed and reporting the minumim available bandwidth. For interdomain connections this value represents available bandwidth through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in packets per second.')
connectionRemOSpaceBdaCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionRemOSpaceBdaCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRemOSpaceBdaCmax.setDescription('This variable provides the minimum BData A Cmax available on the mandatory path of this connection in remote->local direction. This variable is determined by comparing available BData A Cmax on every trunk on which the connection is mandatoryly routed and reporting the minumim available. For interdomain connections this value represents available BData A Cmax through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in bytes.')
connectionRemOSpaceBdbCmax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionRemOSpaceBdbCmax.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRemOSpaceBdbCmax.setDescription('This variable provides the minimum BData B Cmax available on the mandatory path of this connection in remote->local direction. This variable is determined by comparing available BData B Cmax on every trunk on which the connection is mandatoryly routed and reporting the minumim available. For interdomain connections this value represents available BData B Cmax through all domains. This variable is meaningful for routed connections only. Value (-1) is returned in case of internal errors and (0) is returned for DAX connections. These values are returned in bytes.')
connectionTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("continuity", 1), ("delay", 2), ("none", 255))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionTestType.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTestType.setDescription("Specifies the type of test to be conducted on this connection. The test is executed when both this attribute is set to the appropriate test and connectionAdminStatus is SET to 'testing'. The 'continuity' test verifies continuity. The 'delay' test on successful completion sets the delay in msecs in connectionTestResult. This attribute may be set only when connectionOpStatus has the value 'clear', 'fail', or 'down'.")
connectionTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTestResult.setDescription('This object holds the result of an executed connection test. If a continuity test is executed, this object contains the value 0 if successful, or -2 if failed. If a delay test successfully executed, this object will indicate the round trip delay (in milliseconds) for the connection. If the delay test failed this object contains the value -2. If no test has been executed, or the connectionTestType is SET, then this object will return the value -1.')
connectionAbitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionAbitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connectionAbitStatus.setDescription('A-bit status of the connection.')
connectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 20))).clone(namedValues=NamedValues(("fr", 1), ("atm", 2), ("atm-fr", 3), ("unknown", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionType.setStatus('mandatory')
if mibBuilder.loadTexts: connectionType.setDescription('Connection Type. fr indicates Framerelay to Framerelay connection. atm indicates Atm to Atm connection and atm-fr indicates Atm to FrameRelay connection. unknown indicates incomplete connection.')
connectionLocalStr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 24), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionLocalStr.setStatus('mandatory')
if mibBuilder.loadTexts: connectionLocalStr.setDescription('The Local EndPt information in string format. i.e., the instance information of the EndPt. Framerelay Endpt is displayed as: node.shelf.slot.line.port.dlci Atm Endpt is displayed as: node.shelf.slot.port.vpi.vci shelf is 0 for Endpt on a routing node.')
connectionRemoteStr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 3, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionRemoteStr.setStatus('mandatory')
if mibBuilder.loadTexts: connectionRemoteStr.setDescription('The Remote EndPt information in string format. i.e., the instance information of the EndPt. Framerelay Endpt is displayed as: node.shelf.slot.line.port.dlci Atm Endpt is displayed as: node.shelf.slot.port.vpi.vci shelf is 0 for Endpt on a routing node.')
frEndPtTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 4), )
if mibBuilder.loadTexts: frEndPtTable.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtTable.setDescription('A List of frame relay virtual circuit end points')
frEndPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 4, 1), ).setIndexNames((0, "STRATACOM-MIB", "frEndPtNodeName"), (0, "STRATACOM-MIB", "frEndPtIfShelf"), (0, "STRATACOM-MIB", "frEndPtSlot"), (0, "STRATACOM-MIB", "frEndPtLine"), (0, "STRATACOM-MIB", "frEndPtPort"), (0, "STRATACOM-MIB", "frEndPtDlci"))
if mibBuilder.loadTexts: frEndPtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEntry.setDescription('A frame relay end point Entry')
frEndPtNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtNodeName.setDescription('The node name.')
frEndPtIfShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtIfShelf.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtIfShelf.setDescription('String identifying the shelf. This is a null string for end points which do not have a shelf name.')
frEndPtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtSlot.setDescription('Slot Number.')
frEndPtLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtLine.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtLine.setDescription('Line Number. If no line number is associated with the end point then this value is 0.')
frEndPtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtPort.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtPort.setDescription('Port Number. ')
frEndPtDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtDlci.setDescription('DLCI.')
frEndPtConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndPtConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtConnIndex.setDescription('If the value of this object is greater than 0 then it is the index identifying the associated connectionEntry. Value 0 indicates dangling end point.')
frEndPtAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtAdminStatus.setDescription(' Administrative status of the end point.')
frEndPtOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 16))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4), ("alarm", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndPtOpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtOpStatus.setDescription(" Operational Status of the end point. The value 'alarm' may only occur with and end point whose frEndPtCardType = 'frsm'. When frEndPtOpStatus has the value 'alarm' then either the slot, the line, or the port containing this endpoint has an alarm.")
frEndPtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtRowStatus.setDescription("The manager must set this to 'createAndGo' when creating a new entry. Other end point parameters also can be set in the same request. 'destroy' is only supported when the end point is not part of an end to end connection. setting the value to active will result in bad value.")
frEndPtMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtMIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in bits per second) for this end-point. This object has the relationship MIR <= CIR. This attribute can only be set to values evenly divisable by 100.')
frEndPtCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtCIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in bits per second) for this end-point. This object holds the relationship MIR < = CIR <= QIR. This attribute can only be set to values evenly divisable by 100.')
frEndPtBc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtBc.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtBc.setDescription("The value of this object is equal to the committed burst size (Bc) parameter (in bytes) for this end-point. When frEndPtCardType is 'fr', this attribute is calculated as follows and should NOT be set: Bc = (VcQSize/(1 - MIR/port access rate)). When frEndPtCardType is 'frsm' the value is NOT calculated and is assigned the default value unless it is set.")
frEndPtBe = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtBe.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtBe.setDescription("The value of this object is equal to the excess burst size (Be) parameter (in bytes) for this end-point. When frEndPtCardType is 'fr', this attribute is calculated as follows and should NOT be set: Be = Bc * (PIR/MIR - 1) When frEndPtCardType is 'frsm' the value is NOT calculated and is assigned the default value unless it is set.")
frEndPtVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point.')
frEndPtPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtPIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in bits per second) for this end-point. This attribute can only be set to values evenly divisable by 100.')
frEndPtCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtCMAX.setDescription('The maximum credits that can be accrued for this end-point. This is not applicable for AXIS-frsm channels.')
frEndPtEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is specified in bytes. When the frEndPtVcQSize value exceeds this value then the FECN bit will be set in all frames transmitted to the remote end-point.")
frEndPtQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtQIR.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in bits per second) for this end-point. This value has the relationship CIR <= QIR <= PIR. This attribute can only be set to values evenly divisable by 100.')
frEndPtPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
frEndPtPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2))).clone('low')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtPriority.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtPriority.setDescription("Priority for the Egress End. The value of this object determines the priority that is given to the data carried by this . If set to low, then the data is given the standard priority, and if set to high, the data will be given a higher priority. Higher priority data is placed at the beginning of the port's queues. NOTE: For a single segment connection(IPX-Routing to IPX-Routing), SET on frEndPtPriority is allowed for the local endpt only. i.e., SET on frEndPtPriority on the remote endpt is ignored. frEndPtPriority for the remote endpt gets the same value as that of the local endpt. This is not applicable for AXIS-frsm channels.")
frEndPtInitialBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtInitialBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtInitialBurstSize.setDescription("Initial burst size in bytes. Note that InitialBurstSize should be less than or equal to Bc. This is valid for frEndPtType of 'frsm'.")
frEndPtDeTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtDeTagging.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtDeTagging.setDescription("Enable/disable DE tagging in the ingress direction only. This is valid for frEndPtType of 'frsm'.")
frEndPtIngressDeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtIngressDeThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtIngressDeThreshold.setDescription("Ingress threshold at which deletion occurs based on DE. This is valid for frEndPtType of 'frsm'.")
frEndPtEgressQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtEgressQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEgressQDepth.setDescription("Egress Q Depth. This is valid for frEndPtType of 'frsm'.")
frEndPtEgressDeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtEgressDeThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEgressDeThreshold.setDescription("Egress threshold at which deletion occurs based on DE. This is valid for frEndPtType of 'frsm'.")
frEndPtEgressEcnThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtEgressEcnThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEgressEcnThreshold.setDescription("ECN threshold. This is valid for frEndPtType of 'frsm'.")
frEndPtEgressQSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("highPriority", 1), ("lowPriority", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtEgressQSelect.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtEgressQSelect.setDescription("Selects one out of two possible port queues. The default port queue number is 2 which is the low priority queue. This is only valid for frEndPtType of 'frsm'.")
frEndPtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndPtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtLpbkState.setDescription('The state of loopback mode for the end point. This is a bit mapped integer with the values defined as follows: local 1 remote 2 port 4 csu 8 dsu 16 external 32 testcon 64 ')
frEndPtType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cdpSdpCard", 1), ("fr", 2), ("ait", 3), ("frsm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frEndPtType.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtType.setDescription("Identifies a type of fr end point which some attributes may not apply. In particular the attributes frEndPtInitialBurstSize, frEndPtDeTagging frEndPtIngressDeThreshold, frEndPtEgressQDepth, frEndPtEgressDeThreshold, frEndPtEgressEcnThreshold and frEndPtEgressQSelect are valid only when frEndptType has the value 'frsm'. ")
frEndPtchanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("frNIW", 1), ("frSIW-transparent", 2), ("frSIW-translate", 3), ("frFUNI", 4))).clone('frNIW')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtchanType.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtchanType.setDescription("(1) is frame-relay network interworking, (2) is service interworking with out any SDU translation, (3) is service interworking with SDU translation, and (4) is frame-relay UNI. This is only valid for frEndPtType of 'frsm'. Another restriction is that the other endpt should be an ASI(atmEndPtTable) endpt. If the other endpt is a FR endpt the DEFVAL will over-write the user's input.")
frEndPtchanFECNconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mapEFCI", 1), ("setEFCIzero", 2))).clone('setEFCIzero')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtchanFECNconfig.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtchanFECNconfig.setDescription("The FECN bits in frame-relay are mapped to EFCI bit in the ATM cells. mapEFCI is valid only for SIW. This is only valid for frEndPtType of 'frsm'. Another restriction is that the other endpt should be an ASI(atmEndPtTable) endpt. If the other endpt is a FR endpt the DEFVAL will over-write the user's input.")
frEndPtchanDEtoCLPmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mapCLP", 1), ("setCLPzero", 2), ("setCLPone", 3))).clone('mapCLP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtchanDEtoCLPmap.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtchanDEtoCLPmap.setDescription("For (1), The DE bit is mapped to CLP bit in ATM cell. For (2) and (3), the DE bit is ignored and CLP bit is set to the constant value. This is only valid for frEndPtType of 'frsm'. Another restriction is that the other endpt should be an ASI(atmEndPtTable) endpt. If the other endpt is a FR endpt the DEFVAL will over-write the user's input.")
frEndPtchanCLPtoDEmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mapDE", 1), ("setDEzero", 2), ("setDEone", 3), ("ignoreCLP", 4))).clone('mapDE')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frEndPtchanCLPtoDEmap.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtchanCLPtoDEmap.setDescription("Values (1), (2) and (3) are valid for SIW. Values (1) and (4) are valid for NIW. For (1), the CLP bit is mapped to DE bit in frame-relay. For (2) and (3), the CLP bit is ignored and DE bit is set to the constant value. ignoreCLP ignores CLP bit and DE bit remains as received. This is only valid for frEndPtType of 'frsm'. Another restriction is that the other endpt should be an ASI(atmEndPtTable) endpt. If the other endpt is a FR endpt the DEFVAL will over-write the user's input.")
aitEndPtTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 5), )
if mibBuilder.loadTexts: aitEndPtTable.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtTable.setDescription('A List of frame relay virtual circuit end points')
aitEndPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 5, 1), ).setIndexNames((0, "STRATACOM-MIB", "aitEndPtNodeName"), (0, "STRATACOM-MIB", "aitEndPtIfShelf"), (0, "STRATACOM-MIB", "aitEndPtSlot"), (0, "STRATACOM-MIB", "aitEndPtVpi"), (0, "STRATACOM-MIB", "aitEndPtVci"))
if mibBuilder.loadTexts: aitEndPtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtEntry.setDescription('A frame relay end point Entry')
aitEndPtNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtNodeName.setDescription('The node name.')
aitEndPtIfShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtIfShelf.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtIfShelf.setDescription('String identifying the shelf. This is a null string for end points which do not have a shelf name.')
aitEndPtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtSlot.setDescription('Slot Number.')
aitEndPtVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtVpi.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtVpi.setDescription('VPI. ')
aitEndPtVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtVci.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtVci.setDescription('VCI.')
aitEndPtConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtConnIndex.setDescription('If the value of this object is greater than 0 then it is the index identifying the associated connectionEntry.')
aitEndPtAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtAdminStatus.setDescription(' Administrative status of the end point.')
aitEndPtOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtOpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtOpStatus.setDescription(' Operational Status of the end point.')
aitEndPtMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtMIR.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in bits per second) for this end-point. This object has the relationship MIR <= CIR. This attribute can only be set to values evenly divisable by 100.')
aitEndPtCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtCIR.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in bits per second) for this end-point. This object holds the relationship MIR < = CIR <= QIR. This attribute can only be set to values evenly divisable by 100.')
aitEndPtVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtVcQSize.setDescription('The value of this object is the maximum queue depth (in bytes) for this end-point. This object is required before row creation is complete.')
aitEndPtPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtPIR.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in bits per second) for this end-point. This attribute can only be set to values evenly divisable by 100.')
aitEndPtCMAX = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtCMAX.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtCMAX.setDescription('The maximum credits that can be accrued for this end-point. This object is required before row creation is complete.')
aitEndPtEcnQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtEcnQSize.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtEcnQSize.setDescription("The threshold setting used by the explicit congestion notification feature for this end-point's transmit queue. This value is specified in bytes. When the aitEndPtVcQSize value exceeds this value then the FECN bit will be set in all frames transmitted to the remote end-point. This object is required before row creation is complete.")
aitEndPtQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtQIR.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in bits per second) for this end-point. This value has the relationship CIR <= QIR <= PIR. This attribute can only be set to values evenly divisable by 100. ')
aitEndPtPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point. This object is required before row creation is complete.')
aitEndPtPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aitEndPtPriority.setStatus('mandatory')
if mibBuilder.loadTexts: aitEndPtPriority.setDescription('connection priority.')
atmEndPtTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 6), )
if mibBuilder.loadTexts: atmEndPtTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtTable.setDescription('The ATM End-Point table. This table is used to model a PVC end-point. This table contains the traffic parameters for ATM end-point.')
atmEndPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 6, 1), ).setIndexNames((0, "STRATACOM-MIB", "atmEndPtNodeName"), (0, "STRATACOM-MIB", "atmEndPtIfShelf"), (0, "STRATACOM-MIB", "atmEndPtSlot"), (0, "STRATACOM-MIB", "atmEndPtPort"), (0, "STRATACOM-MIB", "atmEndPtVpi"), (0, "STRATACOM-MIB", "atmEndPtVci"))
if mibBuilder.loadTexts: atmEndPtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtEntry.setDescription('An entry in the ATM End-point table.')
atmEndPtNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtNodeName.setDescription('Node name of this endpoint.')
atmEndPtIfShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtIfShelf.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtIfShelf.setDescription('Shelf name of this endpoint. If no shelf name than this value is a NULL string.')
atmEndPtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtSlot.setDescription('Local Slot Number.')
atmEndPtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtPort.setDescription('Local Port Number. These are numbered starting at 1.')
atmEndPtVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtVpi.setDescription('Virtual port index.')
atmEndPtVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtVci.setDescription('virtual channel index.')
atmEndPtConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndPtConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtConnIndex.setDescription('If the value of this object is greater than 0 then it is the index identifying the associated connectionEntry.')
atmEndPtAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("testing", 3))).clone('inactive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtAdminStatus.setDescription('Admin Status of the end point.')
atmEndPtOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("clear", 2), ("fail", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndPtOpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtOpStatus.setDescription('Operational Status of the end point.')
atmEndPtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtRowStatus.setDescription("The manager must set this to 'createAndGo' when creating a new entry. Other required elements can also be set in the same SET request")
atmEndPtMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtMIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtMIR.setDescription('The minimum transmit bandwidth (MIR) parameter (in bits per second) for this end-point. For ATF without Foresight connections this object corresponds to the Peak Cell Rate(PCR) defined by ATM standard documents. For ATF with Foresight connections this object corresponds to the Minimum Cell Rate (MCR). (in bits per second) for this end-point. The maximum value for this object is the port speed of the associated interface.')
atmEndPtCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 353208)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtCIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (in bits per second) for this end-point. This object corresponds to the Sustainable Cell Rate(SCR) defined by ATM standard documents. The maximum value for this object is the port speed of the associated interface. All values between minimum and maximum for a given interface will be accepted, but they will be internally rounded up to the closest higher value valid for that interface.')
atmEndPtPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 353208)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtPIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtPIR.setDescription('The peak transmit bandwidth (PIR) parameter (in bits per second) for this end-point. This object applies only to Foresight connections and corresponds to the Peak Cell Rate (PCR) defined by ATM standard documents. The maximum value for this object is the port speed of the associated interface.')
atmEndPtQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 96000)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtQIR.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtQIR.setDescription('The transmit quiescent information rate (QIR) parameter (in bits per second) for this end-point. This parameter applies only to Foresight connections, and corresponds to the Initial Cell Rate (ICR) defined by ATM standard documents. This value can range between the MIR and PIR values.')
atmEndPtPercUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtPercUtil.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtPercUtil.setDescription('The value of this object is equal to the channel percentage utilization setting for this end-point. This is the expected long-term utilization of the channel by this end-point.')
atmEndPtPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmEndPtPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtPriority.setDescription('queueing priority.')
atmEndPtIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtIBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtIBS.setDescription('The value of this object is equal to the Initial Burst Size in cells for the other end-point. The maximum value for this object on OC3 end points is 1000.')
atmEndPtVcQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmEndPtVcQSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmEndPtVcQSize.setDescription('The value of this object is the maximum queue depth (in cells) for this end-point. For ATF without Foresight connections this object corresponds to the maximum Cell Delay Variation (CDV) Tolerance measured in cells.')
segmentTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 7), )
if mibBuilder.loadTexts: segmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: segmentTable.setDescription('A List of Connection Entries')
segmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 7, 1), ).setIndexNames((0, "STRATACOM-MIB", "segEndPtTableId"), (0, "STRATACOM-MIB", "segNodeName"), (0, "STRATACOM-MIB", "segShelf"), (0, "STRATACOM-MIB", "segSlot"), (0, "STRATACOM-MIB", "segLine"), (0, "STRATACOM-MIB", "segPort"), (0, "STRATACOM-MIB", "segSubChn1"), (0, "STRATACOM-MIB", "segSubChn2"))
if mibBuilder.loadTexts: segmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: segmentEntry.setDescription('A generic end point Entry')
segEndPtTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frEndPtTable", 1), ("atmEndptTable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segEndPtTableId.setStatus('mandatory')
if mibBuilder.loadTexts: segEndPtTableId.setDescription('The end point table from which the remaining indices are obtained.')
segNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: segNodeName.setDescription('The node name.')
segShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segShelf.setStatus('mandatory')
if mibBuilder.loadTexts: segShelf.setDescription('String identifying the shelf. This is a null string for end points which do not have a shelf name.')
segSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segSlot.setStatus('mandatory')
if mibBuilder.loadTexts: segSlot.setDescription('Slot Number.')
segLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segLine.setStatus('mandatory')
if mibBuilder.loadTexts: segLine.setDescription('Line Number. If no line number is associated with the end point then this value is 0.')
segPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segPort.setStatus('mandatory')
if mibBuilder.loadTexts: segPort.setDescription('Port Number. ')
segSubChn1 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segSubChn1.setStatus('mandatory')
if mibBuilder.loadTexts: segSubChn1.setDescription("The meaning of this attribute is dependant on the value of segTableId. For 'frEndPtTable(1)' this value is the end point DLCI otherwise it is the end point VPI")
segSubChn2 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segSubChn2.setStatus('mandatory')
if mibBuilder.loadTexts: segSubChn2.setDescription('If the value of this attribute is 0, then it has no meaning in identifying the end point. If the value of this attribute is greater than 0 the it identifies the end point VCI.')
segOeEndPt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segOeEndPt.setStatus('mandatory')
if mibBuilder.loadTexts: segOeEndPt.setDescription("The object id of the first attribute in the protocol specific end point table which is the 'remote' end point of the segment. If there is no remote end point then this attribute has the value of the NULL object identifier {0 0}.")
segConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: segConnIndex.setDescription('The connectionIndex value identifying the end to end connection of which this segment is a part. If this value is 0, then the segment is not a part of any end to end connection.')
segNextSeg = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 7, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segNextSeg.setStatus('mandatory')
if mibBuilder.loadTexts: segNextSeg.setDescription("The object id of the first attribute in the protocol specific end point table which is the 'local' end point of the next segment of the end to end connection identified by segConnIndex. A value of {0 0}, the NULL object identifier, indicates there is no next segment.")
cmpaErrorLastIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorLastIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorLastIndex.setDescription('If at least one entry exists in the error status table, the value of this object contains the index corresponding to the last entry inserted in the table. If no entries have ever been inserted in the cmpaErrorTable, then the agent will return 0 for a query of this variable. Actually this object is not required any more because of the new objects cmpaErrorLastDesc and cmpaErrorLastEcode. One can do GET directly on cmpaErrorLastDesc/LastEcode.')
cmpaErrorFlushAll = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("flush", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmpaErrorFlushAll.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorFlushAll.setDescription("Setting this object to the value 'flush' indicates to the agent that a manager would like the cmpaErrorTable to be immediately flushed of all entries. A management retrieval of this object will always return the value 'noOp'. Setting this object to the value 'noOp' is invalid.")
cmpaErrorTable = MibTable((1, 3, 6, 1, 4, 1, 351, 3, 10), )
if mibBuilder.loadTexts: cmpaErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorTable.setDescription('A List of recent Errors reported by the Ports Proxy Agent (PPA).')
cmpaErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 3, 10, 1), ).setIndexNames((0, "STRATACOM-MIB", "cmpaErrorReqId"))
if mibBuilder.loadTexts: cmpaErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorEntry.setDescription('A General Error Status Entry.')
cmpaErrorReqId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorReqId.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorReqId.setDescription('This object contains the PDU request ID associated with the SET request. The manager must use this information to find the error associated with a particular SNMP request. Note that an SNMP request ID may be reused by the same manager. When this occurs, the older entry in the table will be replaced with the new error status. Managers must be aware that error information may therefore be lost.')
cmpaErrorDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorDesc.setDescription('This object contains error status information for failed SETS to one or more objects in one or more of the following tables: frPortsCfgTable Rows in this table may be created as the result of a failed SNMP SET operation. Since the SNMP standard allows only limited number of error result codes, the managers can retrieve this variable to get additional information on a failed SET operation. Typically this object will contain a user friendly description of the cause of the error.')
cmpaErrorEcode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 500, 501, 502))).clone(namedValues=NamedValues(("invalid-network", 1), ("invalid-node", 2), ("invalid-shelf", 3), ("invalid-release", 4), ("node-timeout", 5), ("node-busy", 6), ("no-snmpcomm", 7), ("snmpcomm-error", 8), ("node-error", 9), ("bad-value", 10), ("port-not-found", 11), ("slot-is-full", 12), ("conn-not-found", 100), ("endpt-exists", 101), ("lendpt-exists", 102), ("rendpt-exists", 103), ("lendpt-missing", 104), ("rendpt-missing", 105), ("db-lendpt-not-found", 106), ("db-rendpt-not-found", 107), ("lendpt-not-found", 108), ("rendpt-not-found", 109), ("dangling-endpt", 110), ("endpt-rowstatus-missing", 111), ("conn-rowstatus-missing", 112), ("invalid-endpt-rowstatus", 113), ("invalid-conn-rowstatus", 114), ("invalid-connindex", 115), ("testtype-missing", 116), ("partial-add", 117), ("partial-mod", 118), ("invalid-bw", 119), ("not-active", 120), ("invalid-adminstatus", 121), ("not-clear", 122), ("invalid-endpt-comb", 123), ("invalid-chantype", 124), ("cmgrd-timeout", 125), ("no-cmgrd", 126), ("ronly-for-frp", 127), ("invalid-chanFECNconfig", 128), ("invalid-chanCLPtoDEmap", 129), ("ibs-less-bc", 130), ("asi-no-remote", 131), ("frsm-remote", 132), ("foresight-disabled", 133), ("no-error-entry", 500), ("not-applicable", 501), ("invalid-flushall", 502)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorEcode.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorEcode.setDescription('This object contains the error Code of the GET/SET operation. The error Codes from 500 onwards are specific to the Error Table operation itself. Note that currently GET errors are not updated in the error table.')
cmpaErrorLastDesc = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorLastDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorLastDesc.setDescription('This contains the error description of the last error generated. If error table contains no errors, GET on this will return NULL string')
cmpaErrorLastEcode = MibScalar((1, 3, 6, 1, 4, 1, 351, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 500, 501, 502))).clone(namedValues=NamedValues(("invalid-network", 1), ("invalid-node", 2), ("invalid-shelf", 3), ("invalid-release", 4), ("node-timeout", 5), ("node-busy", 6), ("no-snmpcomm", 7), ("snmpcomm-error", 8), ("node-error", 9), ("bad-value", 10), ("port-not-found", 11), ("slot-is-full", 12), ("conn-not-found", 100), ("endpt-exists", 101), ("lendpt-exists", 102), ("rendpt-exists", 103), ("lendpt-missing", 104), ("rendpt-missing", 105), ("db-lendpt-not-found", 106), ("db-rendpt-not-found", 107), ("lendpt-not-found", 108), ("rendpt-not-found", 109), ("dangling-endpt", 110), ("endpt-rowstatus-missing", 111), ("conn-rowstatus-missing", 112), ("invalid-endpt-rowstatus", 113), ("invalid-conn-rowstatus", 114), ("invalid-connindex", 115), ("testtype-missing", 116), ("partial-add", 117), ("partial-mod", 118), ("invalid-bw", 119), ("not-active", 120), ("invalid-adminstatus", 121), ("not-clear", 122), ("invalid-endpt-comb", 123), ("invalid-chantype", 124), ("cmgrd-timeout", 125), ("no-cmgrd", 126), ("ronly-for-frp", 127), ("invalid-chanFECNconfig", 128), ("invalid-chanCLPtoDEmap", 129), ("ibs-less-bc", 130), ("asi-no-remote", 131), ("frsm-remote", 132), ("foresight-disabled", 133), ("no-error-entry", 500), ("not-applicable", 501), ("invalid-flushall", 502)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmpaErrorLastEcode.setStatus('mandatory')
if mibBuilder.loadTexts: cmpaErrorLastEcode.setDescription('This contains the error code of the last error generated. If error table contains no errors, GET on this object returns 500')
portsInfoTable = MibTable((1, 3, 6, 1, 4, 1, 351, 4, 1), )
if mibBuilder.loadTexts: portsInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoTable.setDescription('Ports information for the specified line')
portsInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 4, 1, 1), ).setIndexNames((0, "STRATACOM-MIB", "portsInfoNode"), (0, "STRATACOM-MIB", "portsInfoShelf"), (0, "STRATACOM-MIB", "portsInfoSlot"), (0, "STRATACOM-MIB", "portsInfoLine"), (0, "STRATACOM-MIB", "portsInfoPort"))
if mibBuilder.loadTexts: portsInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoEntry.setDescription('Ports Information Entry')
portsInfoNode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoNode.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoNode.setDescription('String identifying the node')
portsInfoShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoShelf.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoShelf.setDescription('String identifying the shelf')
portsInfoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoSlot.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoSlot.setDescription('Slot Number')
portsInfoLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoLine.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoLine.setDescription('Line Number. For IPX ports Line Number is always 0')
portsInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoPort.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoPort.setDescription('Port Number')
portsInfoPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("frsm", 1), ("frp", 2), ("ausm", 3), ("atm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoPortType.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoPortType.setDescription('Port type includes Card type as well as Interface type')
portsInfoPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("remoteLoopback", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoPortState.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoPortState.setDescription('Port state')
portsInfoPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsInfoPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portsInfoPortSpeed.setDescription('Configured speed of port in kbps')
frPortsCfgTable = MibTable((1, 3, 6, 1, 4, 1, 351, 4, 2), )
if mibBuilder.loadTexts: frPortsCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgTable.setDescription('fr ports updations for AXIS and IPX.')
frPortsCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 4, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "frPortsCfgNode"), (0, "STRATACOM-MIB", "frPortsCfgShelf"), (0, "STRATACOM-MIB", "frPortsCfgSlot"), (0, "STRATACOM-MIB", "frPortsCfgLine"), (0, "STRATACOM-MIB", "frPortsCfgPort"))
if mibBuilder.loadTexts: frPortsCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgEntry.setDescription('Ports Cfgrmation Entry')
frPortsCfgNode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgNode.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgNode.setDescription('String identifying the Node')
frPortsCfgShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgShelf.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgShelf.setDescription('String identifying the shelf')
frPortsCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgSlot.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgSlot.setDescription('Slot Number')
frPortsCfgLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgLine.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgLine.setDescription('Line Number. For IPX ports Line Number is always 0')
frPortsCfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPort.setDescription('Port Number')
frPortsCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("modify", 3), ("up-frp", 4), ("down-frp", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgRowStatus.setDescription('add, del & modify are for both AXIS and IPX ports, but up and down are for IPX only')
frPortsCfgPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frsm", 1), ("frp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgPortType.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPortType.setDescription('Card type, FRP or FRSM')
frPortsCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("remoteLoopback", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPortState.setDescription('PortState')
frPortsCfgChCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgChCnt.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgChCnt.setDescription('The number of aggregate channels assigned to this port (FRI T1/E1 interface only). For subrate ports, this object is always 1.')
frPortsCfgPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPortSpeed.setDescription('Configured speed of port in kbps. - Set operation: For subrate(V.35) interface only. For E1/T1, you can set only while adding the port')
frPortsCfgDs0ChSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s56k", 1), ("s64k", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgDs0ChSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgDs0ChSpeed.setDescription('channel speed. This is not applicable for FRP-V35 subrate ports. Set operation: - Allowed only while adding the port.')
frPortsCfgSigProt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("lmi-noasyn", 2), ("lmi-asyn", 3), ("uni-annexA", 4), ("uni-annexD", 5), ("nni-annexA", 6), ("nni-annexD", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgSigProt.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgSigProt.setDescription('The specified LMI operation mode. The options can be 1 - (UNI)LMI disabled 2 - (UNI)LMI enabled but asynchronous update disabled 3 - (UNI)LMI and asynchronous update enabled 4 - (UNI)LMI enabled using CCITT O.933 Annex A parameters 5 - (UNI)LMI enabled using ANSI T1.617 parameters 6 - (NNI)LMI enabled using CCITT O.933 Annex A parameters 7 - (NNI)LMI enabled using ANSI T1.617 parameters')
frPortsCfgNNIStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgNNIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgNNIStatus.setDescription('The flag indicating whether NNI is active on the specified slot.port. - Get Operation: This object is always NO if the network manager attempts to GET frLportNNIStatus from a disabled or LMI port. In other cases, the value of this object is determined by whether the port is configured as NNI or not.')
frPortsCfgAsyncUpd = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgAsyncUpd.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgAsyncUpd.setDescription('The flag indicating whether the IPX should send unsolicited LMI update messages as they appear or wait for the polling from the user device. This object is applicable to only Annex A/D UNI and Annex A/D NNI protocols for write and LMI, Annex A/D UNI and Annex A/D NNI for read. - Get Operation: This object is always NO for ports without protocols; otherwise, its value is determined by the asynchronous status of the port. - Set Operation: If the network manager attempts to SET this object of a port with none or LMI protocol, an error is reported.')
frPortsCfgPollVerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 15), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgPollVerTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPollVerTimer.setDescription('The link integrity verification timer heartbeat (keep-alive) period. It should be set to 5 seconds more than the heartbeat time in the user device. The valid range is (5..30) - Get Operation: Since this object is not applicable to disabled protocol, (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frPortsCfgErrThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgErrThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgErrThresh.setDescription('The number of the failures in the monitored events that cause the keep-alive process to report an alarm. The valid range is (1..10). - Get Operation: Since this object is not applicable to disabled protocol, (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frPortsCfgMonEveCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgMonEveCnt.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgMonEveCnt.setDescription('The number of monitored events for the keep-alive process. A port communication fail condition is cleared after this number of successful polling cycles. The valid range is (1..10) - Get Operation: Since this object is not applicable to disabled protocol, (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported.')
frPortsCfgFrmFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 18), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgFrmFlags.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgFrmFlags.setDescription('The minimum number of flags between frames. The valid range for AXIS-FRSM ports is (1..10) The valid range for IPX-FRP ports is (1..255)')
frPortsCfgLinkTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 19), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgLinkTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgLinkTimer.setDescription('T391 - Link Integrity Timer (applicable to NNI port only), indicating the interval at which a Status Enquiry message is sent. The valid range is (5..30) - Get Operation: the network manager attempts to GET this object from a port with a protocol other than NNIs, (-1) is returned. - Set Operation: If the network manager attempts to SET this object of a port with a protocol other than NNIs, an error is reported')
frPortsCfgPollCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frPortsCfgPollCycle.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgPollCycle.setDescription('N391 - Full Status Polling Cycle. Applicable to NNI ports only in case of IPX frp. - Get Operation(for IPX-frp): If the network manager attempts to GET this object from a port with a protocol other than NNIs, (-1) is returned. - Set Operation(for IPX-frp): If the network manager attempts to SET this object of a port with a protocol other than NNIs, an error is reported.')
frAxPortsCfgSvcRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 21), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frAxPortsCfgSvcRatio.setStatus('mandatory')
if mibBuilder.loadTexts: frAxPortsCfgSvcRatio.setDescription('Number of times queue 2 is serviced for every time queue 3 is serviced The valid range is (1..15). Only applicable to AXIS-FRSM ports. The value (-2) will be returned for IPX-FRP ports.')
frIxPortsCfgClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("looped", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgClockType.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgClockType.setDescription('The type of port clock (FRI subrate interface only). For T1/E1 interface this object should be none. - Get Operation: If the network manager attempts to get this object from a T1/E1 port, none(3) is returned. - Set Operation: If the network manager attempts to set this object on a T1/E1 port an error is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgVcCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgVcCount.setDescription('The number of virtual connections that terminate on this port. Note that there can be up to 252 connections per FRP cards shared among the ports. A port may have up to 252 connections allocated. The valid range is (0..252). Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frPortsCfgVcPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 24), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsCfgVcPtr.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsCfgVcPtr.setDescription('The object identifier denoting the first endpoint associated with this port. For current implementation, this OID points to the first frame relay connection on the port. It has a NULL OID value (i.e. { 0 0 }) if there is no frame relay connection on this port. The management station can retrieve all the information about the first connection by reading from row pointed to by this OID. Specifically, this OID specifies the first column of the appropriate row in the frEndptTable.')
frIxPortsCfgMaxTxQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 25), Integer32().clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgMaxTxQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgMaxTxQDepth.setDescription('The maximum bytes queued for transmission from the FRP port. The valid range is (0..65535). Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgECNQThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 26), Integer32().clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgECNQThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgECNQThresh.setDescription('Port explicit congestion notification threshold. This is the point at which the BECN and FECN bits will be set in the communications to the user device. The valid range is (0..65535). Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 27), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgDEThresh.setDescription('The percentage of the queue depth above which frames with the Discard Eligibility bit set will be discarded. An entry of 100% effectively disables DE for the port. The valid range is (0..100) Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgIDEMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgIDEMap.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgIDEMap.setDescription('The flag indicating whether IDE to DE mapping should be performed. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgCommPri = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgCommPri.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgCommPri.setDescription('The flag specifying if the connection SNA priority should be communicated to the user device attached to the port. - Get Operation: Since this object is specific to LMI protocols, (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgUpRNR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 30), Integer32().clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgUpRNR.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgUpRNR.setDescription('The upper Receiver-Not-Ready threshold. This threshold specifies the number of receiver not ready indications from the user equipment before an alarm is generated for this connection. The valid range is (1..100) - Get Operation: Since this object is specific to LMI protocols, (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgLowRNR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 31), Integer32().clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgLowRNR.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgLowRNR.setDescription('The Lower Receiver-Not-Ready threshold. This threshold specifies the number of receiver not ready indications from the user equipment before an alarm is cleared for this connection. The valid range is (1..100) - Get Operation: Since this object is specific to LMI protocols, (-1) is returned if the network manager attempts to GET this object from a non-LMI port. - Set Operation: Likewise, if the network manager attempts to SET this object of a non-LMI port, an error is reported. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgOamThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgOamThresh.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgOamThresh.setDescription('The alarm threshold for number of OAM heartbeat FastPackets missed before propagating A-bit=0. This threshold is applicable to both UNI and NNI Frame Relay ports when the node has FR NNI feature enabled and this FRP firmware supports it. The valid range is (0..15). - Get Operation: Since this object is not applicable to disabled protocol, (-1) is returned if the network manager attempts to GET this object from a port without protocols. - Set Operation: If the network manager attempts to SET this object of a port without any protocol, an error is reported. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgCLLMTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgCLLMTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgCLLMTimer.setDescription('The timer for CLLM messages in CLLM intervals. No CLLM if 0 is configured. If a user configures this value to be greater than 0 then it should be in the range 4 to 35. The unit is hundredth of a sec. Note that ForeSight (CLLM) is available only if the firmware supports it. - Get Operation: If the network manager attempts to GET this object from a port where ForeSight is not supported, (-1) is returned. - Set Operation: If the network manager attempts to SET this object of a port where ForeSight is not supported, an error is reported. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgEFCItoBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frIxPortsCfgEFCItoBECN.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgEFCItoBECN.setDescription('This object indicates whether EFCI to BECN mapping is enabled. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgSrRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgSrRTS.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgSrRTS.setDescription('The current status of the RTS lead (subrated FRI only). none is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DTE. Otherwise, none(3) is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgSrDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgSrDTR.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgSrDTR.setDescription('The current status of the DTR lead (subrated FRI only). none is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DTE. Otherwise, none(3) is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgSrDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgSrDCD.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgSrDCD.setDescription('The current status of the DCD lead (subrated FRI only). none is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, none(3) is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgSrCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgSrCTS.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgSrCTS.setDescription('The current status of the CTS lead (subrated FRI only). none is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, none(3) is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgSrDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgSrDSR.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgSrDSR.setDescription('The current status of the DSR lead (subrated FRI only). none is used for T1/E1 FRI. - Get Operation: This object is valid only if the port is subrated and DCE. Otherwise, none(3) is returned. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgLoopBack = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("local", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgLoopBack.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgLoopBack.setDescription('The loopback mode. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frIxPortsCfgExtConFail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frIxPortsCfgExtConFail.setStatus('mandatory')
if mibBuilder.loadTexts: frIxPortsCfgExtConFail.setDescription('The flag indicating if the connection with the external device is lost. Only applicable to IPX-FRP ports. The value (-2) will be returned for AXIS-FRSM ports.')
frAxPortsCfgLogPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 2, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAxPortsCfgLogPort.setStatus('mandatory')
if mibBuilder.loadTexts: frAxPortsCfgLogPort.setDescription('Logical port for the given physical port. Only applicable to AXIS-FRSM ports. The value (-2) will be returned for IPX-FRP ports.')
ppaErrorLastIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorLastIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorLastIndex.setDescription('If at least one entry exists in the error status table, the value of this object contains the index corresponding to the last entry inserted in the table. If no entries have ever been inserted in the ppaErrorTable, then the agent will return 0 for a query of this variable. Actually this object is not required any more because of the new objects ppaErrorLastDesc and ppaErrorLastEcode. One can do GET directly on ppaErrorLastDesc/LastEcode.')
ppaErrorFlushAll = MibScalar((1, 3, 6, 1, 4, 1, 351, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("flush", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppaErrorFlushAll.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorFlushAll.setDescription("Setting this object to the value 'flush' indicates to the agent that a manager would like the ppaErrorTable to be immediately flushed of all entries. A management retrieval of this object will always return the value 'noOp'. Setting this object to the value 'noOp' is invalid.")
ppaErrorTable = MibTable((1, 3, 6, 1, 4, 1, 351, 4, 10), )
if mibBuilder.loadTexts: ppaErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorTable.setDescription('A List of recent Errors reported by the Ports Proxy Agent (PPA).')
ppaErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 4, 10, 1), ).setIndexNames((0, "STRATACOM-MIB", "ppaErrorReqId"))
if mibBuilder.loadTexts: ppaErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorEntry.setDescription('A General Error Status Entry.')
ppaErrorReqId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorReqId.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorReqId.setDescription('This object contains the PDU request ID associated with the SET request. The manager must use this information to find the error associated with a particular SNMP request. Note that an SNMP request ID may be reused by the same manager. When this occurs, the older entry in the table will be replaced with the new error status. Managers must be aware that error information may therefore be lost.')
ppaErrorDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorDesc.setDescription('This object contains error status information for failed SETS to one or more objects in one or more of the following tables: frPortsCfgTable Rows in this table may be created as the result of a failed SNMP SET operation. Since the SNMP standard allows only limited number of error result codes, the managers can retrieve this variable to get additional information on a failed SET operation. Typically this object will contain a user friendly description of the cause of the error.')
ppaErrorEcode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 500, 501, 502))).clone(namedValues=NamedValues(("invalid-network", 1), ("invalid-node", 2), ("invalid-shelf", 3), ("invalid-release", 4), ("node-timeout", 5), ("node-busy", 6), ("no-snmpcomm", 7), ("snmpcomm-error", 8), ("node-error", 9), ("bad-value", 10), ("port-not-found", 11), ("slot-is-full", 12), ("rowstatus-missing", 100), ("port-exists", 101), ("invalid-slot", 102), ("invalid-line", 103), ("line-is-full", 104), ("multiple-ports", 105), ("port-reserved", 106), ("na-frsm", 107), ("na-frp", 108), ("no-up-down-frsm", 109), ("invalid-set", 110), ("illegal-set", 111), ("partial-add", 112), ("no-error-entry", 500), ("not-applicable", 501), ("invalid-flushall", 502)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorEcode.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorEcode.setDescription('This object contains the error Code of the GET/SET operation. The error Codes from 500 onwards are specific to the Error Table operation itself. Note that currently GET errors are not updated in the error table.')
ppaErrorLastDesc = MibScalar((1, 3, 6, 1, 4, 1, 351, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorLastDesc.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorLastDesc.setDescription('This contains the error description of the last error generated. If error table contains no errors, GET on this will return NULL string')
ppaErrorLastEcode = MibScalar((1, 3, 6, 1, 4, 1, 351, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 500, 501, 502))).clone(namedValues=NamedValues(("invalid-network", 1), ("invalid-node", 2), ("invalid-shelf", 3), ("invalid-release", 4), ("node-timeout", 5), ("node-busy", 6), ("no-snmpcomm", 7), ("snmpcomm-error", 8), ("node-error", 9), ("bad-value", 10), ("port-not-found", 11), ("slot-is-full", 12), ("rowstatus-missing", 100), ("port-exists", 101), ("invalid-slot", 102), ("invalid-line", 103), ("line-is-full", 104), ("multiple-ports", 105), ("port-reserved", 106), ("na-frsm", 107), ("na-frp", 108), ("no-up-down-frsm", 109), ("invalid-set", 110), ("illegal-set", 111), ("partial-add", 112), ("no-error-entry", 500), ("not-applicable", 501), ("invalid-flushall", 502)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppaErrorLastEcode.setStatus('mandatory')
if mibBuilder.loadTexts: ppaErrorLastEcode.setDescription('This contains the error code of the last error generated. If error table contains no errors, GET on this object returns 500')
userConnCleared = NotificationType((1, 3, 6, 1, 4, 1, 351, 1) + (0,10000)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "connectionLocalEndPt"), ("STRATACOM-MIB", "connectionLocalStr"), ("STRATACOM-MIB", "connectionRemoteEndPt"), ("STRATACOM-MIB", "connectionRemoteStr"), ("STRATACOM-MIB", "connectionOpStatus"), ("STRATACOM-MIB", "connectionAbitStatus"), ("STRATACOM-MIB", "connectionType"))
if mibBuilder.loadTexts: userConnCleared.setDescription("The ' User Connection has recovered from failed/downed state")
userConnFailed = NotificationType((1, 3, 6, 1, 4, 1, 351, 1) + (0,10001)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "connectionLocalEndPt"), ("STRATACOM-MIB", "connectionLocalStr"), ("STRATACOM-MIB", "connectionRemoteEndPt"), ("STRATACOM-MIB", "connectionRemoteStr"), ("STRATACOM-MIB", "connectionOpStatus"), ("STRATACOM-MIB", "connectionAbitStatus"), ("STRATACOM-MIB", "connectionType"))
if mibBuilder.loadTexts: userConnFailed.setDescription('The User Connection has failed')
userConnDown = NotificationType((1, 3, 6, 1, 4, 1, 351, 1) + (0,10002)).setObjects(("STRATACOM-MIB", "lastSequenceNumber"), ("STRATACOM-MIB", "connectionLocalEndPt"), ("STRATACOM-MIB", "connectionLocalStr"), ("STRATACOM-MIB", "connectionRemoteEndPt"), ("STRATACOM-MIB", "connectionRemoteStr"), ("STRATACOM-MIB", "connectionOpStatus"), ("STRATACOM-MIB", "connectionAbitStatus"), ("STRATACOM-MIB", "connectionType"))
if mibBuilder.loadTexts: userConnDown.setDescription('The User Connection has been downed')
atmTrunks = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2), )
if mibBuilder.loadTexts: atmTrunks.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrunks.setDescription('A list of atmTrk interfaces')
atmTrkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1), ).setIndexNames((0, "STRATACOM-MIB", "switchIfIndex"))
if mibBuilder.loadTexts: atmTrkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkEntry.setDescription('A interface entry')
atmTrkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("down", 4), ("deact", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatus.setDescription('Alarms state for logical interface table row.')
atmTrkAlmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkAlmEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkAlmEnable.setDescription('A writable object to disable a trunk alarm.')
atmTrkComStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("commOK", 1), ("commFAIL", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkComStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkComStatus.setDescription(' The communication status of the protocol on this trunk.')
atmTrkRcvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkRcvRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkRcvRate.setDescription('Unit of ATM Trunk Receive Rate is based on card types. UXM, and ALM-A: cells per second Other cards: 1000 packets per second ')
atmTrkTrnsCap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkTrnsCap.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkTrnsCap.setDescription(' The Transmit Capacity on this trunk in cells per second.')
atmTrkTrnsLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkTrnsLoad.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkTrnsLoad.setDescription(' The Transmit Load on this trunk in cells per second.')
atmTrkRcvCap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkRcvCap.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkRcvCap.setDescription(' The Receive Capacity on this trunk in cells per second.')
atmTrkRcvLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkRcvLoad.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkRcvLoad.setDescription(' The Receive Load on this trunk in cells per second.')
atmTrkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("trkTypePHY", 1), ("trkTypeCBR", 2), ("trkTypeVBR", 3), ("trkTypeABR", 4), ("trkTypeIPXAF", 5), ("trkTypeAXISAF", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkType.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkType.setDescription(' The type this trunk. The values of trkTypeCBR(2), trkTypeVBR(3), and trkTypeABR(4) are writable for virtual trunks only. The trkTypePHY(1) value is returned for a get-request on a physical trunk.')
atmTrkVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkVPI.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkVPI.setDescription(' The VPI used on this virtual trunk. The maximum value is 255 for ds3 trunks, and 63 for OC3 trunks. The minimum value for set-request PDUs is 1. This value must be unique on a physical trunk port and also must match the value for the path through the ATM cloud. The object cannot be set in IPX/IGX.')
atmTrkResChans = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkResChans.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkResChans.setDescription(' The number of channels reserved for this trunk.')
atmTrkTrafCls = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkTrafCls.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkTrafCls.setDescription(' An integer containing bits representing the traffic classes of this trunk: bit0 Voice, bit1 Time Stamped, bit2 Non-Time Stamped, bit3 Frame Relay, bit4 not used, bit5 ForeSight, bit6 ATM CBR, bit7 ATM VBR, bit8 ATM ABR. ')
atmTrkOeNdType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ndTypeOther", 1), ("ndTypeIPX", 2), ("ndTypeBPX", 3), ("ndTypeIPXAF", 4), ("ndTypeAXIS", 5), ("ndTypeIGX", 6), ("ndTypeIGXAF", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkOeNdType.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkOeNdType.setDescription(' The type of node or shelf at the other end of this trunk.')
atmTrkOeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkOeName.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkOeName.setDescription(' The name of shelf at the other end of this trunk.')
atmTrkOeIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkOeIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkOeIpAddr.setDescription(' The IP address of shelf at the other end of this trunk.')
atmTrkOeIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkOeIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkOeIfIndex.setDescription(' The switchIfIndex at the other end of this trunk.')
atmTrkOeDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkOeDomain.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkOeDomain.setDescription(' The domain of the shelf at the other end of this trunk.')
atmTrkSvcChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcChannels.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcChannels.setDescription("The number of LCN's reserved for the SVC's on this trunk. The other SVC parms are valid if this object has a non-zero value.")
atmTrkShareLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("portBased", 1), ("cardBased", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkShareLcn.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkShareLcn.setDescription("Whether the LCN's are shared per port basis or per card basis.")
atmTrkSvcLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcLcnLow.setDescription("The lower limit of the LCN value which can be used on this trunk --DEFAULT test-function test-atmsvcparm for SVC's.")
atmTrkSvcLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcLcnHigh.setDescription("The Upper limit of the LCN value which can be used on this trunk for SVC's.")
atmTrkSvcVpiLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcVpiLow.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcVpiLow.setDescription("It stores the SVC VPI lower limit. The partitioning is based on the STI Header VC-format. The 16 bit concatenated VPI/VCI field is partitioned between PVC and SVC. On a physical trunk a range will be reserved for SVC's.")
atmTrkSvcVpiHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcVpiHigh.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcVpiHigh.setDescription("It stores the SVC VPI Upper limit. The partitioning is based on the STI Header VC-format. The 16 bit concatenated VPI/VCI field is partitioned between PVC and SVC. On a physical trunk a range will be reserved for SVC's.")
atmTrkSvcVciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcVciLow.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcVciLow.setDescription('It stores the SVC VCI Lower limit.')
atmTrkSvcVciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcVciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcVciHigh.setDescription('It stores the SVC VCI Upper limit.')
atmTrkSvcQbinBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcQbinBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcQbinBitMap.setDescription("A 32-bit Octet string which represents the queue bin allocation. If the bit is set to 1, it is allocated to SVC's and if 0 it is allocated to PVC's. The bits are numbered in the BIG endian order, the m.s bit corresponds to Qbin0 and the next m.s bit corresponds to Qbin 1 etc.For ex. atmTrkSvcQbinMap is set to a value 0x8fff0000 to indicate that queues 0 and 4 through 15 are allocated to SVC 's. This object is valid if atmPortSvcChannels is non-zero.")
atmTrkSvcQbinSz = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcQbinSz.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcQbinSz.setDescription('The Egress Queue pool size.')
atmTrkSvcBw = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkSvcBw.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcBw.setDescription("The bandwidth partition available for SVC's.")
atmTrkSvcInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inUse", 1), ("notInUse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkSvcInUse.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkSvcInUse.setDescription('This object is set by the INS to indicate that SVC partitioning information is being used by INS. The initial value is notInUse. This object is valid if atmPortSvcChannels is non-zero.')
atmTrkXmitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkXmitRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkXmitRate.setDescription("The trunk transmission rate in unit of cells per second. * The default values for this object are, ---------------------------------------------------- Back Card Type | Physical Trunk | Virtual Trunk ---------------------------------------------------- T3 | 96000 | 3000 E3 | 80000 | 2500 OC3 | 353208 | 32109 ---------------------------------------------------- * This object can't be set if the routing trunk is added and the trunk is a physical trunk. It can be set if this is a virtual trunk no matter whether the routing trunk is established or not. * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp, atmRteTrkBdataBTxLoClp. ")
atmTrkPassSync = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkPassSync.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkPassSync.setDescription('The selection of this trunk to pass synchronization to the network clock. * The default value for this object is yes(1). * X.21 subrate trunk cannot pass sync. * V.35 and MIL-188 PLNs can only pass sync if the date rate is 256, 512, or 1024 kbps, since these are the only rates for which the NTC-SR accepts clock from the SCC. * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp, atmRteTrkBdataBTxLoClp. ')
atmTrkStatRes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkStatRes.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatRes.setDescription('The Statistical Reserve in cells per second for this trunk. * The default value for this object is 1000. * This can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp, atmRteTrkBdataBTxLoClp. ')
atmTrkLoopClock = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkLoopClock.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkLoopClock.setDescription("This object indicates if this trunk has been configured to loop receive clock back to transmit. * If local end is configured to pass sync, don't loop clock; * If the interface is X.21, loop clook is not supported. * The default value for this object is no(2). * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp, atmRteTrkBdataBTxLoClp,atmRteTrkBdataBRxQlen, atmRteTrkBdataBRxEfcn, atmRteTrkBdataBRxHiClp and atmRteTrkBdataBRxLoClp. ")
atmTrkBdataBTxQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBTxQlen.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBTxQlen.setDescription('The depth of Bursty Data B transmission queue (in decimal). * This object is not applicable (-1) to IPX/IGX ATM trunks. * The default value for this object is 8000. * This object can only be set together with atmRteTrkBdataBTxEfcn,atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxLoClp on BPX ATM trunks. ')
atmTrkBdataBRxQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBRxQlen.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBRxQlen.setDescription('The depth of Bursty Data B receiving queue (in decimal). * This object is not applicable (-1) to BPX ATM trunk (BNI or BXM). * The default value for this object is 8000. * This object can only be set together with atmRteTrkBdataBRxEfcn, atmRteTrkBdataBRxHiClp and atmRteTrkBdataBRxLoClp on IPX ATM trunks ')
atmTrkBdataBTxEfcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBTxEfcn.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBTxEfcn.setDescription('The transmission EFCN threshold (in decimal) for Bursty Data B of this trunk. * This object is not applicable (-1) to IPX/IGX ATM trunks. * The default value for this object is 8000. * This object can only be set together with atmRteTrkBdataBTxQlen,atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxLoClp on BPX ATM trunks. ')
atmTrkBdataBRxEfcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBRxEfcn.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBRxEfcn.setDescription('The receiving EFCN threshold (in decimal) for Bursty Data B of this trunk. * This object is not applicable (-1) to BPX ATM trunk (BNI or BXM). * The default value for this object is 8000. * This object can only be set together with atmRteTrkBdataBRxQlen, atmRteTrkBdataBRxHiClp and atmRteTrkBdataBRxLoClp on IPX ATM trunks. ')
atmTrkBdataBTxHiClp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBTxHiClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBTxHiClp.setDescription('The transmission high CLP threshold (in percentage) for Bursty Data B of this trunk. * The default value for this object is 75. * This object is not applicable (-1) to IPX/IGX ATM trunks. * This object can only be set together with atmRteTrkBdataBTxEfcn,atmRteTrkBdataBTxQlen and atmRteTrkBdataBTxLoClp on BPX ATM trunks. ')
atmTrkBdataBRxHiClp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBRxHiClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBRxHiClp.setDescription('The receiving high CLP threshold (in percentage) for Bursty Data B of this trunk. This object is not applicable (-1) to BPX ATM trunk (BNI or BXM). * The default value for this object is 75. * This object can only be set together with atmRteTrkBdataBRxEfcn, atmRteTrkBdataBRxQlen and atmRteTrkBdataBRxLoClp on IPX ATM trunks ')
atmTrkBdataBTxLoClp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBTxLoClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBTxLoClp.setDescription('The transmission low CLP threshold (in percentage) for Burstry Data B of this trunk.This object is not applicable (-1) to IPX or IGX ATM trunks. * The default value for this object is 25. * This object can only be set together with atmRteTrkBdataBTxEfcn,atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxQlen on BPX ATM trunks. ')
atmTrkBdataBRxLoClp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkBdataBRxLoClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkBdataBRxLoClp.setDescription('The receiving low CLP threshold (in percentage ) for Bursty Data B of this trunk. This object is not applicable (-1) to BPX ATM trunk (BNI or BXM). * The default value for this object is 25. * This object can only be set together with atmRteTrkBdataBRxEfcn, atmRteTrkBdataBRxHiClp and atmRteTrkBdataBRxQlen on IPX ATM trunks ')
atmTrkMaxChanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 16320))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkMaxChanPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkMaxChanPort.setDescription('The maximum number of channels a BXM trunk port can support. This object is applicable to BXM trunk only. * The default value for this object is 1484. * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxLoClp. ')
atmTrkLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("terrestrial", 1), ("satellite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkLinkType.setDescription('The physical link type of the trunk. The default value for this object is terrestrial(1). * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxLoClp. ')
atmTrkDerouteDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkDerouteDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkDerouteDelayTimer.setDescription('The deroute delay timer of the trunk in unit of second. * The default value for this object is 0. * This object can be set with other writable objects in this table except atmRteTrkAlmEnable, atmRteTrkBdataBTxQlen, atmRteTrkBdataBTxEfcn, atmRteTrkBdataBTxHiClp and atmRteTrkBdataBTxLoClp. ')
atmTrkGtwyChCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkGtwyChCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkGtwyChCount.setDescription('The Gateway Channel count for UXM cards. * This cannot exceed the total number channels per port.')
atmTrkRetainedLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkRetainedLinks.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkRetainedLinks.setDescription('No of retained links, This is for UXM T1-IMA mode only ')
atmTrkImaWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkImaWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkImaWindowSize.setDescription('If this object which is the Window size is zero then additional information is not requested, which are the objects given below. This is for UXM E1/T1-IMA mode only ')
atmTrkImaTrnsCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkImaTrnsCnts.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkImaTrnsCnts.setDescription(' This object can be set only if the Window Size is non-zero. This is Maximum transition counts/window This is for UXM E1/T1-IMA mode only ')
atmTrkImaReenableTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 2, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTrkImaReenableTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkImaReenableTimer.setDescription('This object can be set only if the Window Size is non-zero. This is re-enable timer If 0 is disable else it is in 10min units. This is for UXM T1-IMA mode only ')
atmTrunkStatsTable = MibTable((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4), )
if mibBuilder.loadTexts: atmTrunkStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrunkStatsTable.setDescription('A list of ATM trunk statistics object.')
atmTrkStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1), ).setIndexNames((0, "STRATACOM-MIB", "switchIfIndex"))
if mibBuilder.loadTexts: atmTrkStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsEntry.setDescription('A interface entry')
atmTrkStatsTxVoPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxVoPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxVoPktDrps.setDescription('The number of transmitted voice fast packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxTsPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxTsPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxTsPktDrps.setDescription('The number of transmitted time-stamped packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxNonTsPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxNonTsPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxNonTsPktDrps.setDescription('The number of transmitted non time-stamped packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxHiPrioPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxHiPrioPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxHiPrioPktDrps.setDescription('The number of transmitted high priority packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxBdataAPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxBdataAPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxBdataAPktDrps.setDescription('The number of transmitted bursty data A packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxBdataBPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxBdataBPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxBdataBPktDrps.setDescription('The number of transmitted bursty data B packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxVoPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxVoPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxVoPktDrps.setDescription('The number of received voice packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxTsPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxTsPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxTsPktDrps.setDescription('The number of received time-stamped packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxNonTsPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxNonTsPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxNonTsPktDrps.setDescription('The number of received non time-stamped packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxHiPrioPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxHiPrioPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxHiPrioPktDrps.setDescription('The number of received high priority packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxBdataAPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxBdataAPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxBdataAPktDrps.setDescription('The number of received bursty data A packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsRxBdataBPktDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsRxBdataBPktDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsRxBdataBPktDrps.setDescription('The number of received bursty data B packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsSpacerPktsDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsSpacerPktsDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsSpacerPktsDrps.setDescription('The number of received Spacer Packet dropped. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTotalPktsTxtoLns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTotalPktsTxtoLns.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTotalPktsTxtoLns.setDescription('The number of total packets transmitted to the line. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTotalPktsRxFromLns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTotalPktsRxFromLns.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTotalPktsRxFromLns.setDescription('The number of total packets received from the line. This statistics is not applicatable to BPX trunks, 0 is returned for BPX trunks. ')
atmTrkStatsTxVoCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxVoCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxVoCellDrps.setDescription('The number of transmitted ATM voice cell dropped. This statistics is not applicable to ATM Virtual Trunks, 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxTsCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxTsCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxTsCellDrps.setDescription('The number of transmitted time-stamped ATM cell dropped. This statistics is not applicable to ATM Virtual Trunks. 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxNonTsCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxNonTsCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxNonTsCellDrps.setDescription('The number of transmitted non time-stamped ATM cell dropped. This statistics is not applicable to ATM Virtual Trunks. 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxHiPrioCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxHiPrioCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxHiPrioCellDrps.setDescription('The number of transmitted high priority ATM cell dropped. This statistics is not applicable to ATM Virtual Trunks. 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxBdataACellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxBdataACellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxBdataACellDrps.setDescription('The number of transmitted bursty data A cell dropped. This statistics is not applicable to ATM Virtual Trunks. 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxBdataBCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxBdataBCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxBdataBCellDrps.setDescription('The number of transmitted bursty data B cell dropped. This statistics is not applicable to ATM Virtual Trunks. 0 is returned for ATM Virtual trunks. ')
atmTrkStatsTxCbrCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxCbrCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxCbrCellDrps.setDescription('The number of transmitted ATM CBR cell dropped. This statistics is not applicable to IPX/IGX ATM trunks. 0 is returned for IPX/IGX ATM trunks. ')
atmTrkStatsTxVbrCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxVbrCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxVbrCellDrps.setDescription('The number of transmitted ATM VBR cell dropped. This statistics is not applicable to IPX/IGX ATM trunks. 0 is returned for IPX/IGX ATM trunks. ')
atmTrkStatsTxAbrCellDrps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTxAbrCellDrps.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTxAbrCellDrps.setDescription('The number of transmitted ATM ABR cell dropped. This statistics is not applicable to IPX/IGX ATM trunks. 0 is returned for IPX/IGX ATM trunks. ')
atmTrkStatsTotalCellsTxtoLns = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTotalCellsTxtoLns.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTotalCellsTxtoLns.setDescription('The number of total cells transmitted to the line.')
atmTrkStatsTotalCellsRxFromPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 100, 4, 2, 4, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrkStatsTotalCellsRxFromPorts.setStatus('mandatory')
if mibBuilder.loadTexts: atmTrkStatsTotalCellsRxFromPorts.setDescription('The number of total cells received from the port.')
mibBuilder.exportSymbols("STRATACOM-MIB", frLportErrThresh=frLportErrThresh, frLportStatRxNnis=frLportStatRxNnis, trunkRTCTimeStampCellsTx2Line=trunkRTCTimeStampCellsTx2Line, atmPortStatLmiStatEnqTxs=atmPortStatLmiStatEnqTxs, atmBwClassCDVT0=atmBwClassCDVT0, voiceStatPktsXmits=voiceStatPktsXmits, frEndptCIR=frEndptCIR, frpRTCFramesRcvd=frpRTCFramesRcvd, segmentEntry=segmentEntry, atmPortStatHdrDiscards=atmPortStatHdrDiscards, cirLineCardType=cirLineCardType, frPortsCfgPortSpeed=frPortsCfgPortSpeed, aitEndPtPIR=aitEndPtPIR, atmTrkXmitRate=atmTrkXmitRate, atmTrkAlmEnable=atmTrkAlmEnable, portsInfoTable=portsInfoTable, frEndPtIfShelf=frEndPtIfShelf, aitEndPtSlot=aitEndPtSlot, atmPortStatIlmiGetRspTxs=atmPortStatIlmiGetRspTxs, connectionAdminStatus=connectionAdminStatus, ppaErrorDesc=ppaErrorDesc, cirLineRTCOutOfFrames=cirLineRTCOutOfFrames, atmTrkComStatus=atmTrkComStatus, frLportLmiFailFrms=frLportLmiFailFrms, atmEndPtConnIndex=atmEndPtConnIndex, frLportVcCount=frLportVcCount, connSlvOSpaceCells=connSlvOSpaceCells, frPortsCfgPollCycle=frPortsCfgPollCycle, atmEndptCLPTagging=atmEndptCLPTagging, eventFilterTable=eventFilterTable, atmCellsTxPorts=atmCellsTxPorts, atmTrkEntry=atmTrkEntry, frPortsCfgSlot=frPortsCfgSlot, atmTrkSvcBw=atmTrkSvcBw, frEndptMapConnPtr=frEndptMapConnPtr, maintLogFilterNodeName=maintLogFilterNodeName, atmPortStatOamRxs=atmPortStatOamRxs, connRTCFramesDiscardedWithDE=connRTCFramesDiscardedWithDE, userConnFailed=userConnFailed, aitEndPtVci=aitEndPtVci, switchIfMediaType=switchIfMediaType, atmPortStatClpTxs=atmPortStatClpTxs, networkEntry=networkEntry, nodeName=nodeName, frPortsCfgDs0ChSpeed=frPortsCfgDs0ChSpeed, atmTrkStatsRxNonTsPktDrps=atmTrkStatsRxNonTsPktDrps, trunkRTCFrameBitErrors=trunkRTCFrameBitErrors, voiceChannelXmitSigCBit=voiceChannelXmitSigCBit, atmBwClassCIR=atmBwClassCIR, trunkRTCVoicePktsXmitted=trunkRTCVoicePktsXmitted, atmTrkTrnsLoad=atmTrkTrnsLoad, connNoRouteFoundFailure=connNoRouteFoundFailure, frLportSigProt=frLportSigProt, trunkRTCTxNonTStampCellsDropped=trunkRTCTxNonTStampCellsDropped, connectionRemOSpaceBdaCmax=connectionRemOSpaceBdaCmax, frEndptGroupFlag=frEndptGroupFlag, portsInfoShelf=portsInfoShelf, frEndptTxFrmsBecns=frEndptTxFrmsBecns, atmTrkBdataBRxHiClp=atmTrkBdataBRxHiClp, voiceTestFailure=voiceTestFailure, trunkRTCBurstyDataACellsTx2Line=trunkRTCBurstyDataACellsTx2Line, frEndptConnDesc=frEndptConnDesc, atmEndptEfciQSize=atmEndptEfciQSize, voiceChannelChannelIndex=voiceChannelChannelIndex, trunkRTCBurstyDataBEfcnPktsTx2Line=trunkRTCBurstyDataBEfcnPktsTx2Line, networkTable=networkTable, atmBwClassPCR0=atmBwClassPCR0, atmTrkBdataBTxEfcn=atmTrkBdataBTxEfcn, frLportStatEnqUnis=frLportStatEnqUnis, atmTrkOeIpAddr=atmTrkOeIpAddr, readingTrapFlag=readingTrapFlag, frpRTCLmiStatusXmitRate=frpRTCLmiStatusXmitRate, frpRTCCLLMBytesRx=frpRTCCLLMBytesRx, atmEndptOeRateUpICA=atmEndptOeRateUpICA, connMstOSpaceCells=connMstOSpaceCells, frEndptMapTable=frEndptMapTable, frpRTCFramesXmittedWithBECN=frpRTCFramesXmittedWithBECN, connectionTestType=connectionTestType, maintLogFilterSeverity=maintLogFilterSeverity, frPortsCfgPollVerTimer=frPortsCfgPollVerTimer, atmTrkImaTrnsCnts=atmTrkImaTrnsCnts, connectionPrefRouteDesc=connectionPrefRouteDesc, frpRTCCLLMBytesTx=frpRTCCLLMBytesTx, connMstOSpacePkts=connMstOSpacePkts, connRTCXmitPktsProjected=connRTCXmitPktsProjected, atmTrkStatRes=atmTrkStatRes, atmTrkImaReenableTimer=atmTrkImaReenableTimer, atmEndptOeQIR=atmEndptOeQIR, voiceChannelDtMinWink=voiceChannelDtMinWink, frLportChSpeed=frLportChSpeed, frEndptRxFrmsCirs=frEndptRxFrmsCirs, switchShelf=switchShelf, circuitGroup=circuitGroup, trunkRTCBurstyDataPktsDropped=trunkRTCBurstyDataPktsDropped, atmPortMgmtProto=atmPortMgmtProto, switchIfOperStatus=switchIfOperStatus, logNodeName=logNodeName, atmTrkSvcLcnHigh=atmTrkSvcLcnHigh, connectionTrkAvoidType=connectionTrkAvoidType, frLportDscdQTxBytes=frLportDscdQTxBytes, voiceChannelEchoRtnLoss=voiceChannelEchoRtnLoss, atmPortStatFerfRxs=atmPortStatFerfRxs, frpEcnThreshold=frpEcnThreshold, voiceStatRxPktsDscds=voiceStatRxPktsDscds, atmPortLmiPollTimer=atmPortLmiPollTimer, connTable=connTable, atmEndptOeLoCLP=atmEndptOeLoCLP, atmBwClassMFS=atmBwClassMFS, atmEfciTxs=atmEfciTxs, Severity=Severity, nodeFsFastRate=nodeFsFastRate, connCMax=connCMax, atmPortIlmiErrorThresh=atmPortIlmiErrorThresh, connLocalMaxPkts=connLocalMaxPkts, frLportLoopBack=frLportLoopBack, trunkRTCBurstyDataPktsXmitted=trunkRTCBurstyDataPktsXmitted, endOfQueueFlag=endOfQueueFlag, atmServiceObjects=atmServiceObjects, frLportToutCntNnis=frLportToutCntNnis, voiceChannelIf=voiceChannelIf, ppaErrorLastIndex=ppaErrorLastIndex, connRTCXmitFramesWithBECN=connRTCXmitFramesWithBECN, frpRTCRxDEFramesDiscarded=frpRTCRxDEFramesDiscarded, nodeGrpRelease=nodeGrpRelease, connectionTrkAvoidZCS=connectionTrkAvoidZCS, atmPortStatLmiStatRxs=atmPortStatLmiStatRxs, voiceChannelXmitSigDBit=voiceChannelXmitSigDBit, frEndptOeMIR=frEndptOeMIR, frEndptMapSlot=frEndptMapSlot, managerPortNumber=managerPortNumber, frLportCllmFailures=frLportCllmFailures, frEndptRxFrmsDes=frEndptRxFrmsDes, frLportUnknDlcis=frLportUnknDlcis, frIxPortsCfgSrDCD=frIxPortsCfgSrDCD, atmBwClassOeScrPlc=atmBwClassOeScrPlc, frEndPtEgressDeThreshold=frEndPtEgressDeThreshold, aitEndPtMIR=aitEndPtMIR, switchIfTable=switchIfTable, frOtherEndptDesc=frOtherEndptDesc, atmEndptLpbkStatus=atmEndptLpbkStatus, cirLineRTCOutOfMultiFrames=cirLineRTCOutOfMultiFrames, connRTCChannel=connRTCChannel, atmBwClassOeMIR=atmBwClassOeMIR, atmTrkSvcVciHigh=atmTrkSvcVciHigh, switchIfService=switchIfService, voiceStatInservices=voiceStatInservices, atmTrunks=atmTrunks, frpRTCFramesRcvdUndefDlciErrors=frpRTCFramesRcvdUndefDlciErrors, voiceOtherEndptAdv=voiceOtherEndptAdv, frBwClassQIR=frBwClassQIR, atmEndptOeCBS=atmEndptOeCBS, frLportUpdtRxNnis=frLportUpdtRxNnis, voiceEndptConnDesc=voiceEndptConnDesc, atmBwClassOeCCDV=atmBwClassOeCCDV, connRTCCongestedMinuites=connRTCCongestedMinuites, trunkRTCLocalPort=trunkRTCLocalPort, frLportBadFmts=frLportBadFmts, frEndPtQIR=frEndPtQIR, frLportOamThresh=frLportOamThresh, voiceEndptTable=voiceEndptTable, frEndPtVcQSize=frEndPtVcQSize, segmentTable=segmentTable, connLclEndptDesc=connLclEndptDesc, atmTrkBdataBRxQlen=atmTrkBdataBRxQlen, trunkLocalPort=trunkLocalPort, voiceEndptMapSlot=voiceEndptMapSlot, mgrIpAddress=mgrIpAddress, atmEndPtVci=atmEndPtVci, trapConfigTable=trapConfigTable, frLportMonEveCnt=frLportMonEveCnt, atmBwClassOeRateUpICA=atmBwClassOeRateUpICA, frBwClassEnableFST=frBwClassEnableFST, atmBwClassPercUtil=atmBwClassPercUtil, connectionRemOSpaceBdbCmax=connectionRemOSpaceBdbCmax, voiceChannelAdapVoice=voiceChannelAdapVoice, voiceStatDsiOns=voiceStatDsiOns, connectionIndex=connectionIndex, frLportPolVerTmr=frLportPolVerTmr, frLportExtConFail=frLportExtConFail, frEndPtEntry=frEndPtEntry, trunkRTCLocalSlot=trunkRTCLocalSlot, atmBwClassIndex=atmBwClassIndex, frEndPtAdminStatus=frEndPtAdminStatus, atmPortStatBcmRxs=atmPortStatBcmRxs, atmTrkStatsTotalCellsRxFromPorts=atmTrkStatsTotalCellsRxFromPorts, frLportStatEntry=frLportStatEntry, frLportCllmRxBytes=frLportCllmRxBytes, cmpaErrorEcode=cmpaErrorEcode, frLportPollCycle=frLportPollCycle, networkId=networkId, frEndptOeBc=frEndptOeBc, frpGroup=frpGroup, connMstOSpaceBdbCmax=connMstOSpaceBdbCmax, atmPortIlmiVci=atmPortIlmiVci, atmEndptMapSlot=atmEndptMapSlot, atmPortSpeed=atmPortSpeed, frLportMinFrmFlgs=frLportMinFrmFlgs, atmPortStatLmiStatAckTxs=atmPortStatLmiStatAckTxs, voiceChannelTable=voiceChannelTable, connRTCFramesRxWithDE=connRTCFramesRxWithDE, aitEndPtVcQSize=aitEndPtVcQSize, ppaErrorTable=ppaErrorTable, frEndPtchanFECNconfig=frEndPtchanFECNconfig, nodeGrpPlatform=nodeGrpPlatform, atmPortStatIlmiGetNextTxs=atmPortStatIlmiGetNextTxs, atmBwClassOeMFS=atmBwClassOeMFS, frpRTCRxStatusCounter=frpRTCRxStatusCounter, connectionRemOSpacePkts=connectionRemOSpacePkts, atmTrkStatsTxBdataBPktDrps=atmTrkStatsTxBdataBPktDrps, atmPortStatUnknVpiVcis=atmPortStatUnknVpiVcis, atmPortStatIlmiUnkRxs=atmPortStatIlmiUnkRxs, nodeGrpActive=nodeGrpActive, cmpaErrorLastIndex=cmpaErrorLastIndex, networkIpxId=networkIpxId, trunkBurstyDataBQDepth=trunkBurstyDataBQDepth, atmPortAdminStatus=atmPortAdminStatus, stratacom=stratacom, trunkRTCMulticastPktsXmitted=trunkRTCMulticastPktsXmitted, aitEndPtIfShelf=aitEndPtIfShelf, atmPortIlmiTrapEnable=atmPortIlmiTrapEnable, frLportAdminStatus=frLportAdminStatus, connRTCBytesTxExcessCir=connRTCBytesTxExcessCir, atmTrkTrafCls=atmTrkTrafCls, filteredLogRecord=filteredLogRecord, atmBcmRxs=atmBcmRxs, ppaErrorLastDesc=ppaErrorLastDesc, atmTrkBdataBRxLoClp=atmTrkBdataBRxLoClp, frLportStatTable=frLportStatTable, atmNoRouteFoundFailure=atmNoRouteFoundFailure, frEndptVcQSize=frEndptVcQSize, atmBwClassEntry=atmBwClassEntry, connMstOSpaceBdaCmax=connMstOSpaceBdaCmax, trunkActive=trunkActive, connectionForesight=connectionForesight, voiceChannelIfCondIndex=voiceChannelIfCondIndex, trapSequenceNum=trapSequenceNum, atmBwClassOeVcQSize=atmBwClassOeVcQSize, frEndptEnableFST=frEndptEnableFST, atmAisRxs=atmAisRxs, frLportDEThresh=frLportDEThresh, svNodeGroup=svNodeGroup, frLportDmaOvruns=frLportDmaOvruns, trunkRTCTxBurstyDataBClpPktsDropped=trunkRTCTxBurstyDataBClpPktsDropped, frEndptPercUtil=frEndptPercUtil, voiceEndptLpbkStatus=voiceEndptLpbkStatus, frPortsCfgFrmFlags=frPortsCfgFrmFlags, frPortsCfgChCnt=frPortsCfgChCnt, frLportIllegLengths=frLportIllegLengths, frEndptTrkAvoidZCS=frEndptTrkAvoidZCS, frIxPortsCfgSrCTS=frIxPortsCfgSrCTS, atmTrkOeIfIndex=atmTrkOeIfIndex, atmDiscardFails=atmDiscardFails, atmPortQueueClpHi=atmPortQueueClpHi, frOtherEndptIndex=frOtherEndptIndex)
mibBuilder.exportSymbols("STRATACOM-MIB", frEndptOePIR=frEndptOePIR, atmTrkImaWindowSize=atmTrkImaWindowSize, frpRTCBadSequenceNumberCount=frpRTCBadSequenceNumberCount, connRTCSecondsV25ModemOn=connRTCSecondsV25ModemOn, frpRTCDmaOverruns=frpRTCDmaOverruns, frEndPtLine=frEndPtLine, managerNumOfValidEntries=managerNumOfValidEntries, atmBwClassOeFGCRA=atmBwClassOeFGCRA, nodeGrpNetName=nodeGrpNetName, connConnInfoFlag=connConnInfoFlag, frBumpFailure=frBumpFailure, trunkRemSlot=trunkRemSlot, trunkRTCOutOfFrames=trunkRTCOutOfFrames, trunkRTCBurstyDataBEfcnCellsTx2Line=trunkRTCBurstyDataBEfcnCellsTx2Line, frpLocalLine=frpLocalLine, atmCellsTxNets=atmCellsTxNets, atmTrkStatsTotalCellsTxtoLns=atmTrkStatsTotalCellsTxtoLns, frLportPortType=frLportPortType, atmEndptQIR=atmEndptQIR, voiceNoRouteFoundFailure=voiceNoRouteFoundFailure, atmCellsRxNets=atmCellsRxNets, voiceStatV25ModemOns=voiceStatV25ModemOns, connEntry=connEntry, frEndptLpbkStatus=frEndptLpbkStatus, connectionAbitStatus=connectionAbitStatus, maintLogFilterTimeMin=maintLogFilterTimeMin, frpLocalPort=frpLocalPort, connectionRowStatus=connectionRowStatus, voiceServiceObjects=voiceServiceObjects, frBwClassOeMIR=frBwClassOeMIR, atmEndPtIfShelf=atmEndPtIfShelf, atmEndPtOpStatus=atmEndPtOpStatus, trunkEntry=trunkEntry, rtm=rtm, shelfCnfgStatTimeSync=shelfCnfgStatTimeSync, trunkRTCNonTimeStampCellsTx2Line=trunkRTCNonTimeStampCellsTx2Line, atmEndPtPort=atmEndPtPort, trunkInterface=trunkInterface, cmpaErrorDesc=cmpaErrorDesc, connSvc=connSvc, frEndptRxPkts=frEndptRxPkts, atmPortQueueDepth=atmPortQueueDepth, atmTrkResChans=atmTrkResChans, frpActive=frpActive, atmEndPtSlot=atmEndPtSlot, atmConnPtr=atmConnPtr, atmPortStatClpRxs=atmPortStatClpRxs, cirLineTable=cirLineTable, trunkRemLineNumber=trunkRemLineNumber, trunkRTCTxBurstyDataAClpCellsDropped=trunkRTCTxBurstyDataAClpCellsDropped, frLportCllmTxFrms=frLportCllmTxFrms, frPortsCfgEntry=frPortsCfgEntry, frEndptMapPort=frEndptMapPort, frpRTCSlot=frpRTCSlot, portsInfoPort=portsInfoPort, frIxPortsCfgDEThresh=frIxPortsCfgDEThresh, frLportTxBytes=frLportTxBytes, segConnIndex=segConnIndex, atmTrkStatus=atmTrkStatus, frpStatus=frpStatus, atmPortQueueClpLo=atmPortQueueClpLo, atmEndptOeMIR=atmEndptOeMIR, frLportPortIndex=frLportPortIndex, atmEndPtNodeName=atmEndPtNodeName, frEndptSecInServices=frEndptSecInServices, frPortsCfgRowStatus=frPortsCfgRowStatus, atmTrkStatsRxTsPktDrps=atmTrkStatsRxTsPktDrps, atmTrkStatsTxNonTsPktDrps=atmTrkStatsTxNonTsPktDrps, atmTrkStatsSpacerPktsDrps=atmTrkStatsSpacerPktsDrps, frPortsCfgSigProt=frPortsCfgSigProt, voiceOtherEndptDesc=voiceOtherEndptDesc, frEndptOperStatus=frEndptOperStatus, connRTCDLCI=connRTCDLCI, logIndex=logIndex, trunkRTCBadClockErrors=trunkRTCBadClockErrors, frEndPtDlci=frEndPtDlci, atmPortIlmiPollEnable=atmPortIlmiPollEnable, atmPortTable=atmPortTable, atmEndptOePIR=atmEndptOePIR, frLportSrDCD=frLportSrDCD, atmEndptCBS=atmEndptCBS, atmEndptOeEfciQSize=atmEndptOeEfciQSize, voiceEndptAvoidZCS=voiceEndptAvoidZCS, connLocalLine=connLocalLine, frIxPortsCfgLoopBack=frIxPortsCfgLoopBack, frEndptTxBytesCirs=frEndptTxBytesCirs, atmEndptOeVcQSize=atmEndptOeVcQSize, atmEndPtPercUtil=atmEndPtPercUtil, frServiceObjects=frServiceObjects, frLportCommPri=frLportCommPri, frLportSrRTS=frLportSrRTS, atmEndptOperStatus=atmEndptOperStatus, trunkLineLoad=trunkLineLoad, atmTrkStatsTxBdataACellDrps=atmTrkStatsTxBdataACellDrps, lastSequenceNumber=lastSequenceNumber, frpStatusAlarm=frpStatusAlarm, atmBwClassOeEfciQSize=atmBwClassOeEfciQSize, nodeEntry=nodeEntry, voiceChannelEchoCancel=voiceChannelEchoCancel, trunkRTCTxBurstyDataAClpPktsDropped=trunkRTCTxBurstyDataAClpPktsDropped, portSvc=portSvc, voiceChannelOutGain=voiceChannelOutGain, eventFilterSubstring=eventFilterSubstring, aitEndPtEcnQSize=aitEndPtEcnQSize, cmpaErrorLastEcode=cmpaErrorLastEcode, atmEndptOeHiCLP=atmEndptOeHiCLP, frLportTxFrms=frLportTxFrms, aitEndPtEntry=aitEndPtEntry, atmDiscardVcqFulls=atmDiscardVcqFulls, atmEndptTrkAvoidZCS=atmEndptTrkAvoidZCS, frEndptAdminStatus=frEndptAdminStatus, atmPortPercUtil=atmPortPercUtil, eventFilterIndex=eventFilterIndex, switchIfSubPort=switchIfSubPort, connRTCXmitBytes=connRTCXmitBytes, frEndPtPriority=frEndPtPriority, cmpaErrorTable=cmpaErrorTable, networkName=networkName, voiceBumpFailure=voiceBumpFailure, aitEndPtPercUtil=aitEndPtPercUtil, frEndptBe=frEndptBe, shelfCnfgObjects=shelfCnfgObjects, trapUploadTable=trapUploadTable, maintLogFilterNetworkName=maintLogFilterNetworkName, cirLineRTCFrameSlips=cirLineRTCFrameSlips, atmEndptMapEntry=atmEndptMapEntry, atmPortStatEfciRxs=atmPortStatEfciRxs, voiceEndptAdminStatus=voiceEndptAdminStatus, aitEndPtQIR=aitEndPtQIR, frBwClassOePIR=frBwClassOePIR, voiceChannelRecvSigCBit=voiceChannelRecvSigCBit, voiceStatPktsRxs=voiceStatPktsRxs, atmEndptTBE=atmEndptTBE, atmPortAxis=atmPortAxis, voiceEndptAdv=voiceEndptAdv, aitEndPtOpStatus=aitEndPtOpStatus, connRTCXmitFrames=connRTCXmitFrames, switchIfSlot=switchIfSlot, atmEndptDesc=atmEndptDesc, segSubChn2=segSubChn2, frIxPortsCfgLowRNR=frIxPortsCfgLowRNR, frBwClassMIR=frBwClassMIR, atmDiscardQbinFulls=atmDiscardQbinFulls, connCurrRouteDesc=connCurrRouteDesc, frLportSeqnmErrNnis=frLportSeqnmErrNnis, atmTestFailure=atmTestFailure, trunkRTCHighPriorityPktsXmitted=trunkRTCHighPriorityPktsXmitted, connServerType=connServerType, frpRTCLmiStatusUpdateRate=frpRTCLmiStatusUpdateRate, connNextEndptIndex=connNextEndptIndex, frEndptOeBe=frEndptOeBe, atmEndptTrkAvoidType=atmEndptTrkAvoidType, atmEndptOeScrPlc=atmEndptOeScrPlc, trunkRTCTable=trunkRTCTable, segSlot=segSlot, atmBwClassOeCDVT0=atmBwClassOeCDVT0, maintLogEntry=maintLogEntry, frEndPtDeTagging=frEndPtDeTagging, maintLogFilterGroup=maintLogFilterGroup, frIxPortsCfgEFCItoBECN=frIxPortsCfgEFCItoBECN, frEndptTxPkts=frEndptTxPkts, frEndPtPercUtil=frEndPtPercUtil, userConnCleared=userConnCleared, atmPortStatIsuDiscards=atmPortStatIsuDiscards, frLportAggrChCnt=frLportAggrChCnt, DisplayString=DisplayString, atmEndptEnableFST=atmEndptEnableFST, cirLineRTCCrcErrors=cirLineRTCCrcErrors, frEndPtchanType=frEndPtchanType, aitEndPtCMAX=aitEndPtCMAX, trunkRTCNonTimeStampedPktsDropped=trunkRTCNonTimeStampedPktsDropped, cmpaErrorReqId=cmpaErrorReqId, atmEndPtEntry=atmEndPtEntry, atmPortQueueIndex=atmPortQueueIndex, frBwClassTable=frBwClassTable, atmTrkSvcVpiHigh=atmTrkSvcVpiHigh, atmTrkStatsTotalPktsTxtoLns=atmTrkStatsTotalPktsTxtoLns, connPir=connPir, atmTrkSvcQbinBitMap=atmTrkSvcQbinBitMap, trunkRTCTxBurstyDataBCellsDropped=trunkRTCTxBurstyDataBCellsDropped, connectionTable=connectionTable, frEndptCongestMins=frEndptCongestMins, atmCellsRxPorts=atmCellsRxPorts, atmBwClassScrPlc=atmBwClassScrPlc, atmEndptOePCR0=atmEndptOePCR0, frNextPtr=frNextPtr, frEndptOeQIR=frEndptOeQIR, connQir=connQir, frBwClassOeQIR=frBwClassOeQIR, aitEndPtVpi=aitEndPtVpi, atmPortOperStatus=atmPortOperStatus, atmTrkRcvRate=atmTrkRcvRate, nodeNetworkName=nodeNetworkName, connectionLocalEndPt=connectionLocalEndPt, eventFilterStatus=eventFilterStatus, frpRTCBytesRcvd=frpRTCBytesRcvd, connectionTestResult=connectionTestResult, frEndPtCMAX=frEndPtCMAX, frEndPtBe=frEndPtBe, atmPortLmiVpi=atmPortLmiVpi, trunkRTCBurstyDataAEfcnCellsTx2Line=trunkRTCBurstyDataAEfcnCellsTx2Line, atmBwClassOeLoCLP=atmBwClassOeLoCLP, connComment=connComment, atmPortStatEfciTxs=atmPortStatEfciTxs, controlGroup=controlGroup, atmTrkStatsTxNonTsCellDrps=atmTrkStatsTxNonTsCellDrps, atmTrkStatsRxBdataAPktDrps=atmTrkStatsRxBdataAPktDrps, connSlvOSpaceBdbCmax=connSlvOSpaceBdbCmax, frLportSrCTS=frLportSrCTS, trunkStatus=trunkStatus, atmTrkSvcQbinSz=atmTrkSvcQbinSz, aitEndPtTable=aitEndPtTable, atmTrkStatsTxVbrCellDrps=atmTrkStatsTxVbrCellDrps, atmTrkLinkType=atmTrkLinkType, atmTrkStatsRxBdataBPktDrps=atmTrkStatsRxBdataBPktDrps, frpRTCCLLMFailures=frpRTCCLLMFailures, connCir=connCir, segShelf=segShelf, connIndex=connIndex, atmPortStatIlmiGetRxs=atmPortStatIlmiGetRxs, frEndptOePercUtil=frEndptOePercUtil, frBwClassOePercUtil=frBwClassOePercUtil, frEndptOeCMAX=frEndptOeCMAX, atmBwClassToQIR=atmBwClassToQIR, atmDiscardRsrcOflows=atmDiscardRsrcOflows, frpDeThreshold=frpDeThreshold, connLocalDLCI=connLocalDLCI, frEndPtConnIndex=frEndPtConnIndex, connAdminStatus=connAdminStatus, atmEndPtCIR=atmEndPtCIR, frEndptConnPrio=frEndptConnPrio, connPerUtil=connPerUtil, ppaErrorReqId=ppaErrorReqId, logSeverity=logSeverity, connVcQueDepth=connVcQueDepth, connectionRemoteEndPt=connectionRemoteEndPt, voiceChannelIfOnhkDBit=voiceChannelIfOnhkDBit, trunkClpLowDropThreshold=trunkClpLowDropThreshold, atmEndptFGCRA=atmEndptFGCRA, frBwClassCIR=frBwClassCIR, voiceChannelUtil=voiceChannelUtil, switchConnection=switchConnection, atmEndptLocLpbkState=atmEndptLocLpbkState, atmEndptMIR=atmEndptMIR, frPortsCfgPort=frPortsCfgPort, atmPortIfType=atmPortIfType, connectionLocOSpaceBdaCmax=connectionLocOSpaceBdaCmax, connRTCFramesRxExcessCir=connRTCFramesRxExcessCir, frEndPtIngressDeThreshold=frEndPtIngressDeThreshold, connRmtEndptDesc=connRmtEndptDesc, trunkRTCBurstyDataAClpPktsTx2Line=trunkRTCBurstyDataAClpPktsTx2Line, aitEndPtPriority=aitEndPtPriority, atmClpRxs=atmClpRxs, voiceChannelEndptPtr=voiceChannelEndptPtr)
mibBuilder.exportSymbols("STRATACOM-MIB", atmBcmTxs=atmBcmTxs, atmBumpFailure=atmBumpFailure, frpRTCXmitStatusEnquirey=frpRTCXmitStatusEnquirey, atmTrkStatsTotalPktsRxFromLns=atmTrkStatsTotalPktsRxFromLns, switchIfEntry=switchIfEntry, atmPortStatCellsTxs=atmPortStatCellsTxs, frEndptTable=frEndptTable, atmPortType=atmPortType, atmTrkStatsTxHiPrioPktDrps=atmTrkStatsTxHiPrioPktDrps, atmEndPtPriority=atmEndPtPriority, userConnDown=userConnDown, atmPortMetro=atmPortMetro, frEndPtEgressEcnThreshold=frEndPtEgressEcnThreshold, frEndptLocRmtLpbkState=frEndptLocRmtLpbkState, voiceChannelEntry=voiceChannelEntry, atmEndptMapVci=atmEndptMapVci, frEndPtNodeName=frEndPtNodeName, connectionRemoteStr=connectionRemoteStr, voiceChannelIfOnhkCBit=voiceChannelIfOnhkCBit, frEndptRtdTestDelay=frEndptRtdTestDelay, atmEndptOeFGCRA=atmEndptOeFGCRA, frEndptLocLpbkState=frEndptLocLpbkState, nextTrapSeqNum=nextTrapSeqNum, frIxPortsCfgOamThresh=frIxPortsCfgOamThresh, atmPortStatIlmiSetRxs=atmPortStatIlmiSetRxs, atmBwClassRateDnICA=atmBwClassRateDnICA, eventFilterSeverity=eventFilterSeverity, connIcaRTD=connIcaRTD, atmEndptOamStatus=atmEndptOamStatus, atmPortLmiUpdStatRetry=atmPortLmiUpdStatRetry, atmAvgVcqDepths=atmAvgVcqDepths, trunkStatReserve=trunkStatReserve, connMibUpTime=connMibUpTime, connRTCXmitFramesWithFECN=connRTCXmitFramesWithFECN, frBwClassIndex=frBwClassIndex, frPortsCfgPortState=frPortsCfgPortState, connRTCFramesTxWithDE=connRTCFramesTxWithDE, connRTCSecondsOffHook=connRTCSecondsOffHook, voiceEndptTestType=voiceEndptTestType, connRTCSlot=connRTCSlot, frBwClassBc=frBwClassBc, frPortsCfgNNIStatus=frPortsCfgNNIStatus, frEndptTxFrms=frEndptTxFrms, voiceStatOffhks=voiceStatOffhks, atmBwClassTable=atmBwClassTable, frpQDepth=frpQDepth, atmEndPtMIR=atmEndPtMIR, voiceChannelInGain=voiceChannelInGain, frBwClassCMAX=frBwClassCMAX, atmPortStatLmiStatEnqRxs=atmPortStatLmiStatEnqRxs, atmBwClassDescription=atmBwClassDescription, connMasterFlag=connMasterFlag, frLportAsynStatus=frLportAsynStatus, atmBwClassPIR=atmBwClassPIR, switchIfPort=switchIfPort, atmBwClassCBS=atmBwClassCBS, trunkRTCPktOutOfFrames=trunkRTCPktOutOfFrames, frIxPortsCfgIDEMap=frIxPortsCfgIDEMap, atmTrkSvcChannels=atmTrkSvcChannels, managerRowStatus=managerRowStatus, frEndptStatEntry=frEndptStatEntry, voiceChannelPtr=voiceChannelPtr, portsInfoSlot=portsInfoSlot, atmPortLmiStatEnqTimer=atmPortLmiStatEnqTimer, voiceEndptMapConnPtr=voiceEndptMapConnPtr, connRTCFramesTxExcessCir=connRTCFramesTxExcessCir, atmOtherEndptDesc=atmOtherEndptDesc, atmEndPtVpi=atmEndPtVpi, voiceEndptEncoding=voiceEndptEncoding, atmEndPtRowStatus=atmEndPtRowStatus, frIxPortsCfgCommPri=frIxPortsCfgCommPri, atmDiscardSbinFulls=atmDiscardSbinFulls, trunkBurstyDataBQEfcnThreshold=trunkBurstyDataBQEfcnThreshold, segEndPtTableId=segEndPtTableId, atmEndptMapEndptPtr=atmEndptMapEndptPtr, frEndPtType=frEndPtType, frIxPortsCfgSrDSR=frIxPortsCfgSrDSR, atmTrkBdataBTxLoClp=atmTrkBdataBTxLoClp, frBwClassVcQSize=frBwClassVcQSize, shelfCnfgSwError=shelfCnfgSwError, frIxPortsCfgClockType=frIxPortsCfgClockType, frEndptBc=frEndptBc, atmTrkType=atmTrkType, frLportLowRNR=frLportLowRNR, connLocalChannel=connLocalChannel, frEndptTxFrmsFecns=frEndptTxFrmsFecns, frLportLmiFailBytes=frLportLmiFailBytes, trunkRTCTotalCellsTx2Line=trunkRTCTotalCellsTx2Line, frEndptMapDlci=frEndptMapDlci, frEndPtMIR=frEndPtMIR, atmTrkSvcVciLow=atmTrkSvcVciLow, connType=connType, errStatusLastIndex=errStatusLastIndex, voiceChannelSlotIndex=voiceChannelSlotIndex, cirLineActive=cirLineActive, atmEndptGroupFlag=atmEndptGroupFlag, frLportInvldReqCnts=frLportInvldReqCnts, connRTCXmitBytesDiscarded=connRTCXmitBytesDiscarded, frEndPtPIR=frEndPtPIR, atmPortStatTable=atmPortStatTable, cirLinePortNumber=cirLinePortNumber, frPortsCfgShelf=frPortsCfgShelf, connectionCurrRouteDesc=connectionCurrRouteDesc, segNextSeg=segNextSeg, voiceChannelIfOnhkABit=voiceChannelIfOnhkABit, frBwClassOeBc=frBwClassOeBc, atmBwClassLoCLP=atmBwClassLoCLP, frEndPtEgressQSelect=frEndPtEgressQSelect, cmpaErrorEntry=cmpaErrorEntry, atmEndptCCDV=atmEndptCCDV, atmPortLmiUpdStatTimer=atmPortLmiUpdStatTimer, atmPortSlot=atmPortSlot, voiceEndptEndptType=voiceEndptEndptType, shelfCnfgStatMaster=shelfCnfgStatMaster, connMinBandwidth=connMinBandwidth, voiceEndptIndex=voiceEndptIndex, networkGroup=networkGroup, frPortsCfgMonEveCnt=frPortsCfgMonEveCnt, frpRTCBytesXmitted=frpRTCBytesXmitted, voiceChannelXmitSigABit=voiceChannelXmitSigABit, connTableEntry=connTableEntry, voiceChannelDtSignallingDelay=voiceChannelDtSignallingDelay, atmTrkStatsTxTsPktDrps=atmTrkStatsTxTsPktDrps, cirLineRTCLineNumber=cirLineRTCLineNumber, connClassOfService=connClassOfService, atmPortStatIlmiGetNextRxs=atmPortStatIlmiGetNextRxs, atmPortIlmiPollIntrvl=atmPortIlmiPollIntrvl, connFirstEndptPtr=connFirstEndptPtr, atmBwClassQIR=atmBwClassQIR, frLportAlgnErrors=frLportAlgnErrors, atmFerfRxs=atmFerfRxs, frIxPortsCfgSrDTR=frIxPortsCfgSrDTR, voiceChannelEchoConv=voiceChannelEchoConv, frIxPortsCfgVcCount=frIxPortsCfgVcCount, connSlvOSpacePkts=connSlvOSpacePkts, shelfCnfgCardError=shelfCnfgCardError, frpRTCEntry=frpRTCEntry, cirLineComment=cirLineComment, trunkRTCPlcpOutOfFrames=trunkRTCPlcpOutOfFrames, switchIfPartiId=switchIfPartiId, atmPortStatIlmiTrapTxs=atmPortStatIlmiTrapTxs, voiceChannelIfOnhkBBit=voiceChannelIfOnhkBBit, atmEndptLocRmtLpbkState=atmEndptLocRmtLpbkState, voiceEndptMapTable=voiceEndptMapTable, ppaErrorEntry=ppaErrorEntry, trunkRTCTimeStampedPktsXmitted=trunkRTCTimeStampedPktsXmitted, frEndptQIR=frEndptQIR, voiceEndptLocLpbkState=voiceEndptLocLpbkState, frLportPortDLCI=frLportPortDLCI, frpRTCLmiKeepaliveSequenceErrors=frpRTCLmiKeepaliveSequenceErrors, trunkTable=trunkTable, nodeTable=nodeTable, atmPortStatIlmiGetRspRxs=atmPortStatIlmiGetRspRxs, frpRTCFramesRcvdCrcErrors=frpRTCFramesRcvdCrcErrors, frEndptPIR=frEndptPIR, atmEfciRxs=atmEfciRxs, atmEndPtVcQSize=atmEndPtVcQSize, connRate=connRate, frPortsCfgPortType=frPortsCfgPortType, connSlvOSpaceBdaCmax=connSlvOSpaceBdaCmax, atmTrkSvcLcnLow=atmTrkSvcLcnLow, frEndptOeCIR=frEndptOeCIR, atmTrunkStatsTable=atmTrunkStatsTable, shelfCnfgStatCollIntvl=shelfCnfgStatCollIntvl, connRTCSecondsInService=connRTCSecondsInService, frEndptMIR=frEndptMIR, atmTrkBdataBRxEfcn=atmTrkBdataBRxEfcn, voiceEndptDesc=voiceEndptDesc, frEndPointFailure=frEndPointFailure, atmTrkStatsTxBdataAPktDrps=atmTrkStatsTxBdataAPktDrps, atmEndptToQIR=atmEndptToQIR, cmpaErrorFlushAll=cmpaErrorFlushAll, atmBwClassOePCR0=atmBwClassOePCR0, frpRTCLmiLinkTimeoutErrors=frpRTCLmiLinkTimeoutErrors, frIxPortsCfgSrRTS=frIxPortsCfgSrRTS, trapUploadEntry=trapUploadEntry, aitEndPtCIR=aitEndPtCIR, voiceEndptState=voiceEndptState, nodeGrpAlarmState=nodeGrpAlarmState, frpRTCCLLMFramesRx=frpRTCCLLMFramesRx, voiceEndptMapEndptPtr=voiceEndptMapEndptPtr, atmEndPtIBS=atmEndPtIBS, atmEndptMapVpi=atmEndptMapVpi, atmTrkRcvLoad=atmTrkRcvLoad, nodeFsIncRate=nodeFsIncRate, connGroupDesc=connGroupDesc, frBwClassPIR=frBwClassPIR, logGmtDate=logGmtDate, atmPortQueueAlgorithm=atmPortQueueAlgorithm, logNetwork=logNetwork, atmTrkRetainedLinks=atmTrkRetainedLinks, atmEndPtAdminStatus=atmEndPtAdminStatus, atmEndptMinAdjustICA=atmEndptMinAdjustICA, cirLineRTCBipolarViolations=cirLineRTCBipolarViolations, trunkRTCTxBurstyDataACellsDropped=trunkRTCTxBurstyDataACellsDropped, frLportCnfEntry=frLportCnfEntry, frEndptTxBytesDscds=frEndptTxBytesDscds, atmDiscardVcqClpThs=atmDiscardVcqClpThs, trunkRemNodeId=trunkRemNodeId, frpComment=frpComment, trunkRTCNonTimeStampedPktsXmitted=trunkRTCNonTimeStampedPktsXmitted, trunkRTCAtmCellHeaderHecErrors=trunkRTCAtmCellHeaderHecErrors, atmTrkStatsTxHiPrioCellDrps=atmTrkStatsTxHiPrioCellDrps, frEndptTxFrmsCirs=frEndptTxFrmsCirs, frLportClockType=frLportClockType, frpRTCCLLMFramesTx=frpRTCCLLMFramesTx, connLocalSlot=connLocalSlot, atmPortStatPayldErrs=atmPortStatPayldErrs, atmViolRxs=atmViolRxs, frEndPtLpbkState=frEndPtLpbkState, frLportSrDSR=frLportSrDSR, frpRTCFramesRcvdInvalidFormat=frpRTCFramesRcvdInvalidFormat, atmEndptFRTT=atmEndptFRTT, atmPortIlmiEventThresh=atmPortIlmiEventThresh, frpPortSpeed=frpPortSpeed, atmBwClassIBS=atmBwClassIBS, atmBwClassOeHiCLP=atmBwClassOeHiCLP, atmEndptHiCLP=atmEndptHiCLP, voiceStatSprvPktsRcvs=voiceStatSprvPktsRcvs, connRTCRcvdBytes=connRTCRcvdBytes, portsInfoLine=portsInfoLine, atmTrkStatsRxVoPktDrps=atmTrkStatsRxVoPktDrps, connRemoteMaxPkts=connRemoteMaxPkts, realTimeCountersGroup=realTimeCountersGroup, frEndptIndex=frEndptIndex, trunkRTCLossOfSignal=trunkRTCLossOfSignal, connRTCLine=connRTCLine, trunkRTCPktsXmitted=trunkRTCPktsXmitted, atmEndptFastDnICA=atmEndptFastDnICA, trunkLocalSlot=trunkLocalSlot, maintLogFilterTimeMax=maintLogFilterTimeMax, maintLogFilterWindow=maintLogFilterWindow, portsInfoPortSpeed=portsInfoPortSpeed, frLportRxBytes=frLportRxBytes, frEndptSubType=frEndptSubType, maintLogTable=maintLogTable, cirLineStatusAlarm=cirLineStatusAlarm, portsInfoEntry=portsInfoEntry, frpLocalSlot=frpLocalSlot, atmTrkShareLcn=atmTrkShareLcn, voiceChannelDtPlayOutDelay=voiceChannelDtPlayOutDelay, atmEndptOeBCM=atmEndptOeBCM, atmPortQueueType=atmPortQueueType, atmEndptOeCDVT0=atmEndptOeCDVT0, frLportCllmTxBytes=frLportCllmTxBytes, frEndptRxBytesDscds=frEndptRxBytesDscds, cirLineLineNumber=cirLineLineNumber, atmTrkStatsTxTsCellDrps=atmTrkStatsTxTsCellDrps, frpRTCTxProtocolTimeOutCount=frpRTCTxProtocolTimeOutCount, atmBwClassOeCIR=atmBwClassOeCIR, atmTrkGtwyChCount=atmTrkGtwyChCount, frLportUpRNR=frLportUpRNR, frEndPtPort=frEndPtPort, atmTrkStatsTxCbrCellDrps=atmTrkStatsTxCbrCellDrps)
mibBuilder.exportSymbols("STRATACOM-MIB", atmBwClassFastDnICA=atmBwClassFastDnICA, frpRTCFramesXmitted=frpRTCFramesXmitted, atmPortVcCount=atmPortVcCount, connRemoteSlot=connRemoteSlot, frLportDeFrmsDrops=frLportDeFrmsDrops, trunkRTCTxHighPriorityCellsDropped=trunkRTCTxHighPriorityCellsDropped, voiceStatSprvPktsXmits=voiceStatSprvPktsXmits, atmEndptRtdTestDelay=atmEndptRtdTestDelay, voiceEndptOperStatus=voiceEndptOperStatus, svplus=svplus, connRemoteNodeId=connRemoteNodeId, frEndptRxBytesDes=frEndptRxBytesDes, trunkRTCTimeStampedPktsDropped=trunkRTCTimeStampedPktsDropped, atmEndptSubType=atmEndptSubType, frEndPtEgressQDepth=frEndPtEgressQDepth, voiceEndptTrkAvoidType=voiceEndptTrkAvoidType, atmEndptBCM=atmEndptBCM, frLportTxFrmsBecns=frLportTxFrmsBecns, connectionOpStatus=connectionOpStatus, connectionClassOfService=connectionClassOfService, frpRTCLmiInvalidStatusEnquires=frpRTCLmiInvalidStatusEnquires, frEndptMapEndptPtr=frEndptMapEndptPtr, atmEndptScrPlc=atmEndptScrPlc, atmBwClassMinAdjustICA=atmBwClassMinAdjustICA, voiceChannelDialType=voiceChannelDialType, connRTCBytesRxExcessCir=connRTCBytesRxExcessCir, connRTCRxSupervisoryPkts=connRTCRxSupervisoryPkts, atmTrkTrnsCap=atmTrkTrnsCap, trunkRTCHighPriorityPktsDropped=trunkRTCHighPriorityPktsDropped, frEndptTxFrmsDscds=frEndptTxFrmsDscds, atmPortLmiStatEnqRetry=atmPortLmiStatEnqRetry, frLportMaxTxQDepth=frLportMaxTxQDepth, voiceChannelRecvSigDBit=voiceChannelRecvSigDBit, atmEndptAdminStatus=atmEndptAdminStatus, atmNextPtr=atmNextPtr, connDAX=connDAX, connStatusAlarm=connStatusAlarm, atmTrkStatsTxVoPktDrps=atmTrkStatsTxVoPktDrps, atmPortIlmiVpi=atmPortIlmiVpi, frAxPortsCfgSvcRatio=frAxPortsCfgSvcRatio, ppaErrorFlushAll=ppaErrorFlushAll, atmPortQueueEfciTh=atmPortQueueEfciTh, frLportECNQThresh=frLportECNQThresh, cirLineEntry=cirLineEntry, atmEndptBWClass=atmEndptBWClass, atmEndptLoCLP=atmEndptLoCLP, trunkRTCEntry=trunkRTCEntry, frLportCllmRxFrms=frLportCllmRxFrms, logMsg=logMsg, atmPortStatLmiStatAckRxs=atmPortStatLmiStatAckRxs, frTestFailure=frTestFailure, frLportCrcErrors=frLportCrcErrors, trunkRTCTxBurstyDataBClpCellsDropped=trunkRTCTxBurstyDataBClpCellsDropped, atmBwClassRateUpICA=atmBwClassRateUpICA, voiceStatEntry=voiceStatEntry, frEndptDesc=frEndptDesc, atmEndPointFailure=atmEndPointFailure, frEndPtOpStatus=frEndPtOpStatus, frLportSeqnmErrUnis=frLportSeqnmErrUnis, frLportDscdQTxFrms=frLportDscdQTxFrms, frBwClassOeCMAX=frBwClassOeCMAX, frpRTCFramesXmittedWithFECN=frpRTCFramesXmittedWithFECN, frLportStatTxUnis=frLportStatTxUnis, voiceEndptEntry=voiceEndptEntry, frpEntry=frpEntry, atmPortStatEntry=atmPortStatEntry, atmPortLmiPollEnable=atmPortLmiPollEnable, connStatus=connStatus, databaseSampleFreq=databaseSampleFreq, atmEndptEntry=atmEndptEntry, atmEndptCDVT0=atmEndptCDVT0, atmPortStatIsuEmptys=atmPortStatIsuEmptys, frpRTCAsyncStatusCounter=frpRTCAsyncStatusCounter, atmPortPort=atmPortPort, frBwClassDescription=frBwClassDescription, frEndPtchanCLPtoDEmap=frEndPtchanCLPtoDEmap, errStatusTableEntry=errStatusTableEntry, cirLineRTCEntry=cirLineRTCEntry, frEndPtSlot=frEndPtSlot, frIxPortsCfgMaxTxQDepth=frIxPortsCfgMaxTxQDepth, atmBwClassMIR=atmBwClassMIR, atmEndPtTable=atmEndPtTable, atmPortStatLmiUpdtStatTxs=atmPortStatLmiUpdtStatTxs, trunkServiceObjects=trunkServiceObjects, atmTrkStatsEntry=atmTrkStatsEntry, frBwClassEcnQSize=frBwClassEcnQSize, atmEndptMapConnPtr=atmEndptMapConnPtr, frBwClassBe=frBwClassBe, atmEndptOeCIR=atmEndptOeCIR, frEndptRxFrmsDscds=frEndptRxFrmsDscds, voiceChannelEchoNlp=voiceChannelEchoNlp, frPortsCfgLine=frPortsCfgLine, connRemoteDLCI=connRemoteDLCI, cirLineRTCTable=cirLineRTCTable, frNextOnPortPtr=frNextOnPortPtr, connRTCRcvdFrames=connRTCRcvdFrames, nodeFsDecRate=nodeFsDecRate, frLportIDEMap=frLportIDEMap, atmPortEntry=atmPortEntry, connGroup=connGroup, frpTable=frpTable, connActive=connActive, atmTrkStatsTxVoCellDrps=atmTrkStatsTxVoCellDrps, atmBwClassEfciQSize=atmBwClassEfciQSize, voiceChannelRecvSigABit=voiceChannelRecvSigABit, atmEndptMFS=atmEndptMFS, atmEndptCIR=atmEndptCIR, trunkRTCCrcErrors=trunkRTCCrcErrors, frEndptTestType=frEndptTestType, frLportTxFrmsFecns=frLportTxFrmsFecns, frLportToutCntUnis=frLportToutCntUnis, trunkRTCVoicePktsDropped=trunkRTCVoicePktsDropped, connRTCSecondsDsiEnabled=connRTCSecondsDsiEnabled, frEndptRxFrmsDeDscds=frEndptRxFrmsDeDscds, atmPortQueueTable=atmPortQueueTable, trunkAlarmState=trunkAlarmState, frpRTCLine=frpRTCLine, trunkRTCHighPriorityCellsTx2Line=trunkRTCHighPriorityCellsTx2Line, connectionLocOSpacePkts=connectionLocOSpacePkts, atmTrkBdataBTxHiClp=atmTrkBdataBTxHiClp, trunkComment=trunkComment, connRTCRcvdPktsDiscarded=connRTCRcvdPktsDiscarded, frpRTCTable=frpRTCTable, connRTCRcvdBytesDiscarded=connRTCRcvdBytesDiscarded, segNodeName=segNodeName, aitEndPtConnIndex=aitEndPtConnIndex, errCode=errCode, connOeIndex=connOeIndex, connRemoteChannel=connRemoteChannel, frLportSrDTR=frLportSrDTR, cirLineRTCFrameBitErrors=cirLineRTCFrameBitErrors, atmBwClassFGCRA=atmBwClassFGCRA, atmTrkVPI=atmTrkVPI, connBumpFailure=connBumpFailure, voiceEndptMapChannel=voiceEndptMapChannel, segLine=segLine, atmEndptPCR=atmEndptPCR, snmpAgents=snmpAgents, frEndptEntry=frEndptEntry, atmEndptIBS=atmEndptIBS, nodeRstTimeout=nodeRstTimeout, frBwClassEntry=frBwClassEntry, atmOtherEndptIndex=atmOtherEndptIndex, frEndptGroupDesc=frEndptGroupDesc, atmEndptOeCCDV=atmEndptOeCCDV, connRTCXmitFramesDiscarded=connRTCXmitFramesDiscarded, frEndptOeEcnQSize=frEndptOeEcnQSize, logGroup=logGroup, ppaErrorLastEcode=ppaErrorLastEcode, trunkRTCPktCrcErrors=trunkRTCPktCrcErrors, atmBwClassConType=atmBwClassConType, frpRTCPort=frpRTCPort, frAxPortsCfgLogPort=frAxPortsCfgLogPort, atmEndptVSVD=atmEndptVSVD, frBwClassOeBe=frBwClassOeBe, frEndptCMAX=frEndptCMAX, connRTCXmitPkts=connRTCXmitPkts, atmPortStatLmiUpdStatRxs=atmPortStatLmiUpdStatRxs, atmBwClassOePercUtil=atmBwClassOePercUtil, connPrefRouteDesc=connPrefRouteDesc, trapPduString=trapPduString, trunkLocalLine=trunkLocalLine, voiceChannelAdminStatus=voiceChannelAdminStatus, frEndPtRowStatus=frEndPtRowStatus, frpRTCFramesRcvdAlignmentErrors=frpRTCFramesRcvdAlignmentErrors, atmBwClassHiCLP=atmBwClassHiCLP, atmBwClassUPC=atmBwClassUPC, connRTCRcvdPkts=connRTCRcvdPkts, connectionEntry=connectionEntry, atmEndptPolicing=atmEndptPolicing, voiceStatTable=voiceStatTable, connVcQueThreshold=connVcQueThreshold, trunkRTCBurstyDataBClpPktsTx2Line=trunkRTCBurstyDataBClpPktsTx2Line, frEndPtBc=frEndPtBc, atmPortStatCellsRxs=atmPortStatCellsRxs, atmPortQueueAdminStatus=atmPortQueueAdminStatus, frLportSlotIndex=frLportSlotIndex, atmTrkLoopClock=atmTrkLoopClock, frLportStatEnqNnis=frLportStatEnqNnis, trapsConfig=trapsConfig, trunkStatusAlarm=trunkStatusAlarm, frEndPtchanDEtoCLPmap=frEndPtchanDEtoCLPmap, cirLineRTCAllOnesInTimeslot16=cirLineRTCAllOnesInTimeslot16, atmBwClassVcQSize=atmBwClassVcQSize, atmClpTxs=atmClpTxs, frPortsCfgNode=frPortsCfgNode, atmFramesRxPorts=atmFramesRxPorts, atmEndptMapPort=atmEndptMapPort, frLportRxFrms=frLportRxFrms, nodeGrpName=nodeGrpName, atmBwClassOeIBS=atmBwClassOeIBS, connectionType=connectionType, frLportLinkTimer=frLportLinkTimer, frLportPortSpeed=frLportPortSpeed, atmEndptStatTable=atmEndptStatTable, frIxPortsCfgECNQThresh=frIxPortsCfgECNQThresh, frIxPortsCfgCLLMTimer=frIxPortsCfgCLLMTimer, connTXR=connTXR, aitEndPtNodeName=aitEndPtNodeName, cmpaErrorLastDesc=cmpaErrorLastDesc, atmPortQueueEntry=atmPortQueueEntry, frEndptRxBytesCirs=frEndptRxBytesCirs, frEndptTrkAvoidType=frEndptTrkAvoidType, atmEndptGroupDesc=atmEndptGroupDesc, trunkRTCBipolarViolations=trunkRTCBipolarViolations, trapConfigEntry=trapConfigEntry, frEndPtInitialBurstSize=frEndPtInitialBurstSize, atmTrkPassSync=atmTrkPassSync, frEndptTxBytes=frEndptTxBytes, packetGroup=packetGroup, atmPortLmiVci=atmPortLmiVci, frpPortType=frpPortType, frLportCLLMTimer=frLportCLLMTimer, frEndptMapEntry=frEndptMapEntry, frPortsCfgVcPtr=frPortsCfgVcPtr, frpRTCLmiStatusEnquires=frpRTCLmiStatusEnquires, frEndptEcnQSize=frEndptEcnQSize, trunkRemPort=trunkRemPort, connServerTable=connServerTable, trunkRTCBurstyDataAEfcnPktsTx2Line=trunkRTCBurstyDataAEfcnPktsTx2Line, connectionLocalStr=connectionLocalStr, atmBwClassOeCBS=atmBwClassOeCBS, switchServiceObjects=switchServiceObjects, trunkRTCMulticastPktsDropped=trunkRTCMulticastPktsDropped, switchIfIndex=switchIfIndex, frLportFirstVcPtr=frLportFirstVcPtr, frEndptRxFrms=frEndptRxFrms, atmTrkSvcVpiLow=atmTrkSvcVpiLow, frEndptOeVcQSize=frEndptOeVcQSize, segPort=segPort, switchIfAdmStatus=switchIfAdmStatus, connRTCTable=connRTCTable, atmTrkOeName=atmTrkOeName, switchInterfaces=switchInterfaces, atmEndptUPC=atmEndptUPC, atmEndptPCR0=atmEndptPCR0, connRTCXmitPktsSupervisory=connRTCXmitPktsSupervisory, frBwClassPercUtil=frBwClassPercUtil, atmBwClassBCM=atmBwClassBCM, errStatusDesc=errStatusDesc, atmBwClassEnableFST=atmBwClassEnableFST, frEndptStatTable=frEndptStatTable, connectionLocOSpaceBdbCmax=connectionLocOSpaceBdbCmax, atmPortStatBufferOvfls=atmPortStatBufferOvfls, atmBwClassCCDV=atmBwClassCCDV, frEndptRxPktsDscds=frEndptRxPktsDscds, atmBwClassOeBCM=atmBwClassOeBCM, atmTrkMaxChanPort=atmTrkMaxChanPort, atmNextOnPortPtr=atmNextOnPortPtr, switchIfPhysPort=switchIfPhysPort, atmEndptConnDesc=atmEndptConnDesc, trunkRTCBurstyDataBCellsTx2Line=trunkRTCBurstyDataBCellsTx2Line, portsInfoPortState=portsInfoPortState, atmTrkRcvCap=atmTrkRcvCap)
mibBuilder.exportSymbols("STRATACOM-MIB", Active=Active, trunkRTCFrameSlips=trunkRTCFrameSlips, frEndptRxBytes=frEndptRxBytes, atmNonCompRxs=atmNonCompRxs, atmOamTxs=atmOamTxs, portsInfoNode=portsInfoNode, connRTCRcvdFramesDiscarded=connRTCRcvdFramesDiscarded, frLportOperStatus=frLportOperStatus, voiceConnPtr=voiceConnPtr, segOeEndPt=segOeEndPt, alarmTrapSequenceNumber=alarmTrapSequenceNumber, atmTrkSvcInUse=atmTrkSvcInUse, frEndPtEcnQSize=frEndPtEcnQSize, frBwClassOeEcnQSize=frBwClassOeEcnQSize, atmEndPtQIR=atmEndPtQIR, frPortsCfgErrThresh=frPortsCfgErrThresh, atmEndptVcQSize=atmEndptVcQSize, atmPortStatAisRxs=atmPortStatAisRxs, connAvailIndex=connAvailIndex, atmEndptTable=atmEndptTable, voiceOtherEndptIndex=voiceOtherEndptIndex, voiceEndPointFailure=voiceEndPointFailure, atmEndPtPIR=atmEndPtPIR, atmPortFirstVcPtr=atmPortFirstVcPtr, atmPortStatNonZeroGfcs=atmPortStatNonZeroGfcs, frpRTCFramesRcvdIllegalLen=frpRTCFramesRcvdIllegalLen, switchIfCtrlerId=switchIfCtrlerId, atmBwClassOePIR=atmBwClassOePIR, frLportNNIStatus=frLportNNIStatus, voiceChannelEchoTone=voiceChannelEchoTone, frEndptTxFrmsDes=frEndptTxFrmsDes, atmBwClassCLPTagging=atmBwClassCLPTagging, trunkRTCTxTimeStampCellsDropped=trunkRTCTxTimeStampCellsDropped, frIxPortsCfgExtConFail=frIxPortsCfgExtConFail, atmTrkStatsRxHiPrioPktDrps=atmTrkStatsRxHiPrioPktDrps, atmEndptRateUpICA=atmEndptRateUpICA, atmTrkStatsTxAbrCellDrps=atmTrkStatsTxAbrCellDrps, atmEndptPercUtil=atmEndptPercUtil, atmEndptOeMFS=atmEndptOeMFS, atmEndptRateDnICA=atmEndptRateDnICA, frEndptBWClass=frEndptBWClass, atmEndptMapTable=atmEndptMapTable, atmPortStatIlmiGetTxs=atmPortStatIlmiGetTxs, cirLineRTCLossesOfSignal=cirLineRTCLossesOfSignal, atmDiscardQbinClpThs=atmDiscardQbinClpThs, frIxPortsCfgUpRNR=frIxPortsCfgUpRNR, frLportUpdtTxUnis=frLportUpdtTxUnis, frConnPtr=frConnPtr, shelfCnfgStatBcktIntvl=shelfCnfgStatBcktIntvl, currentMaxLogIndex=currentMaxLogIndex, trunkCardType=trunkCardType, cirLineStatus=cirLineStatus, trunkRTCTxVoiceCellsDropped=trunkRTCTxVoiceCellsDropped, voiceChannelXmitSigBBit=voiceChannelXmitSigBBit, frPortsCfgTable=frPortsCfgTable, frEndPtTable=frEndPtTable, atmBwClassOeQIR=atmBwClassOeQIR, atmEndptOeIBS=atmEndptOeIBS, nodeGrpGateway=nodeGrpGateway, frPortsCfgAsyncUpd=frPortsCfgAsyncUpd, ppaErrorEcode=ppaErrorEcode, atmTrkOeNdType=atmTrkOeNdType, atmPortStatIlmiTrapRxs=atmPortStatIlmiTrapRxs, trunkRTCVoiceCellsTx2Line=trunkRTCVoiceCellsTx2Line, voiceEndptRateType=voiceEndptRateType, eventFilterEntry=eventFilterEntry, atmEndptOePercUtil=atmEndptOePercUtil, errReqId=errReqId, voiceOtherEndptEncoding=voiceOtherEndptEncoding, connRTCBytesRxWithDE=connRTCBytesRxWithDE, strmErrors=strmErrors, frNoRouteFoundFailure=frNoRouteFoundFailure, frEndPtCIR=frEndPtCIR, atmPortStatLmiStatTxs=atmPortStatLmiStatTxs, svnode=svnode, atmEndptTestType=atmEndptTestType, connGroupFlag=connGroupFlag, frBwClassOeVcQSize=frBwClassOeVcQSize, voiceEndptMapEntry=voiceEndptMapEntry, portsInfoPortType=portsInfoPortType, atmTrkStatsTxBdataBCellDrps=atmTrkStatsTxBdataBCellDrps, atmEndptPIR=atmEndptPIR, errStatusTable=errStatusTable, trunkClpHighDropThreshold=trunkClpHighDropThreshold, atmTrkOeDomain=atmTrkOeDomain, atmEndptIndex=atmEndptIndex, atmTrkDerouteDelayTimer=atmTrkDerouteDelayTimer, voiceChannelIfTypeName=voiceChannelIfTypeName, frBwClassOeCIR=frBwClassOeCIR, aitEndPtAdminStatus=aitEndPtAdminStatus, nodeGroup=nodeGroup, strmSwitchMIB=strmSwitchMIB, cirLineInterface=cirLineInterface, connABitStatus=connABitStatus, connRTCEntry=connRTCEntry, connRouteMaster=connRouteMaster, frLportCnfTable=frLportCnfTable, managerIPaddress=managerIPaddress, frPortsCfgLinkTimer=frPortsCfgLinkTimer, frLportEFCItoBECN=frLportEFCItoBECN, connOperStatus=connOperStatus, atmEndptStatEntry=atmEndptStatEntry, atmTrkBdataBTxQlen=atmTrkBdataBTxQlen, voiceChannelRecvSigBBit=voiceChannelRecvSigBBit, segSubChn1=segSubChn1)

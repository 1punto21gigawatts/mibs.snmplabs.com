#
# PySNMP MIB module A3Com-System-r8-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3Com-System-r8-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:09:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
MacAddress, = mibBuilder.importSymbols("RFC1286-MIB", "MacAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Gauge32, Counter32, Counter64, Bits, NotificationType, Unsigned32, TimeTicks, IpAddress, ModuleIdentity, iso, Integer32, ObjectIdentity, enterprises, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Gauge32", "Counter32", "Counter64", "Bits", "NotificationType", "Unsigned32", "TimeTicks", "IpAddress", "ModuleIdentity", "iso", "Integer32", "ObjectIdentity", "enterprises", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
a3ComSys = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13))
a3ComSysID = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 1))
a3ComChip = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 2))
a3ComMem = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 3))
a3ComBrd = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 4))
a3ComAudit = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 5))
a3ComTime = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 6))
a3ComAccCtl = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 7))
a3ComSysMisc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 8))
a3ComFW = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 9))
a3ComBoot = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 10))
a3ComLastBoot = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 11))
a3ComFileMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 12))
a3ComFileList = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9))
a3ComFmCksum = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 10))
a3ComFileInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 11))
a3ComRecovery = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 13, 13))
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3sysVersion = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysVersion.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysVersion.setDescription("A text string containing general system information, including the package identifier and the system's software release number.")
a3sysPlatformDescr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysPlatformDescr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysPlatformDescr.setDescription('A text string describing the physical platform or chassis on which the system is running.')
a3sysPlatformID = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysPlatformID.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysPlatformID.setDescription('An OID defining the system platform.')
a3sysCallerID = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysCallerID.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysCallerID.setDescription('A text string defined by the user. This string can be used by a system running PPP as a unique identification of itself to its peer when communicating over a PPP link. ')
a3sysChipTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1), )
if mibBuilder.loadTexts: a3sysChipTable.setReference('NetBuilderII Ref. Guide: System Service Parameters: CPUboardInfo')
if mibBuilder.loadTexts: a3sysChipTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipTable.setDescription('This table contains information about the chips that are used in the CPU board of the system.')
a3sysChipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysChipSlotIndex"), (0, "A3Com-System-r8-MIB", "a3sysChipIndex"))
if mibBuilder.loadTexts: a3sysChipEntry.setReference('NetBuilderII Ref. Guide: System Service Parameters: CPUboardInfo')
if mibBuilder.loadTexts: a3sysChipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipEntry.setDescription('Each entry in this table contains information about one of the chips installed in the CPU module.')
a3sysChipSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysChipSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipSlotIndex.setDescription('This identifies a specific slot (and hence, a specific board). All the Chips described with this index are located on a single board.')
a3sysChipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipIndex.setDescription('This identifies a specific chip on the board identified by a3sysChipSlotIndex.')
a3sysChipName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysChipName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipName.setDescription('This provides a readable name for the chip.')
a3sysChipDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysChipDescr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChipDescr.setDescription('This provides general information about the chip, including its part number and revision number.')
a3sysMemTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1), )
if mibBuilder.loadTexts: a3sysMemTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemTable.setDescription("This table contains information about the system's memory configurations.")
a3sysMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysMemSlotIndex"), (0, "A3Com-System-r8-MIB", "a3sysMemIndex"))
if mibBuilder.loadTexts: a3sysMemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemEntry.setDescription('Each entry in this table contains information about a specific memory component. The information includes the memory type, its starting address and its size.')
a3sysMemSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysMemSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemSlotIndex.setDescription('This identifies the slot (and hence the board) that supports the memory elements identified by this entry in the table.')
a3sysMemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysMemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemIndex.setDescription('The index into this table. Each memory component is identified by a unique value of this object. This is specific to the board identified by a3sysMemSlotIndex.')
a3sysMemType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("ram-instruction", 2), ("ram-data", 3), ("ram-shared", 4), ("rom-fprom", 5), ("rom-eeprom", 6), ("ram-total", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysMemType.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemType.setDescription('This object identifies the type of the memory component.')
a3sysMemStartAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysMemStartAdd.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemStartAdd.setDescription('The starting address of the memory component.')
a3sysMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysMemSize.setDescription('The size of the memory component, in bytes.')
a3sysSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSlotNumber.setDescription('The number of slots (empty or not) in the system')
a3sysBrdTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2), )
if mibBuilder.loadTexts: a3sysBrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdTable.setDescription('A table that contains information about the IO boards in this system.')
a3sysBrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysSlotIndex"))
if mibBuilder.loadTexts: a3sysBrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdEntry.setDescription('A list of information for each IO board in the system.')
a3sysSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSlotIndex.setDescription('The slot number which this board occupies.')
a3sysBrdDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysBrdDescr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdDescr.setDescription('This contains general information about the Board, including the model type, the serial number, and manufacturing information.')
a3sysBrdPathCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysBrdPathCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdPathCapacity.setDescription('The number of physical ports supported by this board.')
a3sysBrdOID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysBrdOID.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdOID.setDescription('The Object Identifier assigned to this Board.')
a3sysBrdReset = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysBrdReset.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdReset.setDescription('When this object is set to reset(2), the IO board in the slot specified by this instance identifier of this object is reset. If a GET request is sent for the value of this object, other(1) is returned.')
a3sysBrdFwVers = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 4, 2, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysBrdFwVers.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBrdFwVers.setDescription("This object returns the version of the firmware that is running on this network interface board. A list of all the OIDs assigned to 3Com router firmware can be ftp'd from ftp.3com.com.")
a3sysAuditTrailType = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("universal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysAuditTrailType.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysAuditTrailType.setDescription('This object allows the user to determine the format of the time/date stamp that is included with each audit trail message the system generates. This only applies if there is a Network Control Server for the IBM PC/AT (NCS/AT) or Remote Boot and Configuration Services (RBCS) server on the attached network. Audit trail messages are generated by various network events and are displayed on the NCS or RBCS console.')
a3sysLogServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysLogServerAddress.setStatus('deprecated')
if mibBuilder.loadTexts: a3sysLogServerAddress.setDescription("The address of the NCS or the RBCS that serves as the log server for the system. The log server receives all of the system's audit trail messages.")
a3sysDate = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 6, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysDate.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDate.setDescription('The current date and time as reflected by the system clock. The date is displayed via the User interface and Audit Trail Messages as yy/mm/dd hh:mm[:ss]. This same format must be used when setting the Date.')
a3sysDSTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-120, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysDSTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDSTime.setDescription('This parameter specifies the displacement, in minutes, from non-daylight savings time. The a3sysDSTime object, along with the a3sysTimeZone object, allows the system to support Universal time for network communications spanning different time zones.')
a3sysTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-720, 720))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysTimeZone.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTimeZone.setDescription("This object specifies the number of minutes displacement west of Greenwich the system's site is located. A negative number for this parameter indicates how many minutes displacement east of Greenwich the site is located. A positive number indicates the number of minutes west of Greenwich.")
a3sysRemoteAccess = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysRemoteAccess.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysRemoteAccess.setDescription('This object determines whether another device can access this system via REMOTE')
a3sysTelnetAccess = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysTelnetAccess.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTelnetAccess.setDescription('This object determines whether another device can access this system via TELNET')
a3sysConsoleAccess = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysConsoleAccess.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysConsoleAccess.setDescription('This object determines whether another device can access this system via the Console')
a3sysSNMPAccess = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabledTraps", 1), ("enabledNoTraps", 2), ("disabledTraps", 3), ("disabledNoTraps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPAccess.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPAccess.setDescription('This object determines whether another device can access this system via SNMP. Note, once SNMP access is disabled, the NMS will no longer be able to access this system via SNMP. If this is set to enabledTraps(1), the system allows SNMP access and will send traps when appropriate. If this is set to enabledNoTraps(2), the system allows SNMP access, but no traps will be sent. If this is set to disabledTraps, the system does not allow SNMP access, but will send traps when appropriate. If this is set to disabledNoTraps(4), the system does not allow SNMP access and does not send any traps.')
a3sysSNMPCommTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5), )
if mibBuilder.loadTexts: a3sysSNMPCommTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommTable.setDescription('This table contains all the community strings known to the SNMP agent.')
a3sysSNMPCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysSNMPCommString"))
if mibBuilder.loadTexts: a3sysSNMPCommEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommEntry.setDescription('Each entry in the table contains information about a single community string. ')
a3sysSNMPCommString = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysSNMPCommString.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommString.setDescription('This identifies a specific community string.')
a3sysSNMPCommAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2))).clone('readOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPCommAccess.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommAccess.setDescription('This identifies the level of access allowed for this community string.')
a3sysSNMPCommTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("genericOnly", 1), ("authenOnly", 2), ("allTraps", 3), ("noTraps", 4))).clone('noTraps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPCommTrap.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommTrap.setDescription('This specifies which traps get sent to the managers specified by this community string.')
a3sysSNMPCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPCommStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3sysSNMPMgrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6), )
if mibBuilder.loadTexts: a3sysSNMPMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrTable.setDescription('This table contains the Managers that are allowed to use the community strings identified in a3sysSNMPCommTable. Each Manager is identified by its IP address.')
a3sysSNMPMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysSNMPMgrCommString"), (0, "A3Com-System-r8-MIB", "a3sysSNMPMgrAddress"))
if mibBuilder.loadTexts: a3sysSNMPMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrEntry.setDescription('Each entry identifies a single Manager, community string pair.')
a3sysSNMPMgrCommString = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysSNMPMgrCommString.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrCommString.setDescription('This identifies a specific community string.')
a3sysSNMPMgrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysSNMPMgrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrAddress.setDescription('This identifies a single Management station that is allowed to use the community string associated with this entry. The set of all entries with same value of a3sysSNMPMgrCommString identifies all the Managers that are allowed to use that community string.')
a3sysSNMPMgrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPMgrMask.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrMask.setDescription('This object can be used to mask part of the IP address specified by a3sysSNMPMgrAddress. The use of this mask can then be used to identify a range of addresses that are allowed to use this community string.')
a3sysSNMPMgrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 6, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSNMPMgrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSNMPMgrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB for specific instructions on how to do this.')
a3sysTelnetMgrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 7), )
if mibBuilder.loadTexts: a3sysTelnetMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTelnetMgrTable.setDescription('This table contains the IP addresses that are allowed to use Telnet to access to the NetBuilder in the TelnetManager table.')
a3sysTelnetMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 7, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysTelnetMgrAddress"))
if mibBuilder.loadTexts: a3sysTelnetMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTelnetMgrEntry.setDescription('Each entry identifies a single Manager, community string pair.')
a3sysTelnetMgrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysTelnetMgrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTelnetMgrAddress.setDescription('This identifies a single Management station that is allowed to use the Telnet to manage the NetBuilder. Maximally, six (6) IP addresses can be configured in each NB.')
a3sysTelnetMgrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 7, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysTelnetMgrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTelnetMgrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB for specific instructions on how to do this.')
a3sysPasswordTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8), )
if mibBuilder.loadTexts: a3sysPasswordTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysPasswordTable.setDescription("This table contains the system's passwords.")
a3sysPasswordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysUserName"), (0, "A3Com-System-r8-MIB", "a3sysOldPassword"))
if mibBuilder.loadTexts: a3sysPasswordEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysPasswordEntry.setDescription('Each entry identifies a single system password.')
a3sysPwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysPwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysPwStatus.setDescription("User Status. `invalid' is used to indicate this user is no longer allowed to access this device, and the table entry may subsequently be re-used. Note that the Status of default Users cannot be set to invalid.")
a3sysUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysUserName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUserName.setDescription("An ASCII string for the User Name. Empty strings are not allowed. The index column for the User Table. There are two default users defined, 'root' and 'user'.")
a3sysUserLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("monitor", 1), ("secureMonitor", 2), ("manager", 3), ("specialist", 4), ("security", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUserLevel.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUserLevel.setDescription('User Access Level defining the scope of management allowed for this user. Note that the access level of default Users cannot be changed.')
a3sysOldPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysOldPassword.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysOldPassword.setDescription('The current password.')
a3sysNewPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 8, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysNewPassword.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysNewPassword.setDescription('The new password.')
a3sysSnmpPasswordCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysSnmpPasswordCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysSnmpPasswordCtl.setDescription("This object indicates whether this system's passwords can be changed via snmp.")
a3sysNetMapTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysNetMapTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysNetMapTime.setDescription("The number of seconds between broadcasts of the system's address on the attached network. This only applies to 3Com's NETMap protocol. If this object is set to 0, the broadcasting of the system's address is disabled.")
a3sysUIBinary = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUIBinary.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUIBinary.setDescription('If on, the system is allowed to negotiate for binary transmission when a Telnet connection is made.')
a3sysChangeTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysChangeTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysChangeTimestamp.setDescription('This object contains the value of sysUpTime when the most recent change was made to this system, either via the Console, TELNET, or through SNMP.')
a3sysCpuUtil = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysCpuUtil.setDescription('This object provides a measure of the current utilization of the CPU on this system.')
a3sysCpuBrdMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysCpuBrdMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysCpuBrdMacAddr.setDescription("The system's MAC address. For those devices whose CPU boards contain a MAC address, this object provides the value of that address (NB2's). For those devices whose CPU boards don't contain a MAC address (NB1's), this provides the MAC address of the first interface.")
a3sysExpMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysExpMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysExpMacAddr.setDescription('This identifies the MAC address to which the @m symbol is expanded when doing file copies.')
a3sysVportTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysVportTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysVportTimestamp.setDescription('This specifies the value of sysUpTime when the last virtual port was added or deleted. This object should be used to determine if and when the set of virtual ports supported by this system has changed.')
a3sysDefDrive = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("driveA", 1), ("driveB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDefDrive.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDefDrive.setDescription('This object identifies the current default drive for this system.')
a3sysDefDriveType = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("floppy", 1), ("flash", 2), ("unknown", 3), ("noDrive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDefDriveType.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDefDriveType.setDescription('This object identifies the current default drive type for this system.')
a3sysDriveStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noDrives", 1), ("driveA", 2), ("driveB", 3), ("driveAB", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDriveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDriveStatus.setDescription('This object identifies which disk drives are supported by this system. noDrives(1) means no disk drives are supported. driveA means only drive A is supported. driveB means only drive B is supported, while driveAB(4) means both drives A and B are supported.')
a3sysBogusDhcpSvr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysBogusDhcpSvr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBogusDhcpSvr.setDescription('This object has the IP address of the last seen bogus DHCP or BOOTP server.')
a3sysNb2EepromVers = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysNb2EepromVers.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysNb2EepromVers.setDescription('This object returns the version number of the EEPROM on a NetBuilderII. Various features are dependent on having the correct version of EEPROM resident on the NetBuilderII.')
a3sysX25Conns = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 8, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysX25Conns.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysX25Conns.setDescription('This object returns the number of active X25 connections currently maintained by the NetBuilder.')
a3sysFwSerBaudCons = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 1), ("bps110", 2), ("bps300", 3), ("bps600", 4), ("bps1200", 5), ("bps2400", 6), ("bps4800", 7), ("bps9600", 8), ("bps19200", 9), ("bps38400", 10), ("bps57600", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFwSerBaudCons.setReference('NBII CEC Module Installation Guide: Serial Port Parameter.')
if mibBuilder.loadTexts: a3sysFwSerBaudCons.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFwSerBaudCons.setDescription("This object sets the baud rate for the console port, which is located on the CEC module's connector/LEDC panel.")
a3sysFwSerBaudAux = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknown", 1), ("bps110", 2), ("bps300", 3), ("bps600", 4), ("bps1200", 5), ("bps2400", 6), ("bps4800", 7), ("bps9600", 8), ("bps19200", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFwSerBaudAux.setReference('NBII CEC Module Installation Guide: Serial Port Parameter.')
if mibBuilder.loadTexts: a3sysFwSerBaudAux.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFwSerBaudAux.setDescription("This object sets the baud rate for the auxiliary port, which is located on the CEC module's connector/LEDC panel.")
a3sysFwSelfTest = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("skip", 1), ("testOnce", 2), ("other", 3), ("loop", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFwSelfTest.setReference('NBII CEC Module Installation Guide: Self Test Parameter.')
if mibBuilder.loadTexts: a3sysFwSelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFwSelfTest.setDescription('This parameter determines how the system handles self tests when the system is powered on or reset. The system can be configured to skip its self tests, run self tests once, or run self tests continuously (loop).')
a3sysReBoot = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("stdReboot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysReBoot.setReference('NBII Ref. Guide, Commands: ReBoot.')
if mibBuilder.loadTexts: a3sysReBoot.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysReBoot.setDescription("This object can be used to reboot the system. If this object is set to stdReboot(2), the system's action is determined by the value of a3sysStartUpAction. If that object has the value monitor(1), the system will go into monitor mode. If that object has the value userListOnce(2) or userListForever(3), the system will attempt to reboot from the sources identified by the User Boot List. If this object is read, the value, other (1), will be returned.")
a3sysTestBootTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysTestBootTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTestBootTime.setDescription('The Test Boot Time indicates the number of seconds after a test reboot the system will automatically reboot. Upon reboot, the system will start up a timer initialized to the value of this object. The object a3sysTestRecoveryTimer contains the real time value of this timer. The timer will automatically start counting down after the system comes up. If this timer expires, the system will automatically reboot using the Primary Boot Source. To cancel the timer, the object a3sysTestRecoveryTimer must be set to zero. This provides a recovery mechanism for a system under test that loses management connectivity.')
a3sysStartUpAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("monitor", 1), ("userListOnce", 2), ("userListForever", 3), ("local", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysStartUpAction.setReference('NBII CEC Module Installation Guide: Initial Boot Type Parameter.')
if mibBuilder.loadTexts: a3sysStartUpAction.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysStartUpAction.setDescription('This parameter determines the boot source when the system is powered on or reset. If monitor (1) is chosen, the system enters monitor mode immediately. If userListOnce (2) is chosen, the system attempts to boot from primary and secondary sources defined by the User Boot List. (Specifics about the use of the secondary boot source are provided by a3sysBootSources.) This list may identify network boot sources or local floppy sources, or both. If userListForever (3) is chosen, the system will keep trying the sources listed in the User Boot List until one of them is successful. If local(4) is chosen, the system will boot from the local floppy. The name of the file used is identified by the value of a3sysUblFileName for the Primary Boot Source.')
a3sysTestRecoveryTimer = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysTestRecoveryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysTestRecoveryTimer.setDescription("This object contains the real time value of the Test Recovery Timer. When the system is performing a 'test boot' (ie, a boot when a3sysBootSources equals testWithPrimaryBackup (3)), the system will start a countdown timer initialized to the value of a3sysBootTime. If this timer is allowed to count down to zero, the system will reboot, this time using the primary boot source instead of the test boot source. If the timer is disabled, however, before it counts down (the timer is disabled by setting the value of this object to zero), the system won't reboot and will continue to run the test boot source's software. This timer is part of a comprehensive software update strategy. See the relevant 3Com manuals for more details.")
a3sysDirectedReBoots = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDirectedReBoots.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDirectedReBoots.setDescription('This is a counter that tracks the number of times the system has completed successfully a boot, no matter how the boot was initiated (power-on, front-panel-button reset, command line, or exception).')
a3sysExceptionReBoots = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysExceptionReBoots.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysExceptionReBoots.setDescription('This is a counter that tracks the number of times the system has crashed and a reboot sequence is begun by the exception handler. Note, some type of crashes are not able to update this counter due to various hardware lockups. Also note, this counter will be incremented when a user resets the system from the command line (RS). This will not be incremented, however, when the user reboots the system from the command line (RB).')
a3sysBootDump = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noDump", 1), ("monitor", 2), ("localDevice", 3), ("userList", 4), ("network", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysBootDump.setReference('NBII CEC Module Installation Guide: Dump Destination Parameter.')
if mibBuilder.loadTexts: a3sysBootDump.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBootDump.setDescription('This determines whether or not a memory dump is performed if the system fails due to a software problem. If noDump (1) is selected, the system will not attempt to perform a memory dump. If monitor (2) is selected, the system goes directly into monitor mode and waits for further commands. If localDevice (3) is selected, the system dumps its memory to the local storage device. Since the memory dump will require several floppy disks, the system will prompt the user via the User Interface to change disks. If userList (4) is selected, the system will upload its memory to the source specified in the User Boot List. Only the NetBuilder Remote Office and NetBuilder II support the network(5) option. If this is set, the parameters in entry four (dump) of a3sysUserBootListTable identify the destination.')
a3sysBootSources = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("primaryAndSecondary", 2), ("testWithPrimaryBackup", 3), ("secondary", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysBootSources.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysBootSources.setDescription("This parameter is used to specify how the entries in this table are used. If this object is set to primary(1), the system will use only the primary boot source when rebooting. (note, this is the entry where a3sysUblSource = primary(1)). If this object is set to primaryAndSecondary(2), the system will attempt to boot first from the primary boot source, and, if that fails (after a3sysUblMaxRetries attemps), the system will try the secondary boot source. If this object has the value testWithPrimaryBackup(3), the system, when rebooting, will perform a test boot using the 'test' boot source. Note, the NetBuilder Remote Office and NetBuilder II use entry 3 in a3sysUserBootListTable as the 'test' boot source (a3sysUblSource = test(3)), while other 3Com routers (NetBuilder Remote, NetBuilder Remote Control, NetBuilder Local, and NetBuilder Remote Access) don't support all 4 rows in a3sysUserBootListTable, and simply use the secondary boot source (a3sysUblSource = secondary(2)) to identify the 'test' boot source. After booting from the 'test' boot source, if the Test Recovery Timer (a3sysTestRecoveryTimer) is allowed to count down to zero, the system will reboot using the primary boot source. (see the reference guide for details about test booting). When in this mode, to prevent the system from rebooting using the primary boot source, the Test Recovery Timer (a3sysTestRecoveryTimer) must be set to zero. Note, this object cannot be set to testWithPrimaryBackup(3) explicitly. Instead, by setting a3sysTestBootTimer to a non-zero value, the system will automatically go into 'Test Boot' mode and this object will be given the value testWithPrimaryBackup(3). If this object has the value secondary(4), the system will use only the secondary boot source when rebooting.")
a3sysUserBootListTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9), )
if mibBuilder.loadTexts: a3sysUserBootListTable.setReference('NBII CEC Module Installation Guide: User Boot List Parameter.')
if mibBuilder.loadTexts: a3sysUserBootListTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUserBootListTable.setDescription("This table defines a list of boot sources (and for the NetBuilder Remote Office -- memory dump destinations). There are two other parameters that dictate how the contents of this table are used. These parameters are represented by a3sysStartUpAction and a3sysBootSources. a3sysStartUpAction specifies what this system does when it first comes up. If a3sysStartUpAction is set to userListOnce (2), the system will make a single attempt to use the entries in this table to identify how it should boot. If a3sysStartUpAction is set to userListForever (3), the system will make repeated attempts at using the entries in this table. If a3sysStartUpAction indicates that the system is to use this table, the order in which the entries are used is dictated by a3sysBootSources. If a3sysBootSources has the value primary (1), the system will attempt to boot only from the source identified by entry 1 in this table. If a3sysBootSources has the value primaryAndSecondary(2), the system will attempt to boot first from the source identified by entry 1, and, if that source fails, the system will try the source identified by entry 2 (the secondary source). If a3sysBootSources has the value testWithPrimaryBackup(3), the system will perform a test boot using the test boot source. Note, for the NetBuilder Remote Office, this is the third entry (test) in this table. For the NetBuilder II and the NetBuilder I family( NetBuilder Local, NetBuilder Remote, NetBuilder RemoteAccess, and NetBuilder RemoteControl), the test boot source is identified by entry 2 (secondary) in this table. If the test boot source fails (see the Reference Guide for more details on test booting), the system will revert back to the source identified by entry 1 (primary) in this table. The NetBuilder Remote Office supports a fourth entry in this table, which identifies where over the network memory is to be dumped in the case of a system crash. Note, the destination device (a3sysUblDevice) must be set to network (3), in this case. Also note that many of the columns in this row will be irrelevant and won't affect where the memory gets dumped. Note, all entries in this table apply only to future boots. They don't necessarily provide information about previous boots.")
a3sysUserBootListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysUblSource"))
if mibBuilder.loadTexts: a3sysUserBootListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUserBootListEntry.setDescription('Each entry in this table contains a single boot source.')
a3sysUblSource = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("test", 3), ("dump", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysUblSource.setReference('NBII CEC Module Installation Guide: User Boot List')
if mibBuilder.loadTexts: a3sysUblSource.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblSource.setDescription('This identifies the entry number in this table. Currently, the table is limited to two entries. The first entry is labelled primary(1), the next has the label secondary(2). The NetBuilder RemoteOffice and NetBuilder II (as of sw version 8.0) supports two additional entries. Entry three (test) identifies a separate boot block which is used when doing a test boot. Entry four (dump) identifies where memory is to be dumped. Note, only a subset of the columns in this entry are relevant. Specifically, a3sysUblDevice must have the value network(3) (ie, memory dumps are preformed only over the network by the NBRO).')
a3sysUblDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("localMediaA", 1), ("localMediaB", 2), ("network", 3), ("monitor", 4), ("other", 5), ("auto", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblDevice.setReference('NBII CEC Module Installation Guide: User Boot List: Boot Source Parameter.')
if mibBuilder.loadTexts: a3sysUblDevice.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblDevice.setDescription('This object identifies the source from which the system attempts to boot. If this object is set to localMediaA(1), the system will attempt to boot from drive A of the local storage media (A is the flash drive for those systems with both flash and floppy drives), using the filename identified by a3sysUblFileName. If this is set to localMediaB(2), the system will boot from drive B. If this object is set to network (3), the system will attempt to boot from a BOOTP/TFTP server attached to the network. The network interface that is used in the booting is identified by both a3sysUblSlot and a3sysUblInterface. The name of the boot file on the remote system is identified by a3sysUblFileName. monitor(4) is no longer supported. If this object has the value other(5), nothing has been specified.')
a3sysUblFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblFileName.setReference('NBII CEC Module Installation Guide: User Boot List: Boot Filename Parameter.')
if mibBuilder.loadTexts: a3sysUblFileName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblFileName.setDescription("This specifies the path and name of the boot file. For example, to specify the file boot.29k in the root directory, this object should have the value 'boot.29k'")
a3sysUblNetFile = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblNetFile.setReference('NBII CEC Module Installation Guide: User Boot List: Network Boot String Parameter.')
if mibBuilder.loadTexts: a3sysUblNetFile.setStatus('deprecated')
if mibBuilder.loadTexts: a3sysUblNetFile.setDescription("This object has been deprecated. (use a3sysUblFileName regardless of whether it's local or remote).")
a3sysUblSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblSlot.setReference('NBII CEC Module Installation Guide: User Boot List: Boot Source Parameter.')
if mibBuilder.loadTexts: a3sysUblSlot.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblSlot.setDescription('This specifies the physical slot where the IO module from which the system will be booting is installed. This only applies when a3sysUblDevice is set to network(2)')
a3sysUblInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("interfaceA", 2), ("interfaceB", 3))).clone('interfaceA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblInterface.setReference('NBII CEC Module Installation Guide: User Boot List: Boot Source Parameter.')
if mibBuilder.loadTexts: a3sysUblInterface.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblInterface.setDescription('This specifies the physical port on the IO module (installed in the slot identified by a3sysUblSlot) that the system will be booting from. This only applies when a3sysUblDevice is set to network(2). If there is only one connector in the module, this object should have the value: interfaceA(2).')
a3sysUblMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblMaxRetries.setReference('NBII CEC Module Installation Guide: User Boot List: Maximum Retries Parameter.')
if mibBuilder.loadTexts: a3sysUblMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblMaxRetries.setDescription('This object determines the number of times the system will try to boot from the source identified by this table entry before going to the next entry.')
a3sysUblConfigFileDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bootDevice", 1), ("local", 2), ("network", 3), ("other", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigFileDevice.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigFileDevice.setDescription('This specifies the device used to access the configuration files needed by this system. If this object has the value bootDevice(1), the system will look for its configuration files on the same device as its boot files. This device is specified by a3sysUblDevice. If this object has the value network(3), the system will look for its configuration files on the device specified by a3sysUblConfigIpAddr. If this object has the value local(2), the system will look for its configuration files on the local storage media. If this object has the value other(4), nothing has been specified. In all the cases listed above, the path for the configuration files is specified by a3sysUblConfigFilePath.')
a3sysUblConfigFilePath = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigFilePath.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigFilePath.setDescription('This object specifies the path to the configuration files needed by this system.')
a3sysUblConfigProt = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fap", 1), ("ftp", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysUblConfigProt.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigProt.setDescription('This object specifies the protocol to use to get the configuration files if they are stored across the network. Note, this applies only if the value of a3sysUblConfigFileDevice is network(3) or bootDevice(1). If a3sysUblConfigFileDevice has the value bootDevice(1), then the corresponding instance of a3sysUblDevice must be network(2) for this object to have relevance. This object has been changed to read-only in 9.0. The only valid value for this object is ftp(2).')
a3sysUblConfigUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigUserName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigUserName.setDescription('This object indicates the Username to be used by the file service protocol identified the corresponding instance of a3sysUblConfigProt.')
a3sysUblConfigPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigPassword.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigPassword.setDescription('This specifies the Password to be used by the file service protocol identified by the corresponding instance of a3sysUblConfigProt. Note, for reasons of security, the value of this object will be hidden. A string of 4 stars (*) will be returned in response to any GET or GETNEXT request.')
a3sysUblConfigAcct = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigAcct.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigAcct.setDescription('This specifies the Account Name used by the file service protocol. Note, for reasons of security, the value of this object will be hidden. A string of 4 stars (*) will be returned in response to any GET or GETNEXT request.')
a3sysUblMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cpu-module", 1), ("io-module", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblMacAddress.setReference('NBII CEC Module Installation Guide: System IP Addresses: Boot MAC Address Parameter.')
if mibBuilder.loadTexts: a3sysUblMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblMacAddress.setDescription('The MAC address to be used for booting over the network. This can be configured to use either the MAC address assigned to the CPU module or the MAC address assigned to the I/O module over which the boot is being performed.')
a3sysUblCanonicalFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("canonical", 2), ("nonCanonical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblCanonicalFlag.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblCanonicalFlag.setDescription('This controls the format of addresses within ARP packets sent by this system.')
a3sysUblRemoteProt = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("ppp", 2), ("frameRelay", 3), ("auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblRemoteProt.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblRemoteProt.setDescription('This object specifies which serial link protocol to use if a3sysUblSlot identifies a slot with a High Speed Serial board. If this is set to auto (4), the system will try all supported protocols until the serial line is active. If there is a different kind of board in that slot, the value of this object is ignored.')
a3sysUblBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("unknown", 1), ("bps9600", 2), ("kbps19", 3), ("kbps38", 4), ("kbps56", 5), ("kbps64", 6), ("kbps128", 7), ("kbps256", 8), ("kbps448", 9), ("kbps1536", 10), ("kbps2048", 11), ("mbps4", 12), ("mbps16", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblBaudRate.setDescription('This object specifies the serial line or Token Ring baud rate. For all other types of ports, this object will be ignored.')
a3sysUblClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("external", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblClockSource.setDescription('This specifies whether to use an internal or external clock source. This applies only to High Speed Serial ports.')
a3sysUblConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("rs232", 2), ("v35", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConnectorType.setDescription('This object specifies the serial line connector type.')
a3sysUblWanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblWanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblWanAddress.setDescription('This specifies a string to initiate a WAN connection. The specified string required is interface and protocol specific. The maximum string length is 80 bytes. Note, this applies only to High Speed Serial ports.')
a3sysUblClientIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblClientIpAddr.setReference('NBII CEC Module Installation Guide: System IP Addresses: Client IP address Parameter.')
if mibBuilder.loadTexts: a3sysUblClientIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblClientIpAddr.setDescription('The IP Address of this system used in packets when booting over the network.')
a3sysUblServerIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 22), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblServerIpAddr.setReference('NBII CEC Module Installation Guide: System IP Addresses: Server IP Address Parameter.')
if mibBuilder.loadTexts: a3sysUblServerIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblServerIpAddr.setDescription('The IP address of the Boot Server.')
a3sysUblGwIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblGwIpAddr.setReference('NBII CEC Module Installation Guide: System IP Addresses: Gateway IP Address Parameter.')
if mibBuilder.loadTexts: a3sysUblGwIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblGwIpAddr.setDescription('The IP address of the gateway that will forward packets to the Boot Server.')
a3sysUblConfigFileIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblConfigFileIpAddr.setReference('NBII CEC Module Installation Guide: System IP Addresses: FAP Server IP Address Parameter.')
if mibBuilder.loadTexts: a3sysUblConfigFileIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblConfigFileIpAddr.setDescription('The IP address of the configuration files Server, if needed.')
a3sysUblIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblIpMask.setDescription('The mask to be applied to the addresses specified above.')
a3sysUblAddressDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("bootp", 2), ("configAddr", 3), ("bootpRarp", 4), ("rarp", 5), ("rarpBootp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblAddressDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblAddressDiscovery.setDescription('This specifies the address discovery protocol to use for booting from the network. If configAddr(3) is specified, then the configured addresses are used. If nothing has been specified, other(1) is returned.')
a3sysUblPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 9, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysUblPassword.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysUblPassword.setDescription('This is needed when booting over a port that uses a protocol that requires a password, e.g, PPP.')
a3sysIioBootTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10), )
if mibBuilder.loadTexts: a3sysIioBootTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootTable.setDescription('This table specifies where each IIO card obtains its boot image.')
a3sysIioBootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysIioBootSlot"))
if mibBuilder.loadTexts: a3sysIioBootEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootEntry.setDescription('Each entry in this table corresponds to a specific slot in the NetBuilder chassis. If an IIO board is in that slot, that entry determines where that IIO board obtains its boot image.')
a3sysIioBootSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysIioBootSlot.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootSlot.setDescription('This object specifies the slot into which the IIO board corresponding to this entry is placed.')
a3sysIioBootFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysIioBootFileName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootFileName.setDescription("This object specifies the path and name of the IIO board's boot image. If the value of this object specifies a drive, the path is assumed to start from root. If the value of this object does not specify a drive number, this object specifies the path starting from the config file directory specified by a3sysUblConfigFilePath. In this case, the value of this object must not begin with a slash '/'.")
a3sysIioBootState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("empty", 1), ("up", 2), ("booting", 3), ("recovering", 4), ("dumping", 5), ("halted", 6), ("selfTestFail", 7), ("error", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysIioBootState.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootState.setDescription('This object provides the current state of the IIO card installed in this slot. If there is no IIO card in the slot, this object will have the value empty(1). If the card is up and running, this object will have the value up(2). If the card is booting, this object will have the value booting(3). If the boot has failed, and the card is in the process of recovering from the failed boot, this object will have the value recovering(4). If in the process of recovering, the IIO dumps its image, this object will have the value dumping(5). Note that this is simply a sub-state within the more general recovering state. If after recovering, the IIO card goes into a halted state, this object will have the value halted(6). If the IIO card gets into an unrecoverable state, this object will have the value error(8).')
a3sysIioBootTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysIioBootTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootTime.setDescription('The value of sysUpTime when the IIO board last went into the UP state.')
a3sysIioBootImage = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 10, 10, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysIioBootImage.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioBootImage.setDescription('The OID assigned to this version of Iio Software.')
a3sysLastBootSource = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("monitor", 3), ("test", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLastBootSource.setReference('NBII CEC Module Installation Guide: User Boot List: Boot Source Parameter.')
if mibBuilder.loadTexts: a3sysLastBootSource.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLastBootSource.setDescription('This object identifies the source from which the system last booted. The specifics of the boot source can be found from the corresponding User Boot List entry.')
a3sysLastBootError = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("unknownLocalAddress", 2), ("unknownServerAddress", 3), ("noServerResponse", 4), ("fileTransferFailed", 5), ("imageNotFound", 6), ("imageInvalid", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLastBootError.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLastBootError.setDescription('This object identifies the reason for the most recent boot failure.')
a3sysLastBootDate = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLastBootDate.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLastBootDate.setDescription('The date and time as reflected by the system clock at the time the system last rebooted. The date has the format yy/mm/dd hh:mm[:ss].')
a3sysLbConfigFileIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbConfigFileIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbConfigFileIpAddr.setDescription('The IP address of the configuration file server used during the most recent boot. Note, even if the configuration files were obtained locally, an address may have been configured. This is the address used when performing all ftp PUT and GET operations.')
a3sysLbGwIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbGwIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbGwIpAddr.setDescription('The IP address of the gateway that was used to forward packets to the boot server or configuration file server during the last boot.')
a3sysLbIpMask = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbIpMask.setDescription('The IP subnet mask configured during the last boot.')
a3sysLbConfigDevice = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bootDevice", 1), ("local", 2), ("network", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbConfigDevice.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbConfigDevice.setDescription('The config file device used during the last boot.')
a3sysLbConfigFilePath = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbConfigFilePath.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbConfigFilePath.setDescription('The config file path used during the last boot.')
a3sysLbConfigUserName = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 11, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysLbConfigUserName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysLbConfigUserName.setDescription('If the config files were obtained from a file server during the last boot, this object contains the user name used during the ftp transfer of those files.')
a3sysFmOperation = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("copy", 2), ("do", 3), ("delete", 4), ("rename", 5), ("directory", 6), ("format", 7), ("copySystem", 8), ("checksum", 9), ("abortCopy", 10), ("makeDir", 11), ("rmDir", 12), ("getFileInfo", 13), ("ftpGet", 14), ("ftpPut", 15), ("cleanFlash", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFmOperation.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmOperation.setDescription('This object is used to initiate a file management operation. When set to copy(2), the system will get the file from the Source device (identified by a3sysFmSourceIpAddr and a3sysFmSourceFile) and copy it to the Target device (identified by a3sysFmTargetIpAddr and a3sysFmTargetFile). Note, both the Source and Target devices cannot be remote systems. At least one must be the local system. All information about the file and the server is taken from the values of the other objects in this group. To avoid unnecessary errors, the relevant objects in this group should be examined and their values validated before setting this object to copy(2). Currently, the do(3) enumeration is not supported. If this object is set to delete(4), the system will delete a single file on the local storage device. The file is identified by a3sysFmTargetFile. For software release 6.2, the rename(5) enumeration is not supported. This is supported, however, by release 7.0. If this object is directory(6), the system will list the file in the directory identified by a3sysFmTargetFile. The resulting list can be obtained by examining a3sysDfTable. For software release 6.2, enumerations 7 through 9 are not supported. Enumeration 7 and 9 are supported by release 7.0. If this object is set to abortCopy(10), the system will abort any file copy process in progress. If this object is set to makeDir(11), the system will create a directory off the root directory. The name of this directory is specified by a3sysFmTargetFile. If this object is set to rmDir(12), the system will remove the directory identified by a3sysFmTargetFile. If this object is set to getFileInfo(13), the system will retrieve information about the file identified by a3sysFmTargetFile and return that information via the a3ComFileInfo group. (ie, examine the contents of that group after this object is set to getFileInfo(13)). If this object is set to ftpGet(14), the system will retrieve the file identified by a3sysFmSourceFile. It will retrieve the file from the device from which the configuration files were originally obtained. That device can be identified by a3sysLbConfigFileIpAddr. Note, even if the config files were obtained locally, a valid IP address may have been configured. That is the device used for future ftp operations. If a path is not specified, the file will be taken from the configuration file directory. The config file directory cay be identified by a3sysLbConfigFilePath. If a relative path is specified, and the configuration files were originally obtained (ie, at last boot) from the network, the path is interpreted relative to the configuration file directory. If a relative path is specified and the configuration files were originally obtained locally, the path is interpreted relative to the login directory. Absolute paths are allowed. Once obtained, the file will be placed in the location identified by a3sysFmTargetFile. Note, this must be on one of the local storage devices. If this object is set to ftpPut(15), the system will place the file identified by a3sysFmSourceFile and place it on the device from which the config files were obtained originally. The path and filename of the placed file is identified by a3sysFmTargetFile. As with ftpGet(14), if a relative path is specified, and the configuration files were originally obtained from the network, the path is interpreted relative to the configuration file directory. If a relative path is specified and the configuration files were originally obtained locally, the path is interpreted relative to the login directory. Absolut paths are allowed. Note, the source file must be on one of the local storage devices. If this object is read, other(1) will be returned.')
a3sysFmSourceIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFmSourceIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmSourceIpAddr.setDescription("This object specifies the IP address of the Source device from which files are obtained. If this is set to zero's, the local storage device is assumed.")
a3sysFmSourceFile = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFmSourceFile.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmSourceFile.setDescription('This specifies the path and name of a source file. For example, if the action specified by a3sysFmOperation is copy(2) or rename(5), this identifies the path and name of the file to be copied or renamed. If there is no leading path string, the source file will be accessed from the root directory. For devices with multiple disk drives, the drive will be identified by appending a prefix to the path. For example, a:/path/name')
a3sysFmTargetIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFmTargetIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmTargetIpAddr.setDescription('This object specifies the IP address of the target device to which files are copied, renamed, etc.')
a3sysFmTargetFile = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysFmTargetFile.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmTargetFile.setDescription("This specifies the path and name of the target file on the target system. (The filename may contain the string '@M' which will be expanded to the system MAC address. Alternatively, the filename may contain the string '@m' which will be expanded to the last six characters of the system MAC address. This provides a mechanism for a remote system to generate system specific filenames automatically.) If there is no leading path string, the file will be accessed from the root directory. For devices with multiple disk drives, the drive will be identified by appending a prefix to the path. For example, a:/path/name. If the action specified by a3sysFmOperation is copy(2), this identifies where, on the target system (identified by a3sysFmTargetIpAddr) the file is to be placed and the name to give it. If the action specified by a3sysFmOperation is delete(4), this identifies the path and name of the local file which is to be deleted. If the action specified by a3sysFmOperation is directory(6), this identifies the full path of the directory that is to be listed.")
a3sysFmStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("inProgress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmStatus.setDescription('This identifies the current status of the file management operation. This applies to the following operations: copy(2), and directory(6). If there is an operation in progress, this object will have the value inProgress(2). Otherwise inactive(1) will be returned.')
a3sysFmTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmTimeStamp.setDescription('This specifies the value of sysUpTime when the most recent file management operation was initiated.')
a3sysFmError = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("none", 1), ("successful", 2), ("inProgress", 3), ("badSourceAddr", 4), ("badSourceFile", 5), ("badTargetAddr", 6), ("badTargetFile", 7), ("noResponse", 8), ("noFile", 9), ("noSpace", 10), ("noPermission", 11), ("writeError", 12), ("timeout", 13), ("badChecksum", 14), ("badOperation", 15), ("aborted", 16), ("other", 17), ("badDefaultDrv", 18), ("badTargetPort", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmError.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmError.setDescription('This object identifies the results of the most recent attempt at a file operation. If no file operations have been attempted since the system was initialized, this object will have the value none(1). If the last operation was successful, this object will have the value successful(2). If the last operation could not be initiated because there was another operation in progress, this object will have the value inProgress (3). If the source IP Address is invalid, this object will have the value badSourceAddr(4). If the source file name contains a syntax error, this object will have the value badSourceFile(5). If the target IP Address is invalid, this object will have the value badTargetAddr(6). If there was a syntax error in the identification of the target file (a3sysFmTargetFile), this object will have the value badTargetFile(7). If the remote server does not respond, this object will have the value noResponse(8). If either the source file or target file could not be found, this object will have the value noFile(9). If there is no space on the destination system this object will have the value noSpace(10). If the destination file location is write protected, this object will have the value noPermission(11). If there is an error encountered while writing the file to its destination, this object will have the value writeError(12). If the transfer took too much time and exceeded its limits, this object will have the value timeout(13). If the verify operation failed, this object will have the value badChecksum(14). If the operation requested is not supported by this platform or software version, this object will have the value badOperation(15). If the opereration was aborted by a user, this object will have the value aborted(16). If no drive is indicated in either the source or target files, and the default drive is not local (this will be the case when the system obtained its config files over the network the last time it booted), this object will have the value badDefaultDrv(18). This object will have the value other(17) if an error occured that is not listed here.')
a3sysDfTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDfTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfTime.setDescription('This object specifies the value of sysUpTime when the list of files on the system disk was last updated. This list is updated by setting a3sysFmOperation to directory(6).')
a3sysDfPath = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDfPath.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfPath.setDescription('This object identifies the directory path under which the files listed in a3sysDfTable were obtained. Where necessary, this object also identifies the disk drive where the files are stored.')
a3sysDfTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 3), )
if mibBuilder.loadTexts: a3sysDfTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfTable.setDescription('This table contains a listing of all the files in a specific directory on one of the systems disks. The directory and disk are identified by a3sysDfPath. Each entry in this table contains information about a single file.')
a3sysDfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 3, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysDfName"))
if mibBuilder.loadTexts: a3sysDfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfEntry.setDescription('Each entry in this table describes a single disk file.')
a3sysDfName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDfName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfName.setDescription('This contains the name of a single file on the disk.')
a3sysDfDir = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("file", 1), ("directory", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysDfDir.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysDfDir.setDescription('This specifies whether the file identified by the corresponding instance of a3sysDfName is a regular file or a directory.')
a3ComDfTotalSpace = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComDfTotalSpace.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComDfTotalSpace.setDescription('The total size (in bytes) of the drive identified by a3sysDfPath')
a3ComDfAvailableSpace = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComDfAvailableSpace.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComDfAvailableSpace.setDescription('The available space (in bytes) of the drive identified by a3sysDfPath.')
a3sysFmCksum = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmCksum.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmCksum.setDescription('This object specifies the results of a ccitt crc16 cyclic redundancy check performed on the file specified by a3sysTargetFile. The value of a3sysTargetFile at the time this crc was performed is provided by a3sysFmCksumFile.')
a3sysFmCksumFile = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 10, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmCksumFile.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmCksumFile.setDescription('This object specifies the file upon which the last ccitt crc16 cyclic redundancy check was performed. The results of this operation are specified by a3sysFmCksum.')
a3sysFmCksumTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 10, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmCksumTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmCksumTime.setDescription('This object specifies the value of sysUpTime when the last ccitt crc16 cyclic redundancy check was performed. The results of this operation are specified by a3sysFmCksum.')
a3sysFiName = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 11, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFiName.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFiName.setDescription('This object specifies the name of the file to which the rest of this group refers.')
a3sysFiDate = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 11, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFiDate.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFiDate.setDescription('This object specifies the date when the file (specified by a3sysFiName was last updated. The format of the date is yy/mm/dd hh:min:sec.')
a3sysFiTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 11, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFiTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFiTimeStamp.setDescription('This object specifies the value of sysUpTime when this group of objects was last updated. To update this group, set a3sysFmTargetFile to the desired file, and set a3sysFmOperation to getFileInfo(13).')
a3sysFmSize = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 13, 12, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysFmSize.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysFmSize.setDescription('This object specifies the size of the file (specified by a3sysFiName) in bytes.')
a3sysIioRecoveryTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 13, 13, 1), )
if mibBuilder.loadTexts: a3sysIioRecoveryTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioRecoveryTable.setDescription('This table specifies the recovery procedure for each Intelligent IO board in the system. This also specifies the recovery procedure for the CEC card. Note, the eeprom version must be 5 or greater for this table to operate properly.')
a3sysIioRecoveryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 13, 13, 1, 1), ).setIndexNames((0, "A3Com-System-r8-MIB", "a3sysIioRecoverySlot"))
if mibBuilder.loadTexts: a3sysIioRecoveryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioRecoveryEntry.setDescription('Each entry in this table corresponds to a specific slot in the NetBuilder chassis. If an IIO board is in that slot, that entry determines the action taken by that IIO board in the event it crashes. There is also an entry in this table for the CEC board.')
a3sysIioRecoverySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3sysIioRecoverySlot.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioRecoverySlot.setDescription('This object specifies the slot into which the IIO (or CEC) board corresponding to this entry is placed.')
a3sysIioRecoveryProcedure = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("halt", 1), ("haltSystem", 2), ("reboot", 3), ("rebootSystem", 4), ("dumpAndReboot", 5), ("selectiveDumpAndReboot", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysIioRecoveryProcedure.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioRecoveryProcedure.setDescription('The value of this object determines the action taken if the IIO (or CEC) crashes. If the value of this object is selectiveDumpAndReboot (5), the value of a3sysIioRecoverySelect determines which IIO (or CEC) boards will dump and reboot in the event that this IIO board crashes.')
a3sysIioRecoverySelect = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 13, 13, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3sysIioRecoverySelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3sysIioRecoverySelect.setDescription('This object specifies the IIO or CEC boards that will dump and reboot in the event this IIO or CEC board crashes. This object is relevant only if the value of a3sysIioRecoveryProcedure is selectiveDumpAndReboot (6). The boards are specified by their slot. Each slot is represented by a single bit in the value of this object. If that bit is set (to 1), then that board will dump and reboot. Slot 0 is used to identify the CEC board, and corresponds to the least significant bit in this object. Slot 1 is used to identify the IIO board in that slot and corresponds to the next significant bit in this object. The identification of all other boards follows this convention.')
a3BogusDhcpSvr = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,100)).setObjects(("A3Com-System-r8-MIB", "a3sysBogusDhcpSvr"))
if mibBuilder.loadTexts: a3BogusDhcpSvr.setDescription('A a3BogusDhcpSvr trap signifies that an unauthorized DHCP or BOOTP server has been detected on the network.')
mibBuilder.exportSymbols("A3Com-System-r8-MIB", a3sysSNMPMgrEntry=a3sysSNMPMgrEntry, a3sysFmCksumFile=a3sysFmCksumFile, a3ComFileMgmt=a3ComFileMgmt, a3ComTime=a3ComTime, a3sysBogusDhcpSvr=a3sysBogusDhcpSvr, a3sysFwSerBaudCons=a3sysFwSerBaudCons, a3sysMemIndex=a3sysMemIndex, a3sysUblConfigProt=a3sysUblConfigProt, a3sysFmError=a3sysFmError, a3sysPasswordEntry=a3sysPasswordEntry, a3sysFiTimeStamp=a3sysFiTimeStamp, a3sysLbConfigFileIpAddr=a3sysLbConfigFileIpAddr, a3sysBrdPathCapacity=a3sysBrdPathCapacity, a3ComSysMisc=a3ComSysMisc, a3sysSNMPMgrStatus=a3sysSNMPMgrStatus, a3sysDfTable=a3sysDfTable, a3sysSlotNumber=a3sysSlotNumber, a3sysBrdOID=a3sysBrdOID, a3sysUblSource=a3sysUblSource, a3sysPlatformID=a3sysPlatformID, a3sysUblConfigUserName=a3sysUblConfigUserName, a3sysUblSlot=a3sysUblSlot, a3sysUblBaudRate=a3sysUblBaudRate, a3ComMem=a3ComMem, a3sysIioBootTable=a3sysIioBootTable, a3sysExceptionReBoots=a3sysExceptionReBoots, a3ComDfTotalSpace=a3ComDfTotalSpace, a3sysTelnetMgrEntry=a3sysTelnetMgrEntry, a3sysOldPassword=a3sysOldPassword, a3sysTelnetAccess=a3sysTelnetAccess, a3sysBrdFwVers=a3sysBrdFwVers, a3sysSNMPAccess=a3sysSNMPAccess, a3sysUblGwIpAddr=a3sysUblGwIpAddr, a3sysFiDate=a3sysFiDate, a3sysUIBinary=a3sysUIBinary, a3sysBrdTable=a3sysBrdTable, a3sysUserBootListEntry=a3sysUserBootListEntry, a3sysMemStartAdd=a3sysMemStartAdd, a3sysUblConfigFilePath=a3sysUblConfigFilePath, a3sysDSTime=a3sysDSTime, a3sysSNMPCommTable=a3sysSNMPCommTable, a3sysChipSlotIndex=a3sysChipSlotIndex, a3Com=a3Com, a3sysIioBootTime=a3sysIioBootTime, a3sysSNMPMgrAddress=a3sysSNMPMgrAddress, a3sysIioRecoverySelect=a3sysIioRecoverySelect, a3sysBrdReset=a3sysBrdReset, a3ComLastBoot=a3ComLastBoot, a3sysPlatformDescr=a3sysPlatformDescr, a3sysFmCksumTime=a3sysFmCksumTime, a3sysSNMPMgrTable=a3sysSNMPMgrTable, a3sysFmSourceIpAddr=a3sysFmSourceIpAddr, a3sysX25Conns=a3sysX25Conns, a3sysUblWanAddress=a3sysUblWanAddress, a3ComBrd=a3ComBrd, a3sysVportTimestamp=a3sysVportTimestamp, a3sysUblConfigPassword=a3sysUblConfigPassword, a3sysRemoteAccess=a3sysRemoteAccess, a3sysSNMPMgrMask=a3sysSNMPMgrMask, a3sysFmSourceFile=a3sysFmSourceFile, a3sysPasswordTable=a3sysPasswordTable, a3sysUblRemoteProt=a3sysUblRemoteProt, a3sysExpMacAddr=a3sysExpMacAddr, a3sysTestRecoveryTimer=a3sysTestRecoveryTimer, a3sysUblNetFile=a3sysUblNetFile, a3sysLogServerAddress=a3sysLogServerAddress, a3sysLbIpMask=a3sysLbIpMask, a3sysTimeZone=a3sysTimeZone, a3sysChipDescr=a3sysChipDescr, a3sysBrdEntry=a3sysBrdEntry, a3sysUblConfigFileDevice=a3sysUblConfigFileDevice, a3sysIioRecoveryProcedure=a3sysIioRecoveryProcedure, a3sysDriveStatus=a3sysDriveStatus, a3sysFwSerBaudAux=a3sysFwSerBaudAux, a3sysChipEntry=a3sysChipEntry, a3sysFwSelfTest=a3sysFwSelfTest, a3sysFmTargetIpAddr=a3sysFmTargetIpAddr, a3sysIioBootSlot=a3sysIioBootSlot, a3sysStartUpAction=a3sysStartUpAction, a3sysDefDriveType=a3sysDefDriveType, a3ComRecovery=a3ComRecovery, a3sysMemSize=a3sysMemSize, a3sysMemType=a3sysMemType, a3sysUserLevel=a3sysUserLevel, a3sysFmStatus=a3sysFmStatus, a3ComChip=a3ComChip, a3sysReBoot=a3sysReBoot, a3sysDfPath=a3sysDfPath, a3ComFileList=a3ComFileList, a3sysTelnetMgrTable=a3sysTelnetMgrTable, a3ComBoot=a3ComBoot, a3sysChipIndex=a3sysChipIndex, a3sysUblClientIpAddr=a3sysUblClientIpAddr, a3ComSysID=a3ComSysID, brouterMIB=brouterMIB, a3sysFmSize=a3sysFmSize, a3sysChipTable=a3sysChipTable, a3sysDate=a3sysDate, a3sysIioBootState=a3sysIioBootState, a3sysUblAddressDiscovery=a3sysUblAddressDiscovery, a3sysLastBootDate=a3sysLastBootDate, a3sysNetMapTime=a3sysNetMapTime, a3sysUblPassword=a3sysUblPassword, a3sysChipName=a3sysChipName, a3ComFmCksum=a3ComFmCksum, a3sysMemSlotIndex=a3sysMemSlotIndex, a3sysNewPassword=a3sysNewPassword, a3sysUblMaxRetries=a3sysUblMaxRetries, a3sysSNMPMgrCommString=a3sysSNMPMgrCommString, a3sysFmTimeStamp=a3sysFmTimeStamp, a3sysFmOperation=a3sysFmOperation, a3ComAccCtl=a3ComAccCtl, a3sysUblCanonicalFlag=a3sysUblCanonicalFlag, a3sysTelnetMgrAddress=a3sysTelnetMgrAddress, a3sysLbGwIpAddr=a3sysLbGwIpAddr, a3sysTestBootTime=a3sysTestBootTime, a3sysLbConfigDevice=a3sysLbConfigDevice, a3sysUblFileName=a3sysUblFileName, a3sysCpuUtil=a3sysCpuUtil, a3sysConsoleAccess=a3sysConsoleAccess, a3sysDefDrive=a3sysDefDrive, a3sysUblInterface=a3sysUblInterface, a3sysFmTargetFile=a3sysFmTargetFile, a3sysUblConfigAcct=a3sysUblConfigAcct, a3sysDfEntry=a3sysDfEntry, a3sysCallerID=a3sysCallerID, a3ComDfAvailableSpace=a3ComDfAvailableSpace, a3sysPwStatus=a3sysPwStatus, a3sysDfName=a3sysDfName, a3sysFmCksum=a3sysFmCksum, a3sysAuditTrailType=a3sysAuditTrailType, a3sysBootDump=a3sysBootDump, a3sysIioBootFileName=a3sysIioBootFileName, a3sysLbConfigUserName=a3sysLbConfigUserName, a3sysIioRecoveryEntry=a3sysIioRecoveryEntry, a3sysFiName=a3sysFiName, a3sysDfDir=a3sysDfDir, a3sysTelnetMgrStatus=a3sysTelnetMgrStatus, a3sysCpuBrdMacAddr=a3sysCpuBrdMacAddr, a3sysUserBootListTable=a3sysUserBootListTable, a3sysMemEntry=a3sysMemEntry, a3sysDirectedReBoots=a3sysDirectedReBoots, a3ComFileInfo=a3ComFileInfo, a3ComFW=a3ComFW, a3sysUblDevice=a3sysUblDevice, a3sysLbConfigFilePath=a3sysLbConfigFilePath, a3sysBootSources=a3sysBootSources, a3sysChangeTimestamp=a3sysChangeTimestamp, a3sysSNMPCommTrap=a3sysSNMPCommTrap, a3sysSNMPCommString=a3sysSNMPCommString, a3sysUblConnectorType=a3sysUblConnectorType, a3sysIioRecoverySlot=a3sysIioRecoverySlot, a3sysSNMPCommAccess=a3sysSNMPCommAccess, a3sysDfTime=a3sysDfTime, RowStatus=RowStatus, a3sysUblConfigFileIpAddr=a3sysUblConfigFileIpAddr, a3sysIioBootImage=a3sysIioBootImage, a3sysUblClockSource=a3sysUblClockSource, a3sysNb2EepromVers=a3sysNb2EepromVers, a3sysLastBootSource=a3sysLastBootSource, a3sysSnmpPasswordCtl=a3sysSnmpPasswordCtl, a3sysLastBootError=a3sysLastBootError, a3sysSNMPCommStatus=a3sysSNMPCommStatus, a3sysVersion=a3sysVersion, a3ComSys=a3ComSys, a3sysSlotIndex=a3sysSlotIndex, a3sysUblServerIpAddr=a3sysUblServerIpAddr, a3sysIioRecoveryTable=a3sysIioRecoveryTable, a3ComAudit=a3ComAudit, a3sysMemTable=a3sysMemTable, a3sysUblMacAddress=a3sysUblMacAddress, a3BogusDhcpSvr=a3BogusDhcpSvr, a3sysUblIpMask=a3sysUblIpMask, a3sysIioBootEntry=a3sysIioBootEntry, a3sysSNMPCommEntry=a3sysSNMPCommEntry, a3sysUserName=a3sysUserName, a3sysBrdDescr=a3sysBrdDescr)

#
# PySNMP MIB module SYNC-RESEARCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYNC-RESEARCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, TimeTicks, Counter32, IpAddress, Gauge32, NotificationType, enterprises, iso, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Unsigned32, Counter64, ModuleIdentity, MibIdentifier, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "Counter32", "IpAddress", "Gauge32", "NotificationType", "enterprises", "iso", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Unsigned32", "Counter64", "ModuleIdentity", "MibIdentifier", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

syncResearch = MibIdentifier((1, 3, 6, 1, 4, 1, 485))
syncResearchAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1))
syncProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1))
oemProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2))
boundary = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1))
centralSite = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2))
syncCN2R2b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 1))
syncFN2R2b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 2))
syncCN4R2b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 3))
syncFN4R2b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 4))
syncQN4R2b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 5))
syncCN4R3b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 6))
syncFN4R3b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 7))
syncQN4R3b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 8))
syncCN4R4b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 9))
syncFN4R4b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 10))
syncQN4R4b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 11))
syncCN4R4bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 12))
syncFN4R4bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 13))
syncQN4R4bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 14))
syncCN4R4du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 15))
syncFN4R4du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 16))
syncQN4R4du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 17))
syncCN2R2du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 18))
syncFN2R2du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 19))
syncCN3R4bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 20))
syncFN3R4bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 21))
syncCN3R4du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 22))
syncFN3R4du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 23))
syncCN4R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 24))
syncFN4R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 25))
syncQN4R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 26))
syncCN4R5bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 27))
syncFN4R5bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 28))
syncQN4R5bu = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 29))
syncCN4R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 30))
syncFN4R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 31))
syncQN4R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 32))
syncFN5R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 33))
syncBC4R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 34))
syncBF4R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 35))
syncBF3R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 36))
syncBF5R5b = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 37))
syncFN3R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 38))
syncCN3R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 39))
syncCN5R5du = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 40))
syncBF3R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 41))
syncBC3R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 42))
syncBF4R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 43))
syncBC4R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 44))
syncBF5R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 45))
syncBC5R5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 1, 46))
syncCN4R2c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 1))
syncFN4R2c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 2))
syncQN4R2c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 3))
syncCN4R3c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 4))
syncFN4R3c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 5))
syncQN4R3c = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 6))
syncCN4R4u = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 7))
syncFN4R4u = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 8))
syncQN4R4u = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 1, 2, 9))
threeCom = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1))
cableTron = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2))
chipcom = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 3))
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4))
linkConverter = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 1))
linkConverter2 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 2))
lc2EN2port = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 3))
lc2EN4port = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 4))
lc2TR2port = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 5))
lc2TR6port = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 1, 6))
oemSNACXR2C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 1))
oemSNACXR2W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 2))
oemSNACMR2C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 3))
oemSNACMR2W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 4))
oemSNACMIM2 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 5))
oemSNACXR2Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 6))
oemSNACMR2Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 7))
oemSNACXR3C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 8))
oemSNACXR3W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 9))
oemSNACMR3C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 10))
oemSNACMR3W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 11))
oemSNACXR3Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 12))
oemSNACMR3Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 13))
oemSNACXR4C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 14))
oemSNACXR4W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 15))
oemSNACMR4C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 16))
oemSNACMR4W = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 17))
oemSNACXR4Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 18))
oemSNACMR4Q = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 2, 19))
oem2490R22F = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 1))
oem2490R22C = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 2))
oem22181FR4 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 3))
oem22181CR4 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 4))
oem22183FR4 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 5))
oem22183CR4 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 6))
oem22181FR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 7))
oem22181CR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 8))
oem22183FR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 9))
oem22183CR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 10))
oem22185FR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 11))
oem22185CR5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 12))
oem22183BF5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 13))
oem22183BC5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 14))
oem22184BF5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 15))
oem22184BC5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 16))
oem22185BF5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 17))
oem22185BC5 = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 1, 2, 4, 18))
srNodeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3))
nodeUnitGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 1))
nodeNetViewPUGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 2))
nodeBridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 3))
nodeLANGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 4))
nodeLineGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5))
nodePUGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6))
nodeDeviceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 7))
nodeT7Group = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 8))
nodeFrCirGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 9))
nodeSlipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 10))
nodeIpxGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 11))
nodeIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 12))
unitControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 1, 1))
unitStatusGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 1, 2))
unitConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 1, 3))
unitStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 1, 4))
netViewPUStatusGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 2, 1))
netViewPUConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 2, 2))
bridgeConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 3, 1))
bridgeStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 3, 2))
ipxConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 11, 1))
ipConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 12, 1))
lanControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 4, 1))
lanTokenRingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 4, 2))
lineControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 1))
linePhysicalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 2))
lineSDLCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 3))
lineBisyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 4))
lineFrameRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 5))
lineAsyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 6))
lineBisyncRjeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 7))
lineDialBackupGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 8))
lineX25Group = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 9))
lineAlcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 10))
isdnControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2))
dsucsuControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3))
puControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 1))
puSDLCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 2))
puBisyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 3))
puMappingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 4))
puAsyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 5))
puLanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 6))
puRemoteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 7))
puX25Group = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 8))
puAlcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 9))
puBisyncRjeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 6, 10))
deviceControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 7, 1))
deviceBSCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 7, 2))
deviceALCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 7, 3))
t7ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 8, 1))
t7StatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 8, 2))
slipConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 10, 1))
slipStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 3, 10, 2))
srCommTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 2))
commCount = MibScalar((1, 3, 6, 1, 4, 1, 485, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commCount.setStatus('mandatory')
if mibBuilder.loadTexts: commCount.setDescription('The number of possible community name entries in the table.')
commTable = MibTable((1, 3, 6, 1, 4, 1, 485, 2, 2), )
if mibBuilder.loadTexts: commTable.setStatus('mandatory')
if mibBuilder.loadTexts: commTable.setDescription('This table houses the information for trivial authentication and sending traps.')
commEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 2, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "commIndex"))
if mibBuilder.loadTexts: commEntry.setStatus('mandatory')
if mibBuilder.loadTexts: commEntry.setDescription('Each entry contains a community name and access code for SNMP trivial authentication and enable/disable traps options, as well as network and physical addressing information for traps.')
commIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commIndex.setStatus('mandatory')
if mibBuilder.loadTexts: commIndex.setDescription('A unique value for each community entry. Its value ranges between 1 and commCount.')
commName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commName.setStatus('mandatory')
if mibBuilder.loadTexts: commName.setDescription('A community name that will be used to access MIB objects. Each community name is associated with an access code of either NO-ACCESS, RO, RW, or SU.')
commTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapoff", 1), ("trapon", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commTrap.setStatus('mandatory')
if mibBuilder.loadTexts: commTrap.setDescription('This object is checked to determine if traps should be sent to the corresponding network address associated with it.')
commIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: commIPAddr.setDescription('The network address of the device that will receive traps from the agent. This IP address also qualifies who may use this community name to access MIB objects. If this community name is use by some one with a different IP address, an Authentication Trap will be generated. If the IP address is set to 0.0.0.0, anyone may use this address, however, traps will not be sent since the address is invalid.')
commMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: commMACAddr.setDescription('The physical address of the device receiving traps from the agent.')
commAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAccess", 1), ("ro", 2), ("rw", 3), ("su", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commAccess.setStatus('mandatory')
if mibBuilder.loadTexts: commAccess.setDescription('Access code assiciated with the community name of the same entry. noAccess indicates a community name with zero privileges. ro has read-only access to MIB objects. rw allows you to read and write MIB objects. SU (super- user) gives you privileges to read and write any MIB object. The community table itself can only be written to with an access of SU as well as the setting of the IP Address on a device.')
unitRestart = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart-unit", 1), ("dummy-restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unitRestart.setStatus('mandatory')
if mibBuilder.loadTexts: unitRestart.setDescription('Setting this variable to a value of 1 will force the unit to restart. Setting this variable to any other value will cause an SNMP error. This variable always returns a value of 2.')
dumpOnRestart = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dump-on-start", 1), ("dont-dump", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dumpOnRestart.setStatus('mandatory')
if mibBuilder.loadTexts: dumpOnRestart.setDescription('Setting this variable to a value of 1 will force the unit to perform a dump on restart. Setting this variable to a value of 2 will force it to not to dump on restart.')
initiateInstall = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start-install", 1), ("dummy-install", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: initiateInstall.setStatus('mandatory')
if mibBuilder.loadTexts: initiateInstall.setDescription('Setting this variable to a value of 1 will force the unit to initiate an install process. This variable always returns a value of 2.')
initializeStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("init-stats", 1), ("dummy-init-stats", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: initializeStats.setStatus('mandatory')
if mibBuilder.loadTexts: initializeStats.setDescription('Setting this variable to a value of 1 will force the unit to initialize (clear) SyncResearch proprietary statistics kept by the unit. This variable always returns a value of 2.')
clearDump = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear-dump-file", 1), ("dummy-clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearDump.setStatus('mandatory')
if mibBuilder.loadTexts: clearDump.setDescription('Setting this variable to a value of 1 will force the unit to clear a dump. This variable always returns a value of 2.')
acknowledgeAllStatuses = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acknowledgeAllStatuses.setStatus('mandatory')
if mibBuilder.loadTexts: acknowledgeAllStatuses.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will mark each of the various statuses in different levels as acknowledged. It will then re-consolidate without putting these statuses into consideration. Subseqent change of these statuses will cause the unit to include them in computing the status of the unit. Setting the object to no has no effect.')
consolidatedUnitStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknown", 1), ("normal", 2), ("informational", 3), ("disabled", 4), ("marginal", 5), ("warning", 6), ("minor", 7), ("major", 8), ("critical", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: consolidatedUnitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: consolidatedUnitStatus.setDescription('This object reports the consolidted status of the unit. All acknowledged element statuses and any element statuses specified as ignored by the user are ignored for unit level status computation.')
homeDialBackup = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("home-dial-backup", 1), ("dummy-home", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: homeDialBackup.setStatus('mandatory')
if mibBuilder.loadTexts: homeDialBackup.setDescription('Setting this variable to a value of 1 will force all dial backup lines to dedicated lines. Setting this variable to any other value will case an SNMP error. This variable always returns a value of 2.')
unitModel = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("boundary", 1), ("lic", 2), ("chipcomPED", 3), ("snacMIM", 4), ("microMac", 5), ("linkConverter", 6), ("universal-boundary", 7), ("universal-desktop", 8), ("linkConverterII", 9), ("ibm", 10), ("sync3600", 11), ("ibm3600", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitModel.setStatus('mandatory')
if mibBuilder.loadTexts: unitModel.setDescription('This variable defines the base hardware model of the unit.')
softwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: softwareVersion.setDescription('The current version number of the operating software in xx.yyy where xx = major release, yyy = revision.')
productType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productType.setStatus('mandatory')
if mibBuilder.loadTexts: productType.setDescription('The product type string returned is set in the MS.SYS file and defines the product name.')
maxPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxPortNumber.setDescription('The maximum number of ports this unit can support (total number of serial access ports plus total number of LAN ports).')
maxPU = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxPU.setStatus('mandatory')
if mibBuilder.loadTexts: maxPU.setDescription('The maximum number of PUs this unit can support (total number that can be configured).')
maxSession = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxSession.setStatus('mandatory')
if mibBuilder.loadTexts: maxSession.setDescription('The maximum number of sessions this unit can support (total number that can be configured).')
maxDevice = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxDevice.setStatus('mandatory')
if mibBuilder.loadTexts: maxDevice.setDescription('The maximum number of devices this unit can support (total number that can be configured).')
msBoardType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16, 17, 18, 22, 23, 26, 30))).clone(namedValues=NamedValues(("not-expected", 1), ("two-port-RS232", 16), ("two-port-RS422", 17), ("two-port-V35", 18), ("v35-RS232", 22), ("rs422-RS232", 23), ("two-port-universal", 26), ("two-port-iusc-RS232", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: msBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: msBoardType.setDescription('Indicates the type of serial I/O ports on main board. It returns 1 if not expected.')
msExtBoardType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 19, 20, 21, 24, 25, 27, 28, 29))).clone(namedValues=NamedValues(("not-present", 1), ("two-port-RS232", 19), ("two-port-RS422", 20), ("two-port-V35", 21), ("two-port-hspeedRS232", 24), ("two-port-hspeedV35", 25), ("two-port-universal", 27), ("four-port-universal", 28), ("six-port-universal", 29)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: msExtBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: msExtBoardType.setDescription('Indicates the type of serial I/O ports on extension board. It returns 1 if not present.')
dumpFileStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("dump-available", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dumpFileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dumpFileStatus.setDescription('Indicates the presence of a dump file.')
dumpFileName = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dumpFileName.setStatus('mandatory')
if mibBuilder.loadTexts: dumpFileName.setDescription('The dump file name.')
unitSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: unitSerialNumber.setDescription('The base unit serial number.')
expansionSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: expansionSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: expansionSerialNumber.setDescription('The expansion board serial number.')
romVersion = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: romVersion.setStatus('mandatory')
if mibBuilder.loadTexts: romVersion.setDescription('The ROM version number.')
processorType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("i286", 1), ("i386", 2), ("i486SX", 3), ("i486DX", 4), ("i486DX-2", 5), ("i486DX-4", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: processorType.setStatus('mandatory')
if mibBuilder.loadTexts: processorType.setDescription('The base unit processor type.')
chassisSlot = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSlot.setDescription('If the unit is a blade in a chassis, then this variable indicates the slot number. If not applicable, a value of 99 will be returned.')
lastTrapSeqNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastTrapSeqNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lastTrapSeqNumber.setDescription('This entry contains the last sequence number of the last trap generated by the unit. When this value reaches its maximum, it then rolls back to 0.')
lastInstallErrCode = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastInstallErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lastInstallErrCode.setDescription('This entry contains the status of last install. If the last install was successful, 0 is returned, 9999 indicates installation is in progress, otherwise an error code is returned.')
unitPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: unitPartNumber.setDescription('The base unit part number.')
expansionPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: expansionPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: expansionPartNumber.setDescription('The expansion board part number.')
wan1BoardType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 31))).clone(namedValues=NamedValues(("not-present", 1), ("dsu-csu", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wan1BoardType.setStatus('mandatory')
if mibBuilder.loadTexts: wan1BoardType.setDescription('Indicates the type of serial I/O ports on extension board. It returns 1 if not present.')
wan2BoardType = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 31, 32))).clone(namedValues=NamedValues(("not-present", 1), ("dsu-csu", 31), ("isdn", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wan2BoardType.setStatus('mandatory')
if mibBuilder.loadTexts: wan2BoardType.setDescription('Indicates the type of serial I/O ports on extension board. It returns 1 if not present.')
patchId = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 2, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: patchId.setStatus('mandatory')
if mibBuilder.loadTexts: patchId.setDescription("The current patch identifier for the operating software. Either the three character Patch ID or 'None'")
unitId = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitId.setStatus('mandatory')
if mibBuilder.loadTexts: unitId.setDescription('This is the unit id. It consists of a 1 to 8 octet right justified case-sensitive ASCII field which uniquely identifies the unit. This ID is displayed on the LCD display if available, all system dumps, and any ASCII alarms. The defalult value for this field is startup.')
nmsSerialSpeed = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 24, 48, 96, 192))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2400", 24), ("speed4800", 48), ("speed9600", 96), ("speed19200", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmsSerialSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: nmsSerialSpeed.setDescription('The async serial port speed for NMS console port. The speed is expressed in bits per second (i.e. 9.6 Kbps is represented as 96 decimal). Currently supported speeds are: 1200 2400 4800 9600 19200 Default speed is 9600 bits per second.')
serialPortLogoffTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialPortLogoffTimer.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortLogoffTimer.setDescription('Units are minutes. Default value is 0, indicating that no timer is active.')
callRetryTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: callRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: callRetryTimer.setDescription('The call retry timer (a.k.a Session Retry Timer). The number of seconds to wait before trying to retry a failed connection attempt. Currently supported values are 2 - 999 seconds. The default is 30 seconds.')
password = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: password.setStatus('mandatory')
if mibBuilder.loadTexts: password.setDescription("The unit's password. This field indicates the system password used to log into the unit for operating the NMS interface. This field is a one to eight byte case-sensitive left justified ASCII data field and may not be left blank. The default value is 'sri' (for Sync Research Inc.), or 'ctron' for Cabletron products.")
configPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPassword.setStatus('mandatory')
if mibBuilder.loadTexts: configPassword.setDescription("The configuration password. This field indicates the password used to enter the configuration subsystem. This field is a one to eight byte case-sensitive left justified ASCII data field and may not be left blank. The default value is 'sri' (for Sync Research Inc.), or 'ctron' for Cabletron products.")
dateTimeField = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dateTimeField.setStatus('mandatory')
if mibBuilder.loadTexts: dateTimeField.setDescription('The date and time. This field is stored as 6 bytes of BCD Data in the following order: Month: 0x01 - 0x12 Day: 0x01 - 0x31 Year: 0x00 - 0x99 Hour: 0x00 - 0x23 Minute: 0x00 - 0x59 Second: 0x00 - 0x59')
configId = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configId.setStatus('mandatory')
if mibBuilder.loadTexts: configId.setDescription('The configuration identifer. This field is the configuration ID assigned when a new configuration is activated. first time. It is assigned by the unit or a Sync Research management product (SyncMan) automatically and is not user assignable.')
internalMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: internalMacAddress.setDescription('Embedded conversion node MAC address. Applicable to Frame Node only.')
internalRingNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: internalRingNumber.setDescription('Embedded conversion node ring number. This should be unique within the network. Applicable to Frame Node only.')
internalBridgeNumber = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: internalBridgeNumber.setDescription('Embedded conversion node bridge number. This parameter is currently not used. Applicable to Frame Node only.')
internalMacAddress2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 12), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalMacAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: internalMacAddress2.setDescription('Optional second embedded conversion node MAC address. Applicable to Frame Node only.')
internalRingNumber2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalRingNumber2.setStatus('mandatory')
if mibBuilder.loadTexts: internalRingNumber2.setDescription('Optional second embedded conversion node ring number. This should be unique within the network. Applicable to Frame Node only.')
associatedPortNumber2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedPortNumber2.setStatus('mandatory')
if mibBuilder.loadTexts: associatedPortNumber2.setDescription('Assigns the physical port number corresponding to the virtual port that the second embedded conversion node is associated with. Applicable to Frame Node only.')
associatedDLCI2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedDLCI2.setStatus('mandatory')
if mibBuilder.loadTexts: associatedDLCI2.setDescription('Assigns the Frame Relay PVC number corresponding to the virtual port that the second embedded conversion node is associated with. Applicable to Frame Node only.')
internalMacAddress3 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 16), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalMacAddress3.setStatus('mandatory')
if mibBuilder.loadTexts: internalMacAddress3.setDescription('Optional third embedded conversion node MAC address. Applicable to Frame Node only.')
internalRingNumber3 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalRingNumber3.setStatus('mandatory')
if mibBuilder.loadTexts: internalRingNumber3.setDescription('Optional third embedded conversion node ring number. This should be unique within the network. Applicable to Frame Node only.')
associatedPortNumber3 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedPortNumber3.setStatus('mandatory')
if mibBuilder.loadTexts: associatedPortNumber3.setDescription('Assigns the physical port number corresponding to the virtual port that the third embedded conversion node is associated with. Applicable to Frame Node only.')
associatedDLCI3 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedDLCI3.setStatus('mandatory')
if mibBuilder.loadTexts: associatedDLCI3.setDescription('Assigns the Frame Relay PVC number corresponding to the virtual port that the third embedded conversion node is associated with. Applicable to Frame Node only.')
internalMacAddress4 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 20), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalMacAddress4.setStatus('mandatory')
if mibBuilder.loadTexts: internalMacAddress4.setDescription('Optional forth embedded conversion node MAC address. Applicable to Frame Node only.')
internalRingNumber4 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalRingNumber4.setStatus('mandatory')
if mibBuilder.loadTexts: internalRingNumber4.setDescription('Optional forth embedded conversion node ring number. This should be unique within the network. Applicable to Frame Node only.')
associatedPortNumber4 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedPortNumber4.setStatus('mandatory')
if mibBuilder.loadTexts: associatedPortNumber4.setDescription('Assigns the physical port number corresponding to the virtual port that the forth embedded conversion node is associated with. Applicable to Frame Node only.')
associatedDLCI4 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: associatedDLCI4.setStatus('mandatory')
if mibBuilder.loadTexts: associatedDLCI4.setDescription('Assigns the Frame Relay PVC number corresponding to the virtual port that the forth embedded conversion node is associated with. Applicable to Frame Node only.')
ipInactivityTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipInactivityTimer.setDescription('This timer is used for IP/SNMP over X25 support. It is the inactivity timer for an IP connection. If there is no activity for an IP session for the time this field specifies, IP will clear the session. The timer is expressed in seconds and is defaulted to 90.')
excessBurstGovernor = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: excessBurstGovernor.setStatus('mandatory')
if mibBuilder.loadTexts: excessBurstGovernor.setDescription('This parameter configuration determines whether the FrameNode should limit the throughput on a per PVC basis to the configured Excess Burst Size (in the excess burst measure time period Tc). The range of this parameter is YES or NO. Default value is NO')
measurementPeriod = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: measurementPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: measurementPeriod.setDescription('This parameter specifies the time period for calculating Excess Burst for Frame Relay ports. The range of this parameter is 1 second to 5 seconds. Default is 1 second.')
markDEBit = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 3, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: markDEBit.setStatus('mandatory')
if mibBuilder.loadTexts: markDEBit.setDescription("This parameter specifies whether the FrameNode marks frames with the DE bit. The range of this parameter is YES or NO. Default is YES. If the parameter is set to YES, the FrameNode marks the frames with the DE bit (for a non-urgent priority traffic) if a port's used bandwidth value is greater than the configured bandwidth.")
numberSamples = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSamples.setStatus('mandatory')
if mibBuilder.loadTexts: numberSamples.setDescription('The number of internal system level samples performed. Samples are taken every 10th of a second.')
systemBufferFreeCounts = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemBufferFreeCounts.setStatus('mandatory')
if mibBuilder.loadTexts: systemBufferFreeCounts.setDescription('The average number of system buffers free in the system during the system sample period. The number of available buffers varies by system type and configuration. To determine the maximum number of buffers for a given configuration, view a sample when there is no activity in the unit. A heavily loaded unit will display a small number of available buffers and low Processor Idle counts.')
cpuIdleSumCounts = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuIdleSumCounts.setStatus('mandatory')
if mibBuilder.loadTexts: cpuIdleSumCounts.setDescription('The main processor average idle sum count. This is the average number of times the idle counter was incremented over the sampling period divided by 1000. This is an absolute value of performance as does not vary by performance. A heavily loaded unit will display a small number of available buffers and low Processor Idle counts.')
netviewConnectionStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("not-connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: netviewConnectionStatus.setDescription('The status of the Primary Netview Connection.')
netviewLastClearCode = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewLastClearCode.setStatus('mandatory')
if mibBuilder.loadTexts: netviewLastClearCode.setDescription('A two octet field indicating the Last Clearing Cause and Diagnostic Field of the last failed primary NetView connection attempt (a.k.a. call attempt) or Netview active connection (a.k.a. session). For LLC type 2 connections the first octet (cause) is always 0. The second octet (diagnostic) indicates the reason for the last connection failure. The second octet is set to 0 when a sucessful call has been placed, or if no call has ever been placed (e.g. PU never came up). If the second octet is non-zero then it indicates the reason for the connection attempt failure. See current product documentation for list of possible values.')
netviewAltConnectionStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("not-connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewAltConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: netviewAltConnectionStatus.setDescription('The status of the alternate Netview Connection')
netviewAltLastClearCode = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewAltLastClearCode.setStatus('mandatory')
if mibBuilder.loadTexts: netviewAltLastClearCode.setDescription('A two octet field indicating the Last Clearing Cause and Diagnostic Field of the last failed alternate NetView connection attempt (a.k.a. call attempt) or Netview active connection (a.k.a. session). For LLC type 2 connections the first octet (cause) is always 0. The second octet (diagnostic) indicates the reason for the last connection failure. The second octet is set to 0 when a sucessful call has been placed, or if no call has ever been placed (e.g. PU never came up). If the second octet is non-zero then it indicates the reason for the connection attempt failure. See current product documentation for list of possible values.')
netviewConnectionAttemptCount = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewConnectionAttemptCount.setStatus('mandatory')
if mibBuilder.loadTexts: netviewConnectionAttemptCount.setDescription('The number of connection attempts performed on the Primary NetView PU. This count is set to zero at startup, and after every loss of an estabished session.')
netviewAltConnectionAttemptCount = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewAltConnectionAttemptCount.setStatus('mandatory')
if mibBuilder.loadTexts: netviewAltConnectionAttemptCount.setDescription('The number of connection attempts performed on the Alternate NetView PU. This count is set to zero at startup, and after every loss of an estabished session.')
netviewStatusIgnored = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netviewStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: netviewStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this netview pu is not put into consideration when consolidating status of the unit if this field is set to yes.')
netviewStatusAcknowledged = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netviewStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: netviewStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will re-consolidate its status without putting the status of this netview PU into consideration. Subseqent status change of the this netview PU will cause the unit to include it in computing the status of the unit. Setting the value to no has no effect.')
netviewAltStatusIgnored = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netviewAltStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: netviewAltStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this netview pu is not put into consideration when consolidating status of the unit if this field is set to yes.')
netviewAltStatusAcknowledged = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netviewAltStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: netviewAltStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will re-consolidate its status without putting the status of this netview pu into consideration. Subseqent status change of the this netview pu will cause the unit to include it in computing the status of the unit. Setting the value to no has no effect.')
netviewPUXID = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewPUXID.setStatus('mandatory')
if mibBuilder.loadTexts: netviewPUXID.setDescription('Primary NetView PU XID. This field indicates the XID data to be sent to the host for establishing Netview Session. This field is a maximum four byte hexadecimal data field. This field should be set to all zeroes if no Netview session is to be established. The default value is all zeroes.')
alternateNetviewPUXID = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alternateNetviewPUXID.setStatus('mandatory')
if mibBuilder.loadTexts: alternateNetviewPUXID.setDescription('Alternate NetView PU XID. This field indicates the XID data to be sent to the host for establishing Netview Session. This field is a maximum four byte hexadecimal data field. This field should be set to all zeroes if no Netview session is to be established. The default value is all zeroes.')
netviewConnectID = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewConnectID.setStatus('mandatory')
if mibBuilder.loadTexts: netviewConnectID.setDescription('The primary NetView PU connection ID. The default value is 0.')
alternateNetviewConnectID = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alternateNetviewConnectID.setStatus('mandatory')
if mibBuilder.loadTexts: alternateNetviewConnectID.setDescription('The alternate NetView PU connection ID. The default value is 0.')
netviewSpecialConnect = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netviewSpecialConnect.setStatus('mandatory')
if mibBuilder.loadTexts: netviewSpecialConnect.setDescription('The primary NetView PU connection type. The default value is originate.')
alternateNetviewSpecialConnect = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alternateNetviewSpecialConnect.setStatus('mandatory')
if mibBuilder.loadTexts: alternateNetviewSpecialConnect.setDescription('The alternate NetView PU connection type. The default value is originate.')
brEnableBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableBridging.setDescription("This flag indicates if bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'No'")
bridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: bridgePriority.setDescription('Sometimes referred to as the ROOT id. Determines the priority component of the Bridge identifier used in determining the Root Bridge for a spanning tree network.')
brMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: brMaxAge.setDescription('The time at which a configuration message is descarded. Units are in seconds. Default value is 10 seconds')
brHelloTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brHelloTimer.setStatus('mandatory')
if mibBuilder.loadTexts: brHelloTimer.setDescription('The time interval between issuing configuration messages. Units are seconds. Default value is 2 seconds')
brFilterIPX = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brFilterIPX.setStatus('mandatory')
if mibBuilder.loadTexts: brFilterIPX.setDescription('If set to yes, all IPX frames are filtered (if bridge is enabled). Default is no.')
brFilterIP = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brFilterIP.setStatus('mandatory')
if mibBuilder.loadTexts: brFilterIP.setDescription('If set to yes, all IP frames are filtered (if bridging is enabled). Default is no.')
brFilterNetBIOS = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brFilterNetBIOS.setStatus('mandatory')
if mibBuilder.loadTexts: brFilterNetBIOS.setDescription('If set to yes, all NetBIOS frames are filtered (if bridging is enabled). Default is no.')
brFilterLLC2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brFilterLLC2.setStatus('mandatory')
if mibBuilder.loadTexts: brFilterLLC2.setDescription('If set to yes, all LAN attached SNA LLC2 frames are filtered (if bridging is enabled). Default is no.')
brFilterSMAN = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brFilterSMAN.setStatus('mandatory')
if mibBuilder.loadTexts: brFilterSMAN.setDescription('If set to yes, all SyncManager LLC2 frames are filtered (if bridging is enabled). Default is no.')
brForwardOther = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brForwardOther.setStatus('mandatory')
if mibBuilder.loadTexts: brForwardOther.setDescription('If set to yes, all other frames are forwarded (if bridging is enabled). Default is No.')
brIPXtargetPort = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPXtargetPort.setStatus('mandatory')
if mibBuilder.loadTexts: brIPXtargetPort.setDescription('If IPX filtering is set to no, then this parameter defines a specific FR port to deliver IPX frames to. Used in conjunction with brIPXtargetDLCI. The valid range is 0 to 5. A value of 0 indicates that the IPX target port/DLCI is not configured. This field has the default value of 0.')
brIPXtargetDLCI = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPXtargetDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: brIPXtargetDLCI.setDescription('If IPX filtering is set to no, then this parameter defines a specific FR DLCI to deliver IPX frames to. Used in conjunction with brIPXtargetPort. If the value of brIPXtargetport is 0, then the value of brIPXtargetDLCI is not significant.')
brIPtargetPort = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPtargetPort.setStatus('mandatory')
if mibBuilder.loadTexts: brIPtargetPort.setDescription('If IP filtering is set to no, then this parameter defines a specific FR port to deliver IP frames to. Used in conjunction with brIPtargetDLCI. The valid range is 0 to 5. A value of 0 indicates that the IP target port/DLCI is not configured. This field has the default value of 0.')
brIPtargetDLCI = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPtargetDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: brIPtargetDLCI.setDescription('If IP filtering is set to no, then this parameter defines a specific FR DLCI to deliver IP frames to. Used in conjunction with brIPtargetPort. If the value of brIPtargetport is 0, then the value of brIPtargetDLCI is not significant.')
brNetBIOStargetPort = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brNetBIOStargetPort.setStatus('mandatory')
if mibBuilder.loadTexts: brNetBIOStargetPort.setDescription('If NetBIOS filtering is set to no, then this parameter defines a specific FR port to deliver NetBIOS frames to. Used in conjunction with brNetBIOStargetDLCI. The valid range is 0 to 5. A value of 0 indicates that the NetBIOS target port/DLCI is not configured. This field has the default value of 0.')
brNetBIOStargetDLCI = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brNetBIOStargetDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: brNetBIOStargetDLCI.setDescription('If NetBIOS filtering is set to no, then this parameter defines a specific FR DLCI to deliver NetBIOS frames to. Used in conjunction with brNetBIOStargetPort. If the value of brNetBIOStargetport is 0, then the value of brNetBIOStargetDLCI is not significant.')
brLLC2targetPort = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brLLC2targetPort.setStatus('mandatory')
if mibBuilder.loadTexts: brLLC2targetPort.setDescription('If SNA LLC2 filtering is set to no, then this parameter defines a specific FR port to deliver LLC2 frames to. Used in conjunction with brLLC2targetDLCI. The valid range is 0 to 5. A value of 0 indicates that the brLLC2targetport/brLLC2targetDLCI is not configured. This field has the default value of 0.')
brLLC2targetDLCI = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brLLC2targetDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: brLLC2targetDLCI.setDescription('If SNA LLC2 filtering is set to no, then this parameter defines a specific FR DLCI to deliver LLC2 frames to. Used in conjunction with brLLC2targetPort. If the value of brLLC2targetport is 0, then the value of brLLC2targetDLCI is not significant.')
brOthertargetPort = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brOthertargetPort.setStatus('mandatory')
if mibBuilder.loadTexts: brOthertargetPort.setDescription('If Other forwarding is set to yes, then this parameter defines a specific FR port to deliver Other frames to. Used in conjunction with brOthertargetDLCI. The valid range is 0 to 5. The value 0 indicates that the brOthertargetport/brOthertargetDLCI is not configured. This field has the default value of 0.')
brOthertargetDLCI = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brOthertargetDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: brOthertargetDLCI.setDescription('If Other forwarding is set to yes, then this parameter defines a specific FR DLCI to deliver Other frames to. Used in conjunction with brOthertargetPort. If the value of brOthertargetport is 0, then the value of brOthertargetDLCI is not significant.')
brSerialPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brSerialPriority.setStatus('mandatory')
if mibBuilder.loadTexts: brSerialPriority.setDescription('This parameter defines the transmit priority for Frame Relay of serial attached port traffic.')
brTerminatedLLC2Priority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brTerminatedLLC2Priority.setStatus('mandatory')
if mibBuilder.loadTexts: brTerminatedLLC2Priority.setDescription('This parameter defines the transmit priority for Frame Relay of terminated LLC2 traffic.')
brLLC2Priority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brLLC2Priority.setStatus('mandatory')
if mibBuilder.loadTexts: brLLC2Priority.setDescription('This parameter defines the transmit priority for Frame Relay of SNA LLC2 traffic.')
brIPXPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPXPriority.setStatus('mandatory')
if mibBuilder.loadTexts: brIPXPriority.setDescription('This parameter defines the transmit priority for Frame Relay of IPX traffic.')
brIPPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brIPPriority.setStatus('mandatory')
if mibBuilder.loadTexts: brIPPriority.setDescription('This parameter defines the transmit priority for Frame Relay of IP traffic.')
brNetBIOSPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brNetBIOSPriority.setStatus('mandatory')
if mibBuilder.loadTexts: brNetBIOSPriority.setDescription('This parameter defines the transmit priority for Frame Relay of NetBIOS traffic.')
brOtherPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brOtherPriority.setStatus('mandatory')
if mibBuilder.loadTexts: brOtherPriority.setDescription('This parameter defines the transmit priority for Frame Relay of other traffic.')
brHighPriorityBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brHighPriorityBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brHighPriorityBandwidth.setDescription('This parameter defines the high priority bandwidth. The sum of high, medium, and low priority bandwidth cannot exceed 100. Default value is 40.')
brMediumPriorityBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMediumPriorityBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brMediumPriorityBandwidth.setDescription('This parameter defines the medium priority bandwidth. The sum of high, medium, and low priority bandwidth cannot exceed 100. Default value is 30.')
brLowPriorityBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brLowPriorityBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brLowPriorityBandwidth.setDescription('This parameter defines the low priority bandwidth. The sum of high, medium, and low priority bandwidth cannot exceed 100. Default value is 20.')
brDelayTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: brDelayTimer.setDescription('This field, expressed in seconds, specifies the maximum number of seconds a bridge frame can live in the unit. If a bridge frame stays in the unit longer than this value, the frame will be tossed. The default value for this field is 1')
brEnableIPXBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableIPXBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableIPXBridging.setDescription("This flag indicates if IPX bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'Yes'")
brEnableIPBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableIPBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableIPBridging.setDescription("This flag indicates if IP bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'Yes'")
brEnableNetBiosBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableNetBiosBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableNetBiosBridging.setDescription("This flag indicates if NetBios bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'Yes'")
brEnableSNABridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableSNABridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableSNABridging.setDescription("This flag indicates if SNA bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'Yes'")
brEnableSyncManBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableSyncManBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableSyncManBridging.setDescription("This flag indicates if Sync/Man bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'Yes'")
brEnableOtherBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 3, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brEnableOtherBridging.setStatus('mandatory')
if mibBuilder.loadTexts: brEnableOtherBridging.setDescription("This flag indicates if any other traffic bridging is to be performed on this unit. Applicable to Frame Nodes only. The default value for this field is 'No'")
ipxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1), )
if mibBuilder.loadTexts: ipxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStatsTable.setDescription('A table for reporting statistics for bridging.')
ipxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "ipxStatsIndex"))
if mibBuilder.loadTexts: ipxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStatsEntry.setDescription('An entry consisting of IPX bridging statistics for each bridge port.')
ipxStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStatsIndex.setDescription('The number that uniquely identifies this IPX bridge port.')
ipxRipRcvdFwdInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRipRcvdFwdInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRipRcvdFwdInterval.setDescription('Identifies the number of IPX RIP packets received on this port during the RIP forwarding interval. These packets were accepted by the port.')
ipxRipRcvdFiltInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRipRcvdFiltInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRipRcvdFiltInterval.setDescription('Identifies the number of IPX RIP packets received on this port during the RIP filtering interval. These packets were tossed by the port.')
ipxSapRcvdFwdInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSapRcvdFwdInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSapRcvdFwdInterval.setDescription('Identifies the number of IPX SAP packets received on this port during the SAP forwarding interval. These packets were accepted by the port.')
ipxSapRcvdFiltInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSapRcvdFiltInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSapRcvdFiltInterval.setDescription('Identifies the number of IPX SAP packets received on this port during the SAP filtering interval. These packets were tossed by the port.')
ipxEnableRouting = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxEnableRouting.setStatus('mandatory')
if mibBuilder.loadTexts: ipxEnableRouting.setDescription("This parameter determines whether or not IPX Routing is enabled. Thr range of this parameter is yes or no. If set to yes, the parameter 'Filter IPX' should be set to yes. The default value for this field is 'No'")
ipxRoutedTxPriority = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("urgent", 1), ("high", 2), ("medium", 3), ("low", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRoutedTxPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRoutedTxPriority.setDescription("This parameter governs the transmission priority of the routed IPX frames for Frame Relay port(s). The range is URGENT, HIGH, MEDIUM AND LOW. The default is set to 'High'.")
ipxEnableRipBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxEnableRipBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: ipxEnableRipBroadcast.setDescription("This parameter governs whether the framenode should send RIP packets or not. The range of this parameter is YES or NO. If IPX routing is disabled, this parameter is ignored. The default value for this field is 'Yes'")
ipxEnableSapBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxEnableSapBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: ipxEnableSapBroadcast.setDescription("This parameter governs whether the framenode should send SAP packets. The range of this parameter is YES or NO. If IPX routing is disabled, this parameter is ignored. The default value for this field is 'Yes'")
ipxEnableNetBIOS = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxEnableNetBIOS.setStatus('mandatory')
if mibBuilder.loadTexts: ipxEnableNetBIOS.setDescription('This parameter governs whether the frame Node should process NetBIOS packets or not. The range of this parameter is Yes or No. If IPX Routing is disabled, this parameter is ignored. Default is Yes.')
ipxGlobalNodeId = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxGlobalNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: ipxGlobalNodeId.setDescription(" By default FrameNode always implements IPX WAN over Frame Relay. The 'timer request' packet is transmitted by the FrameNode over Frame Relay. This packet includes a field call WAN Node (referred to as WNode ID). This parameter defines the Wnode ID field. This field is 4 hexadecimal bytes (8 characters) long. This field is used in determining the MASTER and SLAV relationship between two end points. If IPX routing is enabled, this field needs to be configured for proper operation of IPX routing over Frame Relay. This value should be unique in the network. Default is undefined.")
priIPHelperAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIPHelperAddress.setStatus('mandatory')
if mibBuilder.loadTexts: priIPHelperAddress.setDescription('This is the Primary IP Helper Address of this unit.')
secIPHelperAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: secIPHelperAddress.setStatus('mandatory')
if mibBuilder.loadTexts: secIPHelperAddress.setDescription('This is the Secondary IP Helper Address of this unit.')
internalIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: internalIPAddr.setDescription('The range of this parameter and the default value is same as other IP Address in the unit.')
internalIPNetmask = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalIPNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: internalIPNetmask.setDescription('This is the Internal IP network mask.')
enableIpRouting = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enableIpRouting.setStatus('mandatory')
if mibBuilder.loadTexts: enableIpRouting.setDescription('This is the Internal IP network mask.')
enableIpBridging = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enableIpBridging.setStatus('mandatory')
if mibBuilder.loadTexts: enableIpBridging.setDescription('This is the Internal IP network mask.')
enableRipBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 485, 3, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enableRipBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: enableRipBroadcast.setDescription('This is the Internal IP network mask.')
lanControlTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1), )
if mibBuilder.loadTexts: lanControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlTable.setDescription('A table for controlling LAN ports and obtaining information.')
lanControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "lanControlIndex"))
if mibBuilder.loadTexts: lanControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlEntry.setDescription('An entry consisting of port information for a particular LAN port.')
lanControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlIndex.setDescription('The number that uniquely identifies this LAN port. Currently only one LAN port per unit is supported.')
lanControlType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(21, 17))).clone(namedValues=NamedValues(("token-ring-type", 21), ("ethernet-type", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanControlType.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlType.setDescription('The LAN type. Token-Ring ports run the IEEE 802.5 protocol. Ethernet-type run the IEEE 802.3 and Ethernet Version 2. Other LAN protocols may be added in the future.')
lanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("failed", 3), ("restart", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lanStatus.setDescription('The status of the port. To change status of a port an enable, enable all or disable may be set. Valid Return status are enable(d), disable(d), or failed. Commands: An enable command will attempt to bring up the LAN. An enable all command will perform the same function as enable, since there are no sub elements on a LAN. A disable command will disable the LAN. Status: Enable(d) indicates the LAN is enabled and running. Disable(d) indicates the LAN has been disabled. Failed indicates the LAN is enabled and not Running.')
lanControlFailureCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanControlFailureCode.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlFailureCode.setDescription('This entry contains the failure codes if the associated LAN interface is in the failed state.')
lanControlNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanControlNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: lanControlNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
lanStatusIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: lanStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this LAN is not put into consideration when consolidating status of the unit if this field is set to yes.')
lanStatusAcknowledged = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: lanStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will re-consolidate its status without putting the status of this LAN into consideration. Subseqent status change of the LAN will cause the unit to include it in computing the status of the unit. Setting this value to no has no effect.')
lanPortTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1), )
if mibBuilder.loadTexts: lanPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lanPortTable.setDescription('A table of LAN information.')
lanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "lanPortIndex"))
if mibBuilder.loadTexts: lanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lanPortEntry.setDescription('An entry consisting of port information for a particular LAN port.')
lanPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lanPortIndex.setDescription('The port number that uniquely identifies this port. Currently only one LANtoken ring port per unit is supported.')
lanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(21, 17))).clone(namedValues=NamedValues(("token-ring-type", 21), ("ethernet-type", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPortType.setStatus('mandatory')
if mibBuilder.loadTexts: lanPortType.setDescription('The LAN port type.')
lanMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lanMACAddress.setDescription('The user configured LANtoken ring MAC address. If the address is set to 0 then the burned-in Address is used. This field contains a user configured address if any. If a user configured address is desired, then it must be configured as a valid individual, user defined - MAC address. The address must be configured in the native format convention used by the LAN port. For token Ring LAN ports the address follows User configured addresses must follow IEEE 802.5 IEEE 802.5 rules (most significant bit transmitted first) and must be between 400000000000 and 7FFFFFFFFFFF hexadecimal inclusive. For Ethernet LAN ports the format is must follow IEEE 802.3 rules.where the two least significant bits of the first octet must be zero. This means the first octet must be in the set of numbers 0x00, 0x04, 0x08, ... 0xFC..... The Default Value for this field is all zeroes.')
lanPROMMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPROMMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lanPROMMACAddress.setDescription('The burned in MAC address. This is the MAC address assigned by the factory when the unit is shipped. If the User configured address is set to 0, then this will be the address used by the adapter for the source address field for all frames sent by the LAN adapter. The format ordering of bits is as defined in IEEE 802.5. This ordering is where the Most Significant Bit is transmitted first. This is different from other protocols (e.g. 802.3) where the least significant bit is transmitted first. The representation of the MAC address is in the format native for the LAN port. Boundary platform Token-Ring LAN ports start with the first six digits (three octects) equal to 0002F6 which indicates a Sync Research Token Ring MAC address. Boundary platform Ethernet LAN ports start with the first six digits (three octects) equal to to 00406F which indicates a Sync Research Ethernet MAC address. This field is not changable via any commands and will always contain the manufactured MAC address for the LAN port.')
lanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 10, 16))).clone(namedValues=NamedValues(("speed-4Mbs", 4), ("speed-10Mbs", 10), ("speed-16Mbs", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lanSpeed.setDescription('The LAN port speed in Megabits/second.')
lanT1Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanT1Timer.setStatus('mandatory')
if mibBuilder.loadTexts: lanT1Timer.setDescription('The default LLC T1 timer value in seconds. T1 should be greater than T2 and less than Ti. Currently supported values are 1 to 25 seconds. The default value for this field is 3 seconds.')
lanT2Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanT2Timer.setStatus('mandatory')
if mibBuilder.loadTexts: lanT2Timer.setDescription('The default LLC T2 timer value in tenths of seconds. If configured for 0 then the T2 timer is disabled and an RR frame will be sent for every I frame received. Current supported values are 0 and 2-50. T2 should be less than T1. The default value for this field is 0 (disabled).')
lanTiTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanTiTimer.setStatus('mandatory')
if mibBuilder.loadTexts: lanTiTimer.setDescription('The default LLC Ti (inactivity) timer value in seconds. Ti should be greater than T1. Currently supported values are 2 to 50 seconds. The default value for this field is 30 seconds.')
lanRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: lanRxWindowSize.setDescription('The default LLC receive window (N3) size. Note that this is not the same receive window as defined in IEEE 802.2 LLC. This is N3 which is the number of I frames received before an RR frame is sent (defined as N3 in IEEE 802.2 LLC). Current allowable values are 1-15. The default value for this field is 7.')
lanTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: lanTxWindowSize.setDescription('The defalut LLC transmit window size. Current allowable values are 1-15. The default value for this field is 7.')
lanMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: lanMaxRetries.setDescription('The default LLC maximum number of retries (N2 value). Current allowable values are 1-99. The default value for this field is 3.')
lanRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lanRingNumber.setDescription('802.5 bridging parameter. This variable returns a value of 0, if it is not defined. This value is configured in hex from 0 to FFF. This value is not applicable to Ethernet.')
lanBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lanBridgeNumber.setDescription('802.5 bridging parameter. The default value for this field is 1. This value is not applicable to Ethernet.')
lanEthernetFrameFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("e802-3-type", 2), ("ethernet-type-2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanEthernetFrameFormat.setStatus('mandatory')
if mibBuilder.loadTexts: lanEthernetFrameFormat.setDescription('The Ethernet frame format used on this LAN. The default value for this field is 802.3. Not used if Token Ring, and 1 is returned.')
lanSendLocalTest = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanSendLocalTest.setStatus('mandatory')
if mibBuilder.loadTexts: lanSendLocalTest.setDescription("This port's send local test option. Identifies whether a test frame should be sent on the local ring to discover a destination MAC address. If all destinations for the unit are located on a remote ring, setting this field to No allows the unit to bypass discovery of a destination MAC address on the local ring. If this field is set to 'No' then the broadcastType field must be set to all routes or single route broadcast. If the any destination is on a local ring or unknown, this parameter should be set to 'Yes'. The default value for this field is 'Yes'. Not used if Ethernet, and 0 is returned.")
lanBroadcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-applicable", 1), ("none-bc", 2), ("all-bc", 3), ("single-bc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanBroadcastType.setStatus('mandatory')
if mibBuilder.loadTexts: lanBroadcastType.setDescription("This port's broadcast type. Not used if Ethernet. Types are: none, all-routes, and single-route. Identifies the form of a broadcast test frame sent to discover the route to a destination MAC address. If all destinations are located on the local ring, this field may be set to 'None' to prevent a broadcast search for a destination MAC address. If set to 'None', then the sendLocalTest field must be set to 'Yes'. If set as 'All-routes', the unit will send an All-routes broadcast TEST command frame and expect a non-broadcast TEST response frame in return. If set to Single-route, the unit will send a Single-route broadcast TEST command frame and expect a all-routes TEST response frame in return. The default for this field is all routes broadcast. Not used if Ethernet, and 0 is returned.")
lanIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lanIPAddress.setDescription('This is the IP Address of this interface.')
lanNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: lanNetworkMask.setDescription('This is the network mask to be used on this interface.')
lanDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: lanDefaultGateway.setDescription('Default gateway address to be used when sending responses on this interface.')
lanNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: lanNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
lanInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-applicable", 1), ("aui", 2), ("bnc", 3), ("utp", 4), ("stp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: lanInterfaceType.setDescription("This port's physical interface type. Only used if Ethernet. The default for this field is utp. Not used if Token Ring, and 1 is returned.")
lanIPEthernetFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("e802-3-type", 2), ("ethernet-type-2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanIPEthernetFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: lanIPEthernetFrameType.setDescription('The IP Ethernet frame format used on this LAN for IP frames. The default value for this field is 802.3. Not used if Token Ring, and 1 is returned.')
lanInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanInitState.setStatus('mandatory')
if mibBuilder.loadTexts: lanInitState.setDescription("The initial state of the LAN port. If configured for 'in-service', then the LAN port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the LAN port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
lanSecondDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 24), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanSecondDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: lanSecondDefaultGateway.setDescription('Second Default gateway address to be used when sending responses on this interface.')
lanRIPUpdtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRIPUpdtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: lanRIPUpdtTimer.setDescription('Defines frequency at which the RIP packets are sent over this interface. The range of this parameter is from 10 seconds to 180 seconds. A value of 0 implies no RIP is sent over this interface. Default value is 60 seconds')
lanRIPAge = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 540))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRIPAge.setStatus('mandatory')
if mibBuilder.loadTexts: lanRIPAge.setDescription('Defines frequency at which the learned RIP entries are removed if not corresponding RIP update is received. The range of this parameter is from 40 seconds to 540 seconds. Default value is 180 seconds')
lanSAPUpdtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanSAPUpdtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: lanSAPUpdtTimer.setDescription('Defines frequency at which the SAP packets are sent over this interface. The range of this parameter is from 10 seconds to 180 seconds. A value of 0 implies that no SAP broadcasts are sent over this interface. Default value is 60 seconds')
lanSAPAge = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanSAPAge.setStatus('mandatory')
if mibBuilder.loadTexts: lanSAPAge.setDescription('Defines frequency at which the learned SAP entries are removed if not corresponding SAP update is received. The range of this parameter is from 40 seconds to 720 seconds. Default value is 180 seconds')
lanRSM = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 4, 2, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRSM.setStatus('mandatory')
if mibBuilder.loadTexts: lanRSM.setDescription("The Routing Summary Information parameter indicates whether the routing summary information should be generated in the RIP on that interface. If RSM is set to NO, RIP will broadcast subnet information as it is defined in the routing table. Default value is 'NO'")
lineControlTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1), )
if mibBuilder.loadTexts: lineControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlTable.setDescription('A table for controlling lines and obtaining information.')
lineControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "lineControlIndex"))
if mibBuilder.loadTexts: lineControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlEntry.setDescription('An entry consisting of port information for a particular port.')
lineControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlIndex.setDescription('The port number that uniquely identifies this port.')
lineControlType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7, 8, 9, 10, 11, 12, 19, 20, 13, 14))).clone(namedValues=NamedValues(("hbsc-type", 1), ("tbsc-type", 2), ("x25dte-type", 7), ("x25dce-type", 8), ("hasc-type", 9), ("tasc-type", 10), ("hsdlc-type", 11), ("tsdlc-type", 12), ("frameRelay-type", 19), ("dial-backup-type", 20), ("secondaryRJE-type", 13), ("primaryRJE-type", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineControlType.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlType.setDescription('The port type. TSDLC (Terminal SDLC) ports emulate a Host and poll the downstream PUs (e.g. 3274 or 3174 SDLC/SNA controllers). HSDLC ports (Host SDLC) ports emulate a line with Terminal Controllers (PUs) and respond to polls from the Host or upstream PU. TBSC (Terminal Bisync) ports emulate a Host and poll the downstream CUs (e.g. 3274 or ATM Bisync controllers). HBSC ports (Host Bisync) ports emulate a line with Terminal Controllers (CUs) and respond to polls from the Host or upstream CU. Frame Relay ports support Frame Relay PVC. X25 type is for either X.25 packet level DCE or DTE.')
lineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("failed", 3), ("restart", 4), ("enable-all", 5), ("not-in-use", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lineStatus.setDescription('The status of the port. To change status of a port an enable, enable all or disable may be set. Valid Return status are enable(d), disable(d), or failed. When calculating consolidated status for the unit, if the line status set to not-in-use then this port is not included. Commands: An enable command will attempt to bring up the line. An enable all command will attempt to bring up the line and any lower layer entities (e.g. PUs). A disable command will disable the line. Status: Enable(d) indicates the line is enabled and running. Disable(d) indicates the line has been disabled. Failed indicates the line is enabled and not Running.')
lineControlFailureCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineControlFailureCode.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlFailureCode.setDescription('This entry contains the failure codes if the associated port interface is in the failed state.')
lineControlNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineControlNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: lineControlNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
lineStatusIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: lineStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this line is not put into consideration when consolidating status of the unit if this field is set to yes.')
lineStatusAcknowledged = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: lineStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will re-consolidate its status without putting the status of this line into consideration. Subseqent status change of the line will cause the unit to include it in computing the status of the unit. Setting this value to no has no effect.')
loopbackTest = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 1), ("network-or-full", 2), ("remote", 3), ("stop-test", 4), ("passive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loopbackTest.setStatus('mandatory')
if mibBuilder.loadTexts: loopbackTest.setDescription('Loopback Test can be supported on both DSU/CSU and ISDN. Loopback can be local, Network, or Remote. Local loopback means outgoing serial data is looped back toward DTE device. Network loopback triggers the local node to loopback any incoming serial data back to the network. Remote loopback triggers the far end node to loopback any serial data received from the network. A local loopback test is stopped by entering a Ctrl-C.')
linePhysicalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1), )
if mibBuilder.loadTexts: linePhysicalTable.setStatus('mandatory')
if mibBuilder.loadTexts: linePhysicalTable.setDescription('A table for obtaining physical signal status information.')
linePhysicalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: linePhysicalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: linePhysicalEntry.setDescription('An entry consisting of port information for a particular port.')
linePhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linePhysicalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: linePhysicalIndex.setDescription('The port number that uniquely identifies this port.')
linePhysicalType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7, 8, 9, 10, 19, 11, 12, 20, 13, 14))).clone(namedValues=NamedValues(("hbsc-type", 1), ("tbsc-type", 2), ("x25dte-type", 7), ("x25dce-type", 8), ("tasc-type", 9), ("hasc-type", 10), ("frameRelay-type", 19), ("hsdlc-type", 11), ("tsdlc-type", 12), ("dial-backup-type", 20), ("secondaryRJE-type", 13), ("primaryRJE-type", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linePhysicalType.setStatus('mandatory')
if mibBuilder.loadTexts: linePhysicalType.setDescription('The port type. TSDLC (Terminal SDLC) ports emulate a Host and poll the downstream PUs (e.g. 3274 or 3174 SDLC/SNA controllers). HSDLC ports (Host SDLC) ports emulate a line with Terminal Controllers (PUs) and respond to polls from the Host or upstream PU. TBSC (Terminal Bisync) ports emulate a Host and poll the downstream CUs (e.g. 3274 or ATM Bisync controllers). HBSC ports (Host Bisync) ports emulate a line with Terminal Controllers (CUs) and respond to polls from the Host or upstream CU. Frame Relay ports support Frame Relay PVC.')
lineEIAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineEIAStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lineEIAStatus.setDescription("A port's current control signal status. All SDLC ports have the ability to read the current status of RS-232 or equivalent control signals. The value returned is a 16 bit value where each bit signifies a signal status where 1 means the signal is active and 0 means the signal is inactive. The value returned is a snapshot taken when the command actually is sent to the driver software and wherever possible actually goes out to the driver or receiver control chips to get the value. Currently defined bit values are as follows*: 128 : Data Terminal Ready 0x0080 RS-232 pin 20 64 : Data Set Ready 0x0040 RS-232 pin 6 32 : Clear to Send 0x0020 RS-232 pin 5 16 : Clear to Send Ext. 0x0010 RS-232 pin 11** 8 : Data Carrier Detect 0x0008 RS-232 pin 8 4 : Busy Out 0x0004 RS-232 pin 25 2 : Request to send 0x0002 RS-232 pin 4 1 : Ring Indicator 0x0001 RS-232 pin 22 Note*: Bit values higher than 128 are reserved for future use. Note**: Clear to Send External is extended (non- standard) pin and reserved for future use by Sync Research.")
lineQualityFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineQualityFrameCount.setStatus('mandatory')
if mibBuilder.loadTexts: lineQualityFrameCount.setDescription('This entry contains the number of frames received. For every 255 incoming frames, a trap is generated by the unit if lineQualityCRCErrors or lineQualityAborts exceeds 5. When this value reaches 255, it then rolls back to 0. Applicable to SDLC only.')
lineQualityCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineQualityCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lineQualityCRCErrors.setDescription('This entry contains the number of frames with CRC errors. For every 255 incoming frames, a trap is generated by the unit if lineQualityCRCErrors or lineQualityAborts exceeds 5. Applicable to SDLC only.')
lineQualityAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineQualityAborts.setStatus('mandatory')
if mibBuilder.loadTexts: lineQualityAborts.setDescription('This entry contains the number of aborts received. For every 255 incoming frames, a trap is generated by the unit if lineQualityCRCErrors or lineQualityAborts exceeds 5. Applicable to SDLC only.')
lineInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("line-RS232", 1), ("line-V35", 2), ("line-RS530", 3), ("line-universal", 4), ("dsu-csu", 5), ("isdn", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: lineInterfaceType.setDescription('Report hardware Interface type of the line. For older systems, this interface is fixed per port. For universal ports, the Interface type if set via the cable.')
lineCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("not-applicable", 1), ("indeterminate-cable", 2), ("no-cable-attached", 3), ("rs232-DTE-cable", 4), ("rs232-DCE-cable", 5), ("v35-DTE-cable", 6), ("v35-DCE-cable", 7), ("x21-DTE-cable", 8), ("x21-DCE-cable", 9), ("rs530-DTE-cable", 10), ("rs530-DCE-cable", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineCableType.setStatus('mandatory')
if mibBuilder.loadTexts: lineCableType.setDescription('Returns not-applicable if the h/w does not support universal port configuration. Identifies the cable type connected to the port.')
lineSwitchedConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("dedicated", 2), ("switched", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineSwitchedConnection.setStatus('mandatory')
if mibBuilder.loadTexts: lineSwitchedConnection.setDescription('Identifies whether the line is connected over a switched backup facility or a dedicated facility to a frame relay network. This parameter is applicable to frame relay port only. For any other ports it returns not-applicable. If the object frameRelaySwitchedBackup is set to none it returns not-applicable. Otherwise returns appropriate value.')
isdndeviceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1), )
if mibBuilder.loadTexts: isdndeviceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdndeviceConfigTable.setDescription('A list of device entries.')
isdndeviceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "isdnLineIndex"))
if mibBuilder.loadTexts: isdndeviceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdndeviceConfigEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
isdnLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnLineIndex.setDescription('The port number for which the ISDN line is configured (line level).')
serviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceType.setStatus('mandatory')
if mibBuilder.loadTexts: serviceType.setDescription('Defines the service type of the ISDN WAN port.')
isdnSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(560, 640))).clone(namedValues=NamedValues(("speed56000", 560), ("speed64000", 640)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: isdnSpeed.setDescription('The ports speed in 100 bits per second. The default value is 56000 bits per second.')
connectionTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: connectionTimeOut.setDescription('Defines the time to wait after sensing disruption before declaring failure. The range is 0 to 255 seconds. The default value is 12 seconds.')
nosConnectAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nosConnectAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: nosConnectAttempts.setDescription('Defines the number or re-dial attempts before fail to connect. The range is 0 to 255. The default value is 1.')
farEndNumberType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: farEndNumberType.setStatus('mandatory')
if mibBuilder.loadTexts: farEndNumberType.setDescription('One byte field that defines the called number type.')
farEndNumberPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: farEndNumberPlan.setStatus('mandatory')
if mibBuilder.loadTexts: farEndNumberPlan.setDescription('One byte field that defines the called number Plan.')
farEndNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: farEndNumber.setStatus('mandatory')
if mibBuilder.loadTexts: farEndNumber.setDescription('One byte field that defines the called number.')
localNumberType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localNumberType.setStatus('mandatory')
if mibBuilder.loadTexts: localNumberType.setDescription('One byte field that defines the local number type.')
localNumberPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localNumberPlan.setStatus('mandatory')
if mibBuilder.loadTexts: localNumberPlan.setDescription('One byte field that defines the local number Plan.')
localNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localNumber.setStatus('mandatory')
if mibBuilder.loadTexts: localNumber.setDescription('One byte field that defines the local number.')
spid = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: spid.setStatus('mandatory')
if mibBuilder.loadTexts: spid.setDescription('SPID is a zero-terminated ASCII string with a minium length of 0 and a maximum length of 20. ')
isdndeviceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2), )
if mibBuilder.loadTexts: isdndeviceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdndeviceStatsTable.setDescription('A list of device entries.')
isdndeviceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "isdnIndex"))
if mibBuilder.loadTexts: isdndeviceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdndeviceStatsEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
isdnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIndex.setDescription('The port number for which the ISDN line is configured (line level).')
channelID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelID.setStatus('mandatory')
if mibBuilder.loadTexts: channelID.setDescription('The port number for which the ISDN line is configured (line level).')
kbytesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kbytesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: kbytesTransmitted.setDescription('This entry contains the number of bytes transmited.')
kbytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kbytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: kbytesReceived.setDescription('This entry contains the number of bytes received.')
packetsTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: packetsTransmitted.setDescription('This entry contains the number of packets transmited.')
packetsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: packetsReceived.setDescription('This entry contains the number of packets received.')
isdnloopbackbytesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnloopbackbytesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloopbackbytesTransmitted.setDescription('This entry contains the number of bytes transmited.')
isdnloopbackbytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnloopbackbytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloopbackbytesReceived.setDescription('This entry contains the number of bytes received.')
isdnCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCRCErrors.setDescription('This entry contains the number of frames with CRC errors.')
dsucsudeviceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1), )
if mibBuilder.loadTexts: dsucsudeviceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsudeviceConfigTable.setDescription('A list of device entries.')
dsucsudeviceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "dsucsuLineNumber"))
if mibBuilder.loadTexts: dsucsudeviceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsudeviceConfigEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
dsucsuLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuLineNumber.setDescription('The port number for which the DsuCsu line is configured (line level).')
dsucsuType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dsu-csu-dds", 1), ("dsu-csu-async-dial", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuType.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuType.setDescription('Defines the service type of the DSU/CSU port.')
dsucsuClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("external", 1), ("internal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuClocking.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. The default value for this field is 'external'.")
dsucsuSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(560, 640))).clone(namedValues=NamedValues(("speed56000", 560), ("speed64000", 640)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuSpeed.setDescription('The ports speed in 100 bits per second. The default value is 56000 bits per second.')
dsucsudeviceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 2), )
if mibBuilder.loadTexts: dsucsudeviceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsudeviceStatsTable.setDescription('A list of device entries.')
dsucsudeviceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "dsucsuLine"))
if mibBuilder.loadTexts: dsucsudeviceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsudeviceStatsEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
dsucsuLine = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuLine.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuLine.setDescription('The port number for which the DsuCsu line is configured (line level).')
dsucsuloopbackbytesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuloopbackbytesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuloopbackbytesTransmitted.setDescription('This entry contains the number of bytes transmited.')
dsucsuloopbackbytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 2, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsucsuloopbackbytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: dsucsuloopbackbytesReceived.setDescription('This entry contains the number of bytes received.')
sdlcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1), )
if mibBuilder.loadTexts: sdlcConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcConfigTable.setDescription('A table of SDLC information.')
sdlcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "sdlcConfigPortIndex"))
if mibBuilder.loadTexts: sdlcConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcConfigEntry.setDescription('An entry consisting of port information for a particular SDLC port.')
sdlcConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcConfigPortIndex.setDescription('The port number that uniquely identifies this port. Current supported SDLC numbers are 1-4.')
sdlcConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12))).clone(namedValues=NamedValues(("hsdlc-type", 11), ("tsdlc-type", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcConfigType.setDescription('The port type. TSDLC (Terminal SDLC) ports emulate a Host and poll the downstream PUs (e.g. 3274 or 3174 SDLC/SNA controllers). HSDLC ports (Host SDLC) ports emulate a line with Terminal Controllers (PUs) and respond to polls from the Host or upstream PU. Note that all ports must currently be defined as the same time for a given unit (i.e. no mixing of HSDLC and TSDLC ports is allowed).')
sdlcInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcInitState.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcInitState.setDescription("The initial state of the SDLC port. If configured for 'in-service', then the SDLC port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the SDLC port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
sdlcCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("constant", 1), ("switched", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcCarrier.setDescription("This field indicates whether Carrier (a.k.a. CD or DCD, RS-232 pin 8) is constant or switched for DCE devices (internally clocked), or Request To Send (a.k.a. RTS, RS-232 pin 4) is constant or switched. This parameter also affects SDLC flag generation. If configured for constant then the line will transmit flags in an idle (no data being sent) state. If configured for switched then the line will transmit all one bits (mark state). The default value for this parameter is 'constant'.")
sdlcClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("x21-external", 3), ("x21-internal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcClocking.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. X21 External and Internal are used (with the proper external adapter) to support X.21 Leased Line operation for RS-422/RS-530 (25 pin balanced) interfaces. X21 operation is not supported for boards that operate RS-232 or V.35. The default value for this field is 'external'.")
sdlcSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 20, 24, 36, 48, 72, 96, 144, 192, 288, 480, 560, 640, 1280))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2000", 20), ("speed2400", 24), ("speed3600", 36), ("speed4800", 48), ("speed7200", 72), ("speed9600", 96), ("speed14400", 144), ("speed19200", 192), ("speed28800", 288), ("speed48000", 480), ("speed56000", 560), ("speed64000", 640), ("speed128000", 1280)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcSpeed.setDescription('The ports speed in 100 bits per second. The default value is 9600 bits per second. Speeds higher than 19200 are not supported on RS-232 ports units (must be V.35 or RS-422).')
sdlcPause = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPause.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPause.setDescription('This parameter defines the amount of time between polls in 1/100 second (10 millisecond) intervals. If set to zero then the port will poll the PUs as fast as possible. The minimum value for this parameter is 5 and the timer has a resolution of 25 milliseconds. The default value is 20 (.20 seconds). This field is not applicable to Host port. It returns a dummy value.')
sdlcNRZI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcNRZI.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcNRZI.setDescription("This parameter indicates whether the port is configured for NRZI (yes) or NRZ (no) bit encoding. The default value is 'No' (NRZ encoding selected).")
sdlcT1Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcT1Timer.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcT1Timer.setDescription('The SDLC T1 timer value in 20ths of a second. The default value is 20 (1 second). This field is not applicable to Host ports. It returns a dummy value.')
sdlcSlowPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcSlowPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcSlowPollTimer.setDescription('The slow poll timer value in 20ths of a second. The slow poll timer is the amount of time to wait to contact (send SNRM) failed PUs. The default value for this field is 600 (30 seconds). This field is not applicable to Host ports. It returns a dummy value.')
sdlcMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcMaxRetries.setDescription('The maximum number of retries (N2 value) before failing a PU. The default value for this field is 3. This field is not applicable to Host ports. It returns a dummy value.')
sdlcNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
sdlcMultiFlagInsertion = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcMultiFlagInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcMultiFlagInsertion.setDescription("This parameter indicates whether the port is configured to send multiple interframe flags. The default value is 'No' (single flags).")
sdlcCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcCTS.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
sdlcDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcDCD.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
sdlcDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcDSR.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
sdlcDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcDTR.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
sdlcRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcRTS.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
sdlcReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
sdlcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2), )
if mibBuilder.loadTexts: sdlcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcStatsTable.setDescription('A table of SDLC information.')
sdlcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "sdlcStatsPortIndex"))
if mibBuilder.loadTexts: sdlcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcStatsEntry.setDescription('An entry consisting of port information for a particular SDLC port.')
sdlcStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcStatsPortIndex.setDescription('The port number that uniquely identifies this SDLC port. Current supported numbers on are 1-4.')
sdlcPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12))).clone(namedValues=NamedValues(("hsdlc-type", 11), ("tsdlc-type", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPortType.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPortType.setDescription('The port type. TSDLC (Terminal SDLC) ports emulate a Host and poll the downstream PUs (e.g. 3274 or 3174 SDLC/SNA controllers). HSDLC ports (Host SDLC) ports emulate a line with Terminal Controllers (PUs) and respond to polls from the Host or upstream PU.')
sdlcInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcInOctets.setDescription('The number of bytes received.')
sdlcOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcOutOctets.setDescription('The number of bytes sent.')
sdlcInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcInFrames.setDescription('The number of I-frames received.')
sdlcOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcOutFrames.setDescription('The number of I-frames sent.')
sdlcOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcOverruns.setDescription('The number of overruns.')
sdlcCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcCRCErrors.setDescription('The number of CRC errors.')
sdlcRecvAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcRecvAborts.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcRecvAborts.setDescription('The number of aborts received.')
sdlcpollrsptimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcpollrsptimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcpollrsptimeouts.setDescription('The number of poll response timeouts.')
sdlciframetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlciframetrans.setStatus('mandatory')
if mibBuilder.loadTexts: sdlciframetrans.setDescription('The number of i-frame re-transmissions.')
bisyncConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1), )
if mibBuilder.loadTexts: bisyncConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncConfigTable.setDescription('A table of Bisync port information.')
bisyncConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncConfigPortIndex"))
if mibBuilder.loadTexts: bisyncConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncConfigEntry.setDescription('An entry consisting of port information for a particular Bisync port.')
bisyncConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncConfigPortIndex.setDescription('The port number that uniquely identifies this port. Current supported Bisync numbers are 1-4.')
bisyncConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hbsc-type", 1), ("tbsc-type", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncConfigType.setDescription('The port type. TBSC (Terminal Bisync) ports emulate a Host and polls the downstream controllers). HBSC ports (Host Bisync) ports emulate a line with Terminal Controllers (CUs) and respond to polls from the Host.')
bisyncNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
bisyncInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncInitState.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncInitState.setDescription("The initial state of the Bisync port. If configured for 'in-service', then the Bisync port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', then the Bisync port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
bisyncCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("constant", 1), ("switched", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncCarrier.setDescription("This field indicates whether Carrier (a.k.a. CD or DCD, RS-232 pin 8) is constant or switched for DCE devices (internally clocked), or Request To Send (a.k.a. RTS, RS-232 pin 4) is constant or switched. The default value for this parameter is 'constant'.")
bisyncClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("x21-external", 3), ("x21-internal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncClocking.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. X21 External and Internal are used (with the proper external adapter) to support X.21 Leased Line operation for RS-422/RS-530 (25 pin balanced) interfaces. X21 operation is not supported for boards that operate RS-232 or V.35. The default value for this field is 'external'.")
bisyncSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 20, 24, 36, 48, 72, 96, 144, 192, 288, 480, 560, 640))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2000", 20), ("speed2400", 24), ("speed3600", 36), ("speed4800", 48), ("speed7200", 72), ("speed9600", 96), ("speed14400", 144), ("speed19200", 192), ("speed28800", 288), ("speed48000", 480), ("speed56000", 560), ("speed64000", 640)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncSpeed.setDescription('The ports speed in bits per second. The default value is 9600 bits per second. Speeds higher than 64000 are not supported.')
bisyncPause = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPause.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPause.setDescription('This parameter defines the amount of time between polls in 1/100 second (10 millisecond) intervals. If set to zero then the port will poll the CUs as fast as possible. The minimum value for this parameter is 5 and the timer has a resolution of 25 milliseconds. The default value is 20 (.20 seconds). This field is not applicable to a Host port. It returns a dummy value.')
bisyncReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncReplyTimer.setDescription('The time to wait for a response in seconds. The default value for this field is 3 seconds.')
bisyncRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncRetries.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncRetries.setDescription('The maximum number of retries (N2 value) before failing a CU. The default value for this field is 5.')
bisyncSlowpollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncSlowpollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncSlowpollTimer.setDescription('The time to wait in seconds before attempting a slowpoll. The default value for this field is 30 seconds.')
bisyncSessTerm = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("interventionReq", 2), ("unformattedLogoff", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncSessTerm.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncSessTerm.setDescription('The type of session termination used. Only applies to Host BSC ports.')
bisyncIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncIBS.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncIBS.setDescription('Some of non IBM 3270 BSC controllers can not handle ESC character but IBM 3270 BSC implementation requires ESC character. A new configuration parameter for Terminal BSC line as described below The default value is Yes.')
bisyncCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncCTS.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
bisyncDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncDCD.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncDSR.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncDTR.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncRTS.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
bisyncReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
bisyncStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2), )
if mibBuilder.loadTexts: bisyncStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncStatsTable.setDescription('A table of Bisync information.')
bisyncStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncStatsPortIndex"))
if mibBuilder.loadTexts: bisyncStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncStatsEntry.setDescription('An entry consisting of port information for a particular Bisync port.')
bisyncStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncStatsPortIndex.setDescription('The port number that uniquely identifies this Bisync port. Current supported numbers are 1-4.')
bisyncPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hbsc-type", 1), ("tbsc-type", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPortType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPortType.setDescription('The port type. TBSC (Terminal Bisync) ports emulate a Host and poll the downstream controllers). HBSC ports (Host Bisync) ports emulate a line with Terminal Controllers (PUs) and respond to polls from the Host or upstream PU.')
bisyncInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncInOctets.setDescription('The number of bytes received.')
bisyncOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncOutOctets.setDescription('The number of bytes sent.')
bisyncOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncOverruns.setDescription('The number of receiver overruns.')
bisyncCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncCRCErrors.setDescription('The number of receive frame CRC errors.')
bisyncRcvTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncRcvTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncRcvTimeout.setDescription('The number of receive timeout.')
bisyncXmtTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncXmtTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncXmtTimeout.setDescription('The number of transmit timeout.')
frameRelayConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1), )
if mibBuilder.loadTexts: frameRelayConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayConfigTable.setDescription('A table of Sync product Frame Relay information.')
frameRelayConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "frameRelayConfigPortIndex"))
if mibBuilder.loadTexts: frameRelayConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayConfigEntry.setDescription('An entry consisting of port information for a particular Sync product Frame Relay port.')
frameRelayConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayConfigPortIndex.setDescription('The port number that uniquely identifies this port.')
frameRelayPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(19, 20))).clone(namedValues=NamedValues(("frame-relay-type", 19), ("frame-relay-dialbackup-type", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayPortType.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayPortType.setDescription('The Frame Relay port type.')
frameRelayInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayInitState.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayInitState.setDescription("The initial state of the Frame Relay port. If configured for 'in-service', then the Frame Relay port will be brougt up automatically when the unit is powered up. If configured for 'out-of-service', then the Frame Relay port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
frameRelayClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("x21-external", 3), ("x21-internal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayClocking.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. X21 External and Internal are used (with the proper external adapter) to support X.21 Leased Line operation for RS-422/RS-530 (25 pin balanced) interfaces. X21 operation is not supported for boards that operate RS-232 or V.35. The default value for this field is 'external'.")
frameRelaySpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 20, 24, 36, 48, 72, 96, 144, 192, 288, 480, 560, 640, 1280, 2560, 5120, 10240, 15440, 20480))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2000", 20), ("speed2400", 24), ("speed3600", 36), ("speed4800", 48), ("speed7200", 72), ("speed9600", 96), ("speed14400", 144), ("speed19200", 192), ("speed28800", 288), ("speed48000", 480), ("speed56000", 560), ("speed64000", 640), ("speed128000", 1280), ("speed256000", 2560), ("speed512000", 5120), ("speed102400", 10240), ("speed154400", 15440), ("speed204800", 20480)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySpeed.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySpeed.setDescription('The ports speed in bits per second. The default value is 9600 bits per second. Speeds higher than 19200 are not supported on RS-232 port Sync products (must be V.35 or RS-422).')
frameRelayLocalManagementProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("annexD", 1), ("lmi", 2), ("annexA", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayLocalManagementProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayLocalManagementProtocol.setDescription('The ports management protocol type. Annex D = ANSI T1.617 Annex D LMI = Frame Relay Manufacturers LMI The default value is Annex D.')
frameRelayLinkPollingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayLinkPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayLinkPollingTimer.setDescription('Measured in seconds, intervals of 5 T391 - Annex D nT1 - LMI The default value for this field is 5 seconds.')
frameRelayFullStatusPollingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayFullStatusPollingCount.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayFullStatusPollingCount.setDescription('The number of polls that a full status poll is issued. N391 - Annex D nT1 - LMI The default value for this field is 6.')
frameRelayT1Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayT1Timer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayT1Timer.setDescription('The default LLC T1 timer value in seconds. T1 should be greater than T2 and less than Ti. Currently supported values are 1 to 25 seconds. The default value for this field is 3 seconds.')
frameRelayT2Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayT2Timer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayT2Timer.setDescription('The default LLC T2 timer value in tenths of seconds. If configured for 0 then the T2 timer is disabled and an RR frame will be sent for every I frame received. Current supported values are 0 and 2-50. T2 should be less than T1. The default value for this field is 0 (disabled).')
frameRelayTiTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayTiTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayTiTimer.setDescription('The default LLC Ti (inactivity) timer value in seconds. Ti should be greater than T1. Currently supported values are 2 to 50 seconds. The default value for this field is 30 seconds.')
frameRelayRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRxWindowSize.setDescription('The default LLC receive window (N3) size. Note that this is not the same receive window as defined in IEEE 802.2 LLC. This is N3 which is the number of I frames received before an RR frame is sent (defined as N3 in IEEE 802.2 LLC). Current allowable values are 1-7. The default value for this field is 7.')
frameRelayTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayTxWindowSize.setDescription('The defalut LLC transmit window size. Current allowable values are 1-7. The default value for this field is 7.')
frameRelayMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayMaxRetries.setDescription('The default LLC maximum number of retries (N2 value). The default value for this field is 15.')
frameRelayNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
frameRelayVirtualMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 16), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayVirtualMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayVirtualMACAddress.setDescription('The F/R WAN is treated as a token ring. This address is used for communication with other bridges in the network.')
frameRelayVirtualRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayVirtualRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayVirtualRingNumber.setDescription('The F/R WAN is treated as a token ring. This is the ring number for the F/R network to which the port is attached. It must be a unique ring number in the network. This value is configured in hex from 0 to FFF. The default value for this field is 1.')
frameRelayVirtualBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayVirtualBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayVirtualBridgeNumber.setDescription('The F/R WAN is treated as a token ring. This variable only has significance if more than 1 F/R port is configured. The default value for this field is 1.')
frameRelayIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayIPAddress.setDescription('This is the IP Address of this interface.')
frameRelayNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 20), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayNetworkMask.setDescription('This is the network mask to be used on this interface.')
frameRelayDefaultGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 21), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDefaultGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDefaultGatewayAddress.setDescription('Default gateway address to be used when sending responses on this interface.')
frameRelaySessSwitchThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySessSwitchThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySessSwitchThreshold.setDescription('Describes the session switch threshold for a session to switch between eVR and pVR. The value represents the LLC time-out occurrence for any session on this port. If one session has the configured number of time-outs, all sessions using that PVC are switched between eVR and pVR. Sessions that do not have a pVR are terminated.')
frameRelaySwitchedBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("racal-dtr-initiated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySwitchedBackup.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySwitchedBackup.setDescription('Defines the switched backup protocol used for dial backup. The range of this parameter is NONE or RACAL DTR-initiated. The default value is NONE.')
frameRelaySwitchedLineWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySwitchedLineWaitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySwitchedLineWaitTimer.setDescription('This parameter defines the maximum amount of time the FrameNode waits for the DAP to establish a dial connection before switching back to the dedicated line. This parameter is required because the DAP does not notify the FrameNode as to whether the dial backup connection was successful or not. This parameter, in concert with a high level protocol, helps determine whether or not the connection was successful. This parameter is expressed in minutes. The range of this parameter is from 1 minute to 60 minutes. The default value is 5 minutes.')
frameRelayDedLineWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDedLineWaitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDedLineWaitTimer.setDescription('The FCC regulation for Autodialers requires that an Autodialer waits between successive dial operations. This parameter satisfies the FCC requirements. It controls the maximum time the FrameNode waits before initiating another dial restoral operation if the previous operation fails. The timer starts when DTR is lowered. DTR is raised again upon expiration of the timer. This parameter is expressed in minutes. Its range is from 10 minutes to 120 minutes with a one minute resolution. The default value it 10 minutes.')
frameRelayCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayCommittedBurst.setDescription('This parameter specifies the maximum number of bits, during time interval Tc, the network agrees to accept under normal conditions. This parameter must match the configured value for the network. The value of this parameter can not be greater that the line speed. The range of the parameter is 1Kbits to 2048Kbits. The default value equals the line speed. However, this value depends on the Measurement Period Tc and the line speed. The value is expressed in Kbits.')
frameRelayExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayExcessBurst.setDescription('This is the maximum number of uncommitted bits, during time interval Tc, the network accepts above the committed burst size Bc. When the Excess burst Governor is configured to YES, the FrameNode tries to limit the throughput to the Bc + Be bits in the Time Period Tc. The default value of this parameter is 0. The range is from 0K to 2048K. However, the value depends on the Measurement Period Tc and the speed of the line. The value is expressed in Kbits.')
frameRelayBridgingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("srb", 1), ("tbr", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayBridgingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayBridgingProtocol.setDescription('This parameter specifies the bridging protocol to be used over Frame Relay link. This parameter has no effect if bridging is not turned on. The range of this parameter is SRB (source route bridging), TBR(transparent bridging) or BOTH. The value is BOTH.')
frameRelayProxyARP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayProxyARP.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayProxyARP.setDescription("This parameter defines whether PROXY ARP is enabled for F/R attached devices or not. Range of this parameter is ENABLED or DISABLED. The value is 'DISABLED'.")
frameRelaySecondDefaultGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 30), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySecondDefaultGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySecondDefaultGatewayAddress.setDescription('Second Default gateway address to be used when sending responses on this interface.')
frameRelayAlternateIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 31), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayAlternateIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayAlternateIPAddress.setDescription('This is the Alternate IP Address for single port dial up connection.')
frameRelayAlternateNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 32), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayAlternateNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayAlternateNetmask.setDescription('This is the Alternate network mask for IP for single port dial up connecton.')
frameRelayLLC2FrameFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tokenRing", 1), ("ethernetVersiontwo", 2), ("iEEEeightotwothree", 3), ("all", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayLLC2FrameFormat.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayLLC2FrameFormat.setDescription('This parameter specifies the LLC2 frame format to be used over Frame Relay link. The range of this parameter is Token Ring, Ethernet Version 2, IEEE 802.3 or ALL. The value is ALL.')
frameRelayMultiflagSeparation = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayMultiflagSeparation.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayMultiflagSeparation.setDescription("This parameter specifies whether the unit will insert more than one flag between frames. The range of this parameter is yes and no. The value is 'no'.")
frameRelayRestrictTerminateSessUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("spanningTree", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameRelayRestrictTerminateSessUsage.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRestrictTerminateSessUsage.setDescription("This parameter specifies whether terminated sessions are to follow spanning tree states or not over Frame Relay Link. The range of this parameter is No and SpanningTree. The value is 'no'.")
frameRelayRIPUpdtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRIPUpdtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRIPUpdtTimer.setDescription('Defines frequency at which the RIP packets are sent over this interface. The range of this parameter is from 10 seconds to 180 seconds. A value of 0 implies no RIP is sent over this interface. Default value is 60 seconds')
frameRelayRIPAge = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 540))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRIPAge.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRIPAge.setDescription('Defines frequency at which the learned RIP entries are removed if not corresponding RIP update is received. The range of this parameter is from 40 seconds to 540 seconds. Default value is 180 seconds')
frameRelaySAPUpdtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySAPUpdtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySAPUpdtTimer.setDescription('Defines frequency at which the SAP packets are sent over this interface. The range of this parameter is from 10 seconds to 180 seconds. A value of 0 implies that no SAP broadcasts are sent over this interface. Default value is 60 seconds')
frameRelaySAPAge = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySAPAge.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySAPAge.setDescription('Defines frequency at which the learned SAP entries are removed if not corresponding SAP update is received. The range of this parameter is from 40 seconds to 720 seconds. Default value is 180 seconds')
frameRelayRSM = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRSM.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRSM.setDescription("The Routing Summary Information parameter indicates whether the routing summary information should be generated in the RIP on that interface. If RSM is set to NO, RIP will broadcast subnet information as it is defined in the routing table. Default value is 'NO'")
frameRelayARP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("auto", 1), ("inverseArp", 2), ("routedArp", 3), ("tokenRing", 4), ("ethernetVersiontwo", 5), ("iEEEeightotwothree", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayARP.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayARP.setDescription("The ARP parameter indicates what format of ARP should be generated. Default value is 'Auto'")
frameRelayCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayCTS.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
frameRelayDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDCD.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
frameRelayDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDSR.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
frameRelayDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDTR.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
frameRelayRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRTS.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
frameRelayReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
frameRelayStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2), )
if mibBuilder.loadTexts: frameRelayStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayStatsTable.setDescription('A table of Frame Relay information.')
frameRelayStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "frameRelayStatsPortIndex"))
if mibBuilder.loadTexts: frameRelayStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayStatsEntry.setDescription('An entry consisting of port information for a particular Frame Relay port.')
frameRelayStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayStatsPortIndex.setDescription('The port number that uniquely identifies this Frame Relay port.')
frameRelayInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayInOctets.setDescription('The number of bytes received inclusive of all valid bytes in the frame relay frame except for the CRC field (frame relay header included).')
frameRelayOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayOutOctets.setDescription('The number of bytes transmitted inclusive of all bytes in the frame relay frame except for the CRC field (frame relay header included).')
frameRelaySampleDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySampleDuration.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySampleDuration.setDescription('The sample duration in seconds for Frame Relay Statistics for this port.')
frameRelayOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayOverruns.setDescription('The number of receiver overruns.')
frameRelayCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayCRCErrors.setDescription('The number of received CRC errors.')
frameRelayRecvAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRecvAborts.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRecvAborts.setDescription('The number of received frame aborts received.')
frameRelayTxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayTxDe.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayTxDe.setDescription('Total number of frames sent with the DE bit.')
frameRelayRxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayRxDe.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayRxDe.setDescription('Total number of frames received with the DE bit.')
frameRelaySwitchedAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySwitchedAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySwitchedAttempts.setDescription('The total number of times a switched backup is attempted.')
frameRelaySwitchedAttemptsSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 5, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelaySwitchedAttemptsSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelaySwitchedAttemptsSuccessful.setDescription('The total number of times switched backup attempts were successful.')
frExtCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 9, 1), )
if mibBuilder.loadTexts: frExtCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitTable.setDescription('A table containing information about specific Data Link Connection Identifiers and corresponding virtual circuits.')
frExtCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "frExtCircuitIfIndex"), (0, "SYNC-RESEARCH-MIB", "frExtCircuitDlci"))
if mibBuilder.loadTexts: frExtCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
frExtCircuitIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto.')
frExtCircuitDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frExtCircuitDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitDlci.setDescription('The Data Link Connection Identifier for this virtual circuit.')
frExtCircuitStatusIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frExtCircuitStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this circuit is not put into consideration when consolidating status of the unit if this field is set to yes.')
frExtCircuitStatusAcknowledged = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frExtCircuitStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to acknowledge, unit will re-consolidate its status without putting the status of this circuit into consideration. Subseqent status change of the circuit will cause the unit to include it in computing the status of the unit. Setting this value to no has no effect.')
frExtCircuitPartnerId = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitPartnerId.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitPartnerId.setDescription('This is the unit id of the FrameNode at the other end of the Frame relay PVC. It consists of a 1 to 8 octets right justified case-sensitive ASCII field which uniquely identifies the unit. If the unit at the other end of the Frame Relay PVC is not a Sync Research FrameNode, or and OEM equipment NON-FN is returned for this object.')
frExtCircuitTxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitTxDe.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitTxDe.setDescription('Total number of frames sent with DE bit for this PVC.')
frExtCircuitRxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitRxDe.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitRxDe.setDescription('Total number of frames received with the DE bit for this PVC.')
frExtCircuitMinBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitMinBits.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitMinBits.setDescription('Minimum number of bits transmitted in Time Period Tc for this PVC.')
frExtCircuitMaxBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitMaxBits.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitMaxBits.setDescription('Maximum number of bits transmitted in Time Period Tc for this PVC.')
frExtCircuitQOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 9, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frExtCircuitQOctets.setStatus('mandatory')
if mibBuilder.loadTexts: frExtCircuitQOctets.setDescription('Number of octets queued for transmission because the maximum burst rate was achieved in Tc. These are the number of octets that had transmission delay until next excess burst cycle Tc.')
asyncConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1), )
if mibBuilder.loadTexts: asyncConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigTable.setDescription('A table of Async port information.')
asyncConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "asyncConfigPortIndex"))
if mibBuilder.loadTexts: asyncConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigEntry.setDescription('An entry consisting of port information for a particular async port.')
asyncConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigPortIndex.setDescription('The port number that uniquely identifies this port.')
asyncConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(9, 10))).clone(namedValues=NamedValues(("hasc-type", 9), ("tasc-type", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigType.setDescription('The port type. HASC (Host Async) ports are for attaching to an Async Alarm Central Processor. TASC ports (Terminal Async) ports are for attaching to Alarm Controllers.')
asyncNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: asyncNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
asyncInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncInitState.setStatus('mandatory')
if mibBuilder.loadTexts: asyncInitState.setDescription("The initial state of the async port. If configured for 'in-service', then the Async port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', then the Async port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
asyncCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("constant", 1), ("switched", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: asyncCarrier.setDescription("This field indicates whether Carrier (a.k.a. CD or DCD, RS-232 pin 8) is constant or switched for DCE devices (internally clocked), or Request To Send (a.k.a. RTS, RS-232 pin 4) is constant or switched. The default value for this parameter is 'constant'.")
asyncSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200))).clone(namedValues=NamedValues(("speed75", 75), ("speed150", 150), ("speed300", 300), ("speed600", 600), ("speed1200", 1200), ("speed2400", 2400), ("speed4800", 4800), ("speed9600", 9600), ("speed19200", 19200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: asyncSpeed.setDescription('The ports speed in bits per second. The default value is 300 bits per second. Speeds higher than 19200 are not supported.')
asyncPhysicalType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPhysicalType.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPhysicalType.setDescription('Physical RS-232 type emulated by the port. The default value is 2 or DCE.')
asyncStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sto1", 1), ("sto1-5", 2), ("sto2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: asyncStopBits.setDescription('Number of stop bits generated for transmit characters (received characters may have any number of bits regardless of the configuration). The default value is 1.')
asyncParity = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd", 1), ("even", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncParity.setStatus('mandatory')
if mibBuilder.loadTexts: asyncParity.setDescription('Parity type generated for transmit characters and checked for receive characters. If ODD or EVEN, then if a character is received with invalid parity, it is discarded and the message once completely received is also discarded (i.e. not forwarded to the network). If NONE, then no parity bit is expected within the character or generated to the line. The default value is 1 or NONE.')
asyncDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: asyncDataBits.setDescription('Number of data bits (not including the parity bit). The default value is 8.')
asyncIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: asyncIdleTimer.setDescription('The idle timer is amount of time (in milliseconds) used to determine when a complete message has been received from the line. If configured as 0, then this timer is disabled and the message will be sent to the network only when the RX forwarding count is reached. If configured greater than 0, then the timer must be configured for a time longer than the time it takes to receive one character, otherwise the timer will not function properly. The default value is 40.')
asyncTxFrameGap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncTxFrameGap.setStatus('mandatory')
if mibBuilder.loadTexts: asyncTxFrameGap.setDescription('The TX frame gap is analogous to the idle timer, but is used to separate messages received from the network by gaps in time so that the Async device can distinguish between multiple messages. If configured as 0, then this function is disabled and if messages are received while transmitting a current message, the the two messages from the network will be sent out with no gap between them. If configured greater than 0, then a gap of the specified number of milliseconds will be inserted. The default value is 40.')
asyncRxForwardingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRxForwardingCount.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRxForwardingCount.setDescription('The Async receive forwarding count is used to forward messages when a configured number of characters is received from the Async line. This must be configured to greater than or equal to the maximum message length for a given protocol. The default value is 256.')
asyncEiaSignalForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncEiaSignalForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: asyncEiaSignalForwarding.setDescription('The Async EIA signal forwarding is used to cause receive data to be forwarding based on a change of EIA RS-232 control signals. If configured as a DCE, and this field is set ot YES, then if the Request To Send (RTS) control signal (RS-232 DB25 pin 4) changes from active to inactive, any characters already received are forwarded and sent to the network. If configured as a DTE, and this field is set to YES, then if the DCD (Data Carrier Detect) control signal (RS-232 DB25 pin 8) changes from active to inactive, forwarding to the network will occur. The default value is 1 or YES.')
asyncAddressOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncAddressOffset.setStatus('mandatory')
if mibBuilder.loadTexts: asyncAddressOffset.setDescription('If the address offset is specified as zero, then the data is not parsed to find a device address in order to direct the data to a specified LLC connection. If the address offset is 1 to 255, then the 8 bits specified at that offset (where offset 1 is the first byte of a message received) are interpreted as an address. If this field is set 0 zero, then only one CU record is allowed (i.e. all data sent/received to/from the line is to/from one network connection). If this field is greater than 0 (address offset specified) then one or more CU records can be configured to route the data based on the device address. The default value is 1.')
asyncRTC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRTC.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRTC.setDescription('Defines whether the alarms system protocol has a record termination(forwarding character). The valid range is from hex 01 to hex ff. The default value is not defined.')
asyncCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncCTS.setStatus('mandatory')
if mibBuilder.loadTexts: asyncCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
asyncDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncDCD.setStatus('mandatory')
if mibBuilder.loadTexts: asyncDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
asyncDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncDSR.setStatus('mandatory')
if mibBuilder.loadTexts: asyncDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
asyncDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncDTR.setStatus('mandatory')
if mibBuilder.loadTexts: asyncDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
asyncRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRTS.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
asyncReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: asyncReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
asyncOrt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncOrt.setStatus('mandatory')
if mibBuilder.loadTexts: asyncOrt.setDescription("The ORT command is a new port level command. By default, the setting will be YES to set the N2 value to zero, but can be set to NO to indicate that the normal LLC N2 setting should be used. The default value is 'yes'.")
asyncStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2), )
if mibBuilder.loadTexts: asyncStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncStatsTable.setDescription('A table of Async information.')
asyncStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "asyncStatsPortIndex"))
if mibBuilder.loadTexts: asyncStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncStatsEntry.setDescription('An entry consisting of port information for a particular Async port.')
asyncStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncStatsPortIndex.setDescription('The port number that uniquely identifies this Async port.')
asyncPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(9, 10))).clone(namedValues=NamedValues(("hasc-type", 9), ("tasc-type", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPortType.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPortType.setDescription('The port type. HASC (Host Async) ports are for attaching to an Async Alarm Central Processor. TASC ports (Terminal Async) ports are for attaching to Alarm Controllers.')
asyncInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: asyncInOctets.setDescription('The number of bytes received.')
asyncOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: asyncOutOctets.setDescription('The number of bytes sent.')
asyncInMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncInMessages.setStatus('mandatory')
if mibBuilder.loadTexts: asyncInMessages.setDescription('The number of messages received.')
asyncOutMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncOutMessages.setStatus('mandatory')
if mibBuilder.loadTexts: asyncOutMessages.setDescription('The number of messages sent.')
asyncInMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncInMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: asyncInMsgDiscarded.setDescription('The number of received messages discarded.')
asyncOutMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncOutMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: asyncOutMsgDiscarded.setDescription('The number of sent messages discarded.')
asyncXmtFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncXmtFailures.setStatus('mandatory')
if mibBuilder.loadTexts: asyncXmtFailures.setDescription('The number of failures in transmission.')
asyncRcvMsgForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvMsgForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvMsgForwarded.setDescription('The number of received messages forwarded.')
asyncRcvMsgErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvMsgErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvMsgErrors.setDescription('The number of errors detected in receiving messages.')
asyncRcvCharsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvCharsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvCharsDiscarded.setDescription('The number of received characters discarded.')
asyncRcvParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvParityErrors.setDescription('The number of parity errors detected.')
asyncRcvFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvFramingErrors.setDescription('The number of errors detected in receiving frames.')
asyncRcvFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvFifoOverruns.setDescription('The number FIFO receive overruns detected.')
asyncRcvCharsOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvCharsOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvCharsOverruns.setDescription('The number of character receive overruns detected.')
asyncRcvBreakConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 6, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncRcvBreakConditions.setStatus('mandatory')
if mibBuilder.loadTexts: asyncRcvBreakConditions.setDescription('The number of receive break conditions.')
bisyncrjeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1), )
if mibBuilder.loadTexts: bisyncrjeConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeConfigTable.setDescription('A table of Bisync port information.')
bisyncrjeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncrjeConfigPortIndex"))
if mibBuilder.loadTexts: bisyncrjeConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeConfigEntry.setDescription('An entry consisting of port information for a particular Bisync port.')
bisyncrjeConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeConfigPortIndex.setDescription('The port number that uniquely identifies this port. Current supported Bisync Rje numbers are 1-4.')
bisyncrjeConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13, 14))).clone(namedValues=NamedValues(("secondaryRJE-type", 13), ("primaryRJE-type", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeConfigType.setDescription('The port type. PRJE (Primary RJE) ports emulate a Host and polls the downstream controllers). SRJE ports (Secondary RJE) ports emulate a line with Terminal Controllers (CUs) and respond to polls from the Host.')
bisyncrjeNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
bisyncrjeInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInitState.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInitState.setDescription("The initial state of the Bisync RJE port. If configured for 'in-service', then the Bisync RJE port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', then the Bisync RJE port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
bisyncrjeCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("constant", 1), ("switched", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeCarrier.setDescription("This field indicates whether Carrier is constant or switched. The default value for this parameter is 'constant'.")
bisyncrjeClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("external", 1), ("internal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeClocking.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. The default value for this field is 'external'.")
bisyncrjeSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 20, 24, 36, 48, 72, 96, 144, 192, 288, 480, 560, 640, 1280))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2000", 20), ("speed2400", 24), ("speed3600", 36), ("speed4800", 48), ("speed7200", 72), ("speed9600", 96), ("speed14400", 144), ("speed19200", 192), ("speed28800", 288), ("speed48000", 480), ("speed56000", 560), ("speed64000", 640), ("speed128000", 1280)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeSpeed.setDescription('The ports speed in bits per second. The default value is 9600 bits per second. Speeds higher than 128000 are not supported.')
bisyncrjeReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeReplyTimer.setDescription('The time to wait for a response in seconds. The default value for this field is 3 seconds.')
bisyncrjeRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeRetries.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeRetries.setDescription('The maximum number of retries (N2 value) before failing a CU. The default value for this field is 8.')
bisyncrjeCodeSet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascii", 1), ("ebcdic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeCodeSet.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeCodeSet.setDescription('This parameter sets code set to be used for RJE line. The range of this parameter is ASCII and EBCDIC. The default value for this field is EBCDIC.')
bisyncrjeCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeCTS.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
bisyncrjeDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeDCD.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncrjeDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeDSR.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncrjeDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeDTR.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
bisyncrjeRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeRTS.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
bisyncrjeReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
bisyncrjeStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2), )
if mibBuilder.loadTexts: bisyncrjeStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeStatsTable.setDescription('A table of Bisync information.')
bisyncrjeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncrjeStatsPortIndex"))
if mibBuilder.loadTexts: bisyncrjeStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeStatsEntry.setDescription('An entry consisting of port information for a particular Bisync port.')
bisyncrjeStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeStatsPortIndex.setDescription('The port number that uniquely identifies this Bisync RJE port. Current supported numbers are 1-4.')
bisyncrjePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13, 14))).clone(namedValues=NamedValues(("srje-SecondaryRJE", 13), ("prje-PrimaryRJE", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePortType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePortType.setDescription('The port type.')
bisyncrjeInChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInChrs.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInChrs.setDescription('The number of Characters received.')
bisyncrjeOutChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutChrs.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutChrs.setDescription('The number of Characters sent.')
bisyncrjeInTrns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInTrns.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInTrns.setDescription('The number of Transactions received.')
bisyncrjeOutTrns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutTrns.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutTrns.setDescription('The number of Transactions sent.')
bisyncrjeInRetr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInRetr.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInRetr.setDescription('The number of Retransmits received.')
bisyncrjeOutRetr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutRetr.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutRetr.setDescription('The number of Retransmits sent.')
bisyncrjeInEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInEnq.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInEnq.setDescription('The number of ENQ received.')
bisyncrjeOutEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutEnq.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutEnq.setDescription('The number of ENQ sent.')
bisyncrjeInEtb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInEtb.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInEtb.setDescription('The number of ETB received.')
bisyncrjeOutEtb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutEtb.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutEtb.setDescription('The number of ETB sent.')
bisyncrjeInEtx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeInEtx.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeInEtx.setDescription('The number of ETX received.')
bisyncrjeOutEtx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeOutEtx.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeOutEtx.setDescription('The number of ETX sent.')
bisyncrjeWack = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeWack.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeWack.setDescription('The number of WACK received.')
bisyncrjeRvi = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 7, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjeRvi.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjeRvi.setDescription('The number of RVI received.')
dialbackupConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1), )
if mibBuilder.loadTexts: dialbackupConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupConfigTable.setDescription('A table of Sync product dial backup information.')
dialbackupConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "dialbackupConfigPortIndex"))
if mibBuilder.loadTexts: dialbackupConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupConfigEntry.setDescription('An entry consisting of port information for a particular Sync product dial backup port.')
dialbackupConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupConfigPortIndex.setDescription('This port uniquely identifies the dial backup port. Range is a valid port number.')
dialbackupPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("frame-relay-dialbackup-type", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupPortType.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupPortType.setDescription('The Dial backup connect Type.')
dialbackupConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hayes", 1), ("vtwentyfivebis", 2), ("nullmodem", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupConnectType.setDescription('The Dial backup connect Type.')
dialbackupFirstDedicatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupFirstDedicatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupFirstDedicatedPort.setDescription('This defines a frame relay PVC which will cause dial backup if it is declared as failed (deactivated) by the network. Port number is a valid Frame Relay and DLCI is a valid Frame Relay DLCI.')
dialbackupassociatedDLCIDedicated = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupassociatedDLCIDedicated.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupassociatedDLCIDedicated.setDescription('This defines a frame relay PVC which will cause dial backup if it is declared as failed (deactivated) by the network. DLCI is a valid Frame Relay DLCI.')
dialbackupSecondDedicatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupSecondDedicatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupSecondDedicatedPort.setDescription('This defines a second frame relay PVC which will cause dial backup if it is declared as failed (deactivated) by the network. Port number is a valid Frame Relay and DLCI is a valid Frame Relay DLCI.')
dialbackupassociatedDLCISecond = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupassociatedDLCISecond.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupassociatedDLCISecond.setDescription('This defines a second frame relay PVC which will cause dial backup if it is declared as failed (deactivated) by the network. DLCI is a valid Frame Relay DLCI.')
dialbackupDedicatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupDedicatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupDedicatedPort.setDescription('When this port fails, dial connection is activated. Range is a valid port number. The default value for this field is 1.')
dialbackupDedicatedLMIPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupDedicatedLMIPort.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupDedicatedLMIPort.setDescription('When this port looses LMI connectivity, dial connection is activated. Range is a valid number. The default value for this field is 1.')
dialbackupDialInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupDialInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupDialInactivityTimer.setDescription('This parameter defines inactivity timer for dial connection. Expiration of this timer will cause dial connection to disconnect. The range of this parameter is 0..9999 seconds. Value 0 disables inactivity timer usage. The default value for this field is 60 seconds.')
dialbackupDialSuspendTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupDialSuspendTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupDialSuspendTimer.setDescription('Defines a duration for which the dial connection. will not be attempted after the dial connection is torn down. The range is 0..9999 seconds. Value of 0 disable inactivity timer usage. The default value for this field is 60 seconds.')
dialbackupModemInitString = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupModemInitString.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupModemInitString.setDescription('Defins a modem intialization string. The field is 40 characters long. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
dialbackupModemDialString = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupModemDialString.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupModemDialString.setDescription('Defins a modem dial string to activate dial connection. This field is up to 40 characters long. Dial phone number may be specified here. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
dialbackupModemHangString = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupModemHangString.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupModemHangString.setDescription('Defines a modem hang up string to deactivate dial connection. This field is up to 20 characters long. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
dialbackupDialDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupDialDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupDialDelayTimer.setDescription('Defines a duration for which the dial connecton will not be attempted after need to initiate dial connection is detected. The range of this parameter is 0..9999 seconds. Value 0 implies immediate dial initiation. The default value for this field is 60 seconds.')
dialbackupTreatLLCControlCharacters = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupTreatLLCControlCharacters.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupTreatLLCControlCharacters.setDescription('Defines whether LLC control frames (TEST, XID, RR, RNR, REJ, DISC, UA, DM, FRMR etc. except I frames) are to be considered as user data or not. For a dial backup up port if this contorl frames are not treated as user data, then idle LLC2 sessions on the port will cause inactivity timer to pop causing SNA session disconnect. The range of this parameter is YES or NO. Default value is YES')
dialbackupStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2), )
if mibBuilder.loadTexts: dialbackupStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupStatsTable.setDescription('A table of Frame Relay information.')
dialbackupStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "dialbackupStatsPortIndex"))
if mibBuilder.loadTexts: dialbackupStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupStatsEntry.setDescription('An entry consisting of port information for a particular Frame Relay port.')
dialbackupStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupStatsPortIndex.setDescription('The port number that uniquely identifies this Dial Backup port.')
dialbackupSuccatmpt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupSuccatmpt.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupSuccatmpt.setDescription('The number of successful dial backup attempts.')
dialbackupunsuccatmpt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupunsuccatmpt.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupunsuccatmpt.setDescription('The number of unsuccessful dial backup attempts.')
dialbackupinact = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dialbackupinact.setStatus('mandatory')
if mibBuilder.loadTexts: dialbackupinact.setDescription('The Number of times inactivity timer expired.')
x25ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1), )
if mibBuilder.loadTexts: x25ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConfigTable.setDescription('A table of X25 information.')
x25ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "x25ConfigPortIndex"))
if mibBuilder.loadTexts: x25ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConfigEntry.setDescription('An entry consisting of port information for a particular X25 port.')
x25ConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConfigPortIndex.setDescription('The port number that uniquely identifies this port. Current supported X.25 numbers are 1-4.')
x25ConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("xDTE-XLogicalDTE", 7), ("xDCE-XLogicalDCE", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConfigType.setDescription('The port type. XDCE () ports is a logical DCE device waits to receive an incoming call from the X.25 network. XDTE ports is a logical DTE device initiates a to the X.25 network. Note that all ports must currently be defined as the same time for a given unit (i.e. no mixing of XDCE and XDTE ports is allowed).')
x25NAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25NAUName.setStatus('mandatory')
if mibBuilder.loadTexts: x25NAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
x25InitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InitState.setStatus('mandatory')
if mibBuilder.loadTexts: x25InitState.setDescription("The initial state of the X.25 port. If configured for 'in-service', then the X.25 port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the X.25 port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'enabled'.")
x25Clocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("x21-external", 3), ("x21-internal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Clocking.setStatus('mandatory')
if mibBuilder.loadTexts: x25Clocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. X21 External and Internal are used (with the proper external adapter) to support X.21 Leased Line operation for RS-422/RS-530 (25 pin balanced) interfaces. X21 operation is not supported for boards that operate RS-232 or V.35. The default value for this field is 'external'.")
x25DTEAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DTEAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25DTEAddress.setDescription('This parameter specifies the DTE address this port will use to access the X.25 network.')
x25LinkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LinkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LinkWindowSize.setDescription('This parameter sets the maximum number of concurrent unacknowledged I frames at the X.25 data link level. The default value is 7.')
x25T1Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1980))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25T1Timer.setStatus('mandatory')
if mibBuilder.loadTexts: x25T1Timer.setDescription('The SDLC T1 timer value in 20ths of a second. The default value is 60 (3 seconds).')
x25MaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25MaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: x25MaxRetries.setDescription('The maximum number of retries (N2 value) before failing a PU. The default value for this field is 8.')
x25PortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20, 24, 36, 48, 72, 96, 144, 192, 288, 480, 560, 640, 1280, 2560))).clone(namedValues=NamedValues(("speed2000", 20), ("speed2400", 24), ("speed3600", 36), ("speed4800", 48), ("speed7200", 72), ("speed9600", 96), ("speed14400", 144), ("speed19200", 192), ("speed28800", 288), ("speed48000", 480), ("speed56000", 560), ("speed64000", 640), ("speed128000", 1280), ("speed256000", 2560)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: x25PortSpeed.setDescription('The ports speed in 100 bits per second. The default value is 64000 bits per second. Speeds higher than 19200 are not supported on RS-232 ports units (must be V.35 or RS-422).')
x25ReceiveWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ReceiveWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25ReceiveWindowSize.setDescription('This parameter determines the number of consecutive data packets that the sync unit can receive before requiring an acknowledgment. The default value is 2.')
x25TransmitWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TransmitWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25TransmitWindowSize.setDescription('This parameter determines the number of consecutive data packets to be transmitted on the X.25 network before requiring an acknowledgment. The value you configure in this field must match the value configured in the X.25 network. The default value is 2.')
x25ReceivePacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 128, 256, 512, 1024))).clone(namedValues=NamedValues(("sixteen", 16), ("thirtytwo", 32), ("onetwentyeight", 128), ("twofiftsix", 256), ("fivetwelve", 512), ("onethousand", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ReceivePacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25ReceivePacketSize.setDescription('This parameter defines the size of packets received from the X.25 network in bytes. This value must match the configuration of your X.25 network provider. The default value is 128 bytes.')
x25TransmitPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 128, 256, 512, 1024))).clone(namedValues=NamedValues(("sixteen", 16), ("thirtytwo", 32), ("onetwentyeight", 128), ("twofiftsix", 256), ("fivetwelve", 512), ("onethousand", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TransmitPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25TransmitPacketSize.setDescription('This parameter defines the size of packets transmitted across the X.25 network in bytes. This value must match the configuration of the X.25 network. The default value is 128 bytes.')
x25LowTwoWayChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LowTwoWayChannel.setStatus('mandatory')
if mibBuilder.loadTexts: x25LowTwoWayChannel.setDescription('This parameter specifies the X.25 packet lower-bound channel number for this physical access line. The default value is 1.')
x25HighTwoWayChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HighTwoWayChannel.setStatus('mandatory')
if mibBuilder.loadTexts: x25HighTwoWayChannel.setDescription('This parameter specifies the X.25 packet upper-bound channel number for this physical access line. Note: This value must be greater than the Low Two-Way Channel Number. The default value is 127.')
x25UseCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25UseCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25UseCallingAddress.setDescription("This parameter determines whether the DTE Address assigned to the port you are configuring should be included as a calling address in outgoing call packets. The default value is 'No'.")
x25ForwardingUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4), ("five", 5), ("six", 6), ("seven", 7), ("eom", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ForwardingUnit.setStatus('mandatory')
if mibBuilder.loadTexts: x25ForwardingUnit.setDescription("This parameter limits how many message packets can accumulate before the unit forwards them to higher bytes. The default value is 'EOM'.")
x25DevicePacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 128, 256, 512, 1024, 1))).clone(namedValues=NamedValues(("thirtytwo", 32), ("onetwentyeight", 128), ("twofiftsix", 256), ("fivetwelve", 512), ("onethousand", 1024), ("none", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DevicePacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25DevicePacketSize.setDescription("When the sync unit makes a call on behalf of any configured device, the packet size determines parameter negotiation between the calling and the called packet handlers. Note: This parameter is not currently supported. do no change the default value. The default value is 'NONE'.")
x25DeviceWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4), ("five", 5), ("six", 6), ("seven", 7), ("none", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DeviceWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25DeviceWindowSize.setDescription("When the sync unit makes a call on behalf of any device, the window size determines parameter negotiation between the calling and the called packet handlers. Note: This parameter is not currently supported. do no change the default value. The default value is 'NONE'.")
x25PlaceReverseChargeCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PlaceReverseChargeCalls.setStatus('mandatory')
if mibBuilder.loadTexts: x25PlaceReverseChargeCalls.setDescription("This parameter determines whether the Sync unit will place reverse charge requests on outgoing calls. The default value is 'No'.")
x25AcceptReverseChargeCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25AcceptReverseChargeCalls.setStatus('mandatory')
if mibBuilder.loadTexts: x25AcceptReverseChargeCalls.setDescription("This parameter determines whether the Sync unit will accept reverse charge requests from incoming calls. The default value is 'No'.")
x25NPS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25NPS.setStatus('mandatory')
if mibBuilder.loadTexts: x25NPS.setDescription("This parameter indicates if the QLLC conversion NODE is connecting to a NPSI front-end and is to take on a secondary role. The default value is 'No'.")
x25CTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CTS.setStatus('mandatory')
if mibBuilder.loadTexts: x25CTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
x25DCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DCD.setStatus('mandatory')
if mibBuilder.loadTexts: x25DCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
x25DSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DSR.setStatus('mandatory')
if mibBuilder.loadTexts: x25DSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
x25DTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DTR.setStatus('mandatory')
if mibBuilder.loadTexts: x25DTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
x25RTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RTS.setStatus('mandatory')
if mibBuilder.loadTexts: x25RTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
x25ReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: x25ReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
x25IPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 30), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25IPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25IPAddress.setDescription('This is the IP Address of this interface.')
x25NetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 31), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25NetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: x25NetworkMask.setDescription('This is the network mask to be used on this interface.')
x25DefaultGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 32), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DefaultGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25DefaultGatewayAddress.setDescription('Default gateway address to be used when sending responses on this interface.')
x25SecondDefaultGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 1, 1, 33), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SecondDefaultGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25SecondDefaultGatewayAddress.setDescription('Second Default gateway address to be used when sending responses on this interface.')
x25StatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2), )
if mibBuilder.loadTexts: x25StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatsTable.setDescription('A table of X25 information.')
x25StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "x25StatsPortIndex"))
if mibBuilder.loadTexts: x25StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatsEntry.setDescription('An entry consisting of port information for a particular X25 port.')
x25StatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatsPortIndex.setDescription('The port number that uniquely identifies this X25 port. Current supported numbers on are 1-8.')
x25PortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("xDTE-XLogicalDTE", 7), ("xDCE-XLogicalDCE", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PortType.setStatus('mandatory')
if mibBuilder.loadTexts: x25PortType.setDescription('The port type. XDCE () ports is a logical DCE device waits to receive an incoming call from the X.25 network. XDTE ports is a logical DTE device initiates a to the X.25 network. Note that all ports must currently be defined as the same time for a given unit (i.e. no mixing of XDCE and XDTE ports is allowed).')
x25InFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25InFrames.setDescription('The number of I-frames received.')
x25OutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25OutFrames.setDescription('The number of I-frames sent.')
x25CInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25CInFrames.setDescription('The number of Control-frames received.')
x25COutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25COutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25COutFrames.setDescription('The number of Control-frames sent.')
x25FRMRInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25FRMRInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25FRMRInFrames.setDescription('The number of FRMR-frames received.')
x25FRMROutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25FRMROutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25FRMROutFrames.setDescription('The number of FRMR-frames sent.')
x25Timeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Timeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25Timeouts.setDescription('The number of Timeouts.')
x25UFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25UFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25UFrames.setDescription('The number of Undefined Frames.')
x25Samples = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Samples.setStatus('mandatory')
if mibBuilder.loadTexts: x25Samples.setDescription('The number of Samples.')
x25Sum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Sum.setStatus('mandatory')
if mibBuilder.loadTexts: x25Sum.setDescription('The number of Active Channels Sum.')
x25SumsQ = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SumsQ.setStatus('mandatory')
if mibBuilder.loadTexts: x25SumsQ.setDescription('The number of Active Channels SumsQ.')
x25DataInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataInPkts.setDescription('The number of Data Packets received.')
x25DataOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataOutPkts.setDescription('The number of Data Packets sent.')
x25DataInChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataInChrs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataInChrs.setDescription('The number of Data Characters received.')
x25DataOutChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataOutChrs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataOutChrs.setDescription('The number of Data Characters sent.')
x25QInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25QInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25QInPkts.setDescription('The number of Q-Packets received.')
x25QOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25QOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25QOutPkts.setDescription('The number of Q-Packets sent.')
x25QInChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25QInChrs.setStatus('mandatory')
if mibBuilder.loadTexts: x25QInChrs.setDescription('The number of Q-Characters received.')
x25QOutChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25QOutChrs.setStatus('mandatory')
if mibBuilder.loadTexts: x25QOutChrs.setDescription('The number of Q-Characters sent.')
x25SigInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SigInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SigInPkts.setDescription('The number of Sig-Packets received.')
x25SigOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SigOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SigOutPkts.setDescription('The number of Sig-Packets sent.')
x25InResets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25InResets.setDescription('The number of Resets received.')
x25OutResets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OutResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25OutResets.setDescription('The number of Resets sent.')
x25InRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: x25InRestarts.setDescription('The number of Restarts received.')
x25OutRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 9, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OutRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: x25OutRestarts.setDescription('The number of Restarts sent.')
alcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1), )
if mibBuilder.loadTexts: alcConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: alcConfigTable.setDescription('A table of ALC information.')
alcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "alcConfigPortIndex"))
if mibBuilder.loadTexts: alcConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alcConfigEntry.setDescription('An entry consisting of port information for a particular ALC port.')
alcConfigPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcConfigPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcConfigPortIndex.setDescription('The port number that uniquely identifies this port. Current supported X.25 numbers are 1-4.')
alcConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(23, 24))).clone(namedValues=NamedValues(("tALC-TerminalALC", 23), ("hALC-HostALC", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: alcConfigType.setDescription('The port type. The default is Teminal ALC.')
alcNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: alcNAUName.setDescription('The NAU name of this port. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
alcInitState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcInitState.setStatus('mandatory')
if mibBuilder.loadTexts: alcInitState.setDescription("The initial state of the X.25 port. If configured for 'in-service', then the ALC port will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the ALC port must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'inservice'.")
alcClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("external", 1), ("internal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcClocking.setStatus('mandatory')
if mibBuilder.loadTexts: alcClocking.setDescription("Clocking source for this port. Setting 'internal' will cause the port to emulate a physical DCE, and setting external will cause the port to emulate a physical DTE. The default value for this field is 'internal'.")
alcPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 24, 48, 96, 192))).clone(namedValues=NamedValues(("speed1200", 12), ("speed2400", 24), ("speed4800", 48), ("speed9600", 96), ("speed19200", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: alcPortSpeed.setDescription('The ports speed in 100 bits per second. The default value is 9600 bits per second.')
alcLimitSegsCharsBetweenPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcLimitSegsCharsBetweenPolls.setStatus('mandatory')
if mibBuilder.loadTexts: alcLimitSegsCharsBetweenPolls.setDescription("This parameter specifies whether to limit the number of segments sent between pools. If this parameter is set to 'yes' the parameter 'Number of Segments' and 'Number of Characters' should be configured appropriately. The defualt value is 'yes'.")
alcNumberOfSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcNumberOfSegments.setStatus('mandatory')
if mibBuilder.loadTexts: alcNumberOfSegments.setDescription("This parameter specifies the maximum number of segments that may be sent between polls. This parameter is applicable only if 'Limit SEGs/Chars between polls' is set to yes. The defualt value is 5.")
alcNumberOfCharacters = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcNumberOfCharacters.setStatus('mandatory')
if mibBuilder.loadTexts: alcNumberOfCharacters.setDescription("This parameter specifies the maximum number of characters that may be sent between polls. This parameter is applicable only if 'Limit SEGs/Chars between polls' is set to yes. The defualt value is 2000.")
alcNumberOfNullSeg = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcNumberOfNullSeg.setStatus('mandatory')
if mibBuilder.loadTexts: alcNumberOfNullSeg.setDescription('This parameter specifies the maximum number of null characters that may be sent between segments. The defualt value is 0.')
alcCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcCTS.setStatus('mandatory')
if mibBuilder.loadTexts: alcCTS.setDescription("Defines whether CTS is an input signal used to determine the port status. This parameter is applicable if clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
alcDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcDCD.setStatus('mandatory')
if mibBuilder.loadTexts: alcDCD.setDescription("Defines whether DCD is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DCD is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
alcDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcDSR.setStatus('mandatory')
if mibBuilder.loadTexts: alcDSR.setDescription("Defines whether DSR is required as input signal or ignored. This parameter is applicable if the clocking is set to external. For internal clocking the parameter is ignored and DSR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
alcDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcDTR.setStatus('mandatory')
if mibBuilder.loadTexts: alcDTR.setDescription("Defines whether DTR is required as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and DTR is asserted when port is enabled. The range is yes and no. The default value is 'yes'.")
alcRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcRTS.setStatus('mandatory')
if mibBuilder.loadTexts: alcRTS.setDescription("Defines whether RTS is an input signal to determine the port status. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored and RTS is asserted when port is enabled. The range is yes and no. The default value is 'No'.")
alcReturnClock = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcReturnClock.setStatus('mandatory')
if mibBuilder.loadTexts: alcReturnClock.setDescription("Defines whether Return Clock (SCTE) is available as input signal or ignored. This parameter is applicable if the clocking is set to internal. For external clocking the parameter is ignored. The range is yes and no. The default value is 'yes'.")
alcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2), )
if mibBuilder.loadTexts: alcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: alcStatsTable.setDescription('A table of X25 information.')
alcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "alcStatsPortIndex"))
if mibBuilder.loadTexts: alcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alcStatsEntry.setDescription('An entry consisting of port information for a particular X25 port.')
alcStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcStatsPortIndex.setDescription('The port number that uniquely identifies this Alc port. Current supported numbers on are 1-8.')
alcPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(23, 24))).clone(namedValues=NamedValues(("tALC-TerminalALC", 23), ("hALC-HostALC", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPortType.setStatus('mandatory')
if mibBuilder.loadTexts: alcPortType.setDescription('The port type. The default is Terminal Alc.')
alcRxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcRxOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: alcRxOverruns.setDescription('The number of Received Overruns.')
alcBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: alcBytesRx.setDescription('The number of Bytes Received.')
alcBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: alcBytesTx.setDescription('The number of Bytes Transmitted.')
alcBytesRxDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcBytesRxDisc.setStatus('mandatory')
if mibBuilder.loadTexts: alcBytesRxDisc.setDescription('The number of Bytes Received.')
alcBytesTxDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcBytesTxDisc.setStatus('mandatory')
if mibBuilder.loadTexts: alcBytesTxDisc.setDescription('The number of Bytes Transmitted.')
alcPortFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPortFaults.setStatus('mandatory')
if mibBuilder.loadTexts: alcPortFaults.setDescription('The number of Bytes Transmitted.')
alcRcvCCCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcRcvCCCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: alcRcvCCCErrors.setDescription('The number of Bytes Transmitted.')
alcPollTx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPollTx.setStatus('mandatory')
if mibBuilder.loadTexts: alcPollTx.setDescription('The number of Bytes Transmitted.')
alcResponseTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcResponseTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: alcResponseTimeouts.setDescription('The number of Bytes Transmitted.')
alcSegRx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcSegRx.setStatus('mandatory')
if mibBuilder.loadTexts: alcSegRx.setDescription('The number of Segments Received.')
alcSegTx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcSegTx.setStatus('mandatory')
if mibBuilder.loadTexts: alcSegTx.setDescription('The number of Segments Transmitted.')
alcSegRxDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcSegRxDisc.setStatus('mandatory')
if mibBuilder.loadTexts: alcSegRxDisc.setDescription('The number of Received Segments Discarded.')
alcSegTxDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 5, 10, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcSegTxDisc.setStatus('mandatory')
if mibBuilder.loadTexts: alcSegTxDisc.setDescription('The number of Transmitted Segments Discarded.')
puControlTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1), )
if mibBuilder.loadTexts: puControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: puControlTable.setDescription('A table for controlling lines and obtaining information.')
puControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "puControlLineIndex"), (0, "SYNC-RESEARCH-MIB", "puControlPUAddress"))
if mibBuilder.loadTexts: puControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: puControlEntry.setDescription('An entry consisting of PU information for a particular port.')
puControlLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puControlLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: puControlLineIndex.setDescription('The port number that has a given PU.')
puControlPUAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: puControlPUAddress.setStatus('mandatory')
if mibBuilder.loadTexts: puControlPUAddress.setDescription('The PU address in the range of 0x01 to 0xfe.')
puStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("failed", 3), ("restart", 4), ("enable-all", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puStatus.setStatus('mandatory')
if mibBuilder.loadTexts: puStatus.setDescription('The status of the PU. To change status of a port an enable, enable all or disable may be set. Valid Return status are enable(d), disable(d), or failed. Commands: An enable command will attempt to bring up the PU. An enable all command will attempt to bring up the line and any lower layer entities (e.g. PUs). A disable command will disable the PU. Status: Enable(d) indicates the PU is enabled and running. Disable(d) indicates the PU has been disabled. Failed indicates the PU is enabled and not Running. For a access LAN/X25 PU, the status is enabled when the connection status is connected. Otherwise its status is failed.')
puConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("not-connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: puConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: puConnectionStatus.setDescription('The status of the LLC type 2 Connection for this SDLC PU.')
puLastClearCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastClearCode.setStatus('mandatory')
if mibBuilder.loadTexts: puLastClearCode.setDescription("A two octet field indicating the Last Clearing Cause and Diagnostic Field of the last failed connection attempt (a.k.a. call attempt) or active connection (a.k.a. session). For LLC type 2 connections the second octet (cause) is always 0. The first octet (diagnostic) indicates the reason for the last connection failure. A value of 255 (xff) indicates that no call has ever been placed (e.g. PU never came up) or received. Even if the session call attempt is successful, the first octect still indicates the reason of LAST TIME when the session call attempt failed. See User's Guide for information")
puControlFailureCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: puControlFailureCode.setStatus('mandatory')
if mibBuilder.loadTexts: puControlFailureCode.setDescription('This entry contains the failure codes if the associated PU is in the failed state.')
puControlNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: puControlNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: puControlNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
puConnectionAttemptCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puConnectionAttemptCount.setStatus('mandatory')
if mibBuilder.loadTexts: puConnectionAttemptCount.setDescription('The number of connection attempts performed. This count is set to zero at startup, and after every loss of an estabished session.')
puStatusIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puStatusIgnored.setStatus('mandatory')
if mibBuilder.loadTexts: puStatusIgnored.setDescription('This field is used for consolidating status of the unit. The status of this pu is not put into consideration when consolidating status of the unit if this field is set to yes.')
puStatusAcknowledged = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puStatusAcknowledged.setStatus('mandatory')
if mibBuilder.loadTexts: puStatusAcknowledged.setDescription('This field is used for consolidating status of the unit. When this field is set to yes, the unit will re-consolidate its status without putting the status of this pu into consideration. Subseqent status change of the pu will cause the unit to include it in computing the status of the unit. Setting this value to no has no effect.')
puLastDlciCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastDlciCleared.setStatus('mandatory')
if mibBuilder.loadTexts: puLastDlciCleared.setDescription('Specifies the dlci that the last clear code was associated with. If the last clear code was not associated with a virtual route, i.e. the clear was associated with the lan for example, this field is set to 9999.')
puCurrentDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentDlci.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentDlci.setDescription('Specifies the DLCI active for a session at this time. For LAN or X25 network interface, this field is set to 0')
puLastMACCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 13), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastMACCleared.setStatus('mandatory')
if mibBuilder.loadTexts: puLastMACCleared.setDescription('Specifies the MAC address that the last clear code was associated with.')
puCurrentMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 14), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentMAC.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentMAC.setDescription('Specifies the MAC address that the current session is associated with. For X25 network type, this is set to 0.')
puNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 17, 19, 20, 21))).clone(namedValues=NamedValues(("xDTE-XLogicalDTE", 7), ("xDCE-XLogicalDCE", 8), ("ethernet-type", 17), ("frame-relay-type", 19), ("frame-relay-dialbackup-type", 20), ("token-ring-type", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: puNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: puNetworkType.setDescription('Specifies netowrk type that the current session is associated with.')
puCurrentConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dsp", 1), ("qllc", 2), ("llc2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentConnectionType.setDescription('Specifies network layer that the current session is associated with.')
puLastSVCCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastSVCCleared.setStatus('mandatory')
if mibBuilder.loadTexts: puLastSVCCleared.setDescription('Specifies the LCN that the last clear code is associated with. If the last clear code was not associated with a X25 SVC, i.e. the clear was associated with the lan for example, this field is set to 9999.')
puCurrentSVC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentSVC.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentSVC.setDescription('Specifies the that the current session is associated with. For non X25 network type, this field is set to 0')
puLastLocalDTECleared = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastLocalDTECleared.setStatus('mandatory')
if mibBuilder.loadTexts: puLastLocalDTECleared.setDescription('Specifies the local DTE address that the last clear code is associated with. For non X25 network type, this field is set to 0')
puLastRemoteDTECleared = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puLastRemoteDTECleared.setStatus('mandatory')
if mibBuilder.loadTexts: puLastRemoteDTECleared.setDescription('Specifies the remote DTE address that the last clear code is associated with. For non X25 network type, this field is set to 0')
puCurrentLocalDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentLocalDTE.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentLocalDTE.setDescription('Specifies the local DTE address that the current session is associated with. For non X25 network type, this field is set to 0')
puCurrentRemoteDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puCurrentRemoteDTE.setStatus('mandatory')
if mibBuilder.loadTexts: puCurrentRemoteDTE.setDescription('Specifies the remote DTE address that the current session is associated with. For non X25 network type, this field is set to 0')
puIsDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puIsDynamic.setStatus('mandatory')
if mibBuilder.loadTexts: puIsDynamic.setDescription('The type of PU. YES means that the PU is a dynamic pu created by auto LLC. The puStatus for any dynamic PU must be enabled')
sdlcPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1), )
if mibBuilder.loadTexts: sdlcPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConfigTable.setDescription('A list of PU entries.')
sdlcPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "sdlcPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "sdlcPuConfigAddress"))
if mibBuilder.loadTexts: sdlcPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
sdlcPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConfigLineIndex.setDescription('The port number for which the line (CU)is configured (first level).')
sdlcPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
sdlcPuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
sdlcPuInitialState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInitialState.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInitialState.setDescription("The initial state of the PU. If configured for 'in-service', then the SDLC PU will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the SDLC PU must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'in-service'.")
sdlcPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuXID.setDescription('The XID value for this PU. The XID is used to identify the PU during the LLC connection process to the remote Host or Gateway. If the field is configured to 0 then the unit will solicit the XID from the downstream PU and send the XID data received from SDLC to the XID data sent for the LLC connection process. If not sent to 0, then the unit will insert the data configured in the LLC sent to the host during the LLC connection process on behalf of the CU. For incoming LLC connections on Sync Research products this field is parsed to route the connection to the proper PU. The default value for this field is all zeroes (solicit XID from PU).')
sdlcPuType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type1", 1), ("type2", 2), ("type2-1", 3), ("type4", 4), ("type5", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuType.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuType.setDescription('The SNA PU type. 1 = PU type 1 2 = PU type 2 3 = PU type 2.1 4 = PU type 4 5 = PU type 5 (not supported, reserved) This parameter defaults to a value of 2.')
sdlcPuGroupPollAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuGroupPollAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuGroupPollAddress.setDescription("The PU's group address in the range of 0x01 to 0xfe. setting this value to 0 will disable the group poll feature for polling this and other PUs in a group. The default value for this field is 0.")
sdlcPuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
sdlcPuMAXOUT = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuMAXOUT.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuMAXOUT.setDescription('This entry defines the maximum number of outstanding I frames that the PU will allow. This field is applicable to TSDLC only.')
sdlcPuConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuConnectType.setDescription('The SNA PU Connection type.')
sdlcPuStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2), )
if mibBuilder.loadTexts: sdlcPuStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuStatsTable.setDescription('A list of PU statistics entries.')
sdlcPuStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "sdlcPuStatsLineIndex"), (0, "SYNC-RESEARCH-MIB", "sdlcPuStatsAddress"))
if mibBuilder.loadTexts: sdlcPuStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuStatsEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
sdlcPuStatsLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuStatsLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuStatsLineIndex.setDescription('The port number for which PU is configured on.')
sdlcPuStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuStatsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuStatsAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
sdlcPuInIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInIFrames.setDescription('The number of I frames received on this PU.')
sdlcPuOutIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutIFrames.setDescription('The number of I frames trasnmitted on this PU.')
sdlcPuInRRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInRRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInRRFrames.setDescription('The number of RR frames received on this PU.')
sdlcPuOutRRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutRRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutRRFrames.setDescription('The number of RR frames transmitted on this PU.')
sdlcPuInRNRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInRNRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInRNRFrames.setDescription('The number of RNR frames received on this PU.')
sdlcPuOutRNRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutRNRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutRNRFrames.setDescription('The number of RNR frames transmitted on this PU.')
sdlcPuInXIDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInXIDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInXIDFrames.setDescription('The number of XID frames received on this PU.')
sdlcPuOutXIDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutXIDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutXIDFrames.setDescription('The number of XID frames transmitted on this PU.')
sdlcPuInTESTFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInTESTFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInTESTFrames.setDescription('The number of TEST frames received on this PU.')
sdlcPuOutTESTFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutTESTFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutTESTFrames.setDescription('The number of TEST frames transmitted on this PU.')
sdlcPuInSNRMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInSNRMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInSNRMFrames.setDescription('The number of SNRM frames received on this PU.')
sdlcPuOutSNRMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutSNRMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutSNRMFrames.setDescription('The number of SNRM frames transmitted on this PU.')
sdlcPuInDISCFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInDISCFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInDISCFrames.setDescription('The number of DISC frames received on this PU.')
sdlcPuOutDISCFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutDISCFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutDISCFrames.setDescription('The number of DISC frames transmitted on this PU.')
sdlcPuInDMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInDMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInDMFrames.setDescription('The number of DM frames received on this PU.')
sdlcPuOutDMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutDMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutDMFrames.setDescription('The number of DM frames transmitted on this PU.')
sdlcPuInUAFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInUAFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInUAFrames.setDescription('The number of UA frames received on this PU.')
sdlcPuOutUAFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutUAFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutUAFrames.setDescription('The number of UA frames transmitted on this PU.')
sdlcPuInFRMRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInFRMRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInFRMRFrames.setDescription('The number of FRMR frames received on this PU.')
sdlcPuOutFRMRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutFRMRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutFRMRFrames.setDescription('The number of FRMR frames transmitted on this PU.')
sdlcPuInRDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInRDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInRDFrames.setDescription('The number of RD frames received on this PU.')
sdlcPuOutRDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutRDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutRDFrames.setDescription('The number of RD frames transmitted on this PU.')
sdlcPuInUIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuInUIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuInUIFrames.setDescription('The number of UI frames received on this PU.')
sdlcPuOutUIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuOutUIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuOutUIFrames.setDescription('The number of UI frames transmitted on this PU.')
sdlcPuReTxIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuReTxIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuReTxIFrames.setDescription('The number of re-transmitted I frames on this PU.')
sdlcPuPollResponseTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 2, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcPuPollResponseTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcPuPollResponseTimeouts.setDescription('The number of PU Poll Response timeouts for this PU.')
bisyncPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1), )
if mibBuilder.loadTexts: bisyncPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConfigTable.setDescription('A list of Bisync CU entries.')
bisyncPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "bisyncPuConfigAddress"))
if mibBuilder.loadTexts: bisyncPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
bisyncPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConfigLineIndex.setDescription('The port number for which PU is configured on.')
bisyncPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
bisyncPuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
bisyncPuInitialState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuInitialState.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuInitialState.setDescription("The initial state of the PU. If configured for 'in-service', then the Bisync PU will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the SDLC PU must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'in-service'.")
bisyncPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuXID.setDescription('The XID value for this PU. The XID is used to identify the PU during the LLC connection process to the remote Host or Gateway. The unit will insert the data configured in the LLC XID sent to the host during the LLC connection process on behalf of the CU. For bisync control units, this field is required as bisync cannot solicit an XID. For incoming LLC connections on Sync Research products this field is parsed to route the connection to the proper PU. The default value for this field is all zeroes.')
bisyncPuTargetHostType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sna-host-type", 1), ("bisync-host-type", 2), ("ice-host-type", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuTargetHostType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuTargetHostType.setDescription('The Target Host type. This field specifies the target host type for TBSC and is applicable to BSC-to-SNA conversion only. This parameter defaults to a value of 2.')
bisyncPuMaxData = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuMaxData.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuMaxData.setDescription('This entry defines the SNA frame size which is the sum of SNA data and SNA header. This value must match the MAXData configured for SNA host and is applicable to BSC-to-SNA conversion only. The default value is 521. The valid range is 265, 521, 777, 1033, 1289.')
bisyncPuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
bisyncPuConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuConnectType.setDescription('The Bisync PU Connection type.')
bisyncPuStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2), )
if mibBuilder.loadTexts: bisyncPuStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuStatsTable.setDescription('A list of PU statistics entries.')
bisyncPuStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncPuStatsLineIndex"), (0, "SYNC-RESEARCH-MIB", "bisyncPuStatsAddress"))
if mibBuilder.loadTexts: bisyncPuStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuStatsEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
bisyncPuStatsLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuStatsLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuStatsLineIndex.setDescription('The port number for which PU is configured on.')
bisyncPuStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuStatsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuStatsAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
bisyncPuInTransactions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuInTransactions.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuInTransactions.setDescription('The number of PU Poll Response timeouts for this PU.')
bisyncPuOutTransactions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuOutTransactions.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuOutTransactions.setDescription('The number of PU Poll Response timeouts for this PU.')
bisyncPuSlowPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuSlowPolls.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuSlowPolls.setDescription('The number of PU slow polls for this PU.')
bisyncPuPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncPuPolls.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncPuPolls.setDescription('The number of PU Polls for this PU.')
mappingPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1), )
if mibBuilder.loadTexts: mappingPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConfigTable.setDescription('This Table is obsolete. A list of PU mapping entries.')
mappingPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "mappingPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "mappingPuConfigAddress"))
if mibBuilder.loadTexts: mappingPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConfigEntry.setDescription('This field is obsolete. This entry contains information about a given mapping PU. Each entry includes MAC/SAP information for a source PU and a similar information for the partner (mapped) PU. Depending upon whether the PU is LAN-attached, SDLC-attached or Frame Relay-attached, one or more fields may not apply. Some fields, for example, mappingPuNAU, mappingPuXID, mappingPuConnectID are common to both end points. The entry is indexed by the port number and the PU number.')
mappingPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConfigLineIndex.setDescription('This field is obsolete. The port number for which PU is associated with. Port number 99 is a special value which is used to indicate NetView PU.')
mappingPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConfigAddress.setDescription('This field is obsolete. The PU address in the range of 0x01 to 0xfe.')
mappingPuSourceSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuSourceSAP.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuSourceSAP.setDescription('This field is obsolete. The LLC source SAP value for this PU. Typically the source SAP will vary for each PU. This is due to the fact that most Sync products are configured to always call the same remote Token-Ring Host or Gateway for all connections configured. This means that all the Destination SAP (usually set to 4) and Destination MAC addresses are the same, so the Source SAP field must be set to a unique value in order to uniquely identify the LLC connection to the Host. (SNA does not allow multiplexing of PUs on one LLC connection. Each PU must have its own LLC Type 2 connection.) This field must be set to a range between 04 and E8 hexadecimal and it must be evenly divisible by 4 (802.2 LLC rules for user assigned SAPs). This field is not applicable in all cases, if not it returns a dummy value. This parameter defaults to a value of 4.')
mappingPuDestinationSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuDestinationSAP.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuDestinationSAP.setDescription('This field is obsolete. The LLC Destination SAP value for this PU. For SNA typically the destination is almost always SAP 4. However both Host Front Ends (e.g. 3745) or Gateways (e.g. 3174) allow SAPs to be configured for any value betwee 0x04 and 0xEC as long as the SAP ID is a user assignable individual SAP ID (any value evenly divisable by 4). This field is not applicable to all cases. If not it returns a dummy value. This parameter defaults to a value of 4.')
mappingPuDestinationMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuDestinationMAC.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuDestinationMAC.setDescription("This field is obsolete. The LAN Destination MAC address used in the LLC Type 2 connection for this PU. The Token-Ring format for this field is a 6 octet (48 bit) field represented in IEEE 802.5 format where the first bit transmitted is the most significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses are between 000000000001 and 7FFFFFFFFFFF (an address of all zeroes is not supported). The Ethernet format for this field is a 6 octet (48 bit) field represented in IEEE 802.3 format where the first bit transmitted is the least significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses must start with the least significant bit equal to 0. In other words, the first two digits must be in the set of 0x00, 0x02, 0x04, ... 0xFE (an address of all 12 digits equal to zeroes is not supported). This field is not applicable to all cases. If not it returns a dummy value.")
mappingPuPartnerConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerConfigLineIndex.setDescription('This field is obsolete. The port number for the partner PU associated with source PU. Port number 99 is a special value which is used to indicate NetView PU.')
mappingPuPartnerConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerConfigAddress.setDescription('This field is obsolete. The PU address of the partner PU in the range of 0x01 to 0xfe.')
mappingPuPartnerSourceSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerSourceSAP.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerSourceSAP.setDescription('This field is obsolete. The LLC source SAP value for a partner PU. Typically the source SAP will vary for each PU. This is due to the fact that most Sync products are configured to always call the same remote Token-Ring Host or Gateway for all connections configured. This means that all the Destination SAP (usually set to 4) and Destination MAC addresses are the same, so the Source SAP field must be set to a unique value in order to uniquely identify the LLC connection to the Host. (SNA does not allow multiplexing of PUs on one LLC connection. Each PU must have its own LLC Type 2 connection.) This field must be set to a range between 04 and E8 hexadecimal and it must be evenly divisible by 4 (802.2 LLC rules for user assigned SAPs). This field is not applicable in all cases, if not it returns a dummy value. This parameter defaults to a value of 4.')
mappingPuPartnerDestSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerDestSAP.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerDestSAP.setDescription('This field is obsolete. The LLC Destination SAP value for the partner PU. For SNA typically the destination is almost always SAP 4. However both Host Front Ends (e.g. 3745) or Gateways (e.g. 3174) allow SAPs to be configured for any value betwee 0x04 and 0xEC as long as the SAP ID is a user assignable individual SAP ID (any value evenly divisable by 4). This field is not applicable to all cases. It returns a dummy value. This parameter defaults to a value of 4.')
mappingPuPartnerDestMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 10), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerDestMAC.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerDestMAC.setDescription("This field is obsolete. The LAN Destination MAC address used in the LLC Type 2 connection for the partner PU. The Token-Ring format for this field is a 6 octet (48 bit) field represented in IEEE 802.5 format where the first bit transmitted is the most significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses are between 000000000001 and 7FFFFFFFFFFF (an address of all zeroes is not supported). The Ethernet format for this field is a 6 octet (48 bit) field represented in IEEE 802.3 format where the first bit transmitted is the least significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses must start with the least significant bit equal to 0. In other words, the first two digits must be in the set of 0x00, 0x02, 0x04, ... 0xFE (an address of all 12 digits equal to zeroes is not supported). This field is not applicable to all cases. If not it returns a dummy value.")
mappingPuNAU = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuNAU.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuNAU.setDescription('This field is obsolete. The NAU Name. The NAU name is same for both the source PU and the partner PU. It represents one physical PU in a network.')
mappingPuConnectID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuConnectID.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConnectID.setDescription('This field is obsolete. The connection ID. This must match a connection ID of an access line PU or another mapping PU Connection ID. The connnection ID is 0 if there is no mapping.')
mappingPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuXID.setDescription('This field is obsolete. The XID value for this PU. The XID is used to identify the PU during the LLC connection process to the remote Host or Gateway. For incoming LLC connections on Sync Research products this field is parsed to route the connection to the proper PU. The XID is same for both the source PU and the partner PU. It represents one physical PU in a network. The default value for this field is all zeroes.')
mappingPuDirectDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuDirectDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuDirectDLCI.setDescription('This field is obsolete. The Frame Relay DLCI used in the LLC Type 2 connection for this PU. The Frame Relay format for this field is a 2 octet (16 bit) field represented in BCD format. A valid DLCI would be from 0001 to 1023 (0000 is reserved for AnnexD management. 1023 is reserved for LMI mangement.). This value is applicable to Frame Relay-attached PU only. The field corresponds to a source port or a partner port depending upon whether the source PU is a Frame Relay-attached PU or the partner PU is Frame Relay-attached PU. For Frame Relay-attached PU if this value is not configured, 0 is returned.')
mappingPuLastClearCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuLastClearCode.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuLastClearCode.setDescription("This field is obsolete. A two octet field indicating the Last Clearing Cause and Diagnostic Field of the last failed connection attempt (a.k.a. call attempt) or active connection (a.k.a. session) for this PU. For LLC type 2 connections the first octet (cause) is always 0. The second octet (diagnostic) indicates the reason for the last connection failure. The second octet is set to 0 when a sucessful call has been placed, or if no call has ever been placed, or the clear is initiated by the partner for which mappingPuPartnerLastClearCode has the clear code. If the second octet is non-zero then it indicates the reason for the connection attempt failure. See User's Guide for more information")
mappingPuConnAttemptCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuConnAttemptCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuConnAttemptCnt.setDescription('This field is obsolete. The number of connection attempts performed for this PU. This count is set to zero at startup, and after every loss of an estabished session.')
mappingPuPartnerLastClearCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerLastClearCode.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerLastClearCode.setDescription("This field is obsolete. A two octet field indicating the Last Clearing Cause and Diagnostic Field of the last failed connection attempt (a.k.a. call attempt) or active connection (a.k.a. session) for the partner PU . For LLC type 2 connections the first octet (cause) is always 0. The second octet (diagnostic) indicates the reason for the last connection failure. The second octet is set to 0 when a sucessful call has been placed, or if no call has ever been placed, or the clear is initiated by the partner for which mappingPuLastClearCode has the clear code. If the second octet is non-zero then it indicates the reason for the connection attempt failure. See User's Guide for information")
mappingPuPartnerConnAttemptCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mappingPuPartnerConnAttemptCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mappingPuPartnerConnAttemptCnt.setDescription('This field is obsolete. The number of connection attempts performed for the partner PU. This count is set to zero at startup, and after every loss of an estabished session.')
remotePuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1), )
if mibBuilder.loadTexts: remotePuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuConfigTable.setDescription('A list of PU mapping entries.')
remotePuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "accessPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "accessPuConfigAddress"))
if mibBuilder.loadTexts: remotePuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuConfigEntry.setDescription('This entry contains information about a given mapping PU. Each entry includes MAC/SAP information for a source PU and a similar information for the partner (mapped) PU. Depending upon whether the PU is LAN-attached, SDLC-attached or Frame Relay-attached, one or more fields may not apply. Some fields, for example, mappingPuNAU, mappingPuXID, mappingPuConnectID are common to both end points. The entry is indexed by the port number and the PU number.')
accessPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessPuConfigLineIndex.setDescription('The port number for which PU is associated with. Port number 99 is a special value which is used to indicate NetView PU.')
accessPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: accessPuConfigAddress.setDescription('The PU address in the range of 0x01 to 0xfe. If the accessPuConfigLineIndex indicates a NetView PU then 01 is used to indicate the primary NetView PU and 02 is used to indicate alternate NetView PU.')
remotePuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuConfigLineIndex.setDescription('The port number for which an access PU, LCU or XCU is associated with.')
remotePuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuConfigAddress.setDescription('The access PU, LCU or XCU address in the range of 0x01 to 0xfe.')
remotePuSourceSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuSourceSAP.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuSourceSAP.setDescription('The LLC source SAP value for this PU. Typically the source SAP will vary for each PU. This is due to the fact that most Sync products are configured to always call the same remote Token-Ring Host or Gateway for all connections configured. This means that all the Destination SAP (usually set to 4) and Destination MAC addresses are the same, so the Source SAP field must be set to a unique value in order to uniquely identify the LLC connection to the Host. (SNA does not allow multiplexing of PUs on one LLC connection. Each PU must have its own LLC Type 2 connection.) This field must be set to a range between 04 and E8 hexadecimal and it must be evenly divisible by 4 (802.2 LLC rules for user assigned SAPs). This field is not applicable in all cases, if not it returns a dummy value. This parameter defaults to a value of 4.')
remotePuDestinationSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuDestinationSAP.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuDestinationSAP.setDescription('The LLC Destination SAP value for this PU. For SNA typically the destination is almost always SAP 4. However both Host Front Ends (e.g. 3745) or Gateways (e.g. 3174) allow SAPs to be configured for any value betwee 0x04 and 0xEC as long as the SAP ID is a user assignable individual SAP ID (any value evenly divisable by 4). This field is not applicable to all cases. If not it returns a dummy value. This parameter defaults to a value of 4.')
remotePuMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 7), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuMAC.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuMAC.setDescription("The LAN Destination MAC address used in the LLC Type 2 connection for this PU. The Token-Ring format for this field is a 6 octet (48 bit) field represented in IEEE 802.5 format where the first bit transmitted is the most significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses are between 000000000001 and 7FFFFFFFFFFF (an address of all zeroes is not supported). The Ethernet format for this field is a 6 octet (48 bit) field represented in IEEE 802.3 format where the first bit transmitted is the least significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses must start with the least significant bit equal to 0. In other words, the first two digits must be in the set of 0x00, 0x02, 0x04, ... 0xFE (an address of all 12 digits equal to zeroes is not supported). This field is not applicable to all cases. If not it returns a dummy value.")
remotePuPrimaryDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuPrimaryDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuPrimaryDLCI.setDescription('The Frame Relay DLCI used in the LLC Type 2 connection for this PU. The Frame Relay format for this field is a 2 octet (16 bit) field represented in BCD format. A valid DLCI would be from 0001 to 1023 (0000 is reserved for AnnexD management. 1023 is reserved for LMI mangement.). This value is applicable to Frame Relay-attached PU only. The field corresponds to a source port or a partner port depending upon whether the source PU is a Frame Relay-attached PU or the partner PU is Frame Relay-attached PU. For Frame Relay-attached PU if this value is not configured, 0 is returned.')
remotePuParallelDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuParallelDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuParallelDLCI.setDescription('Specifies a parallel DLCI indicating a virtual route in parallel to the primary DLCI path. The parallel virtual route allows for session resiliency.')
remotePuAlternateDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuAlternateDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuAlternateDLCI.setDescription('Specifies an alternate DLCI indicating a virtual route to a disaster recovery site.')
remotePuAlternateMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 11), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuAlternateMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuAlternateMACAddress.setDescription('Specifies an alternate MAC address indicating a virtual route to a disaster recovery site.')
remotePuTransmitPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuTransmitPriority.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuTransmitPriority.setDescription('Specifies the transmission priority being URGENT, HIGH, MEDIUM or LOW for this PU.')
remotePuBroadcastAllDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuBroadcastAllDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuBroadcastAllDLCI.setDescription('If this field is set to YES, after all specified paths are determined as unavailable, the session request is broadcast to all DLCIs. IF the primary DLCI is set to 0, then this parameter is treated as YES regardless of its configured value.')
remotePuLocalDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuLocalDTE.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuLocalDTE.setDescription('Specifies the local DTE address to match against any in-dial session for an access PU or LAN PU. For non X25 network type, this field is set to 0')
remotePuRemoteDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 7, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePuRemoteDTE.setStatus('mandatory')
if mibBuilder.loadTexts: remotePuRemoteDTE.setDescription('Specifies the remote DTE address that the X25 SVC connection uses for this access PU or LAN PU.')
asyncPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1), )
if mibBuilder.loadTexts: asyncPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConfigTable.setDescription('A list of PU entries.')
asyncPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "asyncPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "asyncPuConfigAddress"))
if mibBuilder.loadTexts: asyncPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
asyncPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConfigLineIndex.setDescription('The port number for which the line (CU)is configured (first level).')
asyncPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
asyncPuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
asyncPuInitialState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuInitialState.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuInitialState.setDescription("The initial state of the PU. If configured for 'in-service', then the async PU will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the async PU must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'in-service'.")
asyncPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuXID.setDescription('The XID value for this PU. The XID is used to identify the PU during the LLC connection process to the remote Host or Gateway. If the field is configured to 0 then the unit will solicit the XID from the downstream PU and send the XID data received from async to the XID data sent for the LLC connection process. If not sent to 0, then the unit will insert the data configured in the LLC sent to the host during the LLC connection process on behalf of the CU. For incoming LLC connections on Sync Research products this field is parsed to route the connection to the proper PU. The default value for this field is all zeroes (solicit XID from PU).')
asyncPuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
asyncPuConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuConnectType.setDescription('The Async PU Connection type.')
asyncPuDeviceRangeLow = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuDeviceRangeLow.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuDeviceRangeLow.setDescription('The device range number low specifies the low number of a range one or more device addresses for which the data to be routed via the connection information (i.e. Connection ID and XID) contained in an individual CU record. This number must be less than or equal to the deviec range number high. This field is in the range of 0x00 to 0xff.')
asyncPuDeviceRangeHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuDeviceRangeHigh.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuDeviceRangeHigh.setDescription('The device range number high specifies the high number of a range of one or more device addresses for which the data to be routed via the connection information (i.e. Connection ID and XID) contained in an individual CU record. This number must be greater than or equal to the device range number low. This field is in the range of 0x00 to 0xff.')
asyncPuStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2), )
if mibBuilder.loadTexts: asyncPuStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuStatsTable.setDescription('A list of PU statistics entries.')
asyncPuStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "asyncPuStatsLineIndex"), (0, "SYNC-RESEARCH-MIB", "asyncPuStatsAddress"))
if mibBuilder.loadTexts: asyncPuStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuStatsEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
asyncPuStatsLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuStatsLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuStatsLineIndex.setDescription('The port number for which PU is configured on.')
asyncPuStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuStatsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuStatsAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
asyncPuInChars = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuInChars.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuInChars.setDescription('The number of characters received for this PU.')
asyncPuOutChars = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuOutChars.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuOutChars.setDescription('The number of characters transmitted to this PU.')
asyncPuInMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuInMessages.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuInMessages.setDescription('The number of messages received from this PU.')
asyncPuOutMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPuOutMessages.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPuOutMessages.setDescription('The number of messages transmitted to this PU.')
lanPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1), )
if mibBuilder.loadTexts: lanPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuConfigTable.setDescription('A list of PU entries.')
lanPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "lanPuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "lanPuConfigAddress"))
if mibBuilder.loadTexts: lanPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
lanPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuConfigLineIndex.setDescription('The port number for which the line (CU)is configured (first level).')
lanPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xff.')
lanPuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
lanPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuXID.setDescription('The XID value for this PU. The XID is used to identify the PU during the LLC connection process to the remote Host or Gateway. If the field is configured to 0 then the unit will solicit the XID from the downstream PU and send the XID data received from async to the XID data sent for the LLC connection process. If not sent to 0, then the unit will insert the data configured in the LLC sent to the host during the LLC connection process on behalf of the CU. For incoming LLC connections on Sync Research products this field is parsed to route the connection to the proper PU.')
lanPuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
lanPuSourceSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuSourceSAP.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuSourceSAP.setDescription('The LLC source SAP value for this PU. Typically the source SAP will vary for each PU. This is due to the fact that most Sync products are configured to always call the same remote Token-Ring Host or Gateway for all connections configured. This means that all the Destination SAP (usually set to 4) and Destination MAC addresses are the same, so the Source SAP field must be set to a unique value in order to uniquely identify the LLC connection to the Host. (SNA does not allow multiplexing of PUs on one LLC connection. Each PU must have its own LLC Type 2 connection.) This field must be set to a range between 04 and E8 hexadecimal and it must be evenly divisible by 4 (802.2 LLC rules for user assigned SAPs). This field is not applicable in all cases, if not it returns a dummy value. This parameter defaults to a value of 4.')
lanPuDestinationSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuDestinationSAP.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuDestinationSAP.setDescription('The LLC Destination SAP value for this PU. For SNA typically the destination is almost always SAP 4. However both Host Front Ends (e.g. 3745) or Gateways (e.g. 3174) allow SAPs to be configured for any value betwee 0x04 and 0xEC as long as the SAP ID is a user assignable individual SAP ID (any value evenly divisable by 4). This field is not applicable to all cases. If not it returns a dummy value. This parameter defaults to a value of 4.')
lanPuMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 8), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuMAC.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuMAC.setDescription("The LAN Destination MAC address used in the LLC Type 2 connection for this PU. The Token-Ring format for this field is a 6 octet (48 bit) field represented in IEEE 802.5 format where the first bit transmitted is the most significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses are between 000000000001 and 7FFFFFFFFFFF (an address of all zeroes is not supported). The Ethernet format for this field is a 6 octet (48 bit) field represented in IEEE 802.3 format where the first bit transmitted is the least significant bit. The destination MAC must also be an 'Individual' address. Therefore valid addresses must start with the least significant bit equal to 0. In other words, the first two digits must be in the set of 0x00, 0x02, 0x04, ... 0xFE (an address of all 12 digits equal to zeroes is not supported). This field is not applicable to all cases. If not it returns a dummy value.")
lanPuAlternateMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 6, 1, 1, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanPuAlternateMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lanPuAlternateMACAddress.setDescription('Specifies the second destination MAC address for a disaster recovery site.')
x25PuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1), )
if mibBuilder.loadTexts: x25PuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuConfigTable.setDescription('A list of PU entries.')
x25PuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "x25PuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "x25PuConfigAddress"))
if mibBuilder.loadTexts: x25PuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
x25PuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuConfigLineIndex.setDescription('The port number for which PU is configured on.')
x25PuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
x25PuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
x25PuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
x25PuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuXID.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuXID.setDescription('The XID value for this PU. The XID set the CU identification used to establish and negotiate PU-application sessions. If the PU cannot respond to an XID request from the Host, you can configure the Sync unit to supply the XID for the PU by enabling Solicit XID. The default value for this field is all zeroes (solicit XID from PU).')
x25PuSolicitXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuSolicitXID.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuSolicitXID.setDescription("This parameter enables or disables soliciting an XID exchange between the Host and DSPU. This determines whether the Sync unit will solicit an XID to the X.25-attached PU. This parameter defaults to a value of 'Yes'.")
x25PuSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuSourceAddress.setDescription('The paramter specifies the Source Address. This is used to match DTE address.')
x25PuRemoteDTEAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 8, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PuRemoteDTEAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25PuRemoteDTEAddress.setDescription("The paramter specifies a DTE address on the connection's remote end enabling the Host to initiate a session. If you would rather have the X.25 PU initiate the session(indial), do not specify a DTE Address. If the LAN is the incoming session path for this LCU, you do not need to configure this parameter if you are using XIDs to set up a connection. The default value for this field is NONE.")
alcPuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1), )
if mibBuilder.loadTexts: alcPuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConfigTable.setDescription('A list of PU entries.')
alcPuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "alcPuConfigAddress"))
if mibBuilder.loadTexts: alcPuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
alcPuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConfigLineIndex.setDescription('The port number for which PU is configured on.')
alcPuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConfigAddress.setDescription('The PU address in the range of 0x01 to 0x3C (both inclusive) with addresses 0x0d, 0x1D and 0x20 being invalid addresses. The default value is 0x01')
alcPuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
alcPuCSS = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuCSS.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuCSS.setDescription("The initial state of the CU. The Interchange (CU) should be enabled or not when the configuration is activated. The range is 'in-service' or 'out-of-service'. The default value is 'inservice'.")
alcPuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
alcPuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuXID.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuXID.setDescription('The XID value for this PU. The XID defines an identifier call ID BLOCK and ID NUM, which is used in session establishment using LLC2. The default value for this field is all zeroes (solicit XID from PU).')
alcPuConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuConnectType.setDescription('The Alc PU Connection type.')
alcPuLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuLineNumber.setDescription('The parmater defines a host reference to as line number. The range of this parameter is 0x01 to 0xFF(both inclusive). This parameter must match the Host configuration table. The default value is 0x01')
alcPuMaximumFastPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuMaximumFastPoll.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuMaximumFastPoll.setDescription('This parameter defines the maximum time the unit will wait before it polls a device. Typicall the data transfer has priority over polling algorithm. This parameter ensures that polling is not suspended in favor of data transmittal for a prolonged period of time. Range of this parameter is from 1 through 99 in seconds. The default value is 1.')
alcPuMinimumFastPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuMinimumFastPoll.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuMinimumFastPoll.setDescription('This parameter defines the minimum time the unit will wait before it polls a device. This parameter ensures that the devices are not polled at a very high rate (allowing for a pause). Range of this parameter is from 1 through 65500 in 100ths of a second. The default value is 300.')
alcPuMaximumSlowPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuMaximumSlowPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuMaximumSlowPollInterval.setDescription('This parameter defines the maximum time an inactive device is left out of poll list before it is put back in the poll list. Range of this parameter is from 1 through 99 in seconds. The default value is 1.')
alcPuMinimumSlowPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 990))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuMinimumSlowPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuMinimumSlowPollInterval.setDescription('This parameter defines the minimum time an inactive device is left out of poll list before it is put back in the poll list. Range of this parameter is from 1 through 990 in 10ths of a second. The default value is 10.')
alcPuResponseTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuResponseTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuResponseTimeout.setDescription('This parameter defines the duration that a unit will wait for a response from a device. Range of this parameter is from 1 through 99 in 10ths of a second. The default value is 5.')
alcPuUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuUserData.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuUserData.setDescription('The paramter specifies the user data upto sixteen hexadecimal bytes for AX.25 protocol.')
alcSourceDTEAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcSourceDTEAddress.setStatus('mandatory')
if mibBuilder.loadTexts: alcSourceDTEAddress.setDescription('This parameter specifies the DTE address this port will use to access the Alc network.')
alcDestinationDTEAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 1, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcDestinationDTEAddress.setStatus('mandatory')
if mibBuilder.loadTexts: alcDestinationDTEAddress.setDescription('This parameter specifies the DTE address this port will use to access the Alc network.')
alcPuStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2), )
if mibBuilder.loadTexts: alcPuStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuStatsTable.setDescription('A list of PU statistics entries.')
alcPuStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "alcPuStatsLineIndex"), (0, "SYNC-RESEARCH-MIB", "alcPuStatsAddress"))
if mibBuilder.loadTexts: alcPuStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuStatsEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
alcPuStatsLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuStatsLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuStatsLineIndex.setDescription('The port number for which PU is configured on.')
alcPuStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuStatsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuStatsAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
alcPuPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuPolls.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuPolls.setDescription('The number of Polls.')
alcPuDeviceFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuDeviceFaults.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuDeviceFaults.setDescription('The number of Device Faults.')
alcPuBytesRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuBytesRcv.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuBytesRcv.setDescription('The number of Bytes Received to this PU.')
alcPuBytesXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuBytesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuBytesXmit.setDescription('The number of Bytes Transmitted for this PU.')
alcPuSegRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuSegRcv.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuSegRcv.setDescription('The number of Segments Received to this PU.')
alcPuSegXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 9, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcPuSegXmit.setStatus('mandatory')
if mibBuilder.loadTexts: alcPuSegXmit.setDescription('The number of Segments Transmitted for this PU.')
bisyncrjePuConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1), )
if mibBuilder.loadTexts: bisyncrjePuConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConfigTable.setDescription('A list of Bisync CU entries.')
bisyncrjePuConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bisyncrjePuConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "bisyncrjePuConfigAddress"))
if mibBuilder.loadTexts: bisyncrjePuConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConfigEntry.setDescription('This entry contains information about a given PU. The entry is indexed by the port number and the PU number.')
bisyncrjePuConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConfigLineIndex.setDescription('The port number for which PU is configured on.')
bisyncrjePuConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConfigAddress.setDescription('The PU address in the range of 0x00 to 0xfe.')
bisyncrjePuNAUName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuNAUName.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuNAUName.setDescription('The NAU name of this PU. The default value for this field is all blank (filled with ASCII space 0x20 characters).')
bisyncrjePuInitialState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in-service", 1), ("out-of-service", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuInitialState.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuInitialState.setDescription("The initial state of the PU. If configured for 'in-service', then the Bisync RJE PU will be brougt up automattically when the unit is powered up. If configured for 'out-of-service', the the SDLC PU must be manually enabled by operator intervention (i.e. enable command must be sent). The default value is 'in-service'.")
bisyncrjePuConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConnectionID.setDescription('This entry defines the Connection ID to a corresponding entry in the mapping table. The default value for this field is all zeroes.')
bisyncrjePuXID = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuXID.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuXID.setDescription('The XID value for this PU. The default value for this field is all zeroes.')
bisyncrjePuConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 6, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bisyncrjePuConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: bisyncrjePuConnectType.setDescription('The Bisync RJE PU Connection type.')
deviceControlTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1), )
if mibBuilder.loadTexts: deviceControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlTable.setDescription('A table for controlling devices and obtaining information.')
deviceControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "deviceControlIndex"), (0, "SYNC-RESEARCH-MIB", "deviceControlCUIndex"), (0, "SYNC-RESEARCH-MIB", "deviceControlAddress"))
if mibBuilder.loadTexts: deviceControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlEntry.setDescription('An entry consisting of device information for a particular device.')
deviceControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlIndex.setDescription('The number that uniquely identifies this device.')
deviceControlCUIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceControlCUIndex.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlCUIndex.setDescription('The CU index for this device.')
deviceControlAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceControlAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlAddress.setDescription('The device address.')
deviceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("failed", 3), ("restart", 4), ("enable-all", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: deviceStatus.setDescription('The status of the device. To change (write) status of a device, enable, disable, restart or enable all may be set. Valid Return (read) status are enable(d), disable(d), or failed (d). Commands: An enable command will attempt to bring up the device. An enable all command will perform the same function as enable, since there are no sub elements on a device. A disable command will disable the device. Status: Enable(d) indicates the device is enabled and running. Disable(d) indicates the device has been disabled. Failed (d) indicates the device is enabled and not Running.')
deviceControlFailureCode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceControlFailureCode.setStatus('mandatory')
if mibBuilder.loadTexts: deviceControlFailureCode.setDescription('This entry contains the failure codes if the associated device is in the failed state.')
deviceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1), )
if mibBuilder.loadTexts: deviceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigTable.setDescription('A list of device entries.')
deviceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "deviceConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "deviceConfigCUIndex"), (0, "SYNC-RESEARCH-MIB", "deviceConfigAddress"))
if mibBuilder.loadTexts: deviceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
deviceConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigLineIndex.setDescription('The port number for which the line (CU)is configured (line level).')
deviceConfigCUIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceConfigCUIndex.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigCUIndex.setDescription('The CU index which this device is configured on (CU level).')
deviceConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigAddress.setDescription('The device address in the legal range of BSC poll addresses (device level).')
deviceConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crt", 1), ("printer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceConfigType.setDescription('The device type. The default value is crt.')
deviceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2), )
if mibBuilder.loadTexts: deviceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceStatsTable.setDescription('A table of device statistics information.')
deviceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "bscDeviceLineIndex"), (0, "SYNC-RESEARCH-MIB", "bscDeviceCUIndex"), (0, "SYNC-RESEARCH-MIB", "bscDeviceAddress"))
if mibBuilder.loadTexts: deviceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: deviceStatsEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
bscDeviceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceLineIndex.setDescription('The port number for which the line (CU)is configured (line level).')
bscDeviceCUIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceCUIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceCUIndex.setDescription('The CU index which this device is configured on (CU level).')
bscDeviceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceAddress.setDescription('The device address in the legal range of BSC poll addresses (device level).')
bscDeviceInTransactions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceInTransactions.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceInTransactions.setDescription('The number of device receiving transactions.')
bscDeviceOutTransactions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceOutTransactions.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceOutTransactions.setDescription('The number of device transmitting transactions.')
bscDeviceSumCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceSumCount.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceSumCount.setDescription('The device sum count.')
bscDeviceResponseDelaySum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceResponseDelaySum.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceResponseDelaySum.setDescription('The device sum count.')
bscDeviceResponseDelaySqSum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscDeviceResponseDelaySqSum.setStatus('mandatory')
if mibBuilder.loadTexts: bscDeviceResponseDelaySqSum.setDescription('The device sum count.')
alcdeviceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1), )
if mibBuilder.loadTexts: alcdeviceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigTable.setDescription('A list of device entries.')
alcdeviceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "alcdeviceConfigLineIndex"), (0, "SYNC-RESEARCH-MIB", "alcdeviceConfigCUIndex"), (0, "SYNC-RESEARCH-MIB", "deviceConfigAddress"))
if mibBuilder.loadTexts: alcdeviceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigEntry.setDescription('This entry contains information about a given device. The entry is indexed by the port number, CU index, and device.')
alcdeviceConfigLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcdeviceConfigLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigLineIndex.setDescription('The port number for which the line (CU)is configured (line level).')
alcdeviceConfigCUIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcdeviceConfigCUIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigCUIndex.setDescription('The CU index which this device is configured on (CU level).')
alcdeviceConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcdeviceConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigAddress.setDescription('The device address in the legal range of ALC poll addresses (device level). The range is 0x01 to 0x3c with 0x20 being invalid address. The default value is 0x01.')
alcdeviceConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 7, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crt", 1), ("printer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alcdeviceConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: alcdeviceConfigType.setDescription('The device type. The default value is printer.')
t7ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1), )
if mibBuilder.loadTexts: t7ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: t7ConfigTable.setDescription('A table for T7 protocol configuration parameters.')
t7ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "t7ConfigIndex"))
if mibBuilder.loadTexts: t7ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: t7ConfigEntry.setDescription('An entry consisting of T7 protocol information for a particular port.')
t7ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: t7ConfigIndex.setDescription('The number that uniquely identifies this T7 port.')
t7ProtocolEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7ProtocolEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: t7ProtocolEnabled.setDescription("This flag indicates if T7 protocol is enabled on this unit. If No, the following T7 variables will have no effect. The default value for this field is 'No'")
t7PortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200))).clone(namedValues=NamedValues(("speed75", 75), ("speed150", 150), ("speed300", 300), ("speed600", 600), ("speed1200", 1200), ("speed2400", 2400), ("speed4800", 4800), ("speed9600", 9600), ("speed19200", 19200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7PortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: t7PortSpeed.setDescription('The speed of the T7 port expressed in bits per second. The default speed is 75 bits per second')
t7StopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7StopBits.setStatus('mandatory')
if mibBuilder.loadTexts: t7StopBits.setDescription('Number of stop bits generated for T7 port transmit characters (received characters may have any number of bits regardless of the configuration). The default value is 2')
t7PortParity = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd", 1), ("even", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7PortParity.setStatus('mandatory')
if mibBuilder.loadTexts: t7PortParity.setDescription('T7 port parity type generated for transmit characters and checked for receive characters. If ODD or EVEN, then if a character is received with invalid parity, it is discarded and the message once completely received is also discarded (i.e. not forwarded to the network). If NONE, then no parity bit is expected within the character or generated to the line. The default value is EVEN.')
t7DataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7DataBits.setStatus('mandatory')
if mibBuilder.loadTexts: t7DataBits.setDescription('T7 port number of data bit (not including the parity bit). The default value is 7')
t7IdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7IdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: t7IdleTimer.setDescription('The T7 Idle timer is amount of time (in milliseconds) used to determine when a complete message has been received from the line. If configured as 0, then this timer is disabled and the message will be sent to the network only when the RX forwarding count is reached. If configured greater than 0, then the timer must be configured for a time longer than the time it takes to receive one character, otherwise the timer will not function properly. The default value is 200')
t7PortTxFrameGap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7PortTxFrameGap.setStatus('mandatory')
if mibBuilder.loadTexts: t7PortTxFrameGap.setDescription('The T7 port TX frame gap is analogous to the idle timer, but is used to separate messages received from the network by gaps in time so that the Async device can distinguish between multiple messages. If configured as 0, then this function is disabled and if messages are received while transmitting a current message, the the two messages from the network will be sent out with no gap between them. If configured greater than 0, then a gap of the specified number of milliseconds will be inserted. The default value is 200')
t7RxForwardingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RxForwardingCount.setStatus('mandatory')
if mibBuilder.loadTexts: t7RxForwardingCount.setDescription('The T7 port receive forwarding count is used to forward messages when a configured number of characters is received from the Async line. This must be configured to greater than or equal to the maximum message length for a given protocol. The default value is 256')
t7PortIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7PortIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: t7PortIPAddress.setDescription('The T7 port IP address is used to configure the remote IP address in which to communicate with.')
t7UDPPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7UDPPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: t7UDPPortNumber.setDescription('The T7 port UDP port number address is used to configure the local and remot UDP port number (i.e. socket) address in which to communicate with. The default value is 600')
t7StatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1), )
if mibBuilder.loadTexts: t7StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: t7StatsTable.setDescription('A table of T7 protocol statistics information.')
t7StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "t7StatsIndex"))
if mibBuilder.loadTexts: t7StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: t7StatsEntry.setDescription('This entry contains information about a T7 port. The entry is indexed by the port number, CU index, and device.')
t7StatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7StatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: t7StatsIndex.setDescription('The number that uniquely identifies this T7 port.')
t7InOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7InOctets.setStatus('mandatory')
if mibBuilder.loadTexts: t7InOctets.setDescription('The number of bytes received.')
t7OutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7OutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: t7OutOctets.setDescription('The number of bytes sent.')
t7InMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7InMessages.setStatus('mandatory')
if mibBuilder.loadTexts: t7InMessages.setDescription('The number of messages received.')
t7OutMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7OutMessages.setStatus('mandatory')
if mibBuilder.loadTexts: t7OutMessages.setDescription('The number of messages sent.')
t7InMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7InMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: t7InMsgDiscarded.setDescription('The number of received messages discarded.')
t7OutMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7OutMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: t7OutMsgDiscarded.setDescription('The number of sent messages discarded.')
t7XmtFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7XmtFailures.setStatus('mandatory')
if mibBuilder.loadTexts: t7XmtFailures.setDescription('The number of failures in transmission.')
t7RcvMsgForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvMsgForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvMsgForwarded.setDescription('The number of received messages forwarded.')
t7RcvMsgErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvMsgErrors.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvMsgErrors.setDescription('The number of errors detected in receiving messages.')
t7RcvCharsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvCharsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvCharsDiscarded.setDescription('The number of received characters discarded.')
t7RcvParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvParityErrors.setDescription('The number of parity errors detected.')
t7RcvFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvFramingErrors.setDescription('The number of errors detected in receiving frames.')
t7RcvFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvFifoOverruns.setDescription('The number FIFO receive overruns detected.')
t7RcvCharsOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvCharsOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvCharsOverruns.setDescription('The number of character receive overruns detected.')
t7RcvBreakConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 8, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t7RcvBreakConditions.setStatus('mandatory')
if mibBuilder.loadTexts: t7RcvBreakConditions.setDescription('The number of receive break conditions.')
slipConfigTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1), )
if mibBuilder.loadTexts: slipConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: slipConfigTable.setDescription('A table for Slip protocol configuration parameters.')
slipConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "slipConfigIndex"))
if mibBuilder.loadTexts: slipConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slipConfigEntry.setDescription('An entry consisting of Slip protocol information for a particular port.')
slipConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slipConfigIndex.setDescription('The number that uniquely identifies this Slip port.')
slipProtocolEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipProtocolEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: slipProtocolEnabled.setDescription("This flag indicates if COM2 port is enabled or disabled for usage for SLIP. The default value for this field is 'Yes'")
slipPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200))).clone(namedValues=NamedValues(("speed75", 75), ("speed150", 150), ("speed300", 300), ("speed600", 600), ("speed1200", 1200), ("speed2400", 2400), ("speed4800", 4800), ("speed9600", 9600), ("speed19200", 19200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: slipPortSpeed.setDescription('This parameter determines the COM2 port speed for the SLIP connection to the modem. The default speed is 9600 bits per second')
slipStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: slipStopBits.setDescription('This parameter specifies the number of transmit Stop Bits used on the SLIP connection to the modem. The range of this parameter is 1 or 2 bits. The default value is 1')
slipIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: slipIdleTimer.setDescription('The Slip Idle timer is amount of time (in milliseconds) used to determine the end of frame. The idel timer is started every time a character is received. The range of this parameter is from 0 to 5000 milliseconds. A valuse of zero implies the parameter is not used. The default value is 200')
slipPortIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipPortIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slipPortIPAddress.setDescription('The Slip port IP address. The default valus is 0.0.0.0.')
slipUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("modem-management", 1), ("ipend-node", 2), ("ip-routing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipUsage.setStatus('mandatory')
if mibBuilder.loadTexts: slipUsage.setDescription('This parameter defines whether SLIP protocol is used to manage locally attached modem or is it used for IP end node function or IP forwarding function. The range of this parameter is MODEM MANAGEMENT, IPEND NODE, IP ROUTING. The default value is Modem Management')
slipNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: slipNetworkMask.setDescription('This parameter defines IP sub-netmask for this parameter. The default valus is 0.0.0.0.')
slipDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: slipDefaultGateway.setDescription('This parameter defines IP default gateway. The default valus is 0.0.0.0.')
slipEnableRIP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipEnableRIP.setStatus('mandatory')
if mibBuilder.loadTexts: slipEnableRIP.setDescription("This parameter defines whether RIP packets should be sent on this interface or not. Range is yes or no. The default valus is 'no'.")
slipStatsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1), )
if mibBuilder.loadTexts: slipStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: slipStatsTable.setDescription('A table of Slip protocol statistics information.')
slipStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1), ).setIndexNames((0, "SYNC-RESEARCH-MIB", "slipStatsIndex"))
if mibBuilder.loadTexts: slipStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slipStatsEntry.setDescription('This entry contains information about a slip Com port.')
slipStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slipStatsIndex.setDescription('The number that uniquely identifies this Slip com port.')
slipInChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInChrs.setStatus('mandatory')
if mibBuilder.loadTexts: slipInChrs.setDescription('The number of Characters received.')
slipOutChrs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutChrs.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutChrs.setDescription('The number of characters sent.')
slipInMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInMessages.setStatus('mandatory')
if mibBuilder.loadTexts: slipInMessages.setDescription('The number of messages received.')
slipOutMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutMessages.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutMessages.setDescription('The number of messages sent.')
slipInMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: slipInMsgDiscarded.setDescription('The number of received messages discarded.')
slipOutMsgDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutMsgDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutMsgDiscarded.setDescription('The number of sent messages discarded.')
slipXmtFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipXmtFailures.setStatus('mandatory')
if mibBuilder.loadTexts: slipXmtFailures.setDescription('The number of failures in transmission.')
slipRcvMsgForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvMsgForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvMsgForwarded.setDescription('The number of received messages forwarded.')
slipRcvMsgErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvMsgErrors.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvMsgErrors.setDescription('The number of errors detected in receiving messages.')
slipRcvCharsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvCharsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvCharsDiscarded.setDescription('The number of received characters discarded.')
slipRcvParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvParityErrors.setDescription('The number of parity errors detected.')
slipRcvFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvFramingErrors.setDescription('The number of errors detected in receiving frames.')
slipRcvFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvFifoOverruns.setDescription('The number FIFO receive overruns detected.')
slipRcvCharsOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvCharsOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvCharsOverruns.setDescription('The number of character receive overruns detected.')
slipRcvBreakConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 3, 10, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipRcvBreakConditions.setStatus('mandatory')
if mibBuilder.loadTexts: slipRcvBreakConditions.setDescription('The number of receive break conditions.')
configChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,800)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "configId"))
if mibBuilder.loadTexts: configChanged.setDescription('This trap indicates that the configuration of the unit has been changed.')
configError = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,801)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "lastInstallErrCode"))
if mibBuilder.loadTexts: configError.setDescription('This trap indicates that the activation of configuration of the unit has resulted in an error. New configuration has not been successfully activated.')
dumpExists = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,802)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "dumpFileName"))
if mibBuilder.loadTexts: dumpExists.setDescription('This trap indicates that a memory core dump exists.')
dumpArchived = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,803)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"))
if mibBuilder.loadTexts: dumpArchived.setDescription('This trap indicates that the memory dump file has been archived.')
lineStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,804)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "lineStatus"), ("SYNC-RESEARCH-MIB", "lineControlFailureCode"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"), ("SYNC-RESEARCH-MIB", "lineCableType"))
if mibBuilder.loadTexts: lineStatusChanged.setDescription('This trap indicates that the indicated Line or Port has changed state. It has either been enabled, failed or disabled.')
lanStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,805)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "lanStatus"), ("SYNC-RESEARCH-MIB", "lanControlFailureCode"))
if mibBuilder.loadTexts: lanStatusChanged.setDescription('This trap indicates that the indicated LAN Port has changed state. It has either been enabled, failed or disabled.')
lineQuality = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,806)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "lineQualityFrameCount"), ("SYNC-RESEARCH-MIB", "lineQualityCRCErrors"), ("SYNC-RESEARCH-MIB", "lineQualityAborts"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: lineQuality.setDescription('This trap indicates that the line quality is changed. If the lineQualityAborts is greater than 5 or lineQualityCRCErrors is greater that 5 then it indicates a poor line quality, otherwise it indicates a change from a poor to good line quality.')
puStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,807)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puStatus"), ("SYNC-RESEARCH-MIB", "puControlFailureCode"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"))
if mibBuilder.loadTexts: puStatusChanged.setDescription('This trap indicates that the indicated PU has changed state. It has either been enabled, failed or disabled.')
puConnectionStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,808)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puConnectionStatus"), ("SYNC-RESEARCH-MIB", "puLastClearCode"))
if mibBuilder.loadTexts: puConnectionStatusChanged.setDescription('Note this trap is obsolete. This trap indicates that the indicated PU has changed connection state. Its connection has either been established, disconnected, or rejected.')
netviewConnectionStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,809)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "netviewConnectionStatus"), ("SYNC-RESEARCH-MIB", "netviewLastClearCode"))
if mibBuilder.loadTexts: netviewConnectionStatusChanged.setDescription('Note this trap is obsolete. This trap indicates that the NetView PU has changed connection state. Its connection has either been established, disconnected, or rejected.')
netviewAltConnectionStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,810)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "netviewAltConnectionStatus"), ("SYNC-RESEARCH-MIB", "netviewAltLastClearCode"))
if mibBuilder.loadTexts: netviewAltConnectionStatusChanged.setDescription('Note this trap is obsolete. This trap indicates that the Alternate NetView PU has changed connection state. Its connection has either been established, disconnected, or rejected.')
puConnectionStatusUp = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,811)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"))
if mibBuilder.loadTexts: puConnectionStatusUp.setDescription('This trap is obsolete. This trap indicates that the indicated PU has changed connection state. Its connection had been established.')
puConnectionStatusDown = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,812)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puLastClearCode"))
if mibBuilder.loadTexts: puConnectionStatusDown.setDescription('This trap is obsolete. This trap indicates that the indicated PU has changed connection state. Its connection has been disconnected. If the indicated PU is not in session, the trap is generated only if the clear code is different from the puLastClearCode.')
netviewConnectionStatusUp = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,813)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"))
if mibBuilder.loadTexts: netviewConnectionStatusUp.setDescription('This trap is obsolete. This trap indicates that the indicated NetView PU has changed connection state. Its connection has been established.')
netviewConnectionStatusDown = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,814)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "netviewLastClearCode"))
if mibBuilder.loadTexts: netviewConnectionStatusDown.setDescription('This trap is obsolete. This trap indicates that the indicated NetView PU has changed connection state. Its connection had been disconnected. If the indicated PU is not in session, the trap is generated only if the clear code is different from the netviewLastClearCode.')
netviewAltConnectionStatusUp = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,815)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"))
if mibBuilder.loadTexts: netviewAltConnectionStatusUp.setDescription('This trap is obsolete. This trap indicates that the indicated Alternate NetView PU has changed connection state. Its connection has been established.')
netviewAltConnectionStatusDown = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,816)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "netviewAltLastClearCode"))
if mibBuilder.loadTexts: netviewAltConnectionStatusDown.setDescription('This trap is obsolete. This trap indicates that the indicated Alternate NetView PU has changed connection state. Its connection had been disconnected. If the indicated PU is not in session, the trap is generated only if the clear code is different from the netviewAltLastClearCode.')
sessSwitchedToPrimaryDLCI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,817)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessSwitchedToPrimaryDLCI.setDescription('This trap indicates that a session switch has occured from a Parallel DLCI to Primary DLCI.')
sessSwitchedToParallelDLCI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,818)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessSwitchedToParallelDLCI.setDescription('This trap indicates that a session switch has occured from the Primary DLCI to the Parallel DLCI.')
sessUpOnPrimaryDLCI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,819)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puCurrentMAC"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnPrimaryDLCI.setDescription('This indicates that a PU session is established on a primary DLCI. This TRAP is generated for Frame Nodes only. For Conversion Node sessUpOnPrimaryMAC or sessUpOnAlternatMAC will be used instead. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU.')
sessUpOnParallelDLCI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,820)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puCurrentMAC"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnParallelDLCI.setDescription('This indicates that a PU session is established on a parallel DLCI. This TRAP is generated for Frame Nodes only. For Conversion Node sessUpOnPrimaryMAC or sessUpOnAlternatMAC will be used instead. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU.')
sessUpOnAlternateDLCI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,821)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puCurrentMAC"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnAlternateDLCI.setDescription('This indicates that a PU session is established on an alternate DLCI. This TRAP is generated for Frame Nodes only. For Conversion Node sessUpOnPrimaryMAC or sessUpOnAlternatMAC will be used instead. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU.')
sessUpOnPrimaryMAC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,822)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puCurrentMAC"), ("SYNC-RESEARCH-MIB", "linePhysicalType"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnPrimaryMAC.setDescription('This indicates that a PU session is established on a non-explicit (dynamic, or broadcast) DLCI to the primary destination MAC. For Conversion Node, puCurrentDlci is set to 0. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU.')
sessUpOnAlternateMAC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,823)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentDlci"), ("SYNC-RESEARCH-MIB", "puCurrentMAC"), ("SYNC-RESEARCH-MIB", "linePhysicalType"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnAlternateMAC.setDescription('This indicates that a PU session is established on a non-explicit (dynamic, or broadcast) DLCI to the alternate destination MAC, if configured. For Conversion Node, puCurrentDlci is set to 0. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU.')
sessDownOnPrimaryMAC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,824)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puLastClearCode"), ("SYNC-RESEARCH-MIB", "puLastDlciCleared"), ("SYNC-RESEARCH-MIB", "puLastMACCleared"), ("SYNC-RESEARCH-MIB", "linePhysicalType"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessDownOnPrimaryMAC.setDescription('This trap indicates that the session for the indicated PU associated with the primary destination MAC was cleared. If the indicated PU is not in session, the trap is generated only if the clear code is different from the puLastClearCode. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU. For Conversion Node, puLastDlicCleared is not applicable and is therefore set to 0')
sessDownOnAlternateMAC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,825)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puLastClearCode"), ("SYNC-RESEARCH-MIB", "puLastDlciCleared"), ("SYNC-RESEARCH-MIB", "puLastMACCleared"), ("SYNC-RESEARCH-MIB", "linePhysicalType"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessDownOnAlternateMAC.setDescription('This trap indicates that the session for the indicated PU associated with the alternate destination MAC, if configured, was cleared. If the indicated PU is not in session, the trap is generated only if the clear code is different from the puLastClearCode. For NetView the puControlLineIndex is set to 99, and the puControlPUAddress is set to 01 for primary PU and 02 for the alternate NetView PU. For Conversion Node, puLastDlicCleared is not applicable and is therefore set to 0')
lostUNI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,826)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: lostUNI.setDescription('This trap indicates that the indicated Frame Relay Line or Port has lost its UNI connectivity to the Frame Relay network.')
restoredUNI = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,827)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: restoredUNI.setDescription('This trap indicates that the indicated Frame Relay Line or Port has restored its UNI connectivity to the Frame Relay network.')
switchedToBackup = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,828)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: switchedToBackup.setDescription('This trap indicates that the indicated Frame Relay Line or Port has successfully switched to switched backup connection.')
switchedToDed = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,829)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: switchedToDed.setDescription('This trap indicates that the indicated Frame Relay Line or Port has successfully switched to the dedicated Frame Relay connection to the network.')
dialConnStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,830)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "lineStatus"), ("SYNC-RESEARCH-MIB", "lineControlFailureCode"), ("SYNC-RESEARCH-MIB", "linePhysicalIndex"))
if mibBuilder.loadTexts: dialConnStatusChanged.setDescription('This trap indicates that the indicated dial backup connection has changed state. It has either been connected or disconnected.')
sessUpOnSVC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,831)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puCurrentSVC"), ("SYNC-RESEARCH-MIB", "puCurrentLocalDTE"), ("SYNC-RESEARCH-MIB", "puCurrentRemoteDTE"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessUpOnSVC.setDescription('This trap indicates that the session for the indicated PU or LAN PU associated with the remote DTE address was established.')
sessDownOnSVC = NotificationType((1, 3, 6, 1, 4, 1, 485) + (0,832)).setObjects(("SYNC-RESEARCH-MIB", "lastTrapSeqNumber"), ("SYNC-RESEARCH-MIB", "puControlLineIndex"), ("SYNC-RESEARCH-MIB", "puControlPUAddress"), ("SYNC-RESEARCH-MIB", "puLastClearCode"), ("SYNC-RESEARCH-MIB", "puLastSVCCleared"), ("SYNC-RESEARCH-MIB", "puLastLocalDTECleared"), ("SYNC-RESEARCH-MIB", "puLastRemoteDTECleared"), ("SYNC-RESEARCH-MIB", "puIsDynamic"))
if mibBuilder.loadTexts: sessDownOnSVC.setDescription('This trap indicates that the session for the indicated PU or LAN PU associated with the last remote DTE address was cleared. If the indicated PU/LAN PU is not in session, the trap is generated only if the clear code is different from the puLastClearCode.')
mibBuilder.exportSymbols("SYNC-RESEARCH-MIB", sdlcPuNAUName=sdlcPuNAUName, lineStatusChanged=lineStatusChanged, lanSendLocalTest=lanSendLocalTest, processorType=processorType, alcResponseTimeouts=alcResponseTimeouts, t7ProtocolEnabled=t7ProtocolEnabled, slipStatsTable=slipStatsTable, frameRelayReturnClock=frameRelayReturnClock, syncResearch=syncResearch, lastTrapSeqNumber=lastTrapSeqNumber, oemSNACXR3C=oemSNACXR3C, brIPXtargetDLCI=brIPXtargetDLCI, lineDialBackupGroup=lineDialBackupGroup, x25ReceivePacketSize=x25ReceivePacketSize, mappingPuXID=mappingPuXID, deviceConfigCUIndex=deviceConfigCUIndex, alcDSR=alcDSR, lanIPEthernetFrameType=lanIPEthernetFrameType, brFilterSMAN=brFilterSMAN, sdlcT1Timer=sdlcT1Timer, sdlcPuConnectionID=sdlcPuConnectionID, t7RcvFifoOverruns=t7RcvFifoOverruns, alternateNetviewSpecialConnect=alternateNetviewSpecialConnect, mappingPuConnAttemptCnt=mappingPuConnAttemptCnt, lanPuConfigTable=lanPuConfigTable, dsucsudeviceStatsTable=dsucsudeviceStatsTable, dialConnStatusChanged=dialConnStatusChanged, x25MaxRetries=x25MaxRetries, sdlcPuOutFRMRFrames=sdlcPuOutFRMRFrames, ipInactivityTimer=ipInactivityTimer, sdlcPuInitialState=sdlcPuInitialState, channelID=channelID, lanSAPAge=lanSAPAge, slipRcvMsgForwarded=slipRcvMsgForwarded, frameRelayProxyARP=frameRelayProxyARP, slipPortIPAddress=slipPortIPAddress, sessUpOnSVC=sessUpOnSVC, frameRelayRIPUpdtTimer=frameRelayRIPUpdtTimer, bisyncPuConfigEntry=bisyncPuConfigEntry, ipxSapRcvdFwdInterval=ipxSapRcvdFwdInterval, frameRelayConfigPortIndex=frameRelayConfigPortIndex, frameRelayMultiflagSeparation=frameRelayMultiflagSeparation, lanPuSourceSAP=lanPuSourceSAP, slipProtocolEnabled=slipProtocolEnabled, frameRelayRIPAge=frameRelayRIPAge, alcBytesRx=alcBytesRx, sdlcStatsPortIndex=sdlcStatsPortIndex, t7DataBits=t7DataBits, brIPXPriority=brIPXPriority, x25DSR=x25DSR, bisyncrjePuConnectType=bisyncrjePuConnectType, bisyncrjeOutEnq=bisyncrjeOutEnq, x25StatsEntry=x25StatsEntry, sdlcPuInUAFrames=sdlcPuInUAFrames, puBisyncRjeGroup=puBisyncRjeGroup, puControlPUAddress=puControlPUAddress, deviceControlAddress=deviceControlAddress, bscDeviceSumCount=bscDeviceSumCount, numberSamples=numberSamples, x25StatsPortIndex=x25StatsPortIndex, x25ReceiveWindowSize=x25ReceiveWindowSize, bisyncNAUName=bisyncNAUName, bisyncPuInitialState=bisyncPuInitialState, alcPuConfigLineIndex=alcPuConfigLineIndex, bridgePriority=bridgePriority, sdlcDCD=sdlcDCD, x25PuConfigTable=x25PuConfigTable, unitRestart=unitRestart, lineInterfaceType=lineInterfaceType, remotePuPrimaryDLCI=remotePuPrimaryDLCI, asyncXmtFailures=asyncXmtFailures, frameRelayInOctets=frameRelayInOctets, enableRipBroadcast=enableRipBroadcast, farEndNumber=farEndNumber, dsucsuClocking=dsucsuClocking, puControlLineIndex=puControlLineIndex, syncBF4R5=syncBF4R5, bisyncrjeDSR=bisyncrjeDSR, syncCN2R2du=syncCN2R2du, puConnectionAttemptCount=puConnectionAttemptCount, asyncPuDeviceRangeHigh=asyncPuDeviceRangeHigh, netviewConnectionStatus=netviewConnectionStatus, dialbackupPortType=dialbackupPortType, x25ConfigPortIndex=x25ConfigPortIndex, syncCN4R5du=syncCN4R5du, x25NetworkMask=x25NetworkMask, mappingPuPartnerDestSAP=mappingPuPartnerDestSAP, linkConverter=linkConverter, frameRelayCommittedBurst=frameRelayCommittedBurst, oem22185BC5=oem22185BC5, remotePuConfigEntry=remotePuConfigEntry, associatedDLCI4=associatedDLCI4, maxPortNumber=maxPortNumber, bisyncRetries=bisyncRetries, bisyncRcvTimeout=bisyncRcvTimeout, frameRelayARP=frameRelayARP, alcSegTx=alcSegTx, alcdeviceConfigLineIndex=alcdeviceConfigLineIndex, netviewAltLastClearCode=netviewAltLastClearCode, lanRIPAge=lanRIPAge, frameRelayOverruns=frameRelayOverruns, t7RcvMsgErrors=t7RcvMsgErrors, t7RcvBreakConditions=t7RcvBreakConditions, associatedDLCI2=associatedDLCI2, sdlcPuInRRFrames=sdlcPuInRRFrames, sdlcReturnClock=sdlcReturnClock, alcNAUName=alcNAUName, sdlcPuOutUAFrames=sdlcPuOutUAFrames, syncFN5R5du=syncFN5R5du, slipRcvCharsDiscarded=slipRcvCharsDiscarded, frExtCircuitQOctets=frExtCircuitQOctets, alcPuBytesXmit=alcPuBytesXmit, asyncPortType=asyncPortType, mappingPuDirectDLCI=mappingPuDirectDLCI, lineAsyncGroup=lineAsyncGroup, lc2TR6port=lc2TR6port, sessUpOnParallelDLCI=sessUpOnParallelDLCI, lanSAPUpdtTimer=lanSAPUpdtTimer, asyncRcvMsgErrors=asyncRcvMsgErrors, sdlcPuMAXOUT=sdlcPuMAXOUT, callRetryTimer=callRetryTimer, lineQualityCRCErrors=lineQualityCRCErrors, syncCN4R4b=syncCN4R4b, lanPortType=lanPortType, associatedDLCI3=associatedDLCI3, sdlcPuOutRRFrames=sdlcPuOutRRFrames, slipStatsEntry=slipStatsEntry, bisyncrjeInEnq=bisyncrjeInEnq, frameRelayLocalManagementProtocol=frameRelayLocalManagementProtocol, bisyncReturnClock=bisyncReturnClock, lanControlEntry=lanControlEntry, deviceControlEntry=deviceControlEntry, associatedPortNumber3=associatedPortNumber3, commTrap=commTrap, commCount=commCount, asyncDCD=asyncDCD, isdnloopbackbytesReceived=isdnloopbackbytesReceived, brEnableOtherBridging=brEnableOtherBridging, frameRelayFullStatusPollingCount=frameRelayFullStatusPollingCount, alcdeviceConfigEntry=alcdeviceConfigEntry, alcDestinationDTEAddress=alcDestinationDTEAddress, frameRelayVirtualRingNumber=frameRelayVirtualRingNumber, bisyncrjePuNAUName=bisyncrjePuNAUName, ipxStatsIndex=ipxStatsIndex, sdlcPuStatsTable=sdlcPuStatsTable, bisyncrjeInEtx=bisyncrjeInEtx, dsucsuloopbackbytesTransmitted=dsucsuloopbackbytesTransmitted, srCommTrapGroup=srCommTrapGroup, syncCN3R4bu=syncCN3R4bu, lc2EN4port=lc2EN4port, x25TransmitWindowSize=x25TransmitWindowSize, sessUpOnPrimaryMAC=sessUpOnPrimaryMAC, asyncPuStatsLineIndex=asyncPuStatsLineIndex, syncFN4R2c=syncFN4R2c, bisyncSessTerm=bisyncSessTerm, dumpFileStatus=dumpFileStatus, bscDeviceInTransactions=bscDeviceInTransactions, bisyncrjeCarrier=bisyncrjeCarrier, remotePuMAC=remotePuMAC, ipxEnableRouting=ipxEnableRouting, alcPuStatsEntry=alcPuStatsEntry, packetsReceived=packetsReceived, mappingPuPartnerSourceSAP=mappingPuPartnerSourceSAP, syncBC5R5=syncBC5R5, lineQuality=lineQuality, bisyncSpeed=bisyncSpeed, brMediumPriorityBandwidth=brMediumPriorityBandwidth, brIPPriority=brIPPriority, sdlcDSR=sdlcDSR, bisyncSlowpollTimer=bisyncSlowpollTimer, asyncDTR=asyncDTR, dialbackupDedicatedLMIPort=dialbackupDedicatedLMIPort, unitId=unitId, x25CTS=x25CTS, bisyncXmtTimeout=bisyncXmtTimeout, asyncCTS=asyncCTS, syncCN4R3c=syncCN4R3c, oemSNACMR2C=oemSNACMR2C, puMappingGroup=puMappingGroup, frExtCircuitRxDe=frExtCircuitRxDe, asyncRTC=asyncRTC, nodeFrCirGroup=nodeFrCirGroup, brHighPriorityBandwidth=brHighPriorityBandwidth, x25PuRemoteDTEAddress=x25PuRemoteDTEAddress, lineAlcGroup=lineAlcGroup, nodePUGroup=nodePUGroup, netviewConnectID=netviewConnectID, frameRelayAlternateIPAddress=frameRelayAlternateIPAddress, associatedPortNumber4=associatedPortNumber4, deviceConfigType=deviceConfigType, puLastDlciCleared=puLastDlciCleared, frameRelayMaxRetries=frameRelayMaxRetries, alcPuXID=alcPuXID, oem22183FR4=oem22183FR4, sdlciframetrans=sdlciframetrans, lineEIAStatus=lineEIAStatus, bisyncInitState=bisyncInitState, frameRelayT1Timer=frameRelayT1Timer, oem22183BF5=oem22183BF5, sdlcPuPollResponseTimeouts=sdlcPuPollResponseTimeouts, brEnableIPXBridging=brEnableIPXBridging, t7OutMsgDiscarded=t7OutMsgDiscarded, switchedToBackup=switchedToBackup, sdlcNRZI=sdlcNRZI, asyncRcvMsgForwarded=asyncRcvMsgForwarded, x25DTEAddress=x25DTEAddress, mappingPuConfigEntry=mappingPuConfigEntry, brIPXtargetPort=brIPXtargetPort, consolidatedUnitStatus=consolidatedUnitStatus, alcRxOverruns=alcRxOverruns, slipRcvBreakConditions=slipRcvBreakConditions, bisyncPuSlowPolls=bisyncPuSlowPolls, deviceConfigEntry=deviceConfigEntry, remotePuAlternateMACAddress=remotePuAlternateMACAddress, boundary=boundary, t7PortParity=t7PortParity, lanT2Timer=lanT2Timer, oemSNACXR4W=oemSNACXR4W, sdlcPuStatsLineIndex=sdlcPuStatsLineIndex, alcStatsTable=alcStatsTable, bisyncPuOutTransactions=bisyncPuOutTransactions, bscDeviceAddress=bscDeviceAddress, dsucsuType=dsucsuType, bisyncDSR=bisyncDSR, alcCTS=alcCTS, t7IdleTimer=t7IdleTimer, bisyncrjeReturnClock=bisyncrjeReturnClock, bisyncrjeConfigTable=bisyncrjeConfigTable, x25OutRestarts=x25OutRestarts, alcBytesTx=alcBytesTx, alcPuSegRcv=alcPuSegRcv, internalMacAddress=internalMacAddress, frameRelayVirtualMACAddress=frameRelayVirtualMACAddress, dialbackupDialSuspendTimer=dialbackupDialSuspendTimer, asyncRcvFramingErrors=asyncRcvFramingErrors, alcConfigEntry=alcConfigEntry, remotePuRemoteDTE=remotePuRemoteDTE, bisyncCTS=bisyncCTS, remotePuAlternateDLCI=remotePuAlternateDLCI, alcPuConfigTable=alcPuConfigTable, lanControlNAUName=lanControlNAUName, sdlcRTS=sdlcRTS, serviceType=serviceType, alcPuMinimumSlowPollInterval=alcPuMinimumSlowPollInterval, x25PuConnectionID=x25PuConnectionID, alcPuMaximumFastPoll=alcPuMaximumFastPoll, sdlcPuInDISCFrames=sdlcPuInDISCFrames, syncQN4R5du=syncQN4R5du, puNetworkType=puNetworkType, frameRelayVirtualBridgeNumber=frameRelayVirtualBridgeNumber, nosConnectAttempts=nosConnectAttempts, sdlcInFrames=sdlcInFrames, netViewPUConfigGroup=netViewPUConfigGroup, bisyncrjeCTS=bisyncrjeCTS)
mibBuilder.exportSymbols("SYNC-RESEARCH-MIB", dialbackupSuccatmpt=dialbackupSuccatmpt, slipInMessages=slipInMessages, bisyncrjeClocking=bisyncrjeClocking, syncCN2R2b=syncCN2R2b, bisyncPuMaxData=bisyncPuMaxData, frameRelayRecvAborts=frameRelayRecvAborts, DisplayString=DisplayString, bisyncPause=bisyncPause, sdlcClocking=sdlcClocking, bisyncrjeReplyTimer=bisyncrjeReplyTimer, bisyncrjeOutEtb=bisyncrjeOutEtb, associatedPortNumber2=associatedPortNumber2, oem22183CR4=oem22183CR4, remotePuConfigLineIndex=remotePuConfigLineIndex, oemSNACXR2C=oemSNACXR2C, nodeSlipGroup=nodeSlipGroup, internalRingNumber4=internalRingNumber4, alcConfigPortIndex=alcConfigPortIndex, bisyncrjePuConfigAddress=bisyncrjePuConfigAddress, commName=commName, wan1BoardType=wan1BoardType, syncQN4R4du=syncQN4R4du, lineQualityFrameCount=lineQualityFrameCount, sdlcCTS=sdlcCTS, x25DataInChrs=x25DataInChrs, t7StatsTable=t7StatsTable, x25DCD=x25DCD, slipEnableRIP=slipEnableRIP, brDelayTimer=brDelayTimer, netviewConnectionStatusChanged=netviewConnectionStatusChanged, bscDeviceResponseDelaySqSum=bscDeviceResponseDelaySqSum, lanPuNAUName=lanPuNAUName, frExtCircuitMaxBits=frExtCircuitMaxBits, lanPuDestinationSAP=lanPuDestinationSAP, isdnSpeed=isdnSpeed, x25ForwardingUnit=x25ForwardingUnit, asyncPuInitialState=asyncPuInitialState, sdlcPuGroupPollAddress=sdlcPuGroupPollAddress, deviceConfigTable=deviceConfigTable, slipRcvCharsOverruns=slipRcvCharsOverruns, alcNumberOfSegments=alcNumberOfSegments, syncFN4R5bu=syncFN4R5bu, acknowledgeAllStatuses=acknowledgeAllStatuses, slipDefaultGateway=slipDefaultGateway, mappingPuNAU=mappingPuNAU, puAsyncGroup=puAsyncGroup, internalMacAddress3=internalMacAddress3, chassisSlot=chassisSlot, systemBufferFreeCounts=systemBufferFreeCounts, frExtCircuitStatusIgnored=frExtCircuitStatusIgnored, puLastMACCleared=puLastMACCleared, asyncIdleTimer=asyncIdleTimer, sdlcPuOutRDFrames=sdlcPuOutRDFrames, alcSegRxDisc=alcSegRxDisc, frExtCircuitStatusAcknowledged=frExtCircuitStatusAcknowledged, syncBF5R5=syncBF5R5, oem22181FR5=oem22181FR5, wan2BoardType=wan2BoardType, t7RcvCharsDiscarded=t7RcvCharsDiscarded, sdlcPuInSNRMFrames=sdlcPuInSNRMFrames, alcdeviceConfigAddress=alcdeviceConfigAddress, puConnectionStatusUp=puConnectionStatusUp, dialbackupConnectType=dialbackupConnectType, netviewPUXID=netviewPUXID, asyncOutMsgDiscarded=asyncOutMsgDiscarded, serialPortLogoffTimer=serialPortLogoffTimer, lostUNI=lostUNI, puIsDynamic=puIsDynamic, bisyncConfigEntry=bisyncConfigEntry, lanT1Timer=lanT1Timer, frameRelayConfigTable=frameRelayConfigTable, x25LinkWindowSize=x25LinkWindowSize, slipNetworkMask=slipNetworkMask, t7StatsIndex=t7StatsIndex, isdnloopbackbytesTransmitted=isdnloopbackbytesTransmitted, connectionTimeOut=connectionTimeOut, bisyncPuStatsLineIndex=bisyncPuStatsLineIndex, alcBytesRxDisc=alcBytesRxDisc, sdlcInitState=sdlcInitState, mappingPuPartnerConfigLineIndex=mappingPuPartnerConfigLineIndex, lineStatus=lineStatus, bisyncPuStatsEntry=bisyncPuStatsEntry, alcDCD=alcDCD, alcPuPolls=alcPuPolls, dsucsuSpeed=dsucsuSpeed, configChanged=configChanged, frameRelayDSR=frameRelayDSR, oemSNACXR3W=oemSNACXR3W, x25PortSpeed=x25PortSpeed, sdlcStatsEntry=sdlcStatsEntry, t7ConfigGroup=t7ConfigGroup, slipStatsIndex=slipStatsIndex, puControlTable=puControlTable, dsucsudeviceStatsEntry=dsucsudeviceStatsEntry, srNodeGroup=srNodeGroup, sdlcCRCErrors=sdlcCRCErrors, accessPuConfigAddress=accessPuConfigAddress, bisyncStatsPortIndex=bisyncStatsPortIndex, frameRelayDTR=frameRelayDTR, x25COutFrames=x25COutFrames, x25SigInPkts=x25SigInPkts, alcSourceDTEAddress=alcSourceDTEAddress, enableIpRouting=enableIpRouting, puBisyncGroup=puBisyncGroup, alcPuLineNumber=alcPuLineNumber, sdlcPuType=sdlcPuType, asyncPuStatsTable=asyncPuStatsTable, alcPuBytesRcv=alcPuBytesRcv, x25OutFrames=x25OutFrames, t7ConfigTable=t7ConfigTable, nodeDeviceGroup=nodeDeviceGroup, remotePuLocalDTE=remotePuLocalDTE, bisyncStatsTable=bisyncStatsTable, asyncConfigType=asyncConfigType, sdlcPuInRNRFrames=sdlcPuInRNRFrames, slipConfigIndex=slipConfigIndex, lanSecondDefaultGateway=lanSecondDefaultGateway, spid=spid, isdnControlGroup=isdnControlGroup, enableIpBridging=enableIpBridging, puCurrentRemoteDTE=puCurrentRemoteDTE, mappingPuSourceSAP=mappingPuSourceSAP, ipxConfigGroup=ipxConfigGroup, netviewStatusIgnored=netviewStatusIgnored, unitStatisticsGroup=unitStatisticsGroup, unitPartNumber=unitPartNumber, dialbackupConfigTable=dialbackupConfigTable, unitSerialNumber=unitSerialNumber, asyncPuConnectType=asyncPuConnectType, ibm=ibm, netviewAltConnectionAttemptCount=netviewAltConnectionAttemptCount, dialbackupTreatLLCControlCharacters=dialbackupTreatLLCControlCharacters, deviceStatsTable=deviceStatsTable, lanTxWindowSize=lanTxWindowSize, slipInChrs=slipInChrs, dialbackupStatsTable=dialbackupStatsTable, x25PuConfigEntry=x25PuConfigEntry, frameRelayStatsPortIndex=frameRelayStatsPortIndex, sdlcPuOutDISCFrames=sdlcPuOutDISCFrames, lanDefaultGateway=lanDefaultGateway, sessUpOnAlternateMAC=sessUpOnAlternateMAC, netviewAltConnectionStatusUp=netviewAltConnectionStatusUp, asyncRcvCharsOverruns=asyncRcvCharsOverruns, alcPuStatsTable=alcPuStatsTable, homeDialBackup=homeDialBackup, lanPortEntry=lanPortEntry, syncCN4R5b=syncCN4R5b, localNumber=localNumber, x25PortType=x25PortType, frameRelayRestrictTerminateSessUsage=frameRelayRestrictTerminateSessUsage, nodeUnitGroup=nodeUnitGroup, x25Sum=x25Sum, initializeStats=initializeStats, commTable=commTable, packetsTransmitted=packetsTransmitted, asyncTxFrameGap=asyncTxFrameGap, sdlcConfigPortIndex=sdlcConfigPortIndex, x25AcceptReverseChargeCalls=x25AcceptReverseChargeCalls, frameRelaySAPAge=frameRelaySAPAge, bisyncrjeDTR=bisyncrjeDTR, asyncSpeed=asyncSpeed, sdlcConfigEntry=sdlcConfigEntry, syncQN4R4b=syncQN4R4b, bisyncrjeInitState=bisyncrjeInitState, syncCN3R5du=syncCN3R5du, x25InFrames=x25InFrames, bisyncrjeNAUName=bisyncrjeNAUName, ipxEnableNetBIOS=ipxEnableNetBIOS, frameRelayTxWindowSize=frameRelayTxWindowSize, dialbackupDialInactivityTimer=dialbackupDialInactivityTimer, asyncPuConfigTable=asyncPuConfigTable, syncQN4R3b=syncQN4R3b, bisyncrjeStatsPortIndex=bisyncrjeStatsPortIndex, asyncCarrier=asyncCarrier, oemSNACMR4C=oemSNACMR4C, alcConfigType=alcConfigType, remotePuConfigTable=remotePuConfigTable, asyncPuInMessages=asyncPuInMessages, dsucsuLine=dsucsuLine, lastInstallErrCode=lastInstallErrCode, t7RcvParityErrors=t7RcvParityErrors, clearDump=clearDump, alcPortSpeed=alcPortSpeed, puLanGroup=puLanGroup, bisyncrjeRTS=bisyncrjeRTS, alternateNetviewConnectID=alternateNetviewConnectID, bisyncPuConnectType=bisyncPuConnectType, asyncInitState=asyncInitState, oemSNACXR2Q=oemSNACXR2Q, oemProducts=oemProducts, msExtBoardType=msExtBoardType, sdlcPuInRDFrames=sdlcPuInRDFrames, excessBurstGovernor=excessBurstGovernor, syncFN4R2b=syncFN4R2b, asyncEiaSignalForwarding=asyncEiaSignalForwarding, syncFN4R3c=syncFN4R3c, frExtCircuitEntry=frExtCircuitEntry, restoredUNI=restoredUNI, lineControlTable=lineControlTable, kbytesReceived=kbytesReceived, configPassword=configPassword, mappingPuConnectID=mappingPuConnectID, oem2490R22C=oem2490R22C, dialbackupDialDelayTimer=dialbackupDialDelayTimer, asyncPuStatsAddress=asyncPuStatsAddress, configError=configError, brEnableNetBiosBridging=brEnableNetBiosBridging, netviewConnectionStatusUp=netviewConnectionStatusUp, x25QOutChrs=x25QOutChrs, alcdeviceConfigTable=alcdeviceConfigTable, bisyncDTR=bisyncDTR, alcPuMinimumFastPoll=alcPuMinimumFastPoll, lineBisyncRjeGroup=lineBisyncRjeGroup, brOthertargetPort=brOthertargetPort, syncFN4R5du=syncFN4R5du, centralSite=centralSite, dialbackupConfigEntry=dialbackupConfigEntry, ipxSapRcvdFiltInterval=ipxSapRcvdFiltInterval, loopbackTest=loopbackTest, frExtCircuitTxDe=frExtCircuitTxDe, netviewAltStatusAcknowledged=netviewAltStatusAcknowledged, puCurrentLocalDTE=puCurrentLocalDTE, x25StatsTable=x25StatsTable, syncCN4R2b=syncCN4R2b, alcBytesTxDisc=alcBytesTxDisc, kbytesTransmitted=kbytesTransmitted, puLastLocalDTECleared=puLastLocalDTECleared, asyncRcvBreakConditions=asyncRcvBreakConditions, sdlcMaxRetries=sdlcMaxRetries, deviceControlCUIndex=deviceControlCUIndex, slipUsage=slipUsage, syncCN5R5du=syncCN5R5du, bisyncrjePuConfigEntry=bisyncrjePuConfigEntry, lineFrameRelayGroup=lineFrameRelayGroup, syncCN4R5bu=syncCN4R5bu, lc2TR2port=lc2TR2port, bisyncrjePuConfigLineIndex=bisyncrjePuConfigLineIndex, x25ConfigType=x25ConfigType, x25PuXID=x25PuXID, frameRelaySwitchedLineWaitTimer=frameRelaySwitchedLineWaitTimer, deviceControlTable=deviceControlTable, nodeLANGroup=nodeLANGroup, bridgeStatsGroup=bridgeStatsGroup, lanControlGroup=lanControlGroup, bisyncrjePuXID=bisyncrjePuXID, brEnableIPBridging=brEnableIPBridging, brMaxAge=brMaxAge, x25NAUName=x25NAUName, alcdeviceConfigType=alcdeviceConfigType, remotePuDestinationSAP=remotePuDestinationSAP, puStatus=puStatus, unitStatusGroup=unitStatusGroup, bisyncrjeConfigEntry=bisyncrjeConfigEntry, slipOutMessages=slipOutMessages)
mibBuilder.exportSymbols("SYNC-RESEARCH-MIB", bisyncrjeOutChrs=bisyncrjeOutChrs, oemSNACMR3C=oemSNACMR3C, frExtCircuitDlci=frExtCircuitDlci, brFilterIP=brFilterIP, x25CInFrames=x25CInFrames, brIPtargetDLCI=brIPtargetDLCI, sdlcPuInTESTFrames=sdlcPuInTESTFrames, netviewAltConnectionStatusChanged=netviewAltConnectionStatusChanged, syncBF4R5b=syncBF4R5b, asyncInOctets=asyncInOctets, netviewStatusAcknowledged=netviewStatusAcknowledged, asyncPuOutChars=asyncPuOutChars, bisyncrjeStatsEntry=bisyncrjeStatsEntry, lanIPAddress=lanIPAddress, bisyncPuXID=bisyncPuXID, bisyncCarrier=bisyncCarrier, x25UFrames=x25UFrames, linePhysicalEntry=linePhysicalEntry, nodeIpGroup=nodeIpGroup, mappingPuPartnerDestMAC=mappingPuPartnerDestMAC, asyncNAUName=asyncNAUName, frameRelayDefaultGatewayAddress=frameRelayDefaultGatewayAddress, asyncDataBits=asyncDataBits, sdlcPuStatsAddress=sdlcPuStatsAddress, sdlcPuConfigAddress=sdlcPuConfigAddress, dumpOnRestart=dumpOnRestart, sdlcPuOutDMFrames=sdlcPuOutDMFrames, sdlcPuStatsEntry=sdlcPuStatsEntry, brNetBIOStargetPort=brNetBIOStargetPort, syncFN3R4du=syncFN3R4du, puControlFailureCode=puControlFailureCode, bisyncConfigPortIndex=bisyncConfigPortIndex, bisyncPortType=bisyncPortType, dialbackupSecondDedicatedPort=dialbackupSecondDedicatedPort, dialbackupinact=dialbackupinact, lineStatusIgnored=lineStatusIgnored, oemSNACMR4Q=oemSNACMR4Q, alcStatsEntry=alcStatsEntry, frameRelayNetworkMask=frameRelayNetworkMask, puConnectionStatusDown=puConnectionStatusDown, brFilterLLC2=brFilterLLC2, frameRelayAlternateNetmask=frameRelayAlternateNetmask, puControlNAUName=puControlNAUName, netviewAltStatusIgnored=netviewAltStatusIgnored, asyncAddressOffset=asyncAddressOffset, puLastRemoteDTECleared=puLastRemoteDTECleared, t7InMsgDiscarded=t7InMsgDiscarded, syncBF3R5=syncBF3R5, sessUpOnAlternateDLCI=sessUpOnAlternateDLCI, internalBridgeNumber=internalBridgeNumber, lineControlNAUName=lineControlNAUName, dumpFileName=dumpFileName, puX25Group=puX25Group, asyncOrt=asyncOrt, frameRelayStatsTable=frameRelayStatsTable, x25InRestarts=x25InRestarts, puStatusAcknowledged=puStatusAcknowledged, frameRelayOutOctets=frameRelayOutOctets, syncFN4R4b=syncFN4R4b, dialbackupassociatedDLCIDedicated=dialbackupassociatedDLCIDedicated, frameRelayT2Timer=frameRelayT2Timer, asyncRTS=asyncRTS, slipXmtFailures=slipXmtFailures, brEnableSyncManBridging=brEnableSyncManBridging, x25T1Timer=x25T1Timer, alcDTR=alcDTR, lc2EN2port=lc2EN2port, asyncOutMessages=asyncOutMessages, puControlEntry=puControlEntry, PhysAddress=PhysAddress, asyncRcvCharsDiscarded=asyncRcvCharsDiscarded, asyncPuConfigLineIndex=asyncPuConfigLineIndex, deviceConfigLineIndex=deviceConfigLineIndex, lanRSM=lanRSM, bscDeviceLineIndex=bscDeviceLineIndex, bisyncIBS=bisyncIBS, sdlcPuInIFrames=sdlcPuInIFrames, oem22181FR4=oem22181FR4, lanBridgeNumber=lanBridgeNumber, commIndex=commIndex, asyncPuConfigAddress=asyncPuConfigAddress, oem22183BC5=oem22183BC5, lanControlIndex=lanControlIndex, expansionSerialNumber=expansionSerialNumber, x25InResets=x25InResets, lineX25Group=lineX25Group, commEntry=commEntry, puCurrentSVC=puCurrentSVC, slipStopBits=slipStopBits, alcLimitSegsCharsBetweenPolls=alcLimitSegsCharsBetweenPolls, brNetBIOSPriority=brNetBIOSPriority, bisyncOutOctets=bisyncOutOctets, commAccess=commAccess, oemSNACXR4C=oemSNACXR4C, oem22181CR4=oem22181CR4, bisyncrjeWack=bisyncrjeWack, oemSNACMR2Q=oemSNACMR2Q, x25DeviceWindowSize=x25DeviceWindowSize, alcPuConfigEntry=alcPuConfigEntry, lanStatusChanged=lanStatusChanged, lineControlFailureCode=lineControlFailureCode, lanPuXID=lanPuXID, bisyncDCD=bisyncDCD, x25ReturnClock=x25ReturnClock, bscDeviceOutTransactions=bscDeviceOutTransactions, lanPuAlternateMACAddress=lanPuAlternateMACAddress, lanControlFailureCode=lanControlFailureCode, syncFN4R3b=syncFN4R3b, threeCom=threeCom, syncFN2R2du=syncFN2R2du, asyncPuNAUName=asyncPuNAUName, oemSNACMR3W=oemSNACMR3W, lanPortIndex=lanPortIndex, mappingPuPartnerConnAttemptCnt=mappingPuPartnerConnAttemptCnt, dumpExists=dumpExists, sdlcStatsTable=sdlcStatsTable, bscDeviceCUIndex=bscDeviceCUIndex, bisyncrjeConfigPortIndex=bisyncrjeConfigPortIndex, puCurrentDlci=puCurrentDlci, nodeT7Group=nodeT7Group, oemSNACXR3Q=oemSNACXR3Q, alcNumberOfCharacters=alcNumberOfCharacters, alcPortType=alcPortType, alcPuConfigAddress=alcPuConfigAddress, t7XmtFailures=t7XmtFailures, bisyncrjeRetries=bisyncrjeRetries, brLLC2targetPort=brLLC2targetPort, brSerialPriority=brSerialPriority, lanTiTimer=lanTiTimer, bisyncPuConnectionID=bisyncPuConnectionID, lanPuMAC=lanPuMAC, alcPuConnectType=alcPuConnectType, t7RcvMsgForwarded=t7RcvMsgForwarded, x25ConfigTable=x25ConfigTable, slipOutMsgDiscarded=slipOutMsgDiscarded, sdlcpollrsptimeouts=sdlcpollrsptimeouts, frameRelayClocking=frameRelayClocking, x25PlaceReverseChargeCalls=x25PlaceReverseChargeCalls, syncFN4R4u=syncFN4R4u, asyncStatsTable=asyncStatsTable, lanPortTable=lanPortTable, alcInitState=alcInitState, oemSNACXR4Q=oemSNACXR4Q, markDEBit=markDEBit, brLowPriorityBandwidth=brLowPriorityBandwidth, oemSNACMR2W=oemSNACMR2W, frameRelayInitState=frameRelayInitState, mappingPuLastClearCode=mappingPuLastClearCode, asyncPuXID=asyncPuXID, lanPuConfigLineIndex=lanPuConfigLineIndex, slipOutChrs=slipOutChrs, sessUpOnPrimaryDLCI=sessUpOnPrimaryDLCI, dumpArchived=dumpArchived, oem22185CR5=oem22185CR5, x25DataOutPkts=x25DataOutPkts, t7OutOctets=t7OutOctets, syncCN4R4bu=syncCN4R4bu, syncBC4R5b=syncBC4R5b, unitModel=unitModel, puAlcGroup=puAlcGroup, brEnableBridging=brEnableBridging, bisyncrjeSpeed=bisyncrjeSpeed, frameRelayRxWindowSize=frameRelayRxWindowSize, mappingPuPartnerConfigAddress=mappingPuPartnerConfigAddress, t7InOctets=t7InOctets, frameRelayRxDe=frameRelayRxDe, puCurrentConnectionType=puCurrentConnectionType, slipIdleTimer=slipIdleTimer, sdlcPuOutTESTFrames=sdlcPuOutTESTFrames, syncFN3R4bu=syncFN3R4bu, syncCN4R2c=syncCN4R2c, sdlcPause=sdlcPause, bisyncRTS=bisyncRTS, slipStatsGroup=slipStatsGroup, bisyncrjeOutTrns=bisyncrjeOutTrns, alcPuNAUName=alcPuNAUName, sdlcPuReTxIFrames=sdlcPuReTxIFrames, frExtCircuitMinBits=frExtCircuitMinBits, sdlcConfigTable=sdlcConfigTable, bisyncStatsEntry=bisyncStatsEntry, lanStatus=lanStatus, netviewConnectionStatusDown=netviewConnectionStatusDown, localNumberType=localNumberType, deviceControlIndex=deviceControlIndex, sdlcOutOctets=sdlcOutOctets, puLastClearCode=puLastClearCode, x25DevicePacketSize=x25DevicePacketSize, dialbackupModemInitString=dialbackupModemInitString, alcPuResponseTimeout=alcPuResponseTimeout, syncQN4R3c=syncQN4R3c, lanRxWindowSize=lanRxWindowSize, bisyncrjeConfigType=bisyncrjeConfigType, nodeBridgeGroup=nodeBridgeGroup, bisyncPuPolls=bisyncPuPolls, expansionPartNumber=expansionPartNumber, sdlcRecvAborts=sdlcRecvAborts, syncQN4R5b=syncQN4R5b, asyncPuStatsEntry=asyncPuStatsEntry, asyncPuConfigEntry=asyncPuConfigEntry, alcdeviceConfigCUIndex=alcdeviceConfigCUIndex, lanInterfaceType=lanInterfaceType, lanNAUName=lanNAUName, lanInitState=lanInitState, sdlcOverruns=sdlcOverruns, cableTron=cableTron, deviceControlFailureCode=deviceControlFailureCode, maxPU=maxPU, mappingPuConfigLineIndex=mappingPuConfigLineIndex, frameRelaySAPUpdtTimer=frameRelaySAPUpdtTimer, alcSegRx=alcSegRx, lanTokenRingGroup=lanTokenRingGroup, x25SecondDefaultGatewayAddress=x25SecondDefaultGatewayAddress, lanBroadcastType=lanBroadcastType, asyncOutOctets=asyncOutOctets, remotePuConfigAddress=remotePuConfigAddress, asyncPuOutMessages=asyncPuOutMessages, bscDeviceResponseDelaySum=bscDeviceResponseDelaySum, bisyncPuStatsAddress=bisyncPuStatsAddress, commMACAddr=commMACAddr, brOthertargetDLCI=brOthertargetDLCI, x25SumsQ=x25SumsQ, alcPuMaximumSlowPollInterval=alcPuMaximumSlowPollInterval, lineControlEntry=lineControlEntry, asyncPuInChars=asyncPuInChars, lanRIPUpdtTimer=lanRIPUpdtTimer, netviewAltConnectionStatus=netviewAltConnectionStatus, alcPuStatsLineIndex=alcPuStatsLineIndex, accessPuConfigLineIndex=accessPuConfigLineIndex, softwareVersion=softwareVersion, dsucsuLineNumber=dsucsuLineNumber, frameRelayNAUName=frameRelayNAUName, x25RTS=x25RTS, remotePuBroadcastAllDLCI=remotePuBroadcastAllDLCI, sdlcPuOutSNRMFrames=sdlcPuOutSNRMFrames, oemSNACMR3Q=oemSNACMR3Q, bisyncrjePortType=bisyncrjePortType, puRemoteGroup=puRemoteGroup, oemSNACXR2W=oemSNACXR2W, frameRelayBridgingProtocol=frameRelayBridgingProtocol, t7UDPPortNumber=t7UDPPortNumber, brNetBIOStargetDLCI=brNetBIOStargetDLCI, syncQN4R4u=syncQN4R4u, x25Samples=x25Samples, frameRelaySwitchedAttemptsSuccessful=frameRelaySwitchedAttemptsSuccessful, remotePuParallelDLCI=remotePuParallelDLCI, slipInMsgDiscarded=slipInMsgDiscarded, bisyncrjeInRetr=bisyncrjeInRetr, internalRingNumber=internalRingNumber, x25FRMRInFrames=x25FRMRInFrames, chipcom=chipcom, slipConfigTable=slipConfigTable, bisyncrjePuInitialState=bisyncrjePuInitialState, alcPuUserData=alcPuUserData, lanPuConnectionID=lanPuConnectionID)
mibBuilder.exportSymbols("SYNC-RESEARCH-MIB", lineControlIndex=lineControlIndex, frameRelayIPAddress=frameRelayIPAddress, asyncPhysicalType=asyncPhysicalType, alcSegTxDisc=alcSegTxDisc, sdlcPuOutIFrames=sdlcPuOutIFrames, frameRelayExcessBurst=frameRelayExcessBurst, sdlcSpeed=sdlcSpeed, lineControlGroup=lineControlGroup, x25QInChrs=x25QInChrs, bisyncConfigType=bisyncConfigType, bisyncPuTargetHostType=bisyncPuTargetHostType, frameRelaySwitchedBackup=frameRelaySwitchedBackup, bisyncPuNAUName=bisyncPuNAUName, asyncRxForwardingCount=asyncRxForwardingCount, lineStatusAcknowledged=lineStatusAcknowledged, maxSession=maxSession, isdndeviceStatsEntry=isdndeviceStatsEntry, asyncPuDeviceRangeLow=asyncPuDeviceRangeLow, x25PuConfigLineIndex=x25PuConfigLineIndex, x25DataInPkts=x25DataInPkts, sessDownOnSVC=sessDownOnSVC, lanPROMMACAddress=lanPROMMACAddress, frameRelayRSM=frameRelayRSM, frExtCircuitPartnerId=frExtCircuitPartnerId, ipxGlobalNodeId=ipxGlobalNodeId, x25PuNAUName=x25PuNAUName, alcClocking=alcClocking, oem22181CR5=oem22181CR5, dialbackupModemDialString=dialbackupModemDialString, sdlcMultiFlagInsertion=sdlcMultiFlagInsertion, initiateInstall=initiateInstall, x25LowTwoWayChannel=x25LowTwoWayChannel, t7PortTxFrameGap=t7PortTxFrameGap, lanMACAddress=lanMACAddress, netviewLastClearCode=netviewLastClearCode, oemSNACMR4W=oemSNACMR4W, deviceBSCGroup=deviceBSCGroup, asyncStatsEntry=asyncStatsEntry, frameRelayTiTimer=frameRelayTiTimer, lanRingNumber=lanRingNumber, alcConfigTable=alcConfigTable, sessSwitchedToParallelDLCI=sessSwitchedToParallelDLCI, frameRelaySpeed=frameRelaySpeed, x25DTR=x25DTR, dateTimeField=dateTimeField, syncQN4R4bu=syncQN4R4bu, syncFN4R4bu=syncFN4R4bu, dialbackupStatsEntry=dialbackupStatsEntry, ipxEnableRipBroadcast=ipxEnableRipBroadcast, alcRcvCCCErrors=alcRcvCCCErrors, configId=configId, netviewAltConnectionStatusDown=netviewAltConnectionStatusDown, slipConfigGroup=slipConfigGroup, ipxEnableSapBroadcast=ipxEnableSapBroadcast, ipxRipRcvdFiltInterval=ipxRipRcvdFiltInterval, dialbackupFirstDedicatedPort=dialbackupFirstDedicatedPort, bisyncPuInTransactions=bisyncPuInTransactions, syncCN4R3b=syncCN4R3b, alcPortFaults=alcPortFaults, puSDLCGroup=puSDLCGroup, x25QOutPkts=x25QOutPkts, lanPuConfigEntry=lanPuConfigEntry, dialbackupassociatedDLCISecond=dialbackupassociatedDLCISecond, t7PortSpeed=t7PortSpeed, x25PuSolicitXID=x25PuSolicitXID, nmsSerialSpeed=nmsSerialSpeed, sdlcPuConnectType=sdlcPuConnectType, dialbackupStatsPortIndex=dialbackupStatsPortIndex, sdlcPuInXIDFrames=sdlcPuInXIDFrames, x25Clocking=x25Clocking, syncCN4R4u=syncCN4R4u, unitControlGroup=unitControlGroup, slipRcvFramingErrors=slipRcvFramingErrors, bisyncrjePuConnectionID=bisyncrjePuConnectionID, password=password, t7StatsEntry=t7StatsEntry, isdnLineIndex=isdnLineIndex, lineCableType=lineCableType, asyncConfigEntry=asyncConfigEntry, bisyncrjeDCD=bisyncrjeDCD, puConnectionStatusChanged=puConnectionStatusChanged, switchedToDed=switchedToDed, internalMacAddress4=internalMacAddress4, isdnIndex=isdnIndex, syncFN4R5b=syncFN4R5b, deviceStatus=deviceStatus, lanSpeed=lanSpeed, remotePuSourceSAP=remotePuSourceSAP, nodeLineGroup=nodeLineGroup, deviceStatsEntry=deviceStatsEntry, lanControlType=lanControlType, remotePuTransmitPriority=remotePuTransmitPriority, t7StopBits=t7StopBits, ipxStatsTable=ipxStatsTable, nodeIpxGroup=nodeIpxGroup, internalIPAddr=internalIPAddr, dialbackupunsuccatmpt=dialbackupunsuccatmpt, sdlcPuConfigEntry=sdlcPuConfigEntry, alcRTS=alcRTS, sdlcPuXID=sdlcPuXID, asyncRcvParityErrors=asyncRcvParityErrors, alternateNetviewPUXID=alternateNetviewPUXID, dialbackupModemHangString=dialbackupModemHangString, bisyncPuConfigTable=bisyncPuConfigTable, asyncPuConnectionID=asyncPuConnectionID, x25PuConfigAddress=x25PuConfigAddress, ipxRoutedTxPriority=ipxRoutedTxPriority, lineQualityAborts=lineQualityAborts, t7InMessages=t7InMessages, msBoardType=msBoardType, brEnableSNABridging=brEnableSNABridging, puConnectionStatus=puConnectionStatus, alcReturnClock=alcReturnClock, t7OutMessages=t7OutMessages, oem22184BC5=oem22184BC5, unitConfigGroup=unitConfigGroup, oem22184BF5=oem22184BF5, internalIPNetmask=internalIPNetmask, frameRelayDCD=frameRelayDCD, frExtCircuitIfIndex=frExtCircuitIfIndex, netViewPUStatusGroup=netViewPUStatusGroup, lanControlTable=lanControlTable, frameRelaySecondDefaultGatewayAddress=frameRelaySecondDefaultGatewayAddress, asyncConfigTable=asyncConfigTable, alcNumberOfNullSeg=alcNumberOfNullSeg, asyncStopBits=asyncStopBits, bisyncPuStatsTable=bisyncPuStatsTable, t7ConfigIndex=t7ConfigIndex, bisyncrjeStatsTable=bisyncrjeStatsTable, linePhysicalTable=linePhysicalTable, brTerminatedLLC2Priority=brTerminatedLLC2Priority, syncProducts=syncProducts, linkConverter2=linkConverter2, linePhysicalIndex=linePhysicalIndex, frameRelayLinkPollingTimer=frameRelayLinkPollingTimer, internalRingNumber2=internalRingNumber2, bisyncPuConfigLineIndex=bisyncPuConfigLineIndex, frameRelaySwitchedAttempts=frameRelaySwitchedAttempts, brFilterNetBIOS=brFilterNetBIOS, bisyncReplyTimer=bisyncReplyTimer, frameRelayLLC2FrameFormat=frameRelayLLC2FrameFormat, sdlcPuOutRNRFrames=sdlcPuOutRNRFrames, brHelloTimer=brHelloTimer, frameRelaySessSwitchThreshold=frameRelaySessSwitchThreshold, sdlcPuConfigLineIndex=sdlcPuConfigLineIndex, puStatusIgnored=puStatusIgnored, bisyncCRCErrors=bisyncCRCErrors, frameRelaySampleDuration=frameRelaySampleDuration, dsucsudeviceConfigEntry=dsucsudeviceConfigEntry, bisyncOverruns=bisyncOverruns, alcPuDeviceFaults=alcPuDeviceFaults, sdlcPuConfigTable=sdlcPuConfigTable, syncQN4R5bu=syncQN4R5bu, slipPortSpeed=slipPortSpeed, x25IPAddress=x25IPAddress, mappingPuConfigAddress=mappingPuConfigAddress, localNumberPlan=localNumberPlan, x25DataOutChrs=x25DataOutChrs, t7ConfigEntry=t7ConfigEntry, brFilterIPX=brFilterIPX, x25InitState=x25InitState, sdlcOutFrames=sdlcOutFrames, sdlcPuOutUIFrames=sdlcPuOutUIFrames, internalRingNumber3=internalRingNumber3, netviewSpecialConnect=netviewSpecialConnect, x25TransmitPacketSize=x25TransmitPacketSize, asyncDSR=asyncDSR, mappingPuDestinationMAC=mappingPuDestinationMAC, patchId=patchId, syncBC3R5=syncBC3R5, syncCN3R4du=syncCN3R4du, oemSNACMIM2=oemSNACMIM2, isdndeviceConfigEntry=isdndeviceConfigEntry, measurementPeriod=measurementPeriod, brLLC2Priority=brLLC2Priority, sdlcSlowPollTimer=sdlcSlowPollTimer, bisyncrjeInTrns=bisyncrjeInTrns, romVersion=romVersion, secIPHelperAddress=secIPHelperAddress, t7RcvCharsOverruns=t7RcvCharsOverruns, lineBisyncGroup=lineBisyncGroup, bisyncrjeRvi=bisyncrjeRvi, syncCN4R4du=syncCN4R4du, t7PortIPAddress=t7PortIPAddress, x25NPS=x25NPS, oem22185BF5=oem22185BF5, mappingPuDestinationSAP=mappingPuDestinationSAP, lineSDLCGroup=lineSDLCGroup, syncFN2R2b=syncFN2R2b, syncBF3R5b=syncBF3R5b, cpuIdleSumCounts=cpuIdleSumCounts, frameRelayConfigEntry=frameRelayConfigEntry, maxDevice=maxDevice, isdndeviceConfigTable=isdndeviceConfigTable, asyncConfigPortIndex=asyncConfigPortIndex, alcPuConnectionID=alcPuConnectionID, alcPollTx=alcPollTx, deviceControlGroup=deviceControlGroup, dialbackupConfigPortIndex=dialbackupConfigPortIndex, t7RcvFramingErrors=t7RcvFramingErrors, frExtCircuitTable=frExtCircuitTable, brForwardOther=brForwardOther, bridgeConfigGroup=bridgeConfigGroup, internalMacAddress2=internalMacAddress2, x25PuSourceAddress=x25PuSourceAddress, t7StatsGroup=t7StatsGroup, frameRelayRTS=frameRelayRTS, bisyncrjeOutEtx=bisyncrjeOutEtx, deviceALCGroup=deviceALCGroup, alcStatsPortIndex=alcStatsPortIndex, frameRelayPortType=frameRelayPortType, sdlcPuInUIFrames=sdlcPuInUIFrames, mappingPuPartnerLastClearCode=mappingPuPartnerLastClearCode, bisyncInOctets=bisyncInOctets, x25HighTwoWayChannel=x25HighTwoWayChannel, sessDownOnAlternateMAC=sessDownOnAlternateMAC, oem2490R22F=oem2490R22F, puCurrentMAC=puCurrentMAC, frameRelayStatsEntry=frameRelayStatsEntry, syncResearchAgent=syncResearchAgent, x25Timeouts=x25Timeouts, farEndNumberPlan=farEndNumberPlan, syncFN3R5du=syncFN3R5du, nodeNetViewPUGroup=nodeNetViewPUGroup, asyncStatsPortIndex=asyncStatsPortIndex, bisyncClocking=bisyncClocking, asyncInMsgDiscarded=asyncInMsgDiscarded, isdnCRCErrors=isdnCRCErrors, lanPuConfigAddress=lanPuConfigAddress, commIPAddr=commIPAddr, x25OutResets=x25OutResets, bisyncrjePuConfigTable=bisyncrjePuConfigTable, mappingPuConfigTable=mappingPuConfigTable, sdlcDTR=sdlcDTR, netviewConnectionAttemptCount=netviewConnectionAttemptCount, dsucsuloopbackbytesReceived=dsucsuloopbackbytesReceived, brOtherPriority=brOtherPriority, ipxStatsEntry=ipxStatsEntry, lanNetworkMask=lanNetworkMask, x25UseCallingAddress=x25UseCallingAddress, slipRcvParityErrors=slipRcvParityErrors, sessDownOnPrimaryMAC=sessDownOnPrimaryMAC, bisyncrjeInChrs=bisyncrjeInChrs, syncQN4R2c=syncQN4R2c, oem22185FR5=oem22185FR5, sdlcInOctets=sdlcInOctets, isdndeviceStatsTable=isdndeviceStatsTable, frameRelayTxDe=frameRelayTxDe, lineSwitchedConnection=lineSwitchedConnection, slipRcvFifoOverruns=slipRcvFifoOverruns, syncQN4R2b=syncQN4R2b, bisyncPuConfigAddress=bisyncPuConfigAddress, puLastSVCCleared=puLastSVCCleared, brLLC2targetDLCI=brLLC2targetDLCI)
mibBuilder.exportSymbols("SYNC-RESEARCH-MIB", lanStatusAcknowledged=lanStatusAcknowledged, asyncReturnClock=asyncReturnClock, dsucsuControlGroup=dsucsuControlGroup, syncBF5R5b=syncBF5R5b, puControlGroup=puControlGroup, syncBC4R5=syncBC4R5, lanEthernetFrameFormat=lanEthernetFrameFormat, sdlcPuOutXIDFrames=sdlcPuOutXIDFrames, bisyncrjeOutRetr=bisyncrjeOutRetr, sdlcConfigType=sdlcConfigType, lanMaxRetries=lanMaxRetries, oem22183FR5=oem22183FR5, dsucsudeviceConfigTable=dsucsudeviceConfigTable, sdlcPuInFRMRFrames=sdlcPuInFRMRFrames, alcPuStatsAddress=alcPuStatsAddress, syncFN4R4du=syncFN4R4du, priIPHelperAddress=priIPHelperAddress, ipxRipRcvdFwdInterval=ipxRipRcvdFwdInterval, slipRcvMsgErrors=slipRcvMsgErrors, frameRelayCRCErrors=frameRelayCRCErrors, sessSwitchedToPrimaryDLCI=sessSwitchedToPrimaryDLCI, brIPtargetPort=brIPtargetPort, productType=productType, frameRelayCTS=frameRelayCTS, sdlcCarrier=sdlcCarrier, bisyncConfigTable=bisyncConfigTable, lineControlType=lineControlType, x25ConfigEntry=x25ConfigEntry, deviceConfigAddress=deviceConfigAddress, alcPuCSS=alcPuCSS, puStatusChanged=puStatusChanged, alcPuSegXmit=alcPuSegXmit, lanStatusIgnored=lanStatusIgnored, asyncInMessages=asyncInMessages, farEndNumberType=farEndNumberType, x25FRMROutFrames=x25FRMROutFrames, bisyncrjeCodeSet=bisyncrjeCodeSet, linePhysicalGroup=linePhysicalGroup, ipConfigGroup=ipConfigGroup, sdlcNAUName=sdlcNAUName, asyncRcvFifoOverruns=asyncRcvFifoOverruns, sdlcPortType=sdlcPortType, x25SigOutPkts=x25SigOutPkts, asyncParity=asyncParity, bisyncrjeInEtb=bisyncrjeInEtb, linePhysicalType=linePhysicalType, slipConfigEntry=slipConfigEntry, dialbackupDedicatedPort=dialbackupDedicatedPort, x25QInPkts=x25QInPkts, x25DefaultGatewayAddress=x25DefaultGatewayAddress, frameRelayDedLineWaitTimer=frameRelayDedLineWaitTimer, sdlcPuInDMFrames=sdlcPuInDMFrames, t7RxForwardingCount=t7RxForwardingCount, oem22183CR5=oem22183CR5)

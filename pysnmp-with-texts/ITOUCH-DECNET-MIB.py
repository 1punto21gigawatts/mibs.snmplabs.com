#
# PySNMP MIB module ITOUCH-DECNET-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ITOUCH-DECNET-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:57:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
DateTime, iTouch = mibBuilder.importSymbols("ITOUCH-MIB", "DateTime", "iTouch")
PhivAddr, = mibBuilder.importSymbols("RFC1289-phivMIB", "PhivAddr")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, iso, ModuleIdentity, Bits, Gauge32, ObjectIdentity, Unsigned32, TimeTicks, MibIdentifier, IpAddress, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "iso", "ModuleIdentity", "Bits", "Gauge32", "ObjectIdentity", "Unsigned32", "TimeTicks", "MibIdentifier", "IpAddress", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xDecnet = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14))
xRcp = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 1))
xPhiv = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2))
xPhivRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 1))
xPhivCircuit = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 2))
xPhivImport = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 3))
xPhivImportArea = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 4))
xPhivExport = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 5))
xPhivExportArea = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 6))
xPhivFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 7))
xPhivTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 14, 2, 8))
rcpRemoteAddress = MibScalar((1, 3, 6, 1, 4, 1, 33, 14, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcpRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rcpRemoteAddress.setDescription('If a remote console session exists, the Ethernet address of the remote partner, otherwise zero length.')
phivPathSelection = MibScalar((1, 3, 6, 1, 4, 1, 33, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("roundRobin", 1), ("samePath", 2))).clone('roundRobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivPathSelection.setStatus('mandatory')
if mibBuilder.loadTexts: phivPathSelection.setDescription("The algorithm used to balance traffic between equal next hop paths. 'roundRobin' selects the next hop using a round robin algorithm for each hop. 'samePath' selects the next hop guaranteeing that all packets with the same source/destination pair will always use the same next hop.")
phivMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 33, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivMaxPaths.setStatus('mandatory')
if mibBuilder.loadTexts: phivMaxPaths.setDescription('The maximum number of equal cost next hops that the router can remember and successfully load balance between.')
phivStatus = MibScalar((1, 3, 6, 1, 4, 1, 33, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("active", 1), ("disabled", 2), ("noAddressSpecified", 3), ("noInterfacesEnabled", 4), ("badCost", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivStatus.setDescription('The status of the DECnet routing software.')
phivCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1), )
if mibBuilder.loadTexts: phivCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitTable.setDescription('A list of DECnet circuit entries.')
phivCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "xPhivCircuitIndex"))
if mibBuilder.loadTexts: phivCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitEntry.setDescription('Parameter values for a DECnet circuit.')
xPhivCircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPhivCircuitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPhivCircuitIndex.setDescription('Identification of a circuit entry. Same as an interface index (ifIndex).')
phivCircuitRoutingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitRoutingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitRoutingTimer.setDescription('The maximum time in seconds allowed between Routing updates on the circuit. Different values for LANs vs. WANs.')
phivCircuitOperCost = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitOperCost.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitOperCost.setDescription('The actual cost associated with the circuit.')
phivCircuitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitErrors.setDescription('The number of routed DECnet packets received in error on this circuit.')
phivCircuitLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noError", 1), ("addressOutOfRange", 2), ("ageExceeded", 3), ("destinationUnreachable", 4), ("packetFormatError", 5), ("packetOversized", 6), ("partialRoutingUpdate", 7), ("verificationReject", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitLastError.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitLastError.setDescription('The error of the last routed DECnet packet received in error on this circuit.')
phivCircuitLastErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 6), DateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitLastErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitLastErrorTime.setDescription('The date and time that the last routed DECnet packet was received in error on this circuit.')
phivCircuitLastErrorData = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitLastErrorData.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitLastErrorData.setDescription('The first 22 bytes of the last routed DECnet packet received in error on this circuit.')
phivCircuitProtocolPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5))).clone(namedValues=NamedValues(("low", 1), ("medium", 3), ("high", 5))).clone('medium')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitProtocolPriority.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitProtocolPriority.setDescription('The priority at which all DECnet routed packets will be placed on the WAN output queue.')
phivCircuitRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitRoutingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitRoutingPriority.setDescription("Router's priority to be designated router on this circuit.")
phivCircuitImportTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1), )
if mibBuilder.loadTexts: phivCircuitImportTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportTable.setDescription('A list of circuit import filter entries.')
phivCircuitImportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivCircuitImportIf"), (0, "ITOUCH-DECNET-MIB", "phivCircuitImportAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitImportMask"))
if mibBuilder.loadTexts: phivCircuitImportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportEntry.setDescription('Parameter values for an import filter.')
phivCircuitImportIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportIf.setDescription('The interface associated with the import routing filter.')
phivCircuitImportAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1, 2), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAddr.setDescription('The address (node or area) to match against learned route entries to decide whether to import the entry to the routing database.')
phivCircuitImportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportMask.setDescription('The mask which is ANDed with the address field as well as the route entries address to determine whether the address matches the route entry.')
phivCircuitImportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitImportAction.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAction.setDescription('The action to take if the address field along with the mask field matches the route entry.')
phivCircuitImportStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitImportStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportStatus.setDescription("Setting to 'invalid' removes this import filter from the table. Setting to 'valid' has no effect.")
phivCircuitImportAreaTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1), )
if mibBuilder.loadTexts: phivCircuitImportAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaTable.setDescription('A list of circuit import area filter entries.')
phivCircuitImportAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivCircuitImportAreaIf"), (0, "ITOUCH-DECNET-MIB", "phivCircuitImportAreaAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitImportAreaMask"))
if mibBuilder.loadTexts: phivCircuitImportAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaEntry.setDescription('Parameter values for an import area filter.')
phivCircuitImportAreaIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportAreaIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaIf.setDescription('The interface associated with the import area routing filter.')
phivCircuitImportAreaAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1, 2), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportAreaAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaAddr.setDescription('The address (node or area) to match against learned route entries to decide whether to import the entry to the routing database.')
phivCircuitImportAreaMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitImportAreaMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaMask.setDescription('The mask which is ANDed with the address field as well as the route entries address to determine whether the address matches the route entry.')
phivCircuitImportAreaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitImportAreaAction.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaAction.setDescription('The action to take if the address field along with the mask field matches the route entry.')
phivCircuitImportAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitImportAreaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitImportAreaStatus.setDescription("Setting to 'invalid' removes this import area filter from the table. Setting to 'valid' has no effect.")
phivCircuitExportTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1), )
if mibBuilder.loadTexts: phivCircuitExportTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportTable.setDescription('A list of circuit export filter entries.')
phivCircuitExportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivCircuitExportIf"), (0, "ITOUCH-DECNET-MIB", "phivCircuitExportAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitExportMask"))
if mibBuilder.loadTexts: phivCircuitExportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportEntry.setDescription('Parameter values for an export filter.')
phivCircuitExportIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportIf.setDescription('The interface associated with the export routing filter.')
phivCircuitExportAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1, 2), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAddr.setDescription('The address (node or area) to match against learned route entries to decide whether to export the entry to the routing database.')
phivCircuitExportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportMask.setDescription('The mask which is ANDed with the address field as well as the route entries address to determine whether the address matches the route entry.')
phivCircuitExportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hide", 1), ("advertise", 2))).clone('advertise')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitExportAction.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAction.setDescription('The action to take if the address field along with the mask field matches the route entry.')
phivCircuitExportStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitExportStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportStatus.setDescription("Setting to 'invalid' removes this export filter from the table. Setting to 'valid' has no effect.")
phivCircuitExportAreaTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1), )
if mibBuilder.loadTexts: phivCircuitExportAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaTable.setDescription('A list of circuit export area filter entries.')
phivCircuitExportAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivCircuitExportAreaIf"), (0, "ITOUCH-DECNET-MIB", "phivCircuitExportAreaAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitExportAreaMask"))
if mibBuilder.loadTexts: phivCircuitExportAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaEntry.setDescription('Parameter values for an export area filter.')
phivCircuitExportAreaIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportAreaIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaIf.setDescription('The interface associated with the export area routing filter.')
phivCircuitExportAreaAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1, 2), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportAreaAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaAddr.setDescription('The address (node or area) to match against learned route entries to decide whether to export the entry to the routing database.')
phivCircuitExportAreaMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitExportAreaMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaMask.setDescription('The mask which is ANDed with the address field as well as the route entries address to determine whether the address matches the route entry.')
phivCircuitExportAreaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hide", 1), ("advertise", 2))).clone('advertise')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitExportAreaAction.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaAction.setDescription('The action to take if the address field along with the mask field matches the route entry.')
phivCircuitExportAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitExportAreaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitExportAreaStatus.setDescription("Setting to 'invalid' removes this export area filter from the table. Setting to 'valid' has no effect.")
phivCircuitFilterTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1), )
if mibBuilder.loadTexts: phivCircuitFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterTable.setDescription('A list of circuit filter entries.')
phivCircuitFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivCircuitFilterIf"), (0, "ITOUCH-DECNET-MIB", "phivCircuitFilterDstAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitFilterDstMask"), (0, "ITOUCH-DECNET-MIB", "phivCircuitFilterSrcAddr"), (0, "ITOUCH-DECNET-MIB", "phivCircuitFilterSrcMask"))
if mibBuilder.loadTexts: phivCircuitFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterEntry.setDescription('Parameter values for a filter.')
phivCircuitFilterIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitFilterIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterIf.setDescription('The interface associated with the filter entry.')
phivCircuitFilterDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 2), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitFilterDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterDstAddr.setDescription('The address (node or area) to match against the destination address of the packet to decide whether to forward the packet.')
phivCircuitFilterDstMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitFilterDstMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterDstMask.setDescription("The mask which is ANDed with the destination address field and the packet's destination address to determine whether the address matches the packet's address.")
phivCircuitFilterSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 4), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitFilterSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterSrcAddr.setDescription('The address (node or area) to match against the source address of the packet to decide whether to forward the packet.')
phivCircuitFilterSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 5), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivCircuitFilterSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterSrcMask.setDescription("The mask which is ANDed with the source address field and the packet's source address to determine whether the address matches the packet's address.")
phivCircuitFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("forward", 2))).clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitFilterAction.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterAction.setDescription('The action to take if the address fields along with the mask fields match the packet.')
phivCircuitFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivCircuitFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phivCircuitFilterStatus.setDescription("Setting to 'invalid' removes this Filter filter from the table. Setting to 'valid' has no effect.")
phivTrafficSort = MibScalar((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phivTrafficSort.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficSort.setDescription("Setting to 'execute' causes the most recent traffic information to be sorted into the phivTrafficTable. The sorting precedence is: decreasing percentage, increasing destination address, increasing source address, and increasing interface number. Setting to 'ready' has no effect.")
phivTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2), )
if mibBuilder.loadTexts: phivTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficTable.setDescription('A list of traffic entries, sorted in the order specified by phivTrafficSort.')
phivTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1), ).setIndexNames((0, "ITOUCH-DECNET-MIB", "phivTrafficIndex"))
if mibBuilder.loadTexts: phivTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficEntry.setDescription('A traffic entry.')
phivTrafficIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivTrafficIndex.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficIndex.setDescription('Identification of this traffic entry.')
phivTrafficPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivTrafficPercent.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficPercent.setDescription('The percentage of total traffic that this traffic entry represents, in tenths of a percent.')
phivTrafficDst = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1, 3), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivTrafficDst.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficDst.setDescription('The destination to which the traffic entry applies.')
phivTrafficSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1, 4), PhivAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivTrafficSrc.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficSrc.setDescription('The source to which the traffic entry applies.')
phivTrafficIf = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 14, 2, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phivTrafficIf.setStatus('mandatory')
if mibBuilder.loadTexts: phivTrafficIf.setDescription('The inbound interface to which the traffic entry applies. This value is the same as IfIndex.')
mibBuilder.exportSymbols("ITOUCH-DECNET-MIB", xPhiv=xPhiv, phivCircuitExportTable=phivCircuitExportTable, phivCircuitExportEntry=phivCircuitExportEntry, phivCircuitFilterSrcMask=phivCircuitFilterSrcMask, phivCircuitExportAreaStatus=phivCircuitExportAreaStatus, phivCircuitLastError=phivCircuitLastError, phivCircuitImportAreaAction=phivCircuitImportAreaAction, xPhivCircuit=xPhivCircuit, phivCircuitFilterStatus=phivCircuitFilterStatus, phivCircuitImportAreaMask=phivCircuitImportAreaMask, phivCircuitExportMask=phivCircuitExportMask, phivCircuitRoutingPriority=phivCircuitRoutingPriority, phivCircuitExportAreaAddr=phivCircuitExportAreaAddr, phivCircuitImportIf=phivCircuitImportIf, phivCircuitImportAreaIf=phivCircuitImportAreaIf, phivCircuitExportAreaMask=phivCircuitExportAreaMask, phivCircuitImportTable=phivCircuitImportTable, xPhivExportArea=xPhivExportArea, phivCircuitExportAreaTable=phivCircuitExportAreaTable, phivTrafficIndex=phivTrafficIndex, phivCircuitExportAreaAction=phivCircuitExportAreaAction, xDecnet=xDecnet, phivCircuitEntry=phivCircuitEntry, xRcp=xRcp, xPhivRoute=xPhivRoute, phivCircuitProtocolPriority=phivCircuitProtocolPriority, phivCircuitImportMask=phivCircuitImportMask, phivCircuitExportAction=phivCircuitExportAction, phivCircuitFilterIf=phivCircuitFilterIf, xPhivTraffic=xPhivTraffic, phivTrafficPercent=phivTrafficPercent, phivCircuitLastErrorTime=phivCircuitLastErrorTime, phivTrafficSort=phivTrafficSort, phivCircuitErrors=phivCircuitErrors, phivCircuitImportAreaEntry=phivCircuitImportAreaEntry, phivCircuitOperCost=phivCircuitOperCost, phivCircuitExportAreaIf=phivCircuitExportAreaIf, phivCircuitImportAreaAddr=phivCircuitImportAreaAddr, phivCircuitFilterDstAddr=phivCircuitFilterDstAddr, rcpRemoteAddress=rcpRemoteAddress, phivTrafficIf=phivTrafficIf, phivMaxPaths=phivMaxPaths, phivTrafficTable=phivTrafficTable, phivPathSelection=phivPathSelection, phivTrafficDst=phivTrafficDst, phivCircuitImportAddr=phivCircuitImportAddr, phivCircuitImportAreaTable=phivCircuitImportAreaTable, phivCircuitExportIf=phivCircuitExportIf, phivCircuitLastErrorData=phivCircuitLastErrorData, phivCircuitImportStatus=phivCircuitImportStatus, phivCircuitFilterEntry=phivCircuitFilterEntry, phivCircuitImportAreaStatus=phivCircuitImportAreaStatus, phivTrafficSrc=phivTrafficSrc, xPhivExport=xPhivExport, phivCircuitFilterTable=phivCircuitFilterTable, xPhivCircuitIndex=xPhivCircuitIndex, phivCircuitExportStatus=phivCircuitExportStatus, phivCircuitImportEntry=phivCircuitImportEntry, phivCircuitFilterAction=phivCircuitFilterAction, phivTrafficEntry=phivTrafficEntry, phivCircuitExportAreaEntry=phivCircuitExportAreaEntry, xPhivImport=xPhivImport, xPhivFilter=xPhivFilter, phivCircuitFilterDstMask=phivCircuitFilterDstMask, phivCircuitImportAction=phivCircuitImportAction, phivCircuitExportAddr=phivCircuitExportAddr, xPhivImportArea=xPhivImportArea, phivCircuitFilterSrcAddr=phivCircuitFilterSrcAddr, phivCircuitRoutingTimer=phivCircuitRoutingTimer, phivCircuitTable=phivCircuitTable, phivStatus=phivStatus)

#
# PySNMP MIB module GDCDATX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCDATX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, Unsigned32, Bits, NotificationType, ObjectIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, MibIdentifier, enterprises, Gauge32, ModuleIdentity, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "Bits", "NotificationType", "ObjectIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "MibIdentifier", "enterprises", "Gauge32", "ModuleIdentity", "Integer32", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
datx = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7))
datxSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1))
dtx2011 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2))
datxVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1, 1))
datxMaintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1, 2))
datxConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1, 3))
datxDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1, 4))
datxStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 1, 5))
datxMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 7, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: datxMIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
datxMaintTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1), )
if mibBuilder.loadTexts: datxMaintTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxMaintTable.setDescription('This table describes the maintenance objects for the unit ')
datxMaintEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxMaintIndex"))
if mibBuilder.loadTexts: datxMaintEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxMaintEntry.setDescription('An entry in the GDC Datx Maintenance Table.')
datxMaintIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxMaintIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxMaintIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: datxFirmwareRev.setDescription('The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. Test versions are numerical from 01 to 99.')
datxDefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("factoryDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxDefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: datxDefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(2) the unit will perform a reset to make the default configuration take affect. The value of normal(1) will be returned when the initialization is complete.')
datxFrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxFrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: datxFrontPanel.setDescription("This variable is used to indicate whether the front panel switches are operational or not. 'inhibit' refers to when the front panel switches are not operational. 'enable' refers to when the front panel switches are operational.")
datxLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxLedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - RD bit 4 - SD bit 3 - CS bit 2 - CO bit 1 - ALM bit 0 - TM Octet 2 bit 7 - not used bit 6 - ST bit 5 - LL bit 4 - RDL bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - future use')
datxTransConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1), )
if mibBuilder.loadTexts: datxTransConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxTransConfigTable.setDescription('This table describes the DATX transmission mode configuration options')
datxTransConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxTransConfigIndex"))
if mibBuilder.loadTexts: datxTransConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxTransConfigEntry.setDescription('An entry in the transmission configuration table')
datxTransConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxTransConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxTransConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("asynchronous", 1), ("synchronous1200", 2), ("synchronous2400", 3), ("synchronous4800", 4), ("synchronous7200", 5), ("synchronous9600", 6), ("synchronous14400", 7), ("synchronous19200", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: datxBaudRate.setDescription('SYNC/ASYNC Mode operation and Baud Rates')
datxSyncTxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("slave", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxSyncTxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: datxSyncTxClockSource.setDescription('Synchronous Tx Clock Configuration')
datxEiaSyncClock = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxEiaSyncClock.setStatus('mandatory')
if mibBuilder.loadTexts: datxEiaSyncClock.setDescription('Control for the EIA sync clock')
datxEiaConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2), )
if mibBuilder.loadTexts: datxEiaConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxEiaConfigTable.setDescription('DATX EIA line configuration options')
datxEiaConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxEIAIndex"))
if mibBuilder.loadTexts: datxEiaConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxEiaConfigEntry.setDescription('An entry in the EIA config table')
datxEIAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxEIAIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxEIAIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxCarrierControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtr", 1), ("rts", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxCarrierControl.setStatus('mandatory')
if mibBuilder.loadTexts: datxCarrierControl.setDescription('')
datxRtsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("real", 1), ("forced", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxRtsMode.setStatus('mandatory')
if mibBuilder.loadTexts: datxRtsMode.setDescription('RTS mode selection')
datxRtsCtsDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t8mSec", 1), ("t75mSec", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxRtsCtsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: datxRtsCtsDelay.setDescription('RTS/CTS Delay time')
datxEiaRdlControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxEiaRdlControl.setStatus('mandatory')
if mibBuilder.loadTexts: datxEiaRdlControl.setDescription('EIA RDL control selection')
datxDsrInAl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxDsrInAl.setStatus('mandatory')
if mibBuilder.loadTexts: datxDsrInAl.setDescription('Selection for providing DSR will in AL mode')
datxEiaAlControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxEiaAlControl.setStatus('mandatory')
if mibBuilder.loadTexts: datxEiaAlControl.setDescription('EIA AL control')
datxMiscConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3), )
if mibBuilder.loadTexts: datxMiscConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxMiscConfigTable.setDescription('DATX misc configuration options')
datxMiscConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxMiscIndex"))
if mibBuilder.loadTexts: datxMiscConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxMiscConfigEntry.setDescription('An entry in the misc config table')
datxMiscIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxMiscIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxMiscIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxSystemStatusOption = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxSystemStatusOption.setStatus('mandatory')
if mibBuilder.loadTexts: datxSystemStatusOption.setDescription('Causes to drop CTS in master mode when remote drops line')
datxDualSignalingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("time3Sec", 2), ("time1Sec", 3), ("immediate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxDualSignalingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: datxDualSignalingTimer.setDescription('')
datxRegenCharLength = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bits8", 1), ("bits9", 2), ("bits10", 3), ("bits11", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxRegenCharLength.setStatus('mandatory')
if mibBuilder.loadTexts: datxRegenCharLength.setDescription('Synchronous Tx Clock Configuration')
datxRegenMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxRegenMode.setStatus('mandatory')
if mibBuilder.loadTexts: datxRegenMode.setDescription('Regen Mode Control')
datxAsyncRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("async4800", 1), ("async7200", 2), ("async9600", 3), ("async14400", 4), ("async19200", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxAsyncRate.setStatus('mandatory')
if mibBuilder.loadTexts: datxAsyncRate.setDescription('')
datxDiagnosticsTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1), )
if mibBuilder.loadTexts: datxDiagnosticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxDiagnosticsTable.setDescription('DATX diagnostics options')
datxDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxDiagnosticsIndex"))
if mibBuilder.loadTexts: datxDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxDiagEntry.setDescription('List of Diagnostic Tests and Status Indicators related to the tests')
datxDiagnosticsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxDiagnosticsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxDiagnosticsIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxDiagTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noTest", 1), ("selfTest", 2), ("analoop", 3), ("analoopSelfTest", 4), ("remoteDL", 5), ("remoteDLselfTest", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: datxDiagTest.setStatus('mandatory')
if mibBuilder.loadTexts: datxDiagTest.setDescription('Perform diagnostic tests on a unit noTest - stops any test in progress selfTest - sends a selftest pattern analoop - puts the unit into analog loopback analoopSelfTest - puts the unit into analog loopback with a self test pattern remoteDL - performs a remote digital loopback remoteDLselfTest - performs a remote digital loopback with a self test pattern')
datxTestError = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noError", 1), ("testError", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxTestError.setStatus('mandatory')
if mibBuilder.loadTexts: datxTestError.setDescription('Test result indicator, shows the results of the last test')
datxTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 4, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: datxTestDuration.setDescription('Indicates the time duration of any test in progress')
datxStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1), )
if mibBuilder.loadTexts: datxStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: datxStatusTable.setDescription('DATX Status indicators')
datxStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1), ).setIndexNames((0, "GDCDATX-MIB", "datxStatusIndex"))
if mibBuilder.loadTexts: datxStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: datxStatusEntry.setDescription('Entry in the status indicator table')
datxStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: datxStatusIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a slot, line, drop, and sub-identifier.')
datxDTRstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxDTRstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxDTRstatus.setDescription('DTR EIA status indicator ')
datxRDLstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxRDLstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxRDLstatus.setDescription('RDL EIA control status indicator')
datxCOstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxCOstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxCOstatus.setDescription('CO EIA status indicator ')
datxCTSstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxCTSstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxCTSstatus.setDescription('CTS EIA indicator ')
datxRTSstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxRTSstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxRTSstatus.setDescription('RTS EIA indicator')
datxTMstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxTMstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxTMstatus.setDescription('Test mode EIA indicator')
datxALstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxALstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxALstatus.setDescription('Analoop EIA status indicator ')
datxDSRstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxDSRstatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxDSRstatus.setDescription('DSR EIA status indicator ')
datxRXclock = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxRXclock.setStatus('mandatory')
if mibBuilder.loadTexts: datxRXclock.setDescription('RxClk activity indicator ')
datxTXclock = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxTXclock.setStatus('mandatory')
if mibBuilder.loadTexts: datxTXclock.setDescription('TxClk activity indicator ')
datxEXTclock = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxEXTclock.setStatus('mandatory')
if mibBuilder.loadTexts: datxEXTclock.setDescription('External clock activity indicator ')
datxAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 7, 1, 5, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: datxAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: datxAlarmStatus.setDescription('The current alarms of the unit without the alarm masks.')
dtx2011AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1))
dtx2011NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1, 1))
dtx2011DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1, 2))
dtx2011PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1, 3))
dtx2011DCDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1, 4))
dtx2011NoExtClockAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 7, 2, 1, 5))
mibBuilder.exportSymbols("GDCDATX-MIB", datxSyncTxClockSource=datxSyncTxClockSource, datxCTSstatus=datxCTSstatus, datxMaintEntry=datxMaintEntry, dtx2011DCDLossAlm=dtx2011DCDLossAlm, datxDiagTest=datxDiagTest, datxEIAIndex=datxEIAIndex, datxDTRstatus=datxDTRstatus, datxRegenCharLength=datxRegenCharLength, datxMiscConfigEntry=datxMiscConfigEntry, dtx2011NoExtClockAlm=dtx2011NoExtClockAlm, datxTransConfigTable=datxTransConfigTable, datxStatusTable=datxStatusTable, datxTransConfigIndex=datxTransConfigIndex, datxRDLstatus=datxRDLstatus, datxMIBversion=datxMIBversion, datxTestDuration=datxTestDuration, datxDSRstatus=datxDSRstatus, datxBaudRate=datxBaudRate, datxFirmwareRev=datxFirmwareRev, datxTestError=datxTestError, datxDiagEntry=datxDiagEntry, datxCOstatus=datxCOstatus, datxEXTclock=datxEXTclock, datxSystemStatusOption=datxSystemStatusOption, datxALstatus=datxALstatus, dtx2011=dtx2011, datxVersion=datxVersion, datxAsyncRate=datxAsyncRate, datxTMstatus=datxTMstatus, datxTransConfigEntry=datxTransConfigEntry, datxDualSignalingTimer=datxDualSignalingTimer, datxEiaConfigTable=datxEiaConfigTable, datxEiaSyncClock=datxEiaSyncClock, datxLedStatus=datxLedStatus, datxDefaultInit=datxDefaultInit, datxCarrierControl=datxCarrierControl, datxEiaConfigEntry=datxEiaConfigEntry, datxMaintenance=datxMaintenance, datxEiaRdlControl=datxEiaRdlControl, datxRXclock=datxRXclock, datxEiaAlControl=datxEiaAlControl, datxStatusIndex=datxStatusIndex, datxFrontPanel=datxFrontPanel, datxMiscIndex=datxMiscIndex, datxAlarmStatus=datxAlarmStatus, datxMaintIndex=datxMaintIndex, datx=datx, datxDiagnosticsTable=datxDiagnosticsTable, datxDiagnosticsIndex=datxDiagnosticsIndex, datxRTSstatus=datxRTSstatus, gdc=gdc, dtx2011AlarmData=dtx2011AlarmData, dtx2011PowerUpAlm=dtx2011PowerUpAlm, datxStatusEntry=datxStatusEntry, datxTXclock=datxTXclock, datxMiscConfigTable=datxMiscConfigTable, datxDsrInAl=datxDsrInAl, dtx2011DiagRxErrAlm=dtx2011DiagRxErrAlm, datxMaintTable=datxMaintTable, dtx2011NoResponseAlm=dtx2011NoResponseAlm, datxRegenMode=datxRegenMode, datxSystem=datxSystem, datxStatus=datxStatus, datxRtsCtsDelay=datxRtsCtsDelay, datxConfiguration=datxConfiguration, datxRtsMode=datxRtsMode, datxDiagnostics=datxDiagnostics)

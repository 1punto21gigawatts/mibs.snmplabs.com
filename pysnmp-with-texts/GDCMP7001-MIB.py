#
# PySNMP MIB module GDCMP7001-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCMP7001-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, IpAddress, NotificationType, Counter32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, iso, Gauge32, ObjectIdentity, MibIdentifier, Unsigned32, enterprises, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "IpAddress", "NotificationType", "Counter32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "iso", "Gauge32", "ObjectIdentity", "MibIdentifier", "Unsigned32", "enterprises", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
mp7001System = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10))
mp7001Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 1))
mp7001Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 2))
mp7001Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 3))
mp7001Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 4))
mp7001Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 5))
mp7001AlarmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 6))
mp7001SysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 7))
mp7001MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
mp7001VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2), )
if mibBuilder.loadTexts: mp7001VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001VersionTable.setDescription(' ')
mp7001VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001VersionIndex"))
if mibBuilder.loadTexts: mp7001VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001VersionEntry.setDescription('An entry in the GDC Mp7001System Version Table.')
mp7001VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001VersionIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001FirmwareRev.setDescription('The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ.')
mp7001CardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001CardType.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CardType.setDescription('This variable is used to determine the type of card family installed ex. MP7001.')
mp7001BootRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001BootRev.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001BootRev.setDescription('The version number of the boot firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
mp7001MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1), )
if mibBuilder.loadTexts: mp7001MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001MaintenanceTable.setDescription('The table describes the maintenance objects for MP 7001.')
mp7001MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001MaintenanceLineIndex"))
if mibBuilder.loadTexts: mp7001MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001MaintenanceEntry.setDescription('An entry in the GDC 701 Maintenance Table.')
mp7001MaintenanceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001MaintenanceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001MaintenanceLineIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(2), then the unit performs a soft reset, whose meaning is specific to the type of unit being managed. The value of norm(1) will be returned when the reset is complete. The value of norm(1) can not be set by management.')
mp7001SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count.')
mp7001DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("factoryDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(2) the unit will perform a reset to make the default configuration take affect. The value of normal(1) will be returned when the initialization is complete. The value of normal(1) can not be set by management.')
mp7001ResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001ResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ResetStats.setDescription('Supports the action of soft resetting the mp7001ValidIntervals object. When this object is set to reset(2), then the unit will reset the mp7001ValidIntervals object to zero. The value of norm(1) can not be set by management.')
mp7001LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - INSV bit 4 - RSP bit 3 - TMG bit 2 - future use bit 1 - future use bit 0 - future use Octet 2 bit 7 - not used bit 6 - future use bit 5 - NTWK AIS bit 4 - NTWK LCV bit 3 - NTWK LOS bit 2 - NTWK OOF bit 1 - ALM bit 0 - TM ')
mp7001T1CircuitName = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001T1CircuitName.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001T1CircuitName.setDescription('Circuit name T1 is connected to.')
mp7001SetRealTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001SetRealTime.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SetRealTime.setDescription('Number of seconds from midnight Dec 31, 1969.')
mp7001AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001AlarmStatus.setDescription('Returns a bit-wise Status of alarms Octet 1 bit 7 - not used bit 6 - NTWK LOS bit 5 - NTWK LOF bit 4 - NWTK_AIS bit 3 - future use bit 2 - NTWK Received YELLOW bit 1 - NTWK Excessive Zeros - not supported bit 0 - NTWK Low Average Density - not supported Octet 2 bit 7 - not used bit 6 - NTWK BiPolar Violations bit 5 - NTWK CRC Errors bit 4 - NTWK Controlled Slips bit 3 - Unavailable Signal State bit 2 - Status Change bit 1 - Timing Loss bit 0 - Unit Failure Octet 3 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - future use Octet 4 bit 7 - not used bit 6 - ES bit 5 - BES bit 4 - SES bit 3 - UAS bit 2 - Unsolicited Test bit 1 - NVRAM checksum corrupted bit 0 - Power-up Alarm ')
mp7001SystemTimingGenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clk8khz", 2), ("clk4mhz", 3), ("clk8khzand4mhz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001SystemTimingGenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SystemTimingGenStatus.setDescription('Indicates if the units configured for primary or secondary system clock are actually supplying clock and if it is the 8hkz, 4mhz, or both.')
mp7001StatLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001StatLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001StatLastInitialized.setDescription('Number of seconds from midnight Dec 31, 1969 up until mp7001ValidIntervals was last initialized to zero')
mp7001ValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001ValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
mp7001ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1), )
if mibBuilder.loadTexts: mp7001ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ConfigTable.setDescription('The GDC Configuration table.')
mp7001ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001ConfigIndex"))
if mibBuilder.loadTexts: mp7001ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ConfigEntry.setDescription('The GDC Configuration table entry.')
mp7001ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ConfigIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001NetworkInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("dsx1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001NetworkInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NetworkInterfaceType.setDescription('Sets the transmit range to DSX-1 short or DS-1 long ')
mp7001TransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("recovered", 2), ("internal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001TransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TransmitClockSource.setDescription('Sets the transmit clock source.')
mp7001FallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("recovered", 2), ("internal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001FallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001FallbackClockSource.setDescription('Identifies the fallback transmit clock source.')
mp7001PreEqualization = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("feet130", 2), ("feet260", 3), ("feet390", 4), ("feet530", 5), ("feet655", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001PreEqualization.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001PreEqualization.setDescription('Pre-Equalization distance')
mp7001Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eSF", 1), ("d4", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001Framing.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001Framing.setDescription('Set the framing for the interface. Abbreviations are as follows: eSF - Extended Super Frame d4 - Super Frame')
mp7001LineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("b8zs", 1), ("ami", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001LineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LineCoding.setDescription('Sets the line coding for the interface.')
mp7001LineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dB0", 1), ("dB75", 2), ("dB15", 3), ("dB22", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001LineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LineBuildout.setDescription('Sets the line build out for the interface 0, -7.5, -15 or -22.5dB')
mp7001FDLMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("aNSIT1403", 2), ("tR54016", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001FDLMode.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001FDLMode.setDescription('Sets the Facility Data Link Mode.')
mp7001FramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001FramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001FramingMode.setDescription('Sets the framing mode')
mp7001Loopback = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inhibitloop", 1), ("payloadloop", 2), ("lineloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001Loopback.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001Loopback.setDescription('Sets the loopback type')
mp7001AISLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001AISLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001AISLoopdown.setDescription('Sets AIS unloop time where 4 = inhibit, 5 thru 60 = number of seconds')
mp7001SignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("robbedbit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001SignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SignalMode.setDescription('Sets signalling mode')
mp7001LineBuildoutCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001LineBuildoutCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LineBuildoutCtrl.setDescription('Sets the line buildout control')
mp7001SysTimingTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 1), )
if mibBuilder.loadTexts: mp7001SysTimingTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SysTimingTable.setDescription('The GDC System Timing table.')
mp7001SysTimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001SysTimingIndex"))
if mibBuilder.loadTexts: mp7001SysTimingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SysTimingEntry.setDescription('The GDC Configuration table entry.')
mp7001SysTimingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001SysTimingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SysTimingIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001SysTimingGen = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001SysTimingGen.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SysTimingGen.setDescription('Selects if the unit provides system timing. none(1) - does not provide Timing Generator primary(2) - unit is primary Timing Generator for the shelf. secondary(3) - unit is secondary Timing Generator for the shelf. Only 1 unit in the shelf can the primary or secondary timing generator. All other must be none.')
mp7001DCCConfigurationTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 2), )
if mibBuilder.loadTexts: mp7001DCCConfigurationTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DCCConfigurationTable.setDescription('The GDC DCC Configuration table. These are Diagnostic Channel configuration options.')
mp7001DCCConfigurationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 2, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001DCCConfigurationIndex"))
if mibBuilder.loadTexts: mp7001DCCConfigurationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DCCConfigurationEntry.setDescription('The GDC Diagnostic Configuration table entry.')
mp7001DCCConfigurationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001DCCConfigurationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DCCConfigurationIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001TimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001TimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TimeSlot.setDescription('Time Slot DCC goes in')
mp7001Bandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("kbps8", 1), ("kbps56", 2), ("kbps64", 3), ("notAssigned", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001Bandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001Bandwidth.setDescription('Bandwidth to use: 8 kbps - bit 7 only 56 kbps - bits 0 - 6 64 kbps - all 8 bits')
mp7001HighwayAssignTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2), )
if mibBuilder.loadTexts: mp7001HighwayAssignTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001HighwayAssignTable.setDescription('The GDC Highway/Timeslot Assignment Table.')
mp7001HighwayAssignEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001HighwayAssignIndex"))
if mibBuilder.loadTexts: mp7001HighwayAssignEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001HighwayAssignEntry.setDescription('The GDC T1 Highway Assign table entry.')
mp7001HighwayAssignIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001HighwayAssignIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001HighwayAssignIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001StartTimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001StartTimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001StartTimeSlot.setDescription('Starting time slot of the bundle. If only 1 bundle is being assigned, or the first of 2 is being assigned, it must start at 1. The second of 2 must start at the next available time slot after the first bundle.')
mp7001NumberOfTimeSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001NumberOfTimeSlots.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NumberOfTimeSlots.setDescription('Number of time slots assigned to the bundle.')
mp7001BundleDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notAssigned", 1), ("highway1", 2), ("highway2", 3), ("highway3", 4), ("highway4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001BundleDestination.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001BundleDestination.setDescription('Defines the destination of the bundle.')
mp7001ExecuteAssign = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001ExecuteAssign.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ExecuteAssign.setDescription('Causes the MP7001 to execute configuration of the assigned highway configuration. This object should be sent in a separate PDU after acknowlegement of the assign PDU(s) has been received.')
mp7001DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1), )
if mibBuilder.loadTexts: mp7001DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DiagTable.setDescription('The GDC T1 Diagnostics table. Information in the entries of this table support diagnostics testing, both active testing via patterns, and passive testing via loopbacks.')
mp7001DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001DiagIndex"))
if mibBuilder.loadTexts: mp7001DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DiagEntry.setDescription('The GDC T1 Diagnostics table entry.')
mp7001DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DiagIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001TestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noCode", 1), ("pat511", 2), ("pat2047", 3), ("patQRSS", 4), ("pat3in24", 5), ("inbandCode", 6), ("resetInband", 7), ("ntwkInterfaceCode", 8), ("resetNtwkInterface", 9), ("ds0Delay", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001TestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TestPattern.setDescription('Test pattern for tests that use the pattern generator.')
mp7001DiagConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noLoop", 1), ("lineLoopback", 2), ("payloadLoopback", 3), ("dsoLoopback", 4), ("cascadeLoopback", 5), ("localTest", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001DiagConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DiagConfig.setDescription('Selects the test to run. noLoop(1) ends the test.')
mp7001TestLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLimit", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("testTime30Secs", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001TestLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TestLimit.setDescription('Selects the duration to run a diagnostic test. The value(1) noLimit signifies that the test should run indefinitely until explicitly terminated.')
mp7001TestExecutionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("notInTest", 1), ("testInProgress", 2), ("testCompleted", 4), ("testCompletedNotInTest", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001TestExecutionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TestExecutionStatus.setDescription('This variable reports the status of a test. notInTest(1) indicates a test is not running. testInProgress(2) indicates that a test is currently running. testCompleted(4) indicates that a test has run and is completed. testCompletedNotInTest(5) indicates that a test has completed and it is no longer in test.')
mp7001TestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001TestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TestExceptions.setDescription('Indicates exceptions that have occurred that may affect interpretation of the test results. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 1 a timed test was preempted so the result cannot be viewed in relation to the test duration 2 the results overflowed so the result cannot be viewed as an absolute value 4 the test was performed while synchronization could not be performed so the result may not be accurate.')
mp7001TestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048576))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001TestResults.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TestResults.setDescription('The results of the last diagnostic test. This can be the current test running or the last completed test. Note that the interpretation of these results may be affected by the value of the mp7001TestExceptions object.')
mp7001ResetTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001ResetTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ResetTestResults.setDescription('Resets the diagnostic error count.')
mp7001DS0Diag = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001DS0Diag.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001DS0Diag.setDescription('Defines a DS0 level diagnostic. Setting this object value to 0 disables a DS0 level diagnostic. Setting this object to a value from 1 to 32 enables a DS0 level diagnostic on the DS0 indicated. Enabling a DS0 level diagnostic bysetting this object to a value from 1 to 32 alters the meaning of the diagnostic test to be specific to the DS0 specified instead of the whole DS1. Note that a DS0 level diagnostic and a DS1 level diagnostic cannot be performed simultaneously.')
mp7001Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8))
mp7001NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 1))
mp7001DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 2))
mp7001PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 3))
mp7001NvRamCorrupt = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 4))
mp7001UnitFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 5))
mp7001LossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 6))
mp7001LossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 7))
mp7001Ais = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 8))
mp7001YELLOW = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 9))
mp7001BipolarViolation = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 10))
mp7001CRC = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 11))
mp7001UnSigState = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 12))
mp7001TimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 13))
mp7001ES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 14))
mp7001BES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 15))
mp7001SES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 16))
mp7001UAS = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 17))
mp7001ControlSlips = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 18))
mp7001UnsolicitedTest = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 10, 8, 19))
mp7001NearEndAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1), )
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigTable.setDescription('This table contains entries that configure Near End Alarm reporting.')
mp7001NearEndAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001NearEndAlarmConfigIndex"), (0, "GDCMP7001-MIB", "mp7001NearEndAlarmConfigIdentifier"))
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigEntry.setDescription('An entry in the MP7001 Alarm Configuration table.')
mp7001NearEndAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001NearEndAlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
mp7001NearEndAlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last10sec", 3), ("last30sec", 4), ("last1min", 5), ("last15min", 6), ("last1hr", 7), ("last24hr", 8), ("infinite", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001NearEndAlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmCountWindow.setDescription('This variable sets/reads the alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting. Default: disabled(1)')
mp7001NearEndAlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("thresGT1", 1), ("thresGT3", 2), ("thresGT10", 3), ("thresGT100", 4), ("thresGT1000", 5), ("thresGT10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001NearEndAlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001NearEndAlarmCountThreshold.setDescription('This function sets/reads the alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Default: thresGT1(1)')
mp7001LocalAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2), )
if mibBuilder.loadTexts: mp7001LocalAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LocalAlarmConfigTable.setDescription('The mp7001LocalAlarmConfigTable contains entries that configure alarm reporting to the alarm card.')
mp7001LocalAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001LocalAlarmConfigIndex"))
if mibBuilder.loadTexts: mp7001LocalAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LocalAlarmConfigEntry.setDescription('An entry in the GDC Local Alarm Configuration table.')
mp7001LocalAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001LocalAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LocalAlarmConfigIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001LOSLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001LOSLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LOSLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001LOFLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001LOFLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001LOFLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001AISLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001AISLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001AISLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001RxYELLOWLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001RxYELLOWLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001RxYELLOWLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001BPVLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001BPVLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001BPVLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001CRCLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001CRCLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CRCLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001UnSigStateLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001UnSigStateLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001UnSigStateLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001TiminglossLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001TiminglossLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TiminglossLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001ESLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001ESLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001ESLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001BESLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001BESLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001BESLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001SESLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001SESLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001SESLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001UASLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 6, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp7001UASLocal.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001UASLocal.setDescription('Disables or enables the alarm on the Major buss or Minor buss.')
mp7001InboundANSIperfTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1), )
if mibBuilder.loadTexts: mp7001InboundANSIperfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIperfTable.setDescription('The GDC ANSI Performance table. Information in the entries of this table support the ANSI Scheduled Performance Reports. Entries supply information for inbound reports for the last 4 seconds.')
mp7001InboundANSIperfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001InboundANSIperfIndex"), (0, "GDCMP7001-MIB", "mp7001InboundANSIseconds"))
if mibBuilder.loadTexts: mp7001InboundANSIperfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIperfEntry.setDescription('The GDC ANSI Performance table entry. The information in this entry presents one of the 4 second periods performance data in the inbound direction.')
mp7001InboundANSIperfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIperfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIperfIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001InboundANSIseconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIseconds.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIseconds.setDescription('Identifies the reporting interval. This has the value 1 to 4 supporting up to the last 4 seconds of performance data.')
mp7001InboundANSICRCerrorEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("noErrors", 1), ("errors1", 2), ("errors2to5", 4), ("errors6to10", 8), ("errors11to100", 16), ("errors101to320", 32), ("errors321orMore", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSICRCerrorEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSICRCerrorEvents.setDescription('Identifies the magnitude of the error events in the interval which this entry represents.')
mp7001InboundANSIsevereErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIsevereErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIsevereErrors.setDescription('Identifies whether or not any severe errors were detected in the interval which this entry represents.')
mp7001InboundANSIframeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIframeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIframeErrors.setDescription('Identifies whether or not any framing errors were detected in the interval which this entry represents.')
mp7001InboundANSIcodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIcodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIcodeViolations.setDescription('Identifies whether or not any code violations were detected in the interval which this entry represents.')
mp7001InboundANSIcontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIcontrolledSlips.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIcontrolledSlips.setDescription('Identifies whether or not any controlled slips were detected in the interval which this entry represents.')
mp7001InboundANSIactivePayloadLoops = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001InboundANSIactivePayloadLoops.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001InboundANSIactivePayloadLoops.setDescription('Identifies whether or not any active payload loops were detected in the interval which this entry represents.')
mp7001OutboundANSIperfTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2), )
if mibBuilder.loadTexts: mp7001OutboundANSIperfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIperfTable.setDescription('The GDC ANSI Performance table. Information in the entries of this table support the ANSI Scheduled Performance Reports. Entries supply information for outbound reports for the last 4 seconds.')
mp7001OutboundANSIperfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001OutboundANSIperfIndex"), (0, "GDCMP7001-MIB", "mp7001OutboundANSIseconds"))
if mibBuilder.loadTexts: mp7001OutboundANSIperfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIperfEntry.setDescription('The GDC ANSI Performance table entry. The information in this entry presents one of the 4 second periods performance data in the outbound direction.')
mp7001OutboundANSIperfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIperfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIperfIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001OutboundANSIseconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIseconds.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIseconds.setDescription('Identifies the reporting interval. This has the value 1 to 4 supporting up to the last 4 seconds of performance data.')
mp7001OutboundANSICRCerrorEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("noErrors", 1), ("errors1", 2), ("errors2to5", 4), ("errors6to10", 8), ("errors11to100", 16), ("errors101to320", 32), ("errors321orMore", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSICRCerrorEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSICRCerrorEvents.setDescription('Identifies the magnitude of the error events in the interval which this entry represents.')
mp7001OutboundANSIsevereErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIsevereErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIsevereErrors.setDescription('Identifies whether or not any severe errors were detected in the interval which this entry represents.')
mp7001OutboundANSIframeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIframeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIframeErrors.setDescription('Identifies whether or not any framing errors were detected in the interval which this entry represents.')
mp7001OutboundANSIcodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIcodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIcodeViolations.setDescription('Identifies whether or not any code violations were detected in the interval which this entry represents.')
mp7001OutboundANSIcontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIcontrolledSlips.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIcontrolledSlips.setDescription('Identifies whether or not any controlled slips were detected in the interval which this entry represents.')
mp7001OutboundANSIactivePayloadLoops = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001OutboundANSIactivePayloadLoops.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001OutboundANSIactivePayloadLoops.setDescription('Identifies whether or not any active payload loops were detected in the interval which this entry represents.')
mp7001CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 3), )
if mibBuilder.loadTexts: mp7001CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CurrentTable.setDescription('The mp7001 Current table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
mp7001CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 3, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001CurrentIndex"))
if mibBuilder.loadTexts: mp7001CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CurrentEntry.setDescription('An entry in the mp7001 Current table.')
mp7001CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CurrentIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001CurrentStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001CurrentStat.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001CurrentStat.setDescription('Returns a bitwise snapshot of the current statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 1: New Interval Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Bursty Errored Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 12 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 13 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 14 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 15 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Controlled Slip Seconds Octet 16 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 17 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loss of Frame Count')
mp7001IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 4), )
if mibBuilder.loadTexts: mp7001IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001IntervalTable.setDescription('The mp7001 Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
mp7001IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 4, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001IntervalIndex"), (0, "GDCMP7001-MIB", "mp7001IntervalNumber"))
if mibBuilder.loadTexts: mp7001IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001IntervalEntry.setDescription('An entry in the DS1 Interval table.')
mp7001IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001IntervalIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
mp7001IntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001IntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001IntervalStat.setDescription('Returns a bitwise snapshot of the interval statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 2 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 4 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 5 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 6 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 7 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 8 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 9 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Bursty Errored Seconds Octet 10 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 11 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 12 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 13 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 14 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Controlled Slip Seconds Octet 15 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 16 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loss of Frame Count')
mp7001TotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 5), )
if mibBuilder.loadTexts: mp7001TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TotalTable.setDescription('The DS1 Total table. 24 hour interval. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
mp7001TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 5, 1), ).setIndexNames((0, "GDCMP7001-MIB", "mp7001TotalIndex"))
if mibBuilder.loadTexts: mp7001TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TotalEntry.setDescription('An entry in the DS1 Total table.')
mp7001TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TotalIndex.setDescription('Integer value which uniquely identifies the MP7001 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
mp7001TotalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 10, 5, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mp7001TotalStat.setStatus('mandatory')
if mibBuilder.loadTexts: mp7001TotalStat.setDescription('Returns a bitwise snapshot of the total statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 1: New Interval Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Bursty Errored Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^15 bit 0 - 2^14 Octet 12 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 13 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 14 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 15 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Controlled Slip Seconds Octet 16 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - 2^7 Octet 17 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loss of Frame Count')
mibBuilder.exportSymbols("GDCMP7001-MIB", mp7001MaintenanceEntry=mp7001MaintenanceEntry, mp7001PreEqualization=mp7001PreEqualization, mp7001IntervalStat=mp7001IntervalStat, mp7001Performance=mp7001Performance, mp7001AlarmConfig=mp7001AlarmConfig, mp7001Bandwidth=mp7001Bandwidth, mp7001InboundANSICRCerrorEvents=mp7001InboundANSICRCerrorEvents, mp7001IntervalNumber=mp7001IntervalNumber, mp7001LineBuildout=mp7001LineBuildout, mp7001BES=mp7001BES, mp7001BipolarViolation=mp7001BipolarViolation, mp7001LocalAlarmConfigTable=mp7001LocalAlarmConfigTable, mp7001DiagTable=mp7001DiagTable, mp7001TotalEntry=mp7001TotalEntry, mp7001NearEndAlarmCountWindow=mp7001NearEndAlarmCountWindow, mp7001VersionEntry=mp7001VersionEntry, mp7001TimeSlot=mp7001TimeSlot, mp7001HighwayAssignIndex=mp7001HighwayAssignIndex, mp7001InboundANSIframeErrors=mp7001InboundANSIframeErrors, mp7001LedStatus=mp7001LedStatus, mp7001InboundANSIactivePayloadLoops=mp7001InboundANSIactivePayloadLoops, mp7001LossOfSignal=mp7001LossOfSignal, mp7001DiagEntry=mp7001DiagEntry, mp7001SysTimingGen=mp7001SysTimingGen, mp7001ExecuteAssign=mp7001ExecuteAssign, mp7001MaintenanceTable=mp7001MaintenanceTable, mp7001IntervalEntry=mp7001IntervalEntry, mp7001SESLocal=mp7001SESLocal, mp7001TestExecutionStatus=mp7001TestExecutionStatus, mp7001LineCoding=mp7001LineCoding, mp7001DefaultInit=mp7001DefaultInit, mp7001FallbackClockSource=mp7001FallbackClockSource, mp7001LineBuildoutCtrl=mp7001LineBuildoutCtrl, mp7001OutboundANSIcodeViolations=mp7001OutboundANSIcodeViolations, mp7001LocalAlarmConfigEntry=mp7001LocalAlarmConfigEntry, mp7001Ais=mp7001Ais, mp7001NetworkInterfaceType=mp7001NetworkInterfaceType, mp7001UAS=mp7001UAS, mp7001CurrentStat=mp7001CurrentStat, mp7001TransmitClockSource=mp7001TransmitClockSource, mp7001Configuration=mp7001Configuration, mp7001InboundANSIperfIndex=mp7001InboundANSIperfIndex, mp7001NearEndAlarmConfigIdentifier=mp7001NearEndAlarmConfigIdentifier, mp7001HighwayAssignEntry=mp7001HighwayAssignEntry, mp7001InboundANSIperfEntry=mp7001InboundANSIperfEntry, mp7001CurrentIndex=mp7001CurrentIndex, mp7001UnitFailure=mp7001UnitFailure, mp7001TotalIndex=mp7001TotalIndex, mp7001DiagRxErrAlm=mp7001DiagRxErrAlm, mp7001UASLocal=mp7001UASLocal, mp7001System=mp7001System, mp7001AISLoopdown=mp7001AISLoopdown, mp7001SysTimingIndex=mp7001SysTimingIndex, mp7001BundleDestination=mp7001BundleDestination, mp7001NumberOfTimeSlots=mp7001NumberOfTimeSlots, mp7001TestLimit=mp7001TestLimit, mp7001SysUpTime=mp7001SysUpTime, mp7001UnsolicitedTest=mp7001UnsolicitedTest, mp7001OutboundANSIperfEntry=mp7001OutboundANSIperfEntry, mp7001DiagIndex=mp7001DiagIndex, mp7001BootRev=mp7001BootRev, mp7001LossOfFrame=mp7001LossOfFrame, mp7001ES=mp7001ES, mp7001RxYELLOWLocal=mp7001RxYELLOWLocal, mp7001UnSigState=mp7001UnSigState, mp7001TiminglossLocal=mp7001TiminglossLocal, mp7001NearEndAlarmConfigEntry=mp7001NearEndAlarmConfigEntry, mp7001CurrentEntry=mp7001CurrentEntry, mp7001OutboundANSIactivePayloadLoops=mp7001OutboundANSIactivePayloadLoops, mp7001OutboundANSIcontrolledSlips=mp7001OutboundANSIcontrolledSlips, mp7001CurrentTable=mp7001CurrentTable, mp7001BPVLocal=mp7001BPVLocal, mp7001StartTimeSlot=mp7001StartTimeSlot, mp7001UnSigStateLocal=mp7001UnSigStateLocal, mp7001Alarms=mp7001Alarms, mp7001ConfigIndex=mp7001ConfigIndex, mp7001InboundANSIperfTable=mp7001InboundANSIperfTable, mp7001YELLOW=mp7001YELLOW, mp7001MIBversion=mp7001MIBversion, mp7001TestResults=mp7001TestResults, mp7001PowerUpAlm=mp7001PowerUpAlm, mp7001DCCConfigurationEntry=mp7001DCCConfigurationEntry, mp7001ResetTestResults=mp7001ResetTestResults, mp7001T1CircuitName=mp7001T1CircuitName, mp7001SystemTimingGenStatus=mp7001SystemTimingGenStatus, mp7001LOSLocal=mp7001LOSLocal, dsx1=dsx1, mp7001SES=mp7001SES, mp7001DCCConfigurationTable=mp7001DCCConfigurationTable, mp7001InboundANSIcontrolledSlips=mp7001InboundANSIcontrolledSlips, mp7001AlarmStatus=mp7001AlarmStatus, mp7001SoftReset=mp7001SoftReset, mp7001ConfigTable=mp7001ConfigTable, mp7001OutboundANSIseconds=mp7001OutboundANSIseconds, mp7001AISLocal=mp7001AISLocal, mp7001BESLocal=mp7001BESLocal, mp7001NearEndAlarmCountThreshold=mp7001NearEndAlarmCountThreshold, mp7001SysTimingTable=mp7001SysTimingTable, mp7001InboundANSIcodeViolations=mp7001InboundANSIcodeViolations, mp7001NoResponseAlm=mp7001NoResponseAlm, mp7001Maintenance=mp7001Maintenance, mp7001OutboundANSIperfIndex=mp7001OutboundANSIperfIndex, mp7001SysConfig=mp7001SysConfig, mp7001FirmwareRev=mp7001FirmwareRev, mp7001DCCConfigurationIndex=mp7001DCCConfigurationIndex, mp7001NvRamCorrupt=mp7001NvRamCorrupt, mp7001SignalMode=mp7001SignalMode, mp7001DiagConfig=mp7001DiagConfig, mp7001TimingLoss=mp7001TimingLoss, mp7001IntervalIndex=mp7001IntervalIndex, mp7001TestPattern=mp7001TestPattern, mp7001Loopback=mp7001Loopback, mp7001LocalAlarmConfigIndex=mp7001LocalAlarmConfigIndex, mp7001CRC=mp7001CRC, mp7001HighwayAssignTable=mp7001HighwayAssignTable, mp7001TotalStat=mp7001TotalStat, mp7001FDLMode=mp7001FDLMode, mp7001NearEndAlarmConfigIndex=mp7001NearEndAlarmConfigIndex, mp7001TestExceptions=mp7001TestExceptions, mp7001DS0Diag=mp7001DS0Diag, mp7001LOFLocal=mp7001LOFLocal, mp7001StatLastInitialized=mp7001StatLastInitialized, mp7001OutboundANSIperfTable=mp7001OutboundANSIperfTable, mp7001OutboundANSIsevereErrors=mp7001OutboundANSIsevereErrors, mp7001CardType=mp7001CardType, mp7001NearEndAlarmConfigTable=mp7001NearEndAlarmConfigTable, mp7001FramingMode=mp7001FramingMode, mp7001ESLocal=mp7001ESLocal, mp7001IntervalTable=mp7001IntervalTable, mp7001TotalTable=mp7001TotalTable, mp7001SetRealTime=mp7001SetRealTime, mp7001SysTimingEntry=mp7001SysTimingEntry, mp7001Version=mp7001Version, mp7001InboundANSIsevereErrors=mp7001InboundANSIsevereErrors, mp7001OutboundANSIframeErrors=mp7001OutboundANSIframeErrors, gdc=gdc, mp7001ControlSlips=mp7001ControlSlips, mp7001VersionIndex=mp7001VersionIndex, mp7001VersionTable=mp7001VersionTable, mp7001MaintenanceLineIndex=mp7001MaintenanceLineIndex, mp7001ResetStats=mp7001ResetStats, mp7001Framing=mp7001Framing, mp7001CRCLocal=mp7001CRCLocal, mp7001ConfigEntry=mp7001ConfigEntry, mp7001OutboundANSICRCerrorEvents=mp7001OutboundANSICRCerrorEvents, mp7001InboundANSIseconds=mp7001InboundANSIseconds, mp7001ValidIntervals=mp7001ValidIntervals, mp7001Diagnostics=mp7001Diagnostics)

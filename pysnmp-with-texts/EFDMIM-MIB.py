#
# PySNMP MIB module EFDMIM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EFDMIM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:59:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Gauge32, Counter32, Counter64, Unsigned32, ModuleIdentity, TimeTicks, ObjectIdentity, Integer32, MibIdentifier, NotificationType, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Gauge32", "Counter32", "Counter64", "Unsigned32", "ModuleIdentity", "TimeTicks", "ObjectIdentity", "Integer32", "MibIdentifier", "NotificationType", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cabletron = MibIdentifier((1, 3, 6, 1, 4, 1, 52))
commsDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1))
subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6))
nb55 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 4))
rev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1))
efdmimRingTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1), )
if mibBuilder.loadTexts: efdmimRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingTable.setDescription('An ordered list of fddi nodes found on the Fddi Ring.')
efdmimRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1), )
if mibBuilder.loadTexts: efdmimRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingEntry.setDescription('An fddi ring entry containing information common to all stations in a token path. All FDDI ring Entry elements have an instance id made up of an index followed by a canonical FDDI station address. The indexes are ordered sequentially 1 to n, and the corresponding FDDI addresses are ordered in reverse token flow. Consider the following example: --->---[1] 00-00-1D-00-00-04 | | (arrows show token flow) | V | [3] 00-00-1D-00-00-01 | | | V | [2] 00-00-1D-00-00-03 | | ----<----------/ A get_next request with instance id = 0 will return 1.0.0.1D.0.0.4 A get_next request with instance id= 1.0.0.1D.0.0.4 will return 2.0.0.1D.0.0.3 A get_next request with instance id= 2.0.0.1D.0.0.1 will return 3.0.0.1D.0.0.1 ')
efdmimRingUpstreamMac = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingUpstreamMac.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingUpstreamMac.setDescription("This is the 6 octet canonical representation of the upstream neighbor's address. The upstream neighbor is the last MAC to receive the token before this MAC. Please Note: SMT Rev 6.2 and under specify the unknown address as 00-00-00-00-00-00. SMT revisions after 6.2 specify the unknown address as 00-00-F8-00-00-00. ")
efdmimRingNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingNodeClass.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingNodeClass.setDescription('Reports if the node is a station or a concentrator. Legal values are: station (0) concentrator (1) ')
efdmimRingMacs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingMacs.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingMacs.setDescription('The number of MACs on this FDDI node.')
efdmimRingNonMasterPhys = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingNonMasterPhys.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingNonMasterPhys.setDescription('The sum of the all A-Ports, B-Ports, and S-Ports on this node.')
efdmimRingMasterPhys = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingMasterPhys.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingMasterPhys.setDescription('The number of master ports on this node. Results will range from 0 to 255.')
efdmimRingTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingTopology.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingTopology.setDescription("A bit-mapped representation of the current state of the node. if this state: Add 2**n where n= Wrapped Node: 0 Unattached Concentrator: 1 A-A twisted ring: 2 B-B twisted ring: 3 Rooted Station: 4 SRF supported 5 Wrapped Node: set when the node's cf-state is Wrap-A, Wrap-B, Wrap-S, or Wrap- AB. Unattached Concentrator: set when a concentrator has no active A, B, or S ports. A-A Twisted ring: A twisted ring has occurred because this node's A port has been connected to another port. B-B Twisted ring: A twisted ring has occurred because this node's B port has been connected to another B port. Rooted Station: This is a station who's A, B and S ports are NOT active in tree mode. If any A, B, or S ports are active in TREE mode, this is FALSE. SRF supported: This node adheres to the status reporting frame protocol. ")
efdmimRingDuplicate = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingDuplicate.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingDuplicate.setDescription("A bit-mapped representation of duplicate address information. if this state: Add 2**n where n= My Duplicate: 0 UNA Duplicate: 1 My Duplicate: This node has determined that it's MAC address is the same as the MAC address for another node on the ring. UNA Duplicate: The upstream neighbor of this node has determined that it's MAC address is the same as the MAC address for another node on the ring. ")
efdmimRingMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingMacAddress.setDescription('A canonical representation of the MAC address.')
efdmimBdgPortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2), )
if mibBuilder.loadTexts: efdmimBdgPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortTable.setDescription('This is a table of items that relate to bridge ports. Note there are 2 bridge (packet communication) ports on the EFDMIM, the ethernet port, and the FDDI port.')
efdmimBdgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1), )
if mibBuilder.loadTexts: efdmimBdgPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortEntry.setDescription('This is an individual entry in the bridge port table. Note that each entry will contain an instance id of 1 to represent the Ethernet port, and 2 to represent the FDDI port.')
efdmimBdgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortState.setStatus('optional')
if mibBuilder.loadTexts: efdmimBdgPortState.setDescription("This object is returned only if spanning tree is enabled on the bridge. It returns a text string representing the current state of the port: 'Disabled', 'Listening', 'Learning', 'Forwarding', or 'Blocking'.")
efdmimBdgPortReceivedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortReceivedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortReceivedPkts.setDescription('The number of frames received by the bridge through this port.')
efdmimBdgPortFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortFilteredPkts.setDescription('The number of frames filtered by the bridge at this port.')
efdmimBdgPortForwardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortForwardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortForwardedPkts.setDescription('The number of frames forwarded by the bridge through this port.')
efdmimBdgPortTransmittedPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortTransmittedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortTransmittedPkts.setDescription('The number of frames transmitted on this port.')
efdmimBdgPortErrorPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBdgPortErrorPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBdgPortErrorPkts.setDescription('The number of frame errors detected on this port.')
efdmimPhyTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 3), )
if mibBuilder.loadTexts: efdmimPhyTable.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimPhyTable.setDescription('This is a table of data that pertains only to phys on the efdmim.')
efdmimPhyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 3, 1), )
if mibBuilder.loadTexts: efdmimPhyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimPhyEntry.setDescription('This is a specific entry in the efdmimPhyTable that represents a specific attribute of a phy. Note that phy entries that refer to PHY-A will use an instance identifier of 1 and phy entries that refer to PHY-B will use an instance identifier of 2.')
efdmimPhyWithold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimPhyWithold.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimPhyWithold.setDescription("Describes if the phy is enabled but not allowed to be used due to a topology problem. Legal values are: none (0) - PHY can be used withold-because-M-M (1) - Don't use PHY withold-because-Other (2) - Don't use PHY ")
efdmimDeviceStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceStatus.setDescription("This is an Ascii string representation of the station's status. Responses include 'ON-LINE', 'STAND BY', and 'DISABLED'.")
efdmimDeviceBdgName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efdmimDeviceBdgName.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceBdgName.setDescription('This is a user-defined name for the bridge. The name may contain up to 32 characters.')
efdmimDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceType.setDescription("This represents the type of bridge this is. The EFDMIM will always respond with 'EFDMIM'. ")
efdmimDeviceVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceVersion.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceVersion.setDescription('A text string representing the firmware version installed in the bridge. ')
efdmimDeviceLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 24), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efdmimDeviceLocation.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceLocation.setDescription('A user defined name used to represent the location of the bridge. ')
efdmimDeviceUptime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceUptime.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceUptime.setDescription('The number of seconds that have elapsed since the bridge reset or initialized. ')
efdmimDeviceDisableBridge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efdmimDeviceDisableBridge.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceDisableBridge.setDescription('States whether or not the bridge is disabled. To disable the bridge, set this value to 1. To enable the bridge, set this value to 0. ')
efdmimDeviceResetCounters = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: efdmimDeviceResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceResetCounters.setDescription("This forces the EFDMIM to reset it's counters. Note: The efdmim will reset all it's counters except for the following: FDDI Frame count FDDI Error count FDDI Lost count FDDI Ring Oscillations. ")
efdmimDeviceSwitchSettings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceSwitchSettings.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceSwitchSettings.setDescription("This describes the dip and jumper settings physically set on the efdmim board. Switch multiply 2**n Root 0 Forward Broadcasts 1 Spanning Tree 2 BPDU Type 3 Bypass 4 Ring Select 5 Diagnostics 6 Mode 7 Root: If 0, then spanning tree root is selected. If 1, then spanning tree root is NOT selected. Forward Broadcasts: If 0, then all broadcast packets are forwarded. If 1, then all broadcasts packets are filtered. Spanning Tree: If 0, then spanning tree facilities are enabled. If 1, then spanning tree facilities are disabled. BPDU Type: If 0, then spanning tree uses the IEE bridge packet protocol. If 1, then spanning tree uses the DEC bridge packet protocol. Bypass: If 0, then there is an optical bypass physically attached to the bridge. If 1, then there is not an optical bypass attached to the bridge. Ring Select: If 0, the bridge should attach to the primary FDDI ring (Through-A mode). If 1, the bridge should attach to the secondary FDDI ring (Through-B mode). Diagnostics: If 0, the bridge is in it's normal mode of operation. If 1, then the bridge is running self diagnostics. Mode: If 0, the bridge is an encapsulating bridge (talks from ethernet to ethernet using FDDI only as a backbone). If 1, the bridge is a translation bridge ( talks ethernet to ethernet, and ethernet to FDDI). ")
efdmimDeviceReceivedPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceReceivedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceReceivedPkts.setDescription("The aggregate number of frames received by the bridge through it's ports.")
efdmimDeviceFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceFilteredPkts.setDescription("The aggregate number of frames received and filtered by the bridge through it's ports.")
efdmimDeviceForwardedPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceForwardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceForwardedPkts.setDescription("The aggregate number of frames received and forwarded by the bridge through it's ports.")
efdmimDeviceTransmittedPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceTransmittedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceTransmittedPkts.setDescription("The aggregate number of frames transmitted on it's ports.")
efdmimDeviceErrorPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceErrorPkts.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceErrorPkts.setDescription("The aggregate number of frame errors detected on it's ports")
efdmimCfmState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimCfmState.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimCfmState.setDescription("The efdmim's current CFM state. Legal values are: isolated (0) wrap-A (1) wrap-B (2) wrap-AB (3) through-A (4) through-B (5) through-AB (6) wrap-S (7) ")
efdmimBypassAttached = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBypassAttached.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBypassAttached.setDescription('Does the station has an optical bypass switch? ')
efdmimOscillations = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimOscillations.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimOscillations.setDescription('The number of times the claim/beacon process has completed since power-up. Note: This does not get reset when a reset counter command is issued. ')
efdmimRingUpTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRingUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRingUpTime.setDescription('The elapsed time in seconds since the most recent ring oscillation. Note: This returns 0 whenever the FDDI ring is down.')
efdmimDownstreamMac = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 38), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDownstreamMac.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDownstreamMac.setDescription("The address of this station's downstream MAC in canonical format. ")
efdmimBypassStuck = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimBypassStuck.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimBypassStuck.setDescription('True if the optical bypass switch is stuck False if everything is ok. ')
efdmimMode = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("encapsulation", 1), ("translation", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimMode.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimMode.setDescription(' Encapsulation bridges talk using the FDDI ring as a back-bone only. Translation bridges translates the packets into FDDI format.')
efdmimRmtState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimRmtState.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimRmtState.setDescription('This represents what state the RMT state machine is in. Legal values are: isolated (0) non-Op (1) ring-Op (2) detect (3) non-Op-Dup (4) ring-Op-Dup (5) directed (6) trace (7) ')
efdmimDeviceBridgeAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1, 42), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efdmimDeviceBridgeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: efdmimDeviceBridgeAddr.setDescription('This returns the Bridge address in canonical format. ')
mibBuilder.exportSymbols("EFDMIM-MIB", efdmimRingDuplicate=efdmimRingDuplicate, efdmimBdgPortTable=efdmimBdgPortTable, efdmimDeviceFilteredPkts=efdmimDeviceFilteredPkts, efdmimDeviceVersion=efdmimDeviceVersion, efdmimDeviceBdgName=efdmimDeviceBdgName, efdmimDeviceForwardedPkts=efdmimDeviceForwardedPkts, efdmimRingUpstreamMac=efdmimRingUpstreamMac, efdmimBdgPortFilteredPkts=efdmimBdgPortFilteredPkts, efdmimRmtState=efdmimRmtState, efdmimBdgPortReceivedPkts=efdmimBdgPortReceivedPkts, efdmimMode=efdmimMode, nb55=nb55, efdmimDeviceUptime=efdmimDeviceUptime, efdmimDeviceDisableBridge=efdmimDeviceDisableBridge, efdmimBypassAttached=efdmimBypassAttached, efdmimRingNodeClass=efdmimRingNodeClass, efdmimRingNonMasterPhys=efdmimRingNonMasterPhys, commsDevice=commsDevice, efdmimDeviceResetCounters=efdmimDeviceResetCounters, efdmimOscillations=efdmimOscillations, efdmimBypassStuck=efdmimBypassStuck, efdmimDownstreamMac=efdmimDownstreamMac, efdmimDeviceSwitchSettings=efdmimDeviceSwitchSettings, efdmimRingTopology=efdmimRingTopology, efdmimDeviceLocation=efdmimDeviceLocation, efdmimBdgPortErrorPkts=efdmimBdgPortErrorPkts, efdmimPhyWithold=efdmimPhyWithold, efdmimDeviceType=efdmimDeviceType, efdmimPhyEntry=efdmimPhyEntry, efdmimDeviceErrorPkts=efdmimDeviceErrorPkts, rev1=rev1, efdmimDeviceReceivedPkts=efdmimDeviceReceivedPkts, efdmimPhyTable=efdmimPhyTable, efdmimBdgPortForwardedPkts=efdmimBdgPortForwardedPkts, efdmimDeviceStatus=efdmimDeviceStatus, efdmimBdgPortTransmittedPkts=efdmimBdgPortTransmittedPkts, efdmimRingTable=efdmimRingTable, efdmimRingEntry=efdmimRingEntry, efdmimRingMacs=efdmimRingMacs, subsystem=subsystem, efdmimCfmState=efdmimCfmState, efdmimBdgPortEntry=efdmimBdgPortEntry, efdmimRingUpTime=efdmimRingUpTime, cabletron=cabletron, efdmimDeviceBridgeAddr=efdmimDeviceBridgeAddr, efdmimDeviceTransmittedPkts=efdmimDeviceTransmittedPkts, efdmimBdgPortState=efdmimBdgPortState, efdmimRingMasterPhys=efdmimRingMasterPhys, efdmimRingMacAddress=efdmimRingMacAddress)

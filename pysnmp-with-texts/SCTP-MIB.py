#
# PySNMP MIB module SCTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SCTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:01:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
InetAddress, InetPortNumber, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Integer32, Counter64, mib_2, TimeTicks, ObjectIdentity, Gauge32, Counter32, MibIdentifier, Bits, NotificationType, iso, IpAddress, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Integer32", "Counter64", "mib-2", "TimeTicks", "ObjectIdentity", "Gauge32", "Counter32", "MibIdentifier", "Bits", "NotificationType", "iso", "IpAddress", "Unsigned32")
DisplayString, TimeStamp, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TruthValue", "TextualConvention")
sctpMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 104))
sctpMIB.setRevisions(('2004-09-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: sctpMIB.setRevisionsDescriptions((' Initial version, published as RFC 3873',))
if mibBuilder.loadTexts: sctpMIB.setLastUpdated('200409020000Z')
if mibBuilder.loadTexts: sctpMIB.setOrganization('IETF SIGTRAN Working Group')
if mibBuilder.loadTexts: sctpMIB.setContactInfo(' WG EMail: sigtran@ietf.org Web Page: http://www.ietf.org/html.charters/sigtran-charter.html Chair: Lyndon Ong Ciena Corporation 0480 Ridgeview Drive Cupertino, CA 95014 USA Tel: Email: lyong@ciena.com Editors: Maria-Carmen Belinchon R&D Department Ericsson Espana S. A. Via de los Poblados, 13 28033 Madrid Spain Tel: +34 91 339 3535 Email: Maria.C.Belinchon@ericsson.com Jose-Javier Pastor-Balbas R&D Department Ericsson Espana S. A. Via de los Poblados, 13 28033 Madrid Spain Tel: +34 91 339 1397 Email: J.Javier.Pastor@ericsson.com ')
if mibBuilder.loadTexts: sctpMIB.setDescription('The MIB module for managing SCTP implementations. Copyright (C) The Internet Society (2004). This version of this MIB module is part of RFC 3873; see the RFC itself for full legal notices. ')
sctpObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1))
sctpStats = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1, 1))
sctpParams = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1, 2))
sctpCurrEstab = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpCurrEstab.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpCurrEstab.setStatus('current')
if mibBuilder.loadTexts: sctpCurrEstab.setDescription('The number of associations for which the current state is either ESTABLISHED, SHUTDOWN-RECEIVED or SHUTDOWN-PENDING.')
sctpActiveEstabs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpActiveEstabs.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpActiveEstabs.setStatus('current')
if mibBuilder.loadTexts: sctpActiveEstabs.setDescription('The number of times that associations have made a direct transition to the ESTABLISHED state from the COOKIE-ECHOED state: COOKIE-ECHOED -> ESTABLISHED. The upper layer initiated the association attempt.')
sctpPassiveEstabs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpPassiveEstabs.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpPassiveEstabs.setStatus('current')
if mibBuilder.loadTexts: sctpPassiveEstabs.setDescription('The number of times that associations have made a direct transition to the ESTABLISHED state from the CLOSED state: CLOSED -> ESTABLISHED. The remote endpoint initiated the association attempt.')
sctpAborteds = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAborteds.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpAborteds.setStatus('current')
if mibBuilder.loadTexts: sctpAborteds.setDescription("The number of times that associations have made a direct transition to the CLOSED state from any state using the primitive 'ABORT': AnyState --Abort--> CLOSED. Ungraceful termination of the association.")
sctpShutdowns = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpShutdowns.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpShutdowns.setStatus('current')
if mibBuilder.loadTexts: sctpShutdowns.setDescription('The number of times that associations have made a direct transition to the CLOSED state from either the SHUTDOWN-SENT state or the SHUTDOWN-ACK-SENT state. Graceful termination of the association.')
sctpOutOfBlues = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutOfBlues.setReference('Section 8.4 in RFC2960 deals with the Out-Of-The-Blue (OOTB) packet definition and procedures.')
if mibBuilder.loadTexts: sctpOutOfBlues.setStatus('current')
if mibBuilder.loadTexts: sctpOutOfBlues.setDescription('The number of out of the blue packets received by the host. An out of the blue packet is an SCTP packet correctly formed, including the proper checksum, but for which the receiver was unable to identify an appropriate association.')
sctpChecksumErrors = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpChecksumErrors.setReference('The checksum is located at the end of the SCTP packet as per Section 3.1 in RFC2960. RFC3309 updates SCTP to use a 32 bit CRC checksum.')
if mibBuilder.loadTexts: sctpChecksumErrors.setStatus('current')
if mibBuilder.loadTexts: sctpChecksumErrors.setDescription('The number of SCTP packets received with an invalid checksum.')
sctpOutCtrlChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutCtrlChunks.setReference('Sections 1.3.5 and 1.4 in RFC2960 refer to control chunk as those chunks different from those that contain user information, i.e., DATA chunks.')
if mibBuilder.loadTexts: sctpOutCtrlChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutCtrlChunks.setDescription('The number of SCTP control chunks sent (retransmissions are not included). Control chunks are those chunks different from DATA.')
sctpOutOrderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutOrderChunks.setReference('Section 3.3.1 in RFC2960 defines the ordered data chunk.')
if mibBuilder.loadTexts: sctpOutOrderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutOrderChunks.setDescription('The number of SCTP ordered data chunks sent (retransmissions are not included).')
sctpOutUnorderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutUnorderChunks.setReference('Section 3.3.1 in RFC2960 defines the unordered data chunk.')
if mibBuilder.loadTexts: sctpOutUnorderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutUnorderChunks.setDescription('The number of SCTP unordered chunks (data chunks in which the U bit is set to 1) sent (retransmissions are not included).')
sctpInCtrlChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInCtrlChunks.setReference('Sections 1.3.5 and 1.4 in RFC2960 refer to control chunk as those chunks different from those that contain user information, i.e., DATA chunks.')
if mibBuilder.loadTexts: sctpInCtrlChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInCtrlChunks.setDescription('The number of SCTP control chunks received (no duplicate chunks included).')
sctpInOrderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInOrderChunks.setReference('Section 3.3.1 in RFC2960 defines the ordered data chunk.')
if mibBuilder.loadTexts: sctpInOrderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInOrderChunks.setDescription('The number of SCTP ordered data chunks received (no duplicate chunks included).')
sctpInUnorderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInUnorderChunks.setReference('Section 3.3.1 in RFC2960 defines the unordered data chunk.')
if mibBuilder.loadTexts: sctpInUnorderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInUnorderChunks.setDescription('The number of SCTP unordered chunks (data chunks in which the U bit is set to 1) received (no duplicate chunks included).')
sctpFragUsrMsgs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpFragUsrMsgs.setStatus('current')
if mibBuilder.loadTexts: sctpFragUsrMsgs.setDescription('The number of user messages that have to be fragmented because of the MTU.')
sctpReasmUsrMsgs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setReference('Section 6.9 in RFC2960 includes a description of the reassembly process.')
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setStatus('current')
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setDescription('The number of user messages reassembled, after conversion into DATA chunks.')
sctpOutSCTPPacks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutSCTPPacks.setStatus('current')
if mibBuilder.loadTexts: sctpOutSCTPPacks.setDescription('The number of SCTP packets sent. Retransmitted DATA chunks are included.')
sctpInSCTPPacks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInSCTPPacks.setStatus('current')
if mibBuilder.loadTexts: sctpInSCTPPacks.setDescription('The number of SCTP packets received. Duplicates are included.')
sctpDiscontinuityTime = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpDiscontinuityTime.setReference('The inclusion of this object is recommended by RFC2578.')
if mibBuilder.loadTexts: sctpDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: sctpDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which any one or more of this general statistics counters suffered a discontinuity. The relevant counters are the specific instances associated with this interface of any Counter32 or Counter64 object contained in the SCTP layer statistics (defined below sctpStats branch). If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.')
sctpRtoAlgorithm = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("vanj", 2))).clone('vanj')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoAlgorithm.setReference('Section 6.3.1 and 6.3.2 in RFC2960 cover the RTO calculation and retransmission timer rules.')
if mibBuilder.loadTexts: sctpRtoAlgorithm.setStatus('current')
if mibBuilder.loadTexts: sctpRtoAlgorithm.setDescription('The algorithm used to determine the timeout value (T3-rtx) used for re-transmitting unacknowledged chunks.')
sctpRtoMin = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 2), Unsigned32().clone(1000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoMin.setStatus('current')
if mibBuilder.loadTexts: sctpRtoMin.setDescription("The minimum value permitted by a SCTP implementation for the retransmission timeout value, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout value. A retransmission time value of zero means immediate retransmission. The value of this object has to be lower than or equal to stcpRtoMax's value.")
sctpRtoMax = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 3), Unsigned32().clone(60000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoMax.setStatus('current')
if mibBuilder.loadTexts: sctpRtoMax.setDescription("The maximum value permitted by a SCTP implementation for the retransmission timeout value, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout value. A retransmission time value of zero means immediate re- transmission. The value of this object has to be greater than or equal to stcpRtoMin's value.")
sctpRtoInitial = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 4), Unsigned32().clone(3000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoInitial.setStatus('current')
if mibBuilder.loadTexts: sctpRtoInitial.setDescription('The initial value for the retransmission timer. A retransmission time value of zero means immediate re- transmission.')
sctpMaxAssocs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpMaxAssocs.setStatus('current')
if mibBuilder.loadTexts: sctpMaxAssocs.setDescription('The limit on the total number of associations the entity can support. In entities where the maximum number of associations is dynamic, this object should contain the value -1.')
sctpValCookieLife = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 6), Unsigned32().clone(60000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpValCookieLife.setReference('Section 5.1.3 in RFC2960 explains the cookie generation process. Recommended value is per section 14 in RFC2960.')
if mibBuilder.loadTexts: sctpValCookieLife.setStatus('current')
if mibBuilder.loadTexts: sctpValCookieLife.setDescription('Valid cookie life in the 4-way start-up handshake procedure.')
sctpMaxInitRetr = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 7), Unsigned32().clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpMaxInitRetr.setReference('Section 5.1.4, 5.1.6 in RFC2960 refers to Max.Init.Retransmit parameter. Recommended value is per section 14 in RFC2960.')
if mibBuilder.loadTexts: sctpMaxInitRetr.setStatus('current')
if mibBuilder.loadTexts: sctpMaxInitRetr.setDescription('The maximum number of retransmissions at the start-up phase (INIT and COOKIE ECHO chunks). ')
sctpAssocTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 3), )
if mibBuilder.loadTexts: sctpAssocTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocTable.setDescription('A table containing SCTP association-specific information.')
sctpAssocEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 3, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpAssocEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocEntry.setDescription('General common variables and statistics for the whole association.')
sctpAssocId = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: sctpAssocId.setStatus('current')
if mibBuilder.loadTexts: sctpAssocId.setDescription('Association Identification. Value identifying the association. ')
sctpAssocRemHostName = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemHostName.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemHostName.setDescription("The peer's DNS name. This object needs to have the same format as the encoding in the DNS protocol. This implies that the domain name can be up to 255 octets long, each octet being 0<=x<=255 as value with US-ASCII A-Z having a case insensitive matching. If no DNS domain name was received from the peer at init time (embedded in the INIT or INIT-ACK chunk), this object is meaningless. In such cases the object MUST contain a zero- length string value. Otherwise, it contains the remote host name received at init time.")
sctpAssocLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 3), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocLocalPort.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalPort.setDescription('The local SCTP port number used for this association.')
sctpAssocRemPort = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 4), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPort.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPort.setDescription('The remote SCTP port number used for this association.')
sctpAssocRemPrimAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPrimAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPrimAddrType.setDescription('The internet type of primary remote IP address. ')
sctpAssocRemPrimAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPrimAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPrimAddr.setDescription('The primary remote IP address. The type of this address is determined by the value of sctpAssocRemPrimAddrType. The client side will know this value after INIT_ACK message reception, the server side will know this value when sending INIT_ACK message. However, values will be filled in at established(4) state.')
sctpAssocHeartBeatInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 7), Unsigned32().clone(30000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocHeartBeatInterval.setStatus('current')
if mibBuilder.loadTexts: sctpAssocHeartBeatInterval.setDescription('The current heartbeat interval.. Zero value means no HeartBeat, even when the concerned sctpAssocRemAddrHBFlag object is true.')
sctpAssocState = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("closed", 1), ("cookieWait", 2), ("cookieEchoed", 3), ("established", 4), ("shutdownPending", 5), ("shutdownSent", 6), ("shutdownReceived", 7), ("shutdownAckSent", 8), ("deleteTCB", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sctpAssocState.setReference('Section 4 in RFC2960 covers the SCTP Association state diagram.')
if mibBuilder.loadTexts: sctpAssocState.setStatus('current')
if mibBuilder.loadTexts: sctpAssocState.setDescription('The state of this SCTP association. As in TCP, deleteTCB(9) is the only value that may be set by a management station. If any other value is received, then the agent must return a wrongValue error. If a management station sets this object to the value deleteTCB(9), then this has the effect of deleting the TCB (as defined in SCTP) of the corresponding association on the managed node, resulting in immediate termination of the association. As an implementation-specific option, an ABORT chunk may be sent from the managed node to the other SCTP endpoint as a result of setting the deleteTCB(9) value. The ABORT chunk implies an ungraceful association shutdown.')
sctpAssocInStreams = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocInStreams.setReference('Section 1.3 in RFC2960 includes a definition of stream. Section 5.1.1 in RFC2960 covers the streams negotiation process.')
if mibBuilder.loadTexts: sctpAssocInStreams.setStatus('current')
if mibBuilder.loadTexts: sctpAssocInStreams.setDescription('Inbound Streams according to the negotiation at association start up.')
sctpAssocOutStreams = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocOutStreams.setReference('Section 1.3 in RFC2960 includes a definition of stream. Section 5.1.1 in RFC2960 covers the streams negotiation process.')
if mibBuilder.loadTexts: sctpAssocOutStreams.setStatus('current')
if mibBuilder.loadTexts: sctpAssocOutStreams.setDescription('Outbound Streams according to the negotiation at association start up. ')
sctpAssocMaxRetr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 11), Unsigned32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocMaxRetr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocMaxRetr.setDescription('The maximum number of data retransmissions in the association context. This value is specific for each association and the upper layer can change it by calling the appropriate primitives. This value has to be smaller than the addition of all the maximum number for all the paths (sctpAssocRemAddrMaxPathRtx). A value of zero value means no retransmissions.')
sctpAssocPrimProcess = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocPrimProcess.setStatus('current')
if mibBuilder.loadTexts: sctpAssocPrimProcess.setDescription("This object identifies the system level process which holds primary responsibility for the SCTP association. Wherever possible, this should be the system's native unique identification number. The special value 0 can be used to indicate that no primary process is known. Note that the value of this object can be used as a pointer into the swRunTable of the HOST-RESOURCES-MIB(if the value is smaller than 2147483647) or into the sysApplElmtRunTable of the SYSAPPL-MIB.")
sctpAssocT1expireds = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocT1expireds.setReference('Section 5 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocT1expireds.setStatus('current')
if mibBuilder.loadTexts: sctpAssocT1expireds.setDescription('The T1 timer determines how long to wait for an acknowledgement after sending an INIT or COOKIE-ECHO chunk. This object reflects the number of times the T1 timer expires without having received the acknowledgement. Discontinuities in the value of this counter can occur at re- initialization of the management system, and at other times as indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocT2expireds = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocT2expireds.setReference('Section 9.2 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocT2expireds.setStatus('current')
if mibBuilder.loadTexts: sctpAssocT2expireds.setDescription('The T2 timer determines how long to wait for an acknowledgement after sending a SHUTDOWN or SHUTDOWN-ACK chunk. This object reflects the number of times that T2- timer expired. Discontinuities in the value of this counter can occur at re- initialization of the management system, and at other times as indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocRtxChunks = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRtxChunks.setReference('Section 6 in RFC2960 covers the retransmission process and rules.')
if mibBuilder.loadTexts: sctpAssocRtxChunks.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRtxChunks.setDescription('When T3-rtx expires, the DATA chunks that triggered the T3 timer will be re-sent according with the retransmissions rules. Every DATA chunk that was included in the SCTP packet that triggered the T3-rtx timer must be added to the value of this counter. Discontinuities in the value of this counter can occur at re- initialization of the management system, and at other times as indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocStartTime.setDescription('The value of sysUpTime at the time that the association represented by this row enters the ESTABLISHED state, i.e., the sctpAssocState object is set to established(4). The value of this object will be zero: - before the association enters the established(4) state, or - if the established(4) state was entered prior to the last re-initialization of the local network management subsystem.')
sctpAssocDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setReference('The inclusion of this object is recommended by RFC2578.')
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which any one or more of this SCTP association counters suffered a discontinuity. The relevant counters are the specific instances associated with this interface of any Counter32 or Counter64 object contained in the sctpAssocTable or sctpLocalAddrTable or sctpRemAddrTable. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value. ')
sctpAssocLocalAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 4), )
if mibBuilder.loadTexts: sctpAssocLocalAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrTable.setDescription('Expanded table of sctpAssocTable based on the AssocId index. This table shows data related to each local IP address which is used by this association.')
sctpAssocLocalAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 4, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"), (0, "SCTP-MIB", "sctpAssocLocalAddrType"), (0, "SCTP-MIB", "sctpAssocLocalAddr"))
if mibBuilder.loadTexts: sctpAssocLocalAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrEntry.setDescription('Local information about the available addresses. There will be an entry for every local IP address defined for this association. Implementors need to be aware that if the size of sctpAssocLocalAddr exceeds 114 octets then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
sctpAssocLocalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: sctpAssocLocalAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrType.setDescription('Internet type of local IP address used for this association.')
sctpAssocLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: sctpAssocLocalAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddr.setDescription('The value of a local IP address available for this association. The type of this address is determined by the value of sctpAssocLocalAddrType.')
sctpAssocLocalAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocLocalAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrStartTime.setDescription('The value of sysUpTime at the time that this row was created.')
sctpAssocRemAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 5), )
if mibBuilder.loadTexts: sctpAssocRemAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrTable.setDescription('Expanded table of sctpAssocTable based on the AssocId index. This table shows data related to each remote peer IP address which is used by this association.')
sctpAssocRemAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 5, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"), (0, "SCTP-MIB", "sctpAssocRemAddrType"), (0, "SCTP-MIB", "sctpAssocRemAddr"))
if mibBuilder.loadTexts: sctpAssocRemAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrEntry.setDescription('Information about the most important variables for every remote IP address. There will be an entry for every remote IP address defined for this association. Implementors need to be aware that if the size of sctpAssocRemAddr exceeds 114 octets then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
sctpAssocRemAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 1), InetAddressType())
if mibBuilder.loadTexts: sctpAssocRemAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrType.setDescription('Internet type of a remote IP address available for this association.')
sctpAssocRemAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 2), InetAddress())
if mibBuilder.loadTexts: sctpAssocRemAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddr.setDescription('The value of a remote IP address available for this association. The type of this address is determined by the value of sctpAssocLocalAddrType.')
sctpAssocRemAddrActive = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setReference('The remote transport states are defined as Active and Inactive in the SCTP, RFC2960.')
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setDescription("This object gives information about the reachability of this specific remote IP address. When the object is set to 'true' (1), the remote IP address is understood as Active. Active means that the threshold of no answers received from this IP address has not been reached. When the object is set to 'false' (2), the remote IP address is understood as Inactive. Inactive means that either no heartbeat or any other message was received from this address, reaching the threshold defined by the protocol.")
sctpAssocRemAddrHBActive = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrHBActive.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrHBActive.setDescription('This object indicates whether the optional Heartbeat check associated to one destination transport address is activated or not (value equal to true or false, respectively). ')
sctpAssocRemAddrRTO = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 5), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setReference('Section 6.3 in RFC2960 deals with the Retransmission Timer Management.')
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setDescription('The current Retransmission Timeout. T3-rtx timer as defined in the protocol SCTP.')
sctpAssocRemAddrMaxPathRtx = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 6), Unsigned32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setReference('Section 8.2, 8.3 and 14 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setDescription('Maximum number of DATA chunks retransmissions allowed to a remote IP address before it is considered inactive, as defined in RFC2960.')
sctpAssocRemAddrRtx = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrRtx.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrRtx.setDescription('Number of DATA chunks retransmissions to this specific IP address. When T3-rtx expires, the DATA chunk that triggered the T3 timer will be re-sent according to the retransmissions rules. Every DATA chunk that is included in a SCTP packet and was transmitted to this specific IP address before, will be included in this counter. Discontinuities in the value of this counter can occur at re- initialization of the management system, and at other times as indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocRemAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrStartTime.setDescription('The value of sysUpTime at the time that this row was created.')
sctpLookupLocalPortTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 6), )
if mibBuilder.loadTexts: sctpLookupLocalPortTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortTable.setDescription('With the use of this table, a list of associations which are using the specified local port can be retrieved.')
sctpLookupLocalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 6, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocLocalPort"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupLocalPortEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortEntry.setDescription('This table is indexed by local port and association ID. Specifying a local port, we would get a list of the associations whose local port is the one specified.')
sctpLookupLocalPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 6, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupLocalPortStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortStartTime.setDescription('The value of sysUpTime at the time that this row was created. As the table will be created after the sctpAssocTable creation, this value could be equal to the sctpAssocStartTime object from the main table.')
sctpLookupRemPortTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 7), )
if mibBuilder.loadTexts: sctpLookupRemPortTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortTable.setDescription('With the use of this table, a list of associations which are using the specified remote port can be got')
sctpLookupRemPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 7, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemPort"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemPortEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortEntry.setDescription('This table is indexed by remote port and association ID. Specifying a remote port we would get a list of the associations whose local port is the one specified ')
sctpLookupRemPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 7, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemPortStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortStartTime.setDescription('The value of sysUpTime at the time that this row was created. As the table will be created after the sctpAssocTable creation, this value could be equal to the sctpAssocStartTime object from the main table.')
sctpLookupRemHostNameTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 8), )
if mibBuilder.loadTexts: sctpLookupRemHostNameTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameTable.setDescription('With the use of this table, a list of associations with that particular host can be retrieved.')
sctpLookupRemHostNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 8, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemHostName"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemHostNameEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameEntry.setDescription('This table is indexed by remote host name and association ID. Specifying a host name we would get a list of the associations specifying that host name as the remote one. Implementors need to be aware that if the size of sctpAssocRemHostName exceeds 115 octets then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
sctpLookupRemHostNameStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 8, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemHostNameStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameStartTime.setDescription('The value of sysUpTime at the time that this row was created. As the table will be created after the sctpAssocTable creation, this value could be equal to the sctpAssocStartTime object from the main table.')
sctpLookupRemPrimIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 9), )
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrTable.setDescription('With the use of this table, a list of associations that have the specified IP address as primary within the remote set of active addresses can be retrieved.')
sctpLookupRemPrimIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 9, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemPrimAddrType"), (0, "SCTP-MIB", "sctpAssocRemPrimAddr"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrEntry.setDescription('This table is indexed by primary address and association ID. Specifying a primary address, we would get a list of the associations that have the specified remote IP address marked as primary. Implementors need to be aware that if the size of sctpAssocRemPrimAddr exceeds 114 octets then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
sctpLookupRemPrimIPAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 9, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrStartTime.setDescription('The value of SysUpTime at the time that this row was created. As the table will be created after the sctpAssocTable creation, this value could be equal to the sctpAssocStartTime object from the main table.')
sctpLookupRemIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 10), )
if mibBuilder.loadTexts: sctpLookupRemIPAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrTable.setDescription('With the use of this table, a list of associations that have the specified IP address as one of the remote ones can be retrieved. ')
sctpLookupRemIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 10, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemAddrType"), (0, "SCTP-MIB", "sctpAssocRemAddr"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemIPAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrEntry.setDescription('This table is indexed by a remote IP address and association ID. Specifying an IP address we would get a list of the associations that have the specified IP address included within the set of remote IP addresses.')
sctpLookupRemIPAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 10, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemIPAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrStartTime.setDescription('The value of SysUpTime at the time that this row was created. As the table will be created after the sctpAssocTable creation, this value could be equal to the sctpAssocStartTime object from the main table.')
sctpMibConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2))
sctpMibCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2, 1))
sctpMibGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2, 2))
sctpLayerParamsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 1)).setObjects(("SCTP-MIB", "sctpRtoAlgorithm"), ("SCTP-MIB", "sctpRtoMin"), ("SCTP-MIB", "sctpRtoMax"), ("SCTP-MIB", "sctpRtoInitial"), ("SCTP-MIB", "sctpMaxAssocs"), ("SCTP-MIB", "sctpValCookieLife"), ("SCTP-MIB", "sctpMaxInitRetr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpLayerParamsGroup = sctpLayerParamsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpLayerParamsGroup.setDescription('Common parameters for the SCTP layer, i.e., for all the associations. They can usually be referred to as configuration parameters.')
sctpStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 2)).setObjects(("SCTP-MIB", "sctpCurrEstab"), ("SCTP-MIB", "sctpActiveEstabs"), ("SCTP-MIB", "sctpPassiveEstabs"), ("SCTP-MIB", "sctpAborteds"), ("SCTP-MIB", "sctpShutdowns"), ("SCTP-MIB", "sctpOutOfBlues"), ("SCTP-MIB", "sctpChecksumErrors"), ("SCTP-MIB", "sctpOutCtrlChunks"), ("SCTP-MIB", "sctpOutOrderChunks"), ("SCTP-MIB", "sctpOutUnorderChunks"), ("SCTP-MIB", "sctpInCtrlChunks"), ("SCTP-MIB", "sctpInOrderChunks"), ("SCTP-MIB", "sctpInUnorderChunks"), ("SCTP-MIB", "sctpFragUsrMsgs"), ("SCTP-MIB", "sctpReasmUsrMsgs"), ("SCTP-MIB", "sctpOutSCTPPacks"), ("SCTP-MIB", "sctpInSCTPPacks"), ("SCTP-MIB", "sctpDiscontinuityTime"), ("SCTP-MIB", "sctpAssocT1expireds"), ("SCTP-MIB", "sctpAssocT2expireds"), ("SCTP-MIB", "sctpAssocRtxChunks"), ("SCTP-MIB", "sctpAssocRemAddrRtx"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpStatsGroup = sctpStatsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpStatsGroup.setDescription('Statistics group. It includes the objects to collect state changes in the SCTP protocol local layer and flow control statistics.')
sctpPerAssocParamsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 3)).setObjects(("SCTP-MIB", "sctpAssocRemHostName"), ("SCTP-MIB", "sctpAssocLocalPort"), ("SCTP-MIB", "sctpAssocRemPort"), ("SCTP-MIB", "sctpAssocRemPrimAddrType"), ("SCTP-MIB", "sctpAssocRemPrimAddr"), ("SCTP-MIB", "sctpAssocHeartBeatInterval"), ("SCTP-MIB", "sctpAssocState"), ("SCTP-MIB", "sctpAssocInStreams"), ("SCTP-MIB", "sctpAssocOutStreams"), ("SCTP-MIB", "sctpAssocMaxRetr"), ("SCTP-MIB", "sctpAssocPrimProcess"), ("SCTP-MIB", "sctpAssocStartTime"), ("SCTP-MIB", "sctpAssocDiscontinuityTime"), ("SCTP-MIB", "sctpAssocLocalAddrStartTime"), ("SCTP-MIB", "sctpAssocRemAddrActive"), ("SCTP-MIB", "sctpAssocRemAddrHBActive"), ("SCTP-MIB", "sctpAssocRemAddrRTO"), ("SCTP-MIB", "sctpAssocRemAddrMaxPathRtx"), ("SCTP-MIB", "sctpAssocRemAddrStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpPerAssocParamsGroup = sctpPerAssocParamsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpPerAssocParamsGroup.setDescription('The SCTP group of objects to manage per-association parameters. These variables include all the SCTP basic features.')
sctpPerAssocStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 4)).setObjects(("SCTP-MIB", "sctpAssocT1expireds"), ("SCTP-MIB", "sctpAssocT2expireds"), ("SCTP-MIB", "sctpAssocRtxChunks"), ("SCTP-MIB", "sctpAssocRemAddrRtx"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpPerAssocStatsGroup = sctpPerAssocStatsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpPerAssocStatsGroup.setDescription('Per Association Statistics group. It includes the objects to collect flow control statistics per association.')
sctpInverseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 5)).setObjects(("SCTP-MIB", "sctpLookupLocalPortStartTime"), ("SCTP-MIB", "sctpLookupRemPortStartTime"), ("SCTP-MIB", "sctpLookupRemHostNameStartTime"), ("SCTP-MIB", "sctpLookupRemPrimIPAddrStartTime"), ("SCTP-MIB", "sctpLookupRemIPAddrStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpInverseGroup = sctpInverseGroup.setStatus('current')
if mibBuilder.loadTexts: sctpInverseGroup.setDescription('Objects used in the inverse lookup tables.')
sctpMibCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 104, 2, 1, 1)).setObjects(("SCTP-MIB", "sctpLayerParamsGroup"), ("SCTP-MIB", "sctpPerAssocParamsGroup"), ("SCTP-MIB", "sctpStatsGroup"), ("SCTP-MIB", "sctpPerAssocStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpMibCompliance = sctpMibCompliance.setStatus('current')
if mibBuilder.loadTexts: sctpMibCompliance.setDescription('The compliance statement for SNMP entities which implement this SCTP MIB Module. There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which we have the following compliance requirements, expressed in OBJECT clause form in this description clause: -- OBJECT sctpAssocLocalAddrType -- SYNTAX InetAddressType {ipv4(1), ipv6(2)} -- DESCRIPTION -- It is only required to have IPv4 and IPv6 addresses without -- zone indices. -- The address with zone indices is required if an -- implementation can connect multiple zones. -- -- OBJECT sctpAssocLocalAddr -- SYNTAX InetAddress (SIZE(4|16)) -- DESCRIPTION -- An implementation is only required to support globally -- unique IPv4 and IPv6 addresses. -- -- OBJECT sctpAssocRemAddrType -- SYNTAX InetAddressType {ipv4(1), ipv6(2)} -- DESCRIPTION -- It is only required to have IPv4 and IPv6 addresses without -- zone indices. -- The address with zone indices is required if an -- implementation can connect multiple zones. -- -- OBJECT sctpAssocRemAddr -- SYNTAX InetAddress (SIZE(4|16)) -- DESCRIPTION -- An implementation is only required to support globally -- unique IPv4 and IPv6 addresses. -- ')
mibBuilder.exportSymbols("SCTP-MIB", sctpInSCTPPacks=sctpInSCTPPacks, sctpLayerParamsGroup=sctpLayerParamsGroup, sctpAssocRtxChunks=sctpAssocRtxChunks, sctpChecksumErrors=sctpChecksumErrors, sctpLookupLocalPortTable=sctpLookupLocalPortTable, sctpAborteds=sctpAborteds, sctpAssocRemHostName=sctpAssocRemHostName, PYSNMP_MODULE_ID=sctpMIB, sctpPerAssocParamsGroup=sctpPerAssocParamsGroup, sctpAssocRemAddrEntry=sctpAssocRemAddrEntry, sctpAssocEntry=sctpAssocEntry, sctpObjects=sctpObjects, sctpLookupRemPrimIPAddrEntry=sctpLookupRemPrimIPAddrEntry, sctpMaxAssocs=sctpMaxAssocs, sctpAssocLocalAddrTable=sctpAssocLocalAddrTable, sctpAssocLocalAddrType=sctpAssocLocalAddrType, sctpAssocStartTime=sctpAssocStartTime, sctpAssocLocalPort=sctpAssocLocalPort, sctpLookupLocalPortEntry=sctpLookupLocalPortEntry, sctpOutOrderChunks=sctpOutOrderChunks, sctpAssocMaxRetr=sctpAssocMaxRetr, sctpAssocRemPrimAddr=sctpAssocRemPrimAddr, sctpAssocRemAddrTable=sctpAssocRemAddrTable, sctpAssocRemAddrType=sctpAssocRemAddrType, sctpPerAssocStatsGroup=sctpPerAssocStatsGroup, sctpRtoInitial=sctpRtoInitial, sctpRtoAlgorithm=sctpRtoAlgorithm, sctpParams=sctpParams, sctpRtoMin=sctpRtoMin, sctpValCookieLife=sctpValCookieLife, sctpAssocRemPort=sctpAssocRemPort, sctpAssocId=sctpAssocId, sctpOutUnorderChunks=sctpOutUnorderChunks, sctpOutSCTPPacks=sctpOutSCTPPacks, sctpMibCompliance=sctpMibCompliance, sctpInverseGroup=sctpInverseGroup, sctpAssocLocalAddrStartTime=sctpAssocLocalAddrStartTime, sctpAssocRemAddrActive=sctpAssocRemAddrActive, sctpLookupRemHostNameTable=sctpLookupRemHostNameTable, sctpAssocOutStreams=sctpAssocOutStreams, sctpAssocRemAddrMaxPathRtx=sctpAssocRemAddrMaxPathRtx, sctpLookupRemHostNameStartTime=sctpLookupRemHostNameStartTime, sctpAssocPrimProcess=sctpAssocPrimProcess, sctpLookupRemIPAddrTable=sctpLookupRemIPAddrTable, sctpAssocState=sctpAssocState, sctpLookupRemPortEntry=sctpLookupRemPortEntry, sctpMibCompliances=sctpMibCompliances, sctpAssocInStreams=sctpAssocInStreams, sctpAssocRemAddr=sctpAssocRemAddr, sctpAssocRemAddrStartTime=sctpAssocRemAddrStartTime, sctpAssocLocalAddrEntry=sctpAssocLocalAddrEntry, sctpAssocRemAddrRtx=sctpAssocRemAddrRtx, sctpActiveEstabs=sctpActiveEstabs, sctpLookupRemPortStartTime=sctpLookupRemPortStartTime, sctpInCtrlChunks=sctpInCtrlChunks, sctpCurrEstab=sctpCurrEstab, sctpInOrderChunks=sctpInOrderChunks, sctpMaxInitRetr=sctpMaxInitRetr, sctpInUnorderChunks=sctpInUnorderChunks, sctpLookupRemPrimIPAddrStartTime=sctpLookupRemPrimIPAddrStartTime, sctpShutdowns=sctpShutdowns, sctpAssocDiscontinuityTime=sctpAssocDiscontinuityTime, sctpMibConformance=sctpMibConformance, sctpDiscontinuityTime=sctpDiscontinuityTime, sctpLookupRemPortTable=sctpLookupRemPortTable, sctpMIB=sctpMIB, sctpLookupRemPrimIPAddrTable=sctpLookupRemPrimIPAddrTable, sctpAssocRemAddrRTO=sctpAssocRemAddrRTO, sctpLookupRemIPAddrEntry=sctpLookupRemIPAddrEntry, sctpStats=sctpStats, sctpAssocT1expireds=sctpAssocT1expireds, sctpOutCtrlChunks=sctpOutCtrlChunks, sctpFragUsrMsgs=sctpFragUsrMsgs, sctpAssocRemAddrHBActive=sctpAssocRemAddrHBActive, sctpAssocT2expireds=sctpAssocT2expireds, sctpMibGroups=sctpMibGroups, sctpPassiveEstabs=sctpPassiveEstabs, sctpAssocLocalAddr=sctpAssocLocalAddr, sctpStatsGroup=sctpStatsGroup, sctpAssocHeartBeatInterval=sctpAssocHeartBeatInterval, sctpRtoMax=sctpRtoMax, sctpAssocTable=sctpAssocTable, sctpReasmUsrMsgs=sctpReasmUsrMsgs, sctpOutOfBlues=sctpOutOfBlues, sctpLookupRemIPAddrStartTime=sctpLookupRemIPAddrStartTime, sctpAssocRemPrimAddrType=sctpAssocRemPrimAddrType, sctpLookupLocalPortStartTime=sctpLookupLocalPortStartTime, sctpLookupRemHostNameEntry=sctpLookupRemHostNameEntry)

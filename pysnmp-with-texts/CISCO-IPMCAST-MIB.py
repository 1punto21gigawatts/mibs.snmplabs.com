#
# PySNMP MIB module CISCO-IPMCAST-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IPMCAST-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
igmpInterfaceEntry, = mibBuilder.importSymbols("IGMP-MIB", "igmpInterfaceEntry")
OwnerString, = mibBuilder.importSymbols("RFC1271-MIB", "OwnerString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
iso, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Gauge32, IpAddress, ModuleIdentity, MibIdentifier, Bits, ObjectIdentity, Counter64, Counter32, enterprises, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Gauge32", "IpAddress", "ModuleIdentity", "MibIdentifier", "Bits", "ObjectIdentity", "Counter64", "Counter32", "enterprises", "Unsigned32", "NotificationType")
RowStatus, DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TextualConvention", "TruthValue")
ciscoMcastMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 4))
if mibBuilder.loadTexts: ciscoMcastMIB.setLastUpdated('9407301359Z')
if mibBuilder.loadTexts: ciscoMcastMIB.setOrganization('Cisco System Inc.')
if mibBuilder.loadTexts: ciscoMcastMIB.setContactInfo(' Cisco System Inc.')
if mibBuilder.loadTexts: ciscoMcastMIB.setDescription('The MIB module for Cisco-specific management of IP Multicast in Cisco devices.')
ciscoMcastMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1))
mcastAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1))
mcastTrace = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2))
mcastFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3))
pimRpAccessListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 1), )
if mibBuilder.loadTexts: pimRpAccessListTable.setStatus('current')
if mibBuilder.loadTexts: pimRpAccessListTable.setDescription('The (conceptual) table containing the access-lists of IP Multicast groups configured for specific Rendezvous- Points. An RP for which there is no entry in this table is configured for all groups.')
pimRpAccessListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-IPMCAST-MIB", "pimRpAccessListRP"))
if mibBuilder.loadTexts: pimRpAccessListEntry.setStatus('current')
if mibBuilder.loadTexts: pimRpAccessListEntry.setDescription('An entry (conceptual row) in the pimRpAccessListTable.')
pimRpAccessListRP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: pimRpAccessListRP.setStatus('current')
if mibBuilder.loadTexts: pimRpAccessListRP.setDescription('The address of the Rendezvous Point for which this entry contains access-list information.')
pimRpAccessListNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pimRpAccessListNumber.setStatus('current')
if mibBuilder.loadTexts: pimRpAccessListNumber.setDescription('The number of the access-list which specifies the range of group addresses which have this Rendezvous Point. A value of zero is equivalent to no access-list.')
pimRpAccessListStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pimRpAccessListStatus.setStatus('current')
if mibBuilder.loadTexts: pimRpAccessListStatus.setDescription('The status of this row.')
igmpAccessListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 2), )
if mibBuilder.loadTexts: igmpAccessListTable.setStatus('current')
if mibBuilder.loadTexts: igmpAccessListTable.setDescription('The (conceptual) table containing the configured access- lists of IP Multicast groups for which join requests received from hosts (i.e., directly attached group members) via specific interfaces are allowed. If no access-list is defined for an interface, any group can be joined via that interace.')
igmpAccessListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 2, 1), )
igmpInterfaceEntry.registerAugmentions(("CISCO-IPMCAST-MIB", "igmpAccessListEntry"))
igmpAccessListEntry.setIndexNames(*igmpInterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: igmpAccessListEntry.setStatus('current')
if mibBuilder.loadTexts: igmpAccessListEntry.setDescription('An entry (conceptual row) in the igmpAccessListTable.')
igmpAccessListNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpAccessListNumber.setStatus('current')
if mibBuilder.loadTexts: igmpAccessListNumber.setDescription('The number of the access-list which specifies the IP multicast groups for which joins are allowed on this interface. A value of zero is equivalent to no access- list.')
mcastTraceRequest = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1))
mcastTraceResponse = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2))
mrbranchState = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrbranchState.setStatus('current')
if mibBuilder.loadTexts: mrbranchState.setDescription("The state of the SNMP-invoked mrbranch facility. Only one such mrbranch may be in progress at a time. When this object has the value 'inactive', setting it to 'active' causes an mrbranch to be invoked using the values of mrbranchGroup, mrbranchBranch and mrbranchTimeout which were set either concurrently or most recently. The value stays 'active' until the mrbranch completes/times-out at which time it becomes 'inactive'. Setting this value to 'active' when it is already 'active' it is an error. Setting it to 'inactive' either cancels the active mrbranch or is a no-op.")
mrbranchGroup = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrbranchGroup.setStatus('current')
if mibBuilder.loadTexts: mrbranchGroup.setDescription('The IP multicast group address to be used by the next SNMP-invoked mrbranch command.')
mrbranchBranch = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrbranchBranch.setStatus('current')
if mibBuilder.loadTexts: mrbranchBranch.setDescription('The branch address, i.e., the IP unicast address of the responding router, to be used by the next SNMP-invoked mrbranch command.')
mrbranchTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1, 4), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrbranchTimeout.setStatus('current')
if mibBuilder.loadTexts: mrbranchTimeout.setDescription('The maximum number of seconds to be taken by the next SNMP-invoked mrbranch command.')
mrbranchRequestor = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 1, 5), OwnerString()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrbranchRequestor.setStatus('current')
if mibBuilder.loadTexts: mrbranchRequestor.setDescription('An indication of the identity of invoker the last/current/next SNMP-invoked mrbranch command.')
mrbranchResponseTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 1), )
if mibBuilder.loadTexts: mrbranchResponseTable.setStatus('current')
if mibBuilder.loadTexts: mrbranchResponseTable.setDescription('The table containing mrbranch responses. Additional information from mrbranch responses is contained in the mrbranchInterfaceListTable.')
mrbranchResponseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-IPMCAST-MIB", "mrbranchResponseResponder"))
if mibBuilder.loadTexts: mrbranchResponseEntry.setStatus('current')
if mibBuilder.loadTexts: mrbranchResponseEntry.setDescription('An entry in the mrbranchResponseTable, representing one mrbranch response.')
mrbranchResponseResponder = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: mrbranchResponseResponder.setStatus('current')
if mibBuilder.loadTexts: mrbranchResponseResponder.setDescription('The IP address of the responder to the mrbranch request for which this entry contains information.')
mrbranchResponseRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrbranchResponseRtt.setStatus('current')
if mibBuilder.loadTexts: mrbranchResponseRtt.setDescription('The time taken for the request to be sent and the response to come back for this responder to the mrbranch request.')
mrbranchResponseRPF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrbranchResponseRPF.setStatus('current')
if mibBuilder.loadTexts: mrbranchResponseRPF.setDescription('The IP address of the RPF neighbor of the responder to the mrbranch request.')
mrbranchInterfaceListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 2), )
if mibBuilder.loadTexts: mrbranchInterfaceListTable.setStatus('current')
if mibBuilder.loadTexts: mrbranchInterfaceListTable.setDescription('The table containing information on outgoing interfaces as reported in a response to a mrbranch. Each entry is one of a list of outgoing interface from a particular responder.')
mrbranchInterfaceListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 2, 1), ).setIndexNames((0, "CISCO-IPMCAST-MIB", "mrbranchResponseResponder"), (0, "CISCO-IPMCAST-MIB", "mrbranchInterfaceListAddress"))
if mibBuilder.loadTexts: mrbranchInterfaceListEntry.setStatus('current')
if mibBuilder.loadTexts: mrbranchInterfaceListEntry.setDescription('An entry in the mrbranchInterfaceListTable containing a particular outgoing interface listed in the response to a mrbranch received from the responder indicated by mrbranchResponseResponder.')
mrbranchInterfaceListAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrbranchInterfaceListAddress.setStatus('current')
if mibBuilder.loadTexts: mrbranchInterfaceListAddress.setDescription('The IP address of the outgoing interface.')
mrbranchInterfaceListNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 2, 2, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrbranchInterfaceListNetMask.setStatus('current')
if mibBuilder.loadTexts: mrbranchInterfaceListNetMask.setDescription('The network mask of the IP address of the outgoing interface.')
igmpConditionalFilteringEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpConditionalFilteringEnable.setStatus('current')
if mibBuilder.loadTexts: igmpConditionalFilteringEnable.setDescription('An indication of whether IGMP Conditional Filtering is enabled.')
igmpMemberReportTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 2), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMemberReportTimeout.setStatus('current')
if mibBuilder.loadTexts: igmpMemberReportTimeout.setDescription('The number of seconds for which the receipt of the most recent IGMP Membership Report for a particular IP multicast group on a particular interface indicates that there is currently a member of that group on that interface.')
igmpCondFilterIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 3), )
if mibBuilder.loadTexts: igmpCondFilterIfTable.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterIfTable.setDescription('The table containing information on interfaces for use with IGMP Conditional Filtering.')
igmpCondFilterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 3, 1), ).setIndexNames((0, "CISCO-IPMCAST-MIB", "igmpCondFilterIfIndex"))
if mibBuilder.loadTexts: igmpCondFilterIfEntry.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterIfEntry.setDescription('An entry in the igmpCondFilterIfTable containing information on a particular interface.')
igmpCondFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: igmpCondFilterIfIndex.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterIfIndex.setDescription('The ifIndex value of the interface.')
igmpCondFilterIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("routerPresent", 1), ("noRouter", 2), ("dynamic", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpCondFilterIfStatus.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterIfStatus.setDescription('An indication of whether the presense of an IP multicast router on this interface is to be determined statically or dynamically. The values routerPresent(1) and noRouter(2) indicate that the presence of a router is statically determined to be present or not-present, respectively. The value dynamic(3) indicates the presence is to be determined dynamically.')
igmpCondFilterIfRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 3, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCondFilterIfRouter.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterIfRouter.setDescription('An indication of whether an IP multicast router is present on this interface.')
igmpCondFilterMcastTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4), )
if mibBuilder.loadTexts: igmpCondFilterMcastTable.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastTable.setDescription('The table containing information on IP multicast groups for use with IGMP Conditional Filtering.')
igmpCondFilterMcastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1), ).setIndexNames((0, "CISCO-IPMCAST-MIB", "igmpCondFilterMcastIfIndex"), (0, "CISCO-IPMCAST-MIB", "igmpCondFilterMcastAddress"))
if mibBuilder.loadTexts: igmpCondFilterMcastEntry.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastEntry.setDescription('An entry in the igmpCondFilterMcastTable containing information on a particular IP multicast group on a particular interface. An entry is created by the agent when it receives on the interface either an IP multicast datagram destined to the multicast group, or an IGMP Membership Report for the group. An entry can also be created by network management to indicate that datagrams for the multicast group are to be forwarded to the interface irrespective of the receipt/non-receipt of IGMP Membership Reports.')
igmpCondFilterMcastIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: igmpCondFilterMcastIfIndex.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastIfIndex.setDescription('The ifIndex value of the interface.')
igmpCondFilterMcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 2), IpAddress())
if mibBuilder.loadTexts: igmpCondFilterMcastAddress.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastAddress.setDescription('The IP multicast group.')
igmpCondFilterMcastMember = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igmpCondFilterMcastMember.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastMember.setDescription('An indication of whether there is currently a member of the IP multicast group on this interface.')
igmpCondFilterMcastInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCondFilterMcastInPkts.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastInPkts.setDescription('The number of IP multicast datagrams destined for this multicast address which have been received on this interface.')
igmpCondFilterMcastOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCondFilterMcastOutPkts.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastOutPkts.setDescription('The number of IP multicast datagrams destined for this multicast address which have been forwarded to this interface.')
igmpCondFilterMcastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 4, 1, 3, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igmpCondFilterMcastStatus.setStatus('current')
if mibBuilder.loadTexts: igmpCondFilterMcastStatus.setDescription('The status of this row. If a row is created for a IP multicast group on a particular interface with the instance of igmpCondFilterMcastMember set to true(1), then datagrams destined to the multicast group are to be forwarded to the interface independent of whether IGMP Membership Reports are received.')
ciscoMcastMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 2))
ciscoMcastMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 1))
ciscoMcastMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 2))
ciscoMcastMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 1, 1)).setObjects(("CISCO-IPMCAST-MIB", "ciscoMcastAccessMIBGroup"), ("CISCO-IPMCAST-MIB", "ciscoMrbranchMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMcastMIBCompliance = ciscoMcastMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoMcastMIBCompliance.setDescription('The compliance statement for routers implementing the Cisco-specific IP Multicast MIB.')
ciscoMcastCondFilterMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 1, 2)).setObjects(("CISCO-IPMCAST-MIB", "ciscoMcastFilterMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMcastCondFilterMIBCompliance = ciscoMcastCondFilterMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoMcastCondFilterMIBCompliance.setDescription('The compliance statement for bridges/switches which implement Conditional IGMP Filtering.')
ciscoMcastAccessMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 2, 1)).setObjects(("CISCO-IPMCAST-MIB", "pimRpAccessListNumber"), ("CISCO-IPMCAST-MIB", "pimRpAccessListStatus"), ("CISCO-IPMCAST-MIB", "igmpAccessListNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMcastAccessMIBGroup = ciscoMcastAccessMIBGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoMcastAccessMIBGroup.setDescription('A collection of objects providing management of Access- Lists for IP Multicast in Cisco routers.')
ciscoMrbranchMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 2, 2)).setObjects(("CISCO-IPMCAST-MIB", "mrbranchState"), ("CISCO-IPMCAST-MIB", "mrbranchGroup"), ("CISCO-IPMCAST-MIB", "mrbranchBranch"), ("CISCO-IPMCAST-MIB", "mrbranchTimeout"), ("CISCO-IPMCAST-MIB", "mrbranchRequestor"), ("CISCO-IPMCAST-MIB", "mrbranchResponseRtt"), ("CISCO-IPMCAST-MIB", "mrbranchResponseRPF"), ("CISCO-IPMCAST-MIB", "mrbranchInterfaceListNetMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMrbranchMIBGroup = ciscoMrbranchMIBGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoMrbranchMIBGroup.setDescription('A collection of objects providing for the invocation of mrbranch commands in Cisco routers.')
ciscoMcastFilterMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 4, 2, 2, 3)).setObjects(("CISCO-IPMCAST-MIB", "igmpConditionalFilteringEnable"), ("CISCO-IPMCAST-MIB", "igmpMemberReportTimeout"), ("CISCO-IPMCAST-MIB", "igmpCondFilterIfStatus"), ("CISCO-IPMCAST-MIB", "igmpCondFilterIfRouter"), ("CISCO-IPMCAST-MIB", "igmpCondFilterMcastMember"), ("CISCO-IPMCAST-MIB", "igmpCondFilterMcastInPkts"), ("CISCO-IPMCAST-MIB", "igmpCondFilterMcastOutPkts"), ("CISCO-IPMCAST-MIB", "igmpCondFilterMcastStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMcastFilterMIBGroup = ciscoMcastFilterMIBGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoMcastFilterMIBGroup.setDescription('A collection of objects for management of bridges/switches which implement IGMP Conditional Filtering.')
mibBuilder.exportSymbols("CISCO-IPMCAST-MIB", mcastAccess=mcastAccess, mrbranchBranch=mrbranchBranch, igmpCondFilterIfEntry=igmpCondFilterIfEntry, igmpCondFilterMcastInPkts=igmpCondFilterMcastInPkts, pimRpAccessListRP=pimRpAccessListRP, igmpCondFilterIfStatus=igmpCondFilterIfStatus, pimRpAccessListNumber=pimRpAccessListNumber, mrbranchResponseEntry=mrbranchResponseEntry, ciscoMcastMIBConformance=ciscoMcastMIBConformance, igmpCondFilterMcastIfIndex=igmpCondFilterMcastIfIndex, mrbranchTimeout=mrbranchTimeout, igmpAccessListNumber=igmpAccessListNumber, mrbranchResponseRtt=mrbranchResponseRtt, igmpCondFilterIfRouter=igmpCondFilterIfRouter, igmpCondFilterMcastMember=igmpCondFilterMcastMember, ciscoMcastMIBCompliance=ciscoMcastMIBCompliance, mrbranchState=mrbranchState, ciscoMcastFilterMIBGroup=ciscoMcastFilterMIBGroup, igmpCondFilterMcastOutPkts=igmpCondFilterMcastOutPkts, mrbranchResponseTable=mrbranchResponseTable, pimRpAccessListStatus=pimRpAccessListStatus, igmpMemberReportTimeout=igmpMemberReportTimeout, mrbranchInterfaceListTable=mrbranchInterfaceListTable, mrbranchResponseResponder=mrbranchResponseResponder, igmpCondFilterMcastAddress=igmpCondFilterMcastAddress, pimRpAccessListTable=pimRpAccessListTable, igmpCondFilterMcastEntry=igmpCondFilterMcastEntry, mcastFilter=mcastFilter, mrbranchInterfaceListAddress=mrbranchInterfaceListAddress, PYSNMP_MODULE_ID=ciscoMcastMIB, mrbranchResponseRPF=mrbranchResponseRPF, ciscoMcastMIBCompliances=ciscoMcastMIBCompliances, ciscoMcastCondFilterMIBCompliance=ciscoMcastCondFilterMIBCompliance, mrbranchRequestor=mrbranchRequestor, mrbranchGroup=mrbranchGroup, igmpCondFilterIfIndex=igmpCondFilterIfIndex, ciscoMcastMIBGroups=ciscoMcastMIBGroups, ciscoMrbranchMIBGroup=ciscoMrbranchMIBGroup, pimRpAccessListEntry=pimRpAccessListEntry, ciscoMcastMIB=ciscoMcastMIB, ciscoMcastAccessMIBGroup=ciscoMcastAccessMIBGroup, mcastTraceRequest=mcastTraceRequest, mcastTraceResponse=mcastTraceResponse, mcastTrace=mcastTrace, igmpAccessListTable=igmpAccessListTable, ciscoMcastMIBObjects=ciscoMcastMIBObjects, igmpCondFilterMcastStatus=igmpCondFilterMcastStatus, igmpCondFilterMcastTable=igmpCondFilterMcastTable, mrbranchInterfaceListEntry=mrbranchInterfaceListEntry, igmpConditionalFilteringEnable=igmpConditionalFilteringEnable, mrbranchInterfaceListNetMask=mrbranchInterfaceListNetMask, igmpCondFilterIfTable=igmpCondFilterIfTable, igmpAccessListEntry=igmpAccessListEntry)

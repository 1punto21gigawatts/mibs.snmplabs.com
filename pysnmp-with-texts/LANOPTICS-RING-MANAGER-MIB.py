#
# PySNMP MIB module LANOPTICS-RING-MANAGER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LANOPTICS-RING-MANAGER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:05:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, iso, NotificationType, Counter32, Integer32, TimeTicks, enterprises, Bits, Gauge32, ModuleIdentity, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Unsigned32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "iso", "NotificationType", "Counter32", "Integer32", "TimeTicks", "enterprises", "Bits", "Gauge32", "ModuleIdentity", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Unsigned32", "ObjectIdentity")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
class BITMAP(Integer32):
    pass

class RING_CONFIGURATION(OctetString):
    pass

lanOptics = MibIdentifier((1, 3, 6, 1, 4, 1, 224))
lanOpticsDot5Monitor = MibIdentifier((1, 3, 6, 1, 4, 1, 224, 5))
rmServerReportingTo = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmServerReportingTo.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerReportingTo.setDescription('This gives the IP address for the reporting manager.')
rmRingStatus = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("beaconing", 1), ("single-station", 2), ("errors-increasing", 3), ("excessive-errors", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingStatus.setDescription('This variable indicates the curent ring status.')
rmServerHealthText = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmServerHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerHealthText.setDescription('This variable describes the status of the ring server in a textural manner.')
rmServerHealth = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initial-State", 1), ("not-Active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmServerHealth.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerHealth.setDescription('This variable will describe the status of the ring server.')
rmRingEventInLog = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingEventInLog.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingEventInLog.setDescription('The number of events currently in the internal event log.')
rmRingEventTable = MibTable((1, 3, 6, 1, 4, 1, 224, 5, 6), )
if mibBuilder.loadTexts: rmRingEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingEventTable.setDescription('A table containing the last events. The detailed structure is TBD.')
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 6, 1) + (1000, ), Integer32())
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 6, 1) + (1001, ), Integer32())
pysmiFakeCol1002 = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 6, 1) + (1002, ), Integer32())
pysmiFakeCol1003 = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 6, 1) + (1003, ), Integer32())
rmRingEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 224, 5, 6, 1), ).setIndexNames((0, "LANOPTICS-RING-MANAGER-MIB", "pysmiFakeCol1000"), (0, "LANOPTICS-RING-MANAGER-MIB", "pysmiFakeCol1001"), (0, "LANOPTICS-RING-MANAGER-MIB", "pysmiFakeCol1002"), (0, "LANOPTICS-RING-MANAGER-MIB", "pysmiFakeCol1003"))
if mibBuilder.loadTexts: rmRingEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingEventEntry.setDescription('An entry containing one event. The index into the table is the event number (32 bits int), where each byte represented by an index digit.')
rmRingEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 6, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingEvent.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingEvent.setDescription('This variable will give the data structure describing a ring event in an internal format')
rmRingBeaconingStatus = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingBeaconingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingBeaconingStatus.setDescription('This variable will give the data structure describing the beaconing state of the ring.')
rmRingIsoErrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingIsoErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingIsoErrorStatus.setDescription('This variable will give the data structure describing the isolating error state of the ring.')
rmRingSingleStationStatus = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingSingleStationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingSingleStationStatus.setDescription('This variable will give the data structure describing the single station state of the ring.')
rmRingFullConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 10), RING_CONFIGURATION()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingFullConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingFullConfiguration.setDescription('This variable gives the ring configuration as known to the server. Each MAC address is represented by 6 bytes. The direction is up-stream.')
rmRingConfigurationUpdate = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 11), RING_CONFIGURATION()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingConfigurationUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingConfigurationUpdate.setDescription('This variable will give a sequence of changes in the ring configuration for the monitored ring.')
rmServerInitProcess = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmServerInitProcess.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerInitProcess.setDescription('This variable will initialize the server (reset the management module).')
rmServerAdminState = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 13), BITMAP()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmServerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerAdminState.setDescription('This variable will indicate administrative status of the server. IDLE - 0 The bit # (LSB = 0): REM - bit 0 on CRS - bit 1 on RPS - bit 2 on LBS - bit 3 on')
rmServerOperatingState = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 14), BITMAP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmServerOperatingState.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerOperatingState.setDescription('This variable will indicate operating status of the server: IDLE - all 0 The bit # (LSB = 0): REM - bit 0 on CRS - bit 1 on RPS - bit 2 on LBS - bit 3 on')
rmServerAdminParameters = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 15), BITMAP()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmServerAdminParameters.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerAdminParameters.setDescription('The required bit per event disabled/enabled. The bit # (LSB = 0): Nullevent(0), Nodenoresponseevent(1), Pollprocessfailevent(2), Criticnodejoinedringevent(3), Noderemovedevent(4), Activemonitorerrorevent(5), Newactivemonitorevent(6), Naunchangeevent(7), Claimtokenevent(8), Ringpurgeevent(9), Activemonitorpresentevent(10), Standbymonitorpresentevent(11), Softerrorreportevent(12), Ringstatusevent(13), Congestthresholdexccededevent(14), Congestthresholdendedevent(15), Nonisolatingthresholdexccededevent(16), Impendthresholdexccededevent(17), Excessivethresholdexcededevent(18), Errorratedecayevent(19), Adaptererrorevent(20), Responseevent(21), Pollprocessevent(22), Beaconevent(23), Nodeleftringevent(24), Nodejoinedringevent(25), Criticnodeleftringevent(26)')
rmServerOperatingParameters = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 16), BITMAP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmServerOperatingParameters.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerOperatingParameters.setDescription('The required bit per event disabled/enabled. The bit # (LSB = 0): Nullevent(0), Nodenoresponseevent(1), Pollprocessfailevent(2), Criticnodejoinedringevent(3), Noderemovedevent(4), Activemonitorerrorevent(5), Newactivemonitorevent(6), Naunchangeevent(7), Claimtokenevent(8), Ringpurgeevent(9), Activemonitorpresentevent(10), Standbymonitorpresentevent(11), Softerrorreportevent(12), Ringstatusevent(13), Congestthresholdexccededevent(14), Congestthresholdendedevent(15), Nonisolatingthresholdexccededevent(16), Impendthresholdexccededevent(17), Excessivethresholdexcededevent(18), Errorratedecayevent(19), Adaptererrorevent(20), Responseevent(21), Pollprocessevent(22), Beaconevent(23), Nodeleftringevent(24), Nodejoinedringevent(25), Criticnodeleftringevent(26)')
rmDeviceStatusTable = MibTable((1, 3, 6, 1, 4, 1, 224, 5, 17), )
if mibBuilder.loadTexts: rmDeviceStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rmDeviceStatusTable.setDescription('A table containing device parameters and configuration.')
rmDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 224, 5, 17, 1), ).setIndexNames((0, "LANOPTICS-RING-MANAGER-MIB", "rmDeviceMacAddress"))
if mibBuilder.loadTexts: rmDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmDeviceEntry.setDescription('An entry containing device parameters and configuration. The index to the table is the MAC address of the device.')
rmDeviceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceMacAddress.setStatus('mandatory')
rmDeviceUpstream = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceUpstream.setStatus('mandatory')
rmDeviceAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("removed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmDeviceAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: rmDeviceAdminState.setDescription('The required state of the adapter. - only removed is supported.')
rmDeviceOperateState = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("removed", 4), ("neverInserted", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceOperateState.setStatus('mandatory')
if mibBuilder.loadTexts: rmDeviceOperateState.setDescription(' The operating state of the adapter.')
rmDevicePhysLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDevicePhysLocation.setStatus('mandatory')
rmDeviceGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceGroupAddress.setStatus('mandatory')
rmDeviceFunctionAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceFunctionAddress.setStatus('mandatory')
rmDeviceProductID = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceProductID.setStatus('mandatory')
rmDeviceStationID = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceStationID.setStatus('mandatory')
rmDeviceStationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceStationStatus.setStatus('mandatory')
rmDeviceFunctionClass = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceFunctionClass.setStatus('mandatory')
rmDeviceAccessPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceAccessPriority.setStatus('mandatory')
rmDeviceMicroLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceMicroLevel.setStatus('mandatory')
rmDeviceMonitored = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceMonitored.setStatus('mandatory')
rmDeviceDaysAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceDaysAllowed.setStatus('mandatory')
rmDeviceHoursAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 224, 5, 17, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmDeviceHoursAllowed.setStatus('mandatory')
rmRingPollProcessStatus = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingPollProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingPollProcessStatus.setDescription('This variable will give the data structure describing the poll process status of the ring.')
rmRingNumber = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingNumber.setDescription('This variable will give the local ring number.')
rmRingSoftErrorTimer = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingSoftErrorTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingSoftErrorTimer.setDescription('This variable will give the ring soft error timer (in units of 10 milliseconds).')
rmRingIsolatingTab = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 37), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingIsolatingTab.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingIsolatingTab.setDescription('This variable will give the ring isolating table.')
rmRingCongestTab = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 38), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingCongestTab.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingCongestTab.setDescription('This variable will give the ring congestion table.')
rmRingNonIsolatingTab = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 39), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingNonIsolatingTab.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingNonIsolatingTab.setDescription('This variable will give the ring non isolating table.')
rmRingAutoRemove = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmRingAutoRemove.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingAutoRemove.setDescription('This variable will enable/disable auto removal of a node when the isolating threshold is exceeded or the congestion threshold is exceeded.')
rmRingAllowedDaysPartition1 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmRingAllowedDaysPartition1.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingAllowedDaysPartition1.setDescription('This variable is the first partition in the days time exis. The partitions define ranges in units of days in which some device are allowed to enter the ring and some are not.')
rmRingAllowedDaysPartition2 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmRingAllowedDaysPartition2.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingAllowedDaysPartition2.setDescription('This variable is the second partition in the days time exis. The partitions define ranges in units of days in which some devices are allowed to enter the ring and some are not. The value should be higher than Partition1')
rmRingAllowedHoursPartition1 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmRingAllowedHoursPartition1.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingAllowedHoursPartition1.setDescription('This variable is the first partition in the hours time exis. The partitions define ranges in units of hours (1-24 hours) in which some devices are allowed to enter the ring and some are not.')
rmRingAllowedHoursPartition2 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmRingAllowedHoursPartition2.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingAllowedHoursPartition2.setDescription('This variable is the second partition in the hours time exis. The partitions define ranges in units of hours (1-24 hours) in which some devices are allowed to enter the ring and some are not. The value should be higher than Partition1.')
rmServerPowerOn = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmServerPowerOn.setStatus('mandatory')
if mibBuilder.loadTexts: rmServerPowerOn.setDescription('This variable indicates if the server is powered on since the last poll.')
rmTRLastErrorClass = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("adapter-error", 1), ("beaconing", 2), ("iso-increasing", 3), ("iso-excessive", 4), ("iso-decay", 5), ("congestion", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmTRLastErrorClass.setStatus('mandatory')
if mibBuilder.loadTexts: rmTRLastErrorClass.setDescription('This var contains the error class of the last Token-Ring error reported by the agent.')
rmTRLastErrorType = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmTRLastErrorType.setStatus('mandatory')
if mibBuilder.loadTexts: rmTRLastErrorType.setDescription('This var contains the error type of the last Token-Ring error, depending on the error class')
rmTRFaultDomainNode1 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 50), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmTRFaultDomainNode1.setStatus('mandatory')
if mibBuilder.loadTexts: rmTRFaultDomainNode1.setDescription('This var contains the MAC address of the first node in the last error fault domain.')
rmTRFaultDomainNode2 = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 51), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmTRFaultDomainNode2.setStatus('mandatory')
if mibBuilder.loadTexts: rmTRFaultDomainNode2.setDescription('This var contains the MAC address of the second node in the last error fault domain.')
rmIsoTresholdExceededCount = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIsoTresholdExceededCount.setStatus('mandatory')
if mibBuilder.loadTexts: rmIsoTresholdExceededCount.setDescription('This var counts the total number that Isloating Treshold has been exceeded (exessive error status of the ring) since the agent is up or reset.')
rmNonIsoTresholdExceededCount = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmNonIsoTresholdExceededCount.setStatus('mandatory')
if mibBuilder.loadTexts: rmNonIsoTresholdExceededCount.setDescription('This var counts the total number that Non Isloating Treshold has been exceeded since the agent is up.')
rmCongestionTresholdExceededCount = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmCongestionTresholdExceededCount.setStatus('mandatory')
if mibBuilder.loadTexts: rmCongestionTresholdExceededCount.setDescription('This var counts the total number that Congestion Treshold has been exceeded since the agent is up.')
rmBeaconCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmBeaconCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmBeaconCounter.setDescription('This var counts the total number of Beacons for the whole ring since the agent is up.')
rmSpareCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmSpareCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmSpareCounter.setDescription('Spare Counter for future use')
rmPurgeCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmPurgeCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmPurgeCounter.setDescription('This var counts the total number of ring Purges since the agent is up.')
rmClaimCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmClaimCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmClaimCounter.setDescription('This var counts the total number of Token Claims since the agent is up.')
rmAdapterResetCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmAdapterResetCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmAdapterResetCounter.setDescription('This var counts the total number of times the agent adapter has to reset itself since the agent is up.')
rmLostFramesCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmLostFramesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmLostFramesCounter.setDescription('This var counts the total number of Lost Frames events for the whole ring since the agent is up.')
rmCongestionCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmCongestionCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmCongestionCounter.setDescription('This var counts the total number of Congestion events for the whole ring since the agent is up.')
rmFrameCopyCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmFrameCopyCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmFrameCopyCounter.setDescription('This var counts the total number of Frame Copy events for the whole ring since the agent is up.')
rmFrequencyErrorCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmFrequencyErrorCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmFrequencyErrorCounter.setDescription('This var counts the total number of Frequency Error events for the whole ring since the agent is up.')
rmTokenCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmTokenCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmTokenCounter.setDescription('This var counts the total number of Token error events for the whole ring since the agent is up.')
rmLineCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmLineCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmLineCounter.setDescription('This var counts the total number of Line error events for the whole ring since the agent is up.')
rmInternalCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmInternalCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmInternalCounter.setDescription('This var counts the total number of Internal error events for the whole ring since the agent is up.')
rmBurstCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmBurstCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmBurstCounter.setDescription('This var counts the total number of Burst error events for the whole ring since the agent is up.')
rmARIFCICounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmARIFCICounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmARIFCICounter.setDescription('This var counts the total number of ARI/FCI events for the whole ring since the agent is up.')
rmAbortCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmAbortCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmAbortCounter.setDescription('This var counts the total number of Abort events for the whole ring since the agent is up.')
rmPollFailCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 70), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmPollFailCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmPollFailCounter.setDescription('This var counts the total number of Poll Failed events for the whole ring since the agent is up.')
rmNoResponseCounter = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 71), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmNoResponseCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rmNoResponseCounter.setDescription('This var counts the total number of No Response events for the whole ring since the agent is up.')
rmWholeRingCounters = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 72), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmWholeRingCounters.setStatus('mandatory')
if mibBuilder.loadTexts: rmWholeRingCounters.setDescription('This var counts a list of all the above counters (52-71) for convenience. Each counter occupies 32 bits of this structure in the order of the related variables. For internal use only.')
rmResetOldDevicesSetup = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 73), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmResetOldDevicesSetup.setStatus('mandatory')
if mibBuilder.loadTexts: rmResetOldDevicesSetup.setDescription('This var resets existing agent setup for all devices, e.g: monitored, not-allowed, etc.')
rmResetErrorCounters = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 74), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmResetErrorCounters.setStatus('mandatory')
if mibBuilder.loadTexts: rmResetErrorCounters.setDescription('This var resets existing agent error counters.')
rmSetCurrentTime = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 75), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmSetCurrentTime.setStatus('mandatory')
if mibBuilder.loadTexts: rmSetCurrentTime.setDescription('This var sets the current time (for security settings). The time is the number of seconds elapsed since midnight, December 31, 1899. ')
rmRingFirstSplitConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 76), RING_CONFIGURATION()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingFirstSplitConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingFirstSplitConfiguration.setDescription("This variable will give the first part of the ring configuration upto 256 bytes including header (for agents with limited buffer for a single octet). Retrieving this variable and several 'nexts' enables to compose the whole ring configuration.")
rmRingNextSplitConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 224, 5, 77), RING_CONFIGURATION()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmRingNextSplitConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rmRingNextSplitConfiguration.setDescription('This variable will give the next part of the ring configuration relating to rmRingFirstSplitConfiguration or previous variable of this type. Upto 256 bytes are given (for agents with limited buffer for a single octet). See previous variable for more details.')
mibBuilder.exportSymbols("LANOPTICS-RING-MANAGER-MIB", rmRingSoftErrorTimer=rmRingSoftErrorTimer, rmNoResponseCounter=rmNoResponseCounter, rmRingAllowedDaysPartition2=rmRingAllowedDaysPartition2, rmRingIsoErrorStatus=rmRingIsoErrorStatus, rmServerOperatingParameters=rmServerOperatingParameters, rmRingBeaconingStatus=rmRingBeaconingStatus, rmIsoTresholdExceededCount=rmIsoTresholdExceededCount, rmDeviceProductID=rmDeviceProductID, rmRingFirstSplitConfiguration=rmRingFirstSplitConfiguration, rmARIFCICounter=rmARIFCICounter, rmDeviceMicroLevel=rmDeviceMicroLevel, rmRingAutoRemove=rmRingAutoRemove, rmDeviceGroupAddress=rmDeviceGroupAddress, rmInternalCounter=rmInternalCounter, rmDeviceFunctionAddress=rmDeviceFunctionAddress, rmTRFaultDomainNode2=rmTRFaultDomainNode2, rmRingEventEntry=rmRingEventEntry, pysmiFakeCol1002=pysmiFakeCol1002, rmRingAllowedHoursPartition1=rmRingAllowedHoursPartition1, rmRingNextSplitConfiguration=rmRingNextSplitConfiguration, rmDeviceMacAddress=rmDeviceMacAddress, rmBeaconCounter=rmBeaconCounter, rmPurgeCounter=rmPurgeCounter, rmRingEventInLog=rmRingEventInLog, rmRingAllowedDaysPartition1=rmRingAllowedDaysPartition1, rmFrequencyErrorCounter=rmFrequencyErrorCounter, rmResetErrorCounters=rmResetErrorCounters, rmServerAdminParameters=rmServerAdminParameters, rmRingConfigurationUpdate=rmRingConfigurationUpdate, rmRingEventTable=rmRingEventTable, rmDeviceStationID=rmDeviceStationID, rmRingEvent=rmRingEvent, rmDeviceFunctionClass=rmDeviceFunctionClass, rmFrameCopyCounter=rmFrameCopyCounter, rmDevicePhysLocation=rmDevicePhysLocation, rmLineCounter=rmLineCounter, BITMAP=BITMAP, rmServerHealth=rmServerHealth, rmCongestionTresholdExceededCount=rmCongestionTresholdExceededCount, rmRingFullConfiguration=rmRingFullConfiguration, rmServerInitProcess=rmServerInitProcess, rmServerAdminState=rmServerAdminState, rmDeviceMonitored=rmDeviceMonitored, rmSetCurrentTime=rmSetCurrentTime, rmDeviceOperateState=rmDeviceOperateState, rmDeviceAccessPriority=rmDeviceAccessPriority, rmServerReportingTo=rmServerReportingTo, rmNonIsoTresholdExceededCount=rmNonIsoTresholdExceededCount, rmAbortCounter=rmAbortCounter, rmAdapterResetCounter=rmAdapterResetCounter, rmTRFaultDomainNode1=rmTRFaultDomainNode1, pysmiFakeCol1003=pysmiFakeCol1003, rmLostFramesCounter=rmLostFramesCounter, RING_CONFIGURATION=RING_CONFIGURATION, rmCongestionCounter=rmCongestionCounter, rmServerOperatingState=rmServerOperatingState, rmRingCongestTab=rmRingCongestTab, lanOpticsDot5Monitor=lanOpticsDot5Monitor, rmDeviceHoursAllowed=rmDeviceHoursAllowed, rmResetOldDevicesSetup=rmResetOldDevicesSetup, rmRingStatus=rmRingStatus, rmClaimCounter=rmClaimCounter, rmWholeRingCounters=rmWholeRingCounters, pysmiFakeCol1001=pysmiFakeCol1001, pysmiFakeCol1000=pysmiFakeCol1000, rmServerPowerOn=rmServerPowerOn, lanOptics=lanOptics, rmRingNonIsolatingTab=rmRingNonIsolatingTab, rmTokenCounter=rmTokenCounter, rmDeviceUpstream=rmDeviceUpstream, rmRingIsolatingTab=rmRingIsolatingTab, rmDeviceStatusTable=rmDeviceStatusTable, rmRingPollProcessStatus=rmRingPollProcessStatus, rmBurstCounter=rmBurstCounter, rmSpareCounter=rmSpareCounter, rmDeviceAdminState=rmDeviceAdminState, rmTRLastErrorType=rmTRLastErrorType, rmRingNumber=rmRingNumber, rmPollFailCounter=rmPollFailCounter, rmRingAllowedHoursPartition2=rmRingAllowedHoursPartition2, rmDeviceEntry=rmDeviceEntry, rmServerHealthText=rmServerHealthText, rmRingSingleStationStatus=rmRingSingleStationStatus, rmDeviceStationStatus=rmDeviceStationStatus, rmDeviceDaysAllowed=rmDeviceDaysAllowed, rmTRLastErrorClass=rmTRLastErrorClass)

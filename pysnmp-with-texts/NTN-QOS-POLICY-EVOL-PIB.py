#
# PySNMP MIB module NTN-QOS-POLICY-EVOL-PIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NTN-QOS-POLICY-EVOL-PIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
bnIfExtnSlot, bnIfExtnPort = mibBuilder.importSymbols("BN-IF-EXTENSIONS-MIB", "bnIfExtnSlot", "bnIfExtnPort")
Dscp, DscpOrAny = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp", "DscpOrAny")
IndexInteger, IndexIntegerNextFree = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexInteger", "IndexIntegerNextFree")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressPrefixLength, InetAddress, InetAddressType, InetPortNumber, InetAddressIPv4 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddress", "InetAddressType", "InetPortNumber", "InetAddressIPv4")
BurstSize, = mibBuilder.importSymbols("INTEGRATED-SERVICES-MIB", "BurstSize")
Role, RoleCombination = mibBuilder.importSymbols("POLICY-FRAMEWORK-PIB", "Role", "RoleCombination")
PortList, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList", "VlanId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, IpAddress, iso, Counter32, Gauge32, ObjectIdentity, Bits, Counter64, ModuleIdentity, zeroDotZero, TimeTicks, Unsigned32, MibIdentifier, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "IpAddress", "iso", "Counter32", "Gauge32", "ObjectIdentity", "Bits", "Counter64", "ModuleIdentity", "zeroDotZero", "TimeTicks", "Unsigned32", "MibIdentifier", "NotificationType")
RowPointer, TruthValue, MacAddress, StorageType, TextualConvention, RowStatus, AutonomousType, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TruthValue", "MacAddress", "StorageType", "TextualConvention", "RowStatus", "AutonomousType", "DisplayString")
policy, = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "policy")
ntnQosPolicyEvolPib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7))
ntnQosPolicyEvolPib.setRevisions(('2015-02-20 00:00', '2014-04-03 00:00', '2014-02-14 00:00', '2012-06-14 00:00', '2012-05-16 00:00', '2012-03-16 00:00', '2012-01-13 00:00', '2011-07-26 00:00', '2011-07-15 00:00', '2011-04-15 00:00', '2010-03-08 00:00', '2010-01-05 00:00', '2009-11-05 00:00', '2009-08-11 00:00', '2009-03-26 00:00', '2009-01-05 00:00', '2008-11-05 00:00', '2008-07-09 00:00', '2008-07-02 00:00', '2008-06-26 00:00', '2008-05-29 00:00', '2006-09-28 00:00', '2006-04-21 00:00', '2005-02-03 00:00', '2004-10-25 00:00', '2004-09-20 00:00', '2004-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ntnQosPolicyEvolPib.setRevisionsDescriptions(('Version 35: Added new values for ntnQosPolicyClassifierType.', 'Version 34: Added description for martian packets in ntnDsMultiFieldClfrAddrType', 'Version 33: Added spb-scaled(6) value for ntnQosConfigDefaultBufferingCaps object.', 'Version 32: Added untrustedv4v6 and untrustedBasic values for ntnQosInterfaceRoleIfClass object.', 'Version 31: updated compliance data. Compliance data was not provided for a number of objects that were previously defined. This causes issues for certain levels of MIB compilation. Updated QoS buffer allocation options.', 'Version 30: Added FCoE application objects, including the avFcoeRedirTable and scalars ntnQosConfigFcoeRedirOperMode, ntnQosConfigFcoeControllerMacAddr, ntnQosConfigFcoeRedirAvail, ntnQosConfigFcoeControllerIfIndex, ntnQosConfigFcoeControllerVlan and avFcoeRedirNextFree. FCoE-related notification defined.', 'Version 29: Augmented enumerations for the following attributes: ntnQosDsL2AccessElemActionRemarkCos, ntnQosDsL2AccessElemOutActionRemarkCos, ntnQosDsL2AccessElemYelActionRemarkCos and ntnQosAccessAsgnOutActionRemarkCos.', 'Version 28: Added ntnQosPolicyMeteringMode.', 'Version 27: Added ntnQosPolicyPrecResDiagsRangeChkElemsAvail.', 'Version 26: Added ntnQosConfigClearStats.', 'Version 25: Added ntnQosFilterLimiting.', 'Version 24: Introduced enhanced Traffic-Profile filter set metering support.', 'Version 23: Added ntnQosConfigResetToPartialDefaults to support a partial QoS reset-to-defaults operation. Added ntnQosDsL2AccessElemMasterBlockMember to support an explicit filter set block member hierarchy. Added ntnSystemClfrPatternL2Format to support pattern matching with different L2 frame formats. Added ntnQosFilterSetStatsTable to facilitate statistics retrieval for filter sets.', 'Version 22: Added lossless(4) to ntnQosConfigDefaultBufferingCaps.', 'Version 21: Added Trusted Processing Mode object.', 'Version 20: Added QoS system disable support. Added objects supporting improved multicast filtering granularity. Augmented available filter set types. New interface shaping objects defined. DSCP mutation object added to DSCP Mapping table.', "Version 19: Added support for 'quick policies'.", 'Version 18: Updated descr of ntnQosConfigNtApplicationMode.', 'Version 17: Added markAsPriorityCopy(13) enumeration to ntnQosBaseActionUpdateUserPriority.', 'Version 16: Added support for Discard Eligible Indicator in the ntnQosDEITable - DEI allows using CFI bit in the vlan tag as the packet color when a packet ingress a port; at egress the packet color is written to CFI bit. Ingress and egress CFI to packet color mappings can be enabled on each interface. Added QinQ traffic classification criteria support in ntnL2MultiFieldClfrTable table. QinQ encapsulation is specified in IEEE 802.1ad. A packet can ingress a port with two vlan tags. New classification criteria support were added to allow classification on both Inner/Outer Tags. For both Tags the user can classify based on the Tag Protocol Identifier, Vlan Id, Priority and CFI.', 'Version 15: Added support for native DoS attack detection package (DAPP). Updated interface capabilities, QoS Agent configuration and Notification definitions. Added filtering options to the DS/L2 meta-table ntnQosDsL2AccessElem. Added ntnQosPolicyPrecResDiagsApplicationIdUsed & ntnQosPolicyPrecResDiagsApplicationNameUsed. Added ntnQosConfigNtApplicationMode object (NT-on-NT support) and ntnQosAccessAsgnSetPriority object (filter set prioritization support). Defined ntnQosInterfaceRoleStatsTrackingType to expose the statistics tracking mode that is associated with a role.', 'Version 13: Introduced stratification of capabilities across a number of tables including all classifier, metering and policy tables. Defined new attributes in these tables as well to support new functionality. Clarified capabilities support in the Interface Role Table and defined per-interface capabilities attribute in the Interface Assignment Table. Added COS queue shaping support. Added srTCM/trTCM metering support to the Access Assignment Table. Added policy resource usage reporting attributes for an architecture in which resources are centrally allocated.', 'Version 12: Added notification support for user access rejection related to local User Based Policies (UBP) support in high-security mode. Added session Id data to several tables in support of User Based Policies (UBP). Added agent attribute to allow the administrator to specify the type UBP support that is enabled. Updated filter set support to accept UBP components. Updated support element types in Access Element and Access Assignment tables. Added DS/L2 Access Element Table. Added evaluation order attribute and new type support to the DS/L2 Access Element tables in support of NSNA. Added non-match drop action support in the Access Assignment Table. Added additional applications bits to the ntnQosIfAppsAppEnable attribute. Fixed ntnQosPolicyInterfaceIndex syntax clause', 'Version 11: Added ntnQosIfAppsTable to support interface-based QoS security applications', 'Version 10: Added ntnSystemClfrPatternFormat and updated for DS/L2 Access Element and Access Assignment definitions', 'Version 9: Added ntnQosMappingRestoreDefault, ntnQosMappingDscpToCosEnabled, and ntnQosMappingCosToDscpEnabled', 'Version 8: Added version info',))
if mibBuilder.loadTexts: ntnQosPolicyEvolPib.setLastUpdated('201502200000Z')
if mibBuilder.loadTexts: ntnQosPolicyEvolPib.setOrganization('Avaya Networks, Inc.')
if mibBuilder.loadTexts: ntnQosPolicyEvolPib.setContactInfo(' John Seligson Avaya Networks, Inc. 4655 Great America Parkway Santa Clara, CA 95054 USA Phone: +1 408 496 3424 Email: jseligso@avaya.com')
if mibBuilder.loadTexts: ntnQosPolicyEvolPib.setDescription("An Avaya Network's management module containing data definitions related to QoS components and services supported by network devices.")
class IndexIntegerOrZero(TextualConvention, Unsigned32):
    description = 'An integer which may be used as a table index. A value of zero indicates that no table index has been specified.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class QosIeee802Cos(TextualConvention, Integer32):
    description = 'An integer that is in the range of the IEEE 802 COS values. This corresponds to the 802.1p priority values.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class FlowIdOrAny(TextualConvention, Integer32):
    description = 'The flow identifier in an IPv6 header that may be used to discriminate traffic flows. The value of -1 is used to indicate a wildcard, i.e., any value.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 1048575), )
class DscpUpdate(TextualConvention, Integer32):
    description = 'The IP header Differentiated Services Code-Point that may be used for discriminating among traffic streams. The value -1 is used to indicate that the DSCP value should not be updated. The value 64 is used to indicate that the DSCP value should be updated using interface-specific (i.e., ingress interface) or Layer 2 (i.e., 802.1p user priority value) data to determine the appropriate DSCP value.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), ValueRangeConstraint(64, 64), )
class VersionIndicator(TextualConvention, Integer32):
    description = 'A version indicator is used when different versions of a given table entry exist. The version itself specifies which attributes in an entry may be set to non-default values. Tables that include a version indicator attribute must indicate the versions to which each attribute is applicable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("version1", 1), ("version2", 2))

class FcId(TextualConvention, OctetString):
    description = 'Represents a Fibre Channel address'
    status = 'current'
    displayHint = '1x.1x.1x'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class InterfaceList(TextualConvention, OctetString):
    description = 'Each bit of this bit mask corresponds to an ifIndex value, with the most significant bit of the i-th octet of this octet string corresponding to the ((8*i) - 7)-th ifIndex, and the least significant bit of the i-th octet corresponding to the (8*i)-th ifIndex.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 128)

ntnQosPolicyEvolPibClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1))
ntnQosPolicyEvolPibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 2))
ntnQosPolicyEvolPibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 3))
ntnQosInterfaceTypeTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1), )
if mibBuilder.loadTexts: ntnQosInterfaceTypeTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeTable.setDescription('Interface type definitions. This class describes the types of interfaces that exist on the device. An interface type is denoted by its designated role identifier.')
ntnQosInterfaceTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeId"))
if mibBuilder.loadTexts: ntnQosInterfaceTypeEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeEntry.setDescription('An instance of this class describes the characteristics of a type of an interface. Interface type characteristics include a role combination identifier, an interface class designation and a filter capabilities attribute. An instance is required for each different unique role combination identifier which represents the different interface types that are operational in the device at any given time. The PEP does not report which specific interfaces have which characteristics.')
ntnQosInterfaceTypeId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosInterfaceTypeId.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeId.setDescription('An arbitrary integer index that uniquely identifies a instance of the ntnQosInterfaceType class. Class instances may not be contiguous.')
ntnQosInterfaceTypeRoles = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 2), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeRoles.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeRoles.setDescription('The role combination that is used to identify interfaces with the characteristics specified by the attributes of this class instance. Interface role combination identifiers are used within a number of classes to logically identify a physical set of interfaces to which policy rules and actions are applied. Role combination identifiers must exist in this table prior to being referenced in other class instances.')
ntnQosInterfaceTypeIfClass = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trusted", 1), ("nonTrusted", 2), ("unrestricted", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeIfClass.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeIfClass.setDescription('A value describing the overall classification of traffic received on interfaces with the given role combination. Traffic received on trusted interfaces may be processed differently and be subject to different restrictions that traffic received on non-trusted interfaces. The treatment of traffic based on interface class is implementation dependent.')
ntnQosInterfaceTypeCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 4), Bits().clone(namedValues=NamedValues(("other", 0), ("inputIpClassification", 1), ("outputIpClassification", 2), ("input802Classification", 3), ("output802Classification", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeCapabilities.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeCapabilities.setDescription('An enumeration of interface capabilities. Used by the PDP or network manager to select which policies and configuration it should push to the PEP.')
ntnQosInterfaceTypeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 5), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosInterfaceTypeStatus object is equal to active(1).')
ntnQosInterfaceTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosQsetPriAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2), )
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentTable.setDescription('Supports the assignment of 802.1p user priority values to a queue for each interface with a specific queue set. There will be 8 instances of this class for each supported queue set.')
ntnQosQsetPriAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentId"))
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentEntry.setDescription('An instance of the ntnQosQsetPriAssignment class.')
ntnQosQsetPriAssignmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentId.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentId.setDescription('An index that is used to uniquely identify the instance of the ntnQosQsetPriAssignment class.')
ntnQosQsetPriAssignmentQset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentQset.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentQset.setDescription("The queue set with which an interface must be configured to support the Pri-to-queue assignment described by this instance. The specified queue set must be defined in the ntnQosIfQueueTable prior to being referenced by this entry. Otherwise a 'priAssociationUnknown(3)' error code will be returned.")
ntnQosQsetPriAssignmentPri = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 3), QosIeee802Cos()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentPri.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentPri.setDescription('The 802.1p user priority to which this class instance applies.')
ntnQosQsetPriAssignmentQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentQueue.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentQueue.setDescription("The specific queue, within the queue set that is associated with the interface set identified by the ntnQosQsetPriAssignmentRoles tag, on which traffic with the specified user priority, dictated by the ntnQosQsetPriAssignmentPri value, is placed. Failure to specify an appropriate queue results in a 'priAssociationConflict(4)' error indication being returned.")
ntnQosQsetPriAssignmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 5), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosQsetPriAssignmentStatus object is equal to active(1).')
ntnQosQsetPriAssignmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosQsetDscpAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3), )
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentTable.setDescription('Supports the assignment of DSCP values to a queue for each interface with a specific queue set. There will be 64 instances of this class for each supported queue set.')
ntnQosQsetDscpAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentId"))
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentEntry.setDescription('An instance of the ntnQosQsetDscpAssignment class.')
ntnQosQsetDscpAssignmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentId.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentId.setDescription('An index that is used to uniquely identify the instance of the ntnQosQsetDscpAssignment class.')
ntnQosQsetDscpAssignmentQset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentQset.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentQset.setDescription("The queue set with which an interface must be configured to support the Dscp-to-queue assignment described by this instance. The specified queue set must be defined in the ntnQosIfQueueTable prior to being referenced by this entry. Otherwise a 'priAssociationUnknown(3)' error code will be returned.")
ntnQosQsetDscpAssignmentDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 3), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentDscp.setDescription('The DSCP value to which this class instance applies.')
ntnQosQsetDscpAssignmentQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentQueue.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentQueue.setDescription("The specific queue, within the queue set that is associated with the interface set identified by the ntnQosQsetDscpAssignmentRoles tag, on which traffic with the specified user priority, dictated by the ntnQosQsetDscpAssignmentDscp value, is placed. Failure to specify an appropriate queue results in a 'priAssociationConflict(4)' error indication being returned.")
ntnQosQsetDscpAssignmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 5), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosQsetDscpAssignmentStatus object is equal to active(1).')
ntnQosQsetDscpAssignmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosShapingParamsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4), )
if mibBuilder.loadTexts: ntnQosShapingParamsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsTable.setDescription('Supports the definition of shaping parameters that can be applied to individual flows. Shaping criteria is associated with a flow using the qosTargetShaper attribute of the qosTarget class.')
ntnQosShapingParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsId"))
if mibBuilder.loadTexts: ntnQosShapingParamsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsEntry.setDescription('An instance of the ntnQosShapingParams class.')
ntnQosShapingParamsId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosShapingParamsId.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsId.setDescription('An index that is used to uniquely identify the instance of the ntnQosShapingParams class.')
ntnQosShapingParamsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsRate.setDescription('The maximum rate, in kilobits per second, at which traffic shaped using this rate criteria will be transmitted over a given period of time. Transmitted traffic may exceed this rate for short periods in accordance with the associated burst size. Typically, this value specifies the rate at which tokens are added to a token bucket used to shape flows. This object specifies a rate in kilobits per second units such that, for example, a value of 100 equates to a shaped flow being transmitted at a maximum rate of 100,000 bits per second.')
ntnQosShapingParamsBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsBurstSize.setDescription('The maximum traffic burst size, in bytes, that can be transmitted without experiencing a shaping delay. Typically, this value represents the maximum number of tokens in a token bucket. Note that the value of this attribute may modified in an implementation dependent, such as being rounded down to an acceptable value, to account for system limitations.')
ntnQosShapingParamsQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("onePkt", 1), ("twoPkts", 2), ("fourPkts", 3), ("eightPkts", 4), ("sixteenPkts", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsQueueSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsQueueSize.setDescription("The amount of traffic, in packets, that may exceed the maximum burst size and still be queued for transmission. This value specifies the size of a shaping queue that holds a flow's traffic that is being delayed for shaping purposes. The specified enumeration dictates whether one ('onePkt'), two ('twoPkts'), four ('fourPkts'), eight, ('eightPkts') or sixteen ('sixteenPkts') packets can be held in the shaping queue prior to transmission.")
ntnQosShapingParamsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 5), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosQsetDscpAssignmentStatus object is equal to active(1).')
ntnQosShapingParamsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosShapingParamsLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 4, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosShapingParamsLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsLabel.setDescription('A label used to reference the entry in a textual manner.')
ntnClassifierClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5))
ntnDsMultiFieldClfrNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrNextFree.setDescription('This object contains an unused value for ntnDsMultiFieldClfrId, or a zero to indicate that none exist.')
ntnDsMultiFieldClfrTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2), )
if mibBuilder.loadTexts: ntnDsMultiFieldClfrTable.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrTable.setDescription('A table of IP Multi-Field Classifier filter entries that a system may use to identify IP traffic.')
ntnDsMultiFieldClfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrId"))
if mibBuilder.loadTexts: ntnDsMultiFieldClfrEntry.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrEntry.setDescription('An IP Multi-Field Classifier entry describes a single filter.')
ntnDsMultiFieldClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnDsMultiFieldClfrId.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrId.setDescription('An index that enumerates the Multi-Field Classifier filter entries. Managers obtain new values for row creation in this table by reading ntnDsMultiFieldClfrNextFree. Version 1/2 attribute.')
ntnDsMultiFieldClfrAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrAddrType.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrAddrType.setDescription('The type of IP address used by this classifier entry. While other types of addresses are defined in the InetAddressType textual convention, and DNS names, a classifier can only look at packets on the wire. Therefore, this object is limited to IPv4 and IPv6 addresses, with the exception of releases that support the logging of martian packets. Instead of IPv4z and IPv6z, the martian variants of IPv4 and IPv6 are used. Version 1/2 attribute.')
ntnDsMultiFieldClfrDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstAddr.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstAddr.setDescription("The IP address to match against the packet's destination IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnDsMultiFieldClfrDstPrefixLength indicates the number of bits that are relevant. Version 1/2 attribute.")
ntnDsMultiFieldClfrDstPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 4), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnDsMultiFieldClfrDstAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128. Version 1/2 attribute.')
ntnDsMultiFieldClfrSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 5), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcAddr.setDescription("The IP address to match against the packet's source IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnDsMultiFieldClfrSrcPrefixLength indicates the number of bits that are relevant. Version 1/2 attribute.")
ntnDsMultiFieldClfrSrcPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 6), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnDsMultiFieldClfrSrcAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128. Version 1/2 attribute.')
ntnDsMultiFieldClfrDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 7), DscpOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDscp.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDscp.setDescription('The value that the DSCP in the packet must have to match this entry. A value of -1 indicates that a specific DSCP value has not been defined and thus all DSCP values are considered a match. Version 1/2 attribute.')
ntnDsMultiFieldClfrFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 8), FlowIdOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrFlowId.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrFlowId.setDescription('The flow identifier in an IPv6 header. Version 1/2 attribute.')
ntnDsMultiFieldClfrProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrProtocol.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrProtocol.setDescription('The IP protocol to match against the IPv4 protocol number or the IPv6 Next-Header number in the packet. A value of 255 means match all. Note the protocol number of 255 is reserved by IANA, and Next-Header number of 0 is used in IPv6. Version 1/2 attribute.')
ntnDsMultiFieldClfrDstL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. Version 1/2 attribute.')
ntnDsMultiFieldClfrDstL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 11), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrDstL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnDsMultiFieldClfrDstL4PortMin. Version 1/2 attribute.')
ntnDsMultiFieldClfrSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcL4PortMin.setDescription('The minimum value that the layer-4 source port number in the packet must have in order to match this classifier entry. Version 1/2 attribute.')
ntnDsMultiFieldClfrSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 13), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSrcL4PortMax.setDescription('The maximum value that the layer-4 source port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnDsMultiFieldClfrSrcL4PortMin. Version 1/2 attribute.')
ntnDsMultiFieldClfrStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 14), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrStorage.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnDsMultiFieldClfrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrStatus.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnDsMultiFieldClfrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrLabel.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrLabel.setDescription('A label used to reference the classifier entry in a textual manner. Version 1/2 attribute.')
ntnDsMultiFieldClfrSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnDsMultiFieldClfrVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 18), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrVersion.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrVersion.setDescription('Version indicator for ntnDsMultiFieldClfrTable.')
ntnDsMultiFieldClfrIpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 19), Bits().clone(namedValues=NamedValues(("ipv4MfFlagSet", 0), ("ipv4DfFlagSet", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrIpFlags.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrIpFlags.setDescription('Represents the flags present in an IPv4 header. If a bit that is associated with a specific IP flag is set in this attribute, IPv4 packets with the specified flag set in the header will match this classifier. Version 2 attribute.')
ntnDsMultiFieldClfrTcpCtrlFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 20), Bits().clone(namedValues=NamedValues(("tcpUrgFlagSet", 0), ("tcpAckFlagSet", 1), ("tcpPshFlagSet", 2), ("tcpRstFlagSet", 3), ("tcpSynFlagSet", 4), ("tcpFinFlagSet", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrTcpCtrlFlags.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrTcpCtrlFlags.setDescription('Represents the control flags (code bits) present in an TCP header. If a bit that is associated with a specific TCP control flag is set in this attribute, TCP packets with the specified flag set in the header will match this classifier. Version 2 attribute.')
ntnDsMultiFieldClfrIpv4Options = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipv4OptionsPresent", 1), ("ipv4OptionsNotPresent", 2), ("ignore", 3))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnDsMultiFieldClfrIpv4Options.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrIpv4Options.setDescription("This object indicates whether the presence, or lack thereof, of IPv4 options in an IPv4 packet should should be considered when looking for a match for this classifier entry. A value of 'ipv4OptionsPresent(1)' indicates that only IPv4 packets with options will match this classifier element. A value of 'ipv4OptionsNotPresent(2)' means that only IPv4 packets without options will be considered a match. A value of 'ignore(3)' means that the presence, or lack thereof, of IPv4 options in the received packet will not be considered when determining whether a packet matches this classifier entry. Version 2 attribute.")
ntnL2MultiFieldClfrNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrNextFree.setDescription('This object contains an unused value for ntnL2MultiFieldClfrId, or a zero to indicate that none exist.')
ntnL2MultiFieldClfrTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4), )
if mibBuilder.loadTexts: ntnL2MultiFieldClfrTable.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrTable.setDescription('IEEE 802-based classifier definitions. A class that contains attributes of IEEE 802 (e.g., 802.3) traffic that form an association that is used to perform traffic classification.')
ntnL2MultiFieldClfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrId"))
if mibBuilder.loadTexts: ntnL2MultiFieldClfrEntry.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrEntry.setDescription('IEEE 802-based classifier definitions. An entry specifies (potentially) several distinct matching components. Each component is tested against the data in a frame individually. An overall match occurs when all of the individual components match the data they are compared against in the frame being processed. A failure of any one test causes the overall match to fail. Wildcards may be specified for those fields that are not relevant.')
ntnL2MultiFieldClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnL2MultiFieldClfrId.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrId.setDescription('An arbitrary integer index that uniquely identifies this 802 classifier among all of the 802 classifiers. Version 1/2 attribute.')
ntnL2MultiFieldClfrDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrDstAddr.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrDstAddr.setDescription('The 802 address against which the 802 DA of incoming traffic streams will be compared. Frames whose 802 DA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnL2MultiFieldClfrDstAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class. Version 1/2 attribute.')
ntnL2MultiFieldClfrDstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 3), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrDstAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrDstAddrMask.setDescription("This object specifies the bits in a 802 destination address that should be considered when performing a 802 DA comparison against the address specified in the ntnL2MultiFieldClfrDstAddr object. The value of this object represents a mask that is logically and'ed with the 802 DA in received frames to derive the value to be compared against the ntnL2MultiFieldClfrDstAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnL2MultiFieldClfrDstAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnL2MultiFieldClfrDstAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnL2MultiFieldClfrDstAddr object. Version 1/2 attribute.")
ntnL2MultiFieldClfrSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 4), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSrcAddr.setDescription('The 802 MAC address against which the 802 MAC SA of incoming traffic streams will be compared. Frames whose 802 MAC SA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnL2MultiFieldClfrSrcAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class. Version 1/2 attribute.')
ntnL2MultiFieldClfrSrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 5), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSrcAddrMask.setDescription("This object specifies the bits in a 802 MAC source address that should be considered when performing a 802 MAC SA comparison against the address specified in the ntnL2MultiFieldClfrSrcAddr object. The value of this object represents a mask that is logically and'ed with the 802 MAC SA in received frames to derive the value to be compared against the ntnL2MultiFieldClfrSrcAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnL2MultiFieldClfrSrcAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnL2MultiFieldClfrSrcAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnL2MultiFieldClfrSrcAddr object. Version 1/2 attribute.")
ntnL2MultiFieldClfrVlanIdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanIdMin.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanIdMin.setDescription('The minimum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrVlanIdMin value must be less than or equal to the ntnL2MultiFieldClfrVlanIdMax value. Setting the ntnL2MultiFieldClfrVlanIdMin object to 1 and the ntnL2MultiFieldClfrVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification. If a frame is double tagged, this value represents the outer VLAN ID (Ovid). Version 1/2 attribute.')
ntnL2MultiFieldClfrVlanIdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanIdMax.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanIdMax.setDescription('The maximum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrVlanIdMax value must be greater than or equal to the ntnL2MultiFieldClfrVlanIdMin value. Setting the ntnL2MultiFieldClfrVlanIdMin object to 1 and the ntnL2MultiFieldClfrVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification. If a frame is double tagged, this value represents the outer VLAN ID (Ovid). Version 1/2 attribute.')
ntnL2MultiFieldClfrVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("ignore", 3), ("doubleTagged", 4))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanTag.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVlanTag.setDescription("This object indicates the data link layer packet format that frames must have to match this L2 classifier entry. A value of 'untagged(1)' indicates that only frames received untagged will match this classifier component. A value of 'tagged(2)' means that only frames received tagged (both single tagged and double tagged) will be considered a match. A value of 'ignore(3)' means that the presence, or lack thereof, of a VLAN tag in the received packet will not be considered when determining whether a frame matches this classifier entry. A value of 'doubleTagged(4)' means that only frames received with an inner and outer tag (i.e., a double tagged frame) will be considered a match. Version 1/2 attribute.")
ntnL2MultiFieldClfrEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrEtherType.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrEtherType.setDescription("This object specifies the value that will be compared against the value contained in the EtherType field of an IEEE 802 frame. Example settings would include 'IP' (0x0800), 'ARP' (0x0806) and 'IPX' (0x8137). Setting the ntnL2MultiFieldClfrEtherType object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA. Version 1/2 attribute.")
ntnL2MultiFieldClfrUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("matchPriority0", 1), ("matchPriority1", 2), ("matchPriority2", 3), ("matchPriority3", 4), ("matchPriority4", 5), ("matchPriority5", 6), ("matchPriority6", 7), ("matchPriority7", 8), ("matchAllPriorities", 9))).clone('matchAllPriorities')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrUserPriority.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrUserPriority.setDescription("The 802.1p user priority value against which the value contained in the user priority field of a tagged 802.1 frame is compared. A test for equality is performed when determining if a match exists between the data in a data link layer frame and the value of this classifier. Setting the value of this object to 'matchAllPriorities(9)' causes all user priority values to match this attribute. This essentially makes any comparisons with regard to user priority values unnecessary. Version 1/2 attribute.")
ntnL2MultiFieldClfrStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrStorage.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnL2MultiFieldClfrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrStatus.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnL2MultiFieldClfrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrLabel.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrLabel.setDescription('A label used to reference the classifier entry in a textual manner. Version 1/2 attribute.')
ntnL2MultiFieldClfrSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 14), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnL2MultiFieldClfrVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 15), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVersion.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrVersion.setDescription('Version indicator for ntnL2MultiFieldClfrTable.')
ntnL2MultiFieldClfrPktType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("snap", 2), ("llc", 3), ("ignore", 4))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrPktType.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrPktType.setDescription("This object indicates the data link layer frame format that frames must have to match this L2 classifier entry. A value of 'ethernetII(1)' indicates that only Ethernet II format frames will match this classifier component. A value of 'snap(2)' indicates that only IEEE 802 SNAP format frames will match this classifier component. A value of 'llc(3)' indicates that only IEEE 802 LLC format frames will match this classifier component. A value of 'ignore(4)' means that the frame, format will not be considered when determining whether a frame matches this classifier entry. Version 2 attribute.")
ntnL2MultiFieldClfrIvidMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIvidMin.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIvidMin.setDescription("The minimum value that the Inner VLAN ID (Ivid) in a double tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrIvidMin value must be less than or equal to the ntnL2MultiFieldClfrIvidMax value. Setting the ntnL2MultiFieldClfrIvidMin object to 1 and the ntnL2MultiFieldClfrIvidMax to 4094 indicates that inner VLAN tag data should not be considered during traffic classification. A non-default value for this attribute may only be specified if the ntnL2MultiFieldClfrVlanTag attribute has a value of 'doubleTagged(4)'. Version 2 attribute.")
ntnL2MultiFieldClfrIvidMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIvidMax.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIvidMax.setDescription("The maximum value that the Inner VLAN ID (Ivid) in a double tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrIvidMax value must be greater than or equal to the ntnL2MultiFieldClfrIvidMin value. Setting the ntnL2MultiFieldClfrIvidMin object to 1 and the ntnL2MultiFieldClfrIvidMax to 4094 indicates that VLAN data should not be considered during traffic classification. A non-default value for this attribute may only be specified if the ntnL2MultiFieldClfrVlanTag attribute has a value of 'doubleTagged(4)'. Version 2 attribute.")
ntnL2MultiFieldClfrTPID = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(33024)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrTPID.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrTPID.setDescription('This object specifies the value that will be compared against the value contained in the Ethertype field of the outer tag of a single or a double tagged (802.1ad QinQ) packet. Setting the ntnL2MultiFieldClfrTPID object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA. The default value is 0x8100, considering the standard 0x8100 value as the tag protocol identifier for the vlan tag. Version 1/2 attribute.')
ntnL2MultiFieldClfrCFI = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cfiZero", 1), ("cfiOne", 2), ("ignore", 3))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrCFI.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrCFI.setDescription("This object indicates the data link layer frame format that frames must have to match this L2 classifier entry. A value of 'cfiZero(1)' indicates that only tagged frames with the CFI bit set to zero will match this classifier component. A value of 'cfiOne(2)' indicates that only tagged frames with the CFI bit is set to one will match this classifier component. A value of 'ignore(3)' means that the frame, format will not be considered when determining whether a frame matches this classifier entry. Version 1/2 attribute.")
ntnL2MultiFieldClfrITPID = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(33024)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrITPID.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrITPID.setDescription('This object specifies the value that will be compared against the value contained in the Ethertype field of the inner tag of a double tagged (802.1ad QinQ) packet. Setting the ntnL2MultiFieldClfrITPID object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA. The default value is 0x8100, considering the standard 0x8100 value as the tag protocol identifier for the vlan tag. Version 1/2 attribute.')
ntnL2MultiFieldClfrICFI = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cfiZero", 1), ("cfiOne", 2), ("ignore", 3))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrICFI.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrICFI.setDescription("This object indicates the data link layer frame format that frames must have to match this L2 classifier entry. A value of 'cfiZero(1)' indicates that only double tagged frames with the CFI bit set to zero in the inner tag will match this classifier component. A value of 'cfiOne(1)' indicates that only double tagged frames with the CFI bit set to one in the inner tag will match this classifier component. A value of 'ignore(3)' means that the frame, format will not be considered when determining whether a frame matches this classifier entry. Version 1/2 attribute.")
ntnL2MultiFieldClfrIUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 4, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("matchPriority0", 1), ("matchPriority1", 2), ("matchPriority2", 3), ("matchPriority3", 4), ("matchPriority4", 5), ("matchPriority5", 6), ("matchPriority6", 7), ("matchPriority7", 8), ("matchAllPriorities", 9))).clone('matchAllPriorities')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIUserPriority.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrIUserPriority.setDescription("The 802.1p user priority value against which the value contained in the user priority field of the inner tag of a double tagged 802.1 frame is compared. A test for equality is performed when determining if a match exists between the data in a data link layer frame and the value of this classifier. Setting the value of this object to 'matchAllPriorities(9)' causes all user priority values to match this attribute. This essentially makes any comparisons with regard to user priority values unnecessary. Version 1/2 attribute.")
ntnSystemClfrNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 5), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnSystemClfrNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrNextFree.setDescription('This object contains an unused value for ntnSystemClfrId, or a zero to indicate that none exist.')
ntnSystemClfrTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6), )
if mibBuilder.loadTexts: ntnSystemClfrTable.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrTable.setDescription('The System Classifier Table defines classification data that is platform or hardware specific.')
ntnSystemClfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrId"))
if mibBuilder.loadTexts: ntnSystemClfrEntry.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrEntry.setDescription('An entry in the System Classifier Table describes classification data that is specifically related to system or hardware capabilities. As such, support for this table or for individual attributes contained in the table will vary from system to system. Entries within this table are referenced through the Classifier Component Table (ntnClfrComponentTable) to provide system-specific classification data.')
ntnSystemClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnSystemClfrId.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrId.setDescription('An index that enumerates the system classifier entries. Managers can obtain new index values for row creation in this table by reading ntnSystemClfrNextFree. Version 1/2 attribute.')
ntnSystemClfrUnknownUcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrUnknownUcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrUnknownUcastFrames.setDescription("If 'true(1)', frames containing an unknown unicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnSystemClfrUnknownMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrUnknownMcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrUnknownMcastFrames.setDescription("If 'true(1)', frames containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnSystemClfrKnownUcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrKnownUcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrKnownUcastFrames.setDescription("If 'true(1)', frames containing a known unicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnSystemClfrKnownMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrKnownMcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrKnownMcastFrames.setDescription("If 'true(1)', frames containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnSystemClfrBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrBcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrBcastFrames.setDescription("If 'true(1)', frames containing a broadcast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnSystemClfrPatternPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrPatternPosition.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrPatternPosition.setDescription('Supports arbitrary pattern match classification. Up to 128 bytes of data within the first 128 bytes of a packet can be identified for pattern matching purposes. This object and the ntnSystemClfrPatternData object specify byte patterns and their position in a packet. When a packet is classified using this data, the appropriate bytes, or portions thereof, in the packet are compared against the byte patterns defined by the ntnSystemClfrPatternData attribute. If the data at the specified packet offset is the same, the packet is considered a match. The byte positions, and the pertinent bits within each identified byte, used for comparison purposes are specified using this attribute. The positions to be matched are identified by setting the appropriate bits to one. All other bits must be set to zero. For example, to specify that byte positions 5-8 and the high-order nibble (4 bits) of bytes 13-16 should be examined, this attribute would be set as follows: ntnSystemClfrPatternPosition (size 16): 00:00:00:00:FF:FF:FF:FF:00:00:00:00:0F:0F:0F:0F The target byte patterns would then be placed in bytes 5-8 and in portions of bytes 13-16 of the ntnSystemClfrPatternData attribute: ntnSystemClfrPatternData (size 16): 00:00:00:00:XX:XX:XX:XX:00:00:00:00:0Y:0Y:0Y:0Y Note that an implementation may not support pattern matching, also know as offset filtering, for the maximum number of bytes supported by the pattern match attributes. The number of bytes that can contain data for comparison purposes and the position of those bytes in relation to the start of a packet are thus implementation dependent. Use of this object and the associated ntnSystemClfrPatternData object invalidates the use of any other classification data in this and related (through the ntnClfrComponentTable) classifier entries. In other words, providing an explicit pattern overrides the implicit patterns defined when classification data is specified for other fields, such as the IP source address or EtherType classification attributes. A zero length string is used to indicate that explicit pattern matching is not requested. Version 1/2 attribute.')
ntnSystemClfrPatternData = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrPatternData.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrPatternData.setDescription('Supports arbitrary pattern match classification. Up to 128 bytes of data within the first 128 bytes of a packet can be identified for pattern matching purposes. This object and the ntnSystemClfrPatternPosition object specify byte patterns and their position in a packet. When a packet is classified using this data, the appropriate bytes, or portions thereof, in the packet are compared against the byte patterns defined by the this attribute. If the data at the specified packet offset is the same, the packet is considered a match. The byte patterns used for comparison purposes are specified using this attribute. The target data is placed in the octet string at the positions specified through the ntnSystemClfrPatternPosition attribute. All other bytes should be set to zero For example, to specify that byte positions 5-8 and the high-order nibble (4 bits) of bytes 13-16 should be examined, the associated ntnSystemClfrPatternPosition value would be set as follows: ntnSystemClfrPatternPosition (size 16): 00:00:00:00:FF:FF:FF:FF:00:00:00:00:0F:0F:0F:0F The target byte patterns would then be placed in bytes 5-8 and in portions of bytes 13-16 of this attribute: ntnSystemClfrPatternData (size 16): 00:00:00:00:XX:XX:XX:XX:00:00:00:00:0Y:0Y:0Y:0Y Note that an implementation may not support pattern matching, also know as offset filtering, for the maximum number of bytes supported by the pattern match attributes. The number of bytes that can contain data for comparison purposes and the position of those bytes in relation to the start of a packet are thus implementation dependent. Use of this object and the associated ntnSystemClfrPatternPosition object invalidates the use of any other classification data in this and related (through the ntnClfrComponentTable) classifier entries. In other words, providing an explicit pattern overrides the implicit patterns defined when classification data is specified for other fields, such as the IP source address or EtherType classification attributes. A zero length string is used to indicate that explicit pattern matching is not requested. Version 1/2 attribute.')
ntnSystemClfrStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrStorage.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnSystemClfrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrStatus.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnSystemClfrPatternFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("doubleTagged", 3))).clone('tagged')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrPatternFormat.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrPatternFormat.setDescription("This object indicates the data link layer packet format that is used when specifying pattern match data. A value of 'untagged(1)' indicates that the specified pattern match data does not include an 802.1Q tag. A value of 'tagged(2)' indicates that the specified pattern match data does include an 802.1Q (single) tag. A value of 'doubleTagged(3)' indicates that the specified pattern match data does include an 802.1Q double tag. Version 1/2 attribute.")
ntnSystemClfrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrLabel.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrLabel.setDescription('A label used to reference the classifier entry in a textual manner. Version 1/2 attribute.')
ntnSystemClfrSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnSystemClfrVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 14), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrVersion.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrVersion.setDescription('Version indicator for ntnSystemClfrTable.')
ntnSystemClfrUnknownIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrUnknownIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrUnknownIpMcast.setDescription("If 'true(1)', IP packets containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnSystemClfrKnownIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrKnownIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrKnownIpMcast.setDescription("If 'true(1)', IP packets containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnSystemClfrNonIpPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrNonIpPkt.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrNonIpPkt.setDescription("If 'true(1)', non IP packets will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this packet type. Version 2 attribute.")
ntnSystemClfrPatternIpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("nonIp", 2), ("ipv4", 3), ("ipv6", 4))).clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrPatternIpVersion.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrPatternIpVersion.setDescription("This object indicates the IP packet format that is used when specifying pattern match data. A value of 'notApplicable(1)' is used when the pattern match data can be specified without indicating the target packet type. A value of 'nonIp(2)' indicates that the specified pattern match data should be applied to non-IP packets. A value of 'ipv4(3)' indicates that the specified pattern match data should be applied to IPv4 packets. A value of 'ipv6(4)' indicates that the specified pattern match data should be applied to IPv6 packets. Version 2 attribute.")
ntnSystemClfrUnknownNonIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrUnknownNonIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrUnknownNonIpMcast.setDescription("If 'true(1)', non-IP packets containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnSystemClfrKnownNonIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 20), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrKnownNonIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrKnownNonIpMcast.setDescription("If 'true(1)', non-IP packets containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnSystemClfrPatternL2Format = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("ethernetII", 2), ("snap", 3), ("llc", 4))).clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnSystemClfrPatternL2Format.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrPatternL2Format.setDescription("This object indicates the L2 packet format that is used when specifying pattern match data. A value of 'notApplicable(1)' is used when the pattern match data can be specified without indicating the target L2 packet format. A value of 'ethernetII(2)' indicates that the specified pattern match data should be applied to Ethernet II format frames. A value of 'snap(3)' indicates that the specified pattern match data should be applied to IEEE 802 SNAP format frames. A value of 'llc(4)' indicates that the specified pattern match data should be applied to IEEE 802 LLC format frames. Version 2 attribute.")
ntnClfrComponentNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 7), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnClfrComponentNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentNextFree.setDescription('This object contains an unused value for ntnClfrComponentId, or a zero to indicate that none exist.')
ntnClfrComponentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8), )
if mibBuilder.loadTexts: ntnClfrComponentTable.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentTable.setDescription('The Classifier Component Table identifies classification data from protocol, media and hardware specific tables and links the data to form a single classifier.')
ntnClfrComponentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentId"))
if mibBuilder.loadTexts: ntnClfrComponentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentEntry.setDescription('An entry in the Classifier Component Table describes a collection of classification data from a single protocol, media or hardware specific classifier table. Entries within this table are linked through a common set identifier. This identifier is used to reference the constructed set of classification data for a policy, through the ntnQosPolicyTable, or for classifier block creation, through the ntnClfrBlockTable.')
ntnClfrComponentId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnClfrComponentId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentId.setDescription('An index that enumerates the classifier component entries. Managers can obtain new index values for row creation in this table by reading ntnClfrComponentNextFree. Version 1/2 attribute.')
ntnClfrComponentSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 2), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentSpecific.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentSpecific.setDescription('Identifies an entry containing classification data in a protocol, media or hardware specific classifier table. Entries are referenced using a RowPointer value specifying the RowStatus attribute of the entry being identified. Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Entries may not be deleted while still referenced by an active entry in this table. Version 1/2 attribute.')
ntnClfrComponentSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentSetId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentSetId.setDescription('Identifies a set of classifier data. Entries in this table with the same value for this attribute are considered components of the same classifier. This set identifier is used to reference this classification data from other QoS tables, including the QoS Policy Table (ntnQosPolicyTable) and the Classifier Block Table (ntnClfrBlockTable). Members of a given classifier component set may be prohibited from being deleted if the set is referenced by an active entry in another table. Version 1/2 attribute.')
ntnClfrComponentLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentLabel.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentLabel.setDescription('A label used to reference the classifier component set in a textual manner. All members of the same component set, as determined by the value of the ntnClfrComponentSetId attribute, must have the same label. Version 1/2 attribute.')
ntnClfrComponentStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentStorage.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnClfrComponentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentStatus.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnClfrComponentSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnClfrComponentVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 8, 1, 8), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrComponentVersion.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentVersion.setDescription('Version indicator for ntnClfrComponentTable. Members of the same classifier component set must all have the same version information.')
ntnClfrBlockNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 9), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnClfrBlockNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockNextFree.setDescription('This object contains an unused value for ntnClfrBlockId ,or a zero to indicate that none exist.')
ntnClfrBlockTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10), )
if mibBuilder.loadTexts: ntnClfrBlockTable.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockTable.setDescription('The Classifier Block Table supports the ability to group individual classifiers into an unordered list, or block, of classifiers. ')
ntnClfrBlockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockId"))
if mibBuilder.loadTexts: ntnClfrBlockEntry.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockEntry.setDescription("An entry in the Classifier Block Table describes a single member of a group of the classifiers. Each entry identifies classification data, defined through the Classifier Component Table (ntnClfrComponentTable). Block members are considered unordered for evaluation purposes and can be thought of as being applied 'simultaneously'. All block members must perform classification based on the same set of data. Related entries within this table are linked through a common group identifier. This identifier is used to reference the classification block for a policy through the QoS Policy Table (ntnQosPolicyTable).")
ntnClfrBlockId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnClfrBlockId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockId.setDescription('An index that enumerates the classifier block entries. Managers can obtain new index values for row creation in this table by reading ntnClfrBlockNextFree. Version 1/2 attribute.')
ntnClfrBlockNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockNumber.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockNumber.setDescription('Identifies a group of classification entries. Entries in this table with the same value for this attribute are considered members of the same group (i.e., classifier block). This block identifier is used to reference this unordered collection of classification data from other QoS tables, including the QoS Policy Table (ntnQosPolicyTable). Members of a specific classification group may be deleted, even if the group is referenced by an active entry in another table, as long as at least one member of the group is not deleted. Version 1/2 attribute.')
ntnClfrBlockClfrCompSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockClfrCompSetId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockClfrCompSetId.setDescription('Identifies a classifier component set in the Classifier Component Table (ntnClfrComponentTable) containing classification data. Component entries must exist prior to being referenced. It may be permissible to create component table entries and classifier block entries in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. Version 1/2 attribute.')
ntnClfrBlockMeter = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 4), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockMeter.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockMeter.setDescription('This attribute identifies the meter that is associated with this classifier block. Meters are specified in the ntnQosMeterTable and associated tables. The corresponding instance in the ntnQosMeter class (i.e., the class instance where the ntnQosMeterId is equal to the value of this object) must exist prior to being associated with a block entry. A value of 0 indicates that no individual classifier metering is requested. Version 1/2 attribute.')
ntnClfrBlockAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 5), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockAction.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockAction.setDescription('This attribute identifies the action that is to be initiated for flows that are not being metered and that match the classification criteria specified through this classifier block. The value of this attribute will not be used (and should be set to 0) when metering is requested. Under this scenario, the in-profile and out-of-profile actions are specified through the appropriate ntnQosMeterEntry. Actions must be defined in the ntnQosBaseActionTable prior to being referenced by this attribute. A non-zero value for this attribute must be provided unless metering is requested (if action data is being specified per classifier). Version 1/2 attribute.')
ntnClfrBlockLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockLabel.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockLabel.setDescription('A label used to reference the classifier group in a textual manner. All members of the same group, as determined by the value of the ntnClfrBlockNumber attribute, must have the same label. Version 1/2 attribute.')
ntnClfrBlockStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockStorage.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnClfrBlockStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockStatus.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnClfrBlockSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnClfrBlockVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 10), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockVersion.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockVersion.setDescription('Version indicator for ntnClfrBlockTable. Members of the same classifier block must all have the same version information.')
ntnClfrBlockPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnClfrBlockPrecedence.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockPrecedence.setDescription('The relative order in which the classifier sets associated with this block are applied, with regard to other classifiers sets within the block. Higher numbers represent block members with higher precedence. Block members with higher precedence are applied before members with lower precedence. Precedence values must be unique across members of the same classifier block when block members are evaluated in a specific order. Precedence values must be the same across block members when they are evaluated simultaneously. Version 1/2 attribute.')
ntnClfrComponentSetNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 11), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnClfrComponentSetNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentSetNextFree.setDescription('This object contains an unused value for ntnClfrComponentSetId, or a zero to indicate that none exist.')
ntnClfrBlockNumberNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 5, 12), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnClfrBlockNumberNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockNumberNextFree.setDescription('This object contains an unused value for ntnClfrBlockNumber ,or a zero to indicate that none exist.')
ntnQosMeterClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6))
ntnQosMeterNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosMeterNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterNextFree.setDescription('This object contains an unused value for ntnQosMeterId, or a zero to indicate that none exist.')
ntnQosMeterTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2), )
if mibBuilder.loadTexts: ntnQosMeterTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterTable.setDescription('This table enumerates specific meters that a system may use to police a stream of traffic. Specific meter details are to be found in table entry referenced by ntnQosMeterSpecific.')
ntnQosMeterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterId"))
if mibBuilder.loadTexts: ntnQosMeterEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterEntry.setDescription('An entry in the meter table describes a single conformance level of a meter.')
ntnQosMeterId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosMeterId.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterId.setDescription('An index that enumerates the Meter entries. Managers can obtain new index values for row creation in this table by reading ntnQosMeterNextFree. Version 1/2 attribute.')
ntnQosMeterSucceedNext = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 2), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterSucceedNext.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterSucceedNext.setDescription('If the traffic being processed does conform, based on the traffic profile associated with this entry, this selects the next element to handle traffic for this data path. This RowPointer should point to an instance of one of: ntnQosMeterEntry ntnQosBaseActionEntry Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. Version 1/2 attribute.')
ntnQosMeterFailNext = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 3), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterFailNext.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterFailNext.setDescription('If the traffic being processed does not conform, based on the traffic profile associated with this entry, this selects the next element to handle traffic for this data path. This RowPointer should point to an instance of one of: ntnQosMeterEntry ntnQosBaseActionEntry Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. Version 1/2 attribute.')
ntnQosMeterSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterSpecific.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterSpecific.setDescription('This indicates the behavior of the meter by pointing to an entry containing detailed parameters. Note that entries in that specific table must be managed explicitly. For example, ntnQosMeterSpecific may point to an entry in ntnQosTBParamTable, which contains an instance of a single set of Token Bucket parameters. Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. Version 1/2 attribute.')
ntnQosMeterOutOfProfileStats = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 5), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterOutOfProfileStats.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterOutOfProfileStats.setDescription('Identifies an entry in the Count Action Table (ntnQosCountActTable) that is used to accumulate statistics related to traffic processed based on this meter data that was deemed to be non-conformant (i.e., out-of-profile). If out-of-profile statistics are not wanted or are not available, this attribute will be set to 0. Version 1/2 attribute.')
ntnQosMeterLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterLabel.setDescription('A label used to reference the meter data in a textual manner. Version 1/2 attribute.')
ntnQosMeterStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnQosMeterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnQosMeterSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnQosMeterVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 2, 1, 10), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosMeterVersion.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterVersion.setDescription('Version indicator for ntnQosMeterTable.')
ntnQosTBParamNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTBParamNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamNextFree.setDescription('This object contains an unused value for ntnQosTBParamId, or a zero to indicate that none exist.')
ntnQosTBParamTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4), )
if mibBuilder.loadTexts: ntnQosTBParamTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamTable.setDescription('Entries in this table enumerate a set of token bucket meter parameters that a system may use to police a stream of traffic. Such meters are modeled here as having a single rate and a single burst size. Multiple entries are used when multiple rates/burst sizes are needed.')
ntnQosTBParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamId"))
if mibBuilder.loadTexts: ntnQosTBParamEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamEntry.setDescription('An entry that describes a single set of token bucket parameters.')
ntnQosTBParamId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosTBParamId.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamId.setDescription('An index that enumerates the Token Bucket Parameter entries. Managers can obtain new index values for row creation in this table by reading ntnQosTBParamNextFree. Version 1/2 attribute.')
ntnQosTBParamType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 2), AutonomousType().clone((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 1))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamType.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamType.setDescription('The Metering algorithm associated with the Token Bucket parameters. The number and type of algorithms supported is implementation dependent. Potential algorithms include: ntnQosTBParamSimpleTokenBucket ntnQosTBParamAvgRate ntnQosTBParamSrTCMBlind ntnQosTBParamSrTCMAware ntnQosTBParamTrTCMBlind ntnQosTBParamTrTCMAware ntnQosTBParamTswTCM An OBJECT-IDENTITY for each of these algorithms is defined in this module. Additional values may be specified as needed. Version 1/2 attribute.')
ntnQosTBParamRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamRate.setDescription('The token-bucket rate, in kilobits per second (kbps). This attribute is used for: CIR for Simple Token Bucket CIR in RFC 2697 for srTCM CIR and PIR in RFC 2698 for trTCM CTR and PTR in RFC 2859 for TSWTCM AverageRate in RFC 3290. Version 1/2 attribute.')
ntnQosTBParamBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 4), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamBurstSize.setDescription('The maximum number of bytes in a single transmission burst. This attribute is used for: Token bucket size for Simple Token Bucket CBS and EBS in RFC 2697 for srTCM CBS and PBS in RFC 2698 for trTCM Burst Size in RFC 3290. Version 1/2 attribute.')
ntnQosTBParamInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('microseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamInterval.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamInterval.setDescription('The time interval used with the token bucket. This attribute is used for: Average Rate Meter (Informal DS Model section 5.2.1) - Delta Simple Token Bucket Meter (Informal DS Model 5.1) - time interval t RFC 2859 TSWTCM - AVG_INTERVAL RFC 2697 srTCM - token bucket update time interval RFC 2698 trTCM - token bucket update time interval. Version 1/2 attribute.')
ntnQosTBParamLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamLabel.setDescription('A label used to reference the token bucket data in a textual manner. Version 1/2 attribute.')
ntnQosTBParamStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnQosTBParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnQosTBParamSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamSessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnQosTBParamVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 10), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamVersion.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamVersion.setDescription('Version indicator for ntnQosTBParamTable.')
ntnQosTBParamMinRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 4, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosTBParamMinRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamMinRate.setDescription('The minimum token-bucket rate, in kilobits per second (kbps). Version 2 attribute.')
ntnQosTBMeters = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5))
ntnQosTBParamSimpleTokenBucket = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 1))
if mibBuilder.loadTexts: ntnQosTBParamSimpleTokenBucket.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamSimpleTokenBucket.setDescription('Two Parameter Token Bucket Meter as described in the Informal Differentiated Services Model section 5.2.3.')
ntnQosTBParamAvgRate = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 2))
if mibBuilder.loadTexts: ntnQosTBParamAvgRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamAvgRate.setDescription('Average Rate Meter as described in the Informal Differentiated Services Model section 5.2.1.')
ntnQosTBParamSrTCMBlind = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 3))
if mibBuilder.loadTexts: ntnQosTBParamSrTCMBlind.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamSrTCMBlind.setDescription("Single Rate Three Color Marker Metering as defined by RFC 2697,in the `Color Blind' mode as described by the RFC.")
if mibBuilder.loadTexts: ntnQosTBParamSrTCMBlind.setReference('RFC 2697')
ntnQosTBParamSrTCMAware = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 4))
if mibBuilder.loadTexts: ntnQosTBParamSrTCMAware.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamSrTCMAware.setDescription("Single Rate Three Color Marker Metering as defined by RFC 2697,in the `Color Aware' mode as described by the RFC.")
if mibBuilder.loadTexts: ntnQosTBParamSrTCMAware.setReference('RFC 2697')
ntnQosTBParamTrTCMBlind = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 5))
if mibBuilder.loadTexts: ntnQosTBParamTrTCMBlind.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamTrTCMBlind.setDescription("Two Rate Three Color Marker Metering as defined by RFC 2698, in the `Color Blind' mode as described by the RFC.")
if mibBuilder.loadTexts: ntnQosTBParamTrTCMBlind.setReference('RFC 2698')
ntnQosTBParamTrTCMAware = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 6))
if mibBuilder.loadTexts: ntnQosTBParamTrTCMAware.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamTrTCMAware.setDescription("Two Rate Three Color Marker Metering as defined by RFC 2698, in the `Color Aware' mode as described by the RFC.")
if mibBuilder.loadTexts: ntnQosTBParamTrTCMAware.setReference('RFC 2698')
ntnQosTBParamTswTCM = ObjectIdentity((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 7))
if mibBuilder.loadTexts: ntnQosTBParamTswTCM.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamTswTCM.setDescription('Time Sliding Window Three Color Marker Metering as defined by RFC 2859.')
if mibBuilder.loadTexts: ntnQosTBParamTswTCM.setReference('RFC 2859')
ntnQosActionClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7))
ntnQosBaseActionNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosBaseActionNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionNextFree.setDescription('This object contains an unused value for ntnQosBaseActionId, or a zero to indicate that none exist.')
ntnQosBaseActionTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2), )
if mibBuilder.loadTexts: ntnQosBaseActionTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionTable.setDescription('Contains the current set of configured base actions. The actions are associated with classifiers, meters and interfaces through policies during operation.')
ntnQosBaseActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionId"))
if mibBuilder.loadTexts: ntnQosBaseActionEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionEntry.setDescription('General action definitions. Each entry specifies an instance of the ntnQosBaseAction class which describes (potentially) several distinct action attributes. Each action is taken individually regarding the data in question. Several actions can be taken for a single frame. An instance of this class cannot be deleted while it is being referenced by an entry in another class.')
ntnQosBaseActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosBaseActionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionId.setDescription('An index that enumerates the QoS Base Action entries. Managers can obtain new index values for row creation in this table by reading ntnQosBaseActionNextFree. Actions are associated with instances in other classes (e.g., the QoS Policy class) using this attribute.')
ntnQosBaseActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("dontDrop", 2), ("deferredPass", 3))).clone('deferredPass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionDrop.setDescription("This action attribute is used to specify whether a packet should dropped, switched (i.e., not dropped) or whether the decision to drop the packet should be deferred. The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'dontDrop(2)' indicates that this packet should not be dropped. A value of 'deferredPass(3)' indicates that no explicit assertion, related to whether or not the packet should be discarded, is being made. This option, when available, can be used to allow actions associated with lower precedence policies to determine whether a packet should be dropped or not. A 'drop(1)' or 'dontDrop(2)' in a lower precedence action is given precedence over a higher precedence 'deferredPass(3)'. Support for this enumeration is implementation dependent. Prior to discarding a packet, other actions that have been specified should be performed if they make protocol sense. For example, requests for traffic mirroring (if such an action is supported by a device) should be honored. However, updating protocol header values will typically not be necessary.")
ntnQosBaseActionUpdateDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 3), DscpUpdate().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionUpdateDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionUpdateDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram to be updated with the value of this object.')
ntnQosBaseActionUpdateUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("deriveFromIngressTosPrec", 9), ("deriveFromIngressDscp", 10), ("deriveFromEgressDscp", 11), ("ignore", 12), ("markAsPriorityCopy", 13))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionUpdateUserPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionUpdateUserPriority.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame to be updated based on the value of this object. Specifying a value equal to 'deriveFromIngressTosPrec(9)' means that the value for this attribute will be assigned based on the value of the precedence bits in the IP Type-Of-Service (TOS) field, as defined in RFC 791. The eight precedence values, also referred to as Class Selector (CS) values, have a one-to-one correspondence with the eight 802.1p user priority values. Specifying a value equal to 'deriveFromIngressDscp(10)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value in received traffic will be used to determine the user priority. Specifying a value equal to 'deriveFromEgressDscp(11)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value specified for remarking in the ntnQosBaseActionUpdateDscp attribute will be used to determine the user priority. Specifying a value equal to 'ignore(12)' means that no action will be taken related to this attribute. Specifying a value equal to 'markAsPriorityCopy(13)' means that the priority is updated based on the user priority field in the outer vlan tag. The priority copy functionality can be used for 802.1ad double tagged traffic where the priority field in the service provider vlan tag can be copied from the user priority in the customer vlan tag.")
ntnQosBaseActionSetDropPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionSetDropPrecedence.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionSetDropPrecedence.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'.")
ntnQosBaseActionCopyToCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionCopyToCpu.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionCopyToCpu.setDescription("This action attribute, when specified, has the ability to cause the packet being evaluated to be sent to the CPU for further processing. Extreme care should be taken when setting this object to 'true(1)' since this action may adversely affect resource availability in the system impacting overall system operation. A value of 'false(2)' indicates that this action will not be initiated. If this operation is requested and 'drop' has been specified, the packet will be sent to the CPU and not forwarded by the system. Specifying 'true(1)' when 'drop' has not been specified will cause a copy of the packet to be sent to the CPU and the packet itself will receive normal forwarding treatment.")
ntnQosBaseActionMirrorFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionMirrorFrame.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionMirrorFrame.setDescription("This action attribute, when specified, will cause the packet being evaluated to be sent to a predefined egress port for transmission in addition to the normal processing associated with the packet. Specification of the egress port or ports that will serve as the destination for mirrored data is beyond the scope of this document. Furthermore, note that data mirroring can potentially consume substantial resources at the egress. Over-subscription issues should be considered prior to specifying this action. A value of 'false(2)' indicates that this action will not be initiated. If this operation is requested and 'drop' has been specified, the packet will be mirrored to the specified port and not forwarded by the system. Specifying 'true(1)' when 'drop' has not been specified will cause a copy of the packet to be mirrored and the packet itself will receive normal forwarding treatment.")
ntnQosBaseActionExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 8), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionExtension.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionExtension.setDescription('Identifies an entry in an auxiliary action table containing additional actions to be performed on/applied to identified traffic. Entries are referenced using a RowPointer value specifying the RowStatus attribute of the entry being identified. Entries in other tables must exist prior to being referenced. It may be permissible to create base table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. A null value for this attribute (0.0) indicates that no action extensions have been specified.')
ntnQosBaseActionLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionLabel.setDescription('A label used to reference the action entry in a textual manner.')
ntnQosBaseActionStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosBaseActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosBaseActionSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 2, 1, 12), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosBaseActionSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionSessionId.setDescription('A session identifier used to reference transitory (volatile) data.')
ntnQosIfcActionNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosIfcActionNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionNextFree.setDescription('This object contains an unused value for ntnQosIfcActionId, or a zero to indicate that none exist.')
ntnQosIfcActionTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4), )
if mibBuilder.loadTexts: ntnQosIfcActionTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionTable.setDescription('Contains the current set of configured interface actions. The actions are associated with classifiers, meters and interfaces through policies during operation indirectly through extensions of other action entries.')
ntnQosIfcActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionId"))
if mibBuilder.loadTexts: ntnQosIfcActionEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionEntry.setDescription('Interface action definitions. Each entry specifies an instance of the ntnQosIfcAction class which describes (potentially) several distinct action attributes. Each action is taken individually regarding the data in question. Several actions can be taken for a single frame. An instance of this class cannot be deleted while it is being referenced by an entry in another class.')
ntnQosIfcActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosIfcActionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionId.setDescription('An index that enumerates the QoS Interface Action entries. Managers can obtain new index values for row creation in this table by reading ntnQosIfcActionNextFree. Actions are associated with instances in other classes (e.g., the QoS Base Action class) using this attribute as a component in the identifying RowPointer.')
ntnQosIfcActionUpdateVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 4094), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionUpdateVlanId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionUpdateVlanId.setDescription('This action attribute, when specified, will cause the Vlan Id in the frame being processed to be updated using the specified value. The Vlan Id value will not be updated based on QoS classification if the value of this attribute equals -1.')
ntnQosIfcActionSetEgressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 3), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(64, 64), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressMask.setDescription('This action component, when specified, will cause the potential list of egress interfaces for a given packet to be limited to those interfaces that are included in the egress interface mask specified by this attribute. A packet will only be transmitted out interfaces that are both identified through this attribute AND through the normal forwarding logic. Potential egress interfaces are identified by setting the bit in the egress mask that corresponds to the ifIndex value associated with the interface. Each bit of this bit mask corresponds to an ifIndex value, with the most significant bit of the i-th octet of this octet string corresponding to the ((8*i) - 7)-th ifIndex, and the least significant bit of the i-th octet corresponding to the (8*i)-th ifIndex. A zero length octet string indicates that this action component has not been set to an appropriate value and should not be used for action initiation. Egress interface restrictions will not be updated based on QoS classification in this case.')
ntnQosIfcActionSetEgressUcastIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressUcastIfc.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressUcastIfc.setDescription('This action attribute supports redirection of normally-switched, known unicast packets to a specific interface. An egress interface is identified for redirection by setting this attribute to the logical ifIndex value associated with the interface. Setting this attribute to 0 indicates that redirection of unicast traffic based on QoS classification is not requested. Specifying the same ifIndex value for this object and the ntnQosIfcActionSetEgressNUcastIfc attribute causes all traffic to be redirected if it matches specified QoS classification criteria.')
ntnQosIfcActionSetEgressNUcastIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressNUcastIfc.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionSetEgressNUcastIfc.setDescription('This action attribute supports redirection of normally-switched non-unicast (includes broadcast, multicast and flooded/unknown unicast) packets to a specific interface. An egress interface is identified for redirection by setting this attribute to the logical ifIndex value associated with the interface. Setting this attribute to 0 indicates that redirection of non-unicast traffic based on QoS classification is not requested. Specifying the same ifIndex value for this object and the ntnQosIfcActionSetEgressUcastIfc attribute causes all traffic to be redirected if it matches specified QoS classification criteria.')
ntnQosIfcActionExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 6), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionExtension.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionExtension.setDescription('Identifies an entry in an auxiliary action table containing additional actions to be performed on/applied to identified traffic. Entries are referenced using a RowPointer value specifying the RowStatus attribute of the entry being identified. Entries in other tables must exist prior to being referenced. It may be permissible to create referencing table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table. A null value for this attribute (0.0) indicates that no action extensions have been specified.')
ntnQosIfcActionLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionLabel.setDescription('A label used to reference the action entry in a textual manner.')
ntnQosIfcActionStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosIfcActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosIfcActionSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 7, 4, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfcActionSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionSessionId.setDescription('A session identifier used to reference transitory (volatile) data.')
ntnQosPolicyClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8))
ntnQosPolicyNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyNextFree.setDescription('This object contains an unused value for ntnQosPolicyId, or a zero to indicate that none exist.')
ntnQosPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2), )
if mibBuilder.loadTexts: ntnQosPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyTable.setDescription('A policy class that applies a set of classifiers to interfaces specifying, for each association, the precedence order of the classifier with respect to other classifiers applied to the same interface and, for each policy, the action to take for a packet that matches the classifiers referenced by the policy. Interfaces are specified abstractly in terms of interface groups or roles. This class may reference individual classifiers or blocks of classifiers. Classification data is identified by its type (i.e., single classifier or group of classifiers) and an identifier based on the type. A policy is formed by associating the classification data with an interface group, actions to be carried out based on classification and metering criteria, if applicable.')
ntnQosPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyId"))
if mibBuilder.loadTexts: ntnQosPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyEntry.setDescription('An instance of the ntnQosPolicy class. Instance creation may be prohibited based on the status of certain class attributes which must exist prior to class instantiation.')
ntnQosPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosPolicyId.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyId.setDescription('An index that enumerates the QoS Policy entries. Managers can obtain new index values for row creation in this table by reading ntnQosPolicyNextFree. Version 1/2 attribute.')
ntnQosPolicyClassifierType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("individualClfr", 1), ("blockOfClfrs", 2), ("filterSetIndividualClfr", 3), ("filterSetBlockOfClfrs", 4))).clone('individualClfr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyClassifierType.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyClassifierType.setDescription("The type of classification resources that are being referenced by this QoS policy. This classifier type indication, together with the corresponding ntnQosPolicyClassifierId attribute, uniquely identifies the classification data associated with this entry. The value of this attribute dictates the interpretation of the classifier Id in the ntnQosPolicyClassifierId attribute. A value of 'individualClfr(1)' means the value references entries in the Classifier Component Table (ntnClfrComponentTable) using the component set identifier. A value of 'blockOfClfrs(2)' means the value reference entries in the Classifier Block Table (ntnClfrBlockTable) using the classification block number. The values 'filterSetIndividualClfr(3)' and 'filterSetBlockOfClfrs(4)' can only be retrieved. Version 1/2 attribute.")
ntnQosPolicyClassifierId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyClassifierId.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyClassifierId.setDescription("This attribute identifies the classification data that is associated with this policy. It identifies either an individual classifier or a block of classifiers, based on the value of the ntnQosPolicyClassifierType attribute. A value of 'individualClfr(1)' means this value references entries in the Classifier Component Table (ntnClfrComponentTable) using the component set identifier. A value of 'blockOfClfrs(2)' means this value reference entries in the Classifier Block Table (ntnClfrBlockTable) using the classification block number Referenced classification data must be defined prior to being referenced. Version 1/2 attribute.")
ntnQosPolicyInterfaceRoles = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 4), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyInterfaceRoles.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyInterfaceRoles.setDescription('The interfaces to which this policy applies, specified in terms of a set of roles. The role combination specified by this attribute must exist in the ntnQosInterfaceTypeTable or the individual roles must exist in the ntnQosInterfaceRoleTable prior to being associated with an instance of this class. Version 1/2 attribute.')
ntnQosPolicyPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyPrecedence.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecedence.setDescription('The relative order in which the classifier elements associated with this policy are applied, with regard to other classifiers applied to the same group of interfaces in other policies. Higher numbers represent policies with higher precedence. Policies with higher precedence are applied before policies with lower precedence. Precedence values must be unique across policies that are associated with the same role combination. Version 1/2 attribute.')
ntnQosPolicyMeter = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 6), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyMeter.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyMeter.setDescription('This attribute identifies the meter that is associated with this QoS Policy instance. Meters are specified in the ntnQosMeterTable and associated tables. The corresponding instance in the ntnQosMeter class (i.e., the class instance where the ntnQosMeterId is equal to the value of this object) must exist prior to being associated with a policy entry. A value of 0 indicates that no metering is requested. Version 1/2 attribute.')
ntnQosPolicyAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 7), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyAction.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyAction.setDescription('This attribute identifies the action that is to be initiated for flows that are not being metered and that match the classification criteria specified via the classifier attributes. The value of this attribute will not be used (and should be set to 0) when metering is requested. Under this scenario, the in-profile and out-of-profile actions are specified through the appropriate ntnQosMeterEntry. Actions must be defined in the ntnQosBaseActionTable prior to being referenced by this attribute. A non-zero value for this attribute must be provided unless metering is requested. Version 1/2 attribute.')
ntnQosPolicyNonMatchAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 8), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyNonMatchAction.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyNonMatchAction.setDescription('This attribute identifies the action that is to be initiated for flows that do not match the classification criteria being applied to the flow. Actions must be defined in the ntnQosBaseActionTable prior to being referenced by this attribute. Version 1 attribute.')
ntnQosPolicyLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyLabel.setDescription('A label used to reference the QoS policy entry in a textual manner. Version 1/2 attribute.')
ntnQosPolicyStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnQosPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnQosPolicyStats = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 12), IndexIntegerOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyStats.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyStats.setDescription('Identifies an entry in the Count Action Table (ntnQosCountActTable) that is used to accumulate statistics related to traffic processed based on this policy data. If metering is specified, the statistics entry identified by this attribute counts traffic that was deemed to be conformant (i.e., in-profile). Version 1/2 attribute.')
ntnQosPolicyStatsType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("individualClfr", 1), ("aggregateClfr", 2))).clone('aggregateClfr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyStatsType.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyStatsType.setDescription("The type of statistics tracking used by this QoS policy. The value of this attribute dictates the amount of statistics tracking resources (i.e., counters) consumed by this policy. A value of 'individualClfr(1)' means that separate counters will be allocated, space permitting, for each classifier referenced by the policy. A value of 'aggregateClfr(2)' means that a single counter will be used to accumulate the statistics data for all the classifiers referenced by the policy. The value of this attribute is only used when statistics tracking is enabled for the overall policy through the ntnQosPolicyStats attribute. Version 1/2 attribute.")
ntnQosPolicyInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 14), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyInterfaceIndex.setDescription('An ifIndex value that is used to identify an interface to which the policy is to be applied. A policy is associated with an interface explicitly using this attribute or implicitly using a role combination through the ntnQosPolicyInterfaceRole attribute. An interface must be identified by one and only one of these attributes. This attribute may identify an interface that does not currently exist in the system as long as the specified interface index represents a potentially valid system interface. Version 1/2 attribute.')
ntnQosPolicySessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 15), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicySessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicySessionId.setDescription('A session identifier used to reference transitory (volatile) data. Version 1/2 attribute.')
ntnQosPolicyVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 16), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosPolicyVersion.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyVersion.setDescription('Version indicator for ntnQosPolicyTable.')
ntnQosPolicyMeteringMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noMetering", 1), ("policyBasedMetering", 2), ("blockBasedMetering", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyMeteringMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyMeteringMode.setDescription("Identifies the metering mode associated with the policy. A value of 'noMetering(1)' indicates that metering is not associated with this policy. A 'policyBasedMetering(2)' value indicates that traffic identified using this policy is metered and the metering criteria is directly associated with the policy. A 'blockBasedMetering(3)' value indicates that traffic identified using this policy is metered and the metering criteria is indirectly associated with the policy (specified through the classifier criteria).")
ntnQosCountActNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosCountActNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActNextFree.setDescription('This object contains an unused value for ntnQosCountActId, or a zero to indicate that none exist.')
ntnQosCountActTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4), )
if mibBuilder.loadTexts: ntnQosCountActTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActTable.setDescription('This table contains counters for all the traffic passing through a processing element.')
ntnQosCountActEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActId"))
if mibBuilder.loadTexts: ntnQosCountActEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActEntry.setDescription('An entry in the count action table describes a single set of traffic counters.')
ntnQosCountActId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosCountActId.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActId.setDescription('An index that enumerates the Count Action entries. Managers can obtain new index values for row creation in this table by reading ntnQosCountActNextFree.')
ntnQosCountActOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosCountActOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActOctets.setDescription('The number of octets processed by the associated data path element (e.g., policy, meter).')
ntnQosCountActPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosCountActPkts.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActPkts.setDescription('The number of packets processed by the associated data path element (e.g., policy, meter).')
ntnQosCountActStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCountActStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosCountActStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCountActStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosCountActSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 4, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCountActSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActSessionId.setDescription('A session identifier used to reference transitory (volatile) data.')
ntnQosFilterStatsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5), )
if mibBuilder.loadTexts: ntnQosFilterStatsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsTable.setDescription('This table contains counters for all the traffic passing through a processing element at the policy/filter level.')
ntnQosFilterStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsPolicyId"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsFilterId"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsInterfaceId"))
if mibBuilder.loadTexts: ntnQosFilterStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsEntry.setDescription('An entry in the filter statistics table describes a single set of traffic counters for a specific policy/filter/interface combination.')
ntnQosFilterStatsPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosFilterStatsPolicyId.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsPolicyId.setDescription('An index component that identifies the policy associated with this Filter Statistics entry. This attribute has the same value as the ntnQosPolicyId attribute with which it is associated.')
ntnQosFilterStatsFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 2), IndexIntegerOrZero())
if mibBuilder.loadTexts: ntnQosFilterStatsFilterId.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsFilterId.setDescription('An index component that identifies the filter instance within a specific policy (as identified by the ntnQosFilterStatsPolicyId attribute) that is associated with this Filter Statistics entry. If the identified policy references an individual classifier (as specified by the QoS Policy Table ntnQosPolicyClassifierType attribute), the value of this attribute will be the referenced classifier component set ID. If a block of classifiers is specified, the value of this attribute will be the classifier component set identifier referenced by the block member. A special value (0) for this attribute indicates that aggregate, not individual, statistics are being maintained for the referenced policy. In this case, the filter ID of 0 should be thought of as a wildcard identifying all the classifiers associated with the policy.')
ntnQosFilterStatsInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 3), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosFilterStatsInterfaceId.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsInterfaceId.setDescription('An index component that identifies the interface index referenced by the specific policy (as identified by the ntnQosFilterStatsPolicyId attribute) that is associated with this Filter Statistics entry.')
ntnQosFilterStatsInProfileOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterStatsInProfileOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsInProfileOctets.setDescription('The number of octets considered to be in-profile that have been processed by the associated data path classifier.')
ntnQosFilterStatsInProfilePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterStatsInProfilePkts.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsInProfilePkts.setDescription('The number of packets considered to be in-profile that have been processed by the associated data path classifier.')
ntnQosFilterStatsOutOfProfileOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterStatsOutOfProfileOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsOutOfProfileOctets.setDescription('The number of octets considered to be out-of-profile that have been processed by the associated data path classifier.')
ntnQosFilterStatsOutOfProfilePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterStatsOutOfProfilePkts.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsOutOfProfilePkts.setDescription('The number of packets considered to be out-of-profile that have been processed by the associated data path classifier.')
ntnQosFilterStatsStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosFilterStatsStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosFilterStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 5, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosFilterStatsStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosPolicyDiagsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6), )
if mibBuilder.loadTexts: ntnQosPolicyDiagsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsTable.setDescription('This table contains attributes used to track the current level of hardware resource consumption related to installed policy data on an interface.')
ntnQosPolicyDiagsMasksConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsMasksConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsMasksConsumed.setDescription('Tracks the current number of classification masks in-use, due to installed policy and filter data, for a given interface.')
ntnQosPolicyDiagsFiltersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsFiltersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsFiltersConsumed.setDescription('Tracks the current number of filters (i.e., rules) in-use, due to installed filter data, for a given interface.')
ntnQosPolicyDiagsMetersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsMetersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsMetersConsumed.setDescription('Tracks the current number of meters in-use, due to installed policy data, for a given interface.')
ntnQosPolicyDiagsNonQosMasksConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosMasksConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosMasksConsumed.setDescription('Tracks the current number of classification masks in-use, not due to installed policy and filter data, for a given interface.')
ntnQosPolicyDiagsNonQosFiltersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosFiltersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosFiltersConsumed.setDescription('Tracks the current number of filters (i.e., rules) in-use, not due to installed filter data, for a given interface.')
ntnQosPolicyDiagsNonQosMetersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosMetersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsNonQosMetersConsumed.setDescription('Tracks the current number of meters in-use, not due to installed policy data, for a given interface.')
ntnQosPolicyDiagsCountersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsCountersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsCountersConsumed.setDescription('Tracks the current number of counters in-use for a given interface.')
ntnQosPolicyDiagsTotalMasksAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalMasksAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalMasksAvail.setDescription('Tracks the total number of classification masks available for a given interface.')
ntnQosPolicyDiagsTotalFiltersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalFiltersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalFiltersAvail.setDescription('Tracks the total number of filters (i.e., rules) available for a given interface.')
ntnQosPolicyDiagsTotalMetersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalMetersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalMetersAvail.setDescription('Tracks the total number of meters available for a given interface.')
ntnQosPolicyDiagsTotalCountersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalCountersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsTotalCountersAvail.setDescription('Tracks the total number of counters available for a given interface.')
ntnQosPolicyPrecResDiagsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7), )
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTable.setDescription('This table contains attributes used to track the current level of hardware resource consumption related to installed policy data for a given precedence level and interface when resources are centrally allocated.')
ntnQosPolicyPrecResDiagsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsPrec"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsInterface"))
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsEntry.setDescription('An entry in the QoS policy precedence resource diagnostics table describes a single set of resource utilization data, related to installed policy data and non-policy data that still consumes policy resources, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsPrec.setDescription('The precedence value for which resource data is being returned. In a centralized architecture, a specific precedence value is typically associated with a bank or slice of filter (rule), meter and counter resources.')
ntnQosPolicyPrecResDiagsInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsInterface.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsInterface.setDescription('The ifIndex value that is associated with this instance of the ntnQosPolicyPrecResDiagsEntry. The ifIndex value of this attribute corresponds to the ifTable entry with the same ifIndex value. When resources are centrally allocated and not port-based, a series of interfaces is typically associated with a bank or slice of filter (rule), meter and counter resources. Interfaces associated with the same slice will have the same values for the returned resource usage data.')
ntnQosPolicyPrecResDiagsKeysConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsKeysConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsKeysConsumed.setDescription('Tracks the current number of classification keys in-use, due to installed policy and filter data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsFiltersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsFiltersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsFiltersConsumed.setDescription('Tracks the current number of filters (i.e., rules) in-use, due to installed filter data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsMetersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsMetersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsMetersConsumed.setDescription('Tracks the current number of meters in-use, due to installed policy data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsNonQosKeysConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosKeysConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosKeysConsumed.setDescription('Tracks the current number of classification keys in-use, not due to installed policy and filter data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsNonQosFiltersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosFiltersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosFiltersConsumed.setDescription('Tracks the current number of filters (i.e., rules) in-use, not due to installed filter data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsNonQosMetersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosMetersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsNonQosMetersConsumed.setDescription('Tracks the current number of meters in-use, not due to installed policy data, for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsCountersConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsCountersConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsCountersConsumed.setDescription('Tracks the current number of counters in-use for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsTotalKeysAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalKeysAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalKeysAvail.setDescription('Tracks the total number of classification keys available for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsTotalFiltersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalFiltersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalFiltersAvail.setDescription('Tracks the total number of filters (i.e., rules) available for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsTotalMetersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalMetersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalMetersAvail.setDescription('Tracks the total number of meters available for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsTotalCountersAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalCountersAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsTotalCountersAvail.setDescription('Tracks the total number of counters available for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsRangeChkElemsConsumed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsRangeChkElemsConsumed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsRangeChkElemsConsumed.setDescription('Tracks the number of range check elements currently consumed for a given precedence level and interface. Note that range check resources may be centrally allocated (not interface-based) meaning that the resource usage data may be the same across the precedence levels/interfaces that share the resource.')
ntnQosPolicyPrecResDiagsApplicationIdUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsApplicationIdUsed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsApplicationIdUsed.setDescription('Tracks the Id of application in-use for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsApplicationNameUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsApplicationNameUsed.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsApplicationNameUsed.setDescription('The name of application in-use for a given precedence level and interface.')
ntnQosPolicyPrecResDiagsRangeChkElemsAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 7, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsRangeChkElemsAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsRangeChkElemsAvail.setDescription('Tracks the total number of range check elements available for a given port cluster.')
ntnQosInterfaceClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9))
ntnQosIfAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1), )
if mibBuilder.loadTexts: ntnQosIfAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentTable.setDescription('Contains interface index to interface role combination associations.')
ntnQosIfAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentIfIndex"))
if mibBuilder.loadTexts: ntnQosIfAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentEntry.setDescription('A conceptual row in the ntnQosIfAssignmentTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II) and a role combination with which the interface is associated.')
ntnQosPolicyDiagsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 8, 6, 1), )
ntnQosIfAssignmentEntry.registerAugmentions(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsEntry"))
ntnQosPolicyDiagsEntry.setIndexNames(*ntnQosIfAssignmentEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQosPolicyDiagsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsEntry.setDescription('An entry in the QoS policy diagnostics table describes a single set of resource utilization data, related to installed policy data and non-policy data that still consumes policy resources, for a given interface.')
ntnQosIfAssignmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosIfAssignmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosIfAssignmentEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosIfAssignmentRoleCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 2), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAssignmentRoleCombination.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentRoleCombination.setDescription('The role combination that is associated with the interface with an ifIndex value that is equal to ntnQosIfAssignmentIfIndex.')
ntnQosIfAssignmentQueueSet = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAssignmentQueueSet.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentQueueSet.setDescription('The queue set associated with this interface. A queue set must be defined in the ntnQosIfQueueTable prior to being referenced by this attribute.')
ntnQosIfAssignmentStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAssignmentStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosIfAssignmentStatus object is equal to active(1).')
ntnQosIfAssignmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAssignmentStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosIfAssignmentCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 1, 1, 6), Bits().clone(namedValues=NamedValues(("other", 0), ("inputIpClassification", 1), ("outputIpClassification", 2), ("input802Classification", 3), ("output802Classification", 4), ("inputSystemClassification", 5), ("outputSystemClassification", 6), ("meteringRate1023", 7), ("meteringRate16383", 8), ("meteringBucket512K", 9), ("meteringBucket8192K", 10), ("meteringGranularity64Kbps", 11), ("meteringGranularity1000Kbps", 12), ("shapingRate1023", 13), ("shapingRate16383", 14), ("shapingBucket512K", 15), ("shapingBucket8192K", 16), ("shapingGranularity64Kbps", 17), ("shapingGranularity1000Kbps", 18), ("actionIPv6Remarking", 19), ("meteringTypeSimpleTb", 20), ("meteringTypeSrTcm", 21), ("meteringTypeTrTcm", 22), ("shapingTypeInterface", 23), ("shapingTypeCos", 24), ("version1Caps", 25), ("version2Caps", 26), ("meteringRate32767", 27), ("shapingRate32767", 28), ("meteringBucket16384K", 29), ("shapingBucket16384K", 30), ("dappSupport", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosIfAssignmentCapabilities.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentCapabilities.setDescription('An enumeration of interface capabilities. Used by the PDP or network manager to select which policies and configuration it should push to the PEP. Also used to derive the capabilities that are common across several interfaces.')
ntnQosIfQueueTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2), )
if mibBuilder.loadTexts: ntnQosIfQueueTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueTable.setDescription('Contains information about the individual queues that comprise a queue set implemented on the device.')
ntnQosIfQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueId"))
if mibBuilder.loadTexts: ntnQosIfQueueEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueEntry.setDescription('A conceptual row in the ntnQosIfQueueTable. Each row identifies a specific queue within a given queue set and contains detailed information about the queue. Queues are associated with a given set through this table and a queue set is associated with an interface through the ntnQosIfAssignmentTable.')
ntnQosIfQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosIfQueueId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueId.setDescription('An index that uniquely identifies an entry in the ntnQosIfQueueTable.')
ntnQosIfQueueSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueSetId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueSetId.setDescription('An index that uniquely identifies a specific queue set. The queue set that is identified with this value is associated with an interface through the ntnQosIfAssignmentQueueSet object in the ntnQosIfAssignmentTable. The individual queues that are members of this set all have the same value for this attribute (i.e., they have the same set ID).')
ntnQosIfQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueIndex.setDescription('An arbitrary index that uniquely identifies a specific queue within a set of queues that is identified by the ntnQosIfQueueSetId value.')
ntnQosIfQueueDiscipline = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("fifo", 1), ("pq", 2), ("fq", 3), ("wfq", 4), ("wrr", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueDiscipline.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueDiscipline.setDescription('This object identifies the queuing discipline that is associated with the specified queue. A value of fifo(1) indicates that the queue is serviced on a first-in-first-out (FIFO) basis. This discipline is generally employed when only a single queue is available for a given interface. A value of pq(2) indicates that the queue is serviced using a priority queuing discipline. This technique is used when several queues are available for a given interface. Each queue is assigned a priority and queues are serviced in order of priority. Higher priority queues are completely drained before lower priority queues are serviced. A value of fq(3) indicates that the queue is serviced using a fair queuing discipline. This technique is used when several queues are available for a given interface. Each queue is treated equally and is serviced in a round-robin fashion. A value of wfq(4) indicates that the queue is serviced using a weighted fair queuing discipline. This technique is used when several queues are available for a given interface. Each queue is serviced based on queue weights which determine the scheduling and frequency of queue servicing. Queues that are assigned a greater weight are implicitly provided with more bandwidth. A value of wrr(5) indicates that the queue is serviced using a weighted round robin discipline. This technique is used when several queues are available for a given interface. Each queue is serviced based on queue weights which determine the scheduling and frequency of queue servicing. Queues that are assigned a greater weight are implicitly provided with more bandwidth. Note that the processing disciplines for all of the queues in a given set must be considered when trying to establish a processing profile for a given interface.')
ntnQosIfQueueDrainSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueDrainSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueDrainSize.setDescription('The maximum number of bytes that may be drained from the queue in one cycle. The percentage of the interface bandwidth allocated to this queue can be calculated from this attribute and the sum of the drain sizes of all the queues in a specific queue cluster in a queue set. This attribute represents the relative bandwidth that is available to a given queue with respect to other queues with which it is associated. The absolute bandwidth that is available to a given queue is specified by the attribute ntnQosIfQueueAbsBandwidth. Which of these two applies is specified by the attribute ntnQosIfQueueBandwidthAllocation.')
ntnQosIfQueueAbsBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueAbsBandwidth.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueAbsBandwidth.setDescription('The maximum interface bandwidth that is available for consumption when servicing this queue. This bandwidth is specified in terms of kilobits per second. This attribute represents the absolute bandwidth that is available to a given queue. The relative bandwidth that is available to a given queue, with respect to other queues with which it is associated, is specified by the attribute ntnQosIfQueueDrainSize. Which of these two applies is specified by the attribute ntnQosIfQueueBandwidthAllocation.')
ntnQosIfQueueBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absolute", 1), ("relative", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueBandwidthAllocation.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueBandwidthAllocation.setDescription('This attribute specifies whether to configure the queue for an absolute bandwidth limit or one that is relative to other queues of the interface. i.e., whether to configure the queue using ntnQosIfQueueAbsBandwidth or ntnQosIfQueueDrainSize.')
ntnQosIfQueueServiceOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueServiceOrder.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueServiceOrder.setDescription("This object is used to provide an additional level of priority that is required for certain queuing disciplines and when the different queues that comprise a queue set are serviced using a mix of queuing disciplines. This object can be used to specify, for example, the order in which queues will be serviced when priority queuing is used. It also supports the ability to describe the servicing hierarchy when a hybrid queuing scheme, such as priority queuing coupled with weighted fair queuing, is used. Queue service priority is assigned such that a lower service order value indicates a higher priority. For example, a priority queue with a value of 1 will be serviced (i.e., drained) before another priority queue with a service order value of 2. Note that multiple queues that are logically associated, based on the queuing discipline that is being employed, will be assigned the same service order value. Under this scenario, other parameters that are related to the queuing discipline determine the order of queue servicing (e.g., queue drain size is used for 'wfq'). For example, an interface that is associated with a queue set supporting two priority queues and three queues that are serviced using WFQ would be modeled as follows: Q Index Q Discipline Q Drain Size Q Service Order 22 pq(1) - 1 23 pq(1) - 2 24 wfq(3) 500 3 25 wfq(3) 350 3 26 wfq(3) 150 3 The queue set presented in this example would service all queued traffic in queue 22 first, followed by all of the queued traffic in queue 23. Next the queued traffic in queues 24 through 26 would be serviced in a round robin fashion with queue 24 receiving 50% of the available bandwidth, queue 25 receiving 35% of the available bandwidth and queue 26 receiving 15% of the available bandwidth. This example is presented for expository purposes and has been simplified accordingly. Note that, in this example, queues 24, 25 and 26 form a queue cluster. Members of a queue cluster are all assigned the same ntnQosIfQueueServiceOrder as there are tightly coupled. The ntnQosIfQueueDrainSize attribute is used to determine the additional processing characteristics of the individual queues in a cluster.")
ntnQosIfQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueSize.setDescription('The size of the queue in bytes. Some devices set queue size in terms of packets. These devices must calculate the queue size in packets by assuming an average packet size suitable for the particular interface. Some devices have a fixed size buffer to be shared among all queues. These devices must allocate a fraction of the total buffer space to this queue calculated as the the ratio of the queue size to the sum of the queue sizes for the interface.')
ntnQosIfQueueStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosIfQueueStatus object is equal to active(1).')
ntnQosIfQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfQueueStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosInterfaceRoleNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosInterfaceRoleNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleNextFree.setDescription('This object contains an unused value for ntnQosInterfaceRoleId, or a zero to indicate that none exist.')
ntnQosInterfaceRoleTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4), )
if mibBuilder.loadTexts: ntnQosInterfaceRoleTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleTable.setDescription('Interface role definitions. This class describes the interface roles that exist on the device. An interface role is denoted by its designated role identifier.')
ntnQosInterfaceRoleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleId"))
if mibBuilder.loadTexts: ntnQosInterfaceRoleEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleEntry.setDescription('An instance of this class describes the characteristics of an interface role. Interface role characteristics include a role identifier, an interface class designation and a filter capabilities attribute.')
ntnQosInterfaceRoleId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosInterfaceRoleId.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleId.setDescription('An arbitrary integer index that uniquely identifies a instance of the ntnQosInterfaceRole class. Class instances may not be contiguous.')
ntnQosInterfaceRoleRole = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 2), Role()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceRoleRole.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleRole.setDescription('The role that is used to identify interfaces with the characteristics specified by the attributes of this class instance. Interface role combination identifiers are used within a number of classes to logically identify a physical set of interfaces to which policy rules and actions are applied. Role combinations are comprised of one or more roles defined in this table. Role identifiers must exist in this table prior to being referenced in other class instances.')
ntnQosInterfaceRoleIfClass = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("trusted", 1), ("nonTrusted", 2), ("unrestricted", 3), ("untrustedv4v6", 4), ("untrustedBasic", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceRoleIfClass.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleIfClass.setDescription('A value describing the overall classification of traffic received on interfaces with the given role. Traffic received on trusted interfaces may be processed differently and be subject to different restrictions that traffic received on non-trusted interfaces. The treatment of traffic based on interface class is implementation dependent.')
ntnQosInterfaceRoleCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 4), Bits().clone(namedValues=NamedValues(("other", 0), ("inputIpClassification", 1), ("outputIpClassification", 2), ("input802Classification", 3), ("output802Classification", 4), ("inputSystemClassification", 5), ("outputSystemClassification", 6), ("meteringRate1023", 7), ("meteringRate16383", 8), ("meteringBucket512K", 9), ("meteringBucket8192K", 10), ("meteringGranularity64Kbps", 11), ("meteringGranularity1000Kbps", 12), ("shapingRate1023", 13), ("shapingRate16383", 14), ("shapingBucket512K", 15), ("shapingBucket8192K", 16), ("shapingGranularity64Kbps", 17), ("shapingGranularity1000Kbps", 18), ("actionIPv6Remarking", 19), ("meteringTypeSimpleTb", 20), ("meteringTypeSrTcm", 21), ("meteringTypeTrTcm", 22), ("shapingTypeInterface", 23), ("shapingTypeCos", 24), ("version1Caps", 25), ("version2Caps", 26), ("meteringRate32767", 27), ("shapingRate32767", 28), ("meteringBucket16384K", 29), ("shapingBucket16384K", 30)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceRoleCapabilities.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleCapabilities.setDescription('An enumeration of interface capabilities. Used by the PDP or network manager to select which policies and configuration it should push to the PEP.')
ntnQosInterfaceRoleStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceRoleStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosInterfaceRoleStatus object is equal to active(1).')
ntnQosInterfaceRoleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceRoleStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosInterfaceRoleStatsTrackingType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("individual", 2), ("aggregate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosInterfaceRoleStatsTrackingType.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleStatsTrackingType.setDescription('The value of this attribute determines if statistics tracking is enabled for system-level policies associated with the designated role. The ntnQosConfigTrackStatistics attribute value at the time the role is created provides the default value for this object.')
ntnQosUserRoleTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5), )
if mibBuilder.loadTexts: ntnQosUserRoleTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleTable.setDescription('User role definitions. This class describes the user roles that exist on the device. User roles associate a user and role with a single interface.')
ntnQosUserRoleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleIfIndex"))
if mibBuilder.loadTexts: ntnQosUserRoleEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleEntry.setDescription('An instance of this class describes the characteristics of an user role. User role characteristics include a role combination, a user and group name and user session attributes, such as a session identifier and a session initiation timestamp.')
ntnQosUserRoleIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosUserRoleIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosUserRoleEntry. The ifIndex value of this attribute must correspond to an ifTable entry with the same ifIndex value.')
ntnQosUserRoleRoleCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 2), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserRoleRoleCombination.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleRoleCombination.setDescription('The role combination that is associated with the interface with an ifIndex value that is equal to ntnQosUserRoleIfIndex and the user identified by the ntnQosUserRoleUserName attribute. A user role combination is used to logically identify a physical interface to which policy rules and actions can be applied. The role combination string must be unique from any other role combinations defined in system.')
ntnQosUserRoleUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserRoleUserName.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleUserName.setDescription('The user name identifying the user that is currently associated with this user role (i.e., ifIndex and role combination) information.')
ntnQosUserRoleUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserRoleUserGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleUserGroup.setDescription('The user group with which the user, identified by the ntnQosUserRoleUserName attribute, is associated.')
ntnQosUserRoleSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserRoleSessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleSessionId.setDescription('The system-assigned session identifier used to track instances of this user role entry (i.e., the user role entry for a specific interface and user).')
ntnQosUserRoleSessionStart = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 6), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserRoleSessionStart.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleSessionStart.setDescription('The system-assigned session start timestamp. The value of this attribute corresponds to the value of the sysUpTime attribute, coverted to seconds, at the instant that this user role entry is created and/or updated.')
ntnQosUserRoleSessionGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserRoleSessionGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleSessionGroup.setDescription('The system-assigned session group identifier. Multiple user sessions belong to the same group if they share the same role combination and have the same value for this attribute. This session group value is associated with installed policy criteria to unambiguously identify the users and interfaces to which QoS policy is being applied.')
ntnQosUserRoleStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 8), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserRoleStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosUserRoleStatus object is equal to active(1).')
ntnQosUserRoleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 5, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserRoleStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosIfShapingTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6), )
if mibBuilder.loadTexts: ntnQosIfShapingTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingTable.setDescription('Identifies shaping criteria that is to be applied to a specific interface.')
ntnQosIfShapingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfShapingIfIndex"))
if mibBuilder.loadTexts: ntnQosIfShapingEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingEntry.setDescription('A conceptual row in the ntnQosIfShapingTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II) and shaping criteria with which the interface is associated.')
ntnQosIfShapingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosIfShapingIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosIfShapingEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosIfShapingSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1, 2), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfShapingSpecific.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingSpecific.setDescription('This indicates the shaping behavior to be applied by pointing to an entry containing detailed parameters. Note that entries in that specific table must be managed explicitly. For example, ntnQosIfShapingSpecific may point to an entry in ntnQosTBParamTable, which contains an instance of a single set of Token Bucket parameters. Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table.')
ntnQosIfShapingLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfShapingLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingLabel.setDescription('A label used to reference the interface shaping data in a textual manner.')
ntnQosIfShapingStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfShapingStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosIfShapingStatus object is equal to active(1).')
ntnQosIfShapingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfShapingStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosCosShapingTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7), )
if mibBuilder.loadTexts: ntnQosCosShapingTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingTable.setDescription("Identifies shaping criteria that is to be applied to a specific interface's CoS queues.")
ntnQosCosShapingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingIfIndex"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingCos"))
if mibBuilder.loadTexts: ntnQosCosShapingEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingEntry.setDescription('A conceptual row in the ntnQosCosShapingTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II), a CoS value and shaping criteria with which the interface-CoS tuple is associated.')
ntnQosCosShapingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosCosShapingIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosCosShapingEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosCosShapingCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 2), QosIeee802Cos())
if mibBuilder.loadTexts: ntnQosCosShapingCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingCos.setDescription('The IEEE 802 CoS value that is associated with this instance of the ntnQosCosShapingEntry.')
ntnQosCosShapingSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 3), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosShapingSpecific.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingSpecific.setDescription('This indicates the shaping behavior to be applied by pointing to an entry containing detailed parameters. Note that entries in that specific table must be managed explicitly. For example, ntnQosCosShapingSpecific may point to an entry in ntnQosTBParamTable, which contains an instance of a single set of Token Bucket parameters. Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table.')
ntnQosCosShapingLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosShapingLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingLabel.setDescription('A label used to reference the CoS shaping data in a textual manner.')
ntnQosCosShapingStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosShapingStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosCosShapingStatus object is equal to active(1).')
ntnQosCosShapingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 7, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosShapingStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosQueueShapingTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8), )
if mibBuilder.loadTexts: ntnQosQueueShapingTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingTable.setDescription("Identifies shaping criteria that is to be applied to a specific interface's egress queues.")
ntnQosQueueShapingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingIfIndex"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingQueue"))
if mibBuilder.loadTexts: ntnQosQueueShapingEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingEntry.setDescription('A conceptual row in the ntnQosQueueShapingTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II), a queue identifier and shaping criteria with which the interface-queue tuple is associated.')
ntnQosQueueShapingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosQueueShapingIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosQueueShapingEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosQueueShapingQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ntnQosQueueShapingQueue.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingQueue.setDescription('The specific queue, within the queue set that is associated with the interface identified by the ntnQosQueueShapingIfIndex value, on which traffic is to be shaped. The value of this attribute corresponds to the ntnQosIfQueueIndex for the specified queue within the queue set (defined in the ntnQosIfQueueTable). The range of acceptable values for this attribute is dictated by the current queue set parameters for the system, as defined by the QoS configuration attribute ntnQosConfigDefaultQueueCfg.')
ntnQosQueueShapingSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 3), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQueueShapingSpecific.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingSpecific.setDescription('This indicates the shaping behavior to be applied by pointing to an entry containing detailed parameters. Note that entries in that specific table must be managed explicitly. For example, ntnQosQueueShapingSpecific may point to an entry in ntnQosTBParamTable, which contains an instance of a single set of Token Bucket parameters. Entries in other tables must exist prior to being referenced. It may be permissible to create component table entries and the entries being referenced in the same request. Referenced entries may not be deleted while still referenced by an active entry in this table.')
ntnQosQueueShapingLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQueueShapingLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingLabel.setDescription('A label used to reference the queue shaping data in a textual manner.')
ntnQosQueueShapingStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQueueShapingStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosQueueShapingStatus object is equal to active(1).')
ntnQosQueueShapingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 9, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosQueueShapingStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosMappingClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10))
ntnQosDscpToCosTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1), )
if mibBuilder.loadTexts: ntnQosDscpToCosTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosTable.setDescription('Maps each DSCP to an IEEE COS value.')
ntnQosDscpToCosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosId"))
if mibBuilder.loadTexts: ntnQosDscpToCosEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosEntry.setDescription('An instance of the ntnQosDscpToCos class. A total of 64 class instances are constantly maintained (i.e., entries may be modified but not added or deleted) in this table.')
ntnQosDscpToCosId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosDscpToCosId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosId.setDescription('A unique identifier for this DSCP-to-COS mapping.')
ntnQosDscpToCosDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 2), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosDscp.setDescription('The DSCP attribute that is used to determine the appropriate Layer 2 COS value for mapping purposes. DSCP values 0 through 63 (inclusive) are maintained in the table.')
ntnQosDscpToCosCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 3), QosIeee802Cos()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosCos.setDescription('The IEEE 802 COS value to use when mapping the DSCP value specified by the ntnQosDscpToCosDscp attribute to a IEEE 802 COS.')
ntnQosDscpToCosDropPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosDropPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosDropPrec.setDescription('The relative drop precedence value to use when mapping the DSCP value specified by the ntnQosDscpToCosDscp attribute to a drop precedence. During times of congestion, packets with a hign drop precedence are discarded before those with a low drop precedence.')
ntnQosDscpToCosLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosLabel.setDescription('A label used to logically identify the mapping.')
ntnQosDscpToCosStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosDscpToCosStatus object is equal to active(1).')
ntnQosDscpToCosStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosDscpToCosNewDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 1, 1, 8), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDscpToCosNewDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosNewDscp.setDescription('Specifies a new DSCP value to be used when DSCP mutation (i.e., translation) is required.')
ntnQosCosToDscpTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2), )
if mibBuilder.loadTexts: ntnQosCosToDscpTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpTable.setDescription('Maps each of eight Layer 2 COS values to a DSCP.')
ntnQosCosToDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpId"))
if mibBuilder.loadTexts: ntnQosCosToDscpEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpEntry.setDescription('An instance of the ntnQosCosToDscp class. A total of 8 class instances are constantly maintained (i.e., entries may be modified but not added or deleted) in this table.')
ntnQosCosToDscpId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosCosToDscpId.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpId.setDescription('A unique identifier for this COS-to-DSCP mapping.')
ntnQosCosToDscpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 2), QosIeee802Cos()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosToDscpCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpCos.setDescription('The Layer 2 COS class instance attribute that is used to determine the appropriate DSCP mappings. COS values 0 through 7 (inclusive) are maintained in the table.')
ntnQosCosToDscpDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 3), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosToDscpDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpDscp.setDescription('The DSCP value to use when mapping the Layer 2 COS value specified by the ntnQosCosToDscpCos attribute to a DSCP.')
ntnQosCosToDscpLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosToDscpLabel.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpLabel.setDescription('A label used to logically identify the mapping.')
ntnQosCosToDscpStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosToDscpStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosCosToDscpStatus object is equal to active(1).')
ntnQosCosToDscpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosCosToDscpStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosMappingClassesScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 3))
ntnQosMappingRestoreDefault = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("dscpToCos", 2), ("cosToDscp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosMappingRestoreDefault.setStatus('current')
if mibBuilder.loadTexts: ntnQosMappingRestoreDefault.setDescription('The object is used to restore factory default values for the ntnQosDscpToCosTable and the ntnQosCosToDscpTable. Setting the object to dscpToCos(2) will restore the ntnQosDscpToCosTable to its factory default state, and will restore the value of ntnQosMappingDscpToCosEnabled to its factory default value. Setting the object to cosToDscp(2) will restore the ntnQosCosToDscpTable to its factory default state, and will restore the value of ntnQosMappingCosToDscpEnabled to its factory default value. Setting the value to other(1) has no effect. The value when retrieved is always other(1).')
ntnQosMappingDscpToCosEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 3, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosMappingDscpToCosEnabled.setStatus('current')
if mibBuilder.loadTexts: ntnQosMappingDscpToCosEnabled.setDescription('This object controls whether the ntnQosDscpToCosTable is enabled. If the value is false(2), any configuration in that table will be ignored.')
ntnQosMappingCosToDscpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 10, 3, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosMappingCosToDscpEnabled.setStatus('current')
if mibBuilder.loadTexts: ntnQosMappingCosToDscpEnabled.setDescription('This object controls whether the ntnQosCosToDscpTable is enabled. If the value is false(2), any configuration in that table will be ignored.')
ntnQosPolicyAgtClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11))
ntnQosPrcSupportTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1), )
if mibBuilder.loadTexts: ntnQosPrcSupportTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportTable.setDescription('Each instance of this class specifies a PRC that the device supports and a bit string to indicate the attributes of the class that are supported.')
ntnQosPrcSupportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportId"))
if mibBuilder.loadTexts: ntnQosPrcSupportEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportEntry.setDescription('An instance of the ntnQosPrcSupport class that identifies a specific policy class and associated attributes as supported by the device.')
ntnQosPrcSupportId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosPrcSupportId.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportId.setDescription('An arbitrary integer index that uniquely identifies an instance of the ntnQosPrcSupport class.')
ntnQosPrcSupportSupportedPrc = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPrcSupportSupportedPrc.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportSupportedPrc.setDescription('The object identifier of a supported PRC. There may not be more than one instance of the ntnQosPrcSupport class with the same value of ntnQosPrcSupportSupportedPrc.')
ntnQosPrcSupportSupportedAttrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPrcSupportSupportedAttrs.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportSupportedAttrs.setDescription("A bit string representing the supported attributes of the class that is identified by the ntnQosPrcSupportSupportedPrc object. Each bit of this bit mask corresponds to a class attribute, with the most significant bit of the i-th octet of this octet string corresponding to the (8*i - 7)-th attribute, and the least significant bit of the i-th octet corresponding to the (8*i)-th class attribute. Each bit of this bit mask specifies whether or not the corresponding class attribute is currently supported, with a '1' indicating support and a '0' indicating no support. If the value of this bit mask is N bits long and there are more than N class attributes then the bit mask is logically extended with 0's to the required length.")
ntnQosPrcSupportMaxPris = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPrcSupportMaxPris.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportMaxPris.setDescription('A non-negative value indicating the maximum numbers of policy rule instances that can be installed in the identified policy rule class. Note that actual number of instances that can be installed in a PRC at any given time may be less than this value based on the current operational state (e.g., resources currently consumed) of the device.')
ntnQosPrcSupportCurrentPris = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPrcSupportCurrentPris.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportCurrentPris.setDescription('The current numbers of class instances.')
ntnQosPolicyDeviceIdentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 2), )
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentTable.setDescription('This class contains a single policy rule instance that contains device-specific information.')
ntnQosPolicyDeviceIdentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDeviceIdentId"))
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentEntry.setDescription('An instance of the ntnQosPolicyDeviceIdent class. Only one instance of this policy class is ever instantiated.')
ntnQosPolicyDeviceIdentId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentId.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentId.setDescription('An index to uniquely identify an instance of this policy class.')
ntnQosPolicyDeviceIdentDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentDescr.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentDescr.setDescription('A textual description of the policy agent. This value should include the name and version identification of the policy agent hardware and software.')
ntnQosPolicyDeviceIdentMaxMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentMaxMsg.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentMaxMsg.setDescription('The maximum message size, in octets, that the device is capable of processing.')
ntnQosInterfaceTypeNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 12), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosInterfaceTypeNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeNextFree.setDescription('This object contains an unused value for ntnQosInterfaceTypeId, or a zero to indicate that none exist.')
ntnQosApplicationClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13))
ntnQosDsAccessElemNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosDsAccessElemNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemNextFree.setDescription('This object contains an unused value for ntnQosDsAccessElemId, or a zero to indicate that none exist.')
ntnQosDsAccessElemTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2), )
if mibBuilder.loadTexts: ntnQosDsAccessElemTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemTable.setDescription('A table of IP access elements that a system may use to identify and manipulate IP traffic.')
ntnQosDsAccessElemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemId"))
if mibBuilder.loadTexts: ntnQosDsAccessElemEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemEntry.setDescription('An IP access element entry describes a single filter and one or more actions.')
ntnQosDsAccessElemId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosDsAccessElemId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemId.setDescription('An index that enumerates the access element entries. Managers can obtain new values for row creation in this table by reading ntnQosDsAccessElemNextFree.')
ntnQosDsAccessElemAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemAddrType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemAddrType.setDescription('The type of IP address used by this access element entry. While other types of addresses are defined in the InetAddressType textual convention, and DNS names, a classifier can only look at packets on the wire. Therefore, this object is limited to IPv4 and IPv6 addresses.')
ntnQosDsAccessElemDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemDstAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemDstAddr.setDescription("The IP address to match against the packet's destination IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnQosDsAccessElemDstPrefixLength indicates the number of bits that are relevant.")
ntnQosDsAccessElemDstPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 4), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemDstPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemDstPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnQosDsAccessElemDstAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128.')
ntnQosDsAccessElemSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 5), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcAddr.setDescription("The IP address to match against the packet's source IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnQosDsAccessElemSrcPrefixLength indicates the number of bits that are relevant.")
ntnQosDsAccessElemSrcPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 6), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnQosDsAccessElemSrcAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128.')
ntnQosDsAccessElemDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 7), DscpOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemDscp.setDescription('The value that the DSCP in the packet must have to match this entry. A value of -1 indicates that a specific DSCP value has not been defined and thus all DSCP values are considered a match.')
ntnQosDsAccessElemFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 8), FlowIdOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemFlowId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemFlowId.setDescription('The flow identifier in an IPv6 header.')
ntnQosDsAccessElemProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemProtocol.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemProtocol.setDescription('The IP protocol to match against the IPv4 protocol number or the IPv6 Next-Header number in the packet. A value of 255 means match all. Note the protocol number of 255 is reserved by IANA, and Next-Header number of 0 is used in IPv6.')
ntnQosDsAccessElemDstL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemDstL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match this classifier entry.')
ntnQosDsAccessElemDstL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 11), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemDstL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnQosDsAccessElemDstL4PortMin.')
ntnQosDsAccessElemSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcL4PortMin.setDescription('The minimum value that the layer-4 source port number in the packet must have in order to match this classifier entry.')
ntnQosDsAccessElemSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 13), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemSrcL4PortMax.setDescription('The maximum value that the layer-4 source port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnQosDsAccessElemSrcL4PortMin.')
ntnQosDsAccessElemActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemActionDrop.setDescription("This action attribute is used to specify whether a packet should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped.")
ntnQosDsAccessElemActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated.')
ntnQosDsAccessElemActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute.")
ntnQosDsAccessElemActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'.")
ntnQosDsAccessElemName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemName.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemName.setDescription('A label used to reference the access element in a textual manner. All related access elements (e.g., those that comprise an access-list) must have the same label.')
ntnQosDsAccessElemBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 19), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemBlock.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemBlock.setDescription('A label used to identify access elements that are members of the same classification block. Access elements are members of the same block if they share the same access element name (ntnQosDsAccessElemName attribute) and the same block name.')
ntnQosDsAccessElemType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dsAcl", 1), ("dsAppClfr", 2), ("dsMultimediaClfr", 3), ("dsUserDefinedClfr", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemType.setDescription('Identifies the DS access element type. Designates the higher-level application through which this entry was created.')
ntnQosDsAccessElemStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 21), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosDsAccessElemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosDsAccessElemEvalPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 2, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsAccessElemEvalPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemEvalPrec.setDescription('An evaluation order attribute used to order elements with the same name and to link elements across DS and L2 Access Element tables. Only used with NSNA applications.')
ntnQosL2AccessElemNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 3), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosL2AccessElemNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemNextFree.setDescription('This object contains an unused value for ntnQosL2AccessElemId, or a zero to indicate that none exist.')
ntnQosL2AccessElemTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4), )
if mibBuilder.loadTexts: ntnQosL2AccessElemTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemTable.setDescription('A table of IEEE 802-based access elements that a system may use to identify and manipulate Layer 2 traffic.')
ntnQosL2AccessElemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemId"))
if mibBuilder.loadTexts: ntnQosL2AccessElemEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemEntry.setDescription('A Layer 2 access element entry describes a single filter and one or more actions.')
ntnQosL2AccessElemId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosL2AccessElemId.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemId.setDescription('An index that enumerates the access element entries. Managers can obtain new values for row creation in this table by reading ntnQosL2AccessElemNextFree.')
ntnQosL2AccessElemDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemDstAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemDstAddr.setDescription('The 802 address against which the 802 DA of incoming traffic streams will be compared. Frames whose 802 DA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnQosL2AccessElemDstAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class.')
ntnQosL2AccessElemDstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 3), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemDstAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemDstAddrMask.setDescription("This object specifies the bits in a 802 destination address that should be considered when performing a 802 DA comparison against the address specified in the ntnQosL2AccessElemDstAddr object. The value of this object represents a mask that is logically and'ed with the 802 DA in received frames to derive the value to be compared against the ntnQosL2AccessElemDstAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnQosL2AccessElemDstAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnQosL2AccessElemDstAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnQosL2AccessElemDstAddr object.")
ntnQosL2AccessElemSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 4), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemSrcAddr.setDescription('The 802 MAC address against which the 802 MAC SA of incoming traffic streams will be compared. Frames whose 802 MAC SA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnQosL2AccessElemSrcAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class.')
ntnQosL2AccessElemSrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 5), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemSrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemSrcAddrMask.setDescription("This object specifies the bits in a 802 MAC source address that should be considered when performing a 802 MAC SA comparison against the address specified in the ntnQosL2AccessElemSrcAddr object. The value of this object represents a mask that is logically and'ed with the 802 MAC SA in received frames to derive the value to be compared against the ntnQosL2AccessElemSrcAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnQosL2AccessElemSrcAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnQosL2AccessElemSrcAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnQosL2AccessElemSrcAddr object.")
ntnQosL2AccessElemVlanIdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanIdMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanIdMin.setDescription('The minimum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnQosL2AccessElemVlanIdMin value must be less than or equal to the ntnQosL2AccessElemVlanIdMax value. Setting the ntnQosL2AccessElemVlanIdMin object to 1 and the ntnQosL2AccessElemVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification.')
ntnQosL2AccessElemVlanIdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanIdMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanIdMax.setDescription('The maximum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnQosL2AccessElemVlanIdMax value must be greater than or equal to the ntnQosL2AccessElemVlanIdMin value. Setting the ntnQosL2AccessElemVlanIdMin object to 1 and the ntnQosL2AccessElemVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification.')
ntnQosL2AccessElemVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("ignore", 3))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanTag.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemVlanTag.setDescription("This object indicates the data link layer packet format that frames must have to match this L2 classifier entry. A value of 'untagged(1)' indicates that only frames received untagged will match this classifier component. A value of 'tagged(2)' means that only frames received tagged will be considered a match. A value of 'ignore(3)' means that the presence, or lack thereof, of a VLAN tag in the received packet will not be considered when determining whether a frame matches this classifier entry.")
ntnQosL2AccessElemEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemEtherType.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemEtherType.setDescription("This object specifies the value that will be compared against the value contained in the EtherType field of an IEEE 802 frame. Example settings would include 'IP' (0x0800), 'ARP' (0x0806) and 'IPX' (0x8137). Setting the ntnQosL2AccessElemEtherType object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA.")
ntnQosL2AccessElemUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("matchPriority0", 1), ("matchPriority1", 2), ("matchPriority2", 3), ("matchPriority3", 4), ("matchPriority4", 5), ("matchPriority5", 6), ("matchPriority6", 7), ("matchPriority7", 8), ("matchAllPriorities", 9))).clone('matchAllPriorities')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemUserPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemUserPriority.setDescription("The 802.1p user priority value against which the value contained in the user priority field of a tagged 802.1 frame is compared. A test for equality is performed when determining if a match exists between the data in a data link layer frame and the value of this classifier. Setting the value of this object to 'matchAllPriorities(9)' causes all user priority values to match this attribute. This essentially makes any comparisons with regard to user priority values unnecessary.")
ntnQosL2AccessElemActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemActionDrop.setDescription("This action attribute is used to specify whether a packet should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped.")
ntnQosL2AccessElemActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated.')
ntnQosL2AccessElemActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute.")
ntnQosL2AccessElemActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'.")
ntnQosL2AccessElemName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 15), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemName.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemName.setDescription('A label used to reference the access element in a textual manner. All related access elements (e.g., those that comprise an access-list) must have the same label.')
ntnQosL2AccessElemBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemBlock.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemBlock.setDescription('A label used to identify access elements that are members of the same classification block. Access elements are members of the same block if they share the same access element name (ntnQosDsAccessElemName attribute) and the same block name.')
ntnQosL2AccessElemType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("l2Acl", 1), ("l2AppClfr", 2), ("l2MultimediaClfr", 3), ("l2UserDefinedClfr", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemType.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemType.setDescription('Identifies the L2 access element type. Designates the higher-level application through which this entry was created.')
ntnQosL2AccessElemStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 18), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosL2AccessElemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosL2AccessElemEvalPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 4, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosL2AccessElemEvalPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemEvalPrec.setDescription('An evaluation order attribute used to order elements with the same name and to link elements across DS and L2 Access Element tables. Only used with NSNA applications.')
ntnQosAccessAsgnNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 5), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosAccessAsgnNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnNextFree.setDescription('This object contains an unused value for ntnQosAccessAsgnId, or a zero to indicate that none exist.')
ntnQosAccessAsgnTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6), )
if mibBuilder.loadTexts: ntnQosAccessAsgnTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnTable.setDescription('A table of access assignments that are currently in place (i.e., access element/interface associations).')
ntnQosAccessAsgnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnId"))
if mibBuilder.loadTexts: ntnQosAccessAsgnEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnEntry.setDescription('An access assignment entry describes an access element/interface association.')
ntnQosAccessAsgnId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosAccessAsgnId.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnId.setDescription('An index that enumerates the access assignment entries. Managers can obtain new values for row creation in this table by reading ntnQosAccessAsgnNextFree.')
ntnQosAccessAsgnAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("dsAcl", 1), ("l2Acl", 2), ("dsAppClfr", 3), ("l2AppClfr", 4), ("dsUserDefinedClfr", 5), ("l2UserDefinedClfr", 6), ("multimediaClfr", 7), ("dsL2NsnaClfr", 8), ("dsL2UbpClfr", 9), ("dsL2TrafficProfile", 10)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnAclType.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnAclType.setDescription('Identifies the type of access element that is being referenced.')
ntnQosAccessAsgnName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnName.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnName.setDescription('A label used to reference an access assignment in a textual manner. This label, coupled with the access element type identifier attribute (ntnQosAccessAsgnAclType), uniquely identifies an access assignment entry.')
ntnQosAccessAsgnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnIfIndex.setDescription('The interface to which the identified access element is to be applied, specified in terms of an ifIndex value. A value of 0 indicates that the entry represents a template that is used to facilitate entry creation for a specific interface based on certain events.')
ntnQosAccessAsgnRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnRate.setDescription('The token-bucket rate, in kilobits per second (kbps). This attribute is used for: CIR for Simple Token Bucket CIR in RFC 2697 for srTCM CIR in RFC 2698 for trTCM CTR in RFC 2859 for TSWTCM AverageRate in RFC 3290. A rate value equal to 0 indicates that no metering is being requested.')
ntnQosAccessAsgnBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 6), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnBurstSize.setDescription('The maximum number of bytes in a single transmission burst. This attribute is used for: Token bucket size for Simple Token Bucket CBS in RFC 2697 for srTCM CBS in RFC 2698 for trTCM Burst Size in RFC 3290.')
ntnQosAccessAsgnOutActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionDrop.setDescription("This action attribute is used to specify whether a packet deemed out-of-profile should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped.")
ntnQosAccessAsgnOutActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram that is deemed to be out-of-profile to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated.')
ntnQosAccessAsgnOutActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9), ("deriveFromEgressDscp", 10), ("deriveFromIngressTosPrec", 11))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame that is deemed to be out-of-profile to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute. Specifying a value equal to 'deriveFromEgressDscp(10)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value specified for remarking in the ntnQosAccessAsgnOutActionRemarkDscp attribute will be used to determine the user priority. Specifying a value equal to 'deriveFromIngressTosPrec(11)' means that the value for this attribute will be assigned based on the value of the precedence bits in the IP Type-Of-Service (TOS) field, as defined in RFC 791. The eight precedence values, also referred to as Class Selector (CS) values, have a one-to-one correspondence with the eight 802.1p user priority values.")
ntnQosAccessAsgnOutActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnOutActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'.")
ntnQosAccessAsgnStatsType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("individualClfr", 1), ("aggregateClfr", 2), ("noStatsTracking", 3))).clone('aggregateClfr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnStatsType.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnStatsType.setDescription("The type of statistics tracking used by this access assignment. The value of this attribute dictates the amount of statistics tracking resources (i.e., counters) consumed by this access assignment entry. A value of 'individualClfr(1)' means that separate counters will be allocated, space permitting, for each access element referenced by the assignment. A value of 'aggregateClfr(2)' means that a single counter will be used to accumulate the statistics data for all the classifiers referenced by the access assignment. A value of 'noStatsTracking(3)' means that no statistics tracking resources will be allocated.")
ntnQosAccessAsgnStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 12), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosAccessAsgnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
ntnQosAccessAsgnNonMatchActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2), ("defer", 3))).clone('defer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnNonMatchActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnNonMatchActionDrop.setDescription("This action attribute is used to specify whether a packet deemed out-of-profile should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped. A value of 'defer(3)' indicates that no explicit drop/pass action has been specified (i.e., no-op).")
ntnQosAccessAsgnMeterType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 15), AutonomousType().clone((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 6, 5, 1))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnMeterType.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnMeterType.setDescription('The metering algorithm associated with the rate and burst parameters. The number and type of algorithms supported is implementation dependent. Potential algorithms include: ntnQosTBParamSimpleTokenBucket ntnQosTBParamSrTCMBlind ntnQosTBParamSrTCMAware ntnQosTBParamTrTCMBlind ntnQosTBParamTrTCMAware An OBJECT-IDENTITY for each of these algorithms is defined in this module. Additional values may be specified as needed.')
ntnQosAccessAsgnSecondaryRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnSecondaryRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnSecondaryRate.setDescription('The token-bucket rate, in kilobits per second (kbps). This attribute is used for: PIR in RFC 2698 for trTCM A rate value equal to 0 indicates that no secondary metering is being requested.')
ntnQosAccessAsgnSecondaryBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 17), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnSecondaryBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnSecondaryBurstSize.setDescription('The maximum number of bytes in a single transmission burst. This attribute is used for: EBS in RFC 2697 for srTCM PBS in RFC 2698 for trTCM.')
ntnQosAccessAsgnYelActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionDrop.setDescription("This action attribute is used to specify whether a packet deemed out-of-profile should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped. Applies to yellow actions.")
ntnQosAccessAsgnYelActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram that is deemed to be out-of-profile to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated. Applies to yellow actions.')
ntnQosAccessAsgnYelActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame that is deemed to be out-of-profile to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute. Applies to yellow actions.")
ntnQosAccessAsgnYelActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnYelActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'. Applies to yellow actions.")
ntnQosAccessAsgnSetPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnSetPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnSetPriority.setDescription('Supports filter set prioritization when multiple filters sets may be associated with an entity (e.g., user, interface) but only one can be applied at the given time. The set with a higher priority value will take precedence and supercede the set with a lower priority value. When priority values are equal, no filter set update will occur. Consulted only when an entity/filter set conflict needs resolution.')
ntnQosAccessAsgnMeteringMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noMetering", 1), ("perPolicyUniformRateMetering", 2), ("perPolicyIndividualRateMetering", 3), ("perClassifierMetering", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosAccessAsgnMeteringMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnMeteringMode.setDescription("Identifies the metering mode requested for the identified filter set. A value of 'noMetering(1)' indicates that metering is not requested for the components of the identified filter set. A 'perPolicyUniformRateMetering(2)' value indicates that a unique meter will be associated with each policy that comprises the identified filter set. Uniform rate and burst data will be used for all meters. A 'perPolicyIndividualRateMetering(3)' value indicates that a unique meter will be associated with each policy that comprises the identified filter set. Unique rate and burst data derived from the associated classifier data will be used for each meter. Setting the attribute to 'perClassifierMetering(4)' will initiate metering on a per-classifier basis. Rate and burst data will be derived from the associated classifier data. The presence of this data will determine whether or not a meter is allocated for the classifier.")
ntnQosIfAppsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7), )
if mibBuilder.loadTexts: ntnQosIfAppsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsTable.setDescription('Identifies QoS/security application criteria that is to be applied to a specific interface.')
ntnQosIfAppsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsIfIndex"))
if mibBuilder.loadTexts: ntnQosIfAppsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsEntry.setDescription('A conceptual row in the ntnQosIfAppsTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II) and application criteria with which the interface is associated.')
ntnQosIfAppsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosIfAppsIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosIfAppsEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosIfAppsAppEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 2), Bits().clone(namedValues=NamedValues(("other", 0), ("arpSpoofing", 1), ("dhcpSnooping", 2), ("dhcpSpoofing", 3), ("sqlSlam", 4), ("nachia", 5), ("xmas", 6), ("synFinScan", 7), ("ftpPort", 8), ("dnsPort", 9), ("bpduBlocker", 10)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsAppEnable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsAppEnable.setDescription('An enumeration of interface applications. Indicates which applications, if any, apply to the associated interface.')
ntnQosIfAppsDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 3), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsDefaultGateway.setDescription('The IP address of the default gateway to be used when defining the policy criteria used by the ARP Spoofing support.')
ntnQosIfAppsIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("core", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsIfType.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsIfType.setDescription('A value describing the overall interface type. Used when determining whether the DHCP Blocking support should be applied to the associated interface.')
ntnQosIfAppsDHCPServer = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 5), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsDHCPServer.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsDHCPServer.setDescription('The IP address of the DHCP Server to be used when defining the policy criteria used by the DHCP Spoofing support.')
ntnQosIfAppsStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosIfAppsStatus object is equal to active(1).')
ntnQosIfAppsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 7, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfAppsStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosUserPolicyNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 8), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserPolicyNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyNextFree.setDescription('This object contains an unused value for ntnQosUserPolicyId, or a zero to indicate that none exist.')
ntnQosUserPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9), )
if mibBuilder.loadTexts: ntnQosUserPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyTable.setDescription('User policy definitions. This class describes the user policy data that exists on the device. User policy data associates a user and role with an interface.')
ntnQosUserPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyId"))
if mibBuilder.loadTexts: ntnQosUserPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyEntry.setDescription('An instance of this class describes the characteristics of a user policy data set. User policy data set components include a role combination, a user and group name and user session attributes, such as a session identifier and a session initiation timestamp.')
ntnQosUserPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosUserPolicyId.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyId.setDescription('An index that enumerates the user policy entries. Managers can obtain new values for row creation in this table by reading ntnQosUserPolicyNextFree.')
ntnQosUserPolicyIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosUserPolicyEntry. The ifIndex value of this attribute must correspond to an ifTable entry with the same ifIndex value.')
ntnQosUserPolicyRoleCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 3), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyRoleCombination.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyRoleCombination.setDescription('The role combination that is associated with the interface with an ifIndex value that is equal to ntnQosUserPolicyIfIndex and the user identified by the ntnQosUserPolicyUserName attribute. A user role combination is used to logically identify a physical interface to which policy rules and actions can be applied. The role combination string must be unique from any other role combinations defined in system.')
ntnQosUserPolicyUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyUserName.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyUserName.setDescription('The user name identifying the user that is currently associated with this user policy (i.e., ifIndex and role combination) information.')
ntnQosUserPolicyUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyUserGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyUserGroup.setDescription('The user group with which the user, identified by the ntnQosUserPolicyUserName attribute, is associated.')
ntnQosUserPolicySessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserPolicySessionId.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicySessionId.setDescription('The system-assigned session identifier used to track instances of this user policy entry (i.e., the user policy entry for a specific interface and user).')
ntnQosUserPolicySessionStart = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 7), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserPolicySessionStart.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicySessionStart.setDescription('The system-assigned session start timestamp. The value of this attribute corresponds to the value of the sysUpTime attribute, coverted to seconds, at the instant that this user policy entry is created and/or updated.')
ntnQosUserPolicySessionGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosUserPolicySessionGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicySessionGroup.setDescription('The system-assigned session group identifier. Multiple user sessions belong to the same group if they share the same role combination and have the same value for this attribute. This session group value is associated with installed policy criteria to unambiguously identify the users and interfaces to which QoS policy is being applied.')
ntnQosUserPolicyStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 9), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyStorage.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosUserPolicyStatus object is equal to active(1).')
ntnQosUserPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosUserPolicySrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 11), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicySrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicySrcMacAddr.setDescription("The 802 source MAC address associated with the identified user. If specified, this address will automatically be used in associated user policy criteria to uniquely identify user traffic on an interface on which potentially other users' traffic will be present.")
ntnQosUserPolicySrcMacAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 9, 1, 12), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosUserPolicySrcMacAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicySrcMacAddrMask.setDescription("This object specifies the bits in an 802 source MAC address that should be considered when performing a 802 MAC SA comparison against the address specified in the ntnQosUserPolicySrcMacAddr object. The value of this object represents a mask that is logically and'ed with the 802 MAC SA in received frames to derive the value to be compared against the ntnQosUserPolicySrcMacAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnQosUserPolicySrcMacAddr value must also be masked using this value prior to any comparisons. The length of this object in bytes must equal the length in bytes of the ntnQosUserPolicySrcMacAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnQosUserPolicySrcMacAddr object.")
ntnQosDsL2AccessElemNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 10), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemNextFree.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemNextFree.setDescription('This object contains an unused value for ntnQosDsL2AccessElemId, or a zero to indicate that none exist.')
ntnQosDsL2AccessElemTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11), )
if mibBuilder.loadTexts: ntnQosDsL2AccessElemTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemTable.setDescription('A table of IP/L2 access elements that a system may use to identify and manipulate IP/L2 traffic.')
ntnQosDsL2AccessElemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemId"))
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEntry.setDescription('An IP/L2 access element entry describes a single filter and one or more actions.')
ntnQosDsL2AccessElemId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosDsL2AccessElemId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemId.setDescription('An index that enumerates the access element entries. Managers can obtain new values for row creation in this table by reading ntnQosDsL2AccessElemNextFree. Version 1/2 attribute.')
ntnQosDsL2AccessElemAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemAddrType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemAddrType.setDescription('The type of IP address used by this access element entry. While other types of addresses are defined in the InetAddressType textual convention, and DNS names, a classifier can only look at packets on the wire. Therefore, this object is limited to IPv4 and IPv6 addresses. Version 1/2 attribute.')
ntnQosDsL2AccessElemDstIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstIpAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstIpAddr.setDescription("The IP address to match against the packet's destination IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnQosDsL2AccessElemDstIpPrefixLength indicates the number of bits that are relevant. Version 1/2 attribute.")
ntnQosDsL2AccessElemDstIpPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 4), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstIpPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstIpPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnQosDsL2AccessElemDstIpAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128. Version 1/2 attribute.')
ntnQosDsL2AccessElemSrcIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 5), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcIpAddr.setDescription("The IP address to match against the packet's source IP address. This may not be a DNS name, but may be an IPv4 or IPv6 prefix. ntnQosDsL2AccessElemSrcIpPrefixLength indicates the number of bits that are relevant. Version 1/2 attribute.")
ntnQosDsL2AccessElemSrcIpPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 6), InetAddressPrefixLength()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcIpPrefixLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcIpPrefixLength.setDescription('The length of the CIDR Prefix carried in ntnQosDsL2AccessElemSrcIpAddr. In IPv4 addresses, a length of 0 indicates a match of any address; a length of 32 indicates a match of a single host address, and a length between 0 and 32 indicates the use of a CIDR Prefix. IPv6 is similar, except that prefix lengths range from 0..128. Version 1/2 attribute.')
ntnQosDsL2AccessElemDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 7), DscpOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDscp.setDescription('The value that the DSCP in the packet must have to match this entry. A value of -1 indicates that a specific DSCP value has not been defined and thus all DSCP values are considered a match. Version 1/2 attribute.')
ntnQosDsL2AccessElemFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 8), FlowIdOrAny().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemFlowId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemFlowId.setDescription('The flow identifier in an IPv6 header. Version 1/2 attribute.')
ntnQosDsL2AccessElemProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemProtocol.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemProtocol.setDescription('The IP protocol to match against the IPv4 protocol number or the IPv6 Next-Header number in the packet. A value of 255 means match all. Note the protocol number of 255 is reserved by IANA, and Next-Header number of 0 is used in IPv6. Version 1/2 attribute.')
ntnQosDsL2AccessElemDstL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. Version 1/2 attribute.')
ntnQosDsL2AccessElemDstL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 11), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnQosDsL2AccessElemDstL4PortMin. Version 1/2 attribute.')
ntnQosDsL2AccessElemSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcL4PortMin.setDescription('The minimum value that the layer-4 source port number in the packet must have in order to match this classifier entry. Version 1/2 attribute.')
ntnQosDsL2AccessElemSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 13), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcL4PortMax.setDescription('The maximum value that the layer-4 source port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in ntnQosDsL2AccessElemSrcL4PortMin. Version 1/2 attribute.')
ntnQosDsL2AccessElemDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 14), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstMacAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstMacAddr.setDescription('The 802 address against which the 802 DA of incoming traffic streams will be compared. Frames whose 802 DA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnQosDsL2AccessElemDstMacAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class. Version 1/2 attribute.')
ntnQosDsL2AccessElemDstMacAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 15), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstMacAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemDstMacAddrMask.setDescription("This object specifies the bits in a 802 destination address that should be considered when performing a 802 DA comparison against the address specified in the ntnQosDsL2AccessElemDstMacAddr object. The value of this object represents a mask that is logically and'ed with the 802 DA in received frames to derive the value to be compared against the ntnQosDsL2AccessElemDstMacAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnQosDsL2AccessElemDstMacAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnQosDsL2AccessElemDstMacAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnQosDsL2AccessElemDstMacAddr object. Version 1/2 attribute.")
ntnQosDsL2AccessElemSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 16), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcMacAddr.setDescription('The 802 MAC address against which the 802 MAC SA of incoming traffic streams will be compared. Frames whose 802 MAC SA matches the physical address specified by this object, taking into account address wildcarding as specified by the ntnQosDsL2AccessElemSrcMacAddrMask object, are potentially subject to the processing guidelines that are associated with this entry through the related action class. Version 1/2 attribute.')
ntnQosDsL2AccessElemSrcMacAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 17), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcMacAddrMask.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSrcMacAddrMask.setDescription("This object specifies the bits in a 802 MAC source address that should be considered when performing a 802 MAC SA comparison against the address specified in the ntnQosDsL2AccessElemSrcMacAddr object. The value of this object represents a mask that is logically and'ed with the 802 MAC SA in received frames to derive the value to be compared against the ntnQosDsL2AccessElemSrcMacAddr address. A zero bit in the mask thus means that the corresponding bit in the address always matches. The ntnQosDsL2AccessElemSrcMacAddr value must also be masked using this value prior to any comparisons. The length of this object in octets must equal the length in octets of the ntnQosDsL2AccessElemSrcMacAddr. Note that a mask with no bits set (i.e., all zeroes) effectively wildcards the ntnQosDsL2AccessElemSrcMacAddr object. Version 1/2 attribute.")
ntnQosDsL2AccessElemVlanIdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanIdMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanIdMin.setDescription('The minimum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnQosDsL2AccessElemVlanIdMin value must be less than or equal to the ntnQosDsL2AccessElemVlanIdMax value. Setting the ntnQosDsL2AccessElemVlanIdMin object to 1 and the ntnQosDsL2AccessElemVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification. If a frame is double tagged, this value represents the outer VLAN ID (Ovid). Version 1/2 attribute.')
ntnQosDsL2AccessElemVlanIdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanIdMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanIdMax.setDescription('The maximum value that the VLAN ID (VID) in a tagged packet must have in order to match this classifier entry. The ntnQosDsL2AccessElemVlanIdMax value must be greater than or equal to the ntnQosDsL2AccessElemVlanIdMin value. Setting the ntnQosDsL2AccessElemVlanIdMin object to 1 and the ntnQosDsL2AccessElemVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic classification. If a frame is double tagged, this value represents the outer VLAN ID (Ovid). Version 1/2 attribute.')
ntnQosDsL2AccessElemVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("ignore", 3), ("doubleTagged", 4))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanTag.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVlanTag.setDescription("This object indicates the data link layer packet format that frames must have to match this L2 classifier entry. A value of 'untagged(1)' indicates that only frames received untagged will match this classifier component. A value of 'tagged(2)' means that only frames received tagged (both single tagged and double tagged) will be considered a match. A value of 'ignore(3)' means that the presence, or lack thereof, of a VLAN tag in the received packet will not be considered when determining whether a frame matches this classifier entry. A value of 'doubleTagged(4)' means that only frames received with an inner and outer tag (i.e., a double tagged frame) will be considered a match. Version 1/2 attribute.")
ntnQosDsL2AccessElemEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEtherType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEtherType.setDescription("This object specifies the value that will be compared against the value contained in the EtherType field of an IEEE 802 frame. Example settings would include 'IP' (0x0800), 'ARP' (0x0806) and 'IPX' (0x8137). Setting the ntnQosDsL2AccessElemEtherType object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA. Version 1/2 attribute.")
ntnQosDsL2AccessElemUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("matchPriority0", 1), ("matchPriority1", 2), ("matchPriority2", 3), ("matchPriority3", 4), ("matchPriority4", 5), ("matchPriority5", 6), ("matchPriority6", 7), ("matchPriority7", 8), ("matchAllPriorities", 9))).clone('matchAllPriorities')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUserPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUserPriority.setDescription("The 802.1p user priority value against which the value contained in the user priority field of a tagged 802.1 frame is compared. A test for equality is performed when determining if a match exists between the data in a data link layer frame and the value of this classifier. Setting the value of this object to 'matchAllPriorities(9)' causes all user priority values to match this attribute. This essentially makes any comparisons with regard to user priority values unnecessary. Version 1/2 attribute.")
ntnQosDsL2AccessElemActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionDrop.setDescription("This action attribute is used to specify whether a packet should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped. Version 1/2 attribute.")
ntnQosDsL2AccessElemActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated. Version 1/2 attribute.')
ntnQosDsL2AccessElemActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9), ("deriveFromEgressDscp", 10), ("deriveFromIngressTosPrec", 11))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute. Specifying a value equal to 'deriveFromEgressDscp(10)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value specified for remarking in the ntnQosDsL2AccessElemActionRemarkDscp attribute will be used to determine the user priority. Specifying a value equal to 'deriveFromIngressTosPrec(11)' means that the value for this attribute will be assigned based on the value of the precedence bits in the IP Type-Of-Service (TOS) field, as defined in RFC 791. The eight precedence values, also referred to as Class Selector (CS) values, have a one-to-one correspondence with the eight 802.1p user priority values. Version 1/2 attribute.")
ntnQosDsL2AccessElemActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'. Version 1/2 attribute.")
ntnQosDsL2AccessElemName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 27), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemName.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemName.setDescription('A label used to reference the access element in a textual manner. All related access elements (e.g., those that comprise an access-list) must have the same label. Version 1/2 attribute.')
ntnQosDsL2AccessElemBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 28), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBlock.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBlock.setDescription('A label used to identify access elements that are members of the same classification block. Access elements are members of the same block if they share the same access element name (ntnQosDsL2AccessElemName attribute) and the same block name. Version 1/2 attribute.')
ntnQosDsL2AccessElemType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dsL2NsnaClfr", 1), ("dsL2UbpClfr", 2), ("dsL2TrafficProfile", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemType.setDescription('Identifies the DS/L2 access element type. Designates the higher-level application through which this entry was created. Version 1/2 attribute.')
ntnQosDsL2AccessElemStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 30), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'. Version 1/2 attribute.")
ntnQosDsL2AccessElemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 31), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Version 1/2 attribute.')
ntnQosDsL2AccessElemEvalPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEvalPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemEvalPrec.setDescription('An evaluation order attribute used to order elements with the same name and to link elements across DS and L2 Access Element tables. Only used with NSNA applications. Version 1/2 attribute.')
ntnQosDsL2AccessElemIpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 33), Bits().clone(namedValues=NamedValues(("ipv4MfFlagSet", 0), ("ipv4DfFlagSet", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIpFlags.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIpFlags.setDescription('Represents the flags present in an IPv4 header. If a bit that is associated with a specific IP flag is set in this attribute, IPv4 packets with the specified flag set in the header will match this classifier. Version 2 attribute.')
ntnQosDsL2AccessElemTcpCtrlFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 34), Bits().clone(namedValues=NamedValues(("tcpUrgFlagSet", 0), ("tcpAckFlagSet", 1), ("tcpPshFlagSet", 2), ("tcpRstFlagSet", 3), ("tcpSynFlagSet", 4), ("tcpFinFlagSet", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemTcpCtrlFlags.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemTcpCtrlFlags.setDescription('Represents the control flags (code bits) present in an TCP header. If a bit that is associated with a specific TCP control flag is set in this attribute, TCP packets with the specified flag set in the header will match this classifier. Version 2 attribute.')
ntnQosDsL2AccessElemIpv4Options = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipv4OptionsPresent", 1), ("ipv4OptionsNotPresent", 2), ("ignore", 3))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIpv4Options.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIpv4Options.setDescription("This object indicates whether the presence, or lack thereof, of IPv4 options in an IPv4 packet should should be considered when looking for a match for this classifier entry. A value of 'ipv4OptionsPresent(1)' indicates that only IPv4 packets with options will match this classifier element. A value of 'ipv4OptionsNotPresent(2)' means that only IPv4 packets without options will be considered a match. A value of 'ignore(3)' means that the presence, or lack thereof, of IPv4 options in the received packet will not be considered when determining whether a packet matches this classifier entry. Version 2 attribute.")
ntnQosDsL2AccessElemPktType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("snap", 2), ("llc", 3), ("ignore", 4))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemPktType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemPktType.setDescription("This object indicates the data link layer frame format that frames must have to match this L2 classifier entry. A value of 'ethernetII(1)' indicates that only Ethernet II format frames will match this classifier component. A value of 'snap(2)' indicates that only IEEE 802 SNAP format frames will match this classifier component. A value of 'llc(3)' indicates that only IEEE 802 LLC format frames will match this classifier component. A value of 'ignore(4)' means that the frame, format will not be considered when determining whether a frame matches this classifier entry. Version 2 attribute.")
ntnQosDsL2AccessElemIvidMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIvidMin.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIvidMin.setDescription("The minimum value that the Inner VLAN ID (Ivid) in a double tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrIvidMin value must be less than or equal to the ntnL2MultiFieldClfrIvidMax value. Setting the ntnL2MultiFieldClfrIvidMin object to 1 and the ntnL2MultiFieldClfrIvidMax to 4094 indicates that inner VLAN tag data should not be considered during traffic classification. A non-default value for this attribute may only be specified if the ntnL2MultiFieldClfrVlanTag attribute has a value of 'doubleTagged(4)'. Version 2 attribute.")
ntnQosDsL2AccessElemIvidMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIvidMax.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemIvidMax.setDescription("The maximum value that the Inner VLAN ID (Ivid) in a double tagged packet must have in order to match this classifier entry. The ntnL2MultiFieldClfrIvidMax value must be greater than or equal to the ntnL2MultiFieldClfrIvidMin value. Setting the ntnL2MultiFieldClfrIvidMin object to 1 and the ntnL2MultiFieldClfrIvidMax to 4094 indicates that VLAN data should not be considered during traffic classification. A non-default value for this attribute may only be specified if the ntnL2MultiFieldClfrVlanTag attribute has a value of 'doubleTagged(4)'. Version 2 attribute.")
ntnQosDsL2AccessElemUnknownUcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 39), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownUcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownUcastFrames.setDescription("If 'true(1)', frames containing an unknown unicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnQosDsL2AccessElemUnknownMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 40), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownMcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownMcastFrames.setDescription("If 'true(1)', frames containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnQosDsL2AccessElemKnownUcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 41), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownUcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownUcastFrames.setDescription("If 'true(1)', frames containing a known unicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnQosDsL2AccessElemKnownMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 42), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownMcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownMcastFrames.setDescription("If 'true(1)', frames containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnQosDsL2AccessElemBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 43), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBcastFrames.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBcastFrames.setDescription("If 'true(1)', frames containing a broadcast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 1/2 attribute.")
ntnQosDsL2AccessElemUnknownIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 44), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownIpMcast.setDescription("If 'true(1)', IP packets containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnQosDsL2AccessElemKnownIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 45), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownIpMcast.setDescription("If 'true(1)', IP packets containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnQosDsL2AccessElemNonIpPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 46), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemNonIpPkt.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemNonIpPkt.setDescription("If 'true(1)', non IP packets will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this packet type. Version 2 attribute.")
ntnQosDsL2AccessElemVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 47), VersionIndicator().clone('version1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVersion.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemVersion.setDescription('Version indicator for ntnQosDsL2AccessElemTable.')
ntnQosDsL2AccessElemUnknownNonIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 48), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownNonIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemUnknownNonIpMcast.setDescription("If 'true(1)', non-IP packets containing an unknown multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnQosDsL2AccessElemKnownNonIpMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 49), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownNonIpMcast.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemKnownNonIpMcast.setDescription("If 'true(1)', non-IP packets containing a known multicast destination address will match this classification entry. A value of 'false(2)' indicates that no classification is requested based on this address type. Version 2 attribute.")
ntnQosDsL2AccessElemMasterBlockMember = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 50), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemMasterBlockMember.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemMasterBlockMember.setDescription("If 'true(1)', attribute values in this DsL2Access element will take precedence over values in other entries when multiple elements are members of the same block and a single value must be chosen to represent all of the block members. For example, a metered policy with a block of filters requires a single in-profile-action be specified. This attribute is used to identify the master block member from the block member list from which the in-profile-action will be derived. A value of 'false(2)' indicates that, if this element is the member of a block, attribute values in this element will not explicitly take precedence over values in other block member elements. Multiple block members may have the value of this attribute set to 'true(1)'. If multiple block member masters are defined or if all block members have the value of this attribute set to 'false(2)', value precedence is determined using element evaluation precedence (i.e., the block member with the lowest evaluation precedence acts as the master when necessary). Version 1/2 attribute.")
ntnQosDsL2AccessElemMeterType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("simpleTokenBucket", 1), ("srTCMBlind", 2), ("srTCMAware", 3), ("trTCMBlind", 4), ("trTCMAware", 5))).clone('simpleTokenBucket')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemMeterType.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemMeterType.setDescription('The metering algorithm associated with the rate and burst parameters. Version 1/2 attribute.')
ntnQosDsL2AccessElemRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 52), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemRate.setDescription('The token-bucket rate, in kilobits per second (kbps). This attribute is used for: CIR for Simple Token Bucket CIR in RFC 2697 for srTCM CIR in RFC 2698 for trTCM CTR in RFC 2859 for TSWTCM AverageRate in RFC 3290. A rate value equal to 0 indicates that no metering is being requested. Version 1/2 attribute.')
ntnQosDsL2AccessElemBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 53), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemBurstSize.setDescription('The maximum number of bytes in a single transmission burst. This attribute is used for: Token bucket size for Simple Token Bucket CBS in RFC 2697 for srTCM CBS in RFC 2698 for trTCM Burst Size in RFC 3290. Version 1/2 attribute.')
ntnQosDsL2AccessElemOutActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionDrop.setDescription("This action attribute is used to specify whether a packet deemed out-of-profile should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped. Version 1/2 attribute.")
ntnQosDsL2AccessElemOutActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram that is deemed to be out-of-profile to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated. Version 1/2 attribute.')
ntnQosDsL2AccessElemOutActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9), ("deriveFromEgressDscp", 10), ("deriveFromIngressTosPrec", 11))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame that is deemed to be out-of-profile to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute. Specifying a value equal to 'deriveFromEgressDscp(10)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value specified for remarking in the ntnQosDsL2AccessElemOutActionRemarkDscp attribute will be used to determine the user priority. Specifying a value equal to 'deriveFromIngressTosPrec(11)' means that the value for this attribute will be assigned based on the value of the precedence bits in the IP Type-Of-Service (TOS) field, as defined in RFC 791. The eight precedence values, also referred to as Class Selector (CS) values, have a one-to-one correspondence with the eight 802.1p user priority values. Version 1/2 attribute.")
ntnQosDsL2AccessElemOutActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemOutActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'. Version 1/2 attribute.")
ntnQosDsL2AccessElemSecondaryRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 58), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSecondaryRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSecondaryRate.setDescription('The token-bucket rate, in kilobits per second (kbps). This attribute is used for: PIR in RFC 2698 for trTCM A rate value equal to 0 indicates that no secondary metering is being requested. Version 2 attribute.')
ntnQosDsL2AccessElemSecondaryBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 59), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSecondaryBurstSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemSecondaryBurstSize.setDescription('The maximum number of bytes in a single transmission burst. This attribute is used for: EBS in RFC 2697 for srTCM PBS in RFC 2698 for trTCM. Version 2 attribute.')
ntnQosDsL2AccessElemYelActionDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2))).clone('pass')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionDrop.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionDrop.setDescription("This action attribute is used to specify whether a packet deemed out-of-profile should dropped or switched (i.e., not dropped). The value 'drop(1)', when specified, will cause the packet being evaluated to be dropped. A value of 'pass(2)' indicates that this packet should not be dropped. Applies to yellow actions. Version 2 attribute.")
ntnQosDsL2AccessElemYelActionRemarkDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionRemarkDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionRemarkDscp.setDescription('This action component, when specified, will cause the value contained in the Differentiated Services (DS) field of an associated IP datagram that is deemed to be out-of-profile to be updated with the value of this object. A value of -1 indicates that the DSCP field should not be updated. Applies to yellow actions. Version 2 attribute.')
ntnQosDsL2AccessElemYelActionRemarkCos = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("ignore", 9), ("deriveFromEgressDscp", 10), ("deriveFromIngressTosPrec", 11))).clone('ignore')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionRemarkCos.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionRemarkCos.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame that is deemed to be out-of-profile to be updated based on the value of this object. Specifying a value equal to 'ignore(9)' means that no action will be taken related to this attribute. Specifying a value equal to 'deriveFromEgressDscp(10)' means that the value for this attribute will be assigned based on DSCP-to-user priority map information maintained in the system. The DSCP value specified for remarking in the ntnQosDsL2AccessElemYelActionRemarkDscp attribute will be used to determine the user priority. Specifying a value equal to 'deriveFromIngressTosPrec(11)' means that the value for this attribute will be assigned based on the value of the precedence bits in the IP Type-Of-Service (TOS) field, as defined in RFC 791. The eight precedence values, also referred to as Class Selector (CS) values, have a one-to-one correspondence with the eight 802.1p user priority values. Applies to yellow actions. Version 2 attribute.")
ntnQosDsL2AccessElemYelActionSetPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 11, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowDropPrec", 1), ("highDropPrec", 2))).clone('lowDropPrec')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionSetPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemYelActionSetPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for the drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, when congestion is encountered, packets with a 'highDropPrec(2)' will be dropped before packets with a 'lowDropPrec(1)'. Applies to yellow actions. Version 2 attribute.")
ntnQosFilterSetStatsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12), )
if mibBuilder.loadTexts: ntnQosFilterSetStatsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsTable.setDescription('This table contains counters for all the traffic passing through a processing element at the filter set/classifier level.')
ntnQosFilterSetStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsAccessAsgnId"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsPrecedence"), (0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsEvalOrder"))
if mibBuilder.loadTexts: ntnQosFilterSetStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsEntry.setDescription('An entry in the filter set statistics table describes a single set of traffic counters for a specific filter set/precedence/evaluation order combination.')
ntnQosFilterSetStatsAccessAsgnId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 1), IndexInteger())
if mibBuilder.loadTexts: ntnQosFilterSetStatsAccessAsgnId.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsAccessAsgnId.setDescription('An index component that identifies the Access Assignment element associated with this Filter Set Statistics entry. This attribute has the same value as the ntnQosAccessAsgnId attribute with which it is associated.')
ntnQosFilterSetStatsPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 2), IndexInteger())
if mibBuilder.loadTexts: ntnQosFilterSetStatsPrecedence.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsPrecedence.setDescription('An index component that identifies the precedence level associated with the filter set element for which statistics data is being returned.')
ntnQosFilterSetStatsEvalOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 3), IndexInteger())
if mibBuilder.loadTexts: ntnQosFilterSetStatsEvalOrder.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsEvalOrder.setDescription('An index component that identifies the evaluation order associated with the filter set element for which statistics data is being returned.')
ntnQosFilterSetStatsInProfileOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterSetStatsInProfileOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsInProfileOctets.setDescription('The number of octets considered to be in-profile that have been processed by the associated data path classifier.')
ntnQosFilterSetStatsInProfilePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterSetStatsInProfilePkts.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsInProfilePkts.setDescription('The number of packets considered to be in-profile that have been processed by the associated data path classifier.')
ntnQosFilterSetStatsOutOfProfileOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterSetStatsOutOfProfileOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsOutOfProfileOctets.setDescription('The number of octets considered to be out-of-profile that have been processed by the associated data path classifier.')
ntnQosFilterSetStatsOutOfProfilePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterSetStatsOutOfProfilePkts.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsOutOfProfilePkts.setDescription('The number of packets considered to be out-of-profile that have been processed by the associated data path classifier.')
ntnQosFilterSetStatsAccessElemId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosFilterSetStatsAccessElemId.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsAccessElemId.setDescription('Identifies the individual Access Element that is a component of the referenced filter set and to which the statistics data associated with this filter set/precedence/eval-order tuple applies.')
ntnQosFilterSetStatsStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosFilterSetStatsStorage.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
ntnQosFilterSetStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 12, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosFilterSetStatsStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
avFcoeRedirNextFree = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 13), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avFcoeRedirNextFree.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirNextFree.setDescription('This object contains an unused value for avFcoeRedirId, or a zero to indicate that none exist.')
avFcoeRedirTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14), )
if mibBuilder.loadTexts: avFcoeRedirTable.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirTable.setDescription('A table of FCoE streams that are being redirected through an external FCoE Network Controller (FNC).')
avFcoeRedirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirId"))
if mibBuilder.loadTexts: avFcoeRedirEntry.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirEntry.setDescription('An FCoE redirection entry contains the data necessary to redirect a specific FCoE stream through an external network controller.')
avFcoeRedirId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 1), IndexInteger())
if mibBuilder.loadTexts: avFcoeRedirId.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirId.setDescription('An index that enumerates the FCoE redirect entries. Managers can obtain new values for row creation in this table by reading avFcoeRedirNextFree.')
avFcoeRedirDstId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 2), FcId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirDstId.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirDstId.setDescription('This object specifies the Fibre Channel (FC) destination ID (D_ID) that should be used when performing stream identification.')
avFcoeRedirIngressInterfaceList = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 3), InterfaceList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirIngressInterfaceList.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirIngressInterfaceList.setDescription("This object identifies ingress interfaces, using an interface's ifIndex representation, to which the filter and action criteria specified in this entry should be applied.")
avFcoeRedirVlanIdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirVlanIdMin.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirVlanIdMin.setDescription('The minimum value that the VLAN ID (VID) in a tagged packet must have in order to match this entry. The avFcoeRedirVlanIdMin value must be less than or equal to the avFcoeRedirVlanIdMax value. Setting the avFcoeRedirVlanIdMin object to 1 and the avFcoeRedirVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic identification.')
avFcoeRedirVlanIdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(4094)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirVlanIdMax.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirVlanIdMax.setDescription('The maximum value that the VLAN ID (VID) in a tagged packet must have in order to match this entry. The avFcoeRedirVlanIdMax value must be greater than or equal to the avFcoeRedirVlanIdMin value. Setting the avFcoeRedirVlanIdMin object to 1 and the avFcoeRedirVlanIdMax to 4094 indicates that VLAN data should not be considered during traffic identification.')
avFcoeRedirUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("matchPriority0", 1), ("matchPriority1", 2), ("matchPriority2", 3), ("matchPriority3", 4), ("matchPriority4", 5), ("matchPriority5", 6), ("matchPriority6", 7), ("matchPriority7", 8), ("matchAllPriorities", 9))).clone('matchAllPriorities')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirUserPriority.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirUserPriority.setDescription("The 802.1p user priority value against which the value contained in the user priority field of a tagged 802.1 frame is compared. A test for equality is performed when determining if a match exists between the data in a data link layer frame and the value of this entry. A value of 'matchAllPriorities(9)' causes all user priority values to match this attribute. This essentially makes any comparisons with regard to user priority values unnecessary.")
avFcoeRedirEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(35078)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirEtherType.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirEtherType.setDescription("This object specifies the value that will be compared against the value contained in the EtherType field of an IEEE 802 frame. Example settings would include 'IP' (0x0800), 'FCoE' (0x8906) and 'FIP' (0x8914). Setting the avFcoeRedirEtherType object to 0xFFFF indicates that EtherType data should not be considered during traffic classification. Note the EtherType value of 0xFFFF is reserved by IANA.")
avFcoeRedirSrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 8), FcId().clone(hexValue="000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirSrcId.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirSrcId.setDescription("This object specifies the Fibre Channel (FC) source ID (D_ID) that should be used when performing stream identification. Setting this attribute to it's default value indicates that S_ID data should not be used for traffic identification.")
avFcoeRedirActionUpdateDstMac = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 9), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirActionUpdateDstMac.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirActionUpdateDstMac.setDescription('The 802 MAC address that will be used to update the destination MAC address in frames that are identified based on filter data specified in this entry.')
avFcoeRedirActionUpdateSrcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 10), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirActionUpdateSrcMac.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirActionUpdateSrcMac.setDescription('The 802 MAC address that will be used to update the source MAC address in frames that are identified based on filter data specified in this entry.')
avFcoeRedirActionEgressInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirActionEgressInterface.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirActionEgressInterface.setDescription('The interface through which frames identified based on filter data specified in this entry will egress the device. An egress interface or an egress trunk must be specified. A value of 0 indicates that an egress interface has not been specified.')
avFcoeRedirName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirName.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirName.setDescription('A label used to reference the FCoE redirect entry in a textual manner.')
avFcoeRedirStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 13), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirStorage.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. This object may not be modified if the associated status object is equal to 'active'.")
avFcoeRedirStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirStatus.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirStatus.setDescription('The status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value.')
avFcoeRedirProcessedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avFcoeRedirProcessedFrames.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirProcessedFrames.setDescription('Counts the frames that have matched the criteria specified in this entry.')
avFcoeRedirActionEgressTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 13, 14, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: avFcoeRedirActionEgressTrunkId.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirActionEgressTrunkId.setDescription('The trunk through which frames identified based on filter data specified in this entry will egress the device. An egress interface or an egress trunk must be specified. A value of 0 indicates that an egress trunk has not been specified.')
ntnQosDEITable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 14), )
if mibBuilder.loadTexts: ntnQosDEITable.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEITable.setDescription('Table to configure DEI support. DEI provides the user the option to set the packet color based on the CFI (used as DEI) bit in the packet 802.1Q tag. Also the user has the option to mark the packet color into the CFI bit in the 802.1Q tag.')
ntnQosDEIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 14, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EVOL-PIB", "ntnQosDEIInterfaceId"))
if mibBuilder.loadTexts: ntnQosDEIEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEIEntry.setDescription('An instance of the ntnQoSDEI class that identifies an interface options for DEI.')
ntnQosDEIInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 14, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosDEIInterfaceId.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEIInterfaceId.setDescription('An index that identifies the interface index associated with this table entry.')
ntnQosDEIIngressColorFromDEI = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 14, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosDEIIngressColorFromDEI.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEIIngressColorFromDEI.setDescription('This option allows the user to enable ingress coloring if the packets based on DEI in the 802.1Q packet tag.')
ntnQosDEIEgressMarkDEI = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 14, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosDEIEgressMarkDEI.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEIEgressMarkDEI.setDescription('This option allows the user to mark at egress the DEI bit in the 802.1Q tag if the packet is colored.')
ntnQosConfigResetToDefaults = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigResetToDefaults.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigResetToDefaults.setDescription("All installed QoS policy state information can be deleted and reset to the device's default state by setting the value of this object to 'true(1)'. The value 'false(2)' will always be returned when querying this object.")
ntnQosConfigTrackStatistics = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("individual", 2), ("aggregate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigTrackStatistics.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigTrackStatistics.setDescription("The value of this attribute determines if statistics tracking is enabled for system-level policies. System-level policies are created to enforce the default QoS processing rules associated with 'trusted' and 'untrusted' interface classes. This attribute is consulted during system policy creation. Setting this object to 'disabled(1)' causes statistics tracking to be disabled for the system-level policy being created. No statistics counter resources will be consumed. Setting this attribute to 'individual(2)' causes individual counters to be allocated for each classifier that comprises the system-level policy. A value of 'aggregate(3)' causes a single statistics counter to be allocated to track data associated with all of the classifiers that comprise the system policy. The value of this attribute is consulted when a policy is created or reinstalled. This allows the filter statistics tracking to be enabled only when deemed necessary.")
ntnQosConfigNVCommitDelay = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigNVCommitDelay.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigNVCommitDelay.setDescription('Specifies the maximum amount of time, in seconds, before non-volatile QoS configuration data will be written to non-volatile storage. Delaying NV access can be used to minimize file I/O aiding agent efficiency if a large amount of QoS data is being configured.')
ntnQosConfigDefaultQueueCfg = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("queueSetOne", 1), ("queueSetTwo", 2), ("queueSetThree", 3), ("queueSetFour", 4), ("queueSetFive", 5), ("queueSetSix", 6), ("queueSetSeven", 7), ("queueSetEight", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDefaultQueueCfg.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDefaultQueueCfg.setDescription('The value of this attribute determines the queue set that is associated with all egress interfaces by default. A queue set is characterized by the number of queues in the set, how the queues are serviced, the queue weights and the buffer resources that are associated with the inidividual queues. All queue sets are defined in the ntnQosIfQueueTable. The value of this attribute is consulted when the system is initialized. Changing the value of this attribute will therefore not take effect until after the system is restarted.')
ntnQosConfigDefaultBufferingCaps = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("minimumOverAllocation", 1), ("mediumOverAllocation", 2), ("maximumOverAllocation", 3), ("lossless", 4), ("losslessPfc", 5), ("spb-scaled", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDefaultBufferingCaps.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDefaultBufferingCaps.setDescription("The value of this attribute determines the method through which buffering resources are allocated to ports sharing a pool of buffers. The buffering resources associated with a series of ports are finite. This buffer pool may be statistically allocated to the individual ports sharing the pool or they may be allocated such that the traffic pattern dictates which ports temporarily consume the majority of the buffers. The value of this attribute determines the level of buffer sharing or over-allocation that can take place among ports sharing a buffer pool. Higher levels of over-allocation increase the likelyhood (under heavy load) of a relatively few number of ports consuming all the buffers in a pool, causing packets to be dropped on other ports due to buffer starvation. A value of 'minimumOverAllocation(1)' indicates that only a small amount of resource sharing is allowed. Greater resource sharing is allowed if the value of this attribute is 'mediumOverAllocation(2)' and the chance of over-allocation occurring is maximized by the specifying that 'maximumOverAllocation(3)' is desired. In lossless mode, the buffer allocation and thresholds are such that pause frames are generated to the endstations prior to frames being discarded due to lack of available buffers, allowing the end stattions to back off. This mode allows for lossless behavior at the expense of throughput. Lossless PFC mode operates in a similar fashion to lossless but provides the service on a per-priority (802.1p) basis. 'spb-scaled(6)' is a mode similar to 'mediumOverAllocation(2)', but optimized for scaled SPB setups. The value of this attribute is consulted when the system is initialized. Changing the value of this attribute will therefore not take effect until after the system is restarted.")
ntnQosConfigUBPSupportLevel = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ubpSupportDisabled", 1), ("ubpSupportHighSecurityLocalData", 2), ("ubpSupportLowSecurityLocalData", 3), ("ubpSupportEPMData", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigUBPSupportLevel.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigUBPSupportLevel.setDescription("Determines whether QoS Agent User Based Policy (UBP) support is enabled and, if so, what level of support is enabled. Setting the value of this attribute to 'ubpSupportDisabled(1)' will cause user information forwarded by other applications (e.g., EAP) to be ignored by the QoS Agent. A value of 'ubpSupportHighSecurityLocalData(2)' or 'ubpSupportLowSecurityLocalData(3)' will cause the internal QoS Agent database to be searched for user-specific classification data when user information is forwarded by other applications. When a high level of security is requested, user- specific classification data that is found must be successfully installed before a user is given access to the switch. A low level of security means that a user will be given access to the switch even if the resources to install user- specific classification data are not currently available. Lastly, a value of 'ubpSupportEPMData(4)' will cause notifications to be generated for Enterprise Policy Manager (EPM) consumption based on user information forwarded by other applications. Notifications will be generated for events of interest to EPM, such as user addition/deletion that is associated with User Based Policy (UBP) support. Notifications will not be generated otherwise. Note that the information that is necessary to construct and transmit a notification must also be configured for this value to be useful. Changing the value of this attribute will cause UBP data currently in-use to be lost.")
ntnQosConfigRoleAssocCompatLevel = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("roleAssocCompatLoose", 1), ("roleAssocCompatStrict", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigRoleAssocCompatLevel.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigRoleAssocCompatLevel.setDescription("Determines whether interface role associations are subject to loose or strict capabilities verification. Setting the value of this attribute to 'roleAssocCompatLoose(1)' means that interfaces with different capabilities may be associated with the same role. In this case, configuration issues may arise due to these differences. Setting the value to 'roleAssocCompatStrict(2)' means that only interfaces with compatible capabilities may be associated with the same role. This mode can be used to avoid configuration issues resulting from the interfaces assigned to a role not having the same underlying capabilities.")
ntnQosConfigDappEnable = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enableWithoutStatusTracking", 2), ("enableWithStatusTracking", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDappEnable.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDappEnable.setDescription("Dictates whether the DoS Attack Prevention Package (DAPP) is enabled on all applicable ports and, when enabled, if resources will be allocated to track and report on DoS attack detection. If the attribute value is 'disable(1)', DAPP support will be disabled. A value of 'enableWithoutStatusTracking(2)' will cause the DAPP support to be enabled on all ports that are DAPP-capable. No resources will be allocated to track the DoS attack detection status. No log messages and no SNMP Traps will be generated based on the DAPP support. A value of 'enableWithStatusTracking(3)' will cause resources to be verified and consumed prior to enabling DoS attack detection support on DAPP-capable ports. Support will not be enabled if adequate resources are not available. Assuming that resources are available, log messages and SNMP Traps will be generated on a per-unit basis when a DoS attack is identified by the detection logic.")
ntnQosConfigDappMinTcpHdrSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDappMinTcpHdrSize.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDappMinTcpHdrSize.setDescription('DAPP minimum TCP header length allowed. Used when performing TCP fragment validation. IPv4 TCP first fragment packets will be dropped if the TCP header (IP payload) is less than this value.')
ntnQosConfigDappIpv4IcmpMaxLength = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDappIpv4IcmpMaxLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDappIpv4IcmpMaxLength.setDescription('DAPP maximum IPv4 ICMP length. Used when performing ICMP validation. IPv4 ICMP packets will be dropped if the length (IP payload) exceeds this value.')
ntnQosConfigDappIpv6IcmpMaxLength = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDappIpv6IcmpMaxLength.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDappIpv6IcmpMaxLength.setDescription('DAPP maximum IPv6 ICMP length. Used when performing ICMP validation. IPv6 ICMP packets will be dropped if the length exceeds this value.')
ntnQosConfigNtApplicationMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enablePureMode", 2), ("enableMixedMode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigNtApplicationMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigNtApplicationMode.setDescription("Controls NT Application Mode processing. When enabled, identified NT application traffic will be given preferential treatment over non-NT application traffic. 'Mixed' mode processing will remove any special traffic markings at egress. 'Pure' mode processing will leave any special traffic markings intact at egress. Mode changes (updates to the value of this attribute) will take effect immediately.")
ntnQosConfigQosOperMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigQosOperMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigQosOperMode.setDescription('Controls overall QoS processing for the system. When enabled, all QoS functionality can be exercised by the user. When disabled, installed QoS components are temporarily removed (until the operational mode is re-enabled) and new requested QoS operations will be rejected. The QoS operational mode can not be disabled if QoS components are currently being used by non-QoS applications. If disabled, requests related to QoS components by non-QoS applications will be rejected. Note that re-enabling the QoS operational mode may result in errors if changes have been made affecting available resources while QoS was temporarily disabled. Mode changes (updates to the value of this attribute) will take effect immediately.')
ntnQosConfigTrustedProcessingMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("partialDscpMapping", 1), ("fullDscpMapping", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigTrustedProcessingMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigTrustedProcessingMode.setDescription("Controls filter usage related to Trusted interface class processing on platforms using filters to support treating traffic as trusted. A mode of 'partialDscpMapping(1)' causes filters to be installed that only support mapping of industry standard DSCP values. This is the default setting. A mode of 'fullDscpMapping(2)' causes filters to be installed mapping all possible DSCP values in support of Trusted interface class processing. A reset may be required for updates of this object to take effect.")
ntnQosConfigResetToPartialDefaults = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigResetToPartialDefaults.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigResetToPartialDefaults.setDescription("Most installed QoS policy state information can be deleted and reset to the device's default state by setting the value of this object to 'true(1)'. QoS data that requires a system reset to take effect (e.g., ntnQosConfigDefaultQueueCfg) is not reset to a default value using this object. The value 'false(2)' will always be returned when querying this object.")
ntnQosConfigClearStats = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 18), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigClearStats.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigClearStats.setDescription("All counters that are associated with QoS policies are reset to zero by setting the value of this object to 'true(1)'. The value 'false(2)' will always be returned when querying this object.")
ntnQosConfigFcoeRedirOperMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigFcoeRedirOperMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigFcoeRedirOperMode.setDescription('Controls the FCoE redirection service for the system. Enabling the service will initiate validation and possible reservation of the resources that are required for service activation. If resources are not available, the enable request will be rejected. Note that re-enabling the FCoE redirection service may result in errors if changes have been made affecting available resources while FCoE redirection was temporarily disabled. Mode changes (updates to the value of this attribute) will take effect immediately.')
ntnQosConfigFcoeControllerMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 20), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerMacAddr.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerMacAddr.setDescription('The 802 MAC address of the FCoE Network Controller (FNC) that is used in conjunction with the FCoE redirection service. Must be defined prior to enabling the FCoE redirection service. Changes made while the FCoE service is enabled will go into effect the next time the service is enabled.')
ntnQosConfigFcoeRedirAvail = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accessible", 1), ("notAccessible", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigFcoeRedirAvail.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigFcoeRedirAvail.setDescription("Controls access to the FCoE Redirect functionality. A value of 'accessible(1)' indicates that the FCoE support can be accessed by an external FCoE Network Controller (FNC). A value of 'notAccessible(2)' indicates that FCoE Redirect functionality can not be accessed by an FNC using SNMP.")
ntnQosConfigFcoeControllerIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 22), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerIfIndex.setDescription('The interface index of the FCoE Network Controller (FNC) that is used in conjunction with the FCoE redirection service. Must be defined prior to enabling the FCoE redirection service. Changes made while the FCoE service is enabled will go into effect the next time the service is enabled.')
ntnQosConfigFcoeControllerVlan = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 11, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerVlan.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigFcoeControllerVlan.setDescription('The VLAN associated with the FCoE Network Controller (FNC) that is used in conjunction with the FCoE redirection service. Must be defined prior to enabling the FCoE redirection service. Changes made while the FCoE service is enabled will go into effect the next time the service is enabled.')
ntnQosQuickPolicy = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15))
ntnQosQuickPolicyControl = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("create", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyControl.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyControl.setDescription('This object is used to create and delete quick policies. Setting the value to create(2) will create a quick policy based on the current values of the other object in the ntnQosQuickPolicy group. Setting the value to delete(3) will delete the quick policy identified by the current value of ntnQosQuickPolicyId. On retrieval, the value is always none(1).')
ntnQosQuickPolicyPortList = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyPortList.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyPortList.setDescription('This object indicates the list of ports to which the quick policy will be applied.')
ntnQosQuickPolicyAction = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forward", 1), ("pbits", 2), ("rate", 3), ("trtcm", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyAction.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyAction.setDescription('This object indicates the main action of the quick-policy.')
ntnQosQuickPolicyId = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 4), IndexInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyId.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyId.setDescription('This object indicates the ID of a policy to be deleted.')
ntnQosQuickPolicyPbitsValue = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyPbitsValue.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyPbitsValue.setDescription('The pbits value for creating a quick policy.')
ntnQosQuickPolicyRate = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 32000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyRate.setDescription('The rate value of the simple meter associated with a quick policy.')
ntnQosQuickPolicyTrTCMType = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("blind", 1), ("aware", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyTrTCMType.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyTrTCMType.setDescription('The type of a trtc quick policy. This object is ignored if the value of ntnQosQuickPolicyAction is not trtcm(4).')
ntnQosQuickPolicyCIRRate = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 32000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyCIRRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyCIRRate.setDescription('The CIR rate for creating a trtcm quick policy.')
ntnQosQuickPolicyPIRRate = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 32000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyPIRRate.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyPIRRate.setDescription('The PIR rate for creating a trtcm quick policy.')
ntnQosQuickPolicyTrackQiQType = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("qinq1", 1), ("qinq2", 2), ("ignore", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyTrackQiQType.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyTrackQiQType.setDescription('The QinQ type for a quick policy.')
ntnQosQuickPolicyDscp = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 11), Dscp()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyDscp.setDescription('The DSCP codepoint for a quick policy.')
ntnQosQuickPolicyPriority = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyPriority.setDescription('The priority value for a quick policy.')
ntnQosQuickPolicyVid = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 13), VlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyVid.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyVid.setDescription('The VLAN ID for a quick policy.')
ntnQosQuickPolicyTPID = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyTPID.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyTPID.setDescription('The TPID value for a quick policy.')
ntnQosQuickPolicyIVid = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 15), VlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyIVid.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyIVid.setDescription('The IVID value or a quick policy.')
ntnQosQuickPolicyITPID = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyITPID.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyITPID.setDescription('The ITPID value for a quick policy.')
ntnQosQuickPolicyIPriority = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyIPriority.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyIPriority.setDescription('The I-priority value for a quick policy.')
ntnQosQuickPolicyPrecedence = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyPrecedence.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyPrecedence.setDescription('The precedence value for a quick policy.')
ntnQosQuickPolicyTrackStatistics = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 15, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosQuickPolicyTrackStatistics.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyTrackStatistics.setDescription('Indicates whether statistics should be tracked for this quick policy.')
ntnQosFilterLimiting = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 16))
ntnQosFilterLimitingAdminEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 16, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosFilterLimitingAdminEnabled.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterLimitingAdminEnabled.setDescription('This object indicates whether QoS filter limiting is administratively enabled. Note that changes to this object are not applied to the operational state until the system is rebooted, so this value may differ from that of ntnQosFilterLimitingOperEnabled.')
ntnQosFilterLimitingOperEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 7, 1, 16, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosFilterLimitingOperEnabled.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterLimitingOperEnabled.setDescription('This object indicates whether QoS filter limiting is currently enabled. Note that this object will only change values (in response to changes to the value of ntnQosFilterLimitingOperEnabled) when the system is rebooted.')
ntnQosPolicyEvolLocalUbpSessionFailure = NotificationType((1, 3, 6, 1, 4, 1, 45, 4, 7, 3, 1)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigUBPSupportLevel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyIfIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyUserName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyUserGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyRoleCombination"))
if mibBuilder.loadTexts: ntnQosPolicyEvolLocalUbpSessionFailure.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyEvolLocalUbpSessionFailure.setDescription('Signifies that filter data associated with a user could not be installed in the context of local UBP support. The current UBP support level determines whether a User Policy element was created or not in this resource-exhaustion scenario.')
ntnQosPolicyEvolDosAttackDetected = NotificationType((1, 3, 6, 1, 4, 1, 45, 4, 7, 3, 2)).setObjects(("BN-IF-EXTENSIONS-MIB", "bnIfExtnSlot"), ("BN-IF-EXTENSIONS-MIB", "bnIfExtnPort"))
if mibBuilder.loadTexts: ntnQosPolicyEvolDosAttackDetected.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyEvolDosAttackDetected.setDescription('Indicates that the DAPP support has detected an attack on the device generating this trap. A notification is generated once for each unit that contains ports on which an attack has been detected. In addition to the required slot and port data, additional ports on the unit that has experienced a DAPP-detected DoS attack may also be included in the trap.')
avFcoeRedirEgressIssueDetected = NotificationType((1, 3, 6, 1, 4, 1, 45, 4, 7, 3, 3)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionEgressInterface"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionEgressTrunkId"))
if mibBuilder.loadTexts: avFcoeRedirEgressIssueDetected.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirEgressIssueDetected.setDescription('Indicates that an event that impacts egress data that is associated with one or more FCoE Redirect entries has been detected.')
ntnQosPolicyEvolPibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 1))
ntnQosPolicyEvolPibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2))
ntnQosPolicyEvolPibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 1, 2)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDeviceIdentGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAgentConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyEvolPibCompliance = ntnQosPolicyEvolPibCompliance.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyEvolPibCompliance.setDescription('Describes the requirements for conformance to the Nortel Networks QoS Policy Evolution PIB.')
ntnQosInterfaceTypeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 1)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeRoles"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeIfClass"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeCapabilities"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeStorageType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceTypeNextFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosInterfaceTypeGroup = ntnQosInterfaceTypeGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeGroup.setDescription('Objects from the ntnQosInterfaceTypeExtTable.')
ntnQosQsetPriAssignmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 2)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentQset"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentPri"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentQueue"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentStorageType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetPriAssignmentStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosQsetPriAssignmentGroup = ntnQosQsetPriAssignmentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetPriAssignmentGroup.setDescription('Objects from the ntnQosQsetPriAssignmentTable.')
ntnQosQsetDscpAssignmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 3)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentQset"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentQueue"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentStorageType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQsetDscpAssignmentStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosQsetDscpAssignmentGroup = ntnQosQsetDscpAssignmentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosQsetDscpAssignmentGroup.setDescription('Objects from the ntnQosQsetDscpAssignmentTable.')
ntnQosShapingParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 4)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsQueueSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsStorageType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosShapingParamsLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosShapingParamsGroup = ntnQosShapingParamsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosShapingParamsGroup.setDescription('Objects from the ntnQosShapingParamsTable.')
ntnDsMultiFieldClfrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 5)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrAddrType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrDstAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrDstPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrSrcAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrSrcPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrFlowId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrProtocol"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrDstL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrDstL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrSrcL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrSrcL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrIpFlags"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrTcpCtrlFlags"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnDsMultiFieldClfrIpv4Options"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnDsMultiFieldClfrGroup = ntnDsMultiFieldClfrGroup.setStatus('current')
if mibBuilder.loadTexts: ntnDsMultiFieldClfrGroup.setDescription('Objects supporting and from the ntnDsMultiFieldClfrTable.')
ntnL2MultiFieldClfrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 6)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrDstAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrDstAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrSrcAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrSrcAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrVlanIdMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrVlanIdMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrVlanTag"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrEtherType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrUserPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrPktType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrIvidMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrIvidMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrTPID"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrCFI"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrITPID"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrICFI"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnL2MultiFieldClfrIUserPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnL2MultiFieldClfrGroup = ntnL2MultiFieldClfrGroup.setStatus('current')
if mibBuilder.loadTexts: ntnL2MultiFieldClfrGroup.setDescription('Objects supporting and from the ntnL2MultiFieldClfrTable.')
ntnSystemClfrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 7)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrUnknownUcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrUnknownMcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrKnownUcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrKnownMcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrBcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrPatternPosition"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrPatternData"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrPatternFormat"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrUnknownIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrKnownIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrNonIpPkt"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrPatternIpVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrUnknownNonIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrKnownNonIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnSystemClfrPatternL2Format"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnSystemClfrGroup = ntnSystemClfrGroup.setStatus('current')
if mibBuilder.loadTexts: ntnSystemClfrGroup.setDescription('Objects supporting and from the ntnSystemClfrTable.')
ntnClfrComponentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 8)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentSpecific"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentSetId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrComponentSetNextFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnClfrComponentGroup = ntnClfrComponentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnClfrComponentGroup.setDescription('Objects supporting and from the ntnClfrComponentTable.')
ntnClfrBlockGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 9)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockNumber"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockClfrCompSetId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockMeter"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockAction"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockNumberNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnClfrBlockPrecedence"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnClfrBlockGroup = ntnClfrBlockGroup.setStatus('current')
if mibBuilder.loadTexts: ntnClfrBlockGroup.setDescription('Objects supporting and from the ntnClfrBlockTable.')
ntnQosMeterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 10)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterSucceedNext"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterFailNext"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterSpecific"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterOutOfProfileStats"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMeterVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosMeterGroup = ntnQosMeterGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosMeterGroup.setDescription('Objects supporting and from the ntnQosMeterTable.')
ntnQosTBParamGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 11)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamInterval"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosTBParamMinRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosTBParamGroup = ntnQosTBParamGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosTBParamGroup.setDescription('Objects supporting and from the ntnQosTBParamTable.')
ntnQosBaseActionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 12)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionUpdateDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionUpdateUserPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionSetDropPrecedence"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionCopyToCpu"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionMirrorFrame"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionExtension"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosBaseActionSessionId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosBaseActionGroup = ntnQosBaseActionGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosBaseActionGroup.setDescription('Objects supporting and from the ntnQosBaseActionTable.')
ntnQosIfcActionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 13)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionUpdateVlanId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionSetEgressMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionSetEgressUcastIfc"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionSetEgressNUcastIfc"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionExtension"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfcActionSessionId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfcActionGroup = ntnQosIfcActionGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfcActionGroup.setDescription('Objects supporting and from the ntnQosIfcActionTable.')
ntnQosPolicyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 14)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyClassifierType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyClassifierId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyInterfaceRoles"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecedence"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyMeter"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyAction"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyNonMatchAction"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyStats"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyStatsType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyInterfaceIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicySessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyMeteringMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyGroup = ntnQosPolicyGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyGroup.setDescription('Objects supporting and from the ntnQosPolicyTable.')
ntnQosCountActGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 15)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActOctets"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActPkts"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCountActSessionId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosCountActGroup = ntnQosCountActGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosCountActGroup.setDescription('Objects supporting and from the ntnCountActTable.')
ntnQosFilterStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 16)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsInProfileOctets"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsInProfilePkts"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsOutOfProfileOctets"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsOutOfProfilePkts"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterStatsStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosFilterStatsGroup = ntnQosFilterStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterStatsGroup.setDescription('Objects from the ntnQosFilterStatsTable.')
ntnQosPolicyDiagsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 17)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsMasksConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsFiltersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsMetersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsNonQosMasksConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsNonQosFiltersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsNonQosMetersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsCountersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsTotalMasksAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsTotalFiltersAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsTotalMetersAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDiagsTotalCountersAvail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyDiagsGroup = ntnQosPolicyDiagsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDiagsGroup.setDescription('Objects from the ntnQosPolicyDiagsTable.')
ntnQosIfAssignmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 18)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentRoleCombination"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentQueueSet"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAssignmentCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfAssignmentGroup = ntnQosIfAssignmentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAssignmentGroup.setDescription('Objects from the ntnQosIfAssignmentTable.')
ntnQosIfQueueGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 19)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueSetId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueDiscipline"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueDrainSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueAbsBandwidth"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueBandwidthAllocation"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueServiceOrder"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfQueueStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfQueueGroup = ntnQosIfQueueGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfQueueGroup.setDescription('Objects from the ntnQosIfQueueTable.')
ntnQosDscpToCosGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 20)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosDropPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDscpToCosNewDscp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosDscpToCosGroup = ntnQosDscpToCosGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosDscpToCosGroup.setDescription('Objects from the ntnQosDscpToCosTable.')
ntnQosCosToDscpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 21)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosToDscpStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosCosToDscpGroup = ntnQosCosToDscpGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosToDscpGroup.setDescription('Objects from the ntnQosCosToDscpTable.')
ntnQosPrcSupportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 22)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportSupportedPrc"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportSupportedAttrs"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportMaxPris"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPrcSupportCurrentPris"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPrcSupportGroup = ntnQosPrcSupportGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosPrcSupportGroup.setDescription('Objects from the ntnQosPrcSupportTable.')
ntnQosPolicyDeviceIdentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 23)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDeviceIdentDescr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyDeviceIdentMaxMsg"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyDeviceIdentGroup = ntnQosPolicyDeviceIdentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyDeviceIdentGroup.setDescription('Objects from the ntnQosPolicyDeviceIdentTable.')
ntnQosAgentConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 24)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigResetToDefaults"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigTrackStatistics"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigNVCommitDelay"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDefaultQueueCfg"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDefaultBufferingCaps"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigUBPSupportLevel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigRoleAssocCompatLevel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDappEnable"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDappMinTcpHdrSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDappIpv4IcmpMaxLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigDappIpv6IcmpMaxLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigNtApplicationMode"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigQosOperMode"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigTrustedProcessingMode"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigResetToPartialDefaults"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigClearStats"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigFcoeRedirOperMode"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigFcoeControllerMacAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigFcoeRedirAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigFcoeControllerIfIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosConfigFcoeControllerVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosAgentConfigGroup = ntnQosAgentConfigGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosAgentConfigGroup.setDescription('Objects used for QoS Policy Agent configuration.')
ntnQosInterfaceRoleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 25)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleRole"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleIfClass"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleCapabilities"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleStorageType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleStatsTrackingType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosInterfaceRoleNextFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosInterfaceRoleGroup = ntnQosInterfaceRoleGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceRoleGroup.setDescription('Objects from the ntnQosInterfaceRoleTable.')
ntnQosUserRoleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 26)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleRoleCombination"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleUserName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleUserGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleSessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleSessionStart"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleSessionGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserRoleStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosUserRoleGroup = ntnQosUserRoleGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserRoleGroup.setDescription('Objects from the ntnQosUserRoleTable.')
ntnQosIfShapingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 27)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfShapingSpecific"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfShapingLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfShapingStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfShapingStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfShapingGroup = ntnQosIfShapingGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfShapingGroup.setDescription('Objects from the ntnQosIfShapingTable.')
ntnQosDsAccessElemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 28)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemAddrType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemDstAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemDstPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemSrcAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemSrcPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemFlowId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemProtocol"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemDstL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemDstL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemSrcL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemSrcL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemBlock"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsAccessElemEvalPrec"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosDsAccessElemGroup = ntnQosDsAccessElemGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsAccessElemGroup.setDescription('Objects supporting and from the ntnQosDsAccessElemTable.')
ntnQosL2AccessElemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 29)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemDstAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemDstAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemSrcAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemSrcAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemVlanIdMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemVlanIdMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemVlanTag"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemEtherType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemUserPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemBlock"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosL2AccessElemEvalPrec"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosL2AccessElemGroup = ntnQosL2AccessElemGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosL2AccessElemGroup.setDescription('Objects supporting and from the ntnQosL2AccessElemTable.')
ntnQosAccessAsgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 30)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnAclType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnIfIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnOutActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnOutActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnOutActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnOutActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnStatsType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnNonMatchActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnMeterType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnSecondaryRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnSecondaryBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnYelActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnYelActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnYelActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnYelActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnSetPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosAccessAsgnMeteringMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosAccessAsgnGroup = ntnQosAccessAsgnGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosAccessAsgnGroup.setDescription('Objects supporting and from the ntnQosAccessAsgnTable.')
ntnQosIfAppsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 31)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsAppEnable"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsDefaultGateway"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsIfType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsDHCPServer"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosIfAppsStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfAppsGroup = ntnQosIfAppsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfAppsGroup.setDescription('Objects from the ntnQosIfAppsTable.')
ntnQosUserPolicyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 32)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyIfIndex"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyRoleCombination"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyUserName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyUserGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicySessionId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicySessionStart"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicySessionGroup"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicyStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicySrcMacAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosUserPolicySrcMacAddrMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosUserPolicyGroup = ntnQosUserPolicyGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosUserPolicyGroup.setDescription('Objects from the ntnQosUserPolicyTable.')
ntnQosDsL2AccessElemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 33)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemAddrType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstIpAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstIpPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcIpAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcIpPrefixLength"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemFlowId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemProtocol"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcL4PortMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcL4PortMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstMacAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemDstMacAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcMacAddr"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSrcMacAddrMask"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemVlanIdMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemVlanIdMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemVlanTag"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemEtherType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemUserPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemName"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemBlock"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemEvalPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemIpFlags"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemTcpCtrlFlags"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemIpv4Options"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemPktType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemIvidMin"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemIvidMax"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemUnknownUcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemUnknownMcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemKnownUcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemKnownMcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemBcastFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemUnknownIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemKnownIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemNonIpPkt"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemVersion"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemUnknownNonIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemKnownNonIpMcast"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemMasterBlockMember"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemMeterType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemOutActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemOutActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemOutActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemOutActionSetPrec"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSecondaryRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemSecondaryBurstSize"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemYelActionDrop"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemYelActionRemarkDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemYelActionRemarkCos"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDsL2AccessElemYelActionSetPrec"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosDsL2AccessElemGroup = ntnQosDsL2AccessElemGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosDsL2AccessElemGroup.setDescription('Objects supporting and from the ntnQosDsL2AccessElemTable.')
ntnQosCosShapingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 34)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingSpecific"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosCosShapingStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosCosShapingGroup = ntnQosCosShapingGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosCosShapingGroup.setDescription('Objects from the ntnQosCosShapingTable.')
ntnQosPolicyPrecResDiagsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 35)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsKeysConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsFiltersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsMetersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsNonQosKeysConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsNonQosFiltersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsNonQosMetersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsCountersConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsTotalKeysAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsTotalFiltersAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsTotalMetersAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsTotalCountersAvail"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsRangeChkElemsConsumed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsApplicationIdUsed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsApplicationNameUsed"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyPrecResDiagsRangeChkElemsAvail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyPrecResDiagsGroup = ntnQosPolicyPrecResDiagsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyPrecResDiagsGroup.setDescription('Objects from the ntnQosPolicyPrecResDiagsTable.')
ntnQosQueueShapingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 36)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingSpecific"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingLabel"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQueueShapingStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosQueueShapingGroup = ntnQosQueueShapingGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosQueueShapingGroup.setDescription('Objects from the ntnQosQueueShapingTable.')
ntnQosFilterSetStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 37)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsInProfileOctets"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsInProfilePkts"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsOutOfProfileOctets"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsOutOfProfilePkts"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsAccessElemId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterSetStatsStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosFilterSetStatsGroup = ntnQosFilterSetStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterSetStatsGroup.setDescription('Objects from the ntnQosFilterSetStatsTable.')
avFcoeRedirGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 38)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirNextFree"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirDstId"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirIngressInterfaceList"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirVlanIdMin"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirVlanIdMax"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirUserPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirEtherType"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirSrcId"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionUpdateDstMac"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionUpdateSrcMac"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionEgressInterface"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirName"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirStorage"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirStatus"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirProcessedFrames"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirActionEgressTrunkId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    avFcoeRedirGroup = avFcoeRedirGroup.setStatus('current')
if mibBuilder.loadTexts: avFcoeRedirGroup.setDescription('Objects from the avFcoeRedirTable.')
ntnQosQuickPolicyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 39)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyControl"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyPortList"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyAction"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyId"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyPbitsValue"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyTrTCMType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyCIRRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyPIRRate"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyTrackQiQType"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyDscp"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyVid"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyTPID"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyIVid"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyITPID"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyIPriority"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyPrecedence"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosQuickPolicyTrackStatistics"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosQuickPolicyGroup = ntnQosQuickPolicyGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosQuickPolicyGroup.setDescription('Objects from the ntnQosQuickPolicy support.')
ntnQosFilterLimitingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 40)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterLimitingAdminEnabled"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosFilterLimitingOperEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosFilterLimitingGroup = ntnQosFilterLimitingGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosFilterLimitingGroup.setDescription('Objects from the ntnQosFilterLimiting support.')
ntnQosDEIGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 41)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDEIIngressColorFromDEI"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosDEIEgressMarkDEI"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosDEIGroup = ntnQosDEIGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosDEIGroup.setDescription('Objects from the ntnQosDEI support.')
ntnQosMappingScalarsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 42)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMappingRestoreDefault"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMappingDscpToCosEnabled"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosMappingCosToDscpEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosMappingScalarsGroup = ntnQosMappingScalarsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosMappingScalarsGroup.setDescription('Objects from the ntnQosMapping support.')
ntnQosNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 45, 4, 7, 2, 2, 43)).setObjects(("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyEvolLocalUbpSessionFailure"), ("NTN-QOS-POLICY-EVOL-PIB", "ntnQosPolicyEvolDosAttackDetected"), ("NTN-QOS-POLICY-EVOL-PIB", "avFcoeRedirEgressIssueDetected"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosNotificationGroup = ntnQosNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosNotificationGroup.setDescription('QoS-related notifications.')
mibBuilder.exportSymbols("NTN-QOS-POLICY-EVOL-PIB", ntnQosShapingParamsId=ntnQosShapingParamsId, ntnQosPolicyDeviceIdentMaxMsg=ntnQosPolicyDeviceIdentMaxMsg, ntnQosInterfaceTypeEntry=ntnQosInterfaceTypeEntry, ntnQosFilterStatsTable=ntnQosFilterStatsTable, ntnQosIfcActionGroup=ntnQosIfcActionGroup, ntnQosPolicyInterfaceIndex=ntnQosPolicyInterfaceIndex, ntnQosConfigUBPSupportLevel=ntnQosConfigUBPSupportLevel, ntnQosDsAccessElemDstL4PortMin=ntnQosDsAccessElemDstL4PortMin, ntnQosTBParamTable=ntnQosTBParamTable, ntnQosUserPolicySessionGroup=ntnQosUserPolicySessionGroup, ntnQosQuickPolicyPbitsValue=ntnQosQuickPolicyPbitsValue, ntnSystemClfrKnownMcastFrames=ntnSystemClfrKnownMcastFrames, avFcoeRedirName=avFcoeRedirName, ntnQosAccessAsgnEntry=ntnQosAccessAsgnEntry, ntnQosDsAccessElemId=ntnQosDsAccessElemId, ntnQosPolicyDiagsMasksConsumed=ntnQosPolicyDiagsMasksConsumed, ntnQosConfigDappEnable=ntnQosConfigDappEnable, ntnQosFilterStatsInterfaceId=ntnQosFilterStatsInterfaceId, avFcoeRedirEgressIssueDetected=avFcoeRedirEgressIssueDetected, avFcoeRedirActionUpdateSrcMac=avFcoeRedirActionUpdateSrcMac, ntnQosDsAccessElemGroup=ntnQosDsAccessElemGroup, ntnQosTBParamEntry=ntnQosTBParamEntry, ntnQosConfigFcoeControllerVlan=ntnQosConfigFcoeControllerVlan, ntnQosTBParamSimpleTokenBucket=ntnQosTBParamSimpleTokenBucket, ntnQosUserRoleUserName=ntnQosUserRoleUserName, ntnQosShapingParamsBurstSize=ntnQosShapingParamsBurstSize, ntnQosDsL2AccessElemActionDrop=ntnQosDsL2AccessElemActionDrop, ntnQosDsAccessElemFlowId=ntnQosDsAccessElemFlowId, ntnQosL2AccessElemActionRemarkDscp=ntnQosL2AccessElemActionRemarkDscp, ntnQosDsL2AccessElemActionRemarkCos=ntnQosDsL2AccessElemActionRemarkCos, ntnQosDsL2AccessElemAddrType=ntnQosDsL2AccessElemAddrType, ntnQosIfAssignmentRoleCombination=ntnQosIfAssignmentRoleCombination, ntnQosIfAssignmentQueueSet=ntnQosIfAssignmentQueueSet, avFcoeRedirProcessedFrames=avFcoeRedirProcessedFrames, ntnQosIfQueueStorage=ntnQosIfQueueStorage, ntnQosL2AccessElemEtherType=ntnQosL2AccessElemEtherType, ntnQosIfcActionSessionId=ntnQosIfcActionSessionId, ntnQosQuickPolicyTrackQiQType=ntnQosQuickPolicyTrackQiQType, QosIeee802Cos=QosIeee802Cos, ntnQosPolicyPrecResDiagsGroup=ntnQosPolicyPrecResDiagsGroup, ntnQosMeterOutOfProfileStats=ntnQosMeterOutOfProfileStats, ntnSystemClfrGroup=ntnSystemClfrGroup, InterfaceList=InterfaceList, ntnQosAccessAsgnSecondaryBurstSize=ntnQosAccessAsgnSecondaryBurstSize, ntnQosCosToDscpGroup=ntnQosCosToDscpGroup, ntnQosQsetDscpAssignmentTable=ntnQosQsetDscpAssignmentTable, ntnQosL2AccessElemVlanIdMin=ntnQosL2AccessElemVlanIdMin, ntnQosQuickPolicyTrTCMType=ntnQosQuickPolicyTrTCMType, ntnQosIfShapingGroup=ntnQosIfShapingGroup, ntnSystemClfrTable=ntnSystemClfrTable, ntnQosPolicyMeteringMode=ntnQosPolicyMeteringMode, ntnL2MultiFieldClfrEtherType=ntnL2MultiFieldClfrEtherType, ntnQosPrcSupportEntry=ntnQosPrcSupportEntry, ntnQosInterfaceRoleId=ntnQosInterfaceRoleId, ntnL2MultiFieldClfrCFI=ntnL2MultiFieldClfrCFI, ntnQosAccessAsgnStatus=ntnQosAccessAsgnStatus, ntnDsMultiFieldClfrSrcL4PortMax=ntnDsMultiFieldClfrSrcL4PortMax, ntnQosDscpToCosEntry=ntnQosDscpToCosEntry, ntnQosDsAccessElemProtocol=ntnQosDsAccessElemProtocol, ntnQosConfigDappIpv6IcmpMaxLength=ntnQosConfigDappIpv6IcmpMaxLength, ntnQosPolicyDiagsTable=ntnQosPolicyDiagsTable, ntnQosUserPolicyUserGroup=ntnQosUserPolicyUserGroup, ntnQosQuickPolicyPriority=ntnQosQuickPolicyPriority, ntnQosDscpToCosLabel=ntnQosDscpToCosLabel, DscpUpdate=DscpUpdate, ntnDsMultiFieldClfrSrcAddr=ntnDsMultiFieldClfrSrcAddr, ntnDsMultiFieldClfrSrcPrefixLength=ntnDsMultiFieldClfrSrcPrefixLength, ntnQosFilterSetStatsPrecedence=ntnQosFilterSetStatsPrecedence, ntnDsMultiFieldClfrFlowId=ntnDsMultiFieldClfrFlowId, avFcoeRedirVlanIdMin=avFcoeRedirVlanIdMin, ntnQosDsAccessElemNextFree=ntnQosDsAccessElemNextFree, ntnL2MultiFieldClfrIUserPriority=ntnL2MultiFieldClfrIUserPriority, ntnQosUserRoleIfIndex=ntnQosUserRoleIfIndex, ntnQosPolicyDeviceIdentId=ntnQosPolicyDeviceIdentId, ntnQosDsL2AccessElemMasterBlockMember=ntnQosDsL2AccessElemMasterBlockMember, ntnQosAccessAsgnStorage=ntnQosAccessAsgnStorage, ntnL2MultiFieldClfrStorage=ntnL2MultiFieldClfrStorage, ntnQosDsL2AccessElemProtocol=ntnQosDsL2AccessElemProtocol, ntnQosDsL2AccessElemTcpCtrlFlags=ntnQosDsL2AccessElemTcpCtrlFlags, ntnClfrBlockVersion=ntnClfrBlockVersion, ntnClfrBlockLabel=ntnClfrBlockLabel, ntnQosBaseActionLabel=ntnQosBaseActionLabel, ntnQosShapingParamsStorageType=ntnQosShapingParamsStorageType, ntnQosDsL2AccessElemEvalPrec=ntnQosDsL2AccessElemEvalPrec, ntnQosIfAssignmentGroup=ntnQosIfAssignmentGroup, ntnQosAccessAsgnRate=ntnQosAccessAsgnRate, ntnDsMultiFieldClfrDscp=ntnDsMultiFieldClfrDscp, ntnQosShapingParamsLabel=ntnQosShapingParamsLabel, ntnQosQsetDscpAssignmentQset=ntnQosQsetDscpAssignmentQset, ntnSystemClfrUnknownNonIpMcast=ntnSystemClfrUnknownNonIpMcast, ntnQosInterfaceRoleEntry=ntnQosInterfaceRoleEntry, ntnQosUserPolicyNextFree=ntnQosUserPolicyNextFree, ntnQosMappingClassesScalars=ntnQosMappingClassesScalars, avFcoeRedirStorage=avFcoeRedirStorage, ntnQosDsL2AccessElemKnownUcastFrames=ntnQosDsL2AccessElemKnownUcastFrames, ntnQosConfigNVCommitDelay=ntnQosConfigNVCommitDelay, ntnQosL2AccessElemSrcAddr=ntnQosL2AccessElemSrcAddr, ntnL2MultiFieldClfrStatus=ntnL2MultiFieldClfrStatus, ntnQosPolicyClassifierType=ntnQosPolicyClassifierType, ntnQosDsL2AccessElemMeterType=ntnQosDsL2AccessElemMeterType, ntnQosL2AccessElemDstAddrMask=ntnQosL2AccessElemDstAddrMask, ntnQosDsL2AccessElemBcastFrames=ntnQosDsL2AccessElemBcastFrames, ntnQosDsL2AccessElemYelActionDrop=ntnQosDsL2AccessElemYelActionDrop, ntnClfrBlockEntry=ntnClfrBlockEntry, ntnQosPolicyPrecResDiagsPrec=ntnQosPolicyPrecResDiagsPrec, ntnClfrBlockGroup=ntnClfrBlockGroup, ntnL2MultiFieldClfrNextFree=ntnL2MultiFieldClfrNextFree, ntnQosPolicyEvolPibCompliances=ntnQosPolicyEvolPibCompliances, ntnQosPolicyStats=ntnQosPolicyStats, ntnQosTBParamTswTCM=ntnQosTBParamTswTCM, ntnQosDsL2AccessElemSrcL4PortMin=ntnQosDsL2AccessElemSrcL4PortMin, ntnQosFilterLimitingGroup=ntnQosFilterLimitingGroup, ntnQosPrcSupportSupportedPrc=ntnQosPrcSupportSupportedPrc, ntnQosPolicyPrecResDiagsRangeChkElemsAvail=ntnQosPolicyPrecResDiagsRangeChkElemsAvail, ntnQosIfQueueTable=ntnQosIfQueueTable, ntnQosIfAppsIfIndex=ntnQosIfAppsIfIndex, ntnQosAccessAsgnSetPriority=ntnQosAccessAsgnSetPriority, ntnQosQsetPriAssignmentStatus=ntnQosQsetPriAssignmentStatus, ntnL2MultiFieldClfrDstAddr=ntnL2MultiFieldClfrDstAddr, ntnQosDsL2AccessElemYelActionRemarkDscp=ntnQosDsL2AccessElemYelActionRemarkDscp, ntnDsMultiFieldClfrDstAddr=ntnDsMultiFieldClfrDstAddr, ntnQosUserRoleEntry=ntnQosUserRoleEntry, ntnQosDsAccessElemEntry=ntnQosDsAccessElemEntry, ntnQosQuickPolicyGroup=ntnQosQuickPolicyGroup, ntnQosQsetPriAssignmentGroup=ntnQosQsetPriAssignmentGroup, ntnQosDscpToCosCos=ntnQosDscpToCosCos, ntnL2MultiFieldClfrUserPriority=ntnL2MultiFieldClfrUserPriority, ntnQosDscpToCosGroup=ntnQosDscpToCosGroup, ntnQosCosShapingIfIndex=ntnQosCosShapingIfIndex, ntnQosConfigRoleAssocCompatLevel=ntnQosConfigRoleAssocCompatLevel, ntnQosAccessAsgnNonMatchActionDrop=ntnQosAccessAsgnNonMatchActionDrop, ntnSystemClfrUnknownIpMcast=ntnSystemClfrUnknownIpMcast, ntnClfrComponentStatus=ntnClfrComponentStatus, ntnQosMeterSpecific=ntnQosMeterSpecific, ntnL2MultiFieldClfrIvidMax=ntnL2MultiFieldClfrIvidMax, ntnQosCosToDscpTable=ntnQosCosToDscpTable, ntnQosPolicyClasses=ntnQosPolicyClasses, ntnQosPrcSupportCurrentPris=ntnQosPrcSupportCurrentPris, ntnQosDEIInterfaceId=ntnQosDEIInterfaceId, ntnQosPolicyDeviceIdentGroup=ntnQosPolicyDeviceIdentGroup, ntnQosBaseActionCopyToCpu=ntnQosBaseActionCopyToCpu, ntnQosCountActSessionId=ntnQosCountActSessionId, ntnClfrBlockSessionId=ntnClfrBlockSessionId, ntnQosDsL2AccessElemOutActionSetPrec=ntnQosDsL2AccessElemOutActionSetPrec, ntnQosPolicyPrecResDiagsTable=ntnQosPolicyPrecResDiagsTable, avFcoeRedirActionUpdateDstMac=avFcoeRedirActionUpdateDstMac, ntnQosQuickPolicyTPID=ntnQosQuickPolicyTPID, ntnQosIfAssignmentStatus=ntnQosIfAssignmentStatus, ntnQosQsetDscpAssignmentQueue=ntnQosQsetDscpAssignmentQueue, ntnSystemClfrPatternIpVersion=ntnSystemClfrPatternIpVersion, avFcoeRedirActionEgressTrunkId=avFcoeRedirActionEgressTrunkId, ntnSystemClfrUnknownUcastFrames=ntnSystemClfrUnknownUcastFrames, ntnQosFilterLimitingAdminEnabled=ntnQosFilterLimitingAdminEnabled, ntnQosCosShapingStatus=ntnQosCosShapingStatus, ntnQosIfAppsIfType=ntnQosIfAppsIfType, ntnQosPolicyEntry=ntnQosPolicyEntry, ntnQosConfigFcoeRedirOperMode=ntnQosConfigFcoeRedirOperMode, ntnQosIfShapingStorage=ntnQosIfShapingStorage, ntnSystemClfrKnownNonIpMcast=ntnSystemClfrKnownNonIpMcast, ntnQosIfAppsGroup=ntnQosIfAppsGroup, ntnQosPolicyEvolPibGroups=ntnQosPolicyEvolPibGroups, ntnQosCountActStorage=ntnQosCountActStorage, ntnDsMultiFieldClfrEntry=ntnDsMultiFieldClfrEntry, ntnQosPolicyDiagsEntry=ntnQosPolicyDiagsEntry, ntnQosBaseActionId=ntnQosBaseActionId, ntnQosConfigQosOperMode=ntnQosConfigQosOperMode, ntnSystemClfrLabel=ntnSystemClfrLabel, ntnQosPolicyEvolPibClasses=ntnQosPolicyEvolPibClasses, ntnQosMappingClasses=ntnQosMappingClasses, ntnQosDsL2AccessElemDstL4PortMax=ntnQosDsL2AccessElemDstL4PortMax, ntnQosDsL2AccessElemVlanTag=ntnQosDsL2AccessElemVlanTag, ntnQosQuickPolicyTrackStatistics=ntnQosQuickPolicyTrackStatistics, ntnQosShapingParamsTable=ntnQosShapingParamsTable, ntnQosMeterStatus=ntnQosMeterStatus, ntnQosAccessAsgnAclType=ntnQosAccessAsgnAclType, ntnQosDsAccessElemStorage=ntnQosDsAccessElemStorage, ntnQosQuickPolicyIVid=ntnQosQuickPolicyIVid, ntnQosIfcActionStorage=ntnQosIfcActionStorage, ntnL2MultiFieldClfrVlanIdMin=ntnL2MultiFieldClfrVlanIdMin, ntnSystemClfrPatternPosition=ntnSystemClfrPatternPosition, ntnClfrComponentStorage=ntnClfrComponentStorage, ntnQosDEITable=ntnQosDEITable, ntnQosDsAccessElemActionRemarkDscp=ntnQosDsAccessElemActionRemarkDscp, ntnQosPolicyDiagsFiltersConsumed=ntnQosPolicyDiagsFiltersConsumed, ntnQosAccessAsgnOutActionDrop=ntnQosAccessAsgnOutActionDrop, ntnQosQuickPolicyControl=ntnQosQuickPolicyControl, ntnQosQsetDscpAssignmentStorageType=ntnQosQsetDscpAssignmentStorageType, ntnQosAccessAsgnMeteringMode=ntnQosAccessAsgnMeteringMode, ntnQosDEIEntry=ntnQosDEIEntry, ntnQosPolicyDiagsNonQosMasksConsumed=ntnQosPolicyDiagsNonQosMasksConsumed, ntnQosInterfaceRoleStatus=ntnQosInterfaceRoleStatus, ntnClfrComponentTable=ntnClfrComponentTable, ntnClfrBlockAction=ntnClfrBlockAction, ntnQosPolicyAgtClasses=ntnQosPolicyAgtClasses, ntnQosUserPolicyId=ntnQosUserPolicyId, ntnQosConfigFcoeControllerMacAddr=ntnQosConfigFcoeControllerMacAddr, ntnL2MultiFieldClfrVersion=ntnL2MultiFieldClfrVersion, ntnQosPrcSupportSupportedAttrs=ntnQosPrcSupportSupportedAttrs, ntnQosIfQueueGroup=ntnQosIfQueueGroup, ntnQosQueueShapingStorage=ntnQosQueueShapingStorage, ntnQosUserPolicySessionStart=ntnQosUserPolicySessionStart, ntnQosConfigResetToPartialDefaults=ntnQosConfigResetToPartialDefaults, ntnQosPolicyPrecResDiagsTotalMetersAvail=ntnQosPolicyPrecResDiagsTotalMetersAvail, ntnSystemClfrSessionId=ntnSystemClfrSessionId, avFcoeRedirNextFree=avFcoeRedirNextFree, ntnQosFilterStatsGroup=ntnQosFilterStatsGroup, ntnQosAccessAsgnYelActionRemarkDscp=ntnQosAccessAsgnYelActionRemarkDscp, ntnQosDsL2AccessElemVlanIdMax=ntnQosDsL2AccessElemVlanIdMax, ntnQosShapingParamsRate=ntnQosShapingParamsRate, ntnQosQsetPriAssignmentQueue=ntnQosQsetPriAssignmentQueue, ntnQosBaseActionUpdateUserPriority=ntnQosBaseActionUpdateUserPriority, ntnQosCosToDscpDscp=ntnQosCosToDscpDscp, ntnQosDEIEgressMarkDEI=ntnQosDEIEgressMarkDEI, ntnClfrBlockId=ntnClfrBlockId, ntnQosFilterSetStatsTable=ntnQosFilterSetStatsTable, ntnQosL2AccessElemActionRemarkCos=ntnQosL2AccessElemActionRemarkCos, avFcoeRedirTable=avFcoeRedirTable, ntnQosShapingParamsGroup=ntnQosShapingParamsGroup, ntnQosPolicyPrecResDiagsApplicationNameUsed=ntnQosPolicyPrecResDiagsApplicationNameUsed, ntnDsMultiFieldClfrTcpCtrlFlags=ntnDsMultiFieldClfrTcpCtrlFlags, ntnQosInterfaceRoleStorageType=ntnQosInterfaceRoleStorageType, ntnQosDsAccessElemActionRemarkCos=ntnQosDsAccessElemActionRemarkCos, ntnQosDsL2AccessElemVersion=ntnQosDsL2AccessElemVersion, ntnSystemClfrPatternL2Format=ntnSystemClfrPatternL2Format, ntnQosQsetDscpAssignmentId=ntnQosQsetDscpAssignmentId, ntnQosL2AccessElemActionDrop=ntnQosL2AccessElemActionDrop, ntnSystemClfrNonIpPkt=ntnSystemClfrNonIpPkt, ntnQosDsL2AccessElemDstMacAddrMask=ntnQosDsL2AccessElemDstMacAddrMask, ntnQosQueueShapingSpecific=ntnQosQueueShapingSpecific, ntnQosUserPolicySessionId=ntnQosUserPolicySessionId, ntnQosAccessAsgnOutActionRemarkDscp=ntnQosAccessAsgnOutActionRemarkDscp, ntnClfrComponentSessionId=ntnClfrComponentSessionId, ntnQosIfAppsEntry=ntnQosIfAppsEntry, ntnQosPolicyPrecResDiagsMetersConsumed=ntnQosPolicyPrecResDiagsMetersConsumed, ntnQosInterfaceRoleTable=ntnQosInterfaceRoleTable, ntnQosDsL2AccessElemYelActionRemarkCos=ntnQosDsL2AccessElemYelActionRemarkCos, ntnQosInterfaceTypeStatus=ntnQosInterfaceTypeStatus, ntnClfrBlockPrecedence=ntnClfrBlockPrecedence, ntnQosBaseActionTable=ntnQosBaseActionTable, ntnQosIfShapingStatus=ntnQosIfShapingStatus, ntnQosUserPolicyStatus=ntnQosUserPolicyStatus, ntnQosL2AccessElemNextFree=ntnQosL2AccessElemNextFree, ntnQosCountActEntry=ntnQosCountActEntry, ntnQosTBParamBurstSize=ntnQosTBParamBurstSize, ntnQosDscpToCosStorage=ntnQosDscpToCosStorage, ntnQosL2AccessElemGroup=ntnQosL2AccessElemGroup, ntnQosIfQueueDrainSize=ntnQosIfQueueDrainSize, ntnQosFilterStatsStorage=ntnQosFilterStatsStorage, ntnQosFilterStatsStatus=ntnQosFilterStatsStatus, ntnQosPolicyDiagsTotalMetersAvail=ntnQosPolicyDiagsTotalMetersAvail, ntnQosDsL2AccessElemBurstSize=ntnQosDsL2AccessElemBurstSize, ntnQosL2AccessElemId=ntnQosL2AccessElemId, ntnQosInterfaceTypeNextFree=ntnQosInterfaceTypeNextFree, ntnQosConfigDefaultBufferingCaps=ntnQosConfigDefaultBufferingCaps)
mibBuilder.exportSymbols("NTN-QOS-POLICY-EVOL-PIB", ntnDsMultiFieldClfrIpFlags=ntnDsMultiFieldClfrIpFlags, ntnQosInterfaceTypeCapabilities=ntnQosInterfaceTypeCapabilities, ntnQosInterfaceTypeIfClass=ntnQosInterfaceTypeIfClass, ntnDsMultiFieldClfrIpv4Options=ntnDsMultiFieldClfrIpv4Options, ntnQosQsetDscpAssignmentStatus=ntnQosQsetDscpAssignmentStatus, ntnQosQuickPolicyPIRRate=ntnQosQuickPolicyPIRRate, ntnQosFilterStatsFilterId=ntnQosFilterStatsFilterId, ntnQosCosToDscpStatus=ntnQosCosToDscpStatus, ntnQosIfcActionExtension=ntnQosIfcActionExtension, ntnSystemClfrNextFree=ntnSystemClfrNextFree, ntnQosCountActGroup=ntnQosCountActGroup, ntnQosDscpToCosStatus=ntnQosDscpToCosStatus, ntnQosConfigFcoeRedirAvail=ntnQosConfigFcoeRedirAvail, ntnQosUserRoleStatus=ntnQosUserRoleStatus, ntnQosMeterGroup=ntnQosMeterGroup, ntnQosCosToDscpStorage=ntnQosCosToDscpStorage, PYSNMP_MODULE_ID=ntnQosPolicyEvolPib, ntnQosQueueShapingEntry=ntnQosQueueShapingEntry, ntnQosDsL2AccessElemPktType=ntnQosDsL2AccessElemPktType, ntnQosConfigDefaultQueueCfg=ntnQosConfigDefaultQueueCfg, ntnQosL2AccessElemActionSetPrec=ntnQosL2AccessElemActionSetPrec, ntnQosCountActStatus=ntnQosCountActStatus, ntnQosL2AccessElemType=ntnQosL2AccessElemType, ntnQosPolicyEvolPib=ntnQosPolicyEvolPib, ntnL2MultiFieldClfrLabel=ntnL2MultiFieldClfrLabel, ntnQosUserRoleSessionId=ntnQosUserRoleSessionId, ntnQosIfQueueServiceOrder=ntnQosIfQueueServiceOrder, ntnQosIfShapingEntry=ntnQosIfShapingEntry, ntnClfrBlockStatus=ntnClfrBlockStatus, ntnSystemClfrBcastFrames=ntnSystemClfrBcastFrames, ntnQosUserRoleSessionGroup=ntnQosUserRoleSessionGroup, ntnQosIfShapingIfIndex=ntnQosIfShapingIfIndex, FcId=FcId, ntnQosBaseActionEntry=ntnQosBaseActionEntry, ntnQosQsetPriAssignmentEntry=ntnQosQsetPriAssignmentEntry, ntnSystemClfrStorage=ntnSystemClfrStorage, ntnQosUserPolicyEntry=ntnQosUserPolicyEntry, ntnQosPolicyDiagsCountersConsumed=ntnQosPolicyDiagsCountersConsumed, ntnQosDsAccessElemType=ntnQosDsAccessElemType, ntnQosL2AccessElemVlanTag=ntnQosL2AccessElemVlanTag, ntnQosQsetPriAssignmentQset=ntnQosQsetPriAssignmentQset, ntnQosFilterStatsInProfilePkts=ntnQosFilterStatsInProfilePkts, ntnQosPolicyStatsType=ntnQosPolicyStatsType, ntnQosCosShapingTable=ntnQosCosShapingTable, ntnQosQsetDscpAssignmentEntry=ntnQosQsetDscpAssignmentEntry, ntnQosQueueShapingGroup=ntnQosQueueShapingGroup, ntnQosCosShapingStorage=ntnQosCosShapingStorage, ntnQosCountActId=ntnQosCountActId, ntnQosTBParamSrTCMAware=ntnQosTBParamSrTCMAware, avFcoeRedirId=avFcoeRedirId, ntnQosCosShapingCos=ntnQosCosShapingCos, ntnQosConfigClearStats=ntnQosConfigClearStats, ntnQosCosToDscpLabel=ntnQosCosToDscpLabel, ntnQosTBParamStatus=ntnQosTBParamStatus, ntnQosPolicyEvolPibNotifications=ntnQosPolicyEvolPibNotifications, ntnQosIfQueueId=ntnQosIfQueueId, ntnDsMultiFieldClfrDstL4PortMax=ntnDsMultiFieldClfrDstL4PortMax, ntnQosPolicyPrecResDiagsTotalFiltersAvail=ntnQosPolicyPrecResDiagsTotalFiltersAvail, ntnQosQuickPolicyId=ntnQosQuickPolicyId, ntnQosDEIGroup=ntnQosDEIGroup, ntnQosDsL2AccessElemGroup=ntnQosDsL2AccessElemGroup, ntnDsMultiFieldClfrStatus=ntnDsMultiFieldClfrStatus, ntnQosIfAppsStorage=ntnQosIfAppsStorage, ntnSystemClfrKnownIpMcast=ntnSystemClfrKnownIpMcast, ntnQosFilterSetStatsStatus=ntnQosFilterSetStatsStatus, ntnQosPolicyEvolLocalUbpSessionFailure=ntnQosPolicyEvolLocalUbpSessionFailure, ntnQosL2AccessElemName=ntnQosL2AccessElemName, ntnQosL2AccessElemBlock=ntnQosL2AccessElemBlock, ntnQosDsL2AccessElemNonIpPkt=ntnQosDsL2AccessElemNonIpPkt, ntnQosIfShapingLabel=ntnQosIfShapingLabel, ntnQosDsL2AccessElemId=ntnQosDsL2AccessElemId, ntnQosQuickPolicyAction=ntnQosQuickPolicyAction, avFcoeRedirStatus=avFcoeRedirStatus, ntnQosDsL2AccessElemIpv4Options=ntnQosDsL2AccessElemIpv4Options, ntnQosPolicySessionId=ntnQosPolicySessionId, ntnDsMultiFieldClfrStorage=ntnDsMultiFieldClfrStorage, ntnQosIfcActionLabel=ntnQosIfcActionLabel, ntnQosPolicyDiagsGroup=ntnQosPolicyDiagsGroup, ntnQosPolicyLabel=ntnQosPolicyLabel, ntnQosL2AccessElemStorage=ntnQosL2AccessElemStorage, ntnL2MultiFieldClfrGroup=ntnL2MultiFieldClfrGroup, ntnSystemClfrKnownUcastFrames=ntnSystemClfrKnownUcastFrames, ntnSystemClfrId=ntnSystemClfrId, ntnQosBaseActionSetDropPrecedence=ntnQosBaseActionSetDropPrecedence, ntnQosPolicyPrecedence=ntnQosPolicyPrecedence, ntnClfrComponentVersion=ntnClfrComponentVersion, ntnL2MultiFieldClfrSrcAddrMask=ntnL2MultiFieldClfrSrcAddrMask, ntnQosIfcActionTable=ntnQosIfcActionTable, ntnQosPrcSupportGroup=ntnQosPrcSupportGroup, ntnQosDsAccessElemTable=ntnQosDsAccessElemTable, ntnQosIfAppsStatus=ntnQosIfAppsStatus, ntnQosTBParamAvgRate=ntnQosTBParamAvgRate, ntnQosQueueShapingStatus=ntnQosQueueShapingStatus, ntnClfrComponentSetId=ntnClfrComponentSetId, ntnQosFilterSetStatsEntry=ntnQosFilterSetStatsEntry, ntnClassifierClasses=ntnClassifierClasses, ntnQosIfcActionNextFree=ntnQosIfcActionNextFree, FlowIdOrAny=FlowIdOrAny, ntnQosAccessAsgnId=ntnQosAccessAsgnId, ntnQosCountActTable=ntnQosCountActTable, ntnL2MultiFieldClfrVlanIdMax=ntnL2MultiFieldClfrVlanIdMax, ntnQosDsAccessElemSrcPrefixLength=ntnQosDsAccessElemSrcPrefixLength, ntnQosPolicyClassifierId=ntnQosPolicyClassifierId, ntnQosIfQueueIndex=ntnQosIfQueueIndex, ntnQosUserPolicySrcMacAddrMask=ntnQosUserPolicySrcMacAddrMask, ntnQosTBParamLabel=ntnQosTBParamLabel, ntnQosTBParamId=ntnQosTBParamId, ntnQosTBParamRate=ntnQosTBParamRate, ntnQosTBMeters=ntnQosTBMeters, ntnDsMultiFieldClfrSessionId=ntnDsMultiFieldClfrSessionId, ntnQosDsL2AccessElemSrcIpAddr=ntnQosDsL2AccessElemSrcIpAddr, ntnQosConfigNtApplicationMode=ntnQosConfigNtApplicationMode, ntnQosIfAssignmentTable=ntnQosIfAssignmentTable, ntnQosPolicyInterfaceRoles=ntnQosPolicyInterfaceRoles, ntnQosShapingParamsQueueSize=ntnQosShapingParamsQueueSize, ntnQosFilterStatsInProfileOctets=ntnQosFilterStatsInProfileOctets, ntnQosQueueShapingLabel=ntnQosQueueShapingLabel, ntnQosTBParamInterval=ntnQosTBParamInterval, ntnQosAccessAsgnOutActionRemarkCos=ntnQosAccessAsgnOutActionRemarkCos, ntnQosPolicyPrecResDiagsFiltersConsumed=ntnQosPolicyPrecResDiagsFiltersConsumed, ntnQosPolicyPrecResDiagsKeysConsumed=ntnQosPolicyPrecResDiagsKeysConsumed, ntnQosUserPolicyGroup=ntnQosUserPolicyGroup, ntnQosDsL2AccessElemIpFlags=ntnQosDsL2AccessElemIpFlags, ntnQosMappingRestoreDefault=ntnQosMappingRestoreDefault, ntnQosPolicyAction=ntnQosPolicyAction, ntnQosPolicyDeviceIdentEntry=ntnQosPolicyDeviceIdentEntry, ntnQosDsAccessElemDscp=ntnQosDsAccessElemDscp, ntnClfrBlockNumberNextFree=ntnClfrBlockNumberNextFree, ntnQosUserRoleUserGroup=ntnQosUserRoleUserGroup, ntnQosPrcSupportMaxPris=ntnQosPrcSupportMaxPris, ntnQosIfAssignmentStorage=ntnQosIfAssignmentStorage, ntnQosPrcSupportId=ntnQosPrcSupportId, ntnQosUserPolicyIfIndex=ntnQosUserPolicyIfIndex, ntnQosAccessAsgnIfIndex=ntnQosAccessAsgnIfIndex, ntnQosTBParamVersion=ntnQosTBParamVersion, ntnQosInterfaceTypeTable=ntnQosInterfaceTypeTable, ntnQosDsAccessElemActionSetPrec=ntnQosDsAccessElemActionSetPrec, ntnQosTBParamType=ntnQosTBParamType, ntnQosAccessAsgnGroup=ntnQosAccessAsgnGroup, ntnClfrBlockNextFree=ntnClfrBlockNextFree, ntnQosDsL2AccessElemIvidMax=ntnQosDsL2AccessElemIvidMax, ntnQosMeterFailNext=ntnQosMeterFailNext, ntnQosFilterSetStatsAccessElemId=ntnQosFilterSetStatsAccessElemId, ntnQosIfcActionUpdateVlanId=ntnQosIfcActionUpdateVlanId, ntnQosIfShapingTable=ntnQosIfShapingTable, ntnL2MultiFieldClfrITPID=ntnL2MultiFieldClfrITPID, ntnQosMappingDscpToCosEnabled=ntnQosMappingDscpToCosEnabled, avFcoeRedirSrcId=avFcoeRedirSrcId, ntnQosFilterSetStatsEvalOrder=ntnQosFilterSetStatsEvalOrder, ntnQosInterfaceTypeId=ntnQosInterfaceTypeId, ntnQosAccessAsgnYelActionRemarkCos=ntnQosAccessAsgnYelActionRemarkCos, ntnQosCosToDscpCos=ntnQosCosToDscpCos, ntnDsMultiFieldClfrDstPrefixLength=ntnDsMultiFieldClfrDstPrefixLength, ntnQosPolicyTable=ntnQosPolicyTable, ntnQosNotificationGroup=ntnQosNotificationGroup, ntnQosFilterStatsOutOfProfilePkts=ntnQosFilterStatsOutOfProfilePkts, ntnQosDsL2AccessElemOutActionDrop=ntnQosDsL2AccessElemOutActionDrop, ntnQosMeterSessionId=ntnQosMeterSessionId, ntnQosQsetPriAssignmentPri=ntnQosQsetPriAssignmentPri, ntnDsMultiFieldClfrTable=ntnDsMultiFieldClfrTable, ntnSystemClfrStatus=ntnSystemClfrStatus, ntnQosCosShapingGroup=ntnQosCosShapingGroup, ntnQosShapingParamsEntry=ntnQosShapingParamsEntry, ntnQosDsAccessElemSrcL4PortMin=ntnQosDsAccessElemSrcL4PortMin, ntnL2MultiFieldClfrId=ntnL2MultiFieldClfrId, ntnQosFilterLimiting=ntnQosFilterLimiting, ntnQosDsL2AccessElemKnownNonIpMcast=ntnQosDsL2AccessElemKnownNonIpMcast, ntnQosCosShapingSpecific=ntnQosCosShapingSpecific, ntnQosInterfaceRoleStatsTrackingType=ntnQosInterfaceRoleStatsTrackingType, ntnQosDsL2AccessElemName=ntnQosDsL2AccessElemName, ntnClfrComponentLabel=ntnClfrComponentLabel, ntnQosDsL2AccessElemVlanIdMin=ntnQosDsL2AccessElemVlanIdMin, ntnQosConfigDappMinTcpHdrSize=ntnQosConfigDappMinTcpHdrSize, ntnQosL2AccessElemEvalPrec=ntnQosL2AccessElemEvalPrec, ntnQosBaseActionSessionId=ntnQosBaseActionSessionId, avFcoeRedirUserPriority=avFcoeRedirUserPriority, ntnL2MultiFieldClfrTable=ntnL2MultiFieldClfrTable, ntnQosDsAccessElemEvalPrec=ntnQosDsAccessElemEvalPrec, ntnQosPolicyPrecResDiagsNonQosFiltersConsumed=ntnQosPolicyPrecResDiagsNonQosFiltersConsumed, ntnQosQuickPolicyIPriority=ntnQosQuickPolicyIPriority, ntnQosMeterStorage=ntnQosMeterStorage, ntnClfrComponentSetNextFree=ntnClfrComponentSetNextFree, ntnQosBaseActionStorage=ntnQosBaseActionStorage, ntnQosUserPolicyTable=ntnQosUserPolicyTable, ntnQosShapingParamsStatus=ntnQosShapingParamsStatus, ntnQosDscpToCosDropPrec=ntnQosDscpToCosDropPrec, ntnQosUserRoleSessionStart=ntnQosUserRoleSessionStart, avFcoeRedirVlanIdMax=avFcoeRedirVlanIdMax, ntnQosPolicyPrecResDiagsInterface=ntnQosPolicyPrecResDiagsInterface, ntnDsMultiFieldClfrDstL4PortMin=ntnDsMultiFieldClfrDstL4PortMin, ntnQosDsL2AccessElemKnownIpMcast=ntnQosDsL2AccessElemKnownIpMcast, ntnQosAccessAsgnNextFree=ntnQosAccessAsgnNextFree, ntnQosQsetDscpAssignmentGroup=ntnQosQsetDscpAssignmentGroup, ntnL2MultiFieldClfrICFI=ntnL2MultiFieldClfrICFI, ntnQosMeterId=ntnQosMeterId, ntnQosPolicyDiagsTotalMasksAvail=ntnQosPolicyDiagsTotalMasksAvail, ntnQosUserRoleGroup=ntnQosUserRoleGroup, avFcoeRedirActionEgressInterface=avFcoeRedirActionEgressInterface, ntnQosPolicyPrecResDiagsRangeChkElemsConsumed=ntnQosPolicyPrecResDiagsRangeChkElemsConsumed, ntnQosDsAccessElemDstAddr=ntnQosDsAccessElemDstAddr, ntnQosDscpToCosNewDscp=ntnQosDscpToCosNewDscp, ntnQosIfQueueBandwidthAllocation=ntnQosIfQueueBandwidthAllocation, avFcoeRedirDstId=avFcoeRedirDstId, ntnQosIfcActionSetEgressUcastIfc=ntnQosIfcActionSetEgressUcastIfc, ntnQosCosShapingLabel=ntnQosCosShapingLabel, ntnQosIfAppsAppEnable=ntnQosIfAppsAppEnable, ntnQosQuickPolicyPortList=ntnQosQuickPolicyPortList, ntnDsMultiFieldClfrAddrType=ntnDsMultiFieldClfrAddrType, ntnL2MultiFieldClfrPktType=ntnL2MultiFieldClfrPktType, ntnQosPolicyStorage=ntnQosPolicyStorage, ntnDsMultiFieldClfrVersion=ntnDsMultiFieldClfrVersion, ntnQosMeterNextFree=ntnQosMeterNextFree, ntnQosActionClasses=ntnQosActionClasses, ntnQosIfQueueAbsBandwidth=ntnQosIfQueueAbsBandwidth, ntnQosAccessAsgnTable=ntnQosAccessAsgnTable, ntnClfrComponentId=ntnClfrComponentId, ntnQosQuickPolicy=ntnQosQuickPolicy, ntnQosPolicyEvolDosAttackDetected=ntnQosPolicyEvolDosAttackDetected, ntnQosIfAssignmentEntry=ntnQosIfAssignmentEntry, ntnQosPolicyNonMatchAction=ntnQosPolicyNonMatchAction, ntnQosDsL2AccessElemUnknownNonIpMcast=ntnQosDsL2AccessElemUnknownNonIpMcast, ntnQosUserPolicyStorage=ntnQosUserPolicyStorage, ntnQosTBParamNextFree=ntnQosTBParamNextFree, ntnQosIfcActionSetEgressNUcastIfc=ntnQosIfcActionSetEgressNUcastIfc, ntnQosIfcActionEntry=ntnQosIfcActionEntry, ntnQosAccessAsgnOutActionSetPrec=ntnQosAccessAsgnOutActionSetPrec, ntnQosPolicyEvolPibConformance=ntnQosPolicyEvolPibConformance, ntnQosBaseActionGroup=ntnQosBaseActionGroup, ntnQosPolicyId=ntnQosPolicyId, ntnQosPolicyPrecResDiagsNonQosMetersConsumed=ntnQosPolicyPrecResDiagsNonQosMetersConsumed, ntnQosIfAppsDefaultGateway=ntnQosIfAppsDefaultGateway, ntnQosConfigDappIpv4IcmpMaxLength=ntnQosConfigDappIpv4IcmpMaxLength, ntnQosFilterSetStatsOutOfProfilePkts=ntnQosFilterSetStatsOutOfProfilePkts, ntnQosAccessAsgnName=ntnQosAccessAsgnName, ntnQosBaseActionDrop=ntnQosBaseActionDrop, ntnQosCountActNextFree=ntnQosCountActNextFree, ntnClfrComponentEntry=ntnClfrComponentEntry, ntnQosMeterSucceedNext=ntnQosMeterSucceedNext, ntnQosDsL2AccessElemEntry=ntnQosDsL2AccessElemEntry, ntnQosPolicyDiagsNonQosFiltersConsumed=ntnQosPolicyDiagsNonQosFiltersConsumed, ntnQosL2AccessElemStatus=ntnQosL2AccessElemStatus, ntnQosTBParamStorage=ntnQosTBParamStorage, ntnQosMeterClasses=ntnQosMeterClasses, ntnQosDsL2AccessElemOutActionRemarkDscp=ntnQosDsL2AccessElemOutActionRemarkDscp, ntnQosL2AccessElemDstAddr=ntnQosL2AccessElemDstAddr, ntnQosBaseActionMirrorFrame=ntnQosBaseActionMirrorFrame, ntnQosAccessAsgnBurstSize=ntnQosAccessAsgnBurstSize, ntnQosConfigTrustedProcessingMode=ntnQosConfigTrustedProcessingMode, avFcoeRedirEtherType=avFcoeRedirEtherType, ntnQosQuickPolicyITPID=ntnQosQuickPolicyITPID, ntnQosBaseActionStatus=ntnQosBaseActionStatus, ntnQosAccessAsgnMeterType=ntnQosAccessAsgnMeterType, ntnQosUserRoleRoleCombination=ntnQosUserRoleRoleCombination, ntnQosDsL2AccessElemDscp=ntnQosDsL2AccessElemDscp)
mibBuilder.exportSymbols("NTN-QOS-POLICY-EVOL-PIB", ntnQosIfShapingSpecific=ntnQosIfShapingSpecific, ntnQosPolicyPrecResDiagsCountersConsumed=ntnQosPolicyPrecResDiagsCountersConsumed, ntnQosTBParamTrTCMAware=ntnQosTBParamTrTCMAware, ntnQosDsL2AccessElemDstIpPrefixLength=ntnQosDsL2AccessElemDstIpPrefixLength, ntnQosQuickPolicyRate=ntnQosQuickPolicyRate, ntnDsMultiFieldClfrNextFree=ntnDsMultiFieldClfrNextFree, avFcoeRedirIngressInterfaceList=avFcoeRedirIngressInterfaceList, ntnQosL2AccessElemTable=ntnQosL2AccessElemTable, ntnQosAccessAsgnYelActionDrop=ntnQosAccessAsgnYelActionDrop, ntnQosDsL2AccessElemRate=ntnQosDsL2AccessElemRate, ntnQosDsL2AccessElemOutActionRemarkCos=ntnQosDsL2AccessElemOutActionRemarkCos, ntnQosDsL2AccessElemSrcMacAddrMask=ntnQosDsL2AccessElemSrcMacAddrMask, ntnQosPolicyPrecResDiagsNonQosKeysConsumed=ntnQosPolicyPrecResDiagsNonQosKeysConsumed, ntnQosTBParamTrTCMBlind=ntnQosTBParamTrTCMBlind, ntnQosDsL2AccessElemActionSetPrec=ntnQosDsL2AccessElemActionSetPrec, avFcoeRedirEntry=avFcoeRedirEntry, ntnQosInterfaceTypeRoles=ntnQosInterfaceTypeRoles, ntnQosDsL2AccessElemSrcMacAddr=ntnQosDsL2AccessElemSrcMacAddr, ntnQosConfigFcoeControllerIfIndex=ntnQosConfigFcoeControllerIfIndex, ntnQosDsL2AccessElemUnknownUcastFrames=ntnQosDsL2AccessElemUnknownUcastFrames, ntnL2MultiFieldClfrEntry=ntnL2MultiFieldClfrEntry, ntnQosDsAccessElemAddrType=ntnQosDsAccessElemAddrType, ntnQosQsetPriAssignmentStorageType=ntnQosQsetPriAssignmentStorageType, ntnQosCosShapingEntry=ntnQosCosShapingEntry, ntnQosInterfaceRoleRole=ntnQosInterfaceRoleRole, ntnSystemClfrPatternData=ntnSystemClfrPatternData, ntnQosL2AccessElemSrcAddrMask=ntnQosL2AccessElemSrcAddrMask, ntnQosDsL2AccessElemTable=ntnQosDsL2AccessElemTable, ntnQosFilterSetStatsOutOfProfileOctets=ntnQosFilterSetStatsOutOfProfileOctets, ntnQosQuickPolicyDscp=ntnQosQuickPolicyDscp, ntnQosQuickPolicyCIRRate=ntnQosQuickPolicyCIRRate, ntnQosTBParamMinRate=ntnQosTBParamMinRate, ntnQosFilterStatsOutOfProfileOctets=ntnQosFilterStatsOutOfProfileOctets, ntnQosCosToDscpId=ntnQosCosToDscpId, ntnQosDEIIngressColorFromDEI=ntnQosDEIIngressColorFromDEI, ntnQosDsL2AccessElemBlock=ntnQosDsL2AccessElemBlock, ntnQosUserPolicyUserName=ntnQosUserPolicyUserName, ntnQosIfcActionStatus=ntnQosIfcActionStatus, ntnQosPolicyVersion=ntnQosPolicyVersion, ntnDsMultiFieldClfrGroup=ntnDsMultiFieldClfrGroup, ntnQosQueueShapingTable=ntnQosQueueShapingTable, ntnQosFilterStatsPolicyId=ntnQosFilterStatsPolicyId, VersionIndicator=VersionIndicator, ntnQosQsetDscpAssignmentDscp=ntnQosQsetDscpAssignmentDscp, ntnQosAccessAsgnYelActionSetPrec=ntnQosAccessAsgnYelActionSetPrec, ntnQosDsL2AccessElemKnownMcastFrames=ntnQosDsL2AccessElemKnownMcastFrames, ntnQosUserPolicyRoleCombination=ntnQosUserPolicyRoleCombination, ntnL2MultiFieldClfrSessionId=ntnL2MultiFieldClfrSessionId, ntnQosDsAccessElemDstL4PortMax=ntnQosDsAccessElemDstL4PortMax, ntnQosDsAccessElemBlock=ntnQosDsAccessElemBlock, ntnClfrComponentSpecific=ntnClfrComponentSpecific, ntnQosIfQueueSetId=ntnQosIfQueueSetId, ntnQosL2AccessElemEntry=ntnQosL2AccessElemEntry, ntnClfrBlockStorage=ntnClfrBlockStorage, ntnDsMultiFieldClfrLabel=ntnDsMultiFieldClfrLabel, ntnQosAccessAsgnStatsType=ntnQosAccessAsgnStatsType, ntnQosFilterSetStatsInProfileOctets=ntnQosFilterSetStatsInProfileOctets, ntnQosDsAccessElemName=ntnQosDsAccessElemName, ntnQosInterfaceRoleGroup=ntnQosInterfaceRoleGroup, ntnQosDsL2AccessElemStorage=ntnQosDsL2AccessElemStorage, ntnQosDsL2AccessElemSecondaryBurstSize=ntnQosDsL2AccessElemSecondaryBurstSize, ntnQosQsetPriAssignmentId=ntnQosQsetPriAssignmentId, ntnQosPolicyDiagsTotalFiltersAvail=ntnQosPolicyDiagsTotalFiltersAvail, ntnQosIfQueueStatus=ntnQosIfQueueStatus, ntnQosTBParamSrTCMBlind=ntnQosTBParamSrTCMBlind, ntnQosDsAccessElemStatus=ntnQosDsAccessElemStatus, ntnQosPolicyPrecResDiagsEntry=ntnQosPolicyPrecResDiagsEntry, ntnQosQueueShapingIfIndex=ntnQosQueueShapingIfIndex, ntnQosDsL2AccessElemYelActionSetPrec=ntnQosDsL2AccessElemYelActionSetPrec, ntnQosCountActOctets=ntnQosCountActOctets, ntnQosDsL2AccessElemSrcL4PortMax=ntnQosDsL2AccessElemSrcL4PortMax, ntnQosPolicyDiagsMetersConsumed=ntnQosPolicyDiagsMetersConsumed, ntnQosDsL2AccessElemSecondaryRate=ntnQosDsL2AccessElemSecondaryRate, ntnQosUserRoleTable=ntnQosUserRoleTable, ntnQosPolicyStatus=ntnQosPolicyStatus, ntnQosFilterSetStatsAccessAsgnId=ntnQosFilterSetStatsAccessAsgnId, ntnQosBaseActionExtension=ntnQosBaseActionExtension, ntnClfrBlockNumber=ntnClfrBlockNumber, ntnQosPolicyNextFree=ntnQosPolicyNextFree, ntnQosInterfaceTypeGroup=ntnQosInterfaceTypeGroup, ntnQosPrcSupportTable=ntnQosPrcSupportTable, ntnSystemClfrPatternFormat=ntnSystemClfrPatternFormat, ntnL2MultiFieldClfrIvidMin=ntnL2MultiFieldClfrIvidMin, ntnQosMeterTable=ntnQosMeterTable, ntnQosInterfaceTypeStorageType=ntnQosInterfaceTypeStorageType, ntnQosDsL2AccessElemUnknownMcastFrames=ntnQosDsL2AccessElemUnknownMcastFrames, ntnQosFilterSetStatsInProfilePkts=ntnQosFilterSetStatsInProfilePkts, ntnQosPolicyDiagsNonQosMetersConsumed=ntnQosPolicyDiagsNonQosMetersConsumed, ntnClfrBlockClfrCompSetId=ntnClfrBlockClfrCompSetId, ntnQosDsL2AccessElemSrcIpPrefixLength=ntnQosDsL2AccessElemSrcIpPrefixLength, avFcoeRedirGroup=avFcoeRedirGroup, ntnSystemClfrVersion=ntnSystemClfrVersion, ntnQosDsAccessElemSrcL4PortMax=ntnQosDsAccessElemSrcL4PortMax, ntnQosBaseActionUpdateDscp=ntnQosBaseActionUpdateDscp, ntnQosIfQueueSize=ntnQosIfQueueSize, ntnQosConfigResetToDefaults=ntnQosConfigResetToDefaults, ntnQosPolicyPrecResDiagsApplicationIdUsed=ntnQosPolicyPrecResDiagsApplicationIdUsed, ntnL2MultiFieldClfrSrcAddr=ntnL2MultiFieldClfrSrcAddr, ntnQosBaseActionNextFree=ntnQosBaseActionNextFree, ntnClfrBlockMeter=ntnClfrBlockMeter, ntnDsMultiFieldClfrProtocol=ntnDsMultiFieldClfrProtocol, ntnQosDsL2AccessElemUserPriority=ntnQosDsL2AccessElemUserPriority, ntnQosUserRoleStorage=ntnQosUserRoleStorage, ntnQosMappingCosToDscpEnabled=ntnQosMappingCosToDscpEnabled, ntnQosDsL2AccessElemDstMacAddr=ntnQosDsL2AccessElemDstMacAddr, ntnQosTBParamGroup=ntnQosTBParamGroup, ntnQosDsL2AccessElemDstL4PortMin=ntnQosDsL2AccessElemDstL4PortMin, ntnQosPolicyPrecResDiagsTotalCountersAvail=ntnQosPolicyPrecResDiagsTotalCountersAvail, ntnQosMeterLabel=ntnQosMeterLabel, ntnQosTBParamSessionId=ntnQosTBParamSessionId, ntnQosFilterStatsEntry=ntnQosFilterStatsEntry, ntnQosDscpToCosTable=ntnQosDscpToCosTable, ntnQosMeterEntry=ntnQosMeterEntry, ntnQosIfQueueDiscipline=ntnQosIfQueueDiscipline, ntnQosConfigTrackStatistics=ntnQosConfigTrackStatistics, ntnQosMappingScalarsGroup=ntnQosMappingScalarsGroup, ntnQosIfQueueEntry=ntnQosIfQueueEntry, ntnQosInterfaceRoleIfClass=ntnQosInterfaceRoleIfClass, ntnQosIfAppsTable=ntnQosIfAppsTable, ntnQosAccessAsgnSecondaryRate=ntnQosAccessAsgnSecondaryRate, ntnQosUserPolicySrcMacAddr=ntnQosUserPolicySrcMacAddr, ntnQosCountActPkts=ntnQosCountActPkts, ntnQosDscpToCosId=ntnQosDscpToCosId, ntnQosAgentConfigGroup=ntnQosAgentConfigGroup, ntnL2MultiFieldClfrTPID=ntnL2MultiFieldClfrTPID, ntnQosInterfaceClasses=ntnQosInterfaceClasses, ntnDsMultiFieldClfrId=ntnDsMultiFieldClfrId, ntnL2MultiFieldClfrDstAddrMask=ntnL2MultiFieldClfrDstAddrMask, ntnClfrComponentGroup=ntnClfrComponentGroup, ntnQosDsAccessElemSrcAddr=ntnQosDsAccessElemSrcAddr, ntnQosPolicyDiagsTotalCountersAvail=ntnQosPolicyDiagsTotalCountersAvail, ntnQosDsL2AccessElemNextFree=ntnQosDsL2AccessElemNextFree, ntnQosDsAccessElemActionDrop=ntnQosDsAccessElemActionDrop, ntnQosDsL2AccessElemIvidMin=ntnQosDsL2AccessElemIvidMin, ntnSystemClfrEntry=ntnSystemClfrEntry, ntnQosDsL2AccessElemUnknownIpMcast=ntnQosDsL2AccessElemUnknownIpMcast, ntnQosPolicyEvolPibCompliance=ntnQosPolicyEvolPibCompliance, ntnQosIfAssignmentIfIndex=ntnQosIfAssignmentIfIndex, ntnQosCosToDscpEntry=ntnQosCosToDscpEntry, ntnQosPolicyDeviceIdentDescr=ntnQosPolicyDeviceIdentDescr, ntnL2MultiFieldClfrVlanTag=ntnL2MultiFieldClfrVlanTag, ntnClfrComponentNextFree=ntnClfrComponentNextFree, ntnQosDsL2AccessElemDstIpAddr=ntnQosDsL2AccessElemDstIpAddr, ntnDsMultiFieldClfrSrcL4PortMin=ntnDsMultiFieldClfrSrcL4PortMin, ntnQosPolicyMeter=ntnQosPolicyMeter, ntnQosIfAppsDHCPServer=ntnQosIfAppsDHCPServer, ntnQosDscpToCosDscp=ntnQosDscpToCosDscp, ntnQosDsL2AccessElemFlowId=ntnQosDsL2AccessElemFlowId, ntnQosL2AccessElemVlanIdMax=ntnQosL2AccessElemVlanIdMax, ntnQosFilterLimitingOperEnabled=ntnQosFilterLimitingOperEnabled, ntnQosQsetPriAssignmentTable=ntnQosQsetPriAssignmentTable, ntnQosIfAssignmentCapabilities=ntnQosIfAssignmentCapabilities, ntnQosPolicyGroup=ntnQosPolicyGroup, ntnQosInterfaceRoleCapabilities=ntnQosInterfaceRoleCapabilities, ntnQosDsL2AccessElemStatus=ntnQosDsL2AccessElemStatus, ntnClfrBlockTable=ntnClfrBlockTable, ntnQosQuickPolicyPrecedence=ntnQosQuickPolicyPrecedence, ntnQosDsAccessElemDstPrefixLength=ntnQosDsAccessElemDstPrefixLength, IndexIntegerOrZero=IndexIntegerOrZero, ntnQosIfcActionId=ntnQosIfcActionId, ntnQosDsL2AccessElemType=ntnQosDsL2AccessElemType, ntnQosFilterSetStatsGroup=ntnQosFilterSetStatsGroup, ntnQosDsL2AccessElemEtherType=ntnQosDsL2AccessElemEtherType, ntnQosMeterVersion=ntnQosMeterVersion, ntnQosApplicationClasses=ntnQosApplicationClasses, ntnQosL2AccessElemUserPriority=ntnQosL2AccessElemUserPriority, ntnSystemClfrUnknownMcastFrames=ntnSystemClfrUnknownMcastFrames, ntnQosInterfaceRoleNextFree=ntnQosInterfaceRoleNextFree, ntnQosPolicyPrecResDiagsTotalKeysAvail=ntnQosPolicyPrecResDiagsTotalKeysAvail, ntnQosQueueShapingQueue=ntnQosQueueShapingQueue, ntnQosQuickPolicyVid=ntnQosQuickPolicyVid, ntnQosPolicyDeviceIdentTable=ntnQosPolicyDeviceIdentTable, ntnQosFilterSetStatsStorage=ntnQosFilterSetStatsStorage, ntnQosIfcActionSetEgressMask=ntnQosIfcActionSetEgressMask, ntnQosDsL2AccessElemActionRemarkDscp=ntnQosDsL2AccessElemActionRemarkDscp)

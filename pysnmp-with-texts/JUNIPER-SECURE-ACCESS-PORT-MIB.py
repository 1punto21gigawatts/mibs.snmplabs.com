#
# PySNMP MIB module JUNIPER-SECURE-ACCESS-PORT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-SECURE-ACCESS-PORT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:01:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
jnxExSecureAccessPort, = mibBuilder.importSymbols("JUNIPER-EX-SMI", "jnxExSecureAccessPort")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, ObjectIdentity, iso, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Unsigned32, Counter32, Bits, NotificationType, TimeTicks, Gauge32, MibIdentifier, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ObjectIdentity", "iso", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Unsigned32", "Counter32", "Bits", "NotificationType", "TimeTicks", "Gauge32", "MibIdentifier", "Counter64")
TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention")
jnxExSecureAccessPortMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1))
if mibBuilder.loadTexts: jnxExSecureAccessPortMIB.setLastUpdated('200705151000Z')
if mibBuilder.loadTexts: jnxExSecureAccessPortMIB.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxExSecureAccessPortMIB.setContactInfo(' Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxExSecureAccessPortMIB.setDescription("This is Juniper Networks' implementation of enterprise specific MIB for configuration of Secure Access Port feature. DHCP Snooping and Dynamic ARP Inspection are mechanisms to provide per interface security capabilities. This MIB Module is also used to control some layer 2 functions like MAC limiting. It also supports IP Source Guard, Mac Source Guard and Storm Control features.")
jnxSecAccessPortMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 0))
jnxSecAccessPortMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1))
class JnxMacLimitExceededAction(TextualConvention, Integer32):
    description = 'One of the following action will be taken by the system on an interface, when the system detects the current learned number of MAC addresses in the forwarding table has exceeded the limit number of MAC address. none : No action will be taken. It means Mac limit is not enabled in the specified interface. drop : The notification will be generated when MAC limit is exceeded and also the MAC limit is enforced for the interface. The new address will not be learned in the entity and also the traffic with new address will not be flooded in the entity. The learning will be re-enabled in the interface if the number of MAC addresses falls below the limit. alarm : A notification will be generated if the Mac Limit is exceeded. shutdown : The notification will be generated as the Mac Limit is exceeded. The interface will be moved to blocked state, no traffic will be allowed in the entity. The traffic will be re-enabled in the interface if the number of MAC addresses falls below the limit.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("drop", 2), ("alarm", 3), ("shutdown", 4))

jnxSecAccessPortVlanTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 1), )
if mibBuilder.loadTexts: jnxSecAccessPortVlanTable.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessPortVlanTable.setDescription('A table provides the mechanism to control DHCP Snooping and Dynamic ARP Inspection per VLAN. When a VLAN is created in a device supporting this table, a corresponding entry will be added to this table.')
jnxSecAccessPortVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 1, 1), ).setIndexNames((0, "JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxSecAccessVlanName"))
if mibBuilder.loadTexts: jnxSecAccessPortVlanEntry.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessPortVlanEntry.setDescription('A row instance contains whether DHCP Snooping and Dynamic ARP Inspection at each existing VLAN is enabled or disabled.')
jnxSecAccessVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: jnxSecAccessVlanName.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessVlanName.setDescription('This object indicates the VLAN name on which Dhcp Snooping feature and Dynamic ARP Inspection is enabled.')
jnxSecAccessVlanDhcpSnoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessVlanDhcpSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessVlanDhcpSnoopStatus.setDescription("This object indicates whether Dhcp Snooping is enabled in this VLAN. If this object is 'true', Dhcp Snooping is enabled in the specified VLAN. If this object is 'false', Dhcp Snooping is disabled in the specified VLAN.")
jnxSecAccessVlanDAIStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessVlanDAIStatus.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessVlanDAIStatus.setDescription("This object indicates whether Dynamic ARP Inspection is enabled in this VLAN. If this object is 'true', Dynamic ARP Inspection is enabled. If this object is 'false', Dynamic ARP Inspection is disabled.")
jnxSecAccessPortIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2), )
if mibBuilder.loadTexts: jnxSecAccessPortIfTable.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessPortIfTable.setDescription('The table contains the trust state and rate limit of each interface for DHCP Snooping purpose. The table also contains information on MAC address limit feature for each interface capable of this feature. This table also specifies whether IP source guard and MAC source guard are enabled on each interface.')
jnxSecAccessPortIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxSecAccessPortIfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessPortIfEntry.setDescription('A table entry contains the trust state and rate limit of an interface, MAC address limit for that Interface. It also contains the action to be undertaken if MAC address limit is exceeded. A table entry specifies whether IP source guard and MAC source guard are enabled on the specified interface.')
jnxSecAccessdsIfTrustState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessdsIfTrustState.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessdsIfTrustState.setDescription("This object indicates whether the interface is trusted for DHCP Snooping purpose. If this object is 'true', the interface is trusted. DHCP packets coming to this interface will be forwarded without checking. If this object is 'false', the interface is not trusted. DHCP packets coming to this interface will be subjected to DHCP checks.")
jnxSecAccessdsIfRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 2), Unsigned32()).setUnits('packets per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessdsIfRateLimit.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessdsIfRateLimit.setDescription('This object indicates rate limit value for DHCP Snooping purpose. If the value of this object is 0, no rate limit is applied for DHCP traffic at this interface.')
jnxSecAccessIfMacLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 3), Unsigned32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessIfMacLimit.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessIfMacLimit.setDescription('This object specifies the threshold limit for the number of MAC address entries on this interface. When the instance value of this object is set to 0, no threshold limit will be applied for this interfacew and the corresponding instance value of jnxIfMacLimitExceedAction of the same row has no effect.')
jnxSecAccessIfMacLimitExceed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 4), JnxMacLimitExceededAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessIfMacLimitExceed.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessIfMacLimitExceed.setDescription('This object specifies the action to be taken by the system for this interface while the number of MAC addresses has exceeded the value of jnxIfMacLimit. This object value is only effective when the corresponding instance value of jnxIfMacLimit is not set to 0.')
jnxSecAccessIfIpSrcGuardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessIfIpSrcGuardStatus.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessIfIpSrcGuardStatus.setDescription("This object indicates whether IP Source Guard is enabled on the specified interface. If this object is 'true', then IP Source Guard is enabled on the specified interface. If this object is 'false', then IP Source Guard is disabled on the specified interface.")
jnxSecAccessIfMacSrcGuardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxSecAccessIfMacSrcGuardStatus.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessIfMacSrcGuardStatus.setDescription("This object indicates whether Mac Source Guard is enabled on the specified interface. If this object is 'true', then Mac Source Guard is enabled on the specified interface. If this object is 'false', then IP Source Guard is disabled on the specified interface.")
jnxStormCtlTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3), )
if mibBuilder.loadTexts: jnxStormCtlTable.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlTable.setDescription('Storm control monitors each type of traffic level on an interface. If traffic level exceeds the threshold value(rising threshold), switch will drop all packets of that type until traffic level drops to the threshold level (falling threshold). If traffic rate for a particular type exceeds the rising threshold, action will be taken to shutdown or add configured filter on the port. This table describes the traffic type for each interface, the rising threshold, falling threshold and the action to be taken if the traffic exceeds the rising threshold.')
jnxStormCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxStormCtlIfTrafficType"))
if mibBuilder.loadTexts: jnxStormCtlEntry.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlEntry.setDescription('An entry contains the interface index,traffic type for the interface, the rising threshold, falling threshold and the action to be taken if the traffic exceeds the rising threshold.')
jnxStormCtlIfTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("multicast", 2), ("unicast", 3))))
if mibBuilder.loadTexts: jnxStormCtlIfTrafficType.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlIfTrafficType.setDescription('This object specifies the traffic type on the particular interface. Value 1 specifies that it is broadcast traffic, value 2 specifies that it is multicast traffic and value 3 specifies that it is unicast traffic.')
jnxStormCtlRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3, 1, 2), Integer32()).setUnits('packets per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxStormCtlRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlRisingThreshold.setDescription('This object specifies the rising threshold value in packets per second. The storm control action is occurs when the traffic exceeds this threshold value.')
jnxStormCtlFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3, 1, 3), Integer32()).setUnits('packets per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxStormCtlFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlFallingThreshold.setDescription('This object specifies the falling threshold value in packets per second. The storm control action ceases when the traffic drops to this threshold value.')
jnxStormCtlAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shutdown", 1), ("filter", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxStormCtlAction.setStatus('current')
if mibBuilder.loadTexts: jnxStormCtlAction.setDescription('This object specifies the action to be taken, when traffic exceeds rising threshold value. Value 1 specifies that the action taken is to shutdown the port. Value 2 specifies that the action taken is to apply a policy filter on the interface for the given packet type. Default is to shutdown(1) the port.')
jnxSecAccessdsRateLimitCrossed = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 0, 1)).setObjects(("JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxSecAccessdsIfRateLimit"))
if mibBuilder.loadTexts: jnxSecAccessdsRateLimitCrossed.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessdsRateLimitCrossed.setDescription('A jnxdsRateLimitCrossed notification is generated when the number of DHCP packets from an untrusted interface exceeds jnxSecAccessdsIfRateLimit.')
jnxSecAccessIfMacLimitExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 0, 2)).setObjects(("JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxSecAccessIfMacLimit"), ("JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxSecAccessIfMacLimitExceed"))
if mibBuilder.loadTexts: jnxSecAccessIfMacLimitExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxSecAccessIfMacLimitExceeded.setDescription('Notification is sent when the number of MAC addresses learnt by the interface has crossed the limit of MAC addresses(jnxSecAccessIfMacLimit) and if MAC Limit Exceeded Action(jnxSecAccessIfMacLimitExceed) is drop or alarm or shutdown.')
jnxStormEventNotification = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 2, 1, 0, 3)).setObjects(("JUNIPER-SECURE-ACCESS-PORT-MIB", "jnxStormCtlRisingThreshold"))
if mibBuilder.loadTexts: jnxStormEventNotification.setStatus('current')
if mibBuilder.loadTexts: jnxStormEventNotification.setDescription('Notification is sent when the traffic in the interface exceeds rising threshold(jnxStormCtlRisingThreshold).')
mibBuilder.exportSymbols("JUNIPER-SECURE-ACCESS-PORT-MIB", PYSNMP_MODULE_ID=jnxExSecureAccessPortMIB, jnxExSecureAccessPortMIB=jnxExSecureAccessPortMIB, jnxSecAccessPortIfEntry=jnxSecAccessPortIfEntry, jnxStormCtlAction=jnxStormCtlAction, jnxStormEventNotification=jnxStormEventNotification, jnxSecAccessIfMacSrcGuardStatus=jnxSecAccessIfMacSrcGuardStatus, jnxSecAccessVlanDAIStatus=jnxSecAccessVlanDAIStatus, jnxSecAccessPortVlanEntry=jnxSecAccessPortVlanEntry, jnxStormCtlTable=jnxStormCtlTable, jnxSecAccessdsRateLimitCrossed=jnxSecAccessdsRateLimitCrossed, jnxSecAccessVlanDhcpSnoopStatus=jnxSecAccessVlanDhcpSnoopStatus, jnxSecAccessPortMIBNotifications=jnxSecAccessPortMIBNotifications, jnxSecAccessVlanName=jnxSecAccessVlanName, JnxMacLimitExceededAction=JnxMacLimitExceededAction, jnxSecAccessPortVlanTable=jnxSecAccessPortVlanTable, jnxSecAccessdsIfRateLimit=jnxSecAccessdsIfRateLimit, jnxSecAccessIfMacLimitExceeded=jnxSecAccessIfMacLimitExceeded, jnxSecAccessIfMacLimit=jnxSecAccessIfMacLimit, jnxSecAccessPortIfTable=jnxSecAccessPortIfTable, jnxStormCtlFallingThreshold=jnxStormCtlFallingThreshold, jnxSecAccessdsIfTrustState=jnxSecAccessdsIfTrustState, jnxSecAccessIfIpSrcGuardStatus=jnxSecAccessIfIpSrcGuardStatus, jnxSecAccessPortMIBObjects=jnxSecAccessPortMIBObjects, jnxSecAccessIfMacLimitExceed=jnxSecAccessIfMacLimitExceed, jnxStormCtlEntry=jnxStormCtlEntry, jnxStormCtlRisingThreshold=jnxStormCtlRisingThreshold, jnxStormCtlIfTrafficType=jnxStormCtlIfTrafficType)

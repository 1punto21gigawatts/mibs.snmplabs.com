#
# PySNMP MIB module DECHUB900-HUBMGR-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECHUB900-HUBMGR-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 12:37:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, NotificationType, Counter64, iso, TimeTicks, ObjectIdentity, Integer32, Unsigned32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, NotificationType, enterprises, ModuleIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "Counter64", "iso", "TimeTicks", "ObjectIdentity", "Integer32", "Unsigned32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "NotificationType", "enterprises", "ModuleIdentity", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
mgmtAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1))
mgmtAgentVersion2 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2))
mamPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1))
eventLogger = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1))
rmonHub = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2))
hubAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1))
hubEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2))
hubEtherCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3))
hubStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4))
hubHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5))
eventLogTotalEvents = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLogTotalEvents.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogTotalEvents.setDescription('The total number of events in the eventLogTable.')
eventLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2), )
if mibBuilder.loadTexts: eventLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogTable.setDescription('A list of eventLogEntry.')
eventLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "eventLogIndex"))
if mibBuilder.loadTexts: eventLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogEntry.setDescription("A list of information describing 'interesting events' which have occurred in the hub or stack.")
eventLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogIndex.setDescription('An index into the eventLogTable. This index begins at one and increments by one each time an event is logged. Older entries may be deleted to make room to newer entries. An eventLogTable of size 7 might look like this: ._____.____.___________.____________________________. |Index|Slot| TimeStamp | Description | |_____|____|___________|____________________________| | 12 | 2 | 2357890 | Port 3 auto-partitioned. | |_____|____|___________|____________________________| | 13 | 4 | 2358900 | Broadcast storm on port 4. | |_____|____|___________|____________________________| | 14 | 2 | 2364220 | Port 3 auto-partitioned. | |_____|____|___________|____________________________| | 15 | 5 | 2369030 | FDDI ring trace received. | |_____|____|___________|____________________________| | 16 | 9 | 2484560 | Stack configuration change.| |_____|____|___________|____________________________| | 17 | 4 | 2504560 | Broadcast storm on port 1. | |_____|____|___________|____________________________| | 18 | 9 | 2600060 | Slot 5 firmware upgraded. | ._____.____.___________.____________________________. ')
eventLogSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLogSlot.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogSlot.setDescription('The slot number of the module reporting the event.')
eventLogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogTimeStamp.setDescription("The time at which the event was logged. This is the Hub Manager's notion of sysUpTime, not the module's.")
eventLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: eventLogDescription.setDescription('A textual description of the event.')
hubAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1), )
if mibBuilder.loadTexts: hubAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmTable.setDescription('A list of alarm entries.')
hubAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmSlotNumber"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmIndex"))
if mibBuilder.loadTexts: hubAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmEntry.setDescription('A list of parameters that set up periodic checking of alarm conditions. For example, an instance of the hubAlarmValue object might be named hubAlarmValue.4.8 for the eighth alarm table entry for hubAlarmValue pertaining to the module occupying slot 4.')
hubAlarmSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAlarmSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmSlotNumber.setDescription("The number of the slot in which the module to be monitored occupies in the hub chassis or the module's position in a stack.")
hubAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmIndex.setDescription('An index that uniquely identifies an entry in the alarm table for a given slot.')
hubAlarmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 21474835))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmInterval.setDescription('The interval, in seconds, over which the data is sampled and compared with the rising and falling thresholds. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmVariable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmVariable.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmVariable.setDescription("The object identifier of the particular variable to be sampled. Only variables that resolve to an ASN.1 primitive type of INTEGER (INTEGER, Counter, Gauge, or TimeTicks) may be sampled. During a set operation, any legally formed Object Identifier is accepted. Once the entry is marked valid, a sample will be taken after the first poll period. If the device (specified by hubAlarmSlotNumber) responds correctly to the first poll, the hubAlarmState for the entry is set to 'active(1)'. Otherwise it is set to 'inactive(2)'. hubAlarmVariables must be unique among slots. For example, you can monitor object X on slot 3 and 5, but you can't monitor object X using two alarmTableEntries on slot 3. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).")
hubAlarmSampleType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmSampleType.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmSampleType.setDescription('The method of sampling the selected variable and calculating the value to be compared against the thresholds. If the value of this object is absoluteValue(1), the value of the selected variable is compared directly with the thresholds at the end of the sampling interval. If the value of this object is deltaValue(2), the value of the selected variable at the last sample will be subtracted from the current value, and the difference compared with the thresholds. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAlarmValue.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmValue.setDescription('The value of the statistic during the last sampling period. For example, if the sample type is deltaValue, this value is the difference between the samples at the beginning and end of the period. If the sample type is absoluteValue, this value is the sampled value at the end of the period. This is the value that is compared with the rising and falling thresholds. The value during the current sampling period is not made available until the period is completed and will remain available until the next period completes.')
hubAlarmStartupAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("risingAlarm", 1), ("fallingAlarm", 2), ("risingOrFallingAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmStartupAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmStartupAlarm.setDescription('The alarm that may be sent when this entry is first set to valid. If the first sample after this entry becomes valid is greater than or equal to the risingThreshold and hubAlarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3), then a single rising alarm will be generated. If the first sample after this entry becomes valid is less than or equal to the fallingThreshold and hubAlarmStartupAlarm is equal to fallingAlarm(2) or risingOrFalling Alarm(3), then a single falling alarm will be generated. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmRisingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmRisingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is greater than or equal to this threshold, and the value at the last sampling interval was less than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is greater than or equal to this threshold and the associated hubAlarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3). After a rising event is generated, another such event will not be generated until the sampled value falls below this threshold and reaches the hubAlarmFallingThreshold. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmFallingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmFallingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is less than or equal to this threshold, and the value at the last sampling interval was greater than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is less than or equal to this threshold and the associated hubAlarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3). After a falling event is generated, another such event will not be generated until the sampled value rises above this threshold and reaches the hubAlarmRisingThreshold. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmRisingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmRisingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmRisingEventIndex.setDescription('The index of the eventEntry that is used when a rising threshold is crossed. The hubEventEntry identified by a particular value of this index is the same as identified by the same value of the hubEvent Index object. If there is no corresponding entry in the hubEvent Table, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmFallingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmFallingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmFallingEventIndex.setDescription('The index of the hubEventEntry that is used when a falling threshold is crossed. The hubEventEntry identified by a particular value of this index is the same as identified by the same value of the hub EventIndex object. If there is no corresponding entry in the hub EventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated hubAlarmStatus object is equal to valid(1).')
hubAlarmOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmOwner.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
hubAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmState.setDescription("The state of this alarm entry. Entries in the Alarm Table are marked as 'inactive' when the module to which they refer: - is removed or becomes 'asleep', - returns an error in response to a poll request, or - ignores a request message. Inactive entries are still polled and are reactivated when: - the module becomes 'awake', and - whenever the module correctly returns a polled value. Entries in the Alarm and Event Tables are deleted either by a network manager, or whenever a stack or hub reconfiguration occurs such that a module of a different type now occupies the slot being polled. (Modules are determined to be 'of a different type' when their sysObjectIDs differ.)")
hubAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hubAlarmStatus.setDescription("The status of this alarm entry. (Refer to the RFC 1757 definition of 'EntryStatus.)")
hubEventTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1), )
if mibBuilder.loadTexts: hubEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventTable.setDescription('A list of events to be generated.')
hubEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEventIndex"))
if mibBuilder.loadTexts: hubEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventEntry.setDescription('A set of parameters that describe an event to be generated when certain conditions are met. As an example, an instance of the hubEventLastTimeSent object might be named hubEventLastTimeSent.6')
hubEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventIndex.setDescription('An index that uniquely identifies an entry in the event table. Each such entry defines one event that is to be generated when the appropriate conditions occur.')
hubEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEventDescription.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventDescription.setDescription('A comment describing this hubEvent entry.')
hubEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmp-trap", 3), ("log-and-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEventType.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventType.setDescription('The type of notification that the probe will make about this event. In the case of log, an entry is made in the log table for each event. In the case of snmp-trap, an SNMP trap is sent to one or more management stations.')
hubEventCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEventCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventCommunity.setDescription('If an SNMP trap is to be sent, it will be sent to the SNMP community specified by this octet string.')
hubEventLastTimeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEventLastTimeSent.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventLastTimeSent.setDescription('The value of sysUpTime at the time this event entry last generated an event. If this entry has not generated any events, this value is zero.')
hubEventOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEventOwner.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
hubEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hubEventStatus.setDescription("The status of this event entry. If this object is not equal to valid(1), all associated log entries shall be deleted by the agent. (Refer to the RFC 1757 definition of 'EntryStatus.)")
hubLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2), )
if mibBuilder.loadTexts: hubLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogTable.setDescription('A list of events that have been logged.')
hubLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubLogSlotNumber"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubLogEventIndex"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubLogIndex"))
if mibBuilder.loadTexts: hubLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogEntry.setDescription('A set of data describing an event that has been logged. For example, an instance of the hubLogDescription object might be named hubLogDescription.6.47')
hubLogSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubLogSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogSlotNumber.setDescription('')
hubLogEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubLogEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogEventIndex.setDescription('The event entry that generated this log entry. The log identified by a particular value of this index is associated with the same eventEntry as identified by the same value of eventIndex.')
hubLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogIndex.setDescription('An index that uniquely identifies an entry in the log table amongst those generated by the same eventEntries. These indexes are assigned beginning with 1 and increase by one with each new log entry. The association between values of hubLogIndex and hubLog Entries is fixed for the lifetime of each hubLogEntry. The agent may choose to delete the oldest instances of hubLogEntry as required because of lack of memory. It is an implementation-specific matter as to when this deletion may occur.')
hubLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogTime.setDescription('The value of sysUpTime when this log entry was created.')
hubLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: hubLogDescription.setDescription('An implementation dependent description of the event that activated this log entry.')
hubEtherCapabilitiesTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1), )
if mibBuilder.loadTexts: hubEtherCapabilitiesTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesTable.setDescription('A list of Ethernet statistic capability entries.')
hubEtherCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherCapabilitiesSlotNumber"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherCapabilitiesIndex"))
if mibBuilder.loadTexts: hubEtherCapabilitiesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesEntry.setDescription('An entry which describes the Ethernet monitoring capabilities or an interface or internal LAN.')
hubEtherCapabilitiesSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherCapabilitiesSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesSlotNumber.setDescription('The number of the slot in which the device resides.')
hubEtherCapabilitiesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherCapabilitiesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesIndex.setDescription('The number of the interface, port, or LAN described by this entry. Where possible, this index should match front bezel numbering. (And front-bezel numbering should match the MIB-II ifIndex of interface types. Where possible, this index should match pcomConTable indices for internal LAN types.')
hubEtherCapabilitiesLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("interface", 1), ("portGroup", 2), ("port", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherCapabilitiesLanType.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesLanType.setDescription('This enumeration describes interface, port, or LAN. The interface type is for any interface which can be described in the MIB-II interface table. Examples of interfaces include switch ports, SLIP/PPP ports, and repeater MACs. The portGroup type is for a group of ports which can be described in the IETF repeater MIB (rfc1368). The portGoup type is for LANs configured to connect the front- bezel ports of repeaters. These internal LANs should be described in the pcomConTable. Indices should match the indices in the pcomConTable. The port type is for a single port which can be described by the IETF repeater MIB.')
hubEtherCapabilitiesLanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherCapabilitiesLanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesLanSpeed.setDescription('The speed at which the Ethernet operates, in mega-bits per second.')
hubEtherCapabilitiesTrueCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherCapabilitiesTrueCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesTrueCollisions.setDescription('The value of this object indicates if the etherStatsCollisions counter is accurately reported. The etherStatsCollisions counter is problematic in that it is defined as the total number of collisions on the segment, while many implementations can only detect the number of collisions involved with transmissions from the interface or port.')
hubEtherCapabilitiesState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubEtherCapabilitiesState.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherCapabilitiesState.setDescription("Setting hubEtherCapabilitiesState to 'active' has the side-effect of: o creating an entry in the hubEtherStatsTable, and o creating two entries in the hubHistoryControlTable. Conversely, setting this object to inactive causes entries in the hubEtherStatsTable and hubHistoryControlTable to be deleted.")
hubEtherStatsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1), )
if mibBuilder.loadTexts: hubEtherStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsTable.setDescription('A list of Ethernet statistics entries.')
hubEtherStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherStatsSlotNumber"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherStatsIndex"))
if mibBuilder.loadTexts: hubEtherStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsEntry.setDescription('A collection of statistics kept for a particular Ethernet interface. As an example, an instance of the hubEtherStatsPkts object might be named hubEtherStatsPkts.1')
hubEtherStatsSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsSlotNumber.setDescription('The number of the slot in which the device whose statistics are being gathered resides. This index corresponds to hubEtherCapabilitiesSlotNumber.')
hubEtherStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsIndex.setDescription('An index into the hubEtherStatsTable. This index corresponds to hubEtherCapabilitiesIndex.')
hubEtherStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsDropEvents.setDescription('The total number of events in which packets were dropped by the device due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
hubEtherStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets).')
hubEtherStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts.setDescription('The total number of packets (including bad packets, broadcast packets, and multicast packets) received.')
hubEtherStatsBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsBroadcastPkts.setDescription('The total number of good packets received that were directed to the broadcast address. Note that this does not include multicast packets.')
hubEtherStatsMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
hubEtherStatsCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsCRCAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsCRCAlignErrors.setDescription('The total number of packets received that had a length (excluding framing bits, but including FCS octets) of between 64 and 1518 octets, inclusive, but but had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
hubEtherStatsUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsUndersizePkts.setDescription('The total number of packets received that were less than 64 octets long (excluding framing bits, but including FCS octets) and were otherwise well formed.')
hubEtherStatsOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsOversizePkts.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets) and were otherwise well formed.')
hubEtherStatsFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsFragments.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsFragments.setDescription('The total number of packets received that were less than 64 octets in length (excluding framing bits but including FCS octets) and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that it is entirely normal for hubEtherStatsFragments to increment. This is because it counts both runts (which are normal occurrences due to collisions) and noise hits.')
hubEtherStatsJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsJabbers.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that this definition of jabber is different than the definition in IEEE-802.3 section 8.2.1.5 (10BASE5) and section 10.3.1.4 (10BASE2). These documents define jabber as the condition where any packet exceeds 20 ms. The allowed range to detect jabber is between 20 ms and 150 ms.')
hubEtherStatsCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsCollisions.setDescription('The best estimate of the total number of collisions on this Ethernet segment.')
hubEtherStatsPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts64Octets.setDescription('The total number of packets (including bad packets) received that were 64 octets in length (excluding framing bits but including FCS octets).')
hubEtherStatsPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts65to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts65to127Octets.setDescription('The total number of packets (including bad packets) received that were between 65 and 127 octets in length inclusive (excluding framing bits but including FCS octets).')
hubEtherStatsPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts128to255Octets.setDescription('The total number of packets (including bad packets) received that were between 128 and 255 octets in length inclusive (excluding framing bits but including FCS octets).')
hubEtherStatsPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts256to511Octets.setDescription('The total number of packets (including bad packets) received that were between 256 and 511 octets in length inclusive (excluding framing bits but including FCS octets).')
hubEtherStatsPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts512to1023Octets.setDescription('The total number of packets (including bad packets) received that were between 512 and 1023 octets in length inclusive (excluding framing bits but including FCS octets).')
hubEtherStatsPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherStatsPkts1024to1518Octets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherStatsPkts1024to1518Octets.setDescription('The total number of packets (including bad packets) received that were between 1024 and 1518 octets in length inclusive (excluding framing bits but including FCS octets).')
hubHistoryControlFastPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 60)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubHistoryControlFastPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlFastPollInterval.setDescription('When hubEtherCapabilitiesState is set to active, two hubHistoryControlEntry are created; a fast poll entry with a default rate of 30 seconds, and a slot poll entry with a default rate of 1800 seconds (30 minutes). This object controls the amount of time, in seconds, between polls of the fast poll entry in the hubHistoryControlTable.')
hubHistoryControlSlowPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubHistoryControlSlowPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlSlowPollInterval.setDescription('When hubEtherCapabilitiesState is set to active, two hubHistoryControlEntry are created; a fast poll entry with a default rate of 30 seconds, and a slot poll entry with a default rate of 1800 seconds (30 minutes). This object controls the amount of time, in seconds, between polls of the slow poll entry in the hubHistoryControlTable.')
hubHistoryControlTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3), )
if mibBuilder.loadTexts: hubHistoryControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlTable.setDescription('A list of history control entries.')
hubHistoryControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubHistoryControlSlotNumber"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubHistoryControlIndex"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubHistoryControlHistoryIndex"))
if mibBuilder.loadTexts: hubHistoryControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlEntry.setDescription('A list of parameters that set up a periodic sampling of statistics. As an example, an instance of the hubHistoryControlInterval object might be named hubHistoryControlInterval.2')
hubHistoryControlSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHistoryControlSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlSlotNumber.setDescription("The number of the slot in which the device's whose Ethernet history is being gathered resides.")
hubHistoryControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHistoryControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlIndex.setDescription('')
hubHistoryControlHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHistoryControlHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlHistoryIndex.setDescription('An index which uniquely identifies instances of both this table and the hubHistoryTable.')
hubHistoryControlBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHistoryControlBuckets.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlBuckets.setDescription('The number of sampling intervals over which data shall be saved in hubEtherHistoryTable.')
hubHistoryControlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHistoryControlInterval.setStatus('mandatory')
if mibBuilder.loadTexts: hubHistoryControlInterval.setDescription('The interval in seconds over which the data is sampled for each bucket in the part of the media-specific table associated with this hubHistoryControlEntry.')
hubEtherHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4), )
if mibBuilder.loadTexts: hubEtherHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryTable.setDescription('A list of Ethernet history entries.')
hubEtherHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1), ).setIndexNames((0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherHistoryIndex"), (0, "DECHUB900-HUBMGR-MIB-V3-0", "hubEtherHistorySampleIndex"))
if mibBuilder.loadTexts: hubEtherHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryEntry.setDescription('An historical sample of Ethernet statistics on a particular Ethernet interface. This sample is associated with the hubHistoryControlEntry which set up the parameters for a regular collection of these samples. As an example, an instance of the hubEtherHistoryPkts object might be named hubEtherHistoryPkts.2.89')
hubEtherHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryIndex.setDescription('')
hubEtherHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same hubHistoryControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
hubEtherHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryIntervalStart.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
hubEtherHistoryDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources during this sampling interval. Note that this number is not necessarily the number of packets dropped, it is just the number of times this condition has been detected.')
hubEtherHistoryOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets).')
hubEtherHistoryPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryPkts.setDescription('The number of packets (including bad packets) received during this sampling interval.')
hubEtherHistoryBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryBroadcastPkts.setDescription('The number of good packets received during this sampling interval that were directed to the broadcast address.')
hubEtherHistoryMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryMulticastPkts.setDescription('The number of good packets received during this sampling interval that were directed to a multicast address. Note that this number does not include packets addressed to the broadcast address.')
hubEtherHistoryCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryCRCAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryCRCAlignErrors.setDescription('The number of packets received during this sampling interval that had a length (excluding framing bits but including FCS octets) between 64 and 1518 octets, inclusive, but had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
hubEtherHistoryUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryUndersizePkts.setDescription('The number of packets received during this sampling interval that were less than 64 octets long (excluding framing bits but including FCS octets) and were otherwise well formed.')
hubEtherHistoryOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryOversizePkts.setDescription('The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets) but were otherwise well formed.')
hubEtherHistoryFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryFragments.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryFragments.setDescription('The total number of packets received during this sampling interval that were less than 64 octets in length (excluding framing bits but including FCS octets) had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that it is entirely normal for hubEtherHistoryFragments to increment. This is because it counts both runts (which are normal occurrences due to collisions) and noise hits.')
hubEtherHistoryJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryJabbers.setDescription('The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non- integral number of octets (Alignment Error). Note that this definition of jabber is different than the definition in IEEE-802.3 section 8.2.1.5 (10BASE5) and section 10.3.1.4 (10BASE2). These documents define jabber as the condition where any packet exceeds 20 ms. The allowed range to detect jabber is between 20 ms and 150 ms.')
hubEtherHistoryCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryCollisions.setDescription('The best estimate of the total number of collisions on this Ethernet segment during this sampling interval.')
hubEtherHistoryUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1, 2, 5, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEtherHistoryUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: hubEtherHistoryUtilization.setDescription('The best estimate of the mean physical layer network utilization on this interface during this sampling interval, in hundredths of a percent.')
hubRisingAlarm = NotificationType((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1) + (0,1)).setObjects(("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmSlotNumber"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmIndex"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmVariable"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmSampleType"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmValue"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmRisingThreshold"))
if mibBuilder.loadTexts: hubRisingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its rising threshold and generates an event that is configured for sending SNMP traps. The enterprise Object Identifier for this trap is: iso(1).org(3).dod(6).internet(1).private(4).enterprises(1). dec(36).ema(2).decMIBextension(18).decHub900(11). mgmtAgent(1).mgmtAgentVersion2(2).mamPrivate(2) ')
hubFallingAlarm = NotificationType((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 2, 1) + (0,2)).setObjects(("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmSlotNumber"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmIndex"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmVariable"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmSampleType"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmValue"), ("DECHUB900-HUBMGR-MIB-V3-0", "hubAlarmRisingThreshold"))
if mibBuilder.loadTexts: hubFallingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its falling threshold and generates an event that is configured for sending SNMP traps. The enterprise Object Identifier for this trap is: iso(1).org(3).dod(6).internet(1).private(4).enterprises(1). dec(36).ema(2).decMIBextension(18).decHub900(11). mgmtAgent(1).mgmtAgentVersion2(2).mamPrivate(2) ')
mibBuilder.exportSymbols("DECHUB900-HUBMGR-MIB-V3-0", hubLogEventIndex=hubLogEventIndex, hubEtherCapabilitiesLanType=hubEtherCapabilitiesLanType, hubEtherStatsTable=hubEtherStatsTable, hubEventDescription=hubEventDescription, hubEventOwner=hubEventOwner, hubHistoryControlTable=hubHistoryControlTable, hubEtherHistoryUtilization=hubEtherHistoryUtilization, hubAlarmFallingThreshold=hubAlarmFallingThreshold, hubEtherStatsMulticastPkts=hubEtherStatsMulticastPkts, hubLogTime=hubLogTime, eventLogDescription=eventLogDescription, hubAlarmStartupAlarm=hubAlarmStartupAlarm, hubEtherHistoryFragments=hubEtherHistoryFragments, hubLogDescription=hubLogDescription, hubAlarmStatus=hubAlarmStatus, hubEtherCapabilitiesIndex=hubEtherCapabilitiesIndex, hubEtherHistoryOversizePkts=hubEtherHistoryOversizePkts, hubEventIndex=hubEventIndex, hubEtherHistoryOctets=hubEtherHistoryOctets, hubHistoryControlHistoryIndex=hubHistoryControlHistoryIndex, decMIBextension=decMIBextension, hubAlarmSampleType=hubAlarmSampleType, hubAlarmState=hubAlarmState, hubEtherCapabilitiesTrueCollisions=hubEtherCapabilitiesTrueCollisions, hubLogSlotNumber=hubLogSlotNumber, hubHistoryControlIndex=hubHistoryControlIndex, hubHistoryControlFastPollInterval=hubHistoryControlFastPollInterval, hubEventTable=hubEventTable, dec=dec, hubEtherStatsPkts1024to1518Octets=hubEtherStatsPkts1024to1518Octets, hubAlarmOwner=hubAlarmOwner, hubEtherStatsFragments=hubEtherStatsFragments, hubHistoryControlInterval=hubHistoryControlInterval, hubEtherHistoryPkts=hubEtherHistoryPkts, hubEventLastTimeSent=hubEventLastTimeSent, hubEventCommunity=hubEventCommunity, hubAlarmFallingEventIndex=hubAlarmFallingEventIndex, hubEtherStatsUndersizePkts=hubEtherStatsUndersizePkts, hubAlarmRisingEventIndex=hubAlarmRisingEventIndex, hubAlarmIndex=hubAlarmIndex, hubEtherStatsCRCAlignErrors=hubEtherStatsCRCAlignErrors, hubEtherHistoryBroadcastPkts=hubEtherHistoryBroadcastPkts, hubEtherStatsPkts256to511Octets=hubEtherStatsPkts256to511Octets, hubEtherHistoryDropEvents=hubEtherHistoryDropEvents, hubEtherHistoryMulticastPkts=hubEtherHistoryMulticastPkts, rmonHub=rmonHub, hubEventType=hubEventType, ema=ema, hubAlarmRisingThreshold=hubAlarmRisingThreshold, eventLogIndex=eventLogIndex, hubAlarmValue=hubAlarmValue, hubEvent=hubEvent, hubEventEntry=hubEventEntry, hubEtherStatsDropEvents=hubEtherStatsDropEvents, hubAlarmTable=hubAlarmTable, hubHistory=hubHistory, eventLogTotalEvents=eventLogTotalEvents, eventLogger=eventLogger, hubEtherStatsSlotNumber=hubEtherStatsSlotNumber, hubEtherCapabilitiesEntry=hubEtherCapabilitiesEntry, hubEtherCapabilities=hubEtherCapabilities, hubHistoryControlSlowPollInterval=hubHistoryControlSlowPollInterval, hubEtherHistoryIndex=hubEtherHistoryIndex, hubEtherHistoryCRCAlignErrors=hubEtherHistoryCRCAlignErrors, decHub900=decHub900, hubLogIndex=hubLogIndex, hubEtherStatsEntry=hubEtherStatsEntry, hubEtherHistoryTable=hubEtherHistoryTable, hubRisingAlarm=hubRisingAlarm, hubEtherCapabilitiesLanSpeed=hubEtherCapabilitiesLanSpeed, hubHistoryControlBuckets=hubHistoryControlBuckets, mgmtAgentVersion2=mgmtAgentVersion2, hubEtherStatsJabbers=hubEtherStatsJabbers, hubFallingAlarm=hubFallingAlarm, hubAlarm=hubAlarm, eventLogTimeStamp=eventLogTimeStamp, mgmtAgent=mgmtAgent, hubEtherStatsPkts128to255Octets=hubEtherStatsPkts128to255Octets, hubEtherStatsPkts512to1023Octets=hubEtherStatsPkts512to1023Octets, hubHistoryControlSlotNumber=hubHistoryControlSlotNumber, hubLogEntry=hubLogEntry, hubStatistics=hubStatistics, hubEtherStatsOctets=hubEtherStatsOctets, hubEtherCapabilitiesTable=hubEtherCapabilitiesTable, hubEtherHistoryEntry=hubEtherHistoryEntry, hubEtherHistoryCollisions=hubEtherHistoryCollisions, hubEtherStatsPkts65to127Octets=hubEtherStatsPkts65to127Octets, hubAlarmVariable=hubAlarmVariable, hubAlarmEntry=hubAlarmEntry, mamPrivate=mamPrivate, hubEtherHistoryUndersizePkts=hubEtherHistoryUndersizePkts, hubAlarmInterval=hubAlarmInterval, hubEtherStatsBroadcastPkts=hubEtherStatsBroadcastPkts, hubEtherStatsPkts=hubEtherStatsPkts, hubLogTable=hubLogTable, eventLogTable=eventLogTable, hubEventStatus=hubEventStatus, hubEtherStatsCollisions=hubEtherStatsCollisions, eventLogSlot=eventLogSlot, hubAlarmSlotNumber=hubAlarmSlotNumber, hubEtherHistoryJabbers=hubEtherHistoryJabbers, eventLogEntry=eventLogEntry, hubHistoryControlEntry=hubHistoryControlEntry, hubEtherHistorySampleIndex=hubEtherHistorySampleIndex, hubEtherCapabilitiesSlotNumber=hubEtherCapabilitiesSlotNumber, hubEtherHistoryIntervalStart=hubEtherHistoryIntervalStart, hubEtherStatsPkts64Octets=hubEtherStatsPkts64Octets, hubEtherStatsIndex=hubEtherStatsIndex, hubEtherCapabilitiesState=hubEtherCapabilitiesState, hubEtherStatsOversizePkts=hubEtherStatsOversizePkts)

#
# PySNMP MIB module HM2-VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-VPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
HmTimeSeconds1970, HmLargeDisplayString, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmTimeSeconds1970", "HmLargeDisplayString", "hm2ConfigurationMibs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, iso, Counter64, MibIdentifier, Integer32, TimeTicks, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Unsigned32, Gauge32, IpAddress, Bits, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "iso", "Counter64", "MibIdentifier", "Integer32", "TimeTicks", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Unsigned32", "Gauge32", "IpAddress", "Bits", "Counter32")
TruthValue, RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "TextualConvention", "DisplayString")
hm2VpnMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120))
hm2VpnMib.setRevisions(('2014-03-14 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2VpnMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2VpnMib.setLastUpdated('201403141200Z')
if mibBuilder.loadTexts: hm2VpnMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2VpnMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 - 7127 -14 -0 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2VpnMib.setDescription('This MIB defines the SNMP interface for Hirschmann VPN implementations.')
hm2VpnMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 0))
hm2VpnMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 1))
hm2VpnMibSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 3))
hm2VpnGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 1))
hm2VpnConnectionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2))
hm2VpnTrafficSelGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3))
hm2VpnCertificateGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4))
hm2VpnConnMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnMax.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnMax.setDescription('Maximum number of VPN connections supported. Notice that the maximum number of active and up VPN connections is limited to hm2VpnConnActiveMax.')
hm2VpnConnActiveMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnActiveMax.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnActiveMax.setDescription('Maximum number of active (and up) VPN connections supported.')
hm2VpnConnNext = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnNext.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnNext.setDescription('This object always holds an appropriate value to be used for hm2VpnConnIndex when creating entries in the hm2VpnConnTable. The value 0 indicates that no unassigned entries are available. To obtain the hm2VpnConnIndex value for a new entry, the management station issues a SNMP retrieval operation to obtain the current value of this object. After each row creation or deletion the agent modifies the value to the next unassigned index.')
hm2VpnConnTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10), )
if mibBuilder.loadTexts: hm2VpnConnTable.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnTable.setDescription('A list of VPN connections.')
hm2VpnConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1), ).setIndexNames((0, "HM2-VPN-MIB", "hm2VpnConnIndex"))
if mibBuilder.loadTexts: hm2VpnConnEntry.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnEntry.setDescription('A VPN connection entry.')
hm2VpnConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2VpnConnIndex.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIndex.setDescription('An index that uniquely identifies the entry in the table.')
hm2VpnConnIkeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ike", 1), ("ikev1", 2), ("ikev2", 3))).clone('ike')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeVersion.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeVersion.setDescription('Version of the IKE protocol: o ike: accept IKEv1/v2 as responder, start with IKEv2 as initiator o ikev1: used protocol is IKE version 1 (ISAKMP) o ikev2: used protocol is IKE version 2')
hm2VpnConnIkeStartup = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initiator", 1), ("responder", 2))).clone('responder')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeStartup.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeStartup.setDescription('If this host acts as a responder it does not initiate a key exchange (IKE) nor connection parameters negotiation. Otherwise, this host acts as an initiator - then it initiates an IKE actively.')
hm2VpnConnIkeLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 86400)).clone(28800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeLifetime.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeLifetime.setDescription('Lifetime of IKE security association in seconds. The maximum value is 24 hours (86400 seconds).')
hm2VpnConnIkeDpdTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(120)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeDpdTimeout.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeDpdTimeout.setDescription('If greater than zero, the local peer sends Dead Peer Detection (DPD) messages (according to RFC 3706) to the remote peer. This value specifies the timeout in seconds, the remote peer is declared dead, if not responding. The value 0 disables this feature.')
hm2VpnConnIkeLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeLocalAddr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeLocalAddr.setDescription("Hostname (FQDN) or IP address of local security gateway. If the value is 'any', then the IP address of the matching interface is used. Establishing the connection may be delayed until the hostname (if specified) can be resolved.")
hm2VpnConnIkeRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeRemoteAddr.setDescription("Typically the hostname (FQDN) or IP address of remote security gateway. If this value is 'any', then any IP address is accepted when establishing an IKE-SA as responder. Also a network in CIDR notation, to be accepted when establishing the IKE-SA, is allowed as responder. As initiator such values are not allowed. Establishing the VPN connection may be delayed until the hostname (if specified) can be resolved.")
hm2VpnConnIkeAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("psk", 1), ("individualx509", 2), ("pkcs12", 3))).clone('psk')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthType.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthType.setDescription('Type of authentication to be used: pre-shared key, individual X509 certificates (separate for CA and local identification) or one PKCS12 container with all the needed certificates (including the CA).')
hm2VpnConnIkeAuthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("aggressive", 2))).clone('main')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthMode.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthMode.setDescription('The phase 1 exchange mode to be used (IKEv1).')
hm2VpnConnIkeAuthCertCA = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertCA.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertCA.setDescription("PEM encoded X.509 certificate file name (RFC 1422), if authentication type in 'hm2VpnConnIkeAuthType' is 'individualx509'. This certificate is used for RSA based signature verification in local and remote certificates. The file needs to be uploaded separately.")
hm2VpnConnIkeAuthCertRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertRemote.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertRemote.setDescription("PEM encoded X.509 certificate file name (RFC 1422), if authentication type in 'hm2VpnConnIkeAuthType' is 'individualx509'. This certificate is used for RSA based authentication of remote peer at the local side. This certificate binds the identity of remote peer to it's public key. It is optional because typically send by the remote peer while negotiating an ISAKMP/IKE security association. The file needs to be uploaded separately.")
hm2VpnConnIkeAuthCertLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertLocal.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthCertLocal.setDescription("PEM encoded X.509 certificate file name (RFC 1422) to be used, if authentication type in 'hm2VpnConnIkeAuthType' is 'individualx509' or 'pkcs12'. This certificate is used for authentication of local peer at the remote side. The certificate binds the identity of local peer to it's public key, signed by the certification authority (CA) from 'hm2VpnConnIkeAuthCertCA'. The file needs to be uploaded separately.")
hm2VpnConnIkeAuthPrivKey = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPrivKey.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPrivKey.setDescription("Private key file name to be used, if authentication type in 'hm2VpnConnIkeAuthType' is 'individualx509' and the key stored on the device is encrypted with a passphrase (so it cannot automatically be matched with the certificate). Note that this is only the filename of the private key. The passphrase must be added to 'hm2VpnConnIkeAuthPasswd'.")
hm2VpnConnIkeAuthPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPasswd.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPasswd.setDescription("Passphrase to be used for decryption of private key from 'hm2VpnConnIkeAuthPrivKey' or the certificate container for 'pkcs12' type certificates which are uploaded encrypted.")
hm2VpnConnIkeAuthPsk = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPsk.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthPsk.setDescription("Pre-shared key (passphrase) to be used if authentication type in 'hm2VpnConnIkeAuthType' is 'psk'. The pre-shared key sequence cannot contain newline or double-quote characters. Alternatively to characters sequence, pre-shared secrets can be represented as hexadecimal or Base64 encoded binary values. A character sequence beginning with 0x is interpreted as sequence hexadecimal digits. Similarly, a character sequence beginning with 0s is interpreted as Base64 encoded binary data. ")
hm2VpnConnIkeAuthLocId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthLocId.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthLocId.setDescription("Local peer identifier to be sent within ID payload during negotiation. The ID payload is used to identify the initiator of the security association. The identity is used by the responder to determine the correct host system security policy requirement for the association (see RFC 2407, section 4.6.2 for details when using IKEv1 and RFC 4306, section 3.5 for IKEv2). Allowed formats for this object depend on 'hm2VpnConnIkeAuthLocType': o default: don't care o address: don't care, take IPv4 address or host name from hm2VpnConnIkeLocalAddr o id: - IPv4 address or host name - key identifier - fully qualified domain name - fully qualified RFC 822 email address - X.500 distinguished name (DN) ")
hm2VpnConnIkeAuthLocType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("address", 2), ("id", 3))).clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthLocType.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthLocType.setDescription("Type of local peer identifier in 'hm2VpnConnIkeAuthLocId': o default: If 'hm2VpnConnIkeAuthType' is 'psk' then use the IP address or host name from 'hm2VpnConnIkeLocalAddr' as local identifier. In case of 'individualx509' or 'pkcs12' use the DN from local certificate in 'hm2VpnConnIkeAuthCertLocal'. o address: use the IP address or DNS name from 'hm2VpnConnIkeLocalAddr' as local identifier. o id: use the configured value in hm2VpnConnIkeAuthLocId (it can be of any type in the description). For further information see RFC 2407, section 4.6.2")
hm2VpnConnIkeAuthRemId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthRemId.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthRemId.setDescription("Remote peer identifier to be compared with ID payload during negotiation. The ID payload is used to identify the initiator of the security association. The identity is used by the responder to determine the correct host system security policy requirement for the association (see RFC 2407, section 4.6.2 for details when using IKEv1 and RFC 4306, section 3.5 for IKEv2). Allowed formats for this entry depend on 'hm2VpnConnIkeAuthRemType': o any: don't care o address: don't care, take IPv4 address or host name from hm2VpnConnIkeRemoteAddr o id: - IPv4 address or host name - key identifier - fully qualified domain name - fully qualified RFC 822 email address - X.500 distinguished name (DN) ")
hm2VpnConnIkeAuthRemType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("address", 2), ("id", 3))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAuthRemType.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAuthRemType.setDescription("Type of remote peer identifier in hm2VpnConnIkeAuthRemId: o any: received remote identifier is not checked o address: use the IP address or host name from 'hm2VpnConnIkeRemoteAddr' as remote identifier. o id: use the configured value in hm2VpnConnIkeAuthRemId (it can be of any type in the description). For further information see RFC 2407, section 4.6.2")
hm2VpnConnIkeAlgDh = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("any", 1), ("modp1024", 2), ("modp1536", 3), ("modp2048", 4), ("modp3072", 5), ("modp4096", 6))).clone('modp1024')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAlgDh.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAlgDh.setDescription('Diffie-Hellman key agreement algorithm to be used for establishment of IKE-SA: o any: accept all supported algorithms as responder, use default as initiator o modp1024: RSA with 1024 bits modulus (DH Group 2) o modp1536: RSA with 1536 bits modulus (DH Group 5) o modp2048: RSA with 2048 bits modulus (DH Group 14) o modp3072: RSA with 3072 bits modulus (DH Group 15) o modp4096: RSA with 4096 bits modulus (DH Group 16)')
hm2VpnConnIkeAlgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("any", 1), ("hmacmd5", 2), ("hmacsha1", 3), ("hmacsha256", 4), ("hmacsha384", 5), ("hmacsha512", 6))).clone('hmacsha1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAlgMac.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAlgMac.setDescription('Integrity (MAC) algorithm to be used in IKEv2: o any: accept all supported algorithms as responder, use various pre-defined as initiator o hmacmd5: HMAC-MD5 (length 96 bit) o hmacsha1: HMAC-SHA1 (length 96 bit) o hmacsha256: HMAC-SHA256 (length 128 bit) o hmacsha384: HMAC-SHA384 (length 196 bit) o hmacsha512: HMAC-SHA512 (length 256 bit) ')
hm2VpnConnIkeAlgEncr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("any", 1), ("des", 2), ("des3", 3), ("aes128", 4), ("aes192", 5), ("aes256", 6))).clone('aes128')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeAlgEncr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeAlgEncr.setDescription('Encryption algorithm to be used in IKE: o any: accept all supported algorithms as responder, use various pre-defined as initiator o des: DES o des3: Triple-DES o aes128: AES with 128 key bits o aes192: AES with 192 key bits o aes256: AES with 256 key bits')
hm2VpnConnIkeReAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIkeReAuth.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIkeReAuth.setDescription('whether re-keying of an IKE_SA should also re-authenticate the peer. In IKEv1, re-authentication is always done (also when set to false). In IKEv2, a value of false does re-keying without un-installing the IPsec SAs, a value of true creates a new IKE_SA from scratch and tries to recreate all IPsec SAs.')
hm2VpnConnIpsecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("tunnel", 1))).clone('tunnel')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIpsecMode.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIpsecMode.setDescription('IPsec encapsulation mode.')
hm2VpnConnIpsecLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 28800)).clone(3600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIpsecLifetime.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIpsecLifetime.setDescription('Lifetime of IPsec security association in seconds. The maximum value is 8 hours (28800 seconds).')
hm2VpnConnMargintime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800)).clone(150)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnMargintime.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnMargintime.setDescription('How long before connection expiry or keying-channel expiry should attempts to negotiate a replacement begin. The maximum value is half an hour (1800 seconds). The margin time needs to be at most half of the lifetime.')
hm2VpnConnIpsecAlgDh = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("any", 1), ("modp1024", 2), ("modp1536", 3), ("modp2048", 4), ("modp3072", 5), ("modp4096", 6), ("none", 7))).clone('modp1024')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgDh.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgDh.setDescription('Diffie-Hellman key agreement algorithm to be used for IPsec-SA session key establishment: o any: accept all supported algorithms as responder, use various pre-defined as initiator o modp1024: RSA with 1024 bits modulus (DH Group 2) o modp1536: RSA with 1536 bits modulus (DH Group 5) o modp2048: RSA with 2048 bits modulus (DH Group 14) o modp3072: RSA with 3072 bits modulus (DH Group 15) o modp4096: RSA with 4096 bits modulus (DH Group 16) o none: no Perfect Forward Secrecy (PFS)')
hm2VpnConnIpsecAlgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("any", 1), ("hmacmd5", 2), ("hmacsha1", 3), ("hmacsha256", 4), ("hmacsha384", 5), ("hmacsha512", 6))).clone('hmacsha1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgMac.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgMac.setDescription('Integrity (MAC) algorithm to be used in IPsec: o any: accept all supported algorithms as responder, use various pre-defined as initiator o hmacmd5: HMAC-MD5 (length 96 bit) o hmacsha1: HMAC-SHA1 (length 96 bit) o hmacsha256: HMAC-SHA256 (length 128 bit) o hmacsha384: HMAC-SHA384 (length 196 bit) o hmacsha512: HMAC-SHA512 (length 256 bit) ')
hm2VpnConnIpsecAlgEncr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("any", 1), ("des", 2), ("des3", 3), ("aes128", 4), ("aes192", 5), ("aes256", 6), ("aes128ctr", 7), ("aes192ctr", 8), ("aes256ctr", 9), ("aes128gcm64", 10), ("aes128gcm96", 11), ("aes128gcm128", 12), ("aes192gcm64", 13), ("aes192gcm96", 14), ("aes192gcm128", 15), ("aes256gcm64", 16), ("aes256gcm96", 17), ("aes256gcm128", 18))).clone('aes128')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgEncr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnIpsecAlgEncr.setDescription('Encryption algorithm to be used for payload encryption in IPsec: o any: accept all supported algorithms as responder, use various pre-defined as initiator o des: DES o des3: Triple-DES o aes128: AES-CBC with 128 key bits o aes192: AES-CBC with 192 key bits o aes256: AES-CBC with 256 key bits o aes128ctr: AES-COUNTER with 128 key bits o aes192ctr: AES-COUNTER with 192 key bits o aes256ctr: AES-COUNTER with 256 key bits o aes128gcm64: AES-GCM with 64 bit ICV with 128 key bits o aes128gcm96: AES-GCM with 96 bit ICV with 128 key bits o aes128gcm128: AES-GCM with 128 bit ICV with 128 key bits o aes192gcm64: AES-GCM with 64 bit ICV with 192 key bits o aes192gcm96: AES-GCM with 96 bit ICV with 192 key bits o aes192gcm128: AES-GCM with 128 bit ICV with 192 key bits o aes256gcm64: AES-GCM with 64 bit ICV with 256 key bits o aes256gcm96: AES-GCM with 96 bit ICV with 256 key bits o aes256gcm128: AES-GCM with 128 bit ICV with 256 key bits ')
hm2VpnConnOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("negotiation", 3), ("constructing", 4), ("dormant", 5), ("re-keying", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnOperStatus.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnOperStatus.setDescription("The current operational status of the VPN connection: o 'up': the IKE-SA and all IPsec SAs are up; o 'down': the IKE-SA and all IPsec SAs are down; o 'negotiation': key exchange and algorithm negotiation is in progress (or, as responder, waiting to be contacted for that purpose); o 'constructing': the IKE-SA is up, but at least one IPsec-SA is not established so far; o 'dormant': waiting for a precondition to be fulfilled before connection setup, e.g.: - a dynamically assigned IP address; - successful hostname resolution; - assignment of a valid system time. o 're-keying': key exchange is in progress after timeout of lifetime has occured, either IKE or IPSEC; ")
hm2VpnConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnDesc.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnDesc.setDescription('User defined text.')
hm2VpnConnLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 32), HmLargeDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnLastError.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnLastError.setDescription('Last error notification occurred for this connection. This is useful if the connection does not reach the up state to see if an error has occurred in the proposal exchange or when establishing the tunnel. In most cases this variable should be empty.')
hm2VpnConnDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 33), Bits().clone(namedValues=NamedValues(("informational", 0), ("unhandled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnDebug.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnDebug.setDescription('Used for debugging purpose of the VPN connections. May affect the performance significant. Please handle with care. If the bit is set informational(0) messages, unhandled(1) messages (not handled by the stack) are logged to the event log')
hm2VpnConnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 10, 1, 34), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnConnRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnRowStatus.setDescription("The row status of this table entry. If the row status is 'active' then it is not allowed to change any value (this applies also to active traffic selectors). The maximum number of active VPN connections is limited to hm2VpnConnMax. The maximum number of active and up VPN connections is limited to hm2VpnConnActiveMax.")
hm2VpnConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15), )
if mibBuilder.loadTexts: hm2VpnConnInfoTable.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoTable.setDescription('A list of VPN connections.')
hm2VpnConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1), ).setIndexNames((0, "HM2-VPN-MIB", "hm2VpnConnIndex"))
if mibBuilder.loadTexts: hm2VpnConnInfoEntry.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoEntry.setDescription('A VPN connection entry.')
hm2VpnConnInfoIkeVersionUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ikev1", 1), ("ikev2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIkeVersionUsed.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIkeVersionUsed.setDescription('Version of the IKE protocol used by connection: o ikev1: used protocol is IKE version 1 (ISAKMP) o ikev2: used protocol is IKE version 2')
hm2VpnConnInfoIkeProposal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIkeProposal.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIkeProposal.setDescription('Algorithms the IKE use for key exchange.')
hm2VpnConnInfoIpsecProposal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecProposal.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecProposal.setDescription('Algorithms IPsec use for the data communication.')
hm2VpnConnInfoLocalHost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoLocalHost.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoLocalHost.setDescription('Local host detected by IKE.')
hm2VpnConnInfoRemoteHost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoRemoteHost.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoRemoteHost.setDescription('Remote host detected by IKE.')
hm2VpnConnInfoEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoEstablished.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoEstablished.setDescription('Time in seconds since the connection has been established (is updated after IKE re-authentication).')
hm2VpnConnInfoIKEReauth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIKEReauth.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIKEReauth.setDescription('Time in seconds when the next IKE re-authentication will take place.')
hm2VpnConnInfoIKERekeying = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIKERekeying.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIKERekeying.setDescription('Time in seconds when the next IKE re-keying will take place.')
hm2VpnConnInfoIpsecRekeying = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecRekeying.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecRekeying.setDescription('Time in seconds when the next IPsec re-keying will take place.')
hm2VpnConnInfoIpsecInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInBytes.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInBytes.setDescription('Number of input Bytes from this IPsec tunnel.')
hm2VpnConnInfoIpsecInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInPackets.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInPackets.setDescription('Number of input packets from this IPsec tunnel.')
hm2VpnConnInfoIpsecInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInUse.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInUse.setDescription('Time in seconds since the IPsec tunnel has received last time data.')
hm2VpnConnInfoIpsecOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutBytes.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutBytes.setDescription('Number of output Bytes to this IPsec tunnel.')
hm2VpnConnInfoIpsecOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutPackets.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutPackets.setDescription('Number of output packets to this IPsec tunnel.')
hm2VpnConnInfoIpsecOutUse = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutUse.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutUse.setDescription('Time in seconds since to the IPsec tunnel has sent last time data.')
hm2VpnConnInfoIKEInitiatorSPI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIKEInitiatorSPI.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIKEInitiatorSPI.setDescription('The IKE initiator SPI (local or remote, depends on initiator settings).')
hm2VpnConnInfoIKEResponderSPI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIKEResponderSPI.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIKEResponderSPI.setDescription('The IKE responder SPI (local or remote, depends on initiator settings).')
hm2VpnConnInfoIpsecInSPI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInSPI.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecInSPI.setDescription('The input IPsec SPI.')
hm2VpnConnInfoIpsecOutSPI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 2, 15, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutSPI.setStatus('current')
if mibBuilder.loadTexts: hm2VpnConnInfoIpsecOutSPI.setDescription('The output IPsec SPI.')
hm2VpnTrafficSelTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1), )
if mibBuilder.loadTexts: hm2VpnTrafficSelTable.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelTable.setDescription('A list of traffic selectors. For details on the role of traffic selectors in IPsec protocol see RFC 2409, section 5.5 and RFC 4306, section 2.9.')
hm2VpnTrafficSelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1), ).setIndexNames((0, "HM2-VPN-MIB", "hm2VpnConnIndex"), (0, "HM2-VPN-MIB", "hm2VpnTrafficSelIndex"))
if mibBuilder.loadTexts: hm2VpnTrafficSelEntry.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelEntry.setDescription('A traffic selector entry. A traffic selector defines the subnet/host addresses for which this IPSec connection (SA) is responsible.')
hm2VpnTrafficSelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: hm2VpnTrafficSelIndex.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelIndex.setDescription('An index that (together with the connection index hm2VpnConnIndex) identifies the entry in the traffic selector table. This index can be choosen freely, but must be greater than 0.')
hm2VpnTrafficSelSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelSrcAddr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelSrcAddr.setDescription("Host or subnet address in CIDR notation (a.b.c.d/n) for which this traffic descriptor (and the associated VPN connection) is responsible. This address is compared to the source address of IP packets sent, when determining the associated IPsec and IKE-SA. The special keyword 'any' means that the address comparison always matches.")
hm2VpnTrafficSelDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelDstAddr.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelDstAddr.setDescription("Host or subnet address in CIDR notation (a.b.c.d/n) for which this traffic descriptor (and the associated VPN connection) is responsible. This address is compared to the destination address of IP packets sent, when determining the associated IPsec and IKE-SA. The special keyword 'any' means that the address comparison always matches.")
hm2VpnTrafficSelSrcRest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelSrcRest.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelSrcRest.setDescription('The optional source restrictions (names or numbers) <protocol/port>, e.g. tcp/http which is equal to 6/80, or udp which is equal to udp/any or /53 which is equal to any/53 ')
hm2VpnTrafficSelDstRest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelDstRest.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelDstRest.setDescription('The optional destination restrictions (names or numbers) <protocol/port>, e.g. tcp/http which is equal to 6/80, or udp which is equal to udp/any or /53 which is equal to any/53 ')
hm2VpnTrafficSelDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelDesc.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelDesc.setDescription('User defined text.')
hm2VpnTrafficSelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 3, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2VpnTrafficSelRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2VpnTrafficSelRowStatus.setDescription("The row status of this table entry. Only traffic selector entries with an 'active' row status will be considered if the connections row status is set 'active'. Independent of that dependency any value in this entry can be changed only if the row status is not 'active'.")
hm2VpnCertificateUploadPassphrase = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2VpnCertificateUploadPassphrase.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateUploadPassphrase.setDescription('Setting the correct passphrase here before uploading an encrypted private key or an encrypted PKCS12 container will trigger the decryption of the uploaded file before storing on the device. The value cannot be read and is not stored after the file transfer. WARNING: the file is stored unencrypted on the device. Use with care!')
hm2VpnCertificateTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10), )
if mibBuilder.loadTexts: hm2VpnCertificateTable.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateTable.setDescription('The list of certificates available on the device.')
hm2VpnCertificateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1), ).setIndexNames((0, "HM2-VPN-MIB", "hm2VpnCertificateIndex"))
if mibBuilder.loadTexts: hm2VpnCertificateEntry.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateEntry.setDescription('A certificate file entry. A certificate file which has been copied to the device and can be used for VPN connections.')
hm2VpnCertificateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: hm2VpnCertificateIndex.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateIndex.setDescription('Index of the entry.')
hm2VpnCertificateSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateSubject.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateSubject.setDescription('Subject field of certificate.')
hm2VpnCertificateIssuer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateIssuer.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateIssuer.setDescription('Certificate issuer.')
hm2VpnCertificateStartDate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 4), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateStartDate.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateStartDate.setDescription('Time and date when certificate is begining to be valid.')
hm2VpnCertificateEndDate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 5), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateEndDate.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateEndDate.setDescription('Time and date when certificate will expire.')
hm2VpnCertificateFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateFileName.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateFileName.setDescription('Name of the file consisting of alphanumeric characters plus hyphen, underscore and dot.')
hm2VpnCertificateType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ca", 1), ("peer", 2), ("encryptedkey", 3), ("pkcs12", 4), ("encryptedpkcs12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateType.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateType.setDescription('Type of the container file used.')
hm2VpnCertificateCertUploadDate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 8), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateCertUploadDate.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateCertUploadDate.setDescription('Time and date of last write access using the content of the variable hm2SystemTime.')
hm2VpnCertificatePrivateKeyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("present", 2), ("notFound", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificatePrivateKeyStatus.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificatePrivateKeyStatus.setDescription('Shows if a Peer certificate has a private key uploaded on the device. A Peer certificate cannot be used without a private key uploaded to the device. Does not apply to CA certificates.')
hm2VpnCertificatePrivateKeyFile = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificatePrivateKeyFile.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificatePrivateKeyFile.setDescription('Name of the file consisting of alphanumeric characters plus hyphen, underscore and dot.')
hm2VpnCertificateNoConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2VpnCertificateNoConnections.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateNoConnections.setDescription('Number of active connections that use this certificate. The certificate cannot be deleted from the device unless there are no active connections using it (this field is set to 0).')
hm2VpnCertificateUserActions = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 120, 1, 4, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2VpnCertificateUserActions.setStatus('current')
if mibBuilder.loadTexts: hm2VpnCertificateUserActions.setDescription('Provides a way to delete unused certificate files from the device. A certificate can only be deleted if there are no active connections using it (see hm2VpnCertificateNoConnections). Deleting a Peer certificate automatically deletes the private key asociated with it (if any).')
hm2VpnMibSNMPExtensionNoTrafficSelector = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120, 3, 1))
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionNoTrafficSelector.setStatus('current')
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionNoTrafficSelector.setDescription('Indicates that for a VPN connection no active traffic selectors are available.')
hm2VpnMibSNMPExtensionTooManyActive = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120, 3, 2))
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionTooManyActive.setStatus('current')
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionTooManyActive.setDescription('Indicates that too many VPN connections are in active state.')
hm2VpnMibSNMPExtensionTooManyConns = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120, 3, 3))
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionTooManyConns.setStatus('current')
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionTooManyConns.setDescription('Indicates that too many VPN connections shall be added to the configuration.')
hm2VpnMibSNMPExtensionActiveRow = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120, 3, 4))
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionActiveRow.setStatus('current')
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionActiveRow.setDescription('Indicates that an active row shall be changed.')
hm2VpnMibSNMPExtensionInitiatorAny = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 120, 3, 5))
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionInitiatorAny.setStatus('current')
if mibBuilder.loadTexts: hm2VpnMibSNMPExtensionInitiatorAny.setDescription('Indicates that for a VPN connection as initiator the remote end point is set to any.')
hm2VpnUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 120, 0, 1)).setObjects(("HM2-VPN-MIB", "hm2VpnConnIndex"), ("HM2-VPN-MIB", "hm2VpnConnOperStatus"))
if mibBuilder.loadTexts: hm2VpnUpTrap.setStatus('current')
if mibBuilder.loadTexts: hm2VpnUpTrap.setDescription("A hm2VpnUpTrap trap signals that a VPN connection is about to enter the up state from some other state (see 'hm2VpnConnOperStatus').")
hm2VpnDownTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 120, 0, 2)).setObjects(("HM2-VPN-MIB", "hm2VpnConnIndex"), ("HM2-VPN-MIB", "hm2VpnConnOperStatus"))
if mibBuilder.loadTexts: hm2VpnDownTrap.setStatus('current')
if mibBuilder.loadTexts: hm2VpnDownTrap.setDescription("A hm2VpnDownTrap trap signals that a VPN connection is about to enter the down state from some other state (see 'hm2VpnConnOperStatus').")
mibBuilder.exportSymbols("HM2-VPN-MIB", hm2VpnConnDebug=hm2VpnConnDebug, hm2VpnConnIkeAuthRemType=hm2VpnConnIkeAuthRemType, hm2VpnCertificateStartDate=hm2VpnCertificateStartDate, hm2VpnConnInfoIKEReauth=hm2VpnConnInfoIKEReauth, hm2VpnConnIkeAuthCertLocal=hm2VpnConnIkeAuthCertLocal, hm2VpnConnIkeRemoteAddr=hm2VpnConnIkeRemoteAddr, hm2VpnCertificateIndex=hm2VpnCertificateIndex, hm2VpnConnIkeStartup=hm2VpnConnIkeStartup, hm2VpnTrafficSelSrcRest=hm2VpnTrafficSelSrcRest, hm2VpnCertificateType=hm2VpnCertificateType, hm2VpnConnActiveMax=hm2VpnConnActiveMax, hm2VpnConnIpsecAlgDh=hm2VpnConnIpsecAlgDh, hm2VpnConnIkeAlgDh=hm2VpnConnIkeAlgDh, hm2VpnTrafficSelEntry=hm2VpnTrafficSelEntry, PYSNMP_MODULE_ID=hm2VpnMib, hm2VpnConnNext=hm2VpnConnNext, hm2VpnTrafficSelGroup=hm2VpnTrafficSelGroup, hm2VpnMibSNMPExtensionTooManyActive=hm2VpnMibSNMPExtensionTooManyActive, hm2VpnConnIkeLifetime=hm2VpnConnIkeLifetime, hm2VpnConnIkeAuthCertRemote=hm2VpnConnIkeAuthCertRemote, hm2VpnConnMargintime=hm2VpnConnMargintime, hm2VpnConnInfoIpsecOutPackets=hm2VpnConnInfoIpsecOutPackets, hm2VpnUpTrap=hm2VpnUpTrap, hm2VpnConnIkeAuthLocId=hm2VpnConnIkeAuthLocId, hm2VpnConnInfoIkeProposal=hm2VpnConnInfoIkeProposal, hm2VpnConnIkeAuthLocType=hm2VpnConnIkeAuthLocType, hm2VpnGeneralGroup=hm2VpnGeneralGroup, hm2VpnCertificateGroup=hm2VpnCertificateGroup, hm2VpnCertificatePrivateKeyFile=hm2VpnCertificatePrivateKeyFile, hm2VpnConnLastError=hm2VpnConnLastError, hm2VpnTrafficSelRowStatus=hm2VpnTrafficSelRowStatus, hm2VpnConnIkeAuthPrivKey=hm2VpnConnIkeAuthPrivKey, hm2VpnTrafficSelDstRest=hm2VpnTrafficSelDstRest, hm2VpnConnInfoIpsecInPackets=hm2VpnConnInfoIpsecInPackets, hm2VpnConnInfoIpsecOutUse=hm2VpnConnInfoIpsecOutUse, hm2VpnMibSNMPExtensionActiveRow=hm2VpnMibSNMPExtensionActiveRow, hm2VpnConnInfoIpsecInSPI=hm2VpnConnInfoIpsecInSPI, hm2VpnMib=hm2VpnMib, hm2VpnConnIkeAuthRemId=hm2VpnConnIkeAuthRemId, hm2VpnConnIkeVersion=hm2VpnConnIkeVersion, hm2VpnConnIkeReAuth=hm2VpnConnIkeReAuth, hm2VpnConnInfoEntry=hm2VpnConnInfoEntry, hm2VpnCertificateEndDate=hm2VpnCertificateEndDate, hm2VpnConnIpsecAlgMac=hm2VpnConnIpsecAlgMac, hm2VpnMibSNMPExtensionTooManyConns=hm2VpnMibSNMPExtensionTooManyConns, hm2VpnCertificateCertUploadDate=hm2VpnCertificateCertUploadDate, hm2VpnConnIkeAuthPasswd=hm2VpnConnIkeAuthPasswd, hm2VpnConnInfoEstablished=hm2VpnConnInfoEstablished, hm2VpnConnIkeDpdTimeout=hm2VpnConnIkeDpdTimeout, hm2VpnTrafficSelDesc=hm2VpnTrafficSelDesc, hm2VpnConnIkeAuthCertCA=hm2VpnConnIkeAuthCertCA, hm2VpnConnInfoIpsecInUse=hm2VpnConnInfoIpsecInUse, hm2VpnConnInfoIKERekeying=hm2VpnConnInfoIKERekeying, hm2VpnCertificatePrivateKeyStatus=hm2VpnCertificatePrivateKeyStatus, hm2VpnCertificateTable=hm2VpnCertificateTable, hm2VpnMibSNMPExtensionNoTrafficSelector=hm2VpnMibSNMPExtensionNoTrafficSelector, hm2VpnCertificateUserActions=hm2VpnCertificateUserActions, hm2VpnConnIkeAuthPsk=hm2VpnConnIkeAuthPsk, hm2VpnConnInfoRemoteHost=hm2VpnConnInfoRemoteHost, hm2VpnMibSNMPExtensionInitiatorAny=hm2VpnMibSNMPExtensionInitiatorAny, hm2VpnConnIkeLocalAddr=hm2VpnConnIkeLocalAddr, hm2VpnConnOperStatus=hm2VpnConnOperStatus, hm2VpnMibSNMPExtensionGroup=hm2VpnMibSNMPExtensionGroup, hm2VpnCertificateFileName=hm2VpnCertificateFileName, hm2VpnConnMax=hm2VpnConnMax, hm2VpnConnInfoIKEInitiatorSPI=hm2VpnConnInfoIKEInitiatorSPI, hm2VpnConnectionGroup=hm2VpnConnectionGroup, hm2VpnCertificateSubject=hm2VpnCertificateSubject, hm2VpnTrafficSelDstAddr=hm2VpnTrafficSelDstAddr, hm2VpnConnInfoIKEResponderSPI=hm2VpnConnInfoIKEResponderSPI, hm2VpnConnIpsecLifetime=hm2VpnConnIpsecLifetime, hm2VpnTrafficSelTable=hm2VpnTrafficSelTable, hm2VpnConnInfoIpsecRekeying=hm2VpnConnInfoIpsecRekeying, hm2VpnConnIkeAlgEncr=hm2VpnConnIkeAlgEncr, hm2VpnTrafficSelSrcAddr=hm2VpnTrafficSelSrcAddr, hm2VpnCertificateIssuer=hm2VpnCertificateIssuer, hm2VpnMibObjects=hm2VpnMibObjects, hm2VpnConnIpsecMode=hm2VpnConnIpsecMode, hm2VpnConnInfoIpsecProposal=hm2VpnConnInfoIpsecProposal, hm2VpnConnRowStatus=hm2VpnConnRowStatus, hm2VpnConnIpsecAlgEncr=hm2VpnConnIpsecAlgEncr, hm2VpnConnInfoIpsecInBytes=hm2VpnConnInfoIpsecInBytes, hm2VpnConnIkeAlgMac=hm2VpnConnIkeAlgMac, hm2VpnCertificateUploadPassphrase=hm2VpnCertificateUploadPassphrase, hm2VpnConnInfoTable=hm2VpnConnInfoTable, hm2VpnDownTrap=hm2VpnDownTrap, hm2VpnConnInfoIkeVersionUsed=hm2VpnConnInfoIkeVersionUsed, hm2VpnConnInfoIpsecOutBytes=hm2VpnConnInfoIpsecOutBytes, hm2VpnConnIndex=hm2VpnConnIndex, hm2VpnCertificateNoConnections=hm2VpnCertificateNoConnections, hm2VpnConnEntry=hm2VpnConnEntry, hm2VpnConnDesc=hm2VpnConnDesc, hm2VpnMibNotifications=hm2VpnMibNotifications, hm2VpnConnIkeAuthType=hm2VpnConnIkeAuthType, hm2VpnConnTable=hm2VpnConnTable, hm2VpnConnIkeAuthMode=hm2VpnConnIkeAuthMode, hm2VpnTrafficSelIndex=hm2VpnTrafficSelIndex, hm2VpnConnInfoLocalHost=hm2VpnConnInfoLocalHost, hm2VpnCertificateEntry=hm2VpnCertificateEntry, hm2VpnConnInfoIpsecOutSPI=hm2VpnConnInfoIpsecOutSPI)

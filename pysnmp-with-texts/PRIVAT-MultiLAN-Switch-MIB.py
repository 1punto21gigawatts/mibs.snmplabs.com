#
# PySNMP MIB module PRIVAT-MultiLAN-Switch-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PRIVAT-MultiLAN-Switch-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Bits, Gauge32, NotificationType, Unsigned32, iso, IpAddress, ModuleIdentity, ObjectIdentity, Integer32, NotificationType, Counter64, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Bits", "Gauge32", "NotificationType", "Unsigned32", "iso", "IpAddress", "ModuleIdentity", "ObjectIdentity", "Integer32", "NotificationType", "Counter64", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
hirschmann = MibIdentifier((1, 3, 6, 1, 4, 1, 248))
multiLANSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2))
bridge1 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1))
bridgemgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1))
hirmaMibhHandler = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 2))
hirmaUserInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 3))
hirmaBasCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1))
hirmaSelfTestCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2))
hirmaFilterCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3))
hirmaAddrBTCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 4))
hirmaLoadCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5))
hirmaFlashUpdate = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 1))
hirmaLoadSaveConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 2))
hirmaBasBridgeTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1))
hirmaBasBridgeGroupCapacity = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeGroupCapacity.setDescription('The number of slots of the MultiLAN Switch.')
hirmaBasBridgeGroupMap = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeGroupMap.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeGroupMap.setDescription('This Bitfield represents the current Interface card configuration. The least significant bit indicates the left slot with the number 1. Each interface card (group) of the MultiLAN Switch is represented by a single bit. The value of a bit=1 indicates that the group is present.')
hirmaBasBridgeSoftVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeSoftVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeSoftVersion.setDescription('A string that contains information about the software release currently in use')
hirmaBasBridgeHardVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeHardVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeHardVersion.setDescription('A string that contains information about the underlying hardware')
hirmaBasBridgeMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeMibVersion.setDescription('A string that contains information about the current private MIB release')
hirmaBasBridgeSpanningTreeVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeSpanningTreeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeSpanningTreeVersion.setDescription('A string that contains information about the current Spanning Tree Version.')
hirmaBasBridgeSwitches = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeSwitches.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeSwitches.setDescription('State of the DIP-switches on the memoryboard (EBGM). The DIP-switches are defined as follows: switch | on | off ------------------------------------------------- 1 | service | normal 2 | service | normal 3 | relay on | relay off 4 | LANswitch | 802.3 Bridge 5 | service | normal 6 | Spanning Tree on | Spanning Tree off 7 | Filtering on | Filtering off 8 | Learning on | Learning off')
hirmaBasBridgePwrSplyState = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ok", 1), ("error5V1", 2), ("error5V2", 3), ("error5V1and5V2", 4), ("error5V3", 5), ("error5V1and5V3", 6), ("error5V2and5v3", 7), ("error5v1and5v2and5v3", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgePwrSplyState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgePwrSplyState.setDescription('Used to indicate the state of the power supplies. 5V1 corresponds to the first power supply on the left side, etc.')
hirmaBasBridgeFanState = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("nofunction", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeFanState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeFanState.setDescription('Used to indicate the fan state. If one of the two fans rotating speed is under value, hirmaBasBridgeFanState will change to nofunction (2).')
hirmaBasBridgePwrAlarm = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasBridgePwrAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgePwrAlarm.setDescription('If enabled (1), the health-trap will be sent in case of a power supply failure.')
hirmaBasBridgeHealthAlarm = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasBridgeHealthAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeHealthAlarm.setDescription('If enabled (1), the health-trap will be sent in case of any kind of failure. Sending of a health-trap in case of a power supply can not be disabled by this attribute (use hirmaBasBridgePwrAlarms instead).')
hirmaBasBridgeSpanningTree = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasBridgeSpanningTree.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeSpanningTree.setDescription('Used to indicate and set the state of the spanning tree mode. Note: Setting this variable to enabled (1), enables also the learning and the filtering mode. Setting this variable to disabled (2), disables only the spanning tree mode.')
hirmaBasBridgeHealthState = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("generalFailure", 3), ("multiLANSwitchFailure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeHealthState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeHealthState.setDescription('The BridgeHealthState indicates the operational state of the MultiLAN Switch. The BridgeHealthData and BridgeHealthText may be consulted for more specific information about this state.')
hirmaBasBridgeHealthText = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeHealthText.setDescription('The BridgeHealthText provides information relevant to the operational state of the MultiLAN Switch.')
hirmaBasBridgeHealthData = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeHealthData.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeHealthData.setDescription('The BridgeHealthData is a block of data octets that provides information relevant to the operational state of the MultiLAN Switch.')
hirmaBasBridgeCounterReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("no-reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasBridgeCounterReset.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeCounterReset.setDescription('Resets all non port related counters of the MultiLAN Switch. Note: Setting this variable to noReset (2) has no effect. The agent will always return the value noReset (2) in response to a GetRequest.')
hirmaBasBridgeEventTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2), )
if mibBuilder.loadTexts: hirmaBasBridgeEventTable.setStatus('mandatory')
hirmaBasBridgeEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaBasBridgeMessageID"))
if mibBuilder.loadTexts: hirmaBasBridgeEventEntry.setStatus('mandatory')
hirmaBasBridgeMessageID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeMessageID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeMessageID.setDescription('Used to uniquely identify messages within this table. Note: This table is as a ring buffer, a new entry in the table may overwrite the oldest message in the table.')
hirmaBasBridgeMessageIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeMessageIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeMessageIfIndex.setDescription('Used to uniquely identify the interface where the event has appeared. ')
hirmaBasBridgeMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeMessage.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeMessage.setDescription('This object shows the message code according to the following table. 1) error message Code |Display| Description *********************************************** 0x45:0f | O | buffer overflow 0x45:91 | O | buffer overflow recovered 0x45:b3 | S | no carrier sense response 0x48:f6 | V | redundant power supply error 0x01:4f | A-a | shut-down TFTP transmission 0x81:a2 | A-b | TFTP transmission error 0x01:64 | A-t | TFTP transmission time out 0x01:65 | A-u | no TFTP server attached | C-g | TCP communication problemes | C-n | all TCP-devices are busy | C-r | TCP rexmit timeout probleme 0x05:a5 | E-e | inaccessible transmission 0x05:88 | E-h | wrong LAN-controller state 0x05:ac | E-l | late collision detection 0x05:ad | E-m | too many collisions 0x05:b6 | E-u | internal transmission error 0x05:b8 | E-x | shut-down transmission 0x06:a1 | F-a | address table overflow 0x07:ce | F-b | inaccessible address table 0x06:a6 | F-f | type field table overflow 0x06:ad | F-m | rejected management packet (rx) 0x06:af | F-o | filter table overflow 0x06:b3 | F-s | filter table overflow 0x08:d7 | H-w | watchdog time out 0x09:89 | I-i | missing IP-address 0x09:8e | I-n | no response with RARP | O-b | TCP buffer overflow | O-f | no TCP connection | O-k | TCP transmission error | O-n | disabled TCP device | S-c | wrong INI-file 2) fatal error messages Code |Display| Errorcode *********************************************** 0x85:84 | E-d | LAN-controller test failed 0x85:87 | E-g | LAN-controller disabled 0x85:94 | E-t | LAN-controller error 0x88:8a | H-j | wrong master or malfunction 0x88:8d | H-m | no attached master 0x88:90 | H-p | processor test failed 0x8d:87 | M-g | global memory test failed 0x8d:8c | M-l | local memory test failed 0x8d:92 | M-r | ROM checksum test failed')
hirmaBasBridgeMessageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasBridgeMessageTime.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasBridgeMessageTime.setDescription('The value of sysUpTime when the message has occured. The time unit is tens of milliseconds.')
hirmaBasGroupTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3), )
if mibBuilder.loadTexts: hirmaBasGroupTable.setStatus('mandatory')
hirmaBasGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaBasGroupID"))
if mibBuilder.loadTexts: hirmaBasGroupEntry.setStatus('mandatory')
hirmaBasGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasGroupID.setDescription('Used to uniquely identify an interface card within the MultiLAN Switch.')
hirmaBasGroupNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasGroupNumOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasGroupNumOfPorts.setDescription('Number of ports of the associated interface card.')
hirmaBasGroupPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasGroupPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasGroupPortMap.setDescription("Used to uniquely map interface numbers and interface card numbers. Both, interfaces and interface cards are numbered within a range of 1 to the maximum number of interface cards, where the interface card list may contain holes in case that an interface card is not present. E.g. this value may contain '6', which indicates that this port of this interface card is currently handled as interface number 6. In case of multiple interfaces (ports) per interface card, the numbers are separated with a comma (e.g. '5,6').")
hirmaBasGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasGroupName.setDescription('Name of the interface cards. E.g : EBAUI, EBTP ...')
hirmaBasPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4), )
if mibBuilder.loadTexts: hirmaBasPortTable.setStatus('mandatory')
hirmaBasPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaBasPortID"))
if mibBuilder.loadTexts: hirmaBasPortEntry.setStatus('mandatory')
hirmaBasPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortID.setDescription('Used to uniquely identify an interface (port) within the MultiLAN Switch. Note: The interfaces (ports) are numbered in ascending order from the left side to the right side, within a range of 1 to n.')
hirmaBasPortGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortGroupID.setDescription('Used to identify the associated interface card.')
hirmaBasPortLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("fddi", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortLanType.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortLanType.setDescription('Used to identify different LAN types.')
hirmaBasPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("aui", 1), ("optical-asynch-850", 2), ("optical-asynch-1300-16", 3), ("optical-asynch-1300-40", 4), ("unshielded-TP-10BaseT", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortType.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortType.setDescription('Used to identify the physical media type of the interface card ')
hirmaBasPortShortDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ieee802-3", 1), ("ethernet-switch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasPortShortDelay.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortShortDelay.setDescription('Used to change the operation mode between ethernet switching and 802.3 CSMA/CD.')
hirmaBasPortLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasPortLearning.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortLearning.setDescription('Used to indicate whether the learning mode of this port is enabled or disabled. Note: The learning mode may only be disabled (2) if the spanning tree mode is disabled.')
hirmaBasPortFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasPortFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortFiltering.setDescription('Used to indicate whether the filtering mode of this port is enabled or disabled. Note: The filtering mode may only be disabled (2) if the spanning tree mode is disabled.')
hirmaBasPortRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasPortRelay.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortRelay.setDescription('If enabled (1), all packets will be forwarded. Otherwise only packets with known addresses will be forwarded.')
hirmaBasPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half-duplex", 1), ("full-duplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortMode.setDescription('Indicates the transmission mode of the interface card. This mode can be adjusted by a jumper on the interface card ')
hirmaBasPortCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("no-reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaBasPortCounterReset.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortCounterReset.setDescription('Resets all port related counters. Note: Setting this variable to no reset (2) has no effect. The agent will always return the value no-reset (2) in response to a GetRequest.')
hirmaBasPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 1, 4, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaBasPortState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaBasPortState.setDescription('Indicates the operational state of the port such as -normal-, -carrier sense-, -jabber-, -idle-, etc.')
hirmaSelfTestBridgeReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("no-reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaSelfTestBridgeReset.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestBridgeReset.setDescription('Setting this value to reset (1), forces the MultiLAN Switch to reset according to the type in hirmaSelfTestBridgeResetType.')
hirmaSelfTestBridgeResetType = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("warm-start", 1), ("cold-start", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaSelfTestBridgeResetType.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestBridgeResetType.setDescription('Type of resetwhich will be executed if hirmaSelfTestBridgeReset will be set to reset.')
hirmaSelfTestBridgeSetDefaults = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("no-reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaSelfTestBridgeSetDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestBridgeSetDefaults.setDescription('Resets all parameters to the default value. Just like after a cold-start.')
hirmaSelfTestGroupTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 4), )
if mibBuilder.loadTexts: hirmaSelfTestGroupTable.setStatus('mandatory')
hirmaSelfTestGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 4, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaSelfTestGroupID"))
if mibBuilder.loadTexts: hirmaSelfTestGroupEntry.setStatus('mandatory')
hirmaSelfTestGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaSelfTestGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestGroupID.setDescription('Used to uniquely identify a interface card.')
hirmaSelfTestGroupDisplayTest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("test", 1), ("no-test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaSelfTestGroupDisplayTest.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestGroupDisplayTest.setDescription('Starts the internal display test.')
hirmaSelfTestGroupSQETest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled-ok", 1), ("disabled", 2), ("not-ok", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaSelfTestGroupSQETest.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaSelfTestGroupSQETest.setDescription('Reading this value will offer the state of the SQE test. SQE test may be enabled by setting this object to enabled (1). Detecting a SQE test problem will change the value to not-ok (3).')
hirmaFilterMaxNumOfFilters = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaFilterMaxNumOfFilters.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterMaxNumOfFilters.setDescription('Number of filters in the following table.')
hirmaFilterTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2), )
if mibBuilder.loadTexts: hirmaFilterTable.setStatus('mandatory')
hirmaFilterTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaFilterID"))
if mibBuilder.loadTexts: hirmaFilterTableEntry.setStatus('mandatory')
hirmaFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaFilterID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterID.setDescription('Used to uniquely identify an extended filter. The filter ID ranges between 1 and hirmaFilterMaxNumOfFilters. Caution: Throughput rate will decrease the more extended filters are used.')
hirmaFilterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("forward", 1), ("disable", 2), ("discard", 3), ("alone", 4), ("channel", 5), ("delete", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterMode.setDescription('Setting this variable to forward (1), will forward all packets that match on a single filter. Setting this variable to discard (3), will discard all packets that match on a single filter. Setting this variable to disable (2), will only forward or discard packets according to the learning tables. Setting this variable to alone (4), the packets are filtered with the private filter (forward) and than filtered with the normaly filter. Setting this variable to channel (5), between the ports hirmaFilterPortIn and hirmaFilterPortOut exists a channel. Setting this variable to delete (6), the filter entry will be deleted from the filter structure. Note: One single filter is defined as a set of hirmaFilterDest, hirmaFilterSrc, hirmaFilterType and hirmaFilterPortIn, where each entry may also be left unused. Forward on match will forward all packets to the specified output port(s). Discard on match will discard all packets regardless to any specified output port(s).')
hirmaFilterDest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterDest.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterDest.setDescription('This display string identifies the MAC address(es) for a single or a set of destination adress filters. For example; 00:80:63:01:02:03-00:80:63:04:05:06 defines a set of MAC addresses as a destination address filter. 00:80:63:01:02:03 defines particularly one MAC destination address filter. Set an empty string to delete the previously defined address. Note: The maximum range runs from XX:XX:XX:00:00:00 to XX:XX:XX:FF:FF:FF. Setting of larger ranges will be ignored.')
hirmaFilterSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterSrc.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterSrc.setDescription('This display string identifies the MAC address(es) for a single or a set of source address filters. For example; 00:80:63:01:02:03-00:80:63:04:05:06 defines a set of MAC addresses as a source address filter. 00:80:63:01:02:03 defines particularly one MAC source adress filter. Set an empty string to delete the previously defined address. Note: The maximum range runs from XX:XX:XX:00:00:00 to XX:XX:XX:FF:FF:FF. Setting of larger ranges will be ignored.')
hirmaFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterType.setDescription('This display string represents a single or a set of protocol types . For example; 8001-8006 defines a set of protocol types filter 8063 defines particularly one protocol types filter Set an empty string to delete the previously defined type. Note: The maximum range runs from XX00 to XXFF. Setting of larger ranges will be ignored. Example of protocols: type 2 bytes | protocols ****************************************** 809B | AppleTalk 6007 | DEC LAVC, SCA 0800 | DoD IP 0803 | ECMA Internet 00FE | ISO DIS 8473 (LSAP) 0003 | LLC (Group) Sublayer Mgmt. 814C | SNMP -------------------------------------------- 6000-6009 | 10 DEC protocols Set an empty string to delete the previously defined type. Note: The maximum range runs from XXX0 to XXXF. Setting of larger ranges will be ignored.')
hirmaFilterPortIn = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterPortIn.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterPortIn.setDescription('Input ports, separated by commas. For example; 1,2,5,6 means, that only packets received on these 4 ports match this filter. Set an empty string to delete the previously defined ports.')
hirmaFilterPortOut = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 3, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFilterPortOut.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFilterPortOut.setDescription('Output ports, separated by commas. For example; 1,2,5,6 means, that matching packets will be forwarded to these 4 ports. Set an empty string to delete the previously defined ports')
hirmaAddrBTAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 4, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaAddrBTAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaAddrBTAddr.setDescription('All following addresses excluding this address will be listed. In general the last address of the previous block is used as the starting address of the next block. The address 00:00:00:00:00:00 is the start address to get the first block.')
hirmaAddrBTBlock = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 4, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaAddrBTBlock.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaAddrBTBlock.setDescription('Offers a block of address information. This list of the address entries is not lexicographically ordered. Byte (n*10) m | State **************************************** Byte m=0 | reserved Byte m=1 | Bit 0..2; 4 | reserved Bit 3 | MultiLAN Switch MAC address Bit 5 | static, entered by mgmt Bit 6 | aged out Bit 7 | valid Byte m=2 | interface card, where the | address appeared. Byte m=3 | reserved Byte m=4..m=9 | MAC address Where n is the number of address entries. So, each address block is aligned to n*10 Bytes.')
hirmaFlashUpdateIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFlashUpdateIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFlashUpdateIPAddr.setDescription('The IP-address of the update-server.')
hirmaFlashUpdateName = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFlashUpdateName.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFlashUpdateName.setDescription('This string contains the full pathname and name of the update file.')
hirmaFlashUpdateAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("program", 1), ("normal-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaFlashUpdateAction.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaFlashUpdateAction.setDescription('Setting this variable to program will force the MultiLAN Switch to run a software update defined by the update file in hirmaFlashUpdateName and the update server defined in hirmaFlashUpdateIPAddr. Note: Setting this variable to normal mode (2) has no effect. The agent will always return normal mode (2) in response to a GetRequest.')
hirmaLoadSaveConIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLoadSaveConIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLoadSaveConIPAddr.setDescription('Tree different values are possible: 1: 0.0.0.0 will cause the MultiLAN Switch to set all read/write attributes to a default value in case of warm/cold start. 2: Setting this value to the IP address of the MultiLAN Switch will cause the Switch in case of a warm/cold start to load the configuration from the flash eprom which has been previously saved into the flash eprom by issueing a Set request to hirmaLoadSaveConAction.0 = 3. 3: The address of an existing tftp server, where to read a configuration file from in case of a Set request hirmaLoadSaveConAction.0 = 1 or a warm/cold start.')
hirmaLoadSaveConName = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLoadSaveConName.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLoadSaveConName.setDescription('This string contains the full pathname and name of the configuration file.')
hirmaLoadSaveConAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 1, 5, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("load", 1), ("normal-mode", 2), ("save", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLoadSaveConAction.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLoadSaveConAction.setDescription('Setting this attribute to 1 (load) will cause the Switch to read a configuration file from a tftp server in case that an existing tftp server is given by hirmaLoadSaveConIPAddr. See the description of hirmaLoadSaveConIPAdd for more details. 3 (save) will cause the Switch to save all read/write attributes in the flash eprom. Setting this variable to normal mode (2) has no effect. The agent will always return the value normal-mode (2) in response to a GetRequest.')
hirmaMibhCommTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 1), )
if mibBuilder.loadTexts: hirmaMibhCommTable.setStatus('mandatory')
hirmaMibhCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 1, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhCommIndex"))
if mibBuilder.loadTexts: hirmaMibhCommEntry.setStatus('mandatory')
hirmaMibhCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhCommIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhCommIndex.setDescription('Used to uniquely identify an object in the table.')
hirmaMibhCommCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaMibhCommCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhCommCommunity.setDescription('Community string which the access rights are assigned to. New communities may be defined by setting community string to any non-empty string. Use an empty string to delete table entries.')
hirmaMibhCommAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-accesible", 1), ("read-only", 2), ("read-write", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaMibhCommAccess.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhCommAccess.setDescription('Access rights of the community. Warning: If you set the access rights of all non-trap communities to read-only you will not be able to write any MIB variable. If you set the access rights of all communities that contain this MIB attribute to read-only, you will not be able to modify any access rights later.')
hirmaMibhAccessTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2), )
if mibBuilder.loadTexts: hirmaMibhAccessTable.setStatus('mandatory')
hirmaMibhAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhAccessCommIndex"), (0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhAccessIPAddr"), (0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhAccessPort"))
if mibBuilder.loadTexts: hirmaMibhAccessEntry.setStatus('mandatory')
hirmaMibhAccessCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhAccessCommIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessCommIndex.setDescription('Index variable, must reference a valid entry in hirmaMibhCommTable.')
hirmaMibhAccessIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhAccessIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessIPAddr.setDescription("Entity's IP address. For example 0.0.0.0 means any IP address.")
hirmaMibhAccessPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhAccessPort.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessPort.setDescription("Entity's UDP port.")
hirmaMibhAccessCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhAccessCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessCommunity.setDescription('Community string referenced by hirmaMibhAccessCommIndex. This variable is supplied for convenience only.')
hirmaMibhAccessAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("read-only", 1), ("read-write", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaMibhAccessAccess.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessAccess.setDescription("Access rights assigned to this entity. As an extension to the SNMP standard, it is possible to reduce the access rights granted by a given SNMP community profile for any host, but it is not possible to extend access rights beyond those specified by mibhCommAccess. Note: On creation, this value defaults to the corresponding hirmaMibhCommAccess instance. Don't write to this attribute if full conformance to the standard is desired.")
hirmaMibhAccessState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("deleted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaMibhAccessState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhAccessState.setDescription('Setting a non-existent instance to enabled (1), will create a new instance in this table. Note: An entry may be temporarily suspended by setting state to disabled (2). To permanently remove an entry from the database, set state to deleted (3).')
hirmaMibhTrapTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3), )
if mibBuilder.loadTexts: hirmaMibhTrapTable.setStatus('mandatory')
hirmaMibhTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhTrapCommIndex"), (0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhTrapIPAddr"), (0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaMibhTrapPort"))
if mibBuilder.loadTexts: hirmaMibhTrapEntry.setStatus('mandatory')
hirmaMibhTrapCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhTrapCommIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhTrapCommIndex.setDescription('Index variable, must reference a valid entry in hirmaMibhCommTable.')
hirmaMibhTrapIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhTrapIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhTrapIPAddr.setDescription('Destination IP address.')
hirmaMibhTrapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhTrapPort.setDescription('Destination UDP port. This must be set to 162 by default because the management system will listen to this UDP port for traps.')
hirmaMibhTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaMibhTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhTrapCommunity.setDescription('Community string referenced by hirmaMibhTrapCommIndex. This variable is supplied for convenience only.')
hirmaMibhTrapState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("deleted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaMibhTrapState.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaMibhTrapState.setDescription('Setting a non-existent instance to enabled (1), will create a new trap entry in this table. Note: An entry may be temporarily suspended by setting state to disabled (2). To permanently remove an entry from the database, set state to deleted (3).')
hirmaLuiSystemTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 1))
hirmaLuiLocalIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiLocalIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiLocalIPAddr.setDescription('IP address of MultiLAN Switch.')
hirmaLuiGatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiGatewayIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiGatewayIPAddr.setDescription('IP address of a gateway (router) needed to reach a server.')
hirmaLuiNetMask = MibScalar((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiNetMask.setDescription('Subnetmask of the subnet.')
hirmaLuiUserTable = MibTable((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2), )
if mibBuilder.loadTexts: hirmaLuiUserTable.setStatus('mandatory')
hirmaLuiUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2, 1), ).setIndexNames((0, "PRIVAT-MultiLAN-Switch-MIB", "hirmaLuiUserID"))
if mibBuilder.loadTexts: hirmaLuiUserEntry.setStatus('mandatory')
hirmaLuiUserID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hirmaLuiUserID.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiUserID.setDescription('Table index variable')
hirmaLuiUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiUserName.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiUserName.setDescription('Userspecific Identification')
hirmaLuiUserPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiUserPasswd.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiUserPasswd.setDescription('password of a specific user')
hirmaLuiUserCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 2, 1, 3, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hirmaLuiUserCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hirmaLuiUserCommunity.setDescription('access-rights of the user')
bridgeHealth = NotificationType((1, 3, 6, 1, 4, 1, 248, 2, 1) + (0,1)).setObjects(("PRIVAT-MultiLAN-Switch-MIB", "hirmaBasBridgeHealthState"))
if mibBuilder.loadTexts: bridgeHealth.setDescription(' The hirmaBridgeHealth trap information relates to the operational state of the MultiLAN Switch. This trap is sent only when the health state of the MultiLAN Switch changes. The hirmaBridgeHealth trap must contain the hirmaBasBridgeHealthState variable. The MultiLANSwitch optionally includes hirmaBasBridgeHealthText and hirmaBasBridgeHealthData in the varBind list. See hirmaBasHubHealthState, hirmaBasHubHealthText and hirmaBasHubHealthData objects for descriptions of the information that are sent.')
mibBuilder.exportSymbols("PRIVAT-MultiLAN-Switch-MIB", hirmaSelfTestGroupID=hirmaSelfTestGroupID, hirmaBasGroupName=hirmaBasGroupName, hirmaBasPortState=hirmaBasPortState, hirmaMibhAccessCommIndex=hirmaMibhAccessCommIndex, hirmaMibhHandler=hirmaMibhHandler, hirmaBasPortLanType=hirmaBasPortLanType, hirmaLuiUserEntry=hirmaLuiUserEntry, hirmaFilterCapability=hirmaFilterCapability, hirmaMibhAccessEntry=hirmaMibhAccessEntry, hirmaMibhTrapCommIndex=hirmaMibhTrapCommIndex, hirmaBasBridgeHealthData=hirmaBasBridgeHealthData, hirmaBasGroupNumOfPorts=hirmaBasGroupNumOfPorts, hirmaMibhAccessState=hirmaMibhAccessState, hirmaBasBridgeMessageIfIndex=hirmaBasBridgeMessageIfIndex, hirmaAddrBTCapability=hirmaAddrBTCapability, hirmaFilterMode=hirmaFilterMode, hirschmann=hirschmann, hirmaMibhCommAccess=hirmaMibhCommAccess, hirmaBasBridgeHardVersion=hirmaBasBridgeHardVersion, bridge1=bridge1, hirmaBasBridgeEventEntry=hirmaBasBridgeEventEntry, hirmaLuiUserCommunity=hirmaLuiUserCommunity, hirmaFilterType=hirmaFilterType, hirmaFilterPortOut=hirmaFilterPortOut, hirmaFilterMaxNumOfFilters=hirmaFilterMaxNumOfFilters, hirmaBasBridgeTable=hirmaBasBridgeTable, hirmaBasBridgeMessageID=hirmaBasBridgeMessageID, hirmaBasBridgePwrAlarm=hirmaBasBridgePwrAlarm, hirmaLuiSystemTable=hirmaLuiSystemTable, hirmaMibhCommCommunity=hirmaMibhCommCommunity, hirmaLuiUserTable=hirmaLuiUserTable, hirmaBasBridgeSoftVersion=hirmaBasBridgeSoftVersion, hirmaMibhTrapState=hirmaMibhTrapState, private=private, enterprises=enterprises, hirmaBasGroupEntry=hirmaBasGroupEntry, hirmaBasPortLearning=hirmaBasPortLearning, hirmaFlashUpdateName=hirmaFlashUpdateName, hirmaLoadSaveConfig=hirmaLoadSaveConfig, hirmaBasPortShortDelay=hirmaBasPortShortDelay, hirmaBasPortID=hirmaBasPortID, hirmaMibhCommTable=hirmaMibhCommTable, hirmaBasPortMode=hirmaBasPortMode, hirmaMibhTrapPort=hirmaMibhTrapPort, hirmaSelfTestGroupTable=hirmaSelfTestGroupTable, bridgemgmt=bridgemgmt, hirmaAddrBTAddr=hirmaAddrBTAddr, hirmaBasPortFiltering=hirmaBasPortFiltering, hirmaSelfTestGroupEntry=hirmaSelfTestGroupEntry, hirmaSelfTestCapability=hirmaSelfTestCapability, hirmaBasPortCounterReset=hirmaBasPortCounterReset, MacAddress=MacAddress, hirmaLoadSaveConName=hirmaLoadSaveConName, hirmaFilterPortIn=hirmaFilterPortIn, hirmaFlashUpdateIPAddr=hirmaFlashUpdateIPAddr, hirmaMibhTrapIPAddr=hirmaMibhTrapIPAddr, hirmaMibhAccessPort=hirmaMibhAccessPort, bridgeHealth=bridgeHealth, hirmaBasPortGroupID=hirmaBasPortGroupID, hirmaBasBridgeHealthAlarm=hirmaBasBridgeHealthAlarm, hirmaMibhAccessTable=hirmaMibhAccessTable, hirmaFilterTableEntry=hirmaFilterTableEntry, hirmaBasBridgeEventTable=hirmaBasBridgeEventTable, hirmaFlashUpdateAction=hirmaFlashUpdateAction, hirmaBasGroupID=hirmaBasGroupID, hirmaLuiLocalIPAddr=hirmaLuiLocalIPAddr, hirmaBasBridgeFanState=hirmaBasBridgeFanState, hirmaLuiUserPasswd=hirmaLuiUserPasswd, hirmaBasBridgeHealthState=hirmaBasBridgeHealthState, hirmaBasBridgeGroupCapacity=hirmaBasBridgeGroupCapacity, hirmaBasPortRelay=hirmaBasPortRelay, hirmaMibhTrapTable=hirmaMibhTrapTable, hirmaFilterTable=hirmaFilterTable, hirmaLoadSaveConIPAddr=hirmaLoadSaveConIPAddr, hirmaLuiNetMask=hirmaLuiNetMask, hirmaBasPortType=hirmaBasPortType, hirmaFilterSrc=hirmaFilterSrc, hirmaAddrBTBlock=hirmaAddrBTBlock, hirmaSelfTestGroupSQETest=hirmaSelfTestGroupSQETest, hirmaBasBridgeSpanningTree=hirmaBasBridgeSpanningTree, hirmaSelfTestBridgeResetType=hirmaSelfTestBridgeResetType, hirmaFilterDest=hirmaFilterDest, hirmaMibhCommIndex=hirmaMibhCommIndex, hirmaBasBridgeSpanningTreeVersion=hirmaBasBridgeSpanningTreeVersion, hirmaFilterID=hirmaFilterID, hirmaMibhAccessAccess=hirmaMibhAccessAccess, hirmaLuiUserName=hirmaLuiUserName, hirmaMibhCommEntry=hirmaMibhCommEntry, hirmaSelfTestBridgeReset=hirmaSelfTestBridgeReset, hirmaBasBridgePwrSplyState=hirmaBasBridgePwrSplyState, hirmaBasPortEntry=hirmaBasPortEntry, hirmaLoadSaveConAction=hirmaLoadSaveConAction, hirmaBasBridgeGroupMap=hirmaBasBridgeGroupMap, hirmaBasBridgeCounterReset=hirmaBasBridgeCounterReset, hirmaMibhAccessCommunity=hirmaMibhAccessCommunity, hirmaMibhAccessIPAddr=hirmaMibhAccessIPAddr, multiLANSwitch=multiLANSwitch, hirmaUserInterface=hirmaUserInterface, hirmaBasGroupTable=hirmaBasGroupTable, hirmaSelfTestBridgeSetDefaults=hirmaSelfTestBridgeSetDefaults, hirmaMibhTrapEntry=hirmaMibhTrapEntry, hirmaBasBridgeMibVersion=hirmaBasBridgeMibVersion, hirmaLuiUserID=hirmaLuiUserID, hirmaBasBridgeMessageTime=hirmaBasBridgeMessageTime, hirmaMibhTrapCommunity=hirmaMibhTrapCommunity, hirmaBasBridgeHealthText=hirmaBasBridgeHealthText, hirmaLoadCapability=hirmaLoadCapability, hirmaBasBridgeMessage=hirmaBasBridgeMessage, hirmaBasBridgeSwitches=hirmaBasBridgeSwitches, hirmaBasPortTable=hirmaBasPortTable, hirmaLuiGatewayIPAddr=hirmaLuiGatewayIPAddr, hirmaFlashUpdate=hirmaFlashUpdate, hirmaBasGroupPortMap=hirmaBasGroupPortMap, hirmaBasCapability=hirmaBasCapability, hirmaSelfTestGroupDisplayTest=hirmaSelfTestGroupDisplayTest)

#
# PySNMP MIB module LUMINOUS-TOPOLOGY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LUMINOUS-TOPOLOGY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:09:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, Integer32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ModuleIdentity, TimeTicks, iso, Unsigned32, MibIdentifier, NotificationType, ObjectIdentity, enterprises, Counter32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Integer32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ModuleIdentity", "TimeTicks", "iso", "Unsigned32", "MibIdentifier", "NotificationType", "ObjectIdentity", "enterprises", "Counter32", "IpAddress")
DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention")
luminous = MibIdentifier((1, 3, 6, 1, 4, 1, 4614))
lumADM = MibIdentifier((1, 3, 6, 1, 4, 1, 4614, 1))
lumTopologyMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 4614, 1, 3))
if mibBuilder.loadTexts: lumTopologyMIB.setLastUpdated('0003080000Z')
if mibBuilder.loadTexts: lumTopologyMIB.setOrganization('Luminous Networks')
if mibBuilder.loadTexts: lumTopologyMIB.setContactInfo(' Luminous Technical Support Postal: Luminous Networks, 14060 Bubb Road, Cupertino, CA 95014 Tel: +1 408 342 6400 Fax: +1 408 863 1100 E-mail: support@lumnet.com Authors: Jason Fan, Nick Gandin Tel: +1 408 342 6431 +1 408 342 6417 E-mail: jason@lumnet.com nick@lumnet.com')
if mibBuilder.loadTexts: lumTopologyMIB.setDescription('The Luminous Topology MIB contains information related to the Luminous Ring Topology.')
lumRingCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1))
lumTopoDiscoveryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1))
lumTopoDiscoveryRetries = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 1), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumTopoDiscoveryRetries.setStatus('current')
if mibBuilder.loadTexts: lumTopoDiscoveryRetries.setDescription('Initially set to 3.')
lumTopoNeighborInfoTimer = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumTopoNeighborInfoTimer.setStatus('current')
if mibBuilder.loadTexts: lumTopoNeighborInfoTimer.setDescription('The Neighbor Information Timer sets the amount of time between periodic sends of the neighbor information message from each node on each egress link.')
lumTopoDiscoveryConvergenceTimer = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumTopoDiscoveryConvergenceTimer.setStatus('current')
if mibBuilder.loadTexts: lumTopoDiscoveryConvergenceTimer.setDescription('The topology convergence timer sets the amount of time during which no messages indicating a change of topology have been received before the topology can be considered to have converged. If the topology convergence timer has not reached the required value for convergence, the topology discovery timer is reset.')
lumTopoDiscoveryTimer = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumTopoDiscoveryTimer.setStatus('current')
if mibBuilder.loadTexts: lumTopoDiscoveryTimer.setDescription('The topology discovery timer sets the total amount of time until the topology convergence timer is checked. If the topology convergence timer has not reached the required value for convergence, the topology discovery timer is reset.')
lumTopoDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("doDiscover", 2), ("stopDiscover", 3), ("discoveryFailed", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumTopoDiscovery.setStatus('current')
if mibBuilder.loadTexts: lumTopoDiscovery.setDescription('Setting this field to doDiscover(2) has the effect of starting the Ring Topology Discovery. The Retries and Timers in the fields above in order for them to have effect should be set before attempting to start discovery. Upon Discovery completion this field is set by the SNMP Agent to either none(1) or ,if failed to discoveryFailed(4). stopDiscovery(3) is for the future. Setting to discoveryFailed(4) is not allowed by SNMP Agent. discoveryFailed(4) can be also the outcome of topology discovery performed by the ring management without NMS requesting it.')
lumTopoDiscoveryFailedNode = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumTopoDiscoveryFailedNode.setStatus('current')
if mibBuilder.loadTexts: lumTopoDiscoveryFailedNode.setDescription('The node that causes the the Topology Discovery failure. Valid only if lumTopoDiscovery is discoveryFailed(4).')
lumRingCommand = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clearAll", 2), ("lockoutOfProtection", 3), ("commandFailed", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumRingCommand.setStatus('current')
if mibBuilder.loadTexts: lumRingCommand.setDescription('Setting this field to clearAll(2) has the effect of clearing all lumLinkAdminStatus (setting it to 0). This clears all externally initiated commands. Setting this field to lockoutOfProtection(3) results in all traffic on the ring returning to the shortest-hop available path. This sets all LinkAdminStatus values to 16000 (standard operational link). Setting this field to switchToRevertiveMode(4), has the effect of switching from non-revertive mode to revertive mode fot the whole ring. commandFailed(5) cannot be set. The lumRingCommand is set to this value by SNMP Agent when requested command fails.')
lumRingRevertiveMode = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("revertiveMode", 1), ("nonRevertiveMode", 2))).clone('nonRevertiveMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumRingRevertiveMode.setStatus('current')
if mibBuilder.loadTexts: lumRingRevertiveMode.setDescription('Setting this field to revertiveMode(1), has the effect of switching from non-revertive mode to revertive mode for the whole ring. Likewise setting this field to nonRevertiveMode(2), has the effect of switching from revertive mode to non-revertive mode fot the whole ring.')
lumProtectionSwitchHysteresis = MibScalar((1, 3, 6, 1, 4, 1, 4614, 1, 3, 1, 4), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtectionSwitchHysteresis.setStatus('current')
if mibBuilder.loadTexts: lumProtectionSwitchHysteresis.setDescription("Hysteresis factor. This factor prevents ping-ponging in protection switching when a link's measured status is varying with time. Valid values are between 5 and 100.")
lumProtectionSwitchingTable = MibTable((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2), )
if mibBuilder.loadTexts: lumProtectionSwitchingTable.setStatus('current')
if mibBuilder.loadTexts: lumProtectionSwitchingTable.setDescription('The Luminous Protection Switching Table.')
lumProtectionSwitchingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1), ).setIndexNames((0, "LUMINOUS-TOPOLOGY-MIB", "lumProtDestinationIP"))
if mibBuilder.loadTexts: lumProtectionSwitchingEntry.setStatus('current')
if mibBuilder.loadTexts: lumProtectionSwitchingEntry.setDescription('Each entry represents connection information of current node to other nodes on the ring.')
lumProtDestinationIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtDestinationIP.setStatus('current')
if mibBuilder.loadTexts: lumProtDestinationIP.setDescription('This is the address of the destination node.')
lumProtMeasDestCost = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtMeasDestCost.setStatus('current')
if mibBuilder.loadTexts: lumProtMeasDestCost.setDescription('This is the cumulative measured cost per destination for each egress interface of a node.')
lumProtNonRevDestCost = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtNonRevDestCost.setStatus('current')
if mibBuilder.loadTexts: lumProtNonRevDestCost.setDescription('This is the non-revertive cost per destination for each egress interface of a node. This is used only for non-revertive protection switching.')
lumProtMeasPrefDir = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtMeasPrefDir.setStatus('current')
if mibBuilder.loadTexts: lumProtMeasPrefDir.setDescription('This is the interface number corresponding to the preferred direction for data from this node to lumProtDestinationIP based on measured costs.')
lumProtNonRevPrefDir = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumProtNonRevPrefDir.setStatus('current')
if mibBuilder.loadTexts: lumProtNonRevPrefDir.setDescription('This is the interface number corresponding to the preferred direction for data from this node to lumProtDestinationIP based on non-revertive costs.')
lumRingLinkTable = MibTable((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3), )
if mibBuilder.loadTexts: lumRingLinkTable.setStatus('current')
if mibBuilder.loadTexts: lumRingLinkTable.setDescription('The Luminous Ring Topology Table.')
lumRingLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1), ).setIndexNames((0, "LUMINOUS-TOPOLOGY-MIB", "lumLinkIngressNodeIP"), (0, "LUMINOUS-TOPOLOGY-MIB", "lumLinkEgressNodeIP"), (0, "LUMINOUS-TOPOLOGY-MIB", "lumLinkIngressInterface"), (0, "LUMINOUS-TOPOLOGY-MIB", "lumLinkEgressInterface"))
if mibBuilder.loadTexts: lumRingLinkEntry.setStatus('current')
if mibBuilder.loadTexts: lumRingLinkEntry.setDescription('Each entry represents connection information of every ingress to every ingress node on the ring')
lumLinkIngressNodeIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkIngressNodeIP.setStatus('current')
if mibBuilder.loadTexts: lumLinkIngressNodeIP.setDescription('This is the address of the ingress link node.')
lumLinkEgressNodeIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkEgressNodeIP.setStatus('current')
if mibBuilder.loadTexts: lumLinkEgressNodeIP.setDescription('This is the address of the egress link node.')
lumLinkIngressInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkIngressInterface.setStatus('current')
if mibBuilder.loadTexts: lumLinkIngressInterface.setDescription('This is the interface number (slot number) of the ring transition card connected to the link at the ingress node.')
lumLinkEgressInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkEgressInterface.setStatus('current')
if mibBuilder.loadTexts: lumLinkEgressInterface.setDescription('This is the interface number (slot number) of the ring transition card connected to the link at the egress node.')
lumLinkOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkOperStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkOperStatus.setDescription('This is the latest measured operational status of the link. It is reported from the ring applications to the shelf manager to the NMS. Currently, traffic congestion is not taken into account in status computations. A bit error rate of a * 10 ^ (-b), where a is greater or equal to 1 and less than 10 and has 3 significant digits, is represented to NMS as 1000*b + 100*(10 - a). The minimum value of lumLinkOperStatus is 1000 to show that the link is down, and the maximum value of lumLinkOperStatus is 16000 to show a standard operational link.')
lumLinkNonRevStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkNonRevStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkNonRevStatus.setDescription('This is the minimum value of link operational status reported since the last Revert-To-Measured-Oper-Status command from the NMS. This field is used only for non-revertive protection switching, e.g. lumLinkNonRevStatus will differ from lumLinkOperStatus if a link goes down and then comes back up, since the operator must reactivate a link under such conditions. For revertive protection switching, this field is equal to lumLinkOperStatus. This value is set by the ring applications and reported to EMS via the shelf manager.')
lumLinkAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumLinkAdminStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkAdminStatus.setDescription("This is the latest administrative status of the link set by the operator. It is reported to the ring applications via the shelf manager. There are several options for this field. If the value of lumLinkAdminStatus is set to 0 by the operator, it is ignored by the ring applications, e.g. the ring applications use lumLinkOperStatus and lumLinkAdminStatus for all decision- making. If lumLinkAdminStatus is set to a valid lumLinkOperStatus value by the operator, the link is considered to have that bit error rate irrespective of the actual lumLinkOperStatus value. It is expected that the 'a' value of BER need only have one significant digit when entered by the operator.")
lumLinkSyncOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkSyncOperStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkSyncOperStatus.setDescription('This is a single indicator of whether a link is an active part of a synchronization path. This value is set by the ring itself and reported to NMS.')
lumLinkSyncNonRevStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lumLinkSyncNonRevStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkSyncNonRevStatus.setDescription('.')
lumLinkSyncAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumLinkSyncAdminStatus.setStatus('current')
if mibBuilder.loadTexts: lumLinkSyncAdminStatus.setDescription('This is the latest administrative status of the link for synchronization set by the operator. It is to be set by NMS.')
lumRingThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 4614, 1, 3, 4), )
if mibBuilder.loadTexts: lumRingThresholdTable.setStatus('current')
if mibBuilder.loadTexts: lumRingThresholdTable.setDescription('The Luminous Ring Threshold Table.')
lumRingThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4614, 1, 3, 4, 1), ).setIndexNames((0, "LUMINOUS-TOPOLOGY-MIB", "lumRingThresholdWindow"))
if mibBuilder.loadTexts: lumRingThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: lumRingThresholdEntry.setDescription('Each entry represents threshold values per threshold window on the ring.')
lumRingThresholdWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumRingThresholdWindow.setStatus('current')
if mibBuilder.loadTexts: lumRingThresholdWindow.setDescription('This is the threshold window size.')
lumRingThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumRingThresholdValue.setStatus('current')
if mibBuilder.loadTexts: lumRingThresholdValue.setDescription('This is the threshold value for this window.')
lumRingThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4614, 1, 3, 4, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lumRingThresholdStatus.setStatus('current')
if mibBuilder.loadTexts: lumRingThresholdStatus.setDescription('This object is used to create and delete rows in the Threshold Table.')
mibBuilder.exportSymbols("LUMINOUS-TOPOLOGY-MIB", lumTopoDiscoveryGroup=lumTopoDiscoveryGroup, lumRingThresholdValue=lumRingThresholdValue, lumTopoDiscoveryConvergenceTimer=lumTopoDiscoveryConvergenceTimer, lumRingCommand=lumRingCommand, lumLinkAdminStatus=lumLinkAdminStatus, lumProtectionSwitchingEntry=lumProtectionSwitchingEntry, lumProtectionSwitchHysteresis=lumProtectionSwitchHysteresis, lumLinkEgressNodeIP=lumLinkEgressNodeIP, lumLinkNonRevStatus=lumLinkNonRevStatus, lumProtectionSwitchingTable=lumProtectionSwitchingTable, lumTopoDiscoveryTimer=lumTopoDiscoveryTimer, lumADM=lumADM, lumLinkSyncNonRevStatus=lumLinkSyncNonRevStatus, lumRingRevertiveMode=lumRingRevertiveMode, lumRingCommands=lumRingCommands, lumRingLinkEntry=lumRingLinkEntry, lumLinkSyncOperStatus=lumLinkSyncOperStatus, lumRingThresholdEntry=lumRingThresholdEntry, lumLinkIngressInterface=lumLinkIngressInterface, lumTopoDiscoveryRetries=lumTopoDiscoveryRetries, lumTopologyMIB=lumTopologyMIB, lumProtNonRevDestCost=lumProtNonRevDestCost, PYSNMP_MODULE_ID=lumTopologyMIB, lumProtMeasDestCost=lumProtMeasDestCost, lumTopoNeighborInfoTimer=lumTopoNeighborInfoTimer, lumProtMeasPrefDir=lumProtMeasPrefDir, lumRingThresholdTable=lumRingThresholdTable, luminous=luminous, lumTopoDiscovery=lumTopoDiscovery, lumProtDestinationIP=lumProtDestinationIP, lumLinkSyncAdminStatus=lumLinkSyncAdminStatus, lumTopoDiscoveryFailedNode=lumTopoDiscoveryFailedNode, lumLinkOperStatus=lumLinkOperStatus, lumRingLinkTable=lumRingLinkTable, lumLinkIngressNodeIP=lumLinkIngressNodeIP, lumLinkEgressInterface=lumLinkEgressInterface, lumProtNonRevPrefDir=lumProtNonRevPrefDir, lumRingThresholdStatus=lumRingThresholdStatus, lumRingThresholdWindow=lumRingThresholdWindow)

#
# PySNMP MIB module SNMP553S-MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SNMP553S-MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:08:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
dsx1, = mibBuilder.importSymbols("GDCDSX1-MIB", "dsx1")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, iso, TimeTicks, Integer32, ModuleIdentity, Counter32, IpAddress, MibIdentifier, Unsigned32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "iso", "TimeTicks", "Integer32", "ModuleIdentity", "Counter32", "IpAddress", "MibIdentifier", "Unsigned32", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
snmp553s = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3))
snmp553sc = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 4))
snmp553sAlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1))
snmp553sNoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 1))
snmp553sDiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 2))
snmp553sPowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 3))
snmp553sNvRamCorrupt = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 4))
snmp553sUnitFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 5))
snmp553sMbiLock = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 6))
snmp553sLocalPwrFail = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 7))
snmp553sTimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 8))
snmp553sStatusChange = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 9))
snmp553sUnsoTest = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 10))
snmp553sLossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 11))
snmp553sLossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 12))
snmp553sAis = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 13))
snmp553sReceivedYellow = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 14))
snmp553sUnavailSignalState = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 15))
snmp553sExcessiveZeros = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 16))
snmp553sLowAverageDensity = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 17))
snmp553sControlledSlips = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 18))
snmp553sBipolarViolations = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 19))
snmp553sCrcErrors = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 3, 1, 20))
snmp553sMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sMIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
snmp553sMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 3), )
if mibBuilder.loadTexts: snmp553sMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sMaintenanceTable.setDescription('The SNMP553S Maintenance table. This table augments the Gdc Dsx1 maintenance table, providing maintenance functions specific to the 553S.')
snmp553sMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sMaintenanceIndex"))
if mibBuilder.loadTexts: snmp553sMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sMaintenanceEntry.setDescription('The SNMP553S Maintenance table entry.')
snmp553sMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sMaintenanceIndex.setDescription('The index value which uniquely identifies the 553S to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the 553S with sub-identifier value set to unit(1).')
snmp553sCascadePresent = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sCascadePresent.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sCascadePresent.setDescription('Identifies whether or not the cascade interface cards are installed.')
snmp553sExtModemPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sExtModemPresent.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sExtModemPresent.setDescription('Identifies whether or not an external modem is attached to the modem ppp interface.')
snmp553sUnitType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sUnitType.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sUnitType.setDescription("Identifies the GDC Netcon position of the unit. The value master(1) indicates that the NMS unit is configured as a Netcon Master, whereby diagnostic management information is received through a local Netcon port. The value remote(2) indicates that the unit is configured as a Netcon remote, whereby diagnostic management information is received through it's network interface or through an out of band (modem) link.")
snmp553sManagementSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("modemSnmp", 1), ("secondaryChannel", 2), ("fdl", 3), ("daisyChain", 4), ("bus485", 5), ("localSnmp", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sManagementSource.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sManagementSource.setDescription('Identifies the management data source. The value modemSnmp(1) indicates that the management source is SNMP via an dial-up ppp link. The value secondaryChannel(2)indicates that the management source is via an inband Diagnostics communications channel. The value fdl(3) indicates that the management source is via the out-of-band facilities data link. The value daisyChain(4) indicates that the management source via the NETCON master-in port. The value bus485(5) indicates that the management source is via the shelf commander in the Universal Systems Shelf. The value localSnmp(6) indicates that the management source is SNMP via a locap ppp link.')
snmp553sProductType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("snmp553sd1ifp", 1), ("snmp553sd3ifp", 2), ("snmp553scifp", 3), ("nms553d1", 4), ("nms553d1ifp", 5), ("nms553d3ifp", 6), ("nms553c", 7), ("nms553cifp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sProductType.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sProductType.setDescription('Indicates the product type of the unit.')
snmp553sLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sLedStatus.setDescription("Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - DSX1 bit 4 - NMSRSP (nms553 products) or MGMT DATA (553s products) bit 3 - NMSDAT (nms553 products) or MGMT RESP (553s products) bit 2 - ER bit 1 - DSX OOF bit 0 - DSX LOS Octet 2 bit 7 - not used bit 6 - NET OOF bit 5 - NET LOS bit 4 - NET BPV bit 3 - NET AIS bit 2 - TM/ALM bit 1 - LBK bit 0 - future use Octet 3 bit 7 - not used bit 6 - CHA SD ==> 553D1 and 553D3 only bit 5 - CHA RD ==> '' bit 4 - CHB SD ==> 553D3 only bit 3 - CHB RD ==> '' bit 2 - CHC SD ==> '' bit 1 - CHC RD ==> '' bit 0 - future use. Note: The value returned for all Channel SD and RD leds is unreliable when the unit is performing DSU level self-tests and loopbacks.")
snmp553sUnitSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sUnitSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sUnitSerialNumber.setDescription("This object returns the GDC 8-byte unit serial number in 16 nibbles. Each device has a unique serial number of the form: 00xx0pmmddyy#### where xx = Product type: 26 - NMS553C products 27 - NMS553D products 43 - 553SD products 44 - 553SC products p = Source of Software 1 - Software programmed by manufacturing ' 9 - Software programmed by engineering mm = Month of manufacture dd = Day of manufacture yy = Year of manufacture #### = Daily manufacturing sequence number.")
snmp553sSaveAllConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("saveConfig", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sSaveAllConfig.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sSaveAllConfig.setDescription('Commands unit to save 553S CSU and DSU configuration variables in non-volatile memory and configure the unit as defined. When CSU and DSU configuration variables are modified they are not updated in the 553S hardware until a SaveConfig command is received via this object. When this value is set to SaveConfig(2) the current 553S csu and dsu configuration variables become active within the unit. The value of normal(1) will be returned when the initialization is complete. The value normal(1) cannot be set by management.')
snmp553sUnitConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 4), )
if mibBuilder.loadTexts: snmp553sUnitConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sUnitConfigTable.setDescription('The SNMP553S Unit Configuration table. This table augments the GDC dsx1 configuration table, providing additional unit level configuration specific to the 553s.')
snmp553sUnitConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sUnitConfigIndex"))
if mibBuilder.loadTexts: snmp553sUnitConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sUnitConfigEntry.setDescription('The SNMP553S Unit Configuration table entry.')
snmp553sUnitConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sUnitConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sUnitConfigIndex.setDescription('The index value which uniquely identifies the SNMP553S to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of 553S with a sub-identifier value of unit(1).')
snmp553sSaveCsuConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("saveConfig", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sSaveCsuConfig.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sSaveCsuConfig.setDescription('Commands unit to save 553S CSU configuration variables in non-volatile memory and configure the unit as defined. When CSU configuration variables are modified they are not updated in the 553S hardware until a SaveConfig command is received via this object. When this value is set to SaveConfig(2) the current 553S csu configuration variables become active within the unit. The value of normal(1) will be returned when the initialization is complete. The value normal(1) cannot be set by management.')
snmp553sShelfCommander = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sShelfCommander.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sShelfCommander.setDescription('Identifies the 553s unit as the shelf commander in a Datacomm 4-pak or Universal Systems Shelf. When configured as the shelf commander, the unit passes the SNMP diagnostics information using the Netcon protocol to other units in the shelf via the RS485 bus.')
snmp553sForceFakeMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sForceFakeMaster.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sForceFakeMaster.setDescription('Forces the 553s as a Netcon Master unit. This option allows a unit without a master-in connection to a netcon controller behave as a Netcon master for configuring diagnostics on downstream (remote) units.')
snmp553sDaisyChainBps = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bps75", 2), ("bps9600", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sDaisyChainBps.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDaisyChainBps.setDescription('Indicates the data rate at which a remote unit will propogate NMS commands out of a daisy chain connection. None(1) indicates that no outbound daisy chain exists on this unit.')
snmp553sChannelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 5), )
if mibBuilder.loadTexts: snmp553sChannelConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sChannelConfigTable.setDescription('The SNMP553S Channel Configuration table. This table augments the GDC dsu Channel Configuration table, providing additional unit level configuration specific to the 553s.')
snmp553sChannelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 5, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sChannelConfigIndex"))
if mibBuilder.loadTexts: snmp553sChannelConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sChannelConfigEntry.setDescription('The SNMP553S Channel Configuration table entry.')
snmp553sChannelConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sChannelConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sChannelConfigIndex.setDescription('The index value which uniquely identifies the 553S to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and channel of the 553S.')
snmp553sDCCCompatibilityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nms553", 1), ("nms510", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sDCCCompatibilityMode.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDCCCompatibilityMode.setDescription('Identifies the 553S DCC mode. The value nms553(1) indicates that the inband link is communicating with an NMS553 remote. The value nms510(2) indicates that the inband link is communicating with an NMS510 remote. This object works with with snmp553sUnitType; it can never be set to nms510(2) unless snmp553sUnitType is master(1). The value other(3) indicates that the compatibility mode has been specified elsewhere. This value can never be set by management operation.')
snmp553sSaveDsuConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("saveConfig", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sSaveDsuConfig.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sSaveDsuConfig.setDescription('Commands unit to save 553S channel configuration variables in non-volatile memory and configure the unit as defined. When DSU configuration variables are modified they are not updated in the 553S hardware until a SaveConfig command is received via this object. When this value is set to SaveConfig(2) the current 553S dsu configuration variables become active within the unit. The value of normal(1) will be returned when the initialization is complete. The value normal(1) cannot be set by management.')
snmp553sDiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 6), )
if mibBuilder.loadTexts: snmp553sDiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDiagTable.setDescription('The 553S Diagnostics table. This table augments the GDC dsx1 Diagnostics table and the GDC dsu diagnostics table.')
snmp553sDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 6, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sDiagIndex"))
if mibBuilder.loadTexts: snmp553sDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDiagEntry.setDescription('The SNMP553S Diagnostics table entry.')
snmp553sDiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sDiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDiagIndex.setDescription('The index value which uniquely identifies the 553S to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the 553S with a sub-identifier value of unit(1).')
snmp553sDiagTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLimit", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("testTime30Secs", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sDiagTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDiagTestDuration.setDescription('Selects the duration to run a diagnostic test, in time. The value(1) noLimit indicates that the test should run until explicitly terminated. The default value is noLimit(1). This object is used for all tests defined in both the GDC dsx1 mib and the GDC dsu mib.')
snmp553sDiagProgPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sDiagProgPattern.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sDiagProgPattern.setDescription('The 16 bit user programmable test pattern. This object works with the gdcDsx1SendCode object in that when gdcDsx1SendCode is set to sendProgPattern(4), the the value of this object is used as the 16 bit user programmable test pattern. This object is used for all tests defined in both the GDC dsx1 mib.')
snmp553sAlarmHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 7), )
if mibBuilder.loadTexts: snmp553sAlarmHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmHistoryTable.setDescription('The snmp553sAlarmHistoryTable contains entries that report the history of all supported alarms. The history consists of the the number of times the alarm has occurred since last history reset, the time of the first alarm occurence (hours,minutes, seconds,day,month,year), and the time of the last alarm occurrence (hours,minutes,seconds,day,month,year). The structure of the table is such that alarm status is supported on a unit or interface basis, and then on an alarm type basis within the interface. For simplicity sake and to support the reporting of status of all alarms, a unit is treated as an interface 1 in this table.')
snmp553sAlarmHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sAlarmHistoryIndex"), (0, "SNMP553S-MGMT-MIB", "snmp553sAlarmHistoryIdentifier"))
if mibBuilder.loadTexts: snmp553sAlarmHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmHistoryEntry.setDescription('An entry in the GDC SNMP553S Alarm History table.')
snmp553sAlarmHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmHistoryIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
snmp553sAlarmHistoryIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmHistoryIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmHistoryIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
snmp553sAlarmCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmCount.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmCount.setDescription('The number of occurrences of this alarm. This objects value is incremented once for each time that the alarm occurs. This count is incremented regardless of whether or not the alarm is masked or is not reporteded because of the threshold configuration.')
snmp553sAlarmFirstOccurrenceHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceHours.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceHours.setDescription('The hour (0-23) the alarm first occurred.')
snmp553sAlarmFirstOccurrenceMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceMinutes.setDescription('The minute (0-59) the alarm first occurred.')
snmp553sAlarmFirstOccurrenceSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceSeconds.setDescription('The second (0-59) the alarm first occurred.')
snmp553sAlarmFirstOccurrenceMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceMonth.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceMonth.setDescription('The month (1-12) the alarm first occurred.')
snmp553sAlarmFirstOccurrenceDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceDay.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceDay.setDescription('The day (1-31) the alarm first occurred.')
snmp553sAlarmFirstOccurrenceYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceYear.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmFirstOccurrenceYear.setDescription('The year (0-99) the alarm first occurred.')
snmp553sAlarmLastOccurrenceHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceHours.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceHours.setDescription('The hour (0-23) the alarm last occurred.')
snmp553sAlarmLastOccurrenceMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceMinutes.setDescription('The minute (0-59) the alarm last occurred.')
snmp553sAlarmLastOccurrenceSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceSeconds.setDescription('The second (0-59) the alarm last occurred.')
snmp553sAlarmLastOccurrenceMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceMonth.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceMonth.setDescription('The month (1-12) the alarm last occurred.')
snmp553sAlarmLastOccurrenceDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceDay.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceDay.setDescription('The day (1-31) the alarm last occurred.')
snmp553sAlarmLastOccurrenceYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 7, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceYear.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmLastOccurrenceYear.setDescription('The year (0-99) the alarm last occurred.')
snmp553sAlarmMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 3, 8), )
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceTable.setDescription('The snmp553sAlarmMaintenanceTable contains entries that configure the real time clock and that clear the alarm history table.')
snmp553sAlarmMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1), ).setIndexNames((0, "SNMP553S-MGMT-MIB", "snmp553sAlarmMaintenanceIndex"))
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceEntry.setDescription('An entry in the GDC snmp553s Alarm Maintenance Table.')
snmp553sAlarmMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sAlarmMaintenanceIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
snmp553sClearAlarmHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sClearAlarmHistory.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sClearAlarmHistory.setDescription('Supports the action of clearing the alarm history table. When this object is set to clear(1), then the unit clears the alarm history table. The value of norm(2) will be returned when the clear is complete. The value of norm(2) can not be set by management.')
snmp553sRTCHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCHours.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCHours.setDescription('The hour of day (0-23) to be set or read.')
snmp553sRTCMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCMinutes.setDescription('The minute of the hour (0-59) to be set or read.')
snmp553sRTCSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCSeconds.setDescription('The second of the minute (0-59) to be set or read.')
snmp553sRTCMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCMonth.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCMonth.setDescription('The month of the year (1-12) to be set or read.')
snmp553sRTCDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCDay.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCDay.setDescription('The day of the month (1-31) to be set or read.')
snmp553sRTCYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmp553sRTCYear.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sRTCYear.setDescription('The year (0-99) to be set or read.')
snmp553sTimeOfLastAlarmClear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 3, 8, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmp553sTimeOfLastAlarmClear.setStatus('mandatory')
if mibBuilder.loadTexts: snmp553sTimeOfLastAlarmClear.setDescription('Returns the time (hours,minutes,seconds,month,day,year) of the last alarm clear command sent to the unit. Octet 1 - Hour of last alarm clear (0-23) Octet 2 - Minute of last alarm clear (0-59) Octet 3 - Second of last alarm clear (0-59) Octet 4 - Month of last alarm clear (1-12) Octet 5 - Day of last alarm clear (1-31) Octet 6 - Year of last alarm clear (0-99).')
mibBuilder.exportSymbols("SNMP553S-MGMT-MIB", snmp553sDiagProgPattern=snmp553sDiagProgPattern, snmp553sExtModemPresent=snmp553sExtModemPresent, snmp553sAlarmHistoryIndex=snmp553sAlarmHistoryIndex, snmp553sDiagTestDuration=snmp553sDiagTestDuration, snmp553sForceFakeMaster=snmp553sForceFakeMaster, snmp553sAlarmHistoryTable=snmp553sAlarmHistoryTable, snmp553sAlarmFirstOccurrenceSeconds=snmp553sAlarmFirstOccurrenceSeconds, snmp553sAlarmHistoryEntry=snmp553sAlarmHistoryEntry, snmp553sDiagRxErrAlm=snmp553sDiagRxErrAlm, snmp553sRTCDay=snmp553sRTCDay, snmp553sLocalPwrFail=snmp553sLocalPwrFail, snmp553sCascadePresent=snmp553sCascadePresent, snmp553sAlarmData=snmp553sAlarmData, snmp553sManagementSource=snmp553sManagementSource, snmp553sDaisyChainBps=snmp553sDaisyChainBps, snmp553sAlarmLastOccurrenceYear=snmp553sAlarmLastOccurrenceYear, snmp553sSaveCsuConfig=snmp553sSaveCsuConfig, snmp553sLedStatus=snmp553sLedStatus, snmp553sAlarmFirstOccurrenceMinutes=snmp553sAlarmFirstOccurrenceMinutes, snmp553sAlarmLastOccurrenceMonth=snmp553sAlarmLastOccurrenceMonth, snmp553sChannelConfigIndex=snmp553sChannelConfigIndex, snmp553sMIBversion=snmp553sMIBversion, snmp553sSaveAllConfig=snmp553sSaveAllConfig, snmp553sProductType=snmp553sProductType, snmp553sDiagTable=snmp553sDiagTable, snmp553sUnitFailure=snmp553sUnitFailure, snmp553s=snmp553s, snmp553sShelfCommander=snmp553sShelfCommander, snmp553sAlarmLastOccurrenceMinutes=snmp553sAlarmLastOccurrenceMinutes, snmp553sAlarmLastOccurrenceSeconds=snmp553sAlarmLastOccurrenceSeconds, snmp553sLossOfSignal=snmp553sLossOfSignal, snmp553sRTCYear=snmp553sRTCYear, snmp553sAlarmFirstOccurrenceHours=snmp553sAlarmFirstOccurrenceHours, snmp553sAlarmLastOccurrenceDay=snmp553sAlarmLastOccurrenceDay, snmp553sDCCCompatibilityMode=snmp553sDCCCompatibilityMode, snmp553sAlarmMaintenanceEntry=snmp553sAlarmMaintenanceEntry, snmp553sNvRamCorrupt=snmp553sNvRamCorrupt, snmp553sBipolarViolations=snmp553sBipolarViolations, snmp553sMaintenanceEntry=snmp553sMaintenanceEntry, snmp553sClearAlarmHistory=snmp553sClearAlarmHistory, snmp553sMaintenanceTable=snmp553sMaintenanceTable, snmp553sAlarmMaintenanceIndex=snmp553sAlarmMaintenanceIndex, snmp553sAlarmFirstOccurrenceYear=snmp553sAlarmFirstOccurrenceYear, snmp553sChannelConfigEntry=snmp553sChannelConfigEntry, snmp553sChannelConfigTable=snmp553sChannelConfigTable, snmp553sCrcErrors=snmp553sCrcErrors, snmp553sStatusChange=snmp553sStatusChange, snmp553sDiagIndex=snmp553sDiagIndex, snmp553sReceivedYellow=snmp553sReceivedYellow, snmp553sExcessiveZeros=snmp553sExcessiveZeros, snmp553sMaintenanceIndex=snmp553sMaintenanceIndex, snmp553sPowerUpAlm=snmp553sPowerUpAlm, snmp553sAlarmFirstOccurrenceMonth=snmp553sAlarmFirstOccurrenceMonth, snmp553sUnitType=snmp553sUnitType, snmp553sRTCMinutes=snmp553sRTCMinutes, snmp553sAis=snmp553sAis, snmp553sAlarmHistoryIdentifier=snmp553sAlarmHistoryIdentifier, snmp553sLossOfFrame=snmp553sLossOfFrame, snmp553sRTCMonth=snmp553sRTCMonth, snmp553sControlledSlips=snmp553sControlledSlips, snmp553sUnitConfigTable=snmp553sUnitConfigTable, snmp553sc=snmp553sc, snmp553sDiagEntry=snmp553sDiagEntry, snmp553sUnsoTest=snmp553sUnsoTest, snmp553sAlarmCount=snmp553sAlarmCount, snmp553sRTCHours=snmp553sRTCHours, snmp553sTimingLoss=snmp553sTimingLoss, snmp553sUnitConfigEntry=snmp553sUnitConfigEntry, snmp553sUnitConfigIndex=snmp553sUnitConfigIndex, snmp553sAlarmFirstOccurrenceDay=snmp553sAlarmFirstOccurrenceDay, snmp553sUnitSerialNumber=snmp553sUnitSerialNumber, snmp553sNoResponseAlm=snmp553sNoResponseAlm, snmp553sAlarmMaintenanceTable=snmp553sAlarmMaintenanceTable, snmp553sUnavailSignalState=snmp553sUnavailSignalState, snmp553sMbiLock=snmp553sMbiLock, snmp553sTimeOfLastAlarmClear=snmp553sTimeOfLastAlarmClear, snmp553sRTCSeconds=snmp553sRTCSeconds, snmp553sAlarmLastOccurrenceHours=snmp553sAlarmLastOccurrenceHours, snmp553sLowAverageDensity=snmp553sLowAverageDensity, snmp553sSaveDsuConfig=snmp553sSaveDsuConfig)

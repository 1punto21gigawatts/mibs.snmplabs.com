#
# PySNMP MIB module CISCO-IPSEC-PROVISIONING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IPSEC-PROVISIONING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
CIPsecCryptomapType, CIPsecDiffHellmanGrp, CIPsecEncapMode, CIPsecLifesize, CIPsecTunnelIdleTime, CIPsecTransform, CIPsecLifetime, CIPsecSecuritySuite, CIPsecNumCryptoMaps = mibBuilder.importSymbols("CISCO-IPSEC-TC", "CIPsecCryptomapType", "CIPsecDiffHellmanGrp", "CIPsecEncapMode", "CIPsecLifesize", "CIPsecTunnelIdleTime", "CIPsecTransform", "CIPsecLifetime", "CIPsecSecuritySuite", "CIPsecNumCryptoMaps")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Integer32, ObjectIdentity, Unsigned32, MibIdentifier, IpAddress, iso, Gauge32, ModuleIdentity, TimeTicks, NotificationType, Bits, Counter32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "ObjectIdentity", "Unsigned32", "MibIdentifier", "IpAddress", "iso", "Gauge32", "ModuleIdentity", "TimeTicks", "NotificationType", "Bits", "Counter32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "TextualConvention", "DisplayString")
ciscoIPsecProvisioningMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 431))
ciscoIPsecProvisioningMIB.setRevisions(('2005-11-02 00:00', '2005-01-25 00:00', '2004-10-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIPsecProvisioningMIB.setRevisionsDescriptions(('Updated description of objects in cipsIPsecXformSetTable and fixed typo.', 'Added new table cipsIfCryptomapSetInfoTable', 'Initial version of this module. ',))
if mibBuilder.loadTexts: ciscoIPsecProvisioningMIB.setLastUpdated('200511020000Z')
if mibBuilder.loadTexts: ciscoIPsecProvisioningMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIPsecProvisioningMIB.setContactInfo('Cisco Systems Network Management Technology Group Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-ipsecurity@cisco.com')
if mibBuilder.loadTexts: ciscoIPsecProvisioningMIB.setDescription("IPSec is the next-generation network layer crypto framework described in RFC2401-2411. This MIB defines the IPsec configurations. It may be used to view and provision IPsec-based VPNs. To create an IPsec tunnel, you need first configure Internet Key Exchange (IKE). IKE negotiates Security Associations with the peer for IPsec. To find out how to configure IKE, please see CISCO-IKE-CONFIGURATION-MIB for detail. Once you setup IKE, you will have to configure IPsec. To configure IPsec, you need perform following steps. 1. Create an IPsec transform set. A transform set describes a security protocol (AH or ESP) with its corresponding algorithms. For example, ESP with the DES cipher algorithm and HMAC-SHA for authentication. 2. Create a cryptomap and its peers. This will a) select data flows that need security processing and b) defines the policy for these flows and the crypto peer that traffic needs to go to. 3. Apply cryptomap to an interface A crypto map is applied to an egress interface. Outgoing data flows are protected by this cryptomap. Acronyms The following acronyms are used in this document: Static Cryptomap Template: A static cryptomap template (or static cryptomap) is a security template created for IPsec. A static cryptomap pulls together various parts to set up an IPsec security association which includes: - which traffic should be protected by IPsec - where IPsec protected traffic should be sent - the local address used for the the IPsec traffic - which transform sets should be applied to this traffic Dynamic Cryptomap Template: A dynamic cryptomap template (or a dynamic cryptomap) is essentially a crypto map entry without all the parameters configured. It acts as a policy template where the missing parameters are later dynamically configured (as the result of an IPsec negotiation) to match a peer's requirements. Cryptomap Set: A cryptomap set may contain multiple cryptomap templates which specify an IPsec policy. TED: Tunnel Endpoint Discovery protocol MIB Structure ------------- This MIB provides the operational information on Cisco's IPsec implementation of IPsec. This MIB delineates ISAKMP and IPsec configuration. This MIB deals only with IPsec (Phase-2) configuration. The following entities are managed: a) IPsec Global Parameters b) IPsec transform set definitions c) Cryptomap Group - Cryptomap Set Table - Cryptomap Table - CryptomapSet Transform Binding Table - CryptomapSet Peer Binding Table - CryptomapSet Interface Binding Table d) Notification Control Group e) Notifications Group ")
ciscoIPsecProvisioningMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 0))
ciscoIPsecProvisioningMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1))
ciscoIPsecProvisioningMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 2))
cipsIPsecGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 1))
cipsIPsecTransforms = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2))
cipsCryptoMapGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 3))
cipsCryptoMaps = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4))
cipsNotificationCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5))
cipsTunnelLifetime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 1, 1), CIPsecLifetime().clone(3600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsTunnelLifetime.setReference('For information on how a security association is established for an IPsec tunnel, please refer to RFC2409, section 4, paragraph 4. ')
if mibBuilder.loadTexts: cipsTunnelLifetime.setStatus('current')
if mibBuilder.loadTexts: cipsTunnelLifetime.setDescription('The default lifetime (in seconds) assigned to an IPsec tunnel as a global policy (maybe overridden in specific cryptomap definitions). ')
cipsTunnelLifesize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 1, 2), CIPsecLifesize().clone(4608000)).setUnits('KBytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsTunnelLifesize.setStatus('current')
if mibBuilder.loadTexts: cipsTunnelLifesize.setDescription('The default lifesize in KBytes assigned to an IPsec tunnel as a global policy (unless overridden in cryptomap definition). ')
cipsTunnelIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 1, 3), CIPsecTunnelIdleTime()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsTunnelIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: cipsTunnelIdleTimeout.setDescription('The number of seconds of idle time (no activity) after which an IPsec tunnel (and its parent ISAKMP SA) is to be deleted. An IPsec tunnel never times out if a value 0 is specified. ')
cipsIPsecXformSetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1), )
if mibBuilder.loadTexts: cipsIPsecXformSetTable.setStatus('current')
if mibBuilder.loadTexts: cipsIPsecXformSetTable.setDescription('This table contains the list of all the transform sets configured on the managed entity. A transform set is usually configured by a management console before a cryptomap is created. Multiple transform sets could be assigned to a cryptomap configuration. ')
cipsIPsecXformSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetName"))
if mibBuilder.loadTexts: cipsIPsecXformSetEntry.setStatus('current')
if mibBuilder.loadTexts: cipsIPsecXformSetEntry.setDescription('Each entry represents a single configured IPsec transform set. ')
cipsXformSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80)))
if mibBuilder.loadTexts: cipsXformSetName.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetName.setDescription('This object contains the name of the transform set corresponding to this conceptual row. ')
cipsXformSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsXformSetId.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetId.setDescription('This is the sequence number of the transform set that uniquely identifies the transform set. Distinct transform sets must have distinct sequence numbers. ')
cipsXformSetSuite = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 3), CIPsecSecuritySuite()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetSuite.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetSuite.setDescription('This object represents the suite of Phase-2 security protocols of this transform set. ')
cipsXformSetEncryptionXform = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 4), CIPsecTransform().clone('xformNONE')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetEncryptionXform.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetEncryptionXform.setDescription("This object represents the transform used for ESP encryption. The only values this object may assume are 'xformNONE', 'xformEspNULL', 'xformEspDES', 'xformEsp3DES', 'xformEspAES128', 'xformEspAES192', 'xformEspAES256', 'xformEspAESCtr128', 'xformEspAESCtr192', 'xformEspAESCtr256' and 'xformEspAESXCbcMac'. If the value of the corresponding instance of cipsXformSetSuite is 'suiteIntegAh', 'suiteIntegAhComp' or 'suiteOther', this object must be set to 'xformNONE'. For any other value of the corresponding instance of cipsXformSetSuite, this object must not be set to 'xformNONE'. ")
cipsXformSetIntegrityXformEsp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 5), CIPsecTransform().clone('xformNONE')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetIntegrityXformEsp.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetIntegrityXformEsp.setDescription("This object represents the transform used to implement integrity check with ESP protocol. If the value of the corresponding instance of cipsXformSetSuite is 'suiteIntegAh', 'suiteIntegAhComp' or 'suiteOther', this object must be set to 'xformNONE'. For any other value of the corresponding instance of cipsXformSetSuite, this object must not be set to 'xformNONE'. ")
cipsXformSetIntegrityXformAh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 6), CIPsecTransform().clone('xformNONE')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetIntegrityXformAh.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetIntegrityXformAh.setDescription("This object represents the transform used to implement integrity check with AH protocol. If the value of the corresponding instance of cipsXformSetSuite is neither 'suiteIntegAh' nor 'suiteIntegAhComp', this object must be set to 'xformNONE'. For any other value of the corresponding instance of cipsXformSetSuite, this object must not be set to 'xformNONE'. ")
cipsXformSetCompressionXform = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 7), CIPsecTransform().clone('xformNONE')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetCompressionXform.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetCompressionXform.setDescription("This object represents the transform used to implement packet compression. If the value of the corresponding instance of cipsXformSetSuite is 'suiteConf', 'suiteIntegEsp', 'suiteIntegAh', 'suiteConfAh', 'suiteIntegEspAhS', 'suiteConfIntegEsp', 'suiteConfIntegEspAh' or 'suiteOther', this object must be set to 'xformNONE'. For any other value of the corresponding instance of cipsXformSetSuite, this object must not be set to 'xformNONE'. ")
cipsXformSetMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 8), CIPsecEncapMode().clone('encapTunnel')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetMode.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetMode.setDescription('This object represents the encapsulation mode of the transform set. ')
cipsXformSetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsXformSetStatus.setStatus('current')
if mibBuilder.loadTexts: cipsXformSetStatus.setDescription('This object represents the status of the transform set entry. ')
cipsNumStaticCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 3, 1), CIPsecNumCryptoMaps()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumStaticCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumStaticCryptomapSets.setDescription('This object reflects the number of static cryptomap sets that are fully configured. Statically defined cryptomap sets are ones where the operator has fully specified all the parameters required to set up IPsec connections. ')
cipsNumDynamicCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 3, 2), CIPsecNumCryptoMaps()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumDynamicCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumDynamicCryptomapSets.setDescription('This object reflects the number of dynamic IPsec policy templates (called dynamic cryptomap templates) that are fully configured. ')
cipsNumTEDCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 3, 3), CIPsecNumCryptoMaps()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumTEDCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumTEDCryptomapSets.setDescription('This object reflects the number of static cryptomap sets that have at least one dynamic cryptomap template which has the Tunnel Endpoint Discovery (TED) enabled. ')
cipsStaticCryptomapSetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1), )
if mibBuilder.loadTexts: cipsStaticCryptomapSetTable.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetTable.setDescription("This read-only table contains the list of all cryptomap sets that are fully configured. The operator may include different types of cryptomaps in such a set - manual, ISAKMP or dynamic. An entry is added to (removed from) this table automatically by the agent when the first (last) 'active' entry with the corresponding cipsStaticCryptomapSetName is added to (removed from) cipsStaticCryptomapTable. ")
cipsStaticCryptomapSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetName"))
if mibBuilder.loadTexts: cipsStaticCryptomapSetEntry.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetEntry.setDescription('Each entry contains the attributes associated with a single static cryptomap set. ')
cipsStaticCryptomapSetSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetSize.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetSize.setDescription('This object reflects the total number of cryptomap templates contained in this cryptomap set. ')
cipsStaticCryptomapSetNumIsakmp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumIsakmp.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumIsakmp.setDescription('This object reflects the number of cryptomaps associated with this cryptomap set that use ISAKMP protocol to do key exchange. ')
cipsStaticCryptomapSetNumManual = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumManual.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumManual.setDescription('This object reflects the number of cryptomaps associated with this cryptomap set that require the operator to manually setup the keys and SPIs. ')
cipsStaticCryptomapSetNumDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDynamic.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDynamic.setDescription('This object reflects the number of dynamic cryptomap templates linked to this cryptomap set. ')
cipsStaticCryptomapSetNumTED = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumTED.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumTED.setDescription('This object reflects the number of dynamic cryptomap templates linked to this cryptomap set that have Tunnel Endpoint Discovery (TED) enabled. ')
cipsStaticCryptomapSetNumSAs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumSAs.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumSAs.setDescription('This object reflects the number of IPsec Security Associations that are active and were setup using this cryptomap set. ')
cipsStaticCryptomapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3), )
if mibBuilder.loadTexts: cipsStaticCryptomapTable.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapTable.setDescription('The table listing the member cryptomaps of the cryptomap sets that are configured on the managed entity. This table does not include the members of dynamic cryptomap sets that may be linked with the parent static cryptomap set. Deletion of a cipsStaticCryptomapEntry will fail if the cipsStaticCryptomapSetName this cipsStaticCryptomapEntry belongs to is referred by a cipsCryptomapSetIfEntry. ')
cipsStaticCryptomapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1), ).setIndexNames((0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetName"), (0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapPriority"))
if mibBuilder.loadTexts: cipsStaticCryptomapEntry.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapEntry.setDescription('Each entry contains the attributes associated with a single static (fully specified) cryptomap entry, identified by its priority. ')
cipsStaticCryptomapSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80)))
if mibBuilder.loadTexts: cipsStaticCryptomapSetName.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetName.setDescription('The index of the static cryptomap table. The value of the string is the name string assigned by the NMS when defining a cryptomap set. ')
cipsStaticCryptomapPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cipsStaticCryptomapPriority.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapPriority.setDescription('The priority of the cryptomap entry in the cryptomap set. A cryptomap entry with smaller cipsStaticCryptomapPriority value takes precedence over the ones with larger values. ')
cipsStaticCryptomapType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 3), CIPsecCryptomapType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapType.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapType.setDescription('The type of the cryptomap entry. This can be an ISAKMP cryptomap or manual. Dynamic cryptomaps are not counted in this table. ')
cipsStaticCryptomapDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapDescr.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapDescr.setDescription('The description string created by the SNMP agent while creating this cryptomap. The string generally identifies a description and the purpose of this policy. ')
cipsStaticCryptomapIpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapIpFilter.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapIpFilter.setDescription('This object specifies an IP protocol filter, cippfIpProfileName (defined in CISCO-IP-PROTOCOL-FILTER-MIB), to be secured using this cryptomap entry. When this object has a value of zero-length string, this object is not valid/applicable. ')
cipsStaticCryptomapXformSetList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapXformSetList.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapXformSetList.setDescription('The list of cipsXformSetId that are members of this CipsStaticCryptomapEntry. The value of this object is a concatenation of zero or more 4-octet strings, where each 4-octet string contains a 32-bit cipsXformSetId value in network byte order. A zero length string value means this list has no members. ')
cipsStaticCryptomapNumPeers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapNumPeers.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapNumPeers.setDescription('This object reflects the number of peers associated with this cryptomap entry. The other peers listed in table cipsIPsecCryMapPeerTable are backup peers. ')
cipsStaticCryotomapNextPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryotomapNextPIndex.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryotomapNextPIndex.setDescription('This object specifies the next available index for object cipsCryMapPeerIndex which can be used for creating an entry in cipsIPsecCryMapPeerTable. ')
cipsStaticCryptomapCurPAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapCurPAddrType.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapCurPAddrType.setDescription('This object represents the address type of cipsStaticCryptomapCurPAddr to which this cryptomap entry is currently connected. ')
cipsStaticCryptomapCurPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 10), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapCurPAddr.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapCurPAddr.setDescription("The IP address of the peer to which this cryptomap entry is currently connected. The value of cipsStaticCryptomapCurPAddrType is 'unknown' and this MIB object is a zero-length string when no tunnels are presently spawned by this cryptomap entry or when cipsStaticCryptomapAutoPeer is equal to 'true'. ")
cipsStaticCryptomapPfs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 11), CIPsecDiffHellmanGrp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapPfs.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapPfs.setDescription('This object identifies if the tunnels instantiated due to this policy item should use Perfect Forward Secrecy (PFS) and if so, what group of Oakley they should use. ')
cipsStaticCryptomapLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 12), CIPsecLifetime()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapLifetime.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLifetime.setDescription('This object specifies the lifetime of the IPsec Security Associations (SA) created using this IPsec policy entry. The default value of this object is the current value of the object cipsTunnelLifetime. When a value 0 is specified in cipsStaticCryptomapLifetime, the default value is used as the lifetime. ')
cipsStaticCryptomapLifesize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 13), CIPsecLifesize()).setUnits('KBytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapLifesize.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLifesize.setDescription('This object identifies the lifesize (maximum traffic in bytes that may be carried) of the IPSec SAs created using this IPSec policy entry. When a Security Association (SA) is created using this IPsec policy entry, its lifesize takes the value of this object. The default value of this object is the current value of the object cipsTunnelLifesize. When a value 0 is specified in cipsStaticCryptomapLifesize, the default value is used as the lifesize. ')
cipsStaticCryptomapLevelHost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapLevelHost.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLevelHost.setDescription("This object specifies the granularity of the IPSec SAs created using this IPSec policy entry. If this value is 'true', distinct SA bundles are created for distinct hosts at the end of the application traffic. ")
cipsStaticCryptomapIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 15), CIPsecTunnelIdleTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapIdleTimeout.setDescription('This object specifies the idle time (lack of traffic) in seconds of a tunnel spawned by this cryptomap after which the tunnel will be torn down. The default value of this object is the current value of cipsTunnelIdleTimeout. ')
cipsStaticCryptomapAutoPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapAutoPeer.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapAutoPeer.setDescription("If 'true' the destination address is taken as the peer address, while creating the tunnel. If 'false' the value shown by the object cipsStaticCryptomapCurPAddr is being used as the peer address. ")
cipsStaticCryptomapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 3, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsStaticCryptomapStatus.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapStatus.setDescription('This object identifies the status of the cryptomap entry represented by this conceptual row. ')
cipsIPsecCryMapPeerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4), )
if mibBuilder.loadTexts: cipsIPsecCryMapPeerTable.setStatus('current')
if mibBuilder.loadTexts: cipsIPsecCryMapPeerTable.setDescription("The table containing the binding of peers to cryptomap entries. An entry is removed from this table automatically by the agent when the last 'active' entry with the corresponding cipsStaticCryptomapSetName is removed from cipsStaticCryptomapTable. ")
cipsIPsecCryMapPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1), ).setIndexNames((0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetName"), (0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapPriority"), (0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsCryMapPeerIndex"))
if mibBuilder.loadTexts: cipsIPsecCryMapPeerEntry.setStatus('current')
if mibBuilder.loadTexts: cipsIPsecCryMapPeerEntry.setDescription('Each entry represents the binding of an IPsec peer address to the specified cryptomap. ')
cipsCryMapPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cipsCryMapPeerIndex.setStatus('current')
if mibBuilder.loadTexts: cipsCryMapPeerIndex.setDescription('This arbitrary number represents the index number in the cryptomap entry of the peer corresponding to this conceptual row. This object could have the same value as cipsStaticCryotomapNextPIndex. ')
cipsCryMapPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsCryMapPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: cipsCryMapPeerAddrType.setDescription("This object represents the address type of cipsCryMapPeerAddr. This object cannot be modified while the corresponding value of cipsCryMapPeerStatus is equal to 'active'. ")
cipsCryMapPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsCryMapPeerAddr.setStatus('current')
if mibBuilder.loadTexts: cipsCryMapPeerAddr.setDescription("This object represents the address of the peer corresponding to this conceptual row. This object cannot be modified while the corresponding value of cipsCryMapPeerStatus is equal to 'active'. ")
cipsCryMapPeerOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsCryMapPeerOrder.setStatus('current')
if mibBuilder.loadTexts: cipsCryMapPeerOrder.setDescription("This object represents the order in the cryptomap entry of the peer corresponding to this conceptual row. The peer with the lowest order number is applied first, that is cipsCryMapPeerOrder '1'. ")
cipsCryMapPeerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsCryMapPeerStatus.setStatus('current')
if mibBuilder.loadTexts: cipsCryMapPeerStatus.setDescription('This object specifies the status column used for creating and deleting instances of the columnar objects in the table. ')
cipsCryptomapSetIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 5), )
if mibBuilder.loadTexts: cipsCryptomapSetIfTable.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfTable.setDescription('The table lists the binding of cryptomap sets to the interfaces of the managed entity. One interface can be bound to only one cryptomap set while one cryptomap set can be bound to multiple interfaces. Any interface (with any ifType) which supports IPsec can be used in this table. ')
cipsCryptomapSetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 5, 1), ).setIndexNames((0, "CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetName"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cipsCryptomapSetIfEntry.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfEntry.setDescription('Each entry lists the association between an interface and a cryptomap set (static) that is defined on the managed entity. ')
cipsCryptomapSetIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 5, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipsCryptomapSetIfStatus.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfStatus.setDescription("This object identifies the status of the binding of the specified cryptomap set with the specified interface. Detaching a cryptomap from an interface: ---------------------------------------- When set to 'destroy', if a cryptomap set is attached to the interface corresponding to ifIndex, the cryptomap set is detached from the interface. Attaching a cryptomap to an interface: ---------------------------------------- If the value 'createAndGo' is set: a row in this table can be created only if it identifies a cryptomap which is represented by an entry in cipsStaticCryptomapSetTable. ")
cipsIfCryptomapSetInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 6), )
if mibBuilder.loadTexts: cipsIfCryptomapSetInfoTable.setStatus('current')
if mibBuilder.loadTexts: cipsIfCryptomapSetInfoTable.setDescription('The table lists the binding information of a interface to a cryptomap sets on the managed entity. One interface can be bound to only one cryptomap set while one cryptomap set can be bound to multiple interfaces. An entry is added to cipsIfCryptomapSetInfoTable when a static cryptomap set is successfully assigned to an interface (of any ifType) in cipsCryptomapSetIfTable. An entry is deleted from cipsIfCryptomapSetInfoTable when its assignment is removed from cipsIfCryptomapSetInfoTable. ')
cipsIfCryptomapSetInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cipsIfCryptomapSetInfoEntry.setStatus('current')
if mibBuilder.loadTexts: cipsIfCryptomapSetInfoEntry.setDescription('Each entry lists the binding between an interface and a cryptomap set (static) that is defined on the managed entity. ')
cipsIfStaticCryptomapSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 4, 6, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIfStaticCryptomapSetName.setStatus('current')
if mibBuilder.loadTexts: cipsIfStaticCryptomapSetName.setDescription('The name of a static cryptomap set which is bound to this interface. The value of the string is one of the entries in cipsStaticCryptomapSetTable indexed by cipsStaticCryptomapSetName. ')
cipsCntlAllNotifs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlAllNotifs.setStatus('current')
if mibBuilder.loadTexts: cipsCntlAllNotifs.setDescription("This object must be set to 'true' to enable any notification in addition to the notification-specific control variables defined below. A notification <foo> defined in this module is enabled if and only if the expression (cipsCntlAllNotifs && cipsCntl<foo>) evaluates to 'true'. ")
cipsCntlCryptomapAdded = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapAdded.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapAdded.setDescription("This variable controls the generation of ciscoIPsecProvCryptomapAdded notification. When this variable is set to 'true', a notification is generated when a static cryptomap is created in cipsStaticCryptomapTable. When this variable is set to 'false', generation of this notification is disabled. ")
cipsCntlCryptomapDeleted = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapDeleted.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapDeleted.setDescription("This variable controls the generation of ciscoIPsecProvCryptomapDeleted notification. When this variable is set to 'true', a notification is generated when a static cryptomap is deleted from cipsStaticCryptomapTable. When this variable is set to 'false', generation of this notification is disabled. ")
cipsCntlCryptomapSetAttached = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapSetAttached.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapSetAttached.setDescription("This variable controls the generation of ciscoIPsecProvCryptomapAttached notification. When this variable is set to 'true', a notification is generated when a cryptomap set is attached to an active interface. When this variable is set to 'false', generation of this notification is disabled. ")
cipsCntlCryptomapSetDetached = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 431, 1, 5, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapSetDetached.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapSetDetached.setDescription("This variable controls the generation of ciscoIPsecProvCryptomapDetached notification. When this variable is set to 'true', a notification is generated when a cryptomap set is detached from an active interface. When this variable is set to 'false', generation of this notification is disabled. ")
ciscoIPsecProvCryptomapAdded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 431, 0, 1)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapType"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapAdded.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapAdded.setDescription("This notification is generated when a new cryptomap is added to the specified cryptomap set. Object 'cipsStaticCryptomapSetSize' contains the number of cryptomap entries after the addition. ")
ciscoIPsecProvCryptomapDeleted = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 431, 0, 2)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapDeleted.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapDeleted.setDescription("This notification is generated when a cryptomap is removed from the specified cryptomap set. Object 'cipsStaticCryptomapSetSize' contains the number of cryptomap entries after the deletion. ")
ciscoIPsecProvCryptomapAttached = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 431, 0, 3)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetSize"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumIsakmp"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumDynamic"))
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapAttached.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapAttached.setDescription('A cryptomap set must be attached to an interface of the device in order for it to be operational. This trap is generated when the cryptomap set attached to an active interface of the managed entity. The contents of the notification includes: Size of the attached cryptomap set, Number of ISAKMP cryptomaps in the set and Number of Dynamic cryptomaps in the set. ')
ciscoIPsecProvCryptomapDetached = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 431, 0, 4)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapDetached.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvCryptomapDetached.setDescription('This trap is generated when a cryptomap set is detached from an interafce to which it was bound earlier. The context of the event identifies the size of the cryptomap set. ')
ciscoIPsecProvMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 1))
ciscoIPsecProvMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2))
ciscoIPsecProvMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 1, 1)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvGlobalsGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvXformsGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvStCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecCryptomapPeerGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvNotifCntlGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvDynCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvTedCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvMIBCompliance = ciscoIPsecProvMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoIPsecProvMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco IPsec Provisioning MIB. ')
ciscoIPsecProvMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 1, 2)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvGlobalsGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvXformsGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvStCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecCryptomapPeerGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvNotifCntlGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvInfoGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvDynCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvTedCryptomapGroup"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvMIBComplianceRev1 = ciscoIPsecProvMIBComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvMIBComplianceRev1.setDescription('The compliance statement for entities which implement the Cisco IPsec Provisioning MIB. ')
ciscoIPsecProvGlobalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 1)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsTunnelLifetime"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsTunnelLifesize"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsTunnelIdleTimeout"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvGlobalsGroup = ciscoIPsecProvGlobalsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvGlobalsGroup.setDescription('A collection of objects providing Global IPSec policy monitoring capability to a IPsec capable VPN router. ')
ciscoIPsecProvXformsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 2)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetId"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetMode"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetSuite"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetEncryptionXform"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetIntegrityXformEsp"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetIntegrityXformAh"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetCompressionXform"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsXformSetStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvXformsGroup = ciscoIPsecProvXformsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvXformsGroup.setDescription('A collection of objects modeling IPsec transform sets and transform set mappings.')
ciscoIPsecProvStCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 3)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsNumStaticCryptomapSets"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetSize"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumIsakmp"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumManual"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumDynamic"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumTED"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapSetNumSAs"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapType"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapDescr"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapIpFilter"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapXformSetList"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapNumPeers"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryotomapNextPIndex"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapCurPAddrType"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapCurPAddr"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapPfs"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapLifetime"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapLifesize"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapLevelHost"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapIdleTimeout"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapStatus"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsStaticCryptomapAutoPeer"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCryMapPeerStatus"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCryptomapSetIfStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvStCryptomapGroup = ciscoIPsecProvStCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvStCryptomapGroup.setDescription('A collection of objects modeling static crypto configuration of the Static (fully specified) Cryptomap Sets on the managed entity. ')
ciscoIPsecProvDynCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 4)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsNumDynamicCryptomapSets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvDynCryptomapGroup = ciscoIPsecProvDynCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvDynCryptomapGroup.setDescription('A collection of objects modeling the configuration of IPsec dynamic cryptomap elements. ')
ciscoIPsecProvTedCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 5)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsNumTEDCryptomapSets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvTedCryptomapGroup = ciscoIPsecProvTedCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvTedCryptomapGroup.setDescription('A collection of objects instrumenting the properties of the Cryptomaps using tunnel endpoint discovery protocol.')
ciscoIPsecCryptomapPeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 6)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsCryMapPeerAddrType"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCryMapPeerAddr"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCryMapPeerOrder"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecCryptomapPeerGroup = ciscoIPsecCryptomapPeerGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecCryptomapPeerGroup.setDescription('A collection of objects displaying the binding of an IPsec peer address to the specified cryptomap. ')
ciscoIPsecProvNotifCntlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 7)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsCntlAllNotifs"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCntlCryptomapAdded"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCntlCryptomapDeleted"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCntlCryptomapSetAttached"), ("CISCO-IPSEC-PROVISIONING-MIB", "cipsCntlCryptomapSetDetached"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvNotifCntlGroup = ciscoIPsecProvNotifCntlGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvNotifCntlGroup.setDescription('A collection of objects providing IPsec Notification capability to a IPsec-capable router. It is mandatory to implement this set of objects pertaining to IOS notifications about IPSec activity. ')
ciscoIPsecProvNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 8)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvCryptomapDetached"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvCryptomapAttached"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvCryptomapDeleted"), ("CISCO-IPSEC-PROVISIONING-MIB", "ciscoIPsecProvCryptomapAdded"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvNotifGroup = ciscoIPsecProvNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvNotifGroup.setDescription('A collection of notification objects signaling changes to the IPsec configuration on the managed entity. ')
ciscoIPsecProvInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 431, 2, 2, 9)).setObjects(("CISCO-IPSEC-PROVISIONING-MIB", "cipsIfStaticCryptomapSetName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIPsecProvInfoGroup = ciscoIPsecProvInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIPsecProvInfoGroup.setDescription('A collection of objects providing current IPsec configuration information on the managedentity. ')
mibBuilder.exportSymbols("CISCO-IPSEC-PROVISIONING-MIB", ciscoIPsecProvMIBGroups=ciscoIPsecProvMIBGroups, cipsStaticCryptomapType=cipsStaticCryptomapType, cipsTunnelLifetime=cipsTunnelLifetime, cipsNotificationCntl=cipsNotificationCntl, cipsStaticCryptomapSetNumManual=cipsStaticCryptomapSetNumManual, ciscoIPsecProvNotifGroup=ciscoIPsecProvNotifGroup, cipsCryptomapSetIfEntry=cipsCryptomapSetIfEntry, ciscoIPsecProvCryptomapDeleted=ciscoIPsecProvCryptomapDeleted, cipsCntlCryptomapDeleted=cipsCntlCryptomapDeleted, cipsStaticCryptomapLevelHost=cipsStaticCryptomapLevelHost, ciscoIPsecProvInfoGroup=ciscoIPsecProvInfoGroup, cipsCryptoMaps=cipsCryptoMaps, cipsXformSetEncryptionXform=cipsXformSetEncryptionXform, cipsXformSetStatus=cipsXformSetStatus, ciscoIPsecCryptomapPeerGroup=ciscoIPsecCryptomapPeerGroup, cipsXformSetSuite=cipsXformSetSuite, cipsStaticCryptomapSetNumTED=cipsStaticCryptomapSetNumTED, cipsIfCryptomapSetInfoTable=cipsIfCryptomapSetInfoTable, cipsStaticCryptomapSetNumDynamic=cipsStaticCryptomapSetNumDynamic, cipsTunnelLifesize=cipsTunnelLifesize, cipsCryMapPeerAddrType=cipsCryMapPeerAddrType, ciscoIPsecProvCryptomapAttached=ciscoIPsecProvCryptomapAttached, cipsStaticCryptomapXformSetList=cipsStaticCryptomapXformSetList, cipsCryMapPeerStatus=cipsCryMapPeerStatus, cipsStaticCryptomapIpFilter=cipsStaticCryptomapIpFilter, cipsStaticCryptomapLifetime=cipsStaticCryptomapLifetime, ciscoIPsecProvCryptomapAdded=ciscoIPsecProvCryptomapAdded, cipsStaticCryptomapSetNumSAs=cipsStaticCryptomapSetNumSAs, cipsStaticCryptomapSetName=cipsStaticCryptomapSetName, cipsCntlCryptomapSetDetached=cipsCntlCryptomapSetDetached, cipsIPsecXformSetEntry=cipsIPsecXformSetEntry, cipsNumTEDCryptomapSets=cipsNumTEDCryptomapSets, cipsXformSetIntegrityXformEsp=cipsXformSetIntegrityXformEsp, cipsIPsecGlobals=cipsIPsecGlobals, ciscoIPsecProvMIBCompliances=ciscoIPsecProvMIBCompliances, cipsStaticCryptomapAutoPeer=cipsStaticCryptomapAutoPeer, cipsStaticCryotomapNextPIndex=cipsStaticCryotomapNextPIndex, cipsStaticCryptomapNumPeers=cipsStaticCryptomapNumPeers, cipsCryMapPeerIndex=cipsCryMapPeerIndex, cipsStaticCryptomapSetEntry=cipsStaticCryptomapSetEntry, ciscoIPsecProvTedCryptomapGroup=ciscoIPsecProvTedCryptomapGroup, cipsCryptomapSetIfTable=cipsCryptomapSetIfTable, cipsStaticCryptomapEntry=cipsStaticCryptomapEntry, cipsStaticCryptomapLifesize=cipsStaticCryptomapLifesize, ciscoIPsecProvNotifCntlGroup=ciscoIPsecProvNotifCntlGroup, cipsIPsecCryMapPeerTable=cipsIPsecCryMapPeerTable, ciscoIPsecProvisioningMIBNotifs=ciscoIPsecProvisioningMIBNotifs, cipsCryptomapSetIfStatus=cipsCryptomapSetIfStatus, cipsStaticCryptomapSetSize=cipsStaticCryptomapSetSize, ciscoIPsecProvStCryptomapGroup=ciscoIPsecProvStCryptomapGroup, cipsStaticCryptomapSetTable=cipsStaticCryptomapSetTable, cipsXformSetCompressionXform=cipsXformSetCompressionXform, PYSNMP_MODULE_ID=ciscoIPsecProvisioningMIB, ciscoIPsecProvGlobalsGroup=ciscoIPsecProvGlobalsGroup, cipsCntlCryptomapSetAttached=cipsCntlCryptomapSetAttached, ciscoIPsecProvisioningMIB=ciscoIPsecProvisioningMIB, cipsStaticCryptomapCurPAddr=cipsStaticCryptomapCurPAddr, cipsCntlAllNotifs=cipsCntlAllNotifs, cipsTunnelIdleTimeout=cipsTunnelIdleTimeout, ciscoIPsecProvisioningMIBConform=ciscoIPsecProvisioningMIBConform, cipsStaticCryptomapIdleTimeout=cipsStaticCryptomapIdleTimeout, cipsXformSetIntegrityXformAh=cipsXformSetIntegrityXformAh, ciscoIPsecProvDynCryptomapGroup=ciscoIPsecProvDynCryptomapGroup, cipsNumStaticCryptomapSets=cipsNumStaticCryptomapSets, cipsStaticCryptomapCurPAddrType=cipsStaticCryptomapCurPAddrType, cipsStaticCryptomapPfs=cipsStaticCryptomapPfs, cipsStaticCryptomapSetNumIsakmp=cipsStaticCryptomapSetNumIsakmp, cipsIfCryptomapSetInfoEntry=cipsIfCryptomapSetInfoEntry, cipsXformSetName=cipsXformSetName, cipsXformSetId=cipsXformSetId, ciscoIPsecProvMIBComplianceRev1=ciscoIPsecProvMIBComplianceRev1, cipsCryptoMapGeneral=cipsCryptoMapGeneral, ciscoIPsecProvXformsGroup=ciscoIPsecProvXformsGroup, cipsIPsecTransforms=cipsIPsecTransforms, cipsStaticCryptomapDescr=cipsStaticCryptomapDescr, ciscoIPsecProvCryptomapDetached=ciscoIPsecProvCryptomapDetached, cipsIPsecCryMapPeerEntry=cipsIPsecCryMapPeerEntry, cipsIPsecXformSetTable=cipsIPsecXformSetTable, cipsIfStaticCryptomapSetName=cipsIfStaticCryptomapSetName, ciscoIPsecProvisioningMIBObjects=ciscoIPsecProvisioningMIBObjects, cipsCntlCryptomapAdded=cipsCntlCryptomapAdded, cipsNumDynamicCryptomapSets=cipsNumDynamicCryptomapSets, cipsStaticCryptomapTable=cipsStaticCryptomapTable, cipsCryMapPeerAddr=cipsCryMapPeerAddr, cipsXformSetMode=cipsXformSetMode, cipsCryMapPeerOrder=cipsCryMapPeerOrder, ciscoIPsecProvMIBCompliance=ciscoIPsecProvMIBCompliance, cipsStaticCryptomapPriority=cipsStaticCryptomapPriority, cipsStaticCryptomapStatus=cipsStaticCryptomapStatus)

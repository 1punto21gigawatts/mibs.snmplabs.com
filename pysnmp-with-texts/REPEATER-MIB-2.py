#
# PySNMP MIB module REPEATER-MIB-2 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/REPEATER-MIB-2
# Produced by pysmi-0.3.4 at Wed May  1 11:44:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
commonRev1, repeaterRev2, product, subSysMMAC, repeaterRev1, sysChassis, sysRepeaters = mibBuilder.importSymbols("IRM-OIDS", "commonRev1", "repeaterRev2", "product", "subSysMMAC", "repeaterRev1", "sysChassis", "sysRepeaters")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter64, iso, ObjectIdentity, TimeTicks, MibIdentifier, Bits, Gauge32, IpAddress, NotificationType, Integer32, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter64", "iso", "ObjectIdentity", "TimeTicks", "MibIdentifier", "Bits", "Gauge32", "IpAddress", "NotificationType", "Integer32", "Counter32", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
deviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceType.setDescription('This object defines the board type for the Management board in the device. (eg. IRBM, IRM). See appendix A for values.')
deviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceName.setStatus('mandatory')
if mibBuilder.loadTexts: deviceName.setDescription('An ASCII name of the device that this agent manages.')
deviceIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceIPAddress.setDescription('The Internet address of this device. Write access is granted only if SuperUser access is used.')
currentTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentTime.setStatus('optional')
if mibBuilder.loadTexts: currentTime.setDescription('The current time of day as measured by the device in HHMMSS format.')
currentDate = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentDate.setStatus('optional')
if mibBuilder.loadTexts: currentDate.setDescription('The current date as measured by the device in MMDDYYYY format.')
mACAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mACAddress.setDescription('The MAC (Ethernet) address of the MMAC. This can also be obtained from address translation MIB.')
soidIRMSNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 1))
soidIRBM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 2))
soidIRM2 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 3))
soidMINIMMAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 3, 1))
soidMRXI = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 3, 2))
device = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1))
board = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 2))
port = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 3))
sourceAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7))
redundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8))
alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9))
deviceMMACType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("mMAC3", 1), ("mMAC5", 2), ("minimmac", 3), ("mrxi1", 4), ("mrxi2", 5), ("mMACm8Shunt", 6), ("mMACm3Shunt", 7), ("mMACm5Shunt", 8), ("mMAC8FNBShunt", 9), ("mMAC3FNBShunt", 10), ("mMAC5FNBShunt", 11), ("mMACm8FNB", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMMACType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceMMACType.setDescription('Indicates the type of MMAC.')
deviceSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 3, 5))).clone(namedValues=NamedValues(("mMAC8", 8), ("mMAC3", 3), ("mMAC5", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSlots.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSlots.setDescription('Number of available slots in this device including the IRM slot.')
deviceOccupiedSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceOccupiedSlots.setStatus('mandatory')
if mibBuilder.loadTexts: deviceOccupiedSlots.setDescription('The slots that contain MIM boards. This field is bit encoded (eg. If a bit is set then that board is present. For example, a value of 3 indicates that there are boards in the IRM slot and the first MIM slot.')
devicePortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devicePortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: devicePortsOn.setDescription('A read will return the number of adminstratively ON ports for the device. A write of a 1 will administratively enable all the ports on the device, except for redundant ports.')
deviceTotalPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalPorts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTotalPorts.setDescription('The total number of ports in the MMAC.')
deviceTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTotalPkts.setDescription('The number of packets detected on all ports of this device.')
deviceTotalErrors = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalErrors.setStatus('optional')
if mibBuilder.loadTexts: deviceTotalErrors.setDescription('The sum of all alignment, CRC, out-of-window collisions, runt, and giant errors detected by this device.')
deviceTransmitColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTransmitColls.setStatus('optional')
if mibBuilder.loadTexts: deviceTransmitColls.setDescription('The number of transmit collisions detected by this device.')
deviceRecColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRecColls.setStatus('optional')
if mibBuilder.loadTexts: deviceRecColls.setDescription('The number of receive collsions detected by this device.')
deviceAligns = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAligns.setStatus('optional')
if mibBuilder.loadTexts: deviceAligns.setDescription('The number of packets with alignment errors detected by this device.')
deviceCRCs = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceCRCs.setStatus('optional')
if mibBuilder.loadTexts: deviceCRCs.setDescription('The number of packets with bad CRC detected by this device.')
deviceRunts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRunts.setStatus('optional')
if mibBuilder.loadTexts: deviceRunts.setDescription('The number of runt frames detected by this device.')
deviceOOWColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceOOWColls.setStatus('optional')
if mibBuilder.loadTexts: deviceOOWColls.setDescription('The number of out-of-window collisions detected by this device.')
deviceNoResources = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceNoResources.setStatus('optional')
if mibBuilder.loadTexts: deviceNoResources.setDescription('The number of no resource condtions detected by this device.')
deviceRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRecBytes.setStatus('optional')
if mibBuilder.loadTexts: deviceRecBytes.setDescription('The number of bytes detected on the network by this device.')
deviceGiantFrames = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceGiantFrames.setStatus('optional')
if mibBuilder.loadTexts: deviceGiantFrames.setDescription('The number of longer than 1518 byte packets detected by this device.')
deviceRestart = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceRestart.setStatus('mandatory')
if mibBuilder.loadTexts: deviceRestart.setDescription('A read will return 0. A set of 0 will restart the device.')
deviceResetCounters = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: deviceResetCounters.setDescription('A read will return 0. A set of 0 will reset all the counters for the device, boards and ports.')
deviceRedundantCts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRedundantCts.setStatus('optional')
if mibBuilder.loadTexts: deviceRedundantCts.setDescription('The number of redundant circuits available for use.')
deviceTimeBase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 24), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceTimeBase.setStatus('optional')
if mibBuilder.loadTexts: deviceTimeBase.setDescription("The number of seconds used as the interval for performing all of the rate alarm checks. The minimum is 10 secs. There isn't a maximum.")
deviceResetRedundancy = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceResetRedundancy.setStatus('optional')
if mibBuilder.loadTexts: deviceResetRedundancy.setDescription('A read will return 0. A set of a 1 will reset redundancy for the entire box.')
deviceSrcAddrAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 26), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrAgingTime.setStatus('optional')
if mibBuilder.loadTexts: deviceSrcAddrAgingTime.setDescription('The number of minutes that a source address is not detected before it is removed from the source address table. The minimum is 1 minute and the maximum is 1440 minutes (max minutes in a day).')
deviceSrcAddrTraps = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapsoff", 1), ("trapson", 2))).clone('trapson')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrTraps.setStatus('optional')
if mibBuilder.loadTexts: deviceSrcAddrTraps.setDescription('Controls sending of source address related traps.')
deviceSrcAddrLocked = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lockoff", 1), ("lockon", 2))).clone('lockoff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrLocked.setStatus('optional')
if mibBuilder.loadTexts: deviceSrcAddrLocked.setDescription('A set of 2 will disable all ports that support link status but do not have link active, or is segmented. The first source address seen on each of the remaining enabled ports, that have the type of station, will be the only address allowed through that port. If any other address is seen the port will be disabled.')
deviceEnetBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceEnetBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceEnetBoardMap.setDescription('The slots that contain Ethernet MIM boards. This field is bit encoded (e.g. If a bit is set then that board is present and is an Ethernet MIM.) For example, a value of 3 indicates that there are boards in the IRM slot and the first MIM slot and that these boards are Ethernet MIMs.')
deviceTokenRingBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTokenRingBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTokenRingBoardMap.setDescription('The slots that contain Token Ring MIM boards. This field is bit encoded (e.g. If a bit is set then that board is present and is a Token Ring MIM.) For example, a value of 2 indicates that there is a board in the first slot and it is a Token Ring board.')
deviceFDDIBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceFDDIBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceFDDIBoardMap.setDescription('The slots that contain FDDI MIM boards. This field is bit encoded (e.g. If a bit is set then that board is present and is a FDDI MIM.) For example, a value of 2 indicates that there is a board in the first slot and it is a FDDI board.')
deviceRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: deviceRestoreDefaults.setDescription('A get will return 0. A set of 0 will restore all of battery backed RAM to factory defaults, with the execption of the IP address, the community table and the modem baud rate.')
deviceActiveUsers = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceActiveUsers.setStatus('optional')
if mibBuilder.loadTexts: deviceActiveUsers.setDescription('The number of active users seen on this device.')
deviceBroadPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceBroadPkts.setStatus('optional')
if mibBuilder.loadTexts: deviceBroadPkts.setDescription('The sum of all of the broadcast packets detected on all ports of this device.')
deviceMultPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMultPkts.setStatus('optional')
if mibBuilder.loadTexts: deviceMultPkts.setDescription('The sum of all of the multicast packets detected on all ports of this device.')
deviceThdPartyOccupiedSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceThdPartyOccupiedSlots.setStatus('optional')
if mibBuilder.loadTexts: deviceThdPartyOccupiedSlots.setDescription('The slots that contain Third Party MIM boards. This field is bit encoded (eg. if a bit is set then that board is present and is a Third Party MIM.) For example, a value of 4 indicates that there is a board in the third MIM slot (slot 4) and that this board is a Third Party MIM.')
deviceImimOccupiedSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceImimOccupiedSlots.setStatus('optional')
if mibBuilder.loadTexts: deviceImimOccupiedSlots.setDescription('The slots that contain IMIM boards. This field is bit encoded (eg. if a bit is set then that board is present and is an IMIM). For example, a value of 4 indicates that there is a board in the third MIM slot (slot 4) and that this board is an IMIM.')
deviceLinkTraps = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapsoff", 1), ("trapson", 2))).clone('trapson')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceLinkTraps.setStatus('optional')
if mibBuilder.loadTexts: deviceLinkTraps.setDescription('Controls sending of link related traps.')
deviceSegTraps = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapsoff", 1), ("trapson", 2))).clone('trapson')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSegTraps.setStatus('optional')
if mibBuilder.loadTexts: deviceSegTraps.setDescription('Controls sending of seg related traps.')
ctIPDefaultFrameType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("snap8022", 2))).clone('ethernet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIPDefaultFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: ctIPDefaultFrameType.setDescription('Defines the default frame type that will be used by the device. A device will understand both frame types and will respond based upon the framing type that is learned for the given address. This object defines the type of framing that will be used if no framing is known, for example ARP requests. Setting a value of 8022snap(2) will result in framing 802.3 - 802.2 - IP packets being generated by default. Setting a value of ethernet(1) will result in framing ethernet IP packets by default.')
sourceAddrBoard = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceAddrBoard.setStatus('mandatory')
if mibBuilder.loadTexts: sourceAddrBoard.setDescription('The board number of the port that the supplied source address has been seen on.')
sourceAddrPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceAddrPort.setStatus('mandatory')
if mibBuilder.loadTexts: sourceAddrPort.setDescription('The port number of the port that the supplied source address has been seen on.')
redundancyPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 1), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyPollInterval.setDescription('The number of seconds between polls for redundancy. The minimum is 0 and the maximum is 99.')
redundancyTestTod = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyTestTod.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyTestTod.setDescription('The time of day at which the redundant circuits should be tested.')
redundancyPerformTest = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("performTest", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyPerformTest.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyPerformTest.setDescription('A read will return a 0. A set of a 1 will test the redundant circuits now.')
redundancyCircuitName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitName.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitName.setDescription('The name of the indicated circuit.')
redundancyRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyRetryCount.setDescription('The number of unanswered polls allowed for the indicated circuit before the current connection is declared bad. The minimum is 0 the maximum is 16.')
redundancyNumBPs = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyNumBPs.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyNumBPs.setDescription('The number of board/port combinations associated with the indicated circuit.')
redundancyCircuitBoards = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitBoards.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitBoards.setDescription('The boards associated with the indicated circuit, accessed by index. Note: The instance identifier for this object is the circuit number followed by an index. The index has no other meaning than to be used as an index for the purposes of the GET NEXT operation.')
redundancyCircuitPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitPort.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitPort.setDescription('The ports associated with the indicated circuit, accessed by index. Note: The instance identifier for this object is the circuit number followed by an index. The index has no other meaning than to be used as an index for the purposes of the GET NEXT operation.')
redundancyCircuitTypes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitTypes.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitTypes.setDescription('The type of each port associated with the indicated circuit, accessed by index. Note: The instance identifier for this object is the circuit number followed by an index. The index has no other meaning than to be used as an index for the purposes of the GET NEXT operation.')
redundancyCircuitNumAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitNumAddr.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitNumAddr.setDescription('The number of addresses associated with the indicated circuit.')
redundancyCircuitMACAddrAdd = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitMACAddrAdd.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrAdd.setDescription('A get will return a null string. A set adds an ethernet address to the polling list for the indicated circuit.')
redundancyCircuitMACAddrDel = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 12), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitMACAddrDel.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrDel.setDescription('A get will return a null string. A set deletes an ethernet address from the polling list for the indicated circuit.')
redundancyCircuitMACAddrDisp = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitMACAddrDisp.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrDisp.setDescription('The ethernet addresses associated with the indicated circuit, accessed by index. Note: The instance identifier for this object is the circuit number followed by an index. The index has no other meaning than to be used as an index for the purposes of the GET NEXT operation.')
redundancyCircuitEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitEnable.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitEnable.setDescription('Enables and disables the indicated circuit.')
redundancyCircuitReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitReset.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitReset.setDescription('A get will return 0. A set of 1 will reset the indicated circuit, return all of the associated board and ports to NOT-USED, remove associated addresses from the polling list, reset the circuit name and retry count to default values.')
devAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1))
bdAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2))
portAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3))
devTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1))
devColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2))
devError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3))
devBroad = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 4))
devTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devTrafficEnable.setDescription('Enable or disable the checking for device level traffic thresholds getting exceeded.')
devTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1, 2), Integer32().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devTrafficThreshold.setDescription("The number of packets detected by the device within the device timebase that will cause a device traffic alarm trap to be sent. The minimum is 0. There isn't a maximum.")
devCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devCollsEnable.setDescription('Enable or disable the checking for device level collision thresholds getting exceeded.')
devCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devCollsThreshold.setDescription('The number of collisions per good packet detected by the device within the device timebase that will cause a device collision alarm trap to be sent. The minimum is 1, the maximum is 15.')
devErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorEnable.setDescription('Enable or disable the checking for device level error thresholds getting exceeded.')
devErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 2), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorThreshold.setDescription('The percentage of errors per good packet detected by the device within the device timebase that will cause a device error alarm trap to be sent. The minimum is 1, the maximum is 100.')
devErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 3), Integer32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorSource.setDescription('The type of errors used for the device error alarm. The INTEGER is a bit encoded version of which errors to include in the error sum. The bits are encoded as follows: CRC_errors - Bit 0 - Least Significant Bit runts - Bit 1 OOW_colls - Bit 2 align_errs - Bit 3 No_resource - Bit 4 Giants - Bit 5')
devBroadEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devBroadEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devBroadEnable.setDescription('Enable the sending of device level broadcast traps.')
devBroadThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devBroadThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devBroadThreshold.setDescription('The threshold of broadcast packets within the Devicetimebase that will cause a broadcast alarm.')
bdTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1))
bdColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2))
bdError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3))
bdBroad = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 4))
bdTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdTrafficEnable.setDescription('Enable or disable the checking for board level traffic thresholds getting exceeded.')
bdTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1, 2), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdTrafficThreshold.setDescription("The number of packets detected by the specified board within the device timebase that will cause a board traffic alarm trap to be sent. The minimum is 0. There isn't a maximum.")
bdTrafficBdDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdTrafficBdDisable.setStatus('mandatory')
if mibBuilder.loadTexts: bdTrafficBdDisable.setDescription('Permits a board to be disabled on a traffic threshold getting exceeded.')
bdCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdCollsEnable.setDescription('Enable or disable the checking for board level collision thresholds getting exceeded.')
bdCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2, 2), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdCollsThreshold.setDescription('The number of collisions per good packet detected by the specified board within the device timebase that will cause a board collision alarm trap to be sent. The minimum is 1, the maximum is 15.')
bdCollsBdDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdCollsBdDisable.setStatus('mandatory')
if mibBuilder.loadTexts: bdCollsBdDisable.setDescription('Permits a board to be disabled on a collision threshold getting exceeded.')
bdErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorEnable.setDescription('Enable or disable the checking for board level error thresholds getting exceeded.')
bdErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 2), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorThreshold.setDescription('The percentage of errors per good packet detected by the specified board within the device timebase that will cause a board error alarm trap to be sent. The minimum is 1, the maximum is 100.')
bdErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 3), Integer32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorSource.setDescription('The type of errors used for the board error alarm. The INTEGER is a bit encoded version of which errors to include in the error sum. The bits are encoded as follows: CRC_errors - Bit 0 - Least Significant Bit runts - Bit 1 OOW_colls - Bit 2 align_errs - Bit 3 No_resource - Bit 4 Giants - Bit 5')
bdErrorBdDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorBdDisable.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorBdDisable.setDescription('Permits a board to be disabled on an error threshold getting exceeded.')
bdBroadEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdBroadEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdBroadEnable.setDescription('Enable the sending of board level broadcast traps for this board.')
bdBroadThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdBroadThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdBroadThreshold.setDescription('The threshold of broadcast packets within the Devicetimebase that will cause a broadcast alarm.')
bdBroadDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdBroadDisable.setStatus('mandatory')
if mibBuilder.loadTexts: bdBroadDisable.setDescription('Permit a board to be disabled on a broadcast threshold alarm.')
portTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1))
portColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2))
portError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3))
portBroad = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 4))
portTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portTrafficEnable.setDescription('Enable or disable the checking for port level traffic thresholds getting exceeded.')
portTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1, 2), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portTrafficThreshold.setDescription("The number of packets detected by the specified port within the device timebase that will cause a port traffic alarm trap to be sent. The minimum is 0. There isn't a maximum.")
portTrafficPortDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficPortDisable.setStatus('mandatory')
if mibBuilder.loadTexts: portTrafficPortDisable.setDescription('Permits a port to be disabled on a traffic threshold getting exceeded.')
portCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portCollsEnable.setDescription('Enable or disable the checking for port level collision thresholds getting exceeded.')
portCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2, 2), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portCollsThreshold.setDescription('The number of collisions per good packet detected by the specified port within the device timebase that will cause a port collision alarm trap to be sent. The minimum is 1, the maximum is 15.')
portCollsPortDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCollsPortDisable.setStatus('mandatory')
if mibBuilder.loadTexts: portCollsPortDisable.setDescription('Permits a port to be disabled on a collision threshold getting exceeded.')
portErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorEnable.setDescription('Enable or disable the checking for port level error thresholds getting exceeded.')
portErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 2), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorThreshold.setDescription('The percentage of errors per good packet detected by the specified port within the device timebase that will cause a port error alarm trap to be sent. The minimum is 1, the maximum is 100.')
portErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 3), Integer32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorSource.setDescription('The type of errors used for the port error alarm. The INTEGER is a bit encoded version of which errors to include in the error sum. The bits are encoded as follows: CRC_errors - Bit 0 - Least Significant Bit runts - Bit 1 OOW_colls - Bit 2 align_errs - Bit 3 No_resource - Bit 4 Giants - Bit 5')
portErrorPortDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorPortDisable.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorPortDisable.setDescription('Permits a port to be disabled on an error threshold getting exceeded.')
portBroadEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBroadEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portBroadEnable.setDescription('Enable the sending of port level broadcast alarms.')
portBroadThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 4, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBroadThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portBroadThreshold.setDescription('The threshold of broadcast packets within the Devicetimebase that will cause a broadcast alarm.')
portBroadDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBroadDisable.setStatus('mandatory')
if mibBuilder.loadTexts: portBroadDisable.setDescription('Permit a port to be disabled on a broadcast threshold alarm.')
rr2device = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1))
network = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 2))
rr2board = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3))
rr2port = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4))
repeaterTables = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 5))
commonD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 1))
ethernetD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 2))
tokenRingD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3))
deviceTRTokenRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTokenRingPortsOn.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTokenRingPortsOn.setDescription('The number of Token Ring Ports (i.e. station, Ring In and Ring Out ports) administratively ON for this device.')
deviceTRTotalTokenRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingPorts.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTotalTokenRingPorts.setDescription('The total number of Token Ring Ports (i.e. station, Ring In and Ring Out ports) on this device.')
deviceTRTotalTokenRingRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPortsOn.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPortsOn.setDescription('The total number of Ring In and Ring Out ports (active) administratively ON for this device.')
deviceTRTotalTokenRingRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPorts.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPorts.setDescription('The total number of Ring In and Ring Out ports on this device.')
deviceTRTotalTokenRingRings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRings.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRings.setDescription('The total number of (Token Ring) rings formed on this device.')
deviceTRTotalTokenRingBoards = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingBoards.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTotalTokenRingBoards.setDescription('The total number of Token Ring MIMs in the MMAC.')
deviceTRTokenRingBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTokenRingBoardMap.setStatus('deprecated')
if mibBuilder.loadTexts: deviceTRTokenRingBoardMap.setDescription('The slots that contain Token Ring MIM boards. This field is bit encoded (e.g. If a bit is set then that board is present and is a Token Ring MIM.) For example, a value of 2 indicates that there is a board in the first slot and it is a Token Ring board.')
commonB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1))
ethernetB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2))
tokenRingB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3))
fddiB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 4))
boardIndex = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: boardIndex.setDescription('The slot number of this board.')
boardName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardName.setStatus('mandatory')
if mibBuilder.loadTexts: boardName.setDescription('The name of the board. This field will only contain printable ASCII characters.')
boardType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardType.setStatus('mandatory')
if mibBuilder.loadTexts: boardType.setDescription('The type of the MIM. (eg. FOT, TPT, etc). See appendix A for encoding.')
boardTotalPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalPorts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalPorts.setDescription('Total number of ports supported on this board.')
boardPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: boardPortsOn.setDescription('A read will return the number of adminstratively ON ports for the board. A write of a 2 will administratively enable all the ports on the board, except for redundant ports.')
boardActiveUsers = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardActiveUsers.setStatus('mandatory')
if mibBuilder.loadTexts: boardActiveUsers.setDescription('The number of active users seen on this board.')
boardTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalPkts.setDescription('The number of packets detected on all ports of this port.')
boardTotalErrors = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalErrors.setDescription('The sum of all alignment, CRC, out-of-window collisions, runt, and giant errors detected by this board.')
boardTransColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTransColls.setStatus('mandatory')
if mibBuilder.loadTexts: boardTransColls.setDescription('The number of transmit collisions detected by this board.')
boardRecColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRecColls.setStatus('mandatory')
if mibBuilder.loadTexts: boardRecColls.setDescription('The number of receive collsions detected by this board.')
boardAligns = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardAligns.setStatus('mandatory')
if mibBuilder.loadTexts: boardAligns.setDescription('The number of packets with alignment errors detected by this board.')
boardCRCs = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardCRCs.setStatus('mandatory')
if mibBuilder.loadTexts: boardCRCs.setDescription('The number of packets with bad CRC detected by this board.')
boardRunts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRunts.setStatus('mandatory')
if mibBuilder.loadTexts: boardRunts.setDescription('The number of runt frames detected by this board.')
boardOOWColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardOOWColls.setStatus('mandatory')
if mibBuilder.loadTexts: boardOOWColls.setDescription('The number of out-of-window collisions detected by this board.')
boardNoResources = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardNoResources.setStatus('mandatory')
if mibBuilder.loadTexts: boardNoResources.setDescription('The number of no resource condtions detected by this board.')
boardRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRecBytes.setStatus('mandatory')
if mibBuilder.loadTexts: boardRecBytes.setDescription('The number of bytes detected on the network by this board.')
boardGiants = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardGiants.setStatus('mandatory')
if mibBuilder.loadTexts: boardGiants.setDescription('The number of longer than 1518 byte packets detected by this board.')
boardBroadPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardBroadPkts.setStatus('mandatory')
if mibBuilder.loadTexts: boardBroadPkts.setDescription('The number broadcast packets detected by this board.')
boardMultPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardMultPkts.setStatus('mandatory')
if mibBuilder.loadTexts: boardMultPkts.setDescription('The number multicast packets detected by this board.')
boardTotalRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalRingPorts.setStatus('deprecated')
if mibBuilder.loadTexts: boardTotalRingPorts.setDescription('The total number of ring ports on this board. Currently, zero or two.')
boardTotalStationPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalStationPorts.setStatus('deprecated')
if mibBuilder.loadTexts: boardTotalStationPorts.setDescription('The total number of station ports on this board.')
boardModeStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("management", 1), ("auto", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardModeStatus.setStatus('deprecated')
if mibBuilder.loadTexts: boardModeStatus.setDescription('The board mode.')
boardTotalRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalRingPortsOn.setStatus('deprecated')
if mibBuilder.loadTexts: boardTotalRingPortsOn.setDescription('The number of administartively ON ring ports on this board.')
boardTotalStationPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalStationPortsOn.setStatus('deprecated')
if mibBuilder.loadTexts: boardTotalStationPortsOn.setDescription('The number of administartively ON station ports on this board.')
boardSpeed = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 16))).clone(namedValues=NamedValues(("fourMhz", 4), ("sixteenMhz", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardSpeed.setStatus('deprecated')
if mibBuilder.loadTexts: boardSpeed.setDescription('The board speed.')
boardRingSpeedFault = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noFaultDetected", 1), ("faultDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRingSpeedFault.setStatus('deprecated')
if mibBuilder.loadTexts: boardRingSpeedFault.setDescription('Data speed of station mismatches configuration speed of board. Board is automatically bypassed.')
boardFirstRingPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardFirstRingPort.setStatus('deprecated')
if mibBuilder.loadTexts: boardFirstRingPort.setDescription('The port number of the first ring port.')
commonP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1))
ethernetP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2))
tokenRingP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3))
fddiP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 4))
portIndex = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('The number of this port relative to the board it is on.')
portMediaType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: portMediaType.setDescription('The type of the port. (eg. FOT, TPT, etc). See appendix A for values.')
portAdminState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: portAdminState.setDescription('The administrative status of this port.')
portSourceAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSourceAddr.setStatus('optional')
if mibBuilder.loadTexts: portSourceAddr.setDescription('A source address that has been seen on this port.')
portActiveUsers = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portActiveUsers.setStatus('optional')
if mibBuilder.loadTexts: portActiveUsers.setDescription('The number of active users seen on this port.')
portTopologyType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("station", 1), ("trunk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopologyType.setStatus('mandatory')
if mibBuilder.loadTexts: portTopologyType.setDescription('The topological type of the port. Station referring to a port that has seen 1 or 0 addresses. Trunk referring to a port that has seen more than 1 address.')
portLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("linkSignalInactive", 1), ("linkSignalActive", 2), ("linkSignalNotSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkStatus.setDescription('The state of the link signal for this port')
portStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("segmented", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portStatus.setDescription('The hardware status of the port.')
portTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portTotalPkts.setDescription('The number of packets detected by this port.')
portTotalErrors = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portTotalErrors.setDescription('The sum of all alignment, CRC, out-of-window collisions, runt, and giant errors detected by this port.')
portTransmitColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTransmitColls.setStatus('mandatory')
if mibBuilder.loadTexts: portTransmitColls.setDescription('The number of transmit collisions detected by this port.')
portRecColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRecColls.setStatus('mandatory')
if mibBuilder.loadTexts: portRecColls.setDescription('The number of receive collsions detected by this port.')
portAligns = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAligns.setStatus('mandatory')
if mibBuilder.loadTexts: portAligns.setDescription('The number of packets with alignment errors detected by this port.')
portCRCs = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCRCs.setStatus('mandatory')
if mibBuilder.loadTexts: portCRCs.setDescription('The number of packets with bad CRC detected by this port.')
portRunts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRunts.setStatus('mandatory')
if mibBuilder.loadTexts: portRunts.setDescription('The number of runt frames detected by this port.')
portOOWColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOOWColls.setStatus('mandatory')
if mibBuilder.loadTexts: portOOWColls.setDescription('The number of out-of-window collisions detected by this port.')
portNoResources = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNoResources.setStatus('mandatory')
if mibBuilder.loadTexts: portNoResources.setDescription('The number of no resource condtions detected by this port.')
portRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRecBytes.setStatus('mandatory')
if mibBuilder.loadTexts: portRecBytes.setDescription('The number of bytes detected on the network by this port.')
portGiantFrames = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGiantFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portGiantFrames.setDescription('The number of longer than 1518 byte packets detected by this port.')
portRedundCrt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundCrt.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundCrt.setDescription('The redundant circuit with which this port is associated.')
portRedundType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("notUsed", 1), ("primary", 3), ("backup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundType.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundType.setDescription('The type of port this port is in the redundant circuit.')
portRedundStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notUsed", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundStatus.setDescription('The current state of this port in the redundant circuit.')
portForceTrunkType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notForced", 1), ("forced", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portForceTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: portForceTrunkType.setDescription('This variable forces a port to be a trunk port.')
portBroadPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBroadPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portBroadPkts.setDescription('The sum of broadcast packets detected on this port.')
portMultPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMultPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portMultPkts.setDescription('The sum of multicast packets detected on this port.')
stationP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1))
ringP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 2))
stationPortLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkSignalInactive", 1), ("linkSignalActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationPortLinkStatus.setStatus('deprecated')
if mibBuilder.loadTexts: stationPortLinkStatus.setDescription('When station is supplying phantom current the Link Signal is active. When there is no phantom current the Link Signal is inactive.')
stationPortLinkStateTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stationPortLinkStateTime.setStatus('deprecated')
if mibBuilder.loadTexts: stationPortLinkStateTime.setDescription('The amount of time (in seconds) elapsed since the station port last changed state. A write of 0 will reset the elapsed time.')
productRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 5, 1))
target = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1))
targetRevision = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: targetRevision.setStatus('mandatory')
if mibBuilder.loadTexts: targetRevision.setDescription('The revision of the target board.')
targetPortAssociation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: targetPortAssociation.setStatus('mandatory')
if mibBuilder.loadTexts: targetPortAssociation.setDescription('Controls how the front panel ports are associated with the bridge or the repeater. The valid values are: Value AUI Port Fiber Port 0 Bridge Redundant 1 Redundant Bridge 2 Bridge Repeater 3 Repeater Bridge 4 Redundant Repeater 5 Repeater Redundant Note: only values 0 and 1 are valid for rev 2 boards and before. Note: only values 4 and 5 are valid for the IRM2.')
fnb = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1))
fnbConnectedLeft = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectedLeft.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectedLeft.setDescription('The Connected Left board (board n + 1) has the following states: Detached == 1 (Management (only management) detached, read/write). Attached == 2 (Management/AutoMode attached, read/write). Faulted == 3 (Management/AutoMode tried to attach but failed read ONLY).')
fnbConnectedRight = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectedRight.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectedRight.setDescription('The Connected Right board (board n - 1) has the following states: Detached == 1 (Management (only management) detached, read/write). Attached == 2 (Management/AutoMode attached, read/write). Faulted == 3 (Management/AutoMode tried to attach but failed read ONLY).')
fnbBoardBypassState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbBoardBypassState.setStatus('mandatory')
if mibBuilder.loadTexts: fnbBoardBypassState.setDescription('Off == 1 (NOT bypassed). On == 2 (bypassed).')
audibleAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2))
audibleAlarmEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audibleAlarmEnable.setStatus('mandatory')
if mibBuilder.loadTexts: audibleAlarmEnable.setDescription('Allows/disallows the audible alarm to be sounded when a situation occurs that the alarm should be sounded.')
audibleAlarmOff = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audibleAlarmOff.setStatus('mandatory')
if mibBuilder.loadTexts: audibleAlarmOff.setDescription('Turn off a sounding alarm. A read will tell you if the alarm is on or not. A write will stop a sounding alarm.')
mibBuilder.exportSymbols("REPEATER-MIB-2", portTotalPkts=portTotalPkts, soidIRBM=soidIRBM, portTrafficEnable=portTrafficEnable, deviceRecColls=deviceRecColls, portBroadEnable=portBroadEnable, boardTotalPkts=boardTotalPkts, boardOOWColls=boardOOWColls, portTotalErrors=portTotalErrors, bdBroadEnable=bdBroadEnable, sourceAddrPort=sourceAddrPort, portIndex=portIndex, deviceTotalErrors=deviceTotalErrors, portBroad=portBroad, deviceTransmitColls=deviceTransmitColls, portStatus=portStatus, stationP=stationP, boardGiants=boardGiants, devColls=devColls, fnbBoardBypassState=fnbBoardBypassState, deviceRecBytes=deviceRecBytes, boardFirstRingPort=boardFirstRingPort, commonB=commonB, portCollsPortDisable=portCollsPortDisable, redundancyCircuitMACAddrDisp=redundancyCircuitMACAddrDisp, fnbConnectedLeft=fnbConnectedLeft, portActiveUsers=portActiveUsers, redundancyCircuitMACAddrAdd=redundancyCircuitMACAddrAdd, portOOWColls=portOOWColls, fddiB=fddiB, deviceBroadPkts=deviceBroadPkts, boardTotalStationPorts=boardTotalStationPorts, portErrorThreshold=portErrorThreshold, portRecColls=portRecColls, devBroadThreshold=devBroadThreshold, port=port, devErrorSource=devErrorSource, deviceFDDIBoardMap=deviceFDDIBoardMap, boardAligns=boardAligns, soidMINIMMAC=soidMINIMMAC, portRedundType=portRedundType, deviceGiantFrames=deviceGiantFrames, redundancyNumBPs=redundancyNumBPs, portErrorPortDisable=portErrorPortDisable, ctIPDefaultFrameType=ctIPDefaultFrameType, alarm=alarm, portGiantFrames=portGiantFrames, portBroadPkts=portBroadPkts, portTraffic=portTraffic, mACAddress=mACAddress, bdErrorSource=bdErrorSource, deviceTotalPkts=deviceTotalPkts, portError=portError, portTransmitColls=portTransmitColls, deviceLinkTraps=deviceLinkTraps, boardType=boardType, redundancyRetryCount=redundancyRetryCount, deviceTRTokenRingBoardMap=deviceTRTokenRingBoardMap, bdCollsBdDisable=bdCollsBdDisable, deviceImimOccupiedSlots=deviceImimOccupiedSlots, device=device, deviceResetRedundancy=deviceResetRedundancy, devBroadEnable=devBroadEnable, devBroad=devBroad, portRunts=portRunts, targetRevision=targetRevision, deviceSrcAddrAgingTime=deviceSrcAddrAgingTime, boardMultPkts=boardMultPkts, deviceTimeBase=deviceTimeBase, soidIRM2=soidIRM2, target=target, deviceTRTotalTokenRingBoards=deviceTRTotalTokenRingBoards, bdBroadDisable=bdBroadDisable, boardName=boardName, boardModeStatus=boardModeStatus, currentTime=currentTime, portNoResources=portNoResources, commonD=commonD, portRedundCrt=portRedundCrt, redundancyCircuitTypes=redundancyCircuitTypes, deviceRestart=deviceRestart, portCollsEnable=portCollsEnable, deviceSrcAddrTraps=deviceSrcAddrTraps, deviceSlots=deviceSlots, devErrorThreshold=devErrorThreshold, rr2device=rr2device, portAdminState=portAdminState, redundancyCircuitReset=redundancyCircuitReset, boardRecBytes=boardRecBytes, audibleAlarm=audibleAlarm, devAlrm=devAlrm, deviceOOWColls=deviceOOWColls, portTopologyType=portTopologyType, bdCollsEnable=bdCollsEnable, portBroadThreshold=portBroadThreshold, deviceTokenRingBoardMap=deviceTokenRingBoardMap, deviceSegTraps=deviceSegTraps, devTrafficEnable=devTrafficEnable, deviceMultPkts=deviceMultPkts, portMultPkts=portMultPkts, deviceTRTotalTokenRingRings=deviceTRTotalTokenRingRings, productRev1=productRev1, deviceMMACType=deviceMMACType, redundancyTestTod=redundancyTestTod, portRecBytes=portRecBytes, bdBroadThreshold=bdBroadThreshold, bdAlrm=bdAlrm, devicePortsOn=devicePortsOn, redundancyPollInterval=redundancyPollInterval, portErrorEnable=portErrorEnable, deviceRunts=deviceRunts, deviceTRTotalTokenRingRingPorts=deviceTRTotalTokenRingRingPorts, deviceNoResources=deviceNoResources, portColls=portColls, boardRunts=boardRunts, targetPortAssociation=targetPortAssociation, fnb=fnb, boardCRCs=boardCRCs, board=board, repeaterTables=repeaterTables, sourceAddr=sourceAddr, rr2port=rr2port, portSourceAddr=portSourceAddr, deviceActiveUsers=deviceActiveUsers, fnbConnectedRight=fnbConnectedRight, boardNoResources=boardNoResources, boardActiveUsers=boardActiveUsers, boardRingSpeedFault=boardRingSpeedFault, deviceRedundantCts=deviceRedundantCts, bdCollsThreshold=bdCollsThreshold, soidMRXI=soidMRXI, boardTotalPorts=boardTotalPorts, redundancyCircuitEnable=redundancyCircuitEnable, deviceRestoreDefaults=deviceRestoreDefaults, redundancyCircuitPort=redundancyCircuitPort, ethernetP=ethernetP, devCollsEnable=devCollsEnable, ringP=ringP, portCollsThreshold=portCollsThreshold, boardTotalStationPortsOn=boardTotalStationPortsOn, portCRCs=portCRCs, tokenRingD=tokenRingD, audibleAlarmEnable=audibleAlarmEnable, deviceTotalPorts=deviceTotalPorts, deviceResetCounters=deviceResetCounters, bdTrafficEnable=bdTrafficEnable, redundancyCircuitName=redundancyCircuitName, bdBroad=bdBroad, tokenRingB=tokenRingB, portMediaType=portMediaType, commonP=commonP, redundancyCircuitBoards=redundancyCircuitBoards, deviceIPAddress=deviceIPAddress, bdTrafficThreshold=bdTrafficThreshold, bdTraffic=bdTraffic, deviceTRTokenRingPortsOn=deviceTRTokenRingPortsOn, deviceTRTotalTokenRingRingPortsOn=deviceTRTotalTokenRingRingPortsOn, boardRecColls=boardRecColls, portErrorSource=portErrorSource, stationPortLinkStateTime=stationPortLinkStateTime, soidIRMSNMP=soidIRMSNMP, portTrafficPortDisable=portTrafficPortDisable, boardBroadPkts=boardBroadPkts, currentDate=currentDate, deviceOccupiedSlots=deviceOccupiedSlots, boardPortsOn=boardPortsOn, redundancyCircuitMACAddrDel=redundancyCircuitMACAddrDel, sourceAddrBoard=sourceAddrBoard, rr2board=rr2board, ethernetB=ethernetB, devTraffic=devTraffic, boardSpeed=boardSpeed, portRedundStatus=portRedundStatus, deviceType=deviceType, bdErrorThreshold=bdErrorThreshold, devCollsThreshold=devCollsThreshold, devError=devError, redundancy=redundancy, boardTotalRingPorts=boardTotalRingPorts, portTrafficThreshold=portTrafficThreshold, portBroadDisable=portBroadDisable, boardIndex=boardIndex, redundancyPerformTest=redundancyPerformTest, tokenRingP=tokenRingP, deviceTRTotalTokenRingPorts=deviceTRTotalTokenRingPorts, bdColls=bdColls, deviceCRCs=deviceCRCs, boardTransColls=boardTransColls, portForceTrunkType=portForceTrunkType, audibleAlarmOff=audibleAlarmOff, deviceEnetBoardMap=deviceEnetBoardMap, portLinkStatus=portLinkStatus, ethernetD=ethernetD, deviceSrcAddrLocked=deviceSrcAddrLocked, portAlrm=portAlrm, boardTotalErrors=boardTotalErrors, portAligns=portAligns, stationPortLinkStatus=stationPortLinkStatus, devTrafficThreshold=devTrafficThreshold, redundancyCircuitNumAddr=redundancyCircuitNumAddr, deviceAligns=deviceAligns, fddiP=fddiP, bdErrorEnable=bdErrorEnable, deviceName=deviceName, devErrorEnable=devErrorEnable, deviceThdPartyOccupiedSlots=deviceThdPartyOccupiedSlots, boardTotalRingPortsOn=boardTotalRingPortsOn, bdError=bdError, bdTrafficBdDisable=bdTrafficBdDisable, bdErrorBdDisable=bdErrorBdDisable, network=network)

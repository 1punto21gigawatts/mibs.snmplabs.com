#
# PySNMP MIB module CISCO-ATM2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
atmInterfaceConfEntry, = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Integer32, iso, TimeTicks, NotificationType, Counter64, IpAddress, Bits, Unsigned32, MibIdentifier, Gauge32, ModuleIdentity, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Integer32", "iso", "TimeTicks", "NotificationType", "Counter64", "IpAddress", "Bits", "Unsigned32", "MibIdentifier", "Gauge32", "ModuleIdentity", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ciscoAtm2MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 23))
ciscoAtm2MIB.setRevisions(('1998-03-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoAtm2MIB.setRevisionsDescriptions(('Added VPI/VCI range objects from supplemental ATOMMIB',))
if mibBuilder.loadTexts: ciscoAtm2MIB.setLastUpdated('9803040000Z')
if mibBuilder.loadTexts: ciscoAtm2MIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoAtm2MIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoAtm2MIB.setDescription('This MIB Module is a supplement to the ATM-MIB [1]. It is an adaptation of a portion of the ATOMMIB supplemental MIB.')
ciscoatm2MIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 23, 1))
ciscoatmSigStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1), )
if mibBuilder.loadTexts: ciscoatmSigStatTable.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigStatTable.setDescription('This table contains ATM interface signalling monitoring , one entry per ATM signalling interface.')
ciscoatmSigStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ciscoatmSigStatEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigStatEntry.setDescription('This list contains signalling statistics variables.')
ciscoatmSigSSCOPConEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigSSCOPConEvents.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSSCOPConEvents.setDescription('SSCOP Connection Events Counter. This counter counts the sum of the following errors: 1) SSCOP Connection Disconnect Counter The abnormal occurrence of this event is characterized by the expiry of Timer_NO_RESPONSE. (This event is communicated to the layer management with MAA-ERROR code P. See ITU-T Q.2110 [13].) 2) SSCOP Connection Initiation Failure This condition indicates the inability to establish an SSCOP connection. This event occurs whenever the number of expiries of the connection control timer (Timer_CC) exceeds the MaxCC or upon receipt of a connection reject message BGREJ PDU. (This event is communicated to layer management with MAA-ERROR code O. See ITU-T Q.2110.) 3) SSCOP Connection Re-Establ/Resynch This event occurs upon receipt of a BGN PDU or RESYNC PDU.')
ciscoatmSigSSCOPErrdPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigSSCOPErrdPdus.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSSCOPErrdPdus.setDescription('SSCOP Errored PDUs Counter. This counter counts the sum of the following errors: 1) Invalid PDUs. These are defined in SSCOP and consist of PDUs with incorrect length (MAA-ERROR code U), undefined PDU type code or not 32-bit aligned. 2) PDUs that result in MAA error codes and are discarded See Errors A-M and Q-T defined in ITU-T Q.2110 [13].')
ciscoatmSigDetectSetupAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectSetupAttempts.setDescription('Call Setup Attempts Counter. This counter counts the number of call setup attempts(both successful and unsuccessful) detected on this interface.')
ciscoatmSigEmitSetupAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitSetupAttempts.setDescription('Call Setup Attempts Counter. This counter counts the number of call setup attempts(both successful and unsuccessful) transmitted on this interface.')
ciscoatmSigDetectUnavailRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectUnavailRoutes.setDescription('Number of Route Unavailability detected on this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 1 unallocated (unassigned) number 2 no route to specified transit network 3 no route to destination 88 incompatible destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigEmitUnavailRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitUnavailRoutes.setDescription('Number of Route Unavailability transmitted from this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 1 unallocated (unassigned) number 2 no route to specified transit network 3 no route to destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigDetectUnavailResrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectUnavailResrcs.setDescription('Number of Resource Unavailability detected on this interfrace. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 35 requested VPCI/VCI not available 37 user cell rate not available (UNI3.1 only) 38 network out of order 41 temporary failure 45 no VPCI/VCI available 47 resource unavailable, unspecified 49 Quality of Service unavailable 51 user cell rate not available (UNI3.0 only) 58 bearer capability not presently available 63 Service or option not available, unspecified 92 too many pending add party requests NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigEmitUnavailResrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitUnavailResrcs.setDescription('Number of Resource Unavailability transmitted from this interfrace. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 35 requested VPCI/VCI not available 37 user cell rate not available (UNI3.1 only) 38 network out of order 41 temporary failure 45 no VPCI/VCI available 47 resource unavailable, unspecified 49 Quality of Service unavailable 51 user cell rate not available (UNI3.0 only) 58 bearer capability not presently available 63 Service or option not available, unspecified 92 too many pending add party requests NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigDetectCldPtyEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call detected on this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 17 user busy 18 no user responding 21 call rejected 22 number changed 23 user rejects all calls with calling line id restriction (CLIR) 27 destination out of order 31 normal, unspecified 88 incompatible destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted. Note: Cause Value #30 'response to STATUS ENQUIRY' was not included in this memo since it did not apply to a hard failure.")
ciscoatmSigEmitCldPtyEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call transmitted from this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 17 user busy 18 no user responding 21 call rejected 22 number changed 23 user rejects all calls with calling line id restriction (CLIR) 27 destination out of order 31 normal, unspecified 88 incompatible destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted. Note: Cause Value #30 'response to STATUS ENQUIRY' was not included in this memo since it did not apply to a hard failure.")
ciscoatmSigDetectMsgErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectMsgErrors.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectMsgErrors.setDescription("Number of Incorrect Messages detected on this interface. The Incorrect Messages Counter reflects any sort of incorrect information in a message. This includes: - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT, and STATUS messages transmitted, that contain any of the Cause values listed below. - Ignored messages. These messages are dropped because the message was so damaged that it could not be further processed. A list of dropped messages is compiled below: 1. Message with invalid protocol discriminator 2. Message with errors in the call reference I.E. - Bits 5-8 of the first octet not equal to '0000' - Bits 1-4 of the first octet indicating a length other than 3 octets - RELEASE COMPLETE message received with a call reference that does not relate to a call active or in progress - SETUP message received with call reference flag incorrectly set to 1 - SETUP message received with a call reference for a call that is already active or in progress. 3. Message too short The following cause values are monitored by this counter (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 10 VPCI/VCI unacceptable (UNI3.0 only) 36 VPCI/VCI assignment failure (UNI3.1 only) 81 invalid call reference value 82 identified channel does not exist 89 invalid endpoint reference 96 mandatory information element is missing 97 message type non-existent or not implemented 99 information element non-existent or not implemented 100 invalid information element contents 101 message not compatible with call state 104 incorrect message length 111 protocol error, unspecified NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
ciscoatmSigEmitMsgErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitMsgErrors.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitMsgErrors.setDescription("Number of Incorrect Messages detected on this interface. The Incorrect Messages Counter reflects any sort of incorrect information in a message. This includes: - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT, and STATUS messages transmitted or received, that contain any of the Cause values listed below. - Ignored messages. These messages are dropped because the message was so damaged that it could not be further processed. A list of dropped messages is compiled below: 1. Message with invalid protocol discriminator 2. Message with errors in the call reference I.E. - Bits 5-8 of the first octet not equal to '0000' - Bits 1-4 of the first octet indicating a length other than 3 octets - RELEASE COMPLETE message received with a call reference that does not relate to a call active or in progress - SETUP message received with call reference flag incorrectly set to 1 - SETUP message received with a call reference for a call that is already active or in progress. 3. Message too short The following cause values are monitored by this counter (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 10 VPCI/VCI unacceptable (UNI3.0 only) 36 VPCI/VCI assignment failure (UNI3.1 only) 81 invalid call reference value 82 identified channel does not exist 89 invalid endpoint reference 96 mandatory information element is missing 97 message type non-existent or not implemented 99 information element non-existent or not implemented 100 invalid information element contents 101 message not compatible with call state 104 incorrect message length 111 protocol error, unspecified NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
ciscoatmSigDetectClgPtyEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectClgPtyEvents.setDescription('Number of Calling Party Events detected on this interface. This counter monitors error events that occur due to the originating user doing something wrong. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 28 invalid number format (address incomplete) 43 access information discarded 57 bearer capability not authorized 65 bearer capability not implemented 73 unsupported combination of traffic parameters 78 AAL parameters cannot be supported (UNI3.1 only) 91 invalid transit network selection 93 AAL parameters cannot be supported (UNI3.0 only) NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigEmitClgPtyEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitClgPtyEvents.setDescription('Number of Calling Party Events transmitted from this interface. This counter monitors error events that occur due to the originating user doing something wrong. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE mesg for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 28 invalid number format (address incomplete) 43 access information discarded 57 bearer capability not authorized 65 bearer capability not implemented 73 unsupported combination of traffic parameters 78 AAL parameters cannot be supported (UNI3.1 only) 91 invalid transit network selection 93 AAL parameters cannot be supported (UNI3.0 only) NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
ciscoatmSigDetectTimerExpireds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectTimerExpireds.setDescription("Number of Timer Expiries detected on this interface. The Timer Expiries Counter provides a count of network timer expiries, and to some extent, host or switch timer expiries. The conditions for incrementing this counter are: - Expiry of any network timer - Receipt of a RELEASE or RELEASE COMPLETE message with Cause #102, 'recovery on timer expiry'. NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
ciscoatmSigEmitTimerExpireds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitTimerExpireds.setDescription("Number of Timer Expiries transmitted from this interface. The Timer Expiries Counter provides a count of network timer expiries, and to some extent, host or switch timer expiries. The conditions for incrementing this counter are: - Expiry of any network timer - Receipt of a RELEASE or RELEASE COMPLETE message with Cause #102, 'recovery on timer expiry'. NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
ciscoatmSigDetectRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigDetectRestarts.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigDetectRestarts.setDescription('Number of Restart Activity errors detected on this interface. The Restart Activity Counter provides a count of host, switch, or network restart activity. This counter is incremented when receiving a RESTART message.')
ciscoatmSigEmitRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigEmitRestarts.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigEmitRestarts.setDescription('Number of Restart Activity errors transmitted from this interface. The Restart Activity Counter provides a count of host, switch, or network restart activity. This counter is incremented when transmitting a RESTART message.')
ciscoatmSigInEstabls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigInEstabls.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigInEstabls.setDescription('Number of SVC VCCs established at this signalling entity for incoming connections.')
ciscoatmSigOutEstabls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmSigOutEstabls.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigOutEstabls.setDescription('Number of SVC VCCs established at this signalling entity for outgoing connections.')
ciscoatmSigSupportTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2), )
if mibBuilder.loadTexts: ciscoatmSigSupportTable.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM signalling interface.')
ciscoatmSigSupportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ciscoatmSigSupportEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportEntry.setDescription('This list contains signalling configuration parameters and state variables.')
ciscoatmSigSupportClgPtyNumDel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportClgPtyNumDel.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportClgPtyNumDel.setDescription('This object indicates whether the Calling Party Number Information Element is transferred to the called party address. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmSigSupportClgPtySubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportClgPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportClgPtySubAddr.setDescription("This object indicates whether to accept and transfer the Calling Party Subaddress Information Element from the calling party to the called party. Calling party subaddress information shall only be transferred to the called party if calling party number delivery is enabled (i.e., atmSigSupportClgPtyNumDel = 'enabled(1)'. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.")
ciscoatmSigSupportCldPtySubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportCldPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportCldPtySubAddr.setDescription('This object indicates whether to accept, transfer, and deliver the Called Party Subaddress Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmSigSupportHiLyrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportHiLyrInfo.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportHiLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver the Broadband High Layer Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmSigSupportLoLyrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportLoLyrInfo.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportLoLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver the Broadband Low Layer Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmSigSupportBlliRepeatInd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportBlliRepeatInd.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportBlliRepeatInd.setDescription("This object indicates whether to accept, transfer, and deliver the Broadband Repeat Indicator with two or three instances of the Broadband Low Layer Information Element for low layer information selection from the calling party to the called party. This object shall only be transferred if atmSigSupportLoLyrInfo = 'enabled(1)'. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.")
ciscoatmSigSupportAALInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportAALInfo.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportAALInfo.setDescription('This object indicates whether to accept, transfer, and deliver the ATM Adaptation Layer Parameters Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmSigSupportUnknownIe = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmSigSupportUnknownIe.setStatus('current')
if mibBuilder.loadTexts: ciscoatmSigSupportUnknownIe.setDescription('This object indicates whether to accept, transfer, and deliver the unknown Information Element from the calling party to the called party, when the IE instruction field flag is set to zero.When the IE action flag is set to one, the IE action indicator should be followed regardless of this configuration. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
ciscoatmInterfaceExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3), )
if mibBuilder.loadTexts: ciscoatmInterfaceExtTable.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceExtTable.setDescription('This table contains ATM interface configuration not defined in the atmInterfaceConfTable from the ATM-MIB. This table has information on the VPI/VCI range.')
ciscoatmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1), )
atmInterfaceConfEntry.registerAugmentions(("CISCO-ATM2-MIB", "ciscoatmInterfaceExtEntry"))
ciscoatmInterfaceExtEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: ciscoatmInterfaceExtEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceExtEntry.setDescription('An entry extends the atmInterfaceConfEntry defined in ATM-MIB. Each entry corresponds to an ATM interface.')
ciscoatmInterfaceConfMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmInterfaceConfMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceConfMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual path connections.')
ciscoatmInterfaceCurrentMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface may currently allocate to switched virtual path connections. This value is the minimum of ciscoatmInterfaceConfMaxSvpcVpi, and the ciscoatmInterfaceConfMaxSvpcVpi of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the maximum VPI that can be allocated to SVPCs on the interface, then the value of this object must equal ciscoatmInterfaceConfMaxSvpcVpi.")
ciscoatmInterfaceConfMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmInterfaceConfMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceConfMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual channel connections.')
ciscoatmInterfaceCurrentMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface may currently allocate to switched virtual channel connections. This value is the minimum of ciscoatmInterfaceConfMaxSvccVpi, and the ciscoatmInterfaceConfMaxSvccVpi of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the maximum VPI that can be allocated to SVCCs on the interface, then the value of this object must equal ciscoatmInterfaceConfMaxSvccVpi.")
ciscoatmInterfaceConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoatmInterfaceConfMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceConfMinSvccVci.setDescription('The minimum VCI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual channel connections.')
ciscoatmInterfaceCurrentMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 23, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: ciscoatmInterfaceCurrentMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM interface may currently allocate to switched virtual channel connections. This value is the maximum of ciscoatmInterfaceConfMinSvccVci, and the ciscoatmInterfaceConfMinSvccVci of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the minimum VCI that can be allocated to SVCCs on the interface, then the value of this object must equal ciscoatmInterfaceConfMinSvccVci.")
ciscoatm2MIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 23, 3))
ciscoatm2MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 1))
ciscoatm2MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 2))
ciscoatm2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 2, 1)).setObjects(("CISCO-ATM2-MIB", "ciscoAtmSwitchServcHostGroup"), ("CISCO-ATM2-MIB", "ciscoAtmSwitchServcGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoatm2MIBCompliance = ciscoatm2MIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoatm2MIBCompliance.setDescription('The compliance statement for SNMP entities which represent ATM interfaces. The compliance statements are used to determine if a particular group or object applies to hosts, networks/switches, or both.')
ciscoatm2MIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 2, 2)).setObjects(("CISCO-ATM2-MIB", "ciscoAtmSwitchServcHostGroup"), ("CISCO-ATM2-MIB", "ciscoAtmSwitchServcHostGroup2"), ("CISCO-ATM2-MIB", "ciscoAtmSwitchServcGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoatm2MIBCompliance2 = ciscoatm2MIBCompliance2.setStatus('current')
if mibBuilder.loadTexts: ciscoatm2MIBCompliance2.setDescription('The compliance statement for SNMP entities which represent ATM interfaces. The compliance statements are used to determine if a particular group or object applies to hosts, networks/switches, or both.')
ciscoAtmSwitchServcHostGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 1, 1)).setObjects(("CISCO-ATM2-MIB", "ciscoatmSigSSCOPConEvents"), ("CISCO-ATM2-MIB", "ciscoatmSigSSCOPErrdPdus"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectSetupAttempts"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitSetupAttempts"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectUnavailRoutes"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitUnavailRoutes"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectUnavailResrcs"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitUnavailResrcs"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectCldPtyEvents"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitCldPtyEvents"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectMsgErrors"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitMsgErrors"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectClgPtyEvents"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitClgPtyEvents"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectTimerExpireds"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitTimerExpireds"), ("CISCO-ATM2-MIB", "ciscoatmSigDetectRestarts"), ("CISCO-ATM2-MIB", "ciscoatmSigEmitRestarts"), ("CISCO-ATM2-MIB", "ciscoatmSigInEstabls"), ("CISCO-ATM2-MIB", "ciscoatmSigOutEstabls"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmSwitchServcHostGroup = ciscoAtmSwitchServcHostGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSwitchServcHostGroup.setDescription('A collection of objects providing information for a Switch/Service/Host that implements ATM interfaces.')
ciscoAtmSwitchServcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 1, 3)).setObjects(("CISCO-ATM2-MIB", "ciscoatmSigSupportClgPtyNumDel"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportClgPtySubAddr"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportCldPtySubAddr"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportHiLyrInfo"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportLoLyrInfo"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportBlliRepeatInd"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportAALInfo"), ("CISCO-ATM2-MIB", "ciscoatmSigSupportUnknownIe"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmSwitchServcGroup = ciscoAtmSwitchServcGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSwitchServcGroup.setDescription('A collection of objects providing information for a Switch/Service that implements ATM interfaces.')
ciscoAtmSwitchServcHostGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 23, 3, 1, 4)).setObjects(("CISCO-ATM2-MIB", "ciscoatmInterfaceConfMaxSvpcVpi"), ("CISCO-ATM2-MIB", "ciscoatmInterfaceCurrentMaxSvpcVpi"), ("CISCO-ATM2-MIB", "ciscoatmInterfaceConfMaxSvccVpi"), ("CISCO-ATM2-MIB", "ciscoatmInterfaceCurrentMaxSvccVpi"), ("CISCO-ATM2-MIB", "ciscoatmInterfaceConfMinSvccVci"), ("CISCO-ATM2-MIB", "ciscoatmInterfaceCurrentMinSvccVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmSwitchServcHostGroup2 = ciscoAtmSwitchServcHostGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSwitchServcHostGroup2.setDescription('A collection of objects providing information regarding VPI/VCI range for SVCCs and SVPCs for a Switch/Service/Host that implements ATM interfaces.')
mibBuilder.exportSymbols("CISCO-ATM2-MIB", ciscoatmSigStatTable=ciscoatmSigStatTable, ciscoatmInterfaceCurrentMaxSvccVpi=ciscoatmInterfaceCurrentMaxSvccVpi, ciscoatmSigSupportClgPtyNumDel=ciscoatmSigSupportClgPtyNumDel, ciscoAtmSwitchServcHostGroup=ciscoAtmSwitchServcHostGroup, ciscoatmInterfaceCurrentMinSvccVci=ciscoatmInterfaceCurrentMinSvccVci, ciscoatmSigDetectCldPtyEvents=ciscoatmSigDetectCldPtyEvents, ciscoatmInterfaceExtTable=ciscoatmInterfaceExtTable, ciscoatm2MIBCompliance=ciscoatm2MIBCompliance, ciscoatmSigEmitSetupAttempts=ciscoatmSigEmitSetupAttempts, ciscoatm2MIBConformance=ciscoatm2MIBConformance, ciscoAtmSwitchServcGroup=ciscoAtmSwitchServcGroup, ciscoatmInterfaceCurrentMaxSvpcVpi=ciscoatmInterfaceCurrentMaxSvpcVpi, ciscoatmSigEmitClgPtyEvents=ciscoatmSigEmitClgPtyEvents, ciscoatmSigDetectUnavailRoutes=ciscoatmSigDetectUnavailRoutes, ciscoatm2MIBObjects=ciscoatm2MIBObjects, ciscoatmSigEmitCldPtyEvents=ciscoatmSigEmitCldPtyEvents, ciscoatmSigSupportHiLyrInfo=ciscoatmSigSupportHiLyrInfo, ciscoatmInterfaceConfMaxSvccVpi=ciscoatmInterfaceConfMaxSvccVpi, ciscoatmSigSupportBlliRepeatInd=ciscoatmSigSupportBlliRepeatInd, ciscoatmSigEmitRestarts=ciscoatmSigEmitRestarts, ciscoatmSigSupportAALInfo=ciscoatmSigSupportAALInfo, ciscoatmSigSupportEntry=ciscoatmSigSupportEntry, ciscoatmSigSupportCldPtySubAddr=ciscoatmSigSupportCldPtySubAddr, ciscoatmSigEmitTimerExpireds=ciscoatmSigEmitTimerExpireds, ciscoatmSigEmitMsgErrors=ciscoatmSigEmitMsgErrors, ciscoatm2MIBCompliances=ciscoatm2MIBCompliances, ciscoAtmSwitchServcHostGroup2=ciscoAtmSwitchServcHostGroup2, ciscoatm2MIBCompliance2=ciscoatm2MIBCompliance2, ciscoatmSigSSCOPConEvents=ciscoatmSigSSCOPConEvents, ciscoatmSigSupportUnknownIe=ciscoatmSigSupportUnknownIe, ciscoatmSigDetectMsgErrors=ciscoatmSigDetectMsgErrors, ciscoatmSigStatEntry=ciscoatmSigStatEntry, ciscoatmInterfaceConfMaxSvpcVpi=ciscoatmInterfaceConfMaxSvpcVpi, ciscoatmSigOutEstabls=ciscoatmSigOutEstabls, ciscoAtm2MIB=ciscoAtm2MIB, ciscoatmSigSupportTable=ciscoatmSigSupportTable, ciscoatmInterfaceConfMinSvccVci=ciscoatmInterfaceConfMinSvccVci, ciscoatmSigDetectClgPtyEvents=ciscoatmSigDetectClgPtyEvents, ciscoatm2MIBGroups=ciscoatm2MIBGroups, ciscoatmSigSupportClgPtySubAddr=ciscoatmSigSupportClgPtySubAddr, PYSNMP_MODULE_ID=ciscoAtm2MIB, ciscoatmSigInEstabls=ciscoatmSigInEstabls, ciscoatmSigDetectSetupAttempts=ciscoatmSigDetectSetupAttempts, ciscoatmSigSSCOPErrdPdus=ciscoatmSigSSCOPErrdPdus, ciscoatmSigEmitUnavailResrcs=ciscoatmSigEmitUnavailResrcs, ciscoatmInterfaceExtEntry=ciscoatmInterfaceExtEntry, ciscoatmSigEmitUnavailRoutes=ciscoatmSigEmitUnavailRoutes, ciscoatmSigDetectRestarts=ciscoatmSigDetectRestarts, ciscoatmSigSupportLoLyrInfo=ciscoatmSigSupportLoLyrInfo, ciscoatmSigDetectTimerExpireds=ciscoatmSigDetectTimerExpireds, ciscoatmSigDetectUnavailResrcs=ciscoatmSigDetectUnavailResrcs)

#
# PySNMP MIB module WL400-SNMPGEN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/WL400-SNMPGEN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:36:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
MibIdentifier, IpAddress, Unsigned32, NotificationType, ObjectIdentity, iso, ModuleIdentity, TimeTicks, Counter32, Counter64, Integer32, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "IpAddress", "Unsigned32", "NotificationType", "ObjectIdentity", "iso", "ModuleIdentity", "TimeTicks", "Counter32", "Counter64", "Integer32", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TextualConvention")
wl400Generic, wl400Modules = mibBuilder.importSymbols("WL400-GLOBAL-REG", "wl400Generic", "wl400Modules")
snmpGenMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 232, 143, 1, 3))
if mibBuilder.loadTexts: snmpGenMIBModule.setLastUpdated('9905260000Z')
if mibBuilder.loadTexts: snmpGenMIBModule.setOrganization('Compaq Computer Corporation')
if mibBuilder.loadTexts: snmpGenMIBModule.setContactInfo(' Name: Compaq Computer Corporation Address: 20555 SH 249 Zip: 77070 City: Houston Country: USA Phone: Fax: e-mail: ')
if mibBuilder.loadTexts: snmpGenMIBModule.setDescription('The Compaq WL400 SNMP General MIB Module.')
snmpGenMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 144, 1))
snmpGenConf = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 144, 1, 1))
snmpGenGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 144, 1, 1, 1))
snmpGenCompl = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 144, 1, 1, 2))
snmpGenObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 144, 1, 2))
snmpGenReadCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGenReadCommunityString.setStatus('current')
if mibBuilder.loadTexts: snmpGenReadCommunityString.setDescription('The community string to use for SNMP communication with this entity when the SNMP operation is a read operation.')
snmpGenWriteCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGenWriteCommunityString.setStatus('current')
if mibBuilder.loadTexts: snmpGenWriteCommunityString.setDescription("The community string to use for SNMP communication with this entity when the SNMP operation is a SET Request. When read, this object has an undefined value. When written, subsequent SNMP SET operations must use the new community string to be accepted as authentic. When the reset button is pressed on the Access Point, this variable is reset to 'private'. This is also the default manufacturer value. ")
snmpGenTrapDstMaxTableLength = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpGenTrapDstMaxTableLength.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstMaxTableLength.setDescription('The maximum number of entries in the Trap Destination Table.')
snmpGenTrapDstTable = MibTable((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4), )
if mibBuilder.loadTexts: snmpGenTrapDstTable.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstTable.setDescription('The table containing management targets where notifications (SNMP traps) must be sent to. Syslog messages also use this table.')
snmpGenTrapDstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4, 1), ).setIndexNames((0, "WL400-SNMPGEN-MIB", "snmpGenTrapDstIndex"))
if mibBuilder.loadTexts: snmpGenTrapDstEntry.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstEntry.setDescription('An entry in the Trap Destination table.')
snmpGenTrapDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: snmpGenTrapDstIndex.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstIndex.setDescription('An index into the Trap Destination table.')
snmpGenTrapDstIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpGenTrapDstIpAddress.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstIpAddress.setDescription('The IP address of a management station to send traps to.')
snmpGenTrapDstType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trapOnly", 1), ("syslogOnly", 2), ("trapAndSyslog", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpGenTrapDstType.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstType.setDescription('The type indicates what kind of notification is sent. When set to trapOnly(1), only SNMP traps are sent to the IP address. When set to syslogOnly(2), only syslog messages are sent and when set to trapAndSyslog(3), both a trap and a syslog message will be sent.')
snmpGenTrapDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpGenTrapDstRowStatus.setStatus('current')
if mibBuilder.loadTexts: snmpGenTrapDstRowStatus.setDescription('The status value for creating and deleting rows in this table.')
snmpGenLockStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGenLockStatus.setStatus('current')
if mibBuilder.loadTexts: snmpGenLockStatus.setDescription("This object can be used to lock the SNMP agent. When locked, the agent becomes read-only, i.e. no objects can be written any more. This is useful in a relatively insecure SNMPv1 environment when the network administrator has configured the device and does not intend to change it. This variable can only be set to locked(1). When pressing the reset button on the Access Point, this variable is reset to unlocked(2) and the snmpGenWriteCommunityString is reset to 'private'.")
snmpGenChangeIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGenChangeIPAddress.setStatus('current')
if mibBuilder.loadTexts: snmpGenChangeIPAddress.setDescription("This object is used to change the fixed or 'remembered' IP address of an Access Point. When there is a DHCP/BOOTP server on the network, this variable is not needed. When there is no DHCP/BOOTP server for the IP subnet, the Access Point will try to use the IP address gotten from a previous BOOTP reply (which gives an infinite lease) or an infinite DHCP lease. When there was no previous BOOTP reply, the Access Point can be given an IP address using this variable. Also when the current IP address of the Access Point is invalid for the current IP subnet, this variable can be set by sending an SNMP SET request to the multicast address 224.0.1.43. The MAC address included here ensures that only the right Access Point will accept the SET Request. The IP address given through this variable is considered an infinite lease by the Access Point. The format of this variable is as follows: MAC Address: 6 octets IP Address: 4 octets (network byte order) IP Subnet Mask: 4 octets (network byte order) IP Default Router: 4 octets (network byte order)")
snmpGenUseDHCP = MibScalar((1, 3, 6, 1, 4, 1, 232, 144, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("always", 1), ("smart", 2), ("never", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGenUseDHCP.setStatus('current')
if mibBuilder.loadTexts: snmpGenUseDHCP.setDescription('This object controls DHCP operation. When set to always(1), the Access Point will not assume an infinite lease it was given but continue trying to obtain an IP address using DHCP. The Access Point can only see the difference between an infinite lease and a finite lease because there is no clock running when the device is shut down. When set to smart(2), the Access Point will use DHCP when it does not have an infinite lease. When it does have an infinite lease, it quickly tries to contact a DHCP server (because it may now be in a new IP subnet) using one DHCPREQUEST and one DHCPDISCOVER. If no replies are received, it will automatically assume its given (infinite) address within a few seconds after reboot. When set to never(3), the Access Point will not use DHCP if it has an infinite address. It will immediately assume that address after a reboot. Note that the Access Point requires a valid (not NULL) IP address for this object to be set to never(3).')
snmpGenBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 232, 144, 1, 1, 1, 1)).setObjects(("WL400-SNMPGEN-MIB", "snmpGenReadCommunityString"), ("WL400-SNMPGEN-MIB", "snmpGenWriteCommunityString"), ("WL400-SNMPGEN-MIB", "snmpGenTrapDstMaxTableLength"), ("WL400-SNMPGEN-MIB", "snmpGenTrapDstIpAddress"), ("WL400-SNMPGEN-MIB", "snmpGenTrapDstType"), ("WL400-SNMPGEN-MIB", "snmpGenTrapDstRowStatus"), ("WL400-SNMPGEN-MIB", "snmpGenLockStatus"), ("WL400-SNMPGEN-MIB", "snmpGenChangeIPAddress"), ("WL400-SNMPGEN-MIB", "snmpGenUseDHCP"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snmpGenBasicGroup = snmpGenBasicGroup.setStatus('current')
if mibBuilder.loadTexts: snmpGenBasicGroup.setDescription('The snmp general group.')
snmpGenBasicCompl = ModuleCompliance((1, 3, 6, 1, 4, 1, 232, 144, 1, 1, 2, 1)).setObjects(("WL400-SNMPGEN-MIB", "snmpGenBasicGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snmpGenBasicCompl = snmpGenBasicCompl.setStatus('current')
if mibBuilder.loadTexts: snmpGenBasicCompl.setDescription('The implementation requirements for an IEEE 802.11 Station.')
mibBuilder.exportSymbols("WL400-SNMPGEN-MIB", snmpGenBasicCompl=snmpGenBasicCompl, snmpGenTrapDstType=snmpGenTrapDstType, snmpGenGroups=snmpGenGroups, snmpGenTrapDstMaxTableLength=snmpGenTrapDstMaxTableLength, snmpGenTrapDstIpAddress=snmpGenTrapDstIpAddress, PYSNMP_MODULE_ID=snmpGenMIBModule, snmpGenBasicGroup=snmpGenBasicGroup, snmpGenTrapDstTable=snmpGenTrapDstTable, snmpGenObjs=snmpGenObjs, snmpGenLockStatus=snmpGenLockStatus, snmpGenReadCommunityString=snmpGenReadCommunityString, snmpGenTrapDstEntry=snmpGenTrapDstEntry, snmpGenChangeIPAddress=snmpGenChangeIPAddress, snmpGenTrapDstIndex=snmpGenTrapDstIndex, snmpGenCompl=snmpGenCompl, snmpGenWriteCommunityString=snmpGenWriteCommunityString, snmpGenMIB=snmpGenMIB, snmpGenMIBModule=snmpGenMIBModule, snmpGenUseDHCP=snmpGenUseDHCP, snmpGenTrapDstRowStatus=snmpGenTrapDstRowStatus, snmpGenConf=snmpGenConf)

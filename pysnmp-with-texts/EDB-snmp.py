#
# PySNMP MIB module EDB-snmp (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EDB-snmp
# Produced by pysmi-0.3.4 at Wed May  1 12:59:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Gauge32, Bits, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Unsigned32, NotificationType, ObjectIdentity, Counter32, NotificationType, TimeTicks, Integer32, IpAddress, mgmt, internet = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "Bits", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Unsigned32", "NotificationType", "ObjectIdentity", "Counter32", "NotificationType", "TimeTicks", "Integer32", "IpAddress", "mgmt", "internet")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
fibronics = MibIdentifier((1, 3, 6, 1, 4, 1, 22))
trap = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3))
traprun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3, 1))
traperm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3, 2))
trapvar = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3, 3))
fm800 = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51))
fmsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 1))
fmslot = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 2))
fmlu = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 3))
fmdiag = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 5))
fmsystemrun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 1, 1))
fmsystemperm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 51, 1, 2))
rTrapAddrTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 3, 1, 1), )
if mibBuilder.loadTexts: rTrapAddrTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrTbl.setDescription('Table of managers to which traps must be sent. Up to 10 entries in table')
rTrapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1), ).setIndexNames((0, "EDB-snmp", "rTrapAddrAddr"))
if mibBuilder.loadTexts: rTrapAddrEntry.setStatus('mandatory')
rTrapAddrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrAddr.setDescription('IP address of entity requesting event notification')
rTrapAddrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrComm.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrComm.setDescription('Community name the receiving entity will expect. When reading the instance of this object the value has no meaning.')
rTrapAddrVer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrVer.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrVer.setDescription('Version number supported by destination node')
rTrapAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrType.setDescription('Type of event that should be reported to this address, bit 0 - authentication trap bit 1 - other SNMP traps bit 2 - Error Traps bit 3 - Diagnostic Traps bit 4 - Debug Traps bit 5 - Enterprise Traps other than fmDiagGenericTrap')
rTrapAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrState.setDescription('Determines status of this entry')
rTrapAddrFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("fixed", 0), ("removable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrFlag.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrFlag.setDescription('If the entry is fixed, it can not be deleted because of aging')
rTrapAddrAge = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rTrapAddrAge.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrAge.setDescription('Aging time of the entry (in sec)')
rTrapLearning = MibScalar((1, 3, 6, 1, 4, 1, 22, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rTrapLearning.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapLearning.setDescription('Learn the addresses of the managers automatically.')
rTrapAging = MibScalar((1, 3, 6, 1, 4, 1, 22, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rTrapAging.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAging.setDescription('Time in sec. until we erase a trap entry')
pTrapAddrTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 3, 2, 1), )
if mibBuilder.loadTexts: pTrapAddrTbl.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrTbl.setDescription('Table of managers to which traps must be sent. Up to 10 entries in table')
pTrapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1), ).setIndexNames((0, "EDB-snmp", "pTrapAddrAddr"))
if mibBuilder.loadTexts: pTrapAddrEntry.setStatus('mandatory')
pTrapAddrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrAddr.setDescription('IP address of entity requesting event notification')
pTrapAddrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrComm.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrComm.setDescription('Community name the receiving entity will expect. When reading the instance of this object the value has no meaning.')
pTrapAddrVer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrVer.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrVer.setDescription('Version number supported by destination node')
pTrapAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrType.setDescription('Type of event that should be reported to this address, bit 0 - authentication trap bit 1 - other SNMP traps bit 2 - Error Traps bit 3 - Diagnostic Traps bit 4 - Debug Traps bit 5 - all Enterprise Traps other than fmDiagGenericTrap')
pTrapAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrState.setDescription('Determines status of this entry')
pTrapLearning = MibScalar((1, 3, 6, 1, 4, 1, 22, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapLearning.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapLearning.setDescription('Learn the addresses of the managers automatically.')
pTrapAging = MibScalar((1, 3, 6, 1, 4, 1, 22, 3, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAging.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAging.setDescription('Time in sec. until we erase a trap entry')
fmSystemPSAdmin = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary-power", 1), ("secondary-power", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemPSAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemPSAdmin.setDescription('Changes power supply to primary or secondary. When reading the instance of this object the value has no meaning.')
fmSystemPSOper = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary-power", 1), ("secondary-power", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemPSOper.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemPSOper.setDescription('Which power supply active')
fmSystemPSCfg = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary-power", 1), ("secondary-power", 2), ("primary-and-secondary-power", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemPSCfg.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemPSCfg.setDescription('Configuration of power supply')
fmSystemReset = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 127))).clone(namedValues=NamedValues(("cold-reset", 0), ("warm-reset", 1), ("power-up", 2), ("meaning-less-value", 127)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemReset.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemReset.setDescription('Resetting the CARD. When reading the instance of this object the value has no meaning. cold reset is performed with selftest , while warm start is performed without selftest')
fmSystemSelfTestLevel = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("partial", 1), ("full", 2), ("extended", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemSelfTestLevel.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSelfTestLevel.setDescription('Type of self test to be executed upon cold-reset')
fmSystemVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemVersion.setDescription('Version of the station. The version includes station type, hardware version and software version. The string can include CR and LF')
fmSystemIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemIpAddr.setDescription('IP address of the agent')
fmSystemIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemIPNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemIPNetMask.setDescription('IP Network Mask')
fmSystemIPDefGway = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemIPDefGway.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemIPDefGway.setDescription('Default Gateway Address')
fmSystemFileServer = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemFileServer.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemFileServer.setDescription('IP address to which a TFTP for boot is sent.')
fmSystemBootFile = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemBootFile.setDescription('Path and file name that is sent as a TFTP request')
fmSystemBootMode = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal-memory", 1), ("bootp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemBootMode.setStatus('deprecated')
if mibBuilder.loadTexts: fmSystemBootMode.setDescription('Method for booting')
fmSystemDownLoad = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 127))).clone(namedValues=NamedValues(("download", 1), ("meaning-less-value", 127)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSystemDownLoad.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemDownLoad.setDescription('Downloading the EDB. When reading the instance of this object the value has no meaning.')
fmSystemSlipIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemSlipIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSlipIpAddr.setDescription('SLIP IP address. This is object is available only when slip interface exist ')
fmSystemSlipIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemSlipIPNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSlipIPNetMask.setDescription('SLIP IP Network Mask This is object is available only when slip interface exist ')
fmSystemSlipBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("baud1200", 0), ("baud2400", 1), ("baud4800", 2), ("baud9600", 3), ("baud19200", 4), ("baud38400", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemSlipBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSlipBaudRate.setDescription('SLIP Baud rate This is object is available only when slip interface exist ')
fmSystemSlipParity = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("odd", 1), ("even", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemSlipParity.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSlipParity.setDescription('SLIP Parity This is object is available only when slip interface exist ')
fmSystemSlipStopBits = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("one", 0), ("two", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSystemSlipStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: fmSystemSlipStopBits.setDescription('SLIP Stop Bits This is object is available only when slip interface exist ')
pfmSystemIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemIpAddr.setDescription('IP address of the agent')
pfmSystemIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemIPNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemIPNetMask.setDescription('IP Network Mask')
pfmSystemIPDefGway = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemIPDefGway.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemIPDefGway.setDescription('Default Gateway Address')
pfmSystemFileServer = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemFileServer.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemFileServer.setDescription('IP address to which a TFTP for boot is sent.')
pfmSystemBootFile = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemBootFile.setDescription('Path and file name that is sent as a TFTP request')
pfmSystemBootMode = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal-memory", 1), ("bootp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemBootMode.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemBootMode.setDescription('Method for booting')
pfmSystemReadCommunity = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 13), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemReadCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemReadCommunity.setDescription('Community string for reading When reading the instance of this object the value has no meaning.')
pfmSystemWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 14), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemWriteCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemWriteCommunity.setDescription('Community string for writing When reading the instance of this object the value has no meaning.')
pfmSystemSlipIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemSlipIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemSlipIpAddr.setDescription('SLIP IP address This is object is available only when slip interface exist ')
pfmSystemSlipIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemSlipIPNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemSlipIPNetMask.setDescription('SLIP IP Network Mask This is object is available only when slip interface exist ')
pfmSystemSlipBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("baud1200", 0), ("baud2400", 1), ("baud4800", 2), ("baud9600", 3), ("baud19200", 4), ("baud38400", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemSlipBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemSlipBaudRate.setDescription('SLIP Baud rate This is object is available only when slip interface exist ')
pfmSystemSlipParity = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("odd", 1), ("even", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemSlipParity.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemSlipParity.setDescription('SLIP Parity This is object is available only when slip interface exist ')
pfmSystemSlipStopBits = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 1, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("one", 0), ("two", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSystemSlipStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSystemSlipStopBits.setDescription('SLIP Stop Bits This is object is available only when slip interface exist ')
fmSlotMasterClear = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotMasterClear.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotMasterClear.setDescription('Upon writing, performs a master clear command on all the slots. When reading the instance of this object the value has no meaning.')
fmSlotTable = MibTable((1, 3, 6, 1, 4, 1, 22, 51, 2, 2), )
if mibBuilder.loadTexts: fmSlotTable.setStatus('mandatory')
fmSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1), ).setIndexNames((0, "EDB-snmp", "fmSlotIndex"))
if mibBuilder.loadTexts: fmSlotEntry.setStatus('mandatory')
fmSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotIndex.setDescription('Slot Number')
fmSlotID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 65537, 65540, 65544, 65545, 65548, 65552, 65553, 65560, 65562, 65563, 65568, 65576, 65580, 65584, 65588, 65589, 65591, 65590, 65592, 65594, 65595, 65550, 65551, 65566, 65567, 65578, 65541, 65542, 65543, 65557, 65558, 65559, 131072, 131073, 131075, 131077))).clone(namedValues=NamedValues(("unconfig", 0), ("empty", 1), ("cc832-10", 2), ("cc832-12", 3), ("cc832-20", 4), ("cc832-31", 5), ("cc832-32", 6), ("cc832-41", 7), ("cc832-42", 8), ("cc832-44", 9), ("cc832-46A", 10), ("cc892-832", 65537), ("lc322", 65540), ("cc892-201", 65544), ("cc892-202", 65545), ("cc892-214", 65548), ("cc892-321", 65552), ("cc892-46B", 65553), ("cc892-301", 65560), ("cc892-303", 65562), ("cc892-308", 65563), ("cc892-233", 65568), ("cc892-260", 65576), ("cc892-427", 65580), ("sw892-11X", 65584), ("cc892-432", 65588), ("cc892-420", 65589), ("cc892-421", 65591), ("cc892-422", 65590), ("cc892-401", 65592), ("cc892-240", 65594), ("cc892-241", 65595), ("cc892-211", 65550), ("cc892-212", 65551), ("lc303", 65566), ("lc308", 65567), ("lc312", 65578), ("cc832-10-ID", 65541), ("cc832-12-ID", 65542), ("cc832-20-ID", 65543), ("cc832-41-ID", 65557), ("cc832-42-ID", 65558), ("cc832-44-ID", 65559), ("general-smartcard", 131072), ("lc308-129", 131073), ("lc303-129", 131075), ("lc312-129", 131077)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotID.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotID.setDescription('ID of the card in the slot')
fmSlotDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSlotDescr.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotDescr.setDescription('Ascii string. Description of the card')
fmSlotInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotInfo.setDescription('User general info for the slot. Can be the use of that slot, its location etc...')
fmSlotStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSlotStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotStatus.setDescription('8 bytes. 60 status bits of the card. For more information about the meaning of the status, read the specific user manual of each card. The channel leds are encoded into 2 bytes.')
fmSlotPrevStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSlotPrevStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotPrevStatus.setDescription('8 bytes. Previous 60 status bits of the card. This object id is used mainly for traps (see Card Trap)')
fmSlotRLBSet = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotRLBSet.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotRLBSet.setDescription('Argument: 1 - 4. Perform a RLB set operation on the channel passed as argument. When reading the instance of this object the value has no meaning.')
fmSlotRLBClear = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotRLBClear.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotRLBClear.setDescription('Argument: 1 - 4. Perform a RLB clear operation on the channel passed as argument. When reading the instance of this object the value has no meaning.')
fmSlotExpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotExpCode.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotExpCode.setDescription('Perform an expanded command on the slot. For expanded codes, see specific card user manual. When reading the instance of this object the value has no meaning. Extended command codes for NDS cards ------------------------------------ 1. CC892.303 (Ethernet) Code (Dec/Hex) Command ----------------------------------- 02/02 Detach Port 13 03/03 Attach Port 13 04/04 Detach Port 01 05/05 Attach Port 01 06/06 Detach Port 02 07/07 Attach Port 02 08/08 Detach Port 03 09/09 Attach Port 03 10/0A Detach Port 04 11/0B Attach Port 04 12/0C Detach Port 05 13/0D Attach Port 05 14/0E Detach Port 06 15/0F Attach Port 06 16/10 Detach Port 07 17/11 Attach Port 07 18/12 Detach Port 08 19/13 Attach Port 08 20/14 Detach Port 09 21/15 Attach Port 09 22/16 Detach Port 10 23/17 Attach Port 10 24/18 Detach Port 11 25/19 Attach Port 11 26/1A Detach Port 12 27/1B Attach Port 12 28/1C Detach All Ports 29/1D Attach All Ports 30/1E Reset Card 31/1F Link Select ====================================================== 2. CC892.308 (Ethernet) Code (Dec/Hex) Command ----------------------------------- 02/02 Detach Port 01 03/03 Attach Port 01 04/04 Detach Port 02 05/05 Attach Port 02 06/06 Detach Port 03 07/07 Attach Port 03 08/08 Detach Port 04 09/09 Attach Port 04 10/0A Detach Port 05 11/0B Attach Port 05 12/0C Detach Port 06 13/0D Attach Port 06 14/0E Detach Port 07 15/0F Attach Port 07 16/10 Detach Port 08 17/11 Attach Port 08 ... 28/1C Detach All Ports 29/1D Attach All Ports 30/1E Reset Card 31/1F Link Select ================================================ 3. CC892.322 (Token-ring) Module 323 ---------- Code (Dec/Hex) Command ----------------------------------- 02/02 Detach Port 01 03/03 Attach Port 01 04/04 Detach Port 02 05/05 Attach Port 02 06/06 Detach Port 03 07/07 Attach Port 03 08/08 Detach Port 04 09/09 Attach Port 04 10/0A Detach Port 05 11/0B Attach Port 05 12/0C Detach Port 06 13/0D Attach Port 06 18/12 Detach Port 07 19/13 Attach Port 07 20/14 Detach Port 08 21/15 Attach Port 08 22/16 Detach Port 19 23/17 Attach Port 19 24/18 Detach Port 10 25/19 Attach Port 10 26/1A Detach Port 11 27/1B Attach Port 11 28/1C Detach Port 12 29/1D Attach Port 12 30/1E Reset Card 34/22 Detach Port 13 35/23 Attach Port 13 36/24 Detach Port 14 37/25 Attach Port 14 38/26 Detach Port 15 39/27 Attach Port 15 40/28 Detach Port 16 41/29 Attach Port 16 42/2A Detach Port 17 43/2B Attach Port 17 44/2C Detach Port 18 45/2D Attach Port 18 50/32 Detach Port 19 51/33 Attach Port 19 52/34 Detach Port 20 53/35 Attach Port 20 54/36 Detach Port 21 55/37 Attach Port 21 56/38 Detach Port 22 57/39 Attach Port 22 58/3A Detach Port 23 59/3B Attach Port 23 60/3C Detach Port 24 61/3D Attach Port 24 77/4D Detach All Ports 79/4F Attach All Ports ======================================================== Module 325 ---------- 30/1E Reset Card 80/50 Detach Local Port 1 (channel 1) 81/51 Attach Local Port 1 (channel 1) 82/52 Detach Local Port 2 (channel 1) 83/53 Attach Local Port 2 (channel 1) 88/58 Detach Local Port 1 (channel 3) 89/59 Attach Local Port 1 (channel 3) 90/5A Detach Local Port 2 (channel 3) 91/5B Attach Local Port 2 (channel 3) 77/4D Detach All Ports 79/4F Attach All Ports 4. CC892.427 (Voice) Code (Dec/Hex) Command ----------------------------------- 04/04 Loopback OFF on Port 1 05/05 Loopback ON on Port 1 06/06 Loopback OFF on Port 2 07/07 Loopback ON on Port 2 08/08 Loopback OFF on Port 3 09/09 Loopback ON on Port 3 10/0A Loopback OFF on Port 4 11/0B Loopback ON on Port 4 12/0C Loopback OFF on Port 5 13/0D Loopback ON on Port 5 14/0E Loopback OFF on Port 6 15/0F Loopback ON on Port 6 16/10 Loopback OFF on Port 7 17/11 Loopback ON on Port 7 18/12 Loopback OFF on Port 8 19/13 Loopback ON on Port 8 20/14 Loopback OFF on Port 9 21/15 Loopback ON on Port 9 22/16 Loopback OFF on Port 10 23/17 Loopback ON on Port 10 24/18 Loopback OFF on Port 11 25/19 Loopback ON on Port 11 26/1A Loopback OFF on Port 12 27/1B Loopback ON on Port 12 28/1C Loopback OFF on Port 13 29/1D Loopback ON on Port 13 30/1E Loopback OFF on Port 14 31/1F Loopback ON on Port 14 32/20 Loopback OFF on Port 15 33/21 Loopback ON on Port 15 34/22 Loopback OFF on Port 16 35/23 Loopback ON on Port 16 37/25 Loopback ALL on Ports 1-8 39/27 Loopback ALL on Ports 9-16 40/28 Alternate Mode on Channel Module #1 41/29 Normal Mode on Channel Module #1 42/2A Alternate Mode on Channel Module #2 43/2B Normal Mode on Channel Module #2 45/2D Configuration Load Module #1 47/2F Configuration Load Module #2 ====================================================== ')
fmSlotTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-mask", 0), ("mask", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmSlotTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotTrapMask.setDescription('When the value is 1, no more traps from that slot are sent, until next reset. (temporary mask)')
pfmSlotTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-mask", 0), ("mask", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmSlotTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: pfmSlotTrapMask.setDescription('When the value is 1, no more traps for that slot will be sent, starting after next reset (permanent mask)')
fmSlotIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 2, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmSlotIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmSlotIpAddr.setDescription(' IP address of a channel card. This is object is available only for channel cards which have their own IP addresses (e.g., LC303/129)')
fmLUID = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unconfig", 0), ("none", 1), ("lu100", 2), ("lu101", 3), ("lu102", 4), ("lu103", 5), ("lu104", 6), ("lu105", 7), ("lu106", 8), ("lu107", 9), ("lu108", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmLUID.setStatus('mandatory')
if mibBuilder.loadTexts: fmLUID.setDescription('Logic unit ID')
fmLUDescr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmLUDescr.setStatus('mandatory')
if mibBuilder.loadTexts: fmLUDescr.setDescription('Ascii string. Description of the logic unit')
fmLUStatus = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmLUStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmLUStatus.setDescription('One byte of LU status')
fmLULinkSelect = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("main-link", 0), ("sec-link", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmLULinkSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fmLULinkSelect.setDescription('Setup LU link.')
fmLULoopBackSet = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmLULoopBackSet.setStatus('mandatory')
if mibBuilder.loadTexts: fmLULoopBackSet.setDescription('Upon writing, performs LLB command. When reading the instance of this object the value has no meaning.')
fmLULoopBackClr = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmLULoopBackClr.setStatus('mandatory')
if mibBuilder.loadTexts: fmLULoopBackClr.setDescription('Upon writing, clear LLB command. When reading the instance of this object the value has no meaning.')
fmLUTrapMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-mask", 0), ("mask", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmLUTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmLUTrapMask.setDescription('When the value is 1, no more traps from the LU are sent, until next reset. (temporary mask)')
pfmLUTrapMask = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-mask", 0), ("mask", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pfmLUTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: pfmLUTrapMask.setDescription('When the value is 1, no more traps for the LU will be sent, starting after next reset (permanent mask)')
fmDiagConfig = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 5, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmDiagConfig.setStatus('mandatory')
if mibBuilder.loadTexts: fmDiagConfig.setDescription('Version of the station. The version includes station type, hardware version and software version. The string can include CR and LF')
fmDiagTrapInfo = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmDiagTrapInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fmDiagTrapInfo.setDescription('Used for generic traps. The first word is the trap code. The rest of the string is the extra information. Contains CR and LF char.')
fmDiagFaultTable = MibTable((1, 3, 6, 1, 4, 1, 22, 51, 5, 3), )
if mibBuilder.loadTexts: fmDiagFaultTable.setStatus('optional')
if mibBuilder.loadTexts: fmDiagFaultTable.setDescription('Table of fault reports from the agent')
fmDiagFaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 51, 5, 3, 1), ).setIndexNames((0, "EDB-snmp", "fmDiagFaultIndex"))
if mibBuilder.loadTexts: fmDiagFaultEntry.setStatus('optional')
fmDiagFaultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmDiagFaultIndex.setStatus('optional')
if mibBuilder.loadTexts: fmDiagFaultIndex.setDescription('The fault index in the fault table')
fmDiagFaultReport = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 51, 5, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmDiagFaultReport.setStatus('optional')
if mibBuilder.loadTexts: fmDiagFaultReport.setDescription('Get the faults detected by the agent')
fmDiagDebug = MibScalar((1, 3, 6, 1, 4, 1, 22, 51, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal-mode", 0), ("debug-mode", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmDiagDebug.setStatus('mandatory')
if mibBuilder.loadTexts: fmDiagDebug.setDescription('This object is for factory use only. Users must not write into this variable or improper operation can occur.')
fmPowerSupplyFail = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,1)).setObjects(("EDB-snmp", "fmSystemPSOper"))
if mibBuilder.loadTexts: fmPowerSupplyFail.setDescription('This trap message is generated as soon as one of the power supply has failed')
fmPrimaryPowerSupplyOK = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,2)).setObjects(("EDB-snmp", "fmSystemPSOper"))
if mibBuilder.loadTexts: fmPrimaryPowerSupplyOK.setDescription('This trap is issued when primary power supply return to work')
fmSecondPowerSupplyOK = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,3)).setObjects(("EDB-snmp", "fmSystemPSOper"))
if mibBuilder.loadTexts: fmSecondPowerSupplyOK.setDescription('This trap is issued when second power supply return to work')
fmPowerSupplyChangeConfig = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,4)).setObjects(("EDB-snmp", "fmSystemPSCfg"), ("EDB-snmp", "fmSystemPSOper"))
if mibBuilder.loadTexts: fmPowerSupplyChangeConfig.setDescription('Issued when a change in the configuration of the power supply is done')
fmLUOutOfSync = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,7)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUOutOfSync.setDescription('Issued when the Logic unit goes out of synchronization')
fmLUReturnToSync = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,8)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUReturnToSync.setDescription('Issues as soon as the logic unit returns to synchronization')
fmLUPassToMain = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,9)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUPassToMain.setDescription('Issues as soon as the logic unit pass to main link')
fmLUPassToSecond = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,10)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUPassToSecond.setDescription('Issues as soon as the logic unit pass to second link')
fmLUPrimaryLinkFail = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,11)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUPrimaryLinkFail.setDescription('When primary link of the logic unit fails this trap is issued')
fmLUPrimaryLinkOK = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,12)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUPrimaryLinkOK.setDescription('When primary link of the logic unit fails this trap is issued')
fmLUSecondLinkFail = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,13)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUSecondLinkFail.setDescription('When second link of the logic unit fails this trap is issued')
fmLUSecondLinkOK = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,14)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUSecondLinkOK.setDescription('When second link of the logic unit fails this trap is issued')
fmLULLBOn = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,15)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLULLBOn.setDescription('When the logic unit enters LLB mode')
fmLULLBOff = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,16)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLULLBOff.setDescription('When the logic unit exits LLB mode')
fmLUChangeConfig = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,20)).setObjects(("EDB-snmp", "fmLUID"), ("EDB-snmp", "fmLUStatus"))
if mibBuilder.loadTexts: fmLUChangeConfig.setDescription('Issues when a change in the LU configuration is done')
fmSlotTrap = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,25)).setObjects(("EDB-snmp", "fmSlotIndex"), ("EDB-snmp", "fmSlotID"), ("EDB-snmp", "fmSlotStatus"), ("EDB-snmp", "fmSlotPrevStatus"))
if mibBuilder.loadTexts: fmSlotTrap.setDescription('Generated when a significant status has changed in a slot. By xoring the 2 statuses, the NMS can identify the cause of the trap.')
fmSlotChangeConfig = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,26)).setObjects(("EDB-snmp", "fmSlotIndex"), ("EDB-snmp", "fmSlotID"), ("EDB-snmp", "fmSlotStatus"))
if mibBuilder.loadTexts: fmSlotChangeConfig.setDescription('Issued when the system detects changes in its slots configuration')
fmDiagGenericTrap = NotificationType((1, 3, 6, 1, 4, 1, 22, 51) + (0,30)).setObjects(("EDB-snmp", "fmDiagTrapInfo"))
if mibBuilder.loadTexts: fmDiagGenericTrap.setDescription('Generic Trap information')
mibBuilder.exportSymbols("EDB-snmp", traperm=traperm, pfmLUTrapMask=pfmLUTrapMask, pfmSystemSlipParity=pfmSystemSlipParity, fmPowerSupplyChangeConfig=fmPowerSupplyChangeConfig, fmSystemSlipIPNetMask=fmSystemSlipIPNetMask, fmSystemVersion=fmSystemVersion, fmLUSecondLinkOK=fmLUSecondLinkOK, fmSlotDescr=fmSlotDescr, fmsystemrun=fmsystemrun, fmSystemSlipIpAddr=fmSystemSlipIpAddr, rTrapAddrState=rTrapAddrState, fmLULinkSelect=fmLULinkSelect, fmLUChangeConfig=fmLUChangeConfig, fmDiagFaultReport=fmDiagFaultReport, fmSlotTable=fmSlotTable, pTrapAddrState=pTrapAddrState, fmSlotChangeConfig=fmSlotChangeConfig, fmSystemSlipStopBits=fmSystemSlipStopBits, fmlu=fmlu, pfmSystemSlipIpAddr=pfmSystemSlipIpAddr, fmSlotTrapMask=fmSlotTrapMask, fmLUDescr=fmLUDescr, fmSystemPSAdmin=fmSystemPSAdmin, enterprises=enterprises, rTrapAddrAge=rTrapAddrAge, pTrapAddrType=pTrapAddrType, fmLUOutOfSync=fmLUOutOfSync, fmPrimaryPowerSupplyOK=fmPrimaryPowerSupplyOK, pfmSystemBootMode=pfmSystemBootMode, fmLUStatus=fmLUStatus, fmslot=fmslot, pTrapAddrComm=pTrapAddrComm, fmSlotPrevStatus=fmSlotPrevStatus, private=private, rTrapAddrTbl=rTrapAddrTbl, rTrapAddrEntry=rTrapAddrEntry, fmSlotRLBSet=fmSlotRLBSet, fmSystemBootFile=fmSystemBootFile, fmDiagFaultEntry=fmDiagFaultEntry, fmSecondPowerSupplyOK=fmSecondPowerSupplyOK, fmPowerSupplyFail=fmPowerSupplyFail, fmDiagDebug=fmDiagDebug, fmSystemReset=fmSystemReset, fmdiag=fmdiag, fmDiagConfig=fmDiagConfig, pfmSystemReadCommunity=pfmSystemReadCommunity, fmSlotExpCode=fmSlotExpCode, fmSystemIPDefGway=fmSystemIPDefGway, rTrapAddrType=rTrapAddrType, fmLUSecondLinkFail=fmLUSecondLinkFail, rTrapAddrVer=rTrapAddrVer, fmSlotID=fmSlotID, fmSlotInfo=fmSlotInfo, rTrapAging=rTrapAging, fmLUID=fmLUID, fibronics=fibronics, pTrapAging=pTrapAging, fmSystemPSOper=fmSystemPSOper, trapvar=trapvar, fmSlotTrap=fmSlotTrap, fm800=fm800, fmDiagFaultIndex=fmDiagFaultIndex, fmsystemperm=fmsystemperm, fmSlotMasterClear=fmSlotMasterClear, fmSystemSlipBaudRate=fmSystemSlipBaudRate, pTrapLearning=pTrapLearning, fmSystemBootMode=fmSystemBootMode, pfmSystemWriteCommunity=pfmSystemWriteCommunity, fmSlotIndex=fmSlotIndex, trap=trap, fmSlotIpAddr=fmSlotIpAddr, fmLUPassToSecond=fmLUPassToSecond, fmsystem=fmsystem, fmLULoopBackSet=fmLULoopBackSet, fmSystemPSCfg=fmSystemPSCfg, fmSystemIPNetMask=fmSystemIPNetMask, fmSlotEntry=fmSlotEntry, pfmSlotTrapMask=pfmSlotTrapMask, traprun=traprun, pfmSystemBootFile=pfmSystemBootFile, pfmSystemIPDefGway=pfmSystemIPDefGway, fmSystemSelfTestLevel=fmSystemSelfTestLevel, fmDiagGenericTrap=fmDiagGenericTrap, fmLUPrimaryLinkOK=fmLUPrimaryLinkOK, fmDiagFaultTable=fmDiagFaultTable, pfmSystemFileServer=pfmSystemFileServer, rTrapLearning=rTrapLearning, fmSystemIpAddr=fmSystemIpAddr, pTrapAddrTbl=pTrapAddrTbl, fmSystemSlipParity=fmSystemSlipParity, pfmSystemSlipIPNetMask=pfmSystemSlipIPNetMask, fmLUPassToMain=fmLUPassToMain, fmLULLBOn=fmLULLBOn, fmLULoopBackClr=fmLULoopBackClr, pfmSystemIpAddr=pfmSystemIpAddr, pTrapAddrEntry=pTrapAddrEntry, fmLULLBOff=fmLULLBOff, rTrapAddrAddr=rTrapAddrAddr, fmSlotRLBClear=fmSlotRLBClear, fmLUTrapMask=fmLUTrapMask, fmDiagTrapInfo=fmDiagTrapInfo, rTrapAddrFlag=rTrapAddrFlag, rTrapAddrComm=rTrapAddrComm, fmLUPrimaryLinkFail=fmLUPrimaryLinkFail, pfmSystemIPNetMask=pfmSystemIPNetMask, fmSystemFileServer=fmSystemFileServer, pfmSystemSlipStopBits=pfmSystemSlipStopBits, pTrapAddrVer=pTrapAddrVer, fmSystemDownLoad=fmSystemDownLoad, fmSlotStatus=fmSlotStatus, pfmSystemSlipBaudRate=pfmSystemSlipBaudRate, fmLUReturnToSync=fmLUReturnToSync, pTrapAddrAddr=pTrapAddrAddr)

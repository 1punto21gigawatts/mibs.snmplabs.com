#
# PySNMP MIB module Novell-LANalyzer-TR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Novell-LANalyzer-TR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
EntryStatus, OwnerString = mibBuilder.importSymbols("RFC1271-MIB", "EntryStatus", "OwnerString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
enterprises, iso, TimeTicks, Counter32, Bits, Counter64, ObjectIdentity, MibIdentifier, Integer32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ModuleIdentity, IpAddress, NotificationType, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "iso", "TimeTicks", "Counter32", "Bits", "Counter64", "ObjectIdentity", "MibIdentifier", "Integer32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ModuleIdentity", "IpAddress", "NotificationType", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

novell = MibIdentifier((1, 3, 6, 1, 4, 1, 23))
productType = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 1))
mibDoc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2))
ringrmon_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 15)).setLabel("ringrmon-mib")
tokenRingStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 15, 1))
tokenRingHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 15, 2))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 15, 3))
tokenRingStatsTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1), )
if mibBuilder.loadTexts: tokenRingStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsTable.setDescription('A list of token ring statistics entries.')
tokenRingStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingStatsIndex"))
if mibBuilder.loadTexts: tokenRingStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsEntry.setDescription('A collection of statistics kept for a particular token ring interface.')
tokenRingStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsIndex.setDescription('The value of this object uniquely identifies this tokenRingStat entry.')
tokenRingStatsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingStatsDataSource.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataSource.setDescription('This object contains the identifier for the source of the data that this tokenRingStats entry is set up to analyze. The identifier is defined to contain the name of the instance that this entry receives data from. This object may not be modified unless the associated tokenRingStatsEntry object is equal to invalid(4).')
tokenRingStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDropEvents.setDescription('The total number of events in which packets are dropped by the probe due to lack of resources. Note that this is not necessarily the number of packets dropped, it is just the number of times this condition has been detected.')
tokenRingStatsDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataOctets.setDescription('The total number of good NON-MAC octets received on the network, excluding framing bits but including FCS octets. In contrast to etherStatsOctets, octets from bad packets are not counted.')
tokenRingStatsDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts.setDescription('The total number of good NON-MAC packets received on the network. In contrast to etherStatsPkts, bad packets are not counted.')
tokenRingStatsBroadcastDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsBroadcastDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsBroadcastDataPkts.setDescription('The total number of good NON-MAC packets received that were direct to the broadcast address. Note that bad broadcast packets are not counted.')
tokenRingStatsMulticastDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsMulticastDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsMulticastDataPkts.setDescription('The total number of good NON-MAC packets received that were directed to a local or global multicast or functional address. Note that bad mutlicast packets are not counted.')
tokenRingStatsMACOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsMACOctets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsMACOctets.setDescription('The total number of good MAC octets received on the network, excluding framing bits but including FCS octets. Same as tokenRingStatsDataOctets, octets from bad MAC packets are not counted.')
tokenRingStatsMACPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsMACPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsMACPkts.setDescription('The total number of good MAC packets received on the network, including unicast, multicast and broadcast MAC packets. Same as tokenRingStatsDataPkts, bad MAC packets are not counted.')
tokenRingStatsRingPurges = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsRingPurges.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsRingPurges.setDescription('The total number of times that the ring enters the ring purge state from normal ring state. Ring purge occurs when the active monitor station detects a type 2 soft errors. The ring purge state that comes from the monitor contention or beacon state is not counted.')
tokenRingStatsMonitorContentions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsMonitorContentions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsMonitorContentions.setDescription('The total number of times that the ring enters the monitor contention state from normal ring state or ring purge state. Monitor contention occurs when a type 3 soft error occurs in the network. The monitor contention state that comes from the beacon state is not counted.')
tokenRingStatsBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsBeacons.setDescription('The total number of times that the ring enters the beaconing state. Beaconing occurs when a type 4 soft error or hard error occurs in the network.')
tokenRingStatsLostMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsLostMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsLostMonitors.setDescription('The total number of monitor errors reported by the Report Monitor Error MAC frame. It occurs when the standby monitor fails to detect a good token in 2.6 seconds, or no ring poll process is executed in 15 seconds. The standby monitor assumes that the active monitor is not present or not functioning. Lost monitor is a type 3 error and will cause the detect station to initiate the monitor contention process.')
tokenRingStatsDuplicateMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDuplicateMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDuplicateMonitors.setDescription('The total number of duplicate monitor errors reported by the Report Monitor Error MAC frame. When an active monitor detects a ring purge frame or an active monitor present frame from other station, it realizes another active monitor in the ring. This station reports duplicate monitor to the Ring Error Monitor and becomes a standby monitor.')
tokenRingStatsDuplicateAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDuplicateAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDuplicateAddresses.setDescription('The total number of duplicate address errors reported by the Report Monitor Error MAC frame. It is generated by the station when it detects other stations using its own address.')
tokenRingStatsRingPollFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsRingPollFailures.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsRingPollFailures.setDescription('The total number of Report Ring Poll Failure MAC frames received. It is generated when the active monitor cannot see a ring poll cycle completed within a time limit. The MAC address of the last station in the incomplete ring poll cycle is saved in the tokenRingNetwork table for reference.')
tokenRingStatsLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsLineErrors.setDescription('The total number of line errors reported to the Ring Error Monitor. Line error means packet contains incorrect CRC or code violation. Line error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsInternalErrors.setDescription('The total number of adapter internal errors reported to the Ring Error Monitor. Internal error indicates that a station recognizes a recoverable internal error. Internal error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsBurstErrors.setDescription('The total number of burst errors reported to the Ring Error Monitor. Burst error indicates that a station detects the absence of transitions for five half-bit times. Burst error is isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingStatsACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsACErrors.setDescription('The total number of AC errors reported to the Ring Error Monitor. AC error indicates that a station cannot interpret the address recognition bit or the frame copied bit. AC error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsAbortDelimiters = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsAbortDelimiters.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsAbortDelimiters.setDescription('The total number of abort delimiters reported to the Ring Error Monitor. Abort delimiter indicates that a station aborts a transmission. Abort delimiter is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsLostFrameErrors.setDescription('The total number of lost frame errors reported to the Ring Error Monitor. Lost frame error indicates that the end delimiter of a frame is lost in the network. Lost frame error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingStatsReceiveCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsReceiveCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsReceiveCongestions.setDescription('The total number of receive congestion errors reported to the Ring Error Monitor. Receive congestion error indicates that a station recognizes a frame addressed to its specific address, but has no available buffer space. Receive congestion error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsFrameCopiedErrors.setDescription('The total number of frame copied errors reported to the Ring Error Monitor. Frame copied error indicates that a station recognizes a frame addressed to its specific address and detects that the FS field A bits are set to 1. It implies either a line hit or duplicate address. Frame copied error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingStatsFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsFrequencyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsFrequencyErrors.setDescription('The total number of frequency errors reported to the Ring Error Monitor. Frequency error indicates that a station detects that the frequency of the incoming signal differs by more than the standard specified margin. Frequency error is non-isolated error. It is a type 3 error and will cause the detect station initiating monitor contention process.')
tokenRingStatsTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsTokenErrors.setDescription('The total number of token errors reported to the Ring Error Monitor. Token error indicates that the Active Monitor station recognizes an error condition that needs a token transmitted. Token error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingStatsDataPktsUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPktsUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPktsUndersizePkts.setDescription('The total number of packets received that were between 0 and 17 octets in length inclusive, excluding framing bits but including FCS octets. Packets in this category are too short. It is the counterpart of runt packets in Ethernet RMON.')
tokenRingStatsDataPkts18to63Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts18to63Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts18to63Octets.setDescription('The total number of data packets received that were between 18 and 63 octets in length inclusive, excluding framing bits but including FCS octets. It is the counterpart of etherStatsPkts64Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts64to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts64to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts64to127Octets.setDescription('The total number of data packets received that were between 64 and 127 octets in length inclusive, excluding framing bits but including FCS octets. It is the counterpart of etherStatsPkts65to127Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts128to255Octets.setDescription('The total number of data packets received that were between 128 and 255 octets in length inclusive, excluding framing bits but including FCS octets. It is the counterpart of etherStatsPkts128to255Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts256to511Octets.setDescription('The total number of data packets received that were between 256 and 511 octets in length inclusive, excluding framing bits but including FCS octets. It is the counterpart of etherStatsPkts256to511Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts512to1023Octets.setDescription('The total number of data packets received that were between 512 and 1023 octets in length inclusive, excluding framing bits but including FCS octets. It is the counterpart of etherStatsPkts512to1023Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts1024to2047Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts1024to2047Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts1024to2047Octets.setDescription('The total number of data packets received that were between 1024 and 2047 octets in length inclusive, excluding framing bits but including FCS octets. It is the superset of etherStatsPkts1024to1518Octets in Ethernet RMON. In contrast to Ethernet, error packets are not counted.')
tokenRingStatsDataPkts2048to4608Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts2048to4608Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts2048to4608Octets.setDescription('The total number of data packets (excluding error packets) received that were between 2048 and 4608 octets in length inclusive, excluding framing bits but including FCS octets. Note that error packets in this length range is not counted.')
tokenRingStatsDataPkts4609to18000Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPkts4609to18000Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPkts4609to18000Octets.setDescription('The total number of data packets (excluding error packets) received that were between 4609 and 18000 octets in length inclusive, excluding framing bits but including FCS octets. Note that error packets in this length range is not counted.')
tokenRingStatsDataPktsMoreThan18000Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingStatsDataPktsMoreThan18000Octets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsDataPktsMoreThan18000Octets.setDescription('The total number of data packets (excluding error packets) received that were more than 18000 in length, excluding framing bits but including FCS octets. Note that error packets in this length range is not counted.')
tokenRingStatsOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 37), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingStatsOwner.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsOwner.setDescription("An administratively assigned name for the management station that configured this entry and is therefore using the resources assigned to it. This object contains a NVT octet string up to 127 characters. In some cases the agent itself will configure an entry. In this case, the agent is responsible for the resources and this object shall be set to a string starting with 'monitor'.")
tokenRingStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 1, 1, 1, 38), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingStatsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingStatsStatus.setDescription('The status of this tokenRingStats entry.')
tokenRingHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1), )
if mibBuilder.loadTexts: tokenRingHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryTable.setDescription('A list of token ring statistics entries.')
tokenRingHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingHistoryIndex"), (0, "Novell-LANalyzer-TR-MIB", "tokenRingHistoryStartIndex"))
if mibBuilder.loadTexts: tokenRingHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryEntry.setDescription('A collection of history statistics kept for a particular token ring interface.')
tokenRingHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
tokenRingHistoryStartIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryStartIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryStartIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same historyControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
tokenRingHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryIntervalStart.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
tokenRingHistoryDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryDropEvents.setDescription('')
tokenRingHistoryDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryDataOctets.setDescription('')
tokenRingHistoryDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryDataPkts.setDescription('')
tokenRingHistoryBroadcastDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryBroadcastDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryBroadcastDataPkts.setDescription('')
tokenRingHistoryMulticastDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryMulticastDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryMulticastDataPkts.setDescription('')
tokenRingHistoryMACOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryMACOctets.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryMACOctets.setDescription('')
tokenRingHistoryMACPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryMACPkts.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryMACPkts.setDescription('')
tokenRingHistoryRingPurges = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryRingPurges.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryRingPurges.setDescription('')
tokenRingHistoryMonitorContentions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryMonitorContentions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryMonitorContentions.setDescription('')
tokenRingHistoryBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryBeacons.setDescription('')
tokenRingHistoryLostMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryLostMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryLostMonitors.setDescription('')
tokenRingHistoryDuplicateMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryDuplicateMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryDuplicateMonitors.setDescription('')
tokenRingHistoryDuplicateAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryDuplicateAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryDuplicateAddresses.setDescription('')
tokenRingHistoryRingPollFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryRingPollFailures.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryRingPollFailures.setDescription('')
tokenRingHistoryLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryLineErrors.setDescription('')
tokenRingHistoryInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryInternalErrors.setDescription('')
tokenRingHistoryBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryBurstErrors.setDescription('')
tokenRingHistoryACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryACErrors.setDescription('')
tokenRingHistoryAbortDelimiters = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryAbortDelimiters.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryAbortDelimiters.setDescription('')
tokenRingHistoryLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryLostFrameErrors.setDescription('')
tokenRingHistoryReceiveCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryReceiveCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryReceiveCongestions.setDescription('')
tokenRingHistoryFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryFrameCopiedErrors.setDescription('')
tokenRingHistoryFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryFrequencyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryFrequencyErrors.setDescription('')
tokenRingHistoryTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryTokenErrors.setDescription('')
tokenRingHistoryUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHistoryUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHistoryUtilization.setDescription('')
tokenRingControlTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1), )
if mibBuilder.loadTexts: tokenRingControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlTable.setDescription('A list of token ring configuration control entries.')
tokenRingControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingControlIndex"))
if mibBuilder.loadTexts: tokenRingControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlEntry.setDescription('A list of parameters that sets up a command buffer and two event pointers for the manager who has created this instance.')
tokenRingControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlIndex.setDescription('An index that uniquely identifies an entry in the tokenRingControl table. Each entry contains a command buffer for the management station to issue a command and two event indexes for specifying the actions to be done when the ring starts beaconing and a host has entered or exited the ring.')
tokenRingControlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlIfIndex.setDescription('This object contains the board interface number which is identical to the ifIndex object in the interface table of MIB-I or MIB-II.')
tokenRingControlCommandStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("inProgress", 3), ("notSupported", 4), ("unAbleToRun", 5), ("missingData", 6), ("aborted", 7), ("failed", 8), ("sendPending", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlCommandStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlCommandStatus.setDescription('The object contains the result of the most recent test, or the value none(1) if no tests have been requested since last reset. After the manager issues a new command, the agent will turn the status to inProgress(3) and start executing. Meanwhile, the manager polls this object until a completion status is returned. Then it proceeds to read the result.')
tokenRingControlCommandType = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("nop", 1), ("removeStation", 2), ("testStation", 3), ("requestStationAddress", 4), ("requestStationState", 5), ("requestStationAttachment", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlCommandType.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlCommandType.setDescription('The object specifies the operation to act upon the target station requested by the manager. The agent only accepts unicast address from the management station. If non-unicast address is specified, the notSupported(4) value will be written to the tokenRingControlCommandStatus object. Note that the agent does not check the specified address with the host table. In other words, the management station can specify a non-existing MAC address in the command. The removeStation(1) command requests the agent to send the Remove Ring Station MAC frame to the target station that deinserts the target station from the ring. The testStation(2) command requests the agent to send the Transmit Forward MAC frame to the tagart station. The agent then monitors the response frames from the target station. If the expected response frame is not detected, the agent will write the failed(7) value to the tokenRingControlCommandStatus object. Otherwise, the success(2) value will be written to. The requestStationAddress(3) command requests the agent to send the Request Station Address MAC frame to the target station. This command is to update the address assignments of the target station in the host table. The requestStationState(4) command requests the agent to send the Request Station State MAC frame to the target station. This command is to update the state information of the target station in the host table. The requestStationAttachment(5) command requests the agent to send the Request Station Attachment MAC frame to the target station. This command is to update the configuration information about the host attachment unit of the target station in the host table.')
tokenRingControlCommandTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlCommandTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlCommandTargetAddress.setDescription('This object contains the MAC address of the target station requested by the manager. The value must be an unicast address. Multicast, functional or broadcast address is not allowed. Note that the proxy agent does not check whether the address is in the host table or not.')
tokenRingControlBeaconEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlBeaconEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlBeaconEventIndex.setDescription('The value of this object identifies the event that is configured to be generated when the ring to which this interface board is connected starts beaconing. The beacon event is generated only when the ring enters the beacon state. The beacon event will not be generated again unless the ring has exited the beacon state. The agent reports the failure domain and the beacon level in the first detected beacon frame to the management station. The information may not be the most accurate because the failure domain takes time to converge and the beacon level can be elevated. The station can poll the tokenRingNetwork table to read the current status of the ring.')
tokenRingControlConfigEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlConfigEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlConfigEventIndex.setDescription('The value of this object identifies the event that is configured to be generated when a station has entered or exited the ring that this interface board is connected to. This control table does not establish any flow control mechanism with the management station. If a group of stations enter or exit the ring at the same time and the link between the management station and the agent is slow, some events may be lost.')
tokenRingControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 8), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlOwner.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlOwner.setDescription("An administratively assigned name for the management station that configured this entry and is therefore using the resources assigned to it. In some cases the agent itself will configure an entry. In this case, the agent is responsible for the resources and this object shall be set to a string starting with 'monitor'.")
tokenRingControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 1, 1, 9), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingControlStatus.setDescription('The status of this entry.')
tokenRingNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2), )
if mibBuilder.loadTexts: tokenRingNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkTable.setDescription('The ring level information about the token ring networks in this machine.')
tokenRingNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingNetworkIfIndex"))
if mibBuilder.loadTexts: tokenRingNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkEntry.setDescription('The current state of this token ring network.')
tokenRingNetworkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkIfIndex.setDescription('This object contains the board interface number which is identical to the ifIndex object in the interface table of MIB-I or MIB-II.')
tokenRingNetworkLastResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 2), TimeTicks().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkLastResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkLastResetTime.setDescription('This object contains the sysUpTime when the data base of this group is created or last reset.')
tokenRingNetworkRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkRingNumber.setDescription('The ring number of which this interface board connects to. If the ring number is not known, it should be set to zero.')
tokenRingNetworkMediaSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 16))).clone(namedValues=NamedValues(("fourMbps", 4), ("sixteenMbps", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkMediaSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkMediaSpeed.setDescription('The media speed of the ring. The value is either 4 or 16. Other values are not allowed.')
tokenRingNetworkBridges = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkBridges.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkBridges.setDescription('The number of bridges in the host table. The bridge is referred to the device which supports the bridge functional address.')
tokenRingNetworkActiveStations = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkActiveStations.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkActiveStations.setDescription('The number of active stations in the host table. The active stations are participating in the ring poll process.')
tokenRingNetworkInactiveStations = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkInactiveStations.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkInactiveStations.setDescription('The number of inactive stations in the host table. The inactive stations are not inserted in the ring or are not participating in the ring poll process. Note that the station became inactive before the tokenRingNetworkLastResetTime cannot be detected by the agent.')
tokenRingNetworkLastEnterMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkLastEnterMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkLastEnterMACAddress.setDescription('The MAC address of the token ring station that has entered this ring most recently.')
tokenRingNetworkLastExitMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkLastExitMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkLastExitMACAddress.setDescription('The MAC address of the token ring station that has left this ring most recently.')
tokenRingNetworkState = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normalOperation", 1), ("ringPurgeState", 2), ("claimTokenState", 3), ("beaconState", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkState.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkState.setDescription('The state of the ring of which this entry is a part.')
tokenRingNetworkStateCause = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("notClear", 1), ("initialState", 2), ("normalRing", 3), ("recovering", 4), ("hardError", 5), ("beaconSetRecoveryMode", 6), ("beaconRingSignalLoss", 7), ("beaconBitStreaming", 8), ("beaconFrameStreaming", 9), ("type1SoftError", 10), ("type2SoftError", 11), ("type3SoftError", 12), ("type4SoftError", 13), ("burst5Error", 14), ("lostFrameError", 15), ("corruptedToken", 16), ("lostToken", 17), ("circulatingFrame", 18), ("multipleMonitor", 19), ("lostMonitor", 20), ("frequencyError", 21))).clone('initialState')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkStateCause.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkStateCause.setDescription('The cause of this state transition. It is required to give the best estimation of the cause. When this interface just enters the ring, this object is initialized to initiatState(2). If no hint is available, then it sets the cause to notClear(1).')
tokenRingNetworkStateSenderMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 12), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkStateSenderMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkStateSenderMACAddress.setDescription('The MAC address of the station which initiates the state transition.')
tokenRingNetworkStateUpstreamNeighborMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkStateUpstreamNeighborMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkStateUpstreamNeighborMACAddress.setDescription('The MAC address in the upstream neighbor address subvector of the MAC protocol frame. Some MAC protocol frames, such as ring purge frame, do not contain that subvector, then the MAC address contained in this object is irrelevant.')
tokenRingNetworkHostOrderChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkHostOrderChanges.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkHostOrderChanges.setDescription('The count of the index in the host table that has changed since this table is created. The host table contains active and inactive stations which are arranged in sequential order. This counter roughly estimates the number of times that the hosts have changed their port connections.')
tokenRingNetworkActiveMonitorChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingNetworkActiveMonitorChanges.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingNetworkActiveMonitorChanges.setDescription('The number of times that the active monitor changes station since this table is created.')
tokenRingHostTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3), )
if mibBuilder.loadTexts: tokenRingHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostTable.setDescription('A list of token ring host table entries.')
tokenRingHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingHostIfIndex"), (0, "Novell-LANalyzer-TR-MIB", "tokenRingHostMACAddress"))
if mibBuilder.loadTexts: tokenRingHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostEntry.setDescription('The information of the host that has been discovered on this interface.')
tokenRingHostIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostIfIndex.setDescription('This object contains the board interface number which is identical to the ifIndex object in the interface table of MIB-I or MIB-II.')
tokenRingHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostIndex.setDescription('An index that defines the relative order of the hosts in this ring starting from the Active Monitor station. The active monitor station contains the value of 1. The rest of the stations are arranged in sequential order relative to the active monitor station. When a station becomes inactive, its entry is not meant to be deleted. The value in the tokenRingHostStatus is changed to inactive. The delete algorithm is implementation specific. If a station becomes active and its entry is already in the host table, then the value of the tokenRingHostStatus object is changed to active. In addition, if the relative order of the host entries has changed, it shall increment the tokenRingNetworkHostOrderChange counter in the tokenRingNetwork table by one. On the other hand, if a station becomes active and its entry is not in the host table, then a new entry must be created. The new entry is inserted right after its upstream neighbor station. The tokenRingNetworkHostOrderChange counter in the tokenRingNetwork table shall not be increment. If the active monitor changes station and the relative position of the host entries is unchanged, then the tokenRingNetworkHostOrderChange object in the tokenRingNetwork table shall not be increment.')
tokenRingHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("activeMonitor", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostStatus.setDescription('The host table contains active and inactive stations. An active station is currently participating in the ring poll process. An inactive station is vice versa. The inactive station can be a previous active station which has exited the ring, or a station which is in the ring but does not participate in the ring poll process.')
tokenRingHostLastEnterTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostLastEnterTime.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostLastEnterTime.setDescription('The sysUpTime that the station has entered the ring most recently or when the host entry is created.')
tokenRingHostLastExitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostLastExitTime.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostLastExitTime.setDescription('The sysUpTime that the station has exited the ring most recently. When this object is created, it shall reset its value to 0. It indicates that the station has never exited since creation.')
tokenRingHostMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostMACAddress.setDescription("The station's MAC address to which this entry is belonged.")
tokenRingHostPhysicalDropNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostPhysicalDropNumber.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostPhysicalDropNumber.setDescription("The station's physical drop number of which this entry is belonged. If the value of this object is not assigned, then it is defaulted to four zeros.")
tokenRingHostSoftErrorReportTimerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostSoftErrorReportTimerValue.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostSoftErrorReportTimerValue.setDescription('The time interval of the host station that the Report Soft Error MAC frame is generated. The default value is two seconds. The value is in units of millisecond.')
tokenRingHostGroupAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostGroupAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostGroupAddresses.setDescription('The group address of this station.')
tokenRingHostFunctionalAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostFunctionalAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostFunctionalAddresses.setDescription("The functional address of the station. The functional address is assigned in the bit map fashion. The first two bytes are always 'C0-00' in hex. and the first bit of the third byte is always zero. The following 31 bits are defined as follows: 00-00-00-01 : Active Monitor. 00-00-00-02 : Ring Parameter Server. 00-00-00-04 : 00-00-00-08 : Ring Error Monitor. 00-00-00-10 : Configuration Report Server. 00-00-00-20 : 00-00-00-40 : 00-00-00-80 : NetBIOS. 00-00-01-00 : Bridge. 00-00-02-00 : 00-00-04-00 : 00-00-08-00 : 00-00-10-00 : 00-00-20-00 : IBM LAN Network Manager. 00-00-40-00 : 00-00-80-00 : The bit range between 00-01-00-00 and 40-00-00-00 are not administrated by IEEE. They are defined by users. Below lists a couple of popular assignments: 00-80-00-00 : Novell NetWare. 40-00-00-00 : Apple TokenTalk Broadcast.")
tokenRingHostAuthorizedFunctionClass = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostAuthorizedFunctionClass.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostAuthorizedFunctionClass.setDescription("Source classes for which the host is enabled to transmit. Valid range is '0000 0000 0000 0000'b to '1111 1111 1111 1111'b. Each bit 0 to 15 corresponds to function class '0000'b to '1111'b. Bit value '1'b means function class is enabled. Defined function classes are the following: '00'H : Ring Station. '01'H : LLC Manager. '04'H : Configuration Report Server. '05'H : Ring Parameter Server. '06'H : Ring Error Monitor.")
tokenRingHostAuthorizedAccessPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostAuthorizedAccessPriority.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostAuthorizedAccessPriority.setDescription('Maximum allowed token priority with which the attached product is allowed to transmit.')
tokenRingHostAdapterSoftwareLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostAdapterSoftwareLevel.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostAdapterSoftwareLevel.setDescription('The adapter software level of this station. The interpretation of the value in this object is vendor specific.')
tokenRingHostAdapterStatusVector = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostAdapterStatusVector.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostAdapterStatusVector.setDescription('The adapter status vector of this station. The interpretation of the value in this object is vendor specific.')
tokenRingHostProductID = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostProductID.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostProductID.setDescription('The product identification of this station. The content is defined by vendor.')
tokenRingHostLostMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostLostMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostLostMonitors.setDescription('The total number of monitor errors reported by the Report Monitor Error MAC frame. It occurs when the standby monitor fails to detect a good token in 2.6 seconds, or no ring poll process is executed in 15 seconds. The standby monitor assumes that the active monitor is not present or not functioning. Lost monitor is a type 3 error and will cause the detect station to initiate the monitor contention process.')
tokenRingHostDuplicateMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostDuplicateMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostDuplicateMonitors.setDescription('The total number of duplicate monitor errors reported by the Report Monitor Error MAC frame. When an active monitor detects a ring purge frame or an active monitor present frame from other station, it realizes another active monitor in the ring. This station reports duplicate monitor to the Ring Error Monitor and becomes a standby monitor.')
tokenRingHostDuplicateAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostDuplicateAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostDuplicateAddresses.setDescription('The total number of duplicate address errors reported by the Report Monitor Error MAC frame. It is generated by the station when it detects other stations using its MAC address.')
tokenRingHostRingPollFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostRingPollFailures.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostRingPollFailures.setDescription('The total number of Report Ring Poll Failure MAC frames received. It is generated when the active monitor cannot see a ring poll cycle completed within a time limit. The MAC address of the last station in the incomplete ring poll cycle is saved in the tokenRingNetwork table for reference.')
tokenRingHostInLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostInLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostInLineErrors.setDescription('The total number of line errors reported to the Ring Error Monitor. Line error means packet contains incorrect CRC or code violation. Line error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostInternalErrors.setDescription('The total number of adapter internal errors reported to the Ring Error Monitor. Internal error indicates that a station recognizes a recoverable internal error. Internal error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostInBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostInBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostInBurstErrors.setDescription('The total number of burst errors reported to the Ring Error Monitor. Burst error indicates that a station detects the absence of transitions for five half-bit times. Burst error is isolated error. It is a type 2 error and will casue the active monitor purging the ring.')
tokenRingHostACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostACErrors.setDescription('The total number of AC errors reported to the Ring Error Monitor. AC error indicates that a station cannot interpret the address recognition bit or the frame copied bit. AC error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostAbortDelimiters = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostAbortDelimiters.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostAbortDelimiters.setDescription('The number of abort delimiters reported to the Ring Error Monitor. Abort delimiter indicates that a station aborts a transmission. Abort delimiter is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostLostFrameErrors.setDescription('The number of lost frame errors reported to the Ring Error Monitor. Lost frame error indicates that the end delimiter of a frame is lost in the network. Lost frame error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingHostReceiveCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostReceiveCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostReceiveCongestions.setDescription('The number of receive congestions reported to the Ring Error Monitor. Receive congestion error indicates that a station recognizes a frame addressed to its specific address, but has no available buffer space. Receive congestion error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostFrameCopiedErrors.setDescription('The number of frame copied errors reported to the Ring Error Monitor. Frame copied error indicates that a station recognizes a frame addressed to its specific address and detects that the A bits in Frame Status byte are set to 1. It implies either a line hit or duplicate address. Frame copied error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostFrequencyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostFrequencyErrors.setDescription('The number of frequency errors reported to the Ring Error Monitor. Frequency error indicates that a station detects that the frequency of the incoming signal differs by more than the standard specified margin. Frequency error is non-isolated error. It is a type 3 error and will cause the detect station initiating monitor contention process.')
tokenRingHostTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostTokenErrors.setDescription('The total number of token errors reported to the Ring Error Monitor. Token error indicates that the Active Monitor station recognizes an error condition that needs a token transmitted. Token error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingHostOutLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostOutLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostOutLineErrors.setDescription('The total number of line errors reported to the Ring Error Monitor. Line error means packet contains incorrect CRC or code violation. Line error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingHostOutBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostOutBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostOutBurstErrors.setDescription('The total number of burst errors reported to the Ring Error Monitor. Burst error indicates that a station detects the absence of transitions for five half-bit times. Burst error is isolated error. It is a type 2 error and will casue the active monitor purging the ring.')
tokenRingHostInBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostInBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostInBeacons.setDescription('')
tokenRingHostOutBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostOutBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostOutBeacons.setDescription('')
tokenRingHostInsertions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingHostInsertions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingHostInsertions.setDescription('')
tokenRingOrderTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4), )
if mibBuilder.loadTexts: tokenRingOrderTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderTable.setDescription('A list of token ring host table entries.')
tokenRingOrderEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1), ).setIndexNames((0, "Novell-LANalyzer-TR-MIB", "tokenRingOrderIfIndex"), (0, "Novell-LANalyzer-TR-MIB", "tokenRingOrderIndex"))
if mibBuilder.loadTexts: tokenRingOrderEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderEntry.setDescription('The information of the host that has been discovered on this interface.')
tokenRingOrderIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderIfIndex.setDescription('This object contains the board interface number which is identical to the ifIndex object in the interface table of MIB-I or MIB-II.')
tokenRingOrderIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderIndex.setDescription('An index that defines the relative order of the hosts in this ring starting from the Active Monitor station. The active monitor station contains the value of 1. The rest of the stations are arranged in sequential order relative to the active monitor station. When a station becomes inactive, its entry is not meant to be deleted. The value in the tokenRingOrderStatus is changed to inactive. The delete algorithm is implementation specific. If a station becomes active and its entry is already in the host table, then the value of the tokenRingOrderStatus object is changed to active. In addition, if the relative order of the host entries has changed, it shall increment the tokenRingNetworkHostOrderChange counter in the tokenRingNetwork table by one. On the other hand, if a station becomes active and its entry is not in the host table, then a new entry must be created. The new entry is inserted right after its upstream neighbor station. The tokenRingNetworkHostOrderChange counter in the tokenRingNetwork table shall not be increment. If the active monitor changes station and the relative position of the host entries is unchanged, then the tokenRingNetworkHostOrderChange object in the tokenRingNetwork table shall not be increment.')
tokenRingOrderStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("activeMonitor", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderStatus.setDescription('The host table contains active and inactive stations. An active station is currently participating in the ring poll process. An inactive station is vice versa. The inactive station can be a previous active station which has exited the ring, or a station which is in the ring but does not participate in the ring poll process.')
tokenRingOrderLastEnterTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderLastEnterTime.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderLastEnterTime.setDescription('The sysUpTime that the station has entered the ring most recently or when the host entry is created.')
tokenRingOrderLastExitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderLastExitTime.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderLastExitTime.setDescription('The sysUpTime that the station has exited the ring most recently. When this object is created, it shall reset its value to 0. It indicates that the station has never exited since creation.')
tokenRingOrderMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderMACAddress.setDescription("The station's MAC address to which this entry is belonged.")
tokenRingOrderPhysicalDropNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderPhysicalDropNumber.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderPhysicalDropNumber.setDescription("The station's physical drop number of which this entry is belonged. If the value of this object is not assigned, then it is defaulted to four zeros.")
tokenRingOrderSoftErrorReportTimerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderSoftErrorReportTimerValue.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderSoftErrorReportTimerValue.setDescription('The time interval of the host station that the Report Soft Error MAC frame is generated. The default value is two seconds. The value is in units of millisecond.')
tokenRingOrderGroupAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderGroupAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderGroupAddresses.setDescription('The group address of this station.')
tokenRingOrderFunctionalAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderFunctionalAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderFunctionalAddresses.setDescription("The functional address of the station. The functional address is assigned in the bit map fashion. The first two bytes are always 'C0-00' in hex. and the first bit of the third byte is always zero. The following 31 bits are defined as follows: 00-00-00-01 : Active Monitor. 00-00-00-02 : Ring Parameter Server. 00-00-00-04 : 00-00-00-08 : Ring Error Monitor. 00-00-00-10 : Configuration Report Server. 00-00-00-20 : 00-00-00-40 : 00-00-00-80 : NetBIOS. 00-00-01-00 : Bridge. 00-00-02-00 : 00-00-04-00 : 00-00-08-00 : 00-00-10-00 : 00-00-20-00 : IBM LAN Network Manager. 00-00-40-00 : 00-00-80-00 : The bit range between 00-01-00-00 and 40-00-00-00 are not administrated by IEEE. They are defined by users. Below lists a couple of popular assignments: 00-80-00-00 : Novell NetWare. 40-00-00-00 : Apple TokenTalk Broadcast.")
tokenRingOrderAuthorizedFunctionClass = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderAuthorizedFunctionClass.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderAuthorizedFunctionClass.setDescription("Source classes for which the host is enabled to transmit. Valid range is '0000 0000 0000 0000'b to '1111 1111 1111 1111'b. Each bit 0 to 15 corresponds to function class '0000'b to '1111'b. Bit value '1'b means function class is enabled. Defined function classes are the following: '00'H : Ring Station. '01'H : LLC Manager. '04'H : Configuration Report Server. '05'H : Ring Parameter Server. '06'H : Ring Error Monitor.")
tokenRingOrderAuthorizedAccessPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderAuthorizedAccessPriority.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderAuthorizedAccessPriority.setDescription('Maximum allowed token priority with which the attached product is allowed to transmit.')
tokenRingOrderAdapterSoftwareLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderAdapterSoftwareLevel.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderAdapterSoftwareLevel.setDescription('The adapter software level of this station. The interpretation of the value in this object is vendor specific.')
tokenRingOrderAdapterStatusVector = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderAdapterStatusVector.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderAdapterStatusVector.setDescription('The adapter status vector of this station. The interpretation of the value in this object is vendor specific.')
tokenRingOrderProductID = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderProductID.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderProductID.setDescription('The product identification of this station. The content is defined by vendor.')
tokenRingOrderLostMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderLostMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderLostMonitors.setDescription('The total number of monitor errors reported by the Report Monitor Error MAC frame. It occurs when the standby monitor fails to detect a good token in 2.6 seconds, or no ring poll process is executed in 15 seconds. The standby monitor assumes that the active monitor is not present or not functioning. Lost monitor is a type 3 error and will cause the detect station to initiate the monitor contention process.')
tokenRingOrderDuplicateMonitors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderDuplicateMonitors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderDuplicateMonitors.setDescription('The total number of duplicate monitor errors reported by the Report Monitor Error MAC frame. When an active monitor detects a ring purge frame or an active monitor present frame from other station, it realizes another active monitor in the ring. This station reports duplicate monitor to the Ring Error Monitor and becomes a standby monitor.')
tokenRingOrderDuplicateAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderDuplicateAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderDuplicateAddresses.setDescription('The total number of duplicate address errors reported by the Report Monitor Error MAC frame. It is generated by the station when it detects other stations using its MAC address.')
tokenRingOrderRingPollFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderRingPollFailures.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderRingPollFailures.setDescription('The total number of Report Ring Poll Failure MAC frames received. It is generated when the active monitor cannot see a ring poll cycle completed within a time limit. The MAC address of the last station in the incomplete ring poll cycle is saved in the tokenRingNetwork table for reference.')
tokenRingOrderInLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderInLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderInLineErrors.setDescription('The total number of line errors reported to the Ring Error Monitor. Line error means packet contains incorrect CRC or code violation. Line error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderInternalErrors.setDescription('The total number of adapter internal errors reported to the Ring Error Monitor. Internal error indicates that a station recognizes a recoverable internal error. Internal error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderInBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderInBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderInBurstErrors.setDescription('The total number of burst errors reported to the Ring Error Monitor. Burst error indicates that a station detects the absence of transitions for five half-bit times. Burst error is isolated error. It is a type 2 error and will casue the active monitor purging the ring.')
tokenRingOrderACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderACErrors.setDescription('The total number of AC errors reported to the Ring Error Monitor. AC error indicates that a station cannot interpret the address recognition bit or the frame copied bit. AC error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderAbortDelimiters = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderAbortDelimiters.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderAbortDelimiters.setDescription('The number of abort delimiters reported to the Ring Error Monitor. Abort delimiter indicates that a station aborts a transmission. Abort delimiter is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderLostFrameErrors.setDescription('The number of lost frame errors reported to the Ring Error Monitor. Lost frame error indicates that the end delimiter of a frame is lost in the network. Lost frame error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingOrderReceiveCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderReceiveCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderReceiveCongestions.setDescription('The number of receive congestions reported to the Ring Error Monitor. Receive congestion error indicates that a station recognizes a frame addressed to its specific address, but has no available buffer space. Receive congestion error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderFrameCopiedErrors.setDescription('The number of frame copied errors reported to the Ring Error Monitor. Frame copied error indicates that a station recognizes a frame addressed to its specific address and detects that the A bits in Frame Status byte are set to 1. It implies either a line hit or duplicate address. Frame copied error is non-isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderFrequencyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderFrequencyErrors.setDescription('The number of frequency errors reported to the Ring Error Monitor. Frequency error indicates that a station detects that the frequency of the incoming signal differs by more than the standard specified margin. Frequency error is non-isolated error. It is a type 3 error and will cause the detect station initiating monitor contention process.')
tokenRingOrderTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderTokenErrors.setDescription('The total number of token errors reported to the Ring Error Monitor. Token error indicates that the Active Monitor station recognizes an error condition that needs a token transmitted. Token error is non-isolated error. It is a type 2 error and the active monitor will purge the ring.')
tokenRingOrderOutLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderOutLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderOutLineErrors.setDescription('The total number of line errors reported to the Ring Error Monitor. Line error means packet contains incorrect CRC or code violation. Line error is isolated error. It is a type 1 error and no ring recovery is performed.')
tokenRingOrderOutBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderOutBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderOutBurstErrors.setDescription('The total number of burst errors reported to the Ring Error Monitor. Burst error indicates that a station detects the absence of transitions for five half-bit times. Burst error is isolated error. It is a type 2 error and will casue the active monitor purging the ring.')
tokenRingOrderInBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderInBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderInBeacons.setDescription('')
tokenRingOrderOutBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderOutBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderOutBeacons.setDescription('')
tokenRingOrderInsertions = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 15, 3, 4, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingOrderInsertions.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingOrderInsertions.setDescription('')
tokenRingBeaconing = NotificationType((1, 3, 6, 1, 4, 1, 23, 2, 15) + (0,4)).setObjects(("Novell-LANalyzer-TR-MIB", "tokenRingNetworkRingNumber"), ("Novell-LANalyzer-TR-MIB", "tokenRingNetworkState"), ("Novell-LANalyzer-TR-MIB", "tokenRingNetworkStateCause"), ("Novell-LANalyzer-TR-MIB", "tokenRingNetworkStateSenderMACAddress"), ("Novell-LANalyzer-TR-MIB", "tokenRingNetworkStateUpstreamNeighborMACAddress"))
if mibBuilder.loadTexts: tokenRingBeaconing.setDescription('The SNMP trap that is generated when the token ring network starts beaconing.')
tokenRingConfigurationChange = NotificationType((1, 3, 6, 1, 4, 1, 23, 2, 15) + (0,5)).setObjects(("Novell-LANalyzer-TR-MIB", "tokenRingNetworkRingNumber"), ("Novell-LANalyzer-TR-MIB", "tokenRingHostMACAddress"), ("Novell-LANalyzer-TR-MIB", "tokenRingHostPhysicalDropNumber"), ("Novell-LANalyzer-TR-MIB", "tokenRingHostStatus"))
if mibBuilder.loadTexts: tokenRingConfigurationChange.setDescription('The SNMP trap that is generated when the a host has entered or exited the token ring network.')
mibBuilder.exportSymbols("Novell-LANalyzer-TR-MIB", tokenRingNetworkIfIndex=tokenRingNetworkIfIndex, tokenRingOrderSoftErrorReportTimerValue=tokenRingOrderSoftErrorReportTimerValue, tokenRingOrderAbortDelimiters=tokenRingOrderAbortDelimiters, tokenRingHistoryTable=tokenRingHistoryTable, tokenRingHostDuplicateMonitors=tokenRingHostDuplicateMonitors, tokenRingHistoryTokenErrors=tokenRingHistoryTokenErrors, tokenRingHostLostMonitors=tokenRingHostLostMonitors, tokenRingOrderAuthorizedAccessPriority=tokenRingOrderAuthorizedAccessPriority, tokenRingHistoryUtilization=tokenRingHistoryUtilization, tokenRingHostAuthorizedFunctionClass=tokenRingHostAuthorizedFunctionClass, tokenRingOrderLostFrameErrors=tokenRingOrderLostFrameErrors, tokenRingHostTokenErrors=tokenRingHostTokenErrors, tokenRingControlBeaconEventIndex=tokenRingControlBeaconEventIndex, tokenRingHostRingPollFailures=tokenRingHostRingPollFailures, tokenRingHistoryLostFrameErrors=tokenRingHistoryLostFrameErrors, tokenRingHistoryFrequencyErrors=tokenRingHistoryFrequencyErrors, tokenRingHostReceiveCongestions=tokenRingHostReceiveCongestions, tokenRingStatsDataPkts256to511Octets=tokenRingStatsDataPkts256to511Octets, tokenRingStatsDataPktsUndersizePkts=tokenRingStatsDataPktsUndersizePkts, tokenRingNetworkLastResetTime=tokenRingNetworkLastResetTime, tokenRingHostOutBeacons=tokenRingHostOutBeacons, tokenRingHostLastEnterTime=tokenRingHostLastEnterTime, tokenRingNetworkInactiveStations=tokenRingNetworkInactiveStations, tokenRingStatsDataPkts=tokenRingStatsDataPkts, tokenRingOrderInternalErrors=tokenRingOrderInternalErrors, tokenRingHostTable=tokenRingHostTable, tokenRingHistory=tokenRingHistory, tokenRingHistoryDuplicateMonitors=tokenRingHistoryDuplicateMonitors, tokenRingControlEntry=tokenRingControlEntry, tokenRingStatsDataSource=tokenRingStatsDataSource, tokenRingHistoryMACPkts=tokenRingHistoryMACPkts, tokenRingNetworkMediaSpeed=tokenRingNetworkMediaSpeed, tokenRingNetworkState=tokenRingNetworkState, tokenRingHostDuplicateAddresses=tokenRingHostDuplicateAddresses, tokenRingOrderOutBurstErrors=tokenRingOrderOutBurstErrors, tokenRingHistoryIndex=tokenRingHistoryIndex, tokenRingStatsDataPkts2048to4608Octets=tokenRingStatsDataPkts2048to4608Octets, tokenRingStatistics=tokenRingStatistics, tokenRingNetworkActiveMonitorChanges=tokenRingNetworkActiveMonitorChanges, tokenRingStatsBurstErrors=tokenRingStatsBurstErrors, tokenRingControlCommandType=tokenRingControlCommandType, tokenRingHostInBurstErrors=tokenRingHostInBurstErrors, tokenRingOrderDuplicateAddresses=tokenRingOrderDuplicateAddresses, tokenRingOrderOutLineErrors=tokenRingOrderOutLineErrors, MacAddress=MacAddress, tokenRingStatsRingPollFailures=tokenRingStatsRingPollFailures, tokenRingStatsTokenErrors=tokenRingStatsTokenErrors, tokenRingHistoryRingPurges=tokenRingHistoryRingPurges, tokenRingStatsFrequencyErrors=tokenRingStatsFrequencyErrors, tokenRingOrderIndex=tokenRingOrderIndex, tokenRingHistoryInternalErrors=tokenRingHistoryInternalErrors, tokenRingHostInternalErrors=tokenRingHostInternalErrors, tokenRingStatsDataPkts128to255Octets=tokenRingStatsDataPkts128to255Octets, tokenRingOrderTable=tokenRingOrderTable, tokenRingOrderProductID=tokenRingOrderProductID, tokenRingHostPhysicalDropNumber=tokenRingHostPhysicalDropNumber, tokenRingStatsDuplicateMonitors=tokenRingStatsDuplicateMonitors, tokenRingNetworkStateUpstreamNeighborMACAddress=tokenRingNetworkStateUpstreamNeighborMACAddress, tokenRingOrderRingPollFailures=tokenRingOrderRingPollFailures, tokenRingStatsIndex=tokenRingStatsIndex, tokenRingOrderIfIndex=tokenRingOrderIfIndex, tokenRingOrderInBeacons=tokenRingOrderInBeacons, tokenRingOrderPhysicalDropNumber=tokenRingOrderPhysicalDropNumber, tokenRingHistoryStartIndex=tokenRingHistoryStartIndex, tokenRingOrderAdapterSoftwareLevel=tokenRingOrderAdapterSoftwareLevel, tokenRingHistoryMACOctets=tokenRingHistoryMACOctets, tokenRingOrderInsertions=tokenRingOrderInsertions, tokenRingOrderFrameCopiedErrors=tokenRingOrderFrameCopiedErrors, tokenRingHistoryReceiveCongestions=tokenRingHistoryReceiveCongestions, tokenRingNetworkStateCause=tokenRingNetworkStateCause, tokenRingStatsMACPkts=tokenRingStatsMACPkts, tokenRingHistoryRingPollFailures=tokenRingHistoryRingPollFailures, tokenRingStatsDataPkts512to1023Octets=tokenRingStatsDataPkts512to1023Octets, tokenRingHistoryBroadcastDataPkts=tokenRingHistoryBroadcastDataPkts, tokenRingHostInLineErrors=tokenRingHostInLineErrors, tokenRingOrderStatus=tokenRingOrderStatus, tokenRingOrderACErrors=tokenRingOrderACErrors, tokenRingHostIndex=tokenRingHostIndex, tokenRingStatsMACOctets=tokenRingStatsMACOctets, tokenRingOrderTokenErrors=tokenRingOrderTokenErrors, tokenRingNetworkStateSenderMACAddress=tokenRingNetworkStateSenderMACAddress, tokenRingHistoryACErrors=tokenRingHistoryACErrors, tokenRingHostFunctionalAddresses=tokenRingHostFunctionalAddresses, tokenRingStatsEntry=tokenRingStatsEntry, tokenRingHostInBeacons=tokenRingHostInBeacons, tokenRingStatsFrameCopiedErrors=tokenRingStatsFrameCopiedErrors, tokenRingHistoryLostMonitors=tokenRingHistoryLostMonitors, tokenRingStatsInternalErrors=tokenRingStatsInternalErrors, tokenRingControlIndex=tokenRingControlIndex, tokenRingControlIfIndex=tokenRingControlIfIndex, tokenRingHistoryAbortDelimiters=tokenRingHistoryAbortDelimiters, tokenRingOrderInLineErrors=tokenRingOrderInLineErrors, tokenRingHostStatus=tokenRingHostStatus, tokenRingHistoryEntry=tokenRingHistoryEntry, tokenRingControlTable=tokenRingControlTable, tokenRingControlOwner=tokenRingControlOwner, tokenRingStatsDuplicateAddresses=tokenRingStatsDuplicateAddresses, tokenRingHistoryDataOctets=tokenRingHistoryDataOctets, tokenRingNetworkLastEnterMACAddress=tokenRingNetworkLastEnterMACAddress, tokenRingHistoryLineErrors=tokenRingHistoryLineErrors, novell=novell, tokenRingHostFrameCopiedErrors=tokenRingHostFrameCopiedErrors, tokenRingOrderFrequencyErrors=tokenRingOrderFrequencyErrors, tokenRingNetworkEntry=tokenRingNetworkEntry, tokenRingNetworkLastExitMACAddress=tokenRingNetworkLastExitMACAddress, tokenRingStatsDataPktsMoreThan18000Octets=tokenRingStatsDataPktsMoreThan18000Octets, tokenRingOrderMACAddress=tokenRingOrderMACAddress, tokenRingOrderDuplicateMonitors=tokenRingOrderDuplicateMonitors, tokenRingStatsOwner=tokenRingStatsOwner, ringrmon_mib=ringrmon_mib, tokenRingHistoryBurstErrors=tokenRingHistoryBurstErrors, tokenRingHistoryDuplicateAddresses=tokenRingHistoryDuplicateAddresses, tokenRingStatsAbortDelimiters=tokenRingStatsAbortDelimiters, tokenRingOrderGroupAddresses=tokenRingOrderGroupAddresses, tokenRingStatsLineErrors=tokenRingStatsLineErrors, tokenRingOrderAdapterStatusVector=tokenRingOrderAdapterStatusVector, tokenRingHistoryMulticastDataPkts=tokenRingHistoryMulticastDataPkts, tokenRingHostLastExitTime=tokenRingHostLastExitTime, tokenRingOrderInBurstErrors=tokenRingOrderInBurstErrors, tokenRingStatsMulticastDataPkts=tokenRingStatsMulticastDataPkts, tokenRingStatsMonitorContentions=tokenRingStatsMonitorContentions, tokenRingOrderOutBeacons=tokenRingOrderOutBeacons, tokenRingHistoryIntervalStart=tokenRingHistoryIntervalStart, tokenRingHostAdapterStatusVector=tokenRingHostAdapterStatusVector, tokenRingHistoryFrameCopiedErrors=tokenRingHistoryFrameCopiedErrors, productType=productType, tokenRingStatsBroadcastDataPkts=tokenRingStatsBroadcastDataPkts, mibDoc=mibDoc, tokenRingStatsDataPkts1024to2047Octets=tokenRingStatsDataPkts1024to2047Octets, tokenRingStatsACErrors=tokenRingStatsACErrors, tokenRingHostEntry=tokenRingHostEntry, tokenRingControlStatus=tokenRingControlStatus, tokenRingHostMACAddress=tokenRingHostMACAddress, tokenRingBeaconing=tokenRingBeaconing, tokenRingHostAdapterSoftwareLevel=tokenRingHostAdapterSoftwareLevel, tokenRingHistoryDropEvents=tokenRingHistoryDropEvents, tokenRingHostOutLineErrors=tokenRingHostOutLineErrors, tokenRingStatsDataOctets=tokenRingStatsDataOctets, tokenRingOrderFunctionalAddresses=tokenRingOrderFunctionalAddresses, tokenRingStatsDataPkts64to127Octets=tokenRingStatsDataPkts64to127Octets, tokenRingStatsRingPurges=tokenRingStatsRingPurges, tokenRingStatsDataPkts4609to18000Octets=tokenRingStatsDataPkts4609to18000Octets, tokenRingStatsDataPkts18to63Octets=tokenRingStatsDataPkts18to63Octets, tokenRingStatsReceiveCongestions=tokenRingStatsReceiveCongestions, tokenRingHostAbortDelimiters=tokenRingHostAbortDelimiters, tokenRingStatsStatus=tokenRingStatsStatus, tokenRingControlCommandStatus=tokenRingControlCommandStatus, tokenRingOrderLostMonitors=tokenRingOrderLostMonitors, tokenRingConfigurationChange=tokenRingConfigurationChange, tokenRingNetworkActiveStations=tokenRingNetworkActiveStations, tokenRingOrderReceiveCongestions=tokenRingOrderReceiveCongestions, tokenRingControlConfigEventIndex=tokenRingControlConfigEventIndex, tokenRingOrderAuthorizedFunctionClass=tokenRingOrderAuthorizedFunctionClass, tokenRingNetworkTable=tokenRingNetworkTable, tokenRingHostACErrors=tokenRingHostACErrors, tokenRingStatsTable=tokenRingStatsTable, tokenRingNetworkHostOrderChanges=tokenRingNetworkHostOrderChanges, tokenRingHostSoftErrorReportTimerValue=tokenRingHostSoftErrorReportTimerValue, tokenRingHostProductID=tokenRingHostProductID, tokenRingControlCommandTargetAddress=tokenRingControlCommandTargetAddress, tokenRingHostOutBurstErrors=tokenRingHostOutBurstErrors, tokenRingHostInsertions=tokenRingHostInsertions, tokenRingHostLostFrameErrors=tokenRingHostLostFrameErrors, tokenRingHistoryBeacons=tokenRingHistoryBeacons, tokenRingOrderLastExitTime=tokenRingOrderLastExitTime, tokenRing=tokenRing, tokenRingHostIfIndex=tokenRingHostIfIndex, tokenRingStatsDropEvents=tokenRingStatsDropEvents, tokenRingNetworkRingNumber=tokenRingNetworkRingNumber, tokenRingStatsBeacons=tokenRingStatsBeacons, tokenRingStatsLostFrameErrors=tokenRingStatsLostFrameErrors, tokenRingHostAuthorizedAccessPriority=tokenRingHostAuthorizedAccessPriority, tokenRingHistoryDataPkts=tokenRingHistoryDataPkts, tokenRingHistoryMonitorContentions=tokenRingHistoryMonitorContentions, tokenRingOrderLastEnterTime=tokenRingOrderLastEnterTime, tokenRingHostGroupAddresses=tokenRingHostGroupAddresses, tokenRingStatsLostMonitors=tokenRingStatsLostMonitors, tokenRingHostFrequencyErrors=tokenRingHostFrequencyErrors, tokenRingOrderEntry=tokenRingOrderEntry, tokenRingNetworkBridges=tokenRingNetworkBridges)

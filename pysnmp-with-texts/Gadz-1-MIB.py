#
# PySNMP MIB module Gadz-1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Gadz-1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:20:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, enterprises, IpAddress, MibIdentifier, Unsigned32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Bits, Counter32, iso, Gauge32, Integer32, Counter64, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "enterprises", "IpAddress", "MibIdentifier", "Unsigned32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Bits", "Counter32", "iso", "Gauge32", "Integer32", "Counter64", "TimeTicks", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gadzoox = MibIdentifier((1, 3, 6, 1, 4, 1, 1754))
netMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1))
common = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1))
zoning = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3))
download = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 4))
discovery = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 5))
monitor = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 6))
proxy = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7))
policy = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 11))
gbic = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 2))
areaSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 3))
channelAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 4))
traps = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 5))
switch = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 6))
capChas = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1))
capPim = MibIdentifier((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2))
sysReset = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("warm", 1), ("cold", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sysReset.setStatus('mandatory')
if mibBuilder.loadTexts: sysReset.setDescription("Setting this object results in the reset of the device. The context of warm vs cold is a function of the device's abilities.")
sysDiagnostic = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: sysDiagnostic.setDescription('When the sysDiagnostic object is written, it causes a diagnostic function to be executed. When read, it returns 0 for a successful completion of the test, 1 for test in process, and greater than 1 for an error indication of the test. Refer to device documentation for the exact definition of the error codes for the device')
nlZoningPolicyControlOwner = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlZoningPolicyControlOwner.setStatus('mandatory')
if mibBuilder.loadTexts: nlZoningPolicyControlOwner.setDescription('The entity that last configured, or is currently configuring the zoning policy.')
nlZoningPolicyTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlZoningPolicyTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: nlZoningPolicyTimeout.setDescription('The timeout value to be used in configuring the zoning agent. The default value is 30 seconds.')
nlZoningPolicyStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("no-current-owner", 0), ("request-valid", 1), ("request-invalid", 2), ("request-in-progress", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlZoningPolicyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlZoningPolicyStatus.setDescription('The status of the current zoning policy configuration.')
nlZoningPolicyControl = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("clear-owner", 0), ("create-table", 1), ("clear-zoning-configuration", 2), ("default-zoning-configuration", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlZoningPolicyControl.setStatus('mandatory')
if mibBuilder.loadTexts: nlZoningPolicyControl.setDescription("The control of the current zoning policy configuration. The procedure for zoning policy configuration is as follows: - user reads nlActiveZoneTable AND/OR nlActiveZoneMemberTable to determine current zone configuration and makes any local edits. - user continually reads back nlZoningPolicyStatus until 'no_current_owner' is received. - user writes its address to nlZoningPolicyControlOwner in order to lock zoning control and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - user can validate that it has successfully locked zone policy control by reading back its own address from nlZoningPolicyControlOwner. - user (optionally) writes timeout value to nlZoningPolicyTimeout, and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - user writes 'clear-zoning-configuration' to nlZoningPolicyControl to clear existing ta nlZoningPolicyControl to clear existing table and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - user continually adds zone OR zone member entries by writing to the appropriate objects using index 0 of the table, and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - after the last entry is made, user writes 'create_table' to nlZoningPolicyControl, and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - OR the user writes 'default-zoning-configuration' to load the default zoning configuration and then continually reads back nlZoningPolicyStatus until 'request_valid' is received. - user writes 'clear_owner' to nlZoningPolicyControl (or waits for the zoning timeout to occur) to release ownership of zoning policy configuration. ")
nlZoningPolicyLastError = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlZoningPolicyLastError.setStatus('mandatory')
if mibBuilder.loadTexts: nlZoningPolicyLastError.setDescription('The last error condition string returned from the zoning agent.')
nlPendingZoneCount = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlPendingZoneCount.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneCount.setDescription('Number of Pending configured zones for this proxied domain')
nlPendingZoneTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7), )
if mibBuilder.loadTexts: nlPendingZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneTable.setDescription('The Pending Zone Table. - this is the zone table the NMS is building up in the proxy domain, before activating it.')
nlPendingZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1), ).setIndexNames((0, "Gadz-1-MIB", "nlPendingZoneIndex"))
if mibBuilder.loadTexts: nlPendingZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneEntry.setDescription('nlPendingZone table entry')
nlPendingZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlPendingZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneIndex.setDescription('An identifier which uniquely identifies a zone in the nlPendingZoneTable')
nlPendingZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlPendingZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneName.setDescription('Specifies the name of the zone. This name is also unique in the Pending Zone Table')
nlPendingZoneType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("edgeDevice", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlPendingZoneType.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneType.setDescription('Specifies the type of the zone')
nlPendingZoneMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlPendingZoneMembers.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMembers.setDescription('Specifies A sequence of zone member indicies for this zone. Write to this object to add a set of zone members to a zone.')
nlPendingZoneLipToZonePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlPendingZoneLipToZonePolicy.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneLipToZonePolicy.setDescription('Specifies state of lip propagation policy 0: No lips should propagate into the zone 1: Only SCSI targets are allowed to propagate lips into the zone. 2: Lips are allowed to propagate into the zone from all devices. ')
nlPendingZoneMemberCount = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlPendingZoneMemberCount.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberCount.setDescription('Number of pending zone members for this proxied domain')
nlPendingZoneMemberTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9), )
if mibBuilder.loadTexts: nlPendingZoneMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberTable.setDescription('Pending Zone Member Table. This table keeps track of the pending zone members that the current snmp zone configuration session has written to the device. If nothing has been written to this table since the start of the current session, then this table will have no entries. Members are added to this table by writing a zone member name to the nlPendingZoneMemberName at an index of 0.')
nlPendingZoneMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9, 1), ).setIndexNames((0, "Gadz-1-MIB", "nlPendingZoneMemberIndex"))
if mibBuilder.loadTexts: nlPendingZoneMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberEntry.setDescription('nlPendingZoneMember table entry')
nlPendingZoneMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlPendingZoneMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberIndex.setDescription('An identifier which uniquely identifies a zone member.')
nlPendingZoneMemberName = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9, 1, 2), OctetString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: nlPendingZoneMemberName.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberName.setDescription('Specifies the name of the zone member. To add an entry to the list of zone member names, a write should be done to index 0.')
nlPendingZoneMemberType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("typeNotYetAssigned", 0), ("portZoneMember", 1), ("hardAssignedALPAZoneMember", 2), ("wwnZoneMember", 3)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: nlPendingZoneMemberType.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberType.setDescription('Specifies the type of this zone member. The type of the zone member dicates the structure of the PendingZoneMemberID. To add an entry to the list of zone member type, a write should be done to index 0. Note that a type of zero is only valid on a get operation. Currently, wwnZoneMember is not supported')
nlPendingZoneMemberID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 9, 1, 4), OctetString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: nlPendingZoneMemberID.setStatus('mandatory')
if mibBuilder.loadTexts: nlPendingZoneMemberID.setDescription("Specifies the intrinsic ID of this zone member. To add an entry to the list of zone member names, a write should be done to index 0. If the ZoneMemberType is PortZoneMember, the structure is: BYTE 0: The Proxy Management ID of the InterConnect device that this port belongs to. If 0, then this is a 'phantom' zone member, in that it does not have a corresponding device ID. Essentially, a phantom zone member is a zone member that has been created, but not yet bound to a proxied device. Use bytes 2 and 3 to correctly determine the ID of this zone member. BYTE 1: The Port Number on the InterConnect Device. BYTE 2: The device ID of the chassis that contains the slot that contains this port. (only valid if byte 0 equals 0) BYTE 3: The slot number of the slot that contains this port. (only valid if byte 0 is 0) If the ZoneMemberType is HardAssignedALPAZoneMember, then the structure is: BYTE 0: The Proxy Management ID of the InterConnect device that this port belongs to. If 0, then this is a 'phantom' zone member, in that it does not have a corresponding device ID. Essentially, a phantom zone member is a zone member that has been created, but not yet bound to a proxied device. Use bytes 3 and 4 to correctly determine the ID of this zone member. BYTE 1: The Port Number on the InterConnect Device. BYTE 2: The hard-assigned AL_PA of the NL_Node. BYTE 3: The device ID of the chassis that contains the slot that contains this port. (only valid if byte 0 equals 0) BYTE 4: The slot number of the slot that contains this port. (only valid if byte 0 is 0) If the ZoneMemberType is WWNZoneMember, the structure is: BYTE 0 -> size of string : The WWN of the zone member.")
nlActiveZoneCount = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneCount.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneCount.setDescription("Number of active configured zones for this proxied domain. When this object is read the 'Zoning Configuration Event' bit in the devEventStatus object will be reset to zero. ")
nlActiveZoneTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11), )
if mibBuilder.loadTexts: nlActiveZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneTable.setDescription('Active Zone Table.')
nlActiveZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1), ).setIndexNames((0, "Gadz-1-MIB", "nlActiveZoneIndex"))
if mibBuilder.loadTexts: nlActiveZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneEntry.setDescription('nlActiveZone table entry')
nlActiveZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneIndex.setDescription('An identifier which uniquely identifies a zone.')
nlActiveZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneName.setDescription('Specifies the name of the zone')
nlActiveZoneType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("edgeDevice", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneType.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneType.setDescription('Specifies the type of the zone')
nlActiveZoneAddressSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneAddressSpace.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneAddressSpace.setDescription('Specifies the address space this zone is in. An address space defines a set of Zones whose members share the same FC-AL address range.')
nlActiveZoneMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMembers.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMembers.setDescription('Specifies A sequence of zone member indexes for this zone. List is terminated by a value of zero.')
nlActiveZoneLipToZonePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneLipToZonePolicy.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneLipToZonePolicy.setDescription('Specifies state of lip propagation policy 0: No lips should propagate into the zone 1: Only SCSI targets are allowed to propagate lips into the zone. 2: Lips are allowed to propagate into the zone from all devices. ')
nlActiveZoneMemberCount = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMemberCount.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberCount.setDescription('Number of configured zone members for this proxied domain')
nlActiveZoneMemberTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13), )
if mibBuilder.loadTexts: nlActiveZoneMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberTable.setDescription('Active Zone Member Table.')
nlActiveZoneMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13, 1), ).setIndexNames((0, "Gadz-1-MIB", "nlActiveZoneMemberIndex"))
if mibBuilder.loadTexts: nlActiveZoneMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberEntry.setDescription('nlActiveZoneMember table entry')
nlActiveZoneMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberIndex.setDescription('An identifier which uniquely identifies a zone member.')
nlActiveZoneMemberName = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMemberName.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberName.setDescription('Specifies the name of the zone member')
nlActiveZoneMemberType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("portZoneMember", 1), ("hardAssignedALPAZoneMember", 2), ("wwnZoneMember", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMemberType.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberType.setDescription('Specifies the type of this zone member. The type of the zone member dictates the structure of the ActiveZoneMemberID')
nlActiveZoneMemberID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 1, 3, 13, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlActiveZoneMemberID.setStatus('mandatory')
if mibBuilder.loadTexts: nlActiveZoneMemberID.setDescription('Specifies the intrinsic ID of this zone member. The structure definition is identical to that of nlPendingZoneMemberID.')
downloadFile = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadFile.setStatus('mandatory')
if mibBuilder.loadTexts: downloadFile.setDescription('The file name to be downloaded from the TFTP server when a download is next requested via this MIB. This value is set to the zero length string when no file name has been specified.')
downloadBootFile = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: downloadBootFile.setDescription('The file name of the switch operational code to be executed on power up. This value is set to the zero length string when no file name has been specified.')
downloadTFTPServer = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadTFTPServer.setStatus('mandatory')
if mibBuilder.loadTexts: downloadTFTPServer.setDescription("The IP address of the TFTP server that contains the boot image to load when a download is next requested via this MIB. This value is set to `0.0.0.0' when no IP address has been specified.")
downloadTargetID = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadTargetID.setStatus('mandatory')
if mibBuilder.loadTexts: downloadTargetID.setDescription('The IntraCom ID of the device to download to. A value of 0 specifies the IntraCom master (i.e., the proxy agent). Values greater than 0 specify proxied devices.')
downloadAction = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notDownloading", 1), ("downloadToPROM", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadAction.setStatus('mandatory')
if mibBuilder.loadTexts: downloadAction.setDescription("When this object is set to downloadToPROM(2), the device will discontinue its normal operation and begin download of the image specified by downloadFile to the specified IntraCom target from the server specified by downloadTFTPServer using the TFTP protocol. The new image is written to the flash EPROM memory after its checksum has been verified to be correct. When the download process is completed, the device will warm boot to restart the newly loaded firmware. When the device is not downloading, this object will have a value of notDownloading(1). For some Gadzoox devices, there is a window of opportunity to cancel a download. Setting this object to the value 'notDownloading' during the TFTP file transfer from the downloadTFTPServer will cancel the current download for Gadzoox hub products.")
downloadStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("downloadSuccess", 1), ("downloadStatusUnknown", 2), ("downloadGeneralError", 3), ("downloadNoResponseFromServer", 4), ("downloadChecksumError", 5), ("downloadIncompatibleImage", 6), ("downloadTftpFileNotFound", 7), ("downloadTftpAccessViolation", 8), ("downloadAlreadyInProgress", 9), ("downloadCancelled", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: downloadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: downloadStatus.setDescription('The status of the last download procedure, if any. This object will have a value of downloadStatusUnknown(2) if no download process has been performed.')
downloadRetry = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadRetry.setStatus('mandatory')
if mibBuilder.loadTexts: downloadRetry.setDescription('Number of retries for each download attempt.')
downloadTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: downloadTimeOut.setDescription('Timeout value (in seconds) for each download retry.')
downloadCfgFileFileName = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadCfgFileFileName.setStatus('mandatory')
if mibBuilder.loadTexts: downloadCfgFileFileName.setDescription('The file name of the backup configuration files. The switches current configuration is saved in the backup configuration file. The switches configuration is also restored from the configuration file.')
downloadCfgFileServerIp = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadCfgFileServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: downloadCfgFileServerIp.setDescription("The IP address of the TFTP server that the backup configuration file will be saved to and restored from. This value is set to `0.0.0.0' when no IP address has been specified.")
downloadCfgFileAction = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("backupConfig", 2), ("restoreConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadCfgFileAction.setStatus('mandatory')
if mibBuilder.loadTexts: downloadCfgFileAction.setDescription("When this object is set to backupConfig(1), the device will write it's current configuration files as downloadCfgFileFileName.* to the server specified by downloadCfgFileServerIp. When this object is set to restoreConfig(2), the device will be reconfigured based on the downloadCfgFileFileName.* files located on the server specified by downloadCfgFileServerIp.")
downloadCfgFileBkupStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("backUpRestoreSuccess", 1), ("backUpRestoreStatusUnknown", 2), ("backUpRestoreIncomplete", 3), ("backUpRestoreGeneralError", 4), ("backUpRestoreNoFileNameSpecified", 5), ("backUpRestoreNoIpAddressSpecified", 6), ("backUpRestoreTftpDriverError", 7), ("backUpRestoreNoResponseFromServer", 8), ("backUpRestoreFileNotFound", 9), ("backUpRestoreCouldNotWriteFile", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: downloadCfgFileBkupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: downloadCfgFileBkupStatus.setDescription('The status of the last know backup/restore procedure, if any. This object will have a value of BackUpRestoreStatusUnknown(2) if no backup/restore process has been performed.')
proxyMaxMembers = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyMaxMembers.setStatus('mandatory')
if mibBuilder.loadTexts: proxyMaxMembers.setDescription("The maximum number of 'Proxy Managed Interconnect Devices' that can be supported from this agent.")
proxyCurMembers = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyCurMembers.setStatus('mandatory')
if mibBuilder.loadTexts: proxyCurMembers.setDescription("The number of 'Proxy Managed Interconnect Devices' currently connected to this agent.")
proxyChanges = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyChanges.setStatus('mandatory')
if mibBuilder.loadTexts: proxyChanges.setDescription("A count of the number of times 'Proxy Managed Interconnect Devices' have been added to or removed from this agent.")
proxyBoardID = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyBoardID.setStatus('mandatory')
if mibBuilder.loadTexts: proxyBoardID.setDescription("An Element Identifier to identify the physical IC board that contains the proxy agent. It's format is only relevant to Gadzoox service personnel.")
proxyFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: proxyFirmwareVersion.setDescription("An 'Element Identifier' to identify the firmware version of this SNMP proxy. The format of this identifier is as follows: MM.mm = majorVersion.minorVersion 02.04 as an example.")
proxyTopologyCRC = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyTopologyCRC.setStatus('mandatory')
if mibBuilder.loadTexts: proxyTopologyCRC.setDescription("CRC conducted on the Topology Table. Read: A change in this value indicates a change to the proxy domain ('Proxy Managed Interconnect Device' addition, deletion, or move). Write: A write will return OK if the value written equals the current Topology Table CRC and an ERROR if the value written does not equal the current Topology Table CRC.")
proxyEventStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: proxyEventStatus.setDescription("Register for Proxy Agent events. Events are 'Proxy Managed Interconnect Device' specific representing alarm-type events such as temperature/fan fault or change in port status")
proxyDeviceEventInd = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyDeviceEventInd.setStatus('mandatory')
if mibBuilder.loadTexts: proxyDeviceEventInd.setDescription("Sequential Device ID indication of any 'Proxy Managed Interconnect Device' events. Each successive read of this object will cycle to the next ID in the list that has outstanding events")
proxyControl = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyControl.setStatus('mandatory')
if mibBuilder.loadTexts: proxyControl.setDescription("This bit-mapped register declares this SNMP Proxy Agent as the one and only 'active' proxy agent from a possible set of potential SNMP Proxy Agents. Other potential SNMP Proxy Agents must have this value set to 'Disable'. Currently, it is the responsibility of the SNMP manager application to administer this object. Register Definition: BYTE 1 Bit 1: Proxy Control & Status Enable/Disable this device as the SNMP Proxy Agent. Note that this value is always read as 1 from a device that can only act as a proxy master. Setting this object on a device that can only act as proxy master has no effect")
deviceTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9), )
if mibBuilder.loadTexts: deviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTable.setDescription('A table of devices currently connected to the same Proxy Domain as this agent.')
deviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1), ).setIndexNames((0, "Gadz-1-MIB", "devDeviceID"))
if mibBuilder.loadTexts: deviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: deviceEntry.setDescription('Proxy Device Entry')
devDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: devDeviceID.setDescription('An integer, ranging consecutively from 1 to proxyCurMembers, which uniquely identifies a particular proxied device. It is not guaranteed, nor should it be assumed, that this identifier will remain constant for any given proxied device.')
devOID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devOID.setStatus('mandatory')
if mibBuilder.loadTexts: devOID.setDescription('The authoritative identification of the box which provides an easy and unambiguous means for determining the type of box.')
devProductID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devProductID.setStatus('mandatory')
if mibBuilder.loadTexts: devProductID.setDescription("An' Element Identifier' to identify the product type and serial number of this device.")
devBoardID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devBoardID.setStatus('mandatory')
if mibBuilder.loadTexts: devBoardID.setDescription("An 'Element Identifier' to identify the primary IC board for the proxied device. ")
devFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: devFirmwareVersion.setDescription("An 'Element Identifier' to identify the firmware version of this proxied device. ")
devEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: devEventStatus.setDescription('This bit-mapped register defines event indicators for the proxied device. Each bit in this register represents a single event defined as follows. Register Definition: BYTE 0 Bit 0: Port Event to clear bit access capPimPortStatus Bit 1: Chassis Event (Fan/Blower, Power, Temperature) to clear bit access capChasEventStatus Bit 2: Configuration Event to clear bit access capChasModuleStatus Bit 3: PIM Event to clear bit access capPimEventStatus Bit 4: Zoning Configuration Event to clear bit access nlActiveZoneCount ')
devReset = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("warm", 1), ("cold", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: devReset.setStatus('mandatory')
if mibBuilder.loadTexts: devReset.setDescription("Resets the proxied device. 'Cold' reset will initialize the device to the power-on state and execute a full self-test diagnostic. 'Warm' reset does the same but does not perform a destructive memory test. Note that some devices don't support a distinction between warm and cold reset (all resets are cold resets")
devDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: devDiagnostic.setDescription('When the this object is written, it causes a diagnostic function to be executed. When read, it returns 0 for a successful completion of the test, 1 for test in process, and greater than 1 for an error indication of the test. Refer to device documentation for the exact definition of the error codes for the device. For the Capellix switch the bit-mapped constant codes are defined as: PostInitialRamError = 0x2, PostRamError = 0x4, PostInitClockError = 0x8, PostSeepError = 0x10, PostValidFfsError = 0x20, PostInitializeFfsError = 0x40, PostDownloadError = 0x80, all other bits are reserved. ')
devSysUpTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devSysUpTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: devSysUpTimestamp.setDescription("The value of the device's sysUpTime at the time this object was last initialized. If the object has not been initialized since the last reinitialization of the proxy agent, then this object has a zero value.")
devCumulativeUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devCumulativeUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: devCumulativeUpTime.setDescription('Total number of hours that the device has be on. This is a persistent value that survives power cycle. ')
devContact = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devContact.setStatus('mandatory')
if mibBuilder.loadTexts: devContact.setDescription('User definable ASCII string to indication contact name for the device. This is a persistent value that survives power cycles.')
devLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devLocation.setStatus('mandatory')
if mibBuilder.loadTexts: devLocation.setDescription('User definable ASCII string to indication location for the device. This is a persistent value that survives power cycles.')
devTopologyLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: devTopologyLink.setStatus('mandatory')
if mibBuilder.loadTexts: devTopologyLink.setDescription('Toplogy Link. A unique octet triplet that associates a proxied device to the overall topology of the proxy domain. Register Definition: BYTE 1 : Parent IntraCom ID. This is the ID of the device that provides the next link up to the proxy device in the IntraCom management hierarchy. For the proxy agent, this value is zero. BYTE 2 : Parent Port. This is the port on the parent device that is connected to this device. BYTE 3 : Uplink Port. This is the port on this device that is connected to the parent device.')
devBeaconOnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devBeaconOnTime.setStatus('mandatory')
if mibBuilder.loadTexts: devBeaconOnTime.setDescription('Time (in 100ths of seconds) that Beacon LED is on. A value of zero (with devBeaconOffTime non-zero) will turn the LED permanently off. This object is not supported in this version of the MIB')
devBeaconOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devBeaconOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: devBeaconOffTime.setDescription('Time (in 100ths of seconds) that Beacon LED is off. A value of zero (with devBeaconOnTime non-zero) will turn the LED permanently on.B')
devFaultLedState = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devFaultLedState.setStatus('mandatory')
if mibBuilder.loadTexts: devFaultLedState.setDescription('State of Fault LED, 0=OFF, 1=ON.')
devNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: devNumPorts.setDescription('Number of configured ports for this proxied device. In the case of a chassis based device, this object represents the number of slots in the box')
devType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: devType.setStatus('mandatory')
if mibBuilder.loadTexts: devType.setDescription('Description data for this proxied device: Byte 3: OEM 1 Gadzoox (open market) 2 Hewlett Packard 3 Compaq 4 3Com 5 Sun Byte 2: masterType: 0 this is a slave hub 1 this is a permanent master hub, 2 this is a removable master hub, Byte 1: mediaConfig: 1 MEDIA_CONFIG_TYPE_10CO (m3) 2 MEDIA_CONFIG_TYPE_10SW_0LW (m4) 3 MEDIA_CONFIG_TYPE_8SW_2LW (m4) 4 MEDIA_CONFIG_TYPE_12GBIC (m5) 5 MEDIA_CONFIG_TYPE_12GBIC_FIB_COP (m5) 6 MEDIA_CONFIG_TYPE_6GBIC_FIB (m5) 7 MEDIA_CONFIG_TYPE_6GBIC_FIB_COP (m5) 10 MEDIA_CONFIG_TYPE_AS_3GBIC (as2) 17 MEDIA_CONFIG_TYPE_SWITCH_1U_8HSSDC (cap jr) 18 MEDIA_CONFIG_TYPE_SWITCH_1U_8SW (cap jr) 19 MEDIA_CONFIG_TYPE_SWITCH_1U_8GBIC (cap jr) 20 MEDIA_CONFIG_TYPE_CHASSIS_2U_3SLOT (cap) 21 MEDIA_CONFIG_TYPE_CHASSIS_3U_3SLOT (cap) 30 MEDIA_CONFIG_TYPE_CHASSIS_PIM_8CO) (cap) 31 MEDIA_CONFIG_TYPE_CHASSIS_PIM_8SW) (cap) 32 MEDIA_CONFIG_TYPE_CHASSIS_PIM_6GBIC) (cap) 33 MEDIA_CONFIG_TYPE_CHASSIS_PIM_12SW_1GBIC) (cap) 34 MEDIA_CONFIG_TYPE_CHASSIS_PIM_11HSSDC_1GBIC) (cap) 35 MEDIA_CONFIG_TYPE_CHASSIS_PIM_ILS(cap - inter-loop module) 36 MEDIA_CONFIG_TYPE_SWITCH_1U_PIM_3GBIC) (cap jr) Byte 0: numPowerSupply 0 NUM_POWER_SUPPLY_0 1 NUM_POWER_SUPPLY_1 2 NUM_POWER_SUPPLY_2 3 NUM_POWER_SUPPLY_3 ')
devDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 7, 9, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: devDescriptor.setDescription('An ASCII string to identify this device.')
gbicTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1), )
if mibBuilder.loadTexts: gbicTable.setStatus('mandatory')
if mibBuilder.loadTexts: gbicTable.setDescription("A table of serial GBIC information, indexed by device and port. Only GBIC-based devices must implement this table. Each port of a GBIC-based device will have a corresponding row, regardless of whether or not the port contains a serial GBIC; if the port does not contain a serial GBIC or if the serial GBIC information has not yet been fully read, then the value of gbicEntryValid is 'invalid'. The gbic device platforms requires a certain minimal level of firmware to support serial GBIC information. The FeatureMask object indicates whether or not this feature is supported via the SGBIC bit. If this feature is not supported on a given device, then the gbicEntryValid object will have the value 'invalid' for all ports on that device.")
gbicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1, 1), ).setIndexNames((0, "Gadz-1-MIB", "gbicDeviceIndex"), (0, "Gadz-1-MIB", "gbicPortIndex"))
if mibBuilder.loadTexts: gbicEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gbicEntry.setDescription('GBIC table entry')
gbicDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gbicDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gbicDeviceIndex.setDescription('An identifier which uniquely identifies a device.')
gbicPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gbicPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gbicPortIndex.setDescription('An identifier which uniquely identifies a device port.')
gbicEntryValid = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("invalid", 0), ("valid", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gbicEntryValid.setStatus('mandatory')
if mibBuilder.loadTexts: gbicEntryValid.setDescription('A flag that indicates whether or not this entry contains valid information.')
gbicInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 1, 8, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gbicInfo.setStatus('mandatory')
if mibBuilder.loadTexts: gbicInfo.setDescription("An encoded string that provides information for the serial GBIC associated with this entry's device and port indices. This value is only valid if the associated gbicEntryValid value is 1.")
capChasTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1), )
if mibBuilder.loadTexts: capChasTable.setStatus('mandatory')
if mibBuilder.loadTexts: capChasTable.setDescription('A table of Capellix chassis devices currently connected to the same agent.')
capChasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1), ).setIndexNames((0, "Gadz-1-MIB", "capChasDeviceID"))
if mibBuilder.loadTexts: capChasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: capChasEntry.setDescription('capChas table entry')
capChasDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: capChasDeviceID.setDescription('An identifier which uniquely identifies this device.')
capChasFeatureMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasFeatureMask.setStatus('mandatory')
if mibBuilder.loadTexts: capChasFeatureMask.setDescription('A bitmask indicating the features supported on this device. Certain MIB objects are supported only if the underlying feature is supported, as indicated by this object. Feature support may differ between devices due to hardware or software versions. At the present time all features are enabled, so this object is meaningless. ')
capChasEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capChasEventStatus.setDescription("This 2 byte bit-mapped register defines the asynchronous events that can occur on the chassis. When this object is read the 'Chassis Event' bit in the devEventStatus object will be reset to zero. Values: 0 = no fault, 1 = fault. Register Definition: BYTE 0 Bit 0: Fan 1 fault (left-most fan, from back of chassis) Bit 1: Fan 2 fault Bit 2: Fan 3 fault Bit 3: Fan 4 fault (right-most fan, from back of chassis) Bit 4: Power Supply 1 fault Bit 5: Power Supply 2 fault (if high availability unit) Bit 6: Power Supply 3 fault (if high availability unit) Bit 7: Reserved BYTE 1 Bit 0: Temperature fault Bits 1-3: Reserved: Bit 4: POST fault Bits 5-7: Reserved: ")
capChasLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capChasLedStatus.setDescription('This bitmapped object indicates state of each of the chassis LEDs. Values: 0 = LED is OFF, 1 = LED in ON. Register Definition: BYTE 0: Bit 0: power LED Bit 1: fault LED Bit 2: initialization LED Bit 3-7: Reserved BYTE 1: Bit 0: fan tray 1 LED Bit 1: fan tray 2 LED Bit 2-3: Reserved Bit 4: power supply 1 LED Bit 5: power supply 2 LED Bit 6: power supply 3 LED Bit 7: Reserved ')
capChasModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasModuleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capChasModuleStatus.setDescription("This bitmapped object indicates the presence of optional chassis modules (PIMs, power supplies, fan trays) that may or may not be installed in the chassis. A value of '1' indicates the presence of a module. When this object is read the 'Configuration Event' bit in the devEventStatus object will be reset to zero. Register Definition: BYTE 0: Bit 0: slot 1 PIM presence Bit 1: slot 2 PIM presence Bit 2: slot 3 PIM presence Bit 3: Reserved Bit 4: fan tray 1 presence Bit 5: fan tray 2 presence Bit 6-7: reserved BYTE 1: Bit 0: power supply 1 presence Bit 1: power supply 2 presence Bit 2: power supply 3 presence Bit 3-7: Reserved ")
capChasWorldWideName = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasWorldWideName.setStatus('mandatory')
if mibBuilder.loadTexts: capChasWorldWideName.setDescription('World Wide Name associated with this chassis.')
capChasTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: capChasTemperature.setDescription('Internal Temperature of the chassis (in degrees C).')
capChasTempMaxAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasTempMaxAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: capChasTempMaxAllowed.setDescription('Maximum Allowable Internal Temperature of the chassis .')
capChasTempMaxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: capChasTempMaxThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: capChasTempMaxThreshold.setDescription('User-configurable Maximum Internal Temperature Threshold of the chassis.')
capChasSANDoctor = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: capChasSANDoctor.setStatus('mandatory')
if mibBuilder.loadTexts: capChasSANDoctor.setDescription('User-configurable SAN Doctor function of the chassis.')
capChasSlotTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2), )
if mibBuilder.loadTexts: capChasSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: capChasSlotTable.setDescription('')
capChasSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1), ).setIndexNames((0, "Gadz-1-MIB", "capChasDevID"), (0, "Gadz-1-MIB", "capChasSlotNum"))
if mibBuilder.loadTexts: capChasSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: capChasSlotEntry.setDescription('Capellix chassis slot table entry')
capChasDevID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasDevID.setStatus('mandatory')
if mibBuilder.loadTexts: capChasDevID.setDescription('An identifier which uniquely identifies the Capellix chassis that contains this PIM.')
capChasSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: capChasSlotNum.setDescription('The slot index of this PIM on this chassis.')
capChasPimDevID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capChasPimDevID.setStatus('mandatory')
if mibBuilder.loadTexts: capChasPimDevID.setDescription('An identifier which uniquely identifies this PIM in the proxy domain. If this value is 0, this PIM is not managealbe by this chassis.')
capSlotPimType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capSlotPimType.setStatus('mandatory')
if mibBuilder.loadTexts: capSlotPimType.setDescription('Description data for this PIM The enumeration of the bytes in this object are identicial to that defined in the object devType.')
capSlotPimStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("empty", 1), ("present-and-active", 2), ("present-but-inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capSlotPimStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capSlotPimStatus.setDescription('The value of this object indicates the general status of this PIM.')
capSlotPimIPaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capSlotPimIPaddr.setStatus('mandatory')
if mibBuilder.loadTexts: capSlotPimIPaddr.setDescription('The (potential) IP address of this PIM. If a PIM does not support an IP address, this value is 0.')
capPimTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1), )
if mibBuilder.loadTexts: capPimTable.setStatus('mandatory')
if mibBuilder.loadTexts: capPimTable.setDescription('A table of Capellix chassis PIMs currently connected to the same agent.')
capPimEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1), ).setIndexNames((0, "Gadz-1-MIB", "capPimDeviceID"))
if mibBuilder.loadTexts: capPimEntry.setStatus('mandatory')
if mibBuilder.loadTexts: capPimEntry.setDescription('capPim table entry')
capPimDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: capPimDeviceID.setDescription('An identifier which uniquely identifies this PIM.')
capPimFeatureMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimFeatureMask.setStatus('mandatory')
if mibBuilder.loadTexts: capPimFeatureMask.setDescription('A bitmask indicating the features supported on this device. Certain MIB objects are supported only if the underlying feature is supported, as indicated by this object. Feature support may differ between devices due to hardware or software versions. At the present time all features are enabled, so this object is meaningless. ')
capPimEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capPimEventStatus.setDescription("This 2 byte bit-mapped register defines the asynchronous events that can occur on the PIM. When this object is read the 'PIM Event' bit in the devEventStatus object will be reset to zero. Register Definition: BYTE 0: Bit 0: power supply temperature Bit 1: power level Bit 2: POST fault Bit 3-7: reserved BYTE 1: Reserved ")
capPimLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capPimLedStatus.setDescription('This bitmapped object indicates state of each of the PIM LEDs. Values: 0 = LED is OFF, 1 = LED in ON. Register Definition: BYTE 0: Bit 0: power LED Bit 1: fault LED Bit 2-7: reserved BYTES 1-2: PIM port LEDs BYTE 1, Bits 0-7 = ports 1-8 BYTE 2, Bits 0-7 = ports 9-16 Note that this object is not supported in this release of the MIB ')
capPimPortAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimPortAttributes.setStatus('mandatory')
if mibBuilder.loadTexts: capPimPortAttributes.setDescription('A 16 byte bitmapped octet string that describes the attributes of each of the ports on this PIM. Bytes 0 - 15 describe ports 1 - 16 respectively. Register Definition: Bit Meaning --- ------- 7 Reserved (IntraComm) 6-0 Media type: 0 = GBIC Optical ShortWave 1 = GBIC Optical LongWave 2 = GBIC Optical ShortWave 3 = GBIC Copper Style DB-9 connector 4 = reserved 5 = GBIC Copper Style-2 connector (from parallel ID) 6 = GBIC type information available via serial ID 7 = No GBIC installed 8 = Fixed Copper DB9 9 = Fixed Optical ShortWare - 1.06 Gigabit 10 = Fixed Optical High Density 11 = Unknown 12 = Fixed Copper HSSDC ')
capPimPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPimPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: capPimPortStatus.setDescription("This 16 byte bitmapped object describes the status of each of the ports on the PIM. The layout of the bits in each byte is as follows: Bit Meaning --- ------- 3-0 encoded state: 0: No GBIC installed 1: Force bypassed by Management 2: Bypassed due to no incomming signal 3: Bypassed due to no outgoin signal 4: Bypassed due to fault: K28.5 denstiy 5: Bypassed due to fault: Running disparity 6: Bypassed due to fault: Mis-aligned K28.5 7: Bypassed due to fault: RLE 8: Bypassed because port is not in any zone 9: Bypassed waiting Cut-In authorization 10: Enabled and initializing 11: Enabled and active 12: Force bypassed by SAN Doctor When this object is read the 'Port Event' bit in the devEventStatus object will be reset to zero.")
capPortTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2), )
if mibBuilder.loadTexts: capPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: capPortTable.setDescription("A table of port objects for the Capellix PIM's")
capPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1), ).setIndexNames((0, "Gadz-1-MIB", "capPortDeviceID"), (0, "Gadz-1-MIB", "capPortIndex"))
if mibBuilder.loadTexts: capPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: capPortEntry.setDescription('cap port table entry')
capPortDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPortDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: capPortDeviceID.setDescription('An identifier which uniquely identifies the capellix PIM that contains this port.')
capPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: capPortIndex.setDescription('The index of this port on the device.')
capPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: capPortType.setStatus('mandatory')
if mibBuilder.loadTexts: capPortType.setDescription(' Port Type 0: unknown 1: initiator 2: target 3: both initator and target ')
capPortForcedBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: capPortForcedBypass.setStatus('mandatory')
if mibBuilder.loadTexts: capPortForcedBypass.setDescription(' Force Port Bypass Control 0: forced port bypass mode is DISABLED 1: forced port bypass mode is ENABLED ')
capPortLipType = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: capPortLipType.setStatus('mandatory')
if mibBuilder.loadTexts: capPortLipType.setDescription(' Lip Generation Type 0: generate LIP F7 (if LIP generation is enabled) 1: generate LIP F8 (if LIP generation is enabled) ')
capPortAlpaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPortAlpaCount.setStatus('mandatory')
if mibBuilder.loadTexts: capPortAlpaCount.setDescription('The total number of detected ALPAs for this port. indicates detection of ALPA 1, and so on. This count is cleared upon either loop initialization or bypass of this port. Bit values can also be cleared manually via capAlpaClear.')
capPortAlpaBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPortAlpaBitmap.setStatus('mandatory')
if mibBuilder.loadTexts: capPortAlpaBitmap.setDescription('Bitmap of ALPAs detected on this port. Bytes 0-15 form an LoopID bitmap similar in form to the bitmaps used in FC-AL address assignment (LIFA/LIPA/LIHA/LISA). If bit 7 of byte 0 is set, then LoopID 0 has been detected on this port. Bit 6 of byte 0 indicates detection of LoopID 1, and so on. This is bitmap is cleared upon either loop initialization or bypass of this port.')
capPortLipInitiatorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 6, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capPortLipInitiatorCount.setStatus('mandatory')
if mibBuilder.loadTexts: capPortLipInitiatorCount.setDescription('Counts the number of times that this port was the first to detect a LIP during loop initialization.')
trapIPaddrTable = MibTable((1, 3, 6, 1, 4, 1, 1754, 1, 5, 1), )
if mibBuilder.loadTexts: trapIPaddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPaddrTable.setDescription('A table of IP addresses to which traps should be sent.')
trapIPentry = MibTableRow((1, 3, 6, 1, 4, 1, 1754, 1, 5, 1, 1), ).setIndexNames((0, "Gadz-1-MIB", "trapIndex"))
if mibBuilder.loadTexts: trapIPentry.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPentry.setDescription('trap table entry')
trapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapIndex.setDescription('An identifier which uniquely identifies the device to send the trap to.')
trapIPaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1754, 1, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapIPaddr.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPaddr.setDescription('The IP address of the device to send the trap to. To add an entry to the list of Trap IP addresses, a write should be done to index 0. To delete an entry from the list of Trap IP addresses, a write should be done to the desired index to be deleted with the IpAddress to be deleted. This will cause the Trap IP address table to shrink by one entry. To read the list of Trap IP addresses, indexes starting at 1 and incrementing should be used. An error indication will be returned when the end of the table is reached.')
trapDevID = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevID.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevID.setDescription('The deviceID of the device with the trap condition.')
trapDevType = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevType.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevType.setDescription('The type of device with the trap condition. The definition of this field is identical to devType.')
trapDevEventStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevEventStatus.setDescription('The event status of the device with the trap condition. The definition of this field is identical to devEventStatus.')
trapDevEnvironmentStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevEnvironmentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevEnvironmentStatus.setDescription('The environmental status of the device with the trap condition. The definition of this field depends on the type of device for which this trap was sent. ')
trapDevPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 36)).setFixedLength(36)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevPortStatus.setDescription('The port status of the device with the trap condition. The definition of this field depends on the type of device for whom this trap was sent. The assumption is that the port status for each port fits in 1 byte.')
trapDevPortAttributes = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 36)).setFixedLength(36)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevPortAttributes.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevPortAttributes.setDescription('The port attributes of the device with the trap condition. The definition of this field depends on the type of device for whom this trap was sent. The assumption is that the port attributes for each port fits in 1 byte.')
trapDevConfigStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevConfigStatus.setDescription('The Configuration Status of the device with the trap condition. The definition of this field depends on the type of device for whom this trap was sent. Examples of this event include inserting or removing a plug-in card.')
trapDevLIPStatus = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDevLIPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDevLIPStatus.setDescription('The Lip status of the device with the trap condition. The definition of this field depends on the type of device for whom this trap was sent. Examples of this event include changes to the m5LIPStatus field.')
trapMaxNumberTrapTargets = MibScalar((1, 3, 6, 1, 4, 1, 1754, 1, 5, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapMaxNumberTrapTargets.setStatus('mandatory')
if mibBuilder.loadTexts: trapMaxNumberTrapTargets.setDescription('The maximumnum number of IP addresses that can be specified as recepients of traps that are sent from this device.')
trapLIPStatus = NotificationType((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1) + (0,1)).setObjects(("Gadz-1-MIB", "trapDevID"), ("Gadz-1-MIB", "trapDevType"), ("Gadz-1-MIB", "trapDevLIPStatus"))
if mibBuilder.loadTexts: trapLIPStatus.setDescription('Information to be sent describing an LIP trap from an IntraCom device. Note that this trap may not be supported on some Gadzoox devices')
trapMgmtTopologyChange = NotificationType((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1) + (0,2)).setObjects(("Gadz-1-MIB", "trapDevID"), ("Gadz-1-MIB", "trapDevType"))
if mibBuilder.loadTexts: trapMgmtTopologyChange.setDescription('Information to be sent describing an topology change trap from an IntraCom device (subcode=2)')
trapEnvironment = NotificationType((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1) + (0,3)).setObjects(("Gadz-1-MIB", "trapDevID"), ("Gadz-1-MIB", "trapDevType"), ("Gadz-1-MIB", "trapDevEnvironmentStatus"))
if mibBuilder.loadTexts: trapEnvironment.setDescription('Information to be sent describing an environmental trap from an IntraCom device (subcode=3)')
trapPortStatus = NotificationType((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1) + (0,4)).setObjects(("Gadz-1-MIB", "trapDevID"), ("Gadz-1-MIB", "trapDevType"), ("Gadz-1-MIB", "trapDevPortStatus"), ("Gadz-1-MIB", "trapDevPortAttributes"))
if mibBuilder.loadTexts: trapPortStatus.setDescription('Information to be sent describing an port status trap from an IntraCom device (subcode=4)')
trapConfigurationStatus = NotificationType((1, 3, 6, 1, 4, 1, 1754, 1, 6, 1) + (0,5)).setObjects(("Gadz-1-MIB", "trapDevID"), ("Gadz-1-MIB", "trapDevType"), ("Gadz-1-MIB", "trapDevConfigStatus"))
if mibBuilder.loadTexts: trapConfigurationStatus.setDescription('Information to be sent describing an configuration trap from an IntraCom device (subcode=5)')
mibBuilder.exportSymbols("Gadz-1-MIB", nlZoningPolicyTimeout=nlZoningPolicyTimeout, trapMgmtTopologyChange=trapMgmtTopologyChange, capChasSANDoctor=capChasSANDoctor, devOID=devOID, capChasWorldWideName=capChasWorldWideName, capSlotPimIPaddr=capSlotPimIPaddr, switch=switch, nlActiveZoneType=nlActiveZoneType, proxy=proxy, trapDevPortAttributes=trapDevPortAttributes, downloadAction=downloadAction, capChasTempMaxAllowed=capChasTempMaxAllowed, capChasFeatureMask=capChasFeatureMask, nlActiveZoneMemberIndex=nlActiveZoneMemberIndex, hub=hub, downloadStatus=downloadStatus, proxyDeviceEventInd=proxyDeviceEventInd, devType=devType, sysReset=sysReset, capChasEntry=capChasEntry, gbicEntry=gbicEntry, nlPendingZoneType=nlPendingZoneType, proxyTopologyCRC=proxyTopologyCRC, netMgmt=netMgmt, devDiagnostic=devDiagnostic, proxyControl=proxyControl, trapMaxNumberTrapTargets=trapMaxNumberTrapTargets, security=security, trapLIPStatus=trapLIPStatus, devReset=devReset, capPortEntry=capPortEntry, nlPendingZoneMemberID=nlPendingZoneMemberID, capPimFeatureMask=capPimFeatureMask, devFaultLedState=devFaultLedState, trapDevEnvironmentStatus=trapDevEnvironmentStatus, devLocation=devLocation, capPimPortStatus=capPimPortStatus, capPimEventStatus=capPimEventStatus, nlActiveZoneTable=nlActiveZoneTable, capChasTable=capChasTable, trapIPaddr=trapIPaddr, areaSwitch=areaSwitch, capPortTable=capPortTable, nlZoningPolicyLastError=nlZoningPolicyLastError, capChasPimDevID=capChasPimDevID, capChasDeviceID=capChasDeviceID, nlActiveZoneMemberName=nlActiveZoneMemberName, capPimEntry=capPimEntry, nlActiveZoneLipToZonePolicy=nlActiveZoneLipToZonePolicy, capPortLipInitiatorCount=capPortLipInitiatorCount, nlPendingZoneEntry=nlPendingZoneEntry, trapDevEventStatus=trapDevEventStatus, capChasTempMaxThreshold=capChasTempMaxThreshold, capPortAlpaBitmap=capPortAlpaBitmap, downloadCfgFileServerIp=downloadCfgFileServerIp, capPortIndex=capPortIndex, proxyChanges=proxyChanges, nlPendingZoneMemberEntry=nlPendingZoneMemberEntry, proxyFirmwareVersion=proxyFirmwareVersion, gbicInfo=gbicInfo, devTopologyLink=devTopologyLink, discovery=discovery, devContact=devContact, nlActiveZoneMemberCount=nlActiveZoneMemberCount, capChas=capChas, devDeviceID=devDeviceID, gbic=gbic, downloadCfgFileFileName=downloadCfgFileFileName, nlActiveZoneMemberID=nlActiveZoneMemberID, downloadFile=downloadFile, capPortForcedBypass=capPortForcedBypass, devBeaconOffTime=devBeaconOffTime, trapPortStatus=trapPortStatus, capChasSlotTable=capChasSlotTable, gbicEntryValid=gbicEntryValid, download=download, proxyCurMembers=proxyCurMembers, nlPendingZoneIndex=nlPendingZoneIndex, capPimTable=capPimTable, deviceEntry=deviceEntry, nlZoningPolicyControl=nlZoningPolicyControl, trapIndex=trapIndex, downloadCfgFileAction=downloadCfgFileAction, nlActiveZoneAddressSpace=nlActiveZoneAddressSpace, downloadTargetID=downloadTargetID, devFirmwareVersion=devFirmwareVersion, nlActiveZoneMemberEntry=nlActiveZoneMemberEntry, capSlotPimStatus=capSlotPimStatus, capChasLedStatus=capChasLedStatus, trapDevID=trapDevID, capPortDeviceID=capPortDeviceID, nlPendingZoneMemberIndex=nlPendingZoneMemberIndex, trapDevConfigStatus=trapDevConfigStatus, devEventStatus=devEventStatus, monitor=monitor, sysDiagnostic=sysDiagnostic, downloadTFTPServer=downloadTFTPServer, proxyBoardID=proxyBoardID, gbicDeviceIndex=gbicDeviceIndex, system=system, zoning=zoning, capPimPortAttributes=capPimPortAttributes, nlZoningPolicyControlOwner=nlZoningPolicyControlOwner, trapEnvironment=trapEnvironment, trapDevType=trapDevType, capPimDeviceID=capPimDeviceID, nlPendingZoneMemberCount=nlPendingZoneMemberCount, capPortLipType=capPortLipType, devDescriptor=devDescriptor, downloadCfgFileBkupStatus=downloadCfgFileBkupStatus, nlActiveZoneMemberType=nlActiveZoneMemberType, proxyEventStatus=proxyEventStatus, capPimLedStatus=capPimLedStatus, gbicPortIndex=gbicPortIndex, nlActiveZoneEntry=nlActiveZoneEntry, nlPendingZoneMemberTable=nlPendingZoneMemberTable, devCumulativeUpTime=devCumulativeUpTime, downloadTimeOut=downloadTimeOut, nlPendingZoneCount=nlPendingZoneCount, channelAgent=channelAgent, capChasEventStatus=capChasEventStatus, capPortType=capPortType, nlActiveZoneIndex=nlActiveZoneIndex, downloadBootFile=downloadBootFile, devSysUpTimestamp=devSysUpTimestamp, capChasModuleStatus=capChasModuleStatus, trapConfigurationStatus=trapConfigurationStatus, downloadRetry=downloadRetry, trapDevPortStatus=trapDevPortStatus, nlActiveZoneMembers=nlActiveZoneMembers, capPim=capPim, capPortAlpaCount=capPortAlpaCount, nlActiveZoneCount=nlActiveZoneCount, trapIPaddrTable=trapIPaddrTable, capChasSlotEntry=capChasSlotEntry, common=common, devBoardID=devBoardID, nlActiveZoneMemberTable=nlActiveZoneMemberTable, gadzoox=gadzoox, nlPendingZoneTable=nlPendingZoneTable, proxyMaxMembers=proxyMaxMembers, deviceTable=deviceTable, devProductID=devProductID, nlActiveZoneName=nlActiveZoneName, nlPendingZoneName=nlPendingZoneName, nlPendingZoneMembers=nlPendingZoneMembers, nlPendingZoneMemberType=nlPendingZoneMemberType, nlPendingZoneMemberName=nlPendingZoneMemberName, capChasDevID=capChasDevID, capChasSlotNum=capChasSlotNum, nlZoningPolicyStatus=nlZoningPolicyStatus, nlPendingZoneLipToZonePolicy=nlPendingZoneLipToZonePolicy, traps=traps, policy=policy, capSlotPimType=capSlotPimType, capChasTemperature=capChasTemperature, trapIPentry=trapIPentry, gbicTable=gbicTable, devNumPorts=devNumPorts, trapDevLIPStatus=trapDevLIPStatus, devBeaconOnTime=devBeaconOnTime)

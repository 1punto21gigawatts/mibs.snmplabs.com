#
# PySNMP MIB module CISCO-SUBSCRIBER-SESSION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-SUBSCRIBER-SESSION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:13:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
CbpElementName, = mibBuilder.importSymbols("CISCO-CBP-TC-MIB", "CbpElementName")
DynamicTemplateName, = mibBuilder.importSymbols("CISCO-DYNAMIC-TEMPLATE-TC-MIB", "DynamicTemplateName")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
SubscriberDnis, SubscriberLabel, SubSessionIdentity, SubSessionIdentities, SubscriberTunnelName, SubscriberVRF, SubscriberDomain, SubscriberCircuitId, SubscriberNasPort, SubscriberAcctSessionId, SubscriberProtocolType, SubscriberDhcpClass, SubscriberLocationName, SubscriberServiceName, SubscriberUsername, SubscriberRemoteId, SubscriberMediaType, SubscriberPbhk = mibBuilder.importSymbols("CISCO-SUBSCRIBER-IDENTITY-TC-MIB", "SubscriberDnis", "SubscriberLabel", "SubSessionIdentity", "SubSessionIdentities", "SubscriberTunnelName", "SubscriberVRF", "SubscriberDomain", "SubscriberCircuitId", "SubscriberNasPort", "SubscriberAcctSessionId", "SubscriberProtocolType", "SubscriberDhcpClass", "SubscriberLocationName", "SubscriberServiceName", "SubscriberUsername", "SubscriberRemoteId", "SubscriberMediaType", "SubscriberPbhk")
SubSessionState, SubSessionType, SubSessionRedundancyMode = mibBuilder.importSymbols("CISCO-SUBSCRIBER-SESSION-TC-MIB", "SubSessionState", "SubSessionType", "SubSessionRedundancyMode")
PhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "PhysicalIndex")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
PerfTotalCount, PerfCurrentCount, PerfIntervalCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfTotalCount", "PerfCurrentCount", "PerfIntervalCount")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Unsigned32, TimeTicks, Counter32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, Integer32, iso, MibIdentifier, ObjectIdentity, ModuleIdentity, Gauge32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "TimeTicks", "Counter32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "Integer32", "iso", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "Gauge32", "IpAddress")
DisplayString, DateAndTime, MacAddress, RowStatus, TextualConvention, TimeStamp, TruthValue, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "DateAndTime", "MacAddress", "RowStatus", "TextualConvention", "TimeStamp", "TruthValue", "StorageType")
ciscoSubscriberSessionMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 786))
ciscoSubscriberSessionMIB.setRevisions(('2012-08-08 00:00', '2012-03-12 00:00', '2011-09-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoSubscriberSessionMIB.setRevisionsDescriptions(('csubAggStatsThreshTable , csubAggStatsThreshGroup, csubAggStatsNotifGroup are newly added', 'SubscriberLoationName corrected to SubscriberLocationName', 'The initial version of the MIB module.',))
if mibBuilder.loadTexts: ciscoSubscriberSessionMIB.setLastUpdated('201208080000Z')
if mibBuilder.loadTexts: ciscoSubscriberSessionMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoSubscriberSessionMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoSubscriberSessionMIB.setDescription("This MIB defines objects describing subscriber sessions, or more specifically, subscriber sessions terminated by a RAS. A subscriber session consists of the traffic between a CPE and a NAS, as illustrated in the diagram below. Service Access Provider Network Network +--+ +---+ +--+ { } +---+ { } |PC+--+CPE+--+AN+--{ }--+NAS+--{ } +--+ +---+ +--+ { } +---+ { } | | |<--------------->| subscriber session A subscriber session behaves according to the FSM illustrated below. +-----------------+ +--->| DISCONNECTED |<-------+ | +--------+--------+ | | | | | failed | initiated | disconnect | V | | +-----------------+ | +----+ PENDING +--------+ +--------+--------+ | | | | established | V | +----------------------------+ | | UP | | | +---+ | +-----------------+ | | | UNAUTHENTICATED | | | +--------+--------+ | | | | | | authenticated | | V | | +-----------------+ | | | AUTHENTICATED | | | +-----------------+ | | | +----------------------------+ A subscriber session in the DISCONNECTED state technically doesn't exist; that is, the system does not maintain a context to describe a disconnected subscriber session. Once the system detects the initiation of a subscriber session, then it creates a context and places the subscriber session in the PENDING state. The initiation of a subscriber session can occur either through provisioning or the reception of a packet. In the PENDING state, a system does not forward subscriber traffic. A pending subscriber session can become DISCONNECTED if it fails to come up (e.g., a timeout) or if the system or the subscriber explicitly terminates the subscriber session. A pending subscriber session can become UP if the system successfully configures and applies any relevant policies. Once in the UP state, a system forwards subscriber traffic. A operationally UP subscriber session can become DISCONNECTED if either system or the subscriber terminates it. A operationally UP subscriber session can either be UNAUTHENTICATED or AUTHENTICATED. When the system is in the process of checking a the credentials associated with a subscriber session, it is in the UNAUTHENTICATED state. When the system successfully completes this process, it transitions the subscriber session to the AUTHENTICATED state. If the process fails, then the system terminates the subscriber session. Besides describing individual subscriber sessions, this MIB module provides an EMS/NMS with the means to perform the following functions: 1) Enumerate subscriber sessions by ifIndex. 2) Enumerate subscriber sessions by subscriber session type and ifIndex. 3) Monitor aggregated statistics relating to subscriber sessions: a. System-wide b. System-wide by subscriber session type c. Per node d. Per node by subscriber session type 4) Collect 15-minute aggregated performance data history relating to subscriber sessions: a. System-wide b. System-wide by subscriber session type c. Per node d. Per node by subscriber session type 5) Submit a query for a report containing those subscriber sessions that match a specified identity match criteria. 6) Terminate those subscriber session that match a specified identify match criteria. GLOSSARY ======== Access Concentrator See NAS. Access Network The network that provides connectivity between a AN and NAS. An access network may provide L2 or L3 connectivity. If the access network provide L2 connectivity, it may switch traffic or tunnel it through a MPLS or IP network. AN (Access Node) A device (e.g., a DSLAM) that multiplexes or switches traffic between many CPEs and an access network. BRAS (Broadband Remote Access Server) See NAS. CPE (Customer Premise Equipment) A device (e.g., a DSL modem) that connects a customer's network to an AN. DHCP (Dynamic Host Configuration Protocol) The protocol that provides a framework for transacting configuration information to devices on an IP network, as specified by RFC-2131. NAS (Network Access Server) A device that switches or routes traffic between subscriber sessions and service provider networks. Network Service Access to the Internet backbone, voice, video, or other content. Node A physical entity capable of maintaining a subscriber session within a distributed system. The notion of a node is not applicable to a centralized system. PADI (PPPoE Active Discovery Initiation) A subscriber broadcasts a PADI packet to start the process of discovering access concentrators capable of serving it. PADO (PPPoE Active Discovery Offer) The packet sent by an access concentrator to a subscriber indicating that it can serve the subscriber. PADR (PPPoE Active Discovery Request) The packet sent by a subscriber to an access concentrator requesting a PPPoE connection. PADS (PPPoE Active Discovery Session-confirmation) The packet sent by an access concentrator to a subscriber confirming the request for a PPPoE connection. Once this packet has been sent, then the PPP can proceed as specified by RFC-1661. PADT (PPPoE Active Discovery Terminate) The packet indicating that a PPPoE connection has been terminated. Either the subscriber or the access concentrator can send this packet. PPP (Point-to-Point Protocol) The standard method for transporting multi-protocol datagrams over point-to-point links, as defined by RFC-1661. The PPP specifies the encapsulation for these datagrams and the protocols necessary for establishing, configuring, and maintaining connectivity. PPPoE (Point-to-Point Protocol over Ethernet) The protocol and encapsulation necessary to support a PPP connection over an Ethernet connection, as defined by IETF RFC-2516. Service Provider Network The network that provides connectivity between a NAS and a network service. Subscriber A customer of a network service. Subscriber Session A context maintained by a NAS for the purpose of classifying a subscriber's traffic, maintaining a subscriber's identity, applying configuration and policies, and maintaining statistics. For more information on the types of subscriber sessions, see the CISCO-SUBSCRIBER-SESSION-TC-MIB.")
class SubscriberJobIdentifier(TextualConvention, Unsigned32):
    description = 'An arbitrary positive, integer-value uniquely identifying a subscriber session job.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class SubscriberJobIdentifierOrZero(TextualConvention, Unsigned32):
    description = "This textual convention serves as an extension of the SubscriberJobIdentifier textual convention, which permits the value '0'. The use of the value '0' is specific to an object, thus requiring the descriptive text associated with the object to describe the semantics of its use."
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

ciscoSubscriberSessionMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 0))
ciscoSubscriberSessionMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 1))
ciscoSubscriberSessionMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 2))
csubSession = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1))
csubAggStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2))
csubJob = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3))
csubAggThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 4))
csubSessionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1), )
if mibBuilder.loadTexts: csubSessionTable.setStatus('current')
if mibBuilder.loadTexts: csubSessionTable.setDescription('This table describes a list of subscriber sessions currently maintained by the system. This table has a sparse dependent relationship on the ifTable, containing a row for each interface having an interface type describing a subscriber session.')
csubSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: csubSessionEntry.setStatus('current')
if mibBuilder.loadTexts: csubSessionEntry.setDescription("This entry contains data describing a subscriber sessions, including its state, configuration, and collected identities. An entry exists for a corresponding entry in the ifTable describing a subscriber session. Currently, subscriber sessions must have one of the following ifType values: 'ppp' 'ipSubscriberSession' 'l2SubscriberSession' The system creates an entry when it establishes a subscriber session. Likewise, the system destroys an entry when it terminates the corresponding subscriber session.")
csubSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 1), SubSessionType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionType.setStatus('current')
if mibBuilder.loadTexts: csubSessionType.setDescription('This object indicates the type of subscriber session.')
csubSessionIpAddrAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("static", 3), ("localPool", 4), ("dhcpv4", 5), ("dhcpv6", 6), ("userProfileIpAddr", 7), ("userProfileIpSubnet", 8), ("userProfileNamedPool", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionIpAddrAssignment.setStatus('current')
if mibBuilder.loadTexts: csubSessionIpAddrAssignment.setDescription("This object indicates how the system assigns IP addresses to the subscriber: 'none' The system does not an involvement in (or is it aware of) the assignment an subscriber IP addresses. For example, a system does not have an involvement in the assignment of subscriber IP addresses for IP interface subscriber sessions. 'other' The system assigns subscriber IP addresses using a method not recognized by this MIB module. 'static' Subscriber IP addresses have been configured correctly for the service domain. The system does not have an involvement in the assignment of the IP address. 'localPool' The system assigns subscriber IP addresses from a locally configured pool of IP addresses. 'dhcpv4' The system assigns subscriber IP addresses are using the DHCPv4. 'dhcpv6' The system assigns subscriber IP addresses using the DHCPv6. 'userProfileIpAddr' The system assigns subscriber IP addresses from a user profile. 'userProfileIpSubnet' The system assigns the subscriber an IP subnet from a user profile. 'userProfileNamedPool' The system assigns subscriber IP addresses from a locally configured named pool specified by a user profile.")
csubSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 3), SubSessionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionState.setStatus('current')
if mibBuilder.loadTexts: csubSessionState.setDescription('This object indicates the operational state of the subscriber session.')
csubSessionAuthenticated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionAuthenticated.setStatus('current')
if mibBuilder.loadTexts: csubSessionAuthenticated.setDescription("This object indicates whether the system has successfully authenticated the subscriber session. 'false' The subscriber session is operationally up, but in the UNAUTHENTICATED state. 'true' The subscriber session is operationally up, but in the AUTHENTICATED state.")
csubSessionRedundancyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 5), SubSessionRedundancyMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: csubSessionRedundancyMode.setDescription('This object indicates the redundancy mode in which the subscriber session is operating.')
csubSessionCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionCreationTime.setStatus('current')
if mibBuilder.loadTexts: csubSessionCreationTime.setDescription('This object indicates when the subscriber session was created (i.e., when the subscriber session was initiated).')
csubSessionDerivedCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 7), DynamicTemplateName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDerivedCfg.setStatus('current')
if mibBuilder.loadTexts: csubSessionDerivedCfg.setDescription("This object indicates the row in the cdtTemplateTable (defined by the CISCO-DYNAMIC-TEMPLATE-MIB) describing the derived configuration for the subscriber session. Observe that the value of cdtTemplateType corresponding to the referenced row must be 'derived'.")
csubSessionAvailableIdentities = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 8), SubSessionIdentities()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionAvailableIdentities.setStatus('current')
if mibBuilder.loadTexts: csubSessionAvailableIdentities.setDescription("This object indicates the subscriber identities that the system has successfully collected for the subscriber session. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is invalid. If the bit is '1', then the value of the corresponding column represents the value of the subscriber identity collected by the system. The following list specifies the mappings between the bits and the columns: 'subscriberLabel' => csubSessionSubscriberLabel 'macAddress' => csubSessionMacAddress 'nativeVrf' => csubSessionNativeVrf 'nativeIpAddress' => csubSessionNativeIpAddrType, csubSessionNativeIpAddr, csubSessionNativeIpMask 'nativeIpAddress2'=> csubSessionNativeIpAddrType2, csubSessionNativeIpAddr2, csubSessionNativeIpMask2 'domainVrf' => csubSessionDomainVrf 'domainIpAddress' => csubSessionDomainIpAddrType, csubSessionDomainIpAddr, csubSessionDomainIpMask 'pbhk' => csubSessionPbhk 'remoteId' => csubSessionRemoteId 'circuitId' => csubSessionCircuitId 'nasPort' => csubSessionNasPort 'domain' => csubSessionDomain 'username' => csubSessionUsername 'acctSessionId' => csubSessionAcctSessionId 'dnis' => csubSessionDnis 'media' => csubSessionMedia 'mlpNegotiated' => csubSessionMlpNegotiated 'protocol' => csubSessionProtocol 'dhcpClass' => csubSessionDhcpClass 'tunnelName' => csubSessionTunnelName Observe that the bit 'ifIndex' should always be '1'. This identity maps to the ifIndex assigned to the subscriber session. Observe that the bit 'serviceName' maps to one or more instance of ccbptPolicyMap (defined by the CISCO-CBP-TARGET-MIB).")
csubSessionSubscriberLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 9), SubscriberLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionSubscriberLabel.setStatus('current')
if mibBuilder.loadTexts: csubSessionSubscriberLabel.setDescription("This object indicates a positive integer-value uniquely identifying the subscriber session within the scope of the system. This column is valid only if the 'subscriberLabel' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionMacAddress.setStatus('current')
if mibBuilder.loadTexts: csubSessionMacAddress.setDescription("This object indicates the MAC address of the subscriber. This column is valid only if the 'macAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNativeVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 11), SubscriberVRF()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeVrf.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeVrf.setDescription("This object indicates the VRF originating the subscriber session. This column is valid only if the 'nativeVrf' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNativeIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 12), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpAddrType.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpAddrType.setDescription("This object indicates the type of IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNativeIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpAddr.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpAddr.setDescription("This object indicates the IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNativeIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 14), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpMask.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpMask.setDescription("This object indicates the corresponding mask for the IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDomainVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 15), SubscriberVRF()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDomainVrf.setStatus('current')
if mibBuilder.loadTexts: csubSessionDomainVrf.setDescription("This object indicates the VRF to which the system transfers the subscriber session's traffic. This column is valid only if the 'domainVrf' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDomainIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 16), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDomainIpAddrType.setStatus('current')
if mibBuilder.loadTexts: csubSessionDomainIpAddrType.setDescription("This object indicates the type of IP address assigned to the subscriber on the service-facing side of the system. This column is valid only if the 'domainIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDomainIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 17), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDomainIpAddr.setStatus('current')
if mibBuilder.loadTexts: csubSessionDomainIpAddr.setDescription("This object indicates the IP address assigned to the subscriber on the service-facing side of the system. This column is valid only if the 'domainIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDomainIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDomainIpMask.setStatus('current')
if mibBuilder.loadTexts: csubSessionDomainIpMask.setDescription("This object indicates the corresponding mask for the IP address assigned to the subscriber on the service-facing side of the system. This column is valid only if the 'domainIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionPbhk = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 19), SubscriberPbhk()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionPbhk.setStatus('current')
if mibBuilder.loadTexts: csubSessionPbhk.setDescription("This object indicates the PBHK identifying the subscriber. This column is valid only if the 'pbhk' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 20), SubscriberRemoteId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionRemoteId.setStatus('current')
if mibBuilder.loadTexts: csubSessionRemoteId.setDescription("This object indicates the Remote-Id identifying the 'calling station' or AN supporting the circuit that provides access to the subscriber. This column is valid only if the 'remoteId' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 21), SubscriberCircuitId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionCircuitId.setStatus('current')
if mibBuilder.loadTexts: csubSessionCircuitId.setDescription("This object indicates the Circuit-Id identifying the circuit supported by the 'calling station' or AN providing access to the subscriber. This column is valid only if the 'circuitId' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNasPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 22), SubscriberNasPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNasPort.setStatus('current')
if mibBuilder.loadTexts: csubSessionNasPort.setDescription("This object indicates the NAS port-identifier identifying the port on the NAS providing access to the subscriber. This column is valid only if the 'nasPort' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 23), SubscriberDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDomain.setStatus('current')
if mibBuilder.loadTexts: csubSessionDomain.setDescription("This object indicates the domain associated with the subscriber. This column is valid only if the 'domain' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 24), SubscriberUsername()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionUsername.setStatus('current')
if mibBuilder.loadTexts: csubSessionUsername.setDescription("This object indicates the username identifying the subscriber. This column is valid only if the 'username' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionAcctSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 25), SubscriberAcctSessionId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionAcctSessionId.setStatus('current')
if mibBuilder.loadTexts: csubSessionAcctSessionId.setDescription("This object indicates the accounting session identifier assigned to the subscriber session. This column is valid only if the 'accountingSid' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDnis = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 26), SubscriberDnis()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDnis.setStatus('current')
if mibBuilder.loadTexts: csubSessionDnis.setDescription("This object indicates the DNIS number dialed by the subscriber to access the 'calling station' or AN. This column is valid only if the 'dnis' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 27), SubscriberMediaType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionMedia.setStatus('current')
if mibBuilder.loadTexts: csubSessionMedia.setDescription("This object indicates the type of media providing access to the subscriber. This column is valid only if the 'media' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionMlpNegotiated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 28), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionMlpNegotiated.setStatus('current')
if mibBuilder.loadTexts: csubSessionMlpNegotiated.setDescription("This object indicates whether the subscriber session was established using multi-link PPP negotiation. This column is valid only if the 'mlpNegotiated' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 29), SubscriberProtocolType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionProtocol.setStatus('current')
if mibBuilder.loadTexts: csubSessionProtocol.setDescription("This object indicates the type of protocol providing access to the subscriber. This column is valid only if the 'protocol' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionDhcpClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 30), SubscriberDhcpClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionDhcpClass.setStatus('current')
if mibBuilder.loadTexts: csubSessionDhcpClass.setDescription("This object indicates the name of the class matching the DHCP DISCOVER message received from the subscriber. This column is valid only if the 'dhcpClass' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 31), SubscriberTunnelName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionTunnelName.setStatus('current')
if mibBuilder.loadTexts: csubSessionTunnelName.setDescription("This object indicates the name of the VPDN used to carry the subscriber session to the system. This column is valid only if the 'tunnelName' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionLocationIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 32), SubscriberLocationName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionLocationIdentifier.setStatus('current')
if mibBuilder.loadTexts: csubSessionLocationIdentifier.setDescription('This object indicates the location of the subscriber')
csubSessionServiceIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 33), SubscriberServiceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionServiceIdentifier.setStatus('current')
if mibBuilder.loadTexts: csubSessionServiceIdentifier.setDescription('This object indicates the name used to identify the services subscribed by a particular session.')
csubSessionLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 34), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionLastChanged.setStatus('current')
if mibBuilder.loadTexts: csubSessionLastChanged.setDescription('This object indicates when the subscriber session is updated with new policy information.')
csubSessionNativeIpAddrType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 35), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpAddrType2.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpAddrType2.setDescription("This object indicates the type of IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'. In Dual stack scenarios both 'csubSessionNativeIpAddrType' and 'csubSessionNativeIpAddrType2' will be valid")
csubSessionNativeIpAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 36), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpAddr2.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpAddr2.setDescription("This object indicates the IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionNativeIpMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 1, 1, 37), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionNativeIpMask2.setStatus('current')
if mibBuilder.loadTexts: csubSessionNativeIpMask2.setDescription("This object indicates the corresponding mask for the IP address assigned to the subscriber on the customer-facing side of the system. This column is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubSessionAvailableIdentities is '1'.")
csubSessionByTypeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 2), )
if mibBuilder.loadTexts: csubSessionByTypeTable.setStatus('current')
if mibBuilder.loadTexts: csubSessionByTypeTable.setDescription("This table describes a list of subscriber sessions currently maintained by the system. The tables sorts the subscriber sessions first by the subscriber session's type and second by the ifIndex assigned to the subscriber session.")
csubSessionByTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionByType"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionIfIndex"))
if mibBuilder.loadTexts: csubSessionByTypeEntry.setStatus('current')
if mibBuilder.loadTexts: csubSessionByTypeEntry.setDescription("This entry identifies a subscriber session. An entry exists for a corresponding entry in the ifTable describing a subscriber session. Currently, subscriber sessions must have one of the following ifType values: 'ppp' 'ipSubscriberSession' 'l2SubscriberSession' The system creates an entry when it establishes a subscriber session. Likewise, the system destroys an entry when it terminates the corresponding subscriber session.")
csubSessionByType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 2, 1, 1), SubSessionType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionByType.setStatus('current')
if mibBuilder.loadTexts: csubSessionByType.setDescription('This object indicates the type of the subscriber session.')
csubSessionIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 1, 2, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubSessionIfIndex.setStatus('current')
if mibBuilder.loadTexts: csubSessionIfIndex.setDescription('This object indicates the ifIndex assigned to the subscriber session.')
csubAggStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1), )
if mibBuilder.loadTexts: csubAggStatsTable.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTable.setDescription('This table contains sets of aggregated statistics relating to subscriber sessions, where each set has a unique scope of aggregation.')
csubAggStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsPointType"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsPoint"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsSessionType"))
if mibBuilder.loadTexts: csubAggStatsEntry.setReference("A. Bierman and K. McCloghrie, 'Entity MIB (Version 3)', RFC-4133, August 2005.")
if mibBuilder.loadTexts: csubAggStatsEntry.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsEntry.setDescription("An entry contains a set of aggregated statistics relating to those subscriber sessions that fall into a 'scope of aggregation'. A 'scope of aggregation' is the set of subscriber sessions that meet specified criteria. For example, a 'scope of aggregation' may be the set of all PPPoE subscriber sessions maintained by the system. The following criteria define the 'scope of aggregation': 1) Aggregation Point type Aggregation point type identifies the format of the csubAggStatsPoint for this entry. 2) Aggregation Point 'Physical' Aggregation Point type case: In a distributed system, a 'node' represents a physical entity capable of maintaining the context representing a subscriber session. If the 'scope of aggregation' specifies a physical entity having an entPhysicalClass of 'chassis', then the set of subscriber sessions in the 'scope of aggregation' may contain the subscriber sessions maintained by all the nodes contained in the system. If the 'scope of aggregation' specifies a physical entity having an entPhysicalClass of 'module' (e.g., a line card), then the set of subscriber sessions in the 'scope of aggregation' may contain the subscriber sessions maintained by the nodes contained by the module. If the 'scope of aggregation' specifies a physical entity having an entPhysicalClass of 'cpu', then the set of subscriber sessions in the 'scope of aggregation' may contain the subscriber sessions maintained by the node running on that processor. Observe that a centralized system (i.e., a system that essentially contains a single node) can only support a 'scope of aggregation' that specifies a physical entity classified as a 'chassis'. If the scope of aggregation specifies 'interface', then the scope is the set of subscriber sessions carried by the interface identified the ifIndex value represented in the csubAggStatsPoint value. 2) Subscriber Session Type If the 'scope of aggregation' specifies the value 'all' for the subscriber session type, then the set of subscriber sessions in the 'scope of aggregation' may contain all subscriber sessions, regardless of type. If the 'scope of aggregation' specifies a value other than 'all' for the subscriber session type, then the set of subscriber sessions in the 'scope of aggregation may contain only those subscriber sessions of the specified type. Implementation Guidance ======================= A system MUST maintain a set of statistics with a 'scope of aggregation' that contains all subscriber sessions maintained by the system. The system creates this entry during the initialization of the SNMP entity. A system SHOULD maintain a set of statistics for each 'scope of aggregation' containing subscriber sessions of each subscriber session type the system is capable of providing access. If the system supports these sets of statistics, then it creates these entries during the initialization of the SNMP entity. A system MAY maintain sets of node-specific statistics. if the system supports sets of node-specific statistics, then it creates the appropriate entries upon detection of a physical entity (resulting from system restart or insertion) containing those nodes. Likewise, the system destroys these entries upon removal of the physical entity.")
csubAggStatsPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("physical", 1), ("interface", 2))))
if mibBuilder.loadTexts: csubAggStatsPointType.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsPointType.setDescription("This object indicates format of the csubAggStatsPoint for this entry. The format for the csubAggStatsPoint is as follows: csubAggStatsPointType csubAggStatsPoint ---------------------- ------------------ 'physical' PhysicalIndex 'interface' InterfaceIndex")
csubAggStatsPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: csubAggStatsPoint.setReference("A. Bierman and K. McCloghrie, 'Entity MIB (Version 3)', RFC-4133, August 2005.")
if mibBuilder.loadTexts: csubAggStatsPoint.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsPoint.setDescription("This object should be read with csubAggStatsPointType always. This object indicates one of the determining factors affecting the 'scope of aggregation' for the set of statistics contained by the row. The value indicated by this object should be interpreted as the identifier for the point type specific base table. For point types of 'physical', the type specific base table is the entPhysicalTable and this value is a PhysicalIndex. For point types of 'interface', the type specific base table is the ifTable and this value is an InterfaceIndex. If this column indicates a physical entity which has an entPhysicalClass of 'chassis', then the 'scope of aggregation' may includes those subscriber sessions maintained by all nodes contained by the system. If this column indicates a physical entity which has an entPhysicalClass of 'module' (e.g., a line card), then the 'scope of aggregation' may include those subscriber sessions maintained by the nodes contained by the module. If this column indicates a physical entity which has an entPhysicalClass of 'cpu', then the 'scope of aggregation' may include those subscriber sessions maintained by the node running on the processor. Aggregation points with entPhysicalTable / ifTable overlap: For interfaces which map directly to physical 'port' class entities in the entPhysicalTable, the preferred representation as aggregation points is the 'physical' point type and PhysicalIndex identifier.")
csubAggStatsSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 3), SubSessionType())
if mibBuilder.loadTexts: csubAggStatsSessionType.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsSessionType.setDescription("This object indicates one of the determining factors affecting the 'scope of aggregation' for the statistics contained by the row. If the value of this column is 'all', then the 'scope of aggregation' may include all subscriber sessions, regardless of type. If the value of this column is not 'all', then the 'scope of aggregation' may include subscriber sessions of the indicated subscriber session type.")
csubAggStatsPendingSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 4), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsPendingSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsPendingSessions.setDescription("This object indicates the current number of subscriber sessions within the 'scope of aggregation' that are in the PENDING state.")
csubAggStatsUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 5), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsUpSessions.setDescription("This object indicates the current number of subscriber sessions within the 'scope of aggregation' that are in the UP state.")
csubAggStatsAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 6), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsAuthSessions.setDescription("This object indicates the current number of subscriber session within the 'scope of aggregation' that have been authenticated.")
csubAggStatsUnAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 7), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsUnAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsUnAuthSessions.setDescription("This object indicates the current number of subscriber session within the 'scope of aggregation' that have not been authenticated.")
csubAggStatsLightWeightSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 8), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsLightWeightSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsLightWeightSessions.setDescription("This object indicates the current number of subscriber sessions within the 'scope of aggregation' that are less resource intensive.")
csubAggStatsRedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 9), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsRedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsRedSessions.setDescription("This object indicates the current number of subscriber sessions within the 'scope of aggregation' that are redundant (i.e., sessions with a csubSessionRedundancyMode of 'standby').")
csubAggStatsHighUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 10), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsHighUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsHighUpSessions.setDescription("This object indicates the highest number of subscriber sessions within the 'scope of aggregation' observed simultaneously in the UP state since the last discontinuity time.")
csubAggStatsAvgSessionUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 11), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsAvgSessionUptime.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsAvgSessionUptime.setDescription("This object indicates the average time subscriber sessions within the 'scope of aggregation' spent in the UP state. The system calculates this average over all subscriber sessions maintained by all nodes contained by the 'scope of aggregation' since the last discontinuity time.")
csubAggStatsAvgSessionRPM = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 12), Gauge32()).setUnits('sessions per minute').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsAvgSessionRPM.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsAvgSessionRPM.setDescription("This object indicates the average rate (per minute) at which the nodes contained by the 'scope of aggregation' have established new subscriber sessions.")
csubAggStatsAvgSessionRPH = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 13), Gauge32()).setUnits('sessions per hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsAvgSessionRPH.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsAvgSessionRPH.setDescription("This object indicates the average rate (per hour) at which the nodes contained by the 'scope of aggregation' have established new subscriber sessions.")
csubAggStatsThrottleEngagements = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 14), Counter64()).setUnits('engagements').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsThrottleEngagements.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsThrottleEngagements.setDescription("This object indicates the number of times that nodes contained within the 'scope of aggregation' have engaged the subscriber session throttle since the last discontinuity time. The mechanics of a subscriber session throttle vary with subscriber session type and implementation. However, the general concept of the throttle prevents a node from having to deal with more than a configured number of requests to establish subscriber sessions from the same CPE within the a configured interval of time. When the number of requests exceeds the configured threshold within the configured interval, then the node processing the requests engages the throttle. Typically, when a node engages a throttle, it drops requests from the CPE for some period of time, after which the node disengages the throttle. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime.")
csubAggStatsTotalCreatedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 15), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalCreatedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalCreatedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' created since the discontinuity time. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime.")
csubAggStatsTotalFailedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 16), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalFailedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalFailedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that were in the PENDING state and terminated for reasons other than disconnect since the last discontinuity time. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime.")
csubAggStatsTotalUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 17), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalUpSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned to the UP state since the last discontinuity time. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime")
csubAggStatsTotalAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 18), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalAuthSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned from the UNAUTHENTICATED to the AUTHENTICATED state since the last discontinuity time. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime")
csubAggStatsTotalDiscSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 19), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalDiscSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalDiscSessions.setDescription('This object indicates the total number of subscriber sessions terminated due to a disconnect event since the last discontinuity time. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of csubAggStatsDiscontinuityTime')
csubAggStatsTotalLightWeightSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 20), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalLightWeightSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalLightWeightSessions.setDescription('This object indicates the total number of subscriber sessions that are less resource intensive')
csubAggStatsTotalFlowsUp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 21), Counter64()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsTotalFlowsUp.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsTotalFlowsUp.setDescription('This object indicates the total number of differential traffic classes on subscriber sessions. IP ACLs are used to create differential flows(Traffic Classes). Each Traffic Class can have a different set of features applied.')
csubAggStatsDayCreatedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 22), PerfTotalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDayCreatedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayCreatedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' created during the last 24 hours. The system calculates the value of this column by summing the values of all instances of csubAggStatsIntCreatedSessions that expand this row and have a corresponding csubAggStatsIntValid of 'true'.")
csubAggStatsDayFailedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 23), PerfTotalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDayFailedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayFailedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that were in the PENDING state and terminated for reasons other than disconnect during the last 24 hours. The system calculates the value of this column by summing the values of all instances of csubAggStatsIntFailedSessions that expand this row and have a corresponding csubAggStatsIntValid of 'true'.")
csubAggStatsDayUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 24), PerfTotalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDayUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayUpSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned to the UP state during the last 24 hours. The system calculates the value of this column by summing the values of all instances of csubAggStatsIntUpSessions that expand this row and have a corresponding csubAggStatsIntValid of 'true'.")
csubAggStatsDayAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 25), PerfTotalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDayAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayAuthSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned from the UNAUTHENTICATED to the AUTHENTICATED state during the last 24 hours. The system calculates the value of this column by summing the values of all instances of csubAggStatsIntAuthSessions that expand this row and have a corresponding csubAggStatsIntValid of 'true'.")
csubAggStatsDayDiscSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 26), PerfTotalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDayDiscSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayDiscSessions.setDescription("This object indicates the total number of subscriber sessions terminated due to a disconnect event during the last 24 hours. The system calculates the value of this column by summing the values of all instances of csubAggStatsIntDiscSessions that expand this row and have a corresponding csubAggStatsIntValid of 'true'.")
csubAggStatsCurrTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 27), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrTimeElapsed.setDescription("This object indicates the time that has elapsed since the beginning of the current 15-minute measurement interval. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, then the value of this column will be the maximum value.")
csubAggStatsCurrValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 28), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setUnits('intervals').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrValidIntervals.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrValidIntervals.setDescription("This object indicates the number of intervals for which data was collected. The value of this column will be '96' unless the measurement was started (or restarted) within 1,440 minutes, in which case the value will be the number of complete 15-minute intervals for which the system has at least some data. In certain cases it is possible that some intervals are unavailable, in which case the value of this column will be maximum interval number for which data is available.")
csubAggStatsCurrInvalidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 29), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setUnits('intervals').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrInvalidIntervals.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrInvalidIntervals.setDescription("This object indicates the number of intervals in the range from 0 to csubCurrValidIntervals for which no data is available. This object will typically be '0' except in certain circumstances when some intervals are unavailable.")
csubAggStatsCurrFlowsUp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 30), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setUnits('intervals').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrFlowsUp.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrFlowsUp.setDescription('This object indicates the current number of differential traffic classes on subscriber sessions currently UP. IP ACLs are used to create differential flows (Traffic Classes).Each Traffic Class can have a different set of features applied.')
csubAggStatsCurrCreatedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 31), PerfCurrentCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrCreatedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrCreatedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' created during the current 15-minute interval.")
csubAggStatsCurrFailedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 32), PerfCurrentCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrFailedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrFailedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that were in the PENDING state and terminated for reasons other than disconnect during the current 15-minute interval.")
csubAggStatsCurrUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 33), PerfCurrentCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrUpSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned to the UP state during the current 15-minute interval.")
csubAggStatsCurrAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 34), PerfCurrentCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrAuthSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned from the UNAUTHENTICATED to the AUTHENTICATED state during the current 15-minute interval.")
csubAggStatsCurrDiscSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 35), PerfCurrentCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsCurrDiscSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrDiscSessions.setDescription('This object indicates the total number of subscriber sessions terminated due to a disconnect event during the current 15-minute interval.')
csubAggStatsDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 1, 1, 36), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDiscontinuityTime.setDescription("The date and time (as determined by the system's clock) of the most recent occurrence of an event affecting the continuity of the aggregation statistics for this aggregation point.")
csubAggStatsIntTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2), )
if mibBuilder.loadTexts: csubAggStatsIntTable.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntTable.setDescription("This table contains aggregated subscriber session performance data collected for as much as a day's worth of 15-minute measurement intervals. This table has an expansion dependent relationship on the csubAggStatsTable, containing zero or more rows for each row contained by the csubAggStatsTable. Observe that the collection and maintenance of aggregated subscriber performance data is OPTIONAL for all scopes of aggregation. However, an implementation should maintain at least one interval for the 'scope of aggregation' that contains all subscriber sessions maintained by the system.")
csubAggStatsIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsPointType"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsPoint"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsSessionType"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntNumber"))
if mibBuilder.loadTexts: csubAggStatsIntEntry.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntEntry.setDescription("An entry contains the aggregated subscriber session performance data collected over a single 15-minute measurement interval within a 'scope of aggregation'. For further details regarding 'scope of aggregation', see the descriptive text associated with the csubAggStatsEntry.")
csubAggStatsIntNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: csubAggStatsIntNumber.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntNumber.setDescription("This object indicates the interval number identifying the 15-minute measurement interval for which aggregated subscriber session performance data was successfully collected by the system. The interval identified by the value '1' represents the most recent 15-minute measurement interval, and the interval identified by the value (n) represents the interval immediately preceding the interval identified by the value (n-1).")
csubAggStatsIntValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntValid.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntValid.setDescription('This object indicates whether the data for the 15-minute measurement interval is valid.')
csubAggStatsIntCreatedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 3), PerfIntervalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntCreatedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntCreatedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' created during the 15-minute measurement interval.")
csubAggStatsIntFailedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 4), PerfIntervalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntFailedSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntFailedSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that were in the PENDING state and terminated for reasons other than disconnect during the 15-minute measurement interval.")
csubAggStatsIntUpSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 5), PerfIntervalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntUpSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntUpSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned to the UP state during the 15-minute measurement interval.")
csubAggStatsIntAuthSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 6), PerfIntervalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntAuthSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntAuthSessions.setDescription("This object indicates the total number of subscriber sessions within the 'scope of aggregation' that transitioned from the UNAUTHENTICATED to the AUTHENTICATED state during the 15-minute measurement interval.")
csubAggStatsIntDiscSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 2, 1, 7), PerfIntervalCount()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubAggStatsIntDiscSessions.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntDiscSessions.setDescription('This object indicates the total number of subscriber sessions terminated due to a disconnect event during the 15-minute measurement interval.')
csubAggStatsThreshTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3), )
if mibBuilder.loadTexts: csubAggStatsThreshTable.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsThreshTable.setDescription('Please enter the Table Description here.')
csubAggStatsThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRisingThresh"))
if mibBuilder.loadTexts: csubAggStatsThreshEntry.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsThreshEntry.setDescription('A row in this table exists for each row in the csubAggStatsTable. Each row defines the set of thresholds and evaluation attributes for an aggregation point.')
csubSessionRisingThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubSessionRisingThresh.setStatus('current')
if mibBuilder.loadTexts: csubSessionRisingThresh.setDescription('This threshold, if non-zero, indicates the rising threshold for the value of csubAggStatsUpSessions for the aggregation point, When the current sample of csubAggStatsUpSessions is greater than or equal to this threshold, and the value of csubAggStatsUpSessions for the last sample interval was less than this thershold, the csubSessionRisingNotif is triggered. If the value of this threshold is 0, the threshold is not evaluated.')
csubSessionFallingThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubSessionFallingThresh.setStatus('current')
if mibBuilder.loadTexts: csubSessionFallingThresh.setDescription('This threshold, if non-zero, indicates the falling threshold for the value of csubAggStatsUpSessions for the aggregation point, When the current sample of csubAggStatsUpSessions is less than or equal to this threshold, and the value of csubAggStatsUpSessions for the last sample interval was greater than this thershold, the csubSessionFallingNotif is triggered. If the value of this threshold is 0, the threshold is not evaluated.')
csubSessionDeltaPercentFallingThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubSessionDeltaPercentFallingThresh.setStatus('current')
if mibBuilder.loadTexts: csubSessionDeltaPercentFallingThresh.setDescription('This threshold, if non-zero, indicates the delta falling threshold as a percentage of the value of csubAggStatsUpSessions for the aggregation point, The delta as a percentage of csubAggStatsUpSessions (delta_percent) is calculated as follows: current value of csubAggStatsUpSessions = value(n) previous sampled value of csubAggStatsUpSessions = value(n-1) delta_percent = ((value(n-1) - value(n)) / value(n-1)) * 100 If the delta_percent value of the current evaluation interval is greater than the value of this threshold, a csubSessionDeltaPercentLossNotif is triggered. If the value of this threshold is 0, the threshold is not evaluated.')
csubSessionThreshEvalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 2, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubSessionThreshEvalInterval.setStatus('current')
if mibBuilder.loadTexts: csubSessionThreshEvalInterval.setDescription('The value of this object sets the number of seconds between samples for threshold evaluation. For implementations capable of per-session event evaluation of thresholds this object represents the maximum number of seconds between samples.')
csubJobFinishedNotifyEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubJobFinishedNotifyEnable.setStatus('current')
if mibBuilder.loadTexts: csubJobFinishedNotifyEnable.setDescription('This object specifies whether the system generates a csubJobFinishedNotify notification when the system finishes processing a subscriber session job.')
csubJobIndexedAttributes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 2), SubSessionIdentities()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobIndexedAttributes.setStatus('current')
if mibBuilder.loadTexts: csubJobIndexedAttributes.setDescription("This object indicates which subscriber session identities the system maintains as searchable keys. This value serves the EMS/NMS in configuring a subscriber session query, as at least one match criteria must be an 'indexed attribute'.")
csubJobIdNext = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 3), SubscriberJobIdentifierOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobIdNext.setStatus('current')
if mibBuilder.loadTexts: csubJobIdNext.setDescription("This object indicates the next available identifier for the creation of a new row in the csubJobTable. If no available identifier exists, then this object has the value '0'.")
csubJobMaxNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('jobs').setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubJobMaxNumber.setStatus('current')
if mibBuilder.loadTexts: csubJobMaxNumber.setDescription("This object indicates the maximum number of outstanding subscriber session jobs the system can support. If the csubJobTable contains a number of rows (i.e., the value of csubJobCount) equal to this value, then any attempt to create a new row will result in a response with an error-status of 'resourceUnavailable'.")
csubJobMaxLife = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubJobMaxLife.setStatus('current')
if mibBuilder.loadTexts: csubJobMaxLife.setDescription("This object specifies the maximum life a subscriber session report corresponding to a subscriber session job having a csubJobType of 'query'. The system tracks the time elapsed after it finishes processing a query. When the time elapsed reaches the value specified by this column, the system automatically destroys the report. A value of '0' disables the automatic destruction of reports.")
csubJobCount = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 6), Gauge32()).setUnits('jobs').setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobCount.setStatus('current')
if mibBuilder.loadTexts: csubJobCount.setDescription('This object indicates the number of subscriber session jobs currently maintained by the csubJobTable.')
csubJobTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7), )
if mibBuilder.loadTexts: csubJobTable.setStatus('current')
if mibBuilder.loadTexts: csubJobTable.setDescription('This table contains the subscriber session jobs submitted by the EMS/NMS.')
csubJobEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobId"))
if mibBuilder.loadTexts: csubJobEntry.setStatus('current')
if mibBuilder.loadTexts: csubJobEntry.setDescription("An entry describing a subscriber session job. At this time, subscriber session jobs can perform one of two tasks: - Subscriber Session Query This type of job invokes the report generator, which builds a list of subscriber sessions matching criteria specified by the corresponding row in the csubJobMatchParamsTable. The list built by the report generator must conform to parameters specified by the corresponding row in csubJobQueryParamsTable, which at this time only affects sorting order. - Subscriber Session Clear This type of job causes the system to terminate those subscriber sessions matching criteria specified by the corresponding row in the csubJobMatchParamsTable. The following procedure summarizes how the EMS/NMS can start and monitor a subscriber session job: 1) The EMS/NMS must start by reading csubJobIdNext. If it is zero, continue polling csubJobIdNext until it is non-zero. 2) The EMS/NMS creates a row in the csubJobTable using the instance identifier retrieved in the last step. Since every object contained by the entry with a MAX-ACCESS of 'read-create' specifies a default value, it makes little difference whether the EMS/NMS employs create-and-wait or create-and-go semantics. 3) The EMS/NMS sets the type of subscriber session job by setting the corresponding instance of csubJobType. 4a) If the job is a 'query', then the EMS/NMS must configure the query before starting it by setting columns contained by the corresponding rows in the csubJobMatchParamsTable and csubJobQueryParamsTable. 4b) If job is a 'clear', then the EMS/NMS must configure the job before starting it by setting columns contained by the corresponding row in the csubJobMatchParamsTable. 5) The EMS/NMS can now start the job by setting the corresponding instance of csubJobControl to 'start'. 6) The EMS/NMS can monitor the progress of the job by polling the corresponding instance of csubJobState. It can also wait for a csubJobFinishedNotify notification. When the state of the job transitions to 'finished', then the system has finished executing the job. 7) The EMS/NMS can determine the final status of the job by reading the corresponding instance of csubJobFinishedReason. If job is a 'query' and the corresponding instance of csubJobFinishedReason is 'normal', then the EMS/NMS can safely read the report by retrieving the corresponding rows from the csubJobReportTable. 8a) After a job has finished, the EMS/NMS has the option of destroying it. It can do this by simply setting the corresponding instance of csubJobStatus to 'destroy'. Alternatively, the EMS/NMS may retain the job and execute it again in the future (by returning to step 5). Additionally, nothing would prevent the EMS/NMS from changing the job's type, which causes the automatic destruction of the corresponding report. 8b) If the job is a 'query' and the EMS/NMS opts to retain the job, then it may consider releasing the corresponding report after reading it. It can do this by setting the corresponding instance of csubJobControl to 'release'.")
csubJobId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 1), SubscriberJobIdentifier())
if mibBuilder.loadTexts: csubJobId.setStatus('current')
if mibBuilder.loadTexts: csubJobId.setDescription('This object indicates an arbitrary, positive integer-value uniquely identifying the subscriber session job.')
csubJobStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobStatus.setStatus('current')
if mibBuilder.loadTexts: csubJobStatus.setDescription("This object specifies the status of the subscriber session job. The following columns must be valid before activating a subscriber session job: - csubJobStorage - csubJobType - csubJobControl However, these objects specify a default value. Thus, it is possible to use create-and-go semantics without setting any additional columns. An implementation must allow the EMS/NMS to modify any column when this column is 'active', including columns defined in tables that have a one-to-one or sparse dependent relationship on this table.")
csubJobStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobStorage.setStatus('current')
if mibBuilder.loadTexts: csubJobStorage.setDescription('This object specifies what happens to the subscriber session job upon restart.')
csubJobType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noop", 1), ("query", 2), ("clear", 3))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobType.setStatus('current')
if mibBuilder.loadTexts: csubJobType.setDescription("This object specifies the type of subscriber session job: 'noop' This type of job does nothing and simply serves as a convenient default value for newly created jobs, thereby allowing create-and-go row creation without having to specify the type of job. 'query' This type of job starts a subscriber session query. The system searches for any subscriber sessions matching the configured criteria and sorts them into a resulting report. Upon activation of a subscriber session with this value, the system automatically creates corresponding rows in the csubJobMatchParamsTable and csubQueryParamsTable. 'clear' This type of job causes the system to terminated all subscriber sessions matching configured criteria. Upon activation of a subscriber session with this value, the system automatically creates a corresponding row in the csubJobMatchParamsTable.")
csubJobControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noop", 1), ("start", 2), ("abort", 3), ("release", 4))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobControl.setStatus('current')
if mibBuilder.loadTexts: csubJobControl.setDescription("This object specifies an action relating to the subscriber session job: 'noop' This action does nothing. 'start' If the corresponding instance of csubJobType is 'noop', then this action simply causes the system to set the corresponding instances of csubJobState and csubJobFinishedReason to 'finished' and 'normal', respectively. If the corresponding instance of csubJobType is not 'noop' and the system is not executing a subscriber session job, then this action causes the system immediately execute the subscriber session job. If the corresponding instance of csubJobType is not 'noop' and the system is already executing a subscriber session job, then this action causes the system to put the job on the subscriber session job queue. 'abort' If the subscriber session job is in the subscriber session job queue, then this action causes the system to remove the job from the queue. If the system is executing the subscriber session job, then this action causes the system to stop the job. 'release' This action causes the system to destroy any corresponding rows in the csubJobReportTable. The system only accepts this action for a previously executed subscriber session job having a corresponding instance of csubJobType set to 'query'. Any attempt to issue this action under other circumstances will result in a response indicating an error-status of 'inconsistentValue'. When read, this column is always 'noop'.")
csubJobState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("pending", 2), ("inProgress", 3), ("finished", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobState.setStatus('current')
if mibBuilder.loadTexts: csubJobState.setDescription("This object indicates the current state of the subscriber session job: 'idle' This state indicates that the system has not executed the subscriber session job since it was created. 'pending' This state indicates that the subscriber session job is waiting in the subscriber session job queue. 'inProgress' This state indicates that the system is executing the subscriber session job. Observe that the system may execute more than one subscriber session job at a time. 'finished' This state indicates that the system has executed the subscriber session job and it has finished. The corresponding instance of csubJobFinishedReason indicates further details regarding the reason why the job finished.")
csubJobStartedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobStartedTime.setStatus('current')
if mibBuilder.loadTexts: csubJobStartedTime.setDescription("This object indicates the value of sysUpTime when the system started executing the subscriber session job. This value will be '0' when the corresponding instance of csubJobState is 'idle' or 'pending'.")
csubJobFinishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobFinishedTime.setStatus('current')
if mibBuilder.loadTexts: csubJobFinishedTime.setDescription("This object indicates the value of sysUpTime when the system finished executing the subscriber session job, for whatever reason. This value will be '0' when the corresponding instance of csubJobState is 'idle', 'pending', or 'inProgress'.")
csubJobFinishedReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("invalid", 1), ("other", 2), ("normal", 3), ("aborted", 4), ("insufficientResources", 5), ("error", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobFinishedReason.setStatus('current')
if mibBuilder.loadTexts: csubJobFinishedReason.setDescription("This object indicates the reason why the system finished executing the subscriber session job: 'invalid' Indicates that the corresponding instance of csubJobState is either 'idle', 'pending', or 'inProgress'. 'other' Indicates that the system finished executing the subscriber session job abnormally for a reason not recognized by this MIB module. 'normal' Indicates that the system finished executing the subscriber session job with no problems. 'aborted' Indicates that the system finished executing the subscriber session job as the result of the EMS/NMS writing 'abort' to the corresponding instance of csubJobControl. 'insufficientResources' Indicates that the system finished executing the subscriber session job abnormally due to insufficient resources to continue. 'error' Indicates that the system encountered an error that prevented it from completing the job.")
csubJobMatchParamsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8), )
if mibBuilder.loadTexts: csubJobMatchParamsTable.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchParamsTable.setDescription("This table contains subscriber session job parameters describing match criteria. This table has a sparse-dependent relationship on the csubJobTable, containing a row for each job having a csubJobType of 'query' or 'clear'.")
csubJobMatchParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobId"))
if mibBuilder.loadTexts: csubJobMatchParamsEntry.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchParamsEntry.setDescription("An entry describes a set of subscriber session match criteria. The set contains those subscriber session identities specified by csubJobMatchIdentities. If the corresponding row in the csubJobTable has a csubJobType of 'query', then the system builds a report containing those subscriber sessions matching these criteria. If the corresponding row in the csubJobTable has a csubJobType of 'clear', then the system terminates those subscriber sessions matching these criteria. The system automatically creates an entry when the EMS/NMS sets the corresponding instance of csubJobType to 'query' or 'clear'. Likewise, the system automatically destroys an entry under the following circumstances: 1) The EMS/NMS destroys the corresponding row in the csubJobTable. 2) The EMS/NMS sets the corresponding instance of csubJobType to 'noop'.")
csubJobMatchIdentities = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 1), SubSessionIdentities()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchIdentities.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchIdentities.setDescription("This object specifies the subscriber identities that the system uses to determine the subscriber sessions the job executes on. Each bit in this bit string corresponds to one or more columns in this table. If the bit is '0', then the value of the corresponding columns are invalid. If the bit is '1', then the value of corresponding columns are valid. The following list specifies the mappings between the bits and the columns: 'subscriberLabel' => csubJobMatchSubscriberLabel 'macAddress' => csubJobMatchMacAddress 'nativeVrf' => csubJobMatchNativeVrf 'nativeIpAddress' => csubJobMatchNativeIpAddrType, csubJobMatchNativeIpAddr, csubJobMatchNativeIpMask, 'domainVrf' => csubJobMatchDomainVrf 'domainIpAddress' => csubJobMatchDomainIpAddrType, csubJobMatchDomainIpAddr, csubJobMatchDomainIpMask 'pbhk' => csubJobMatchPbhk 'remoteId' => csubJobMatchRemoteId 'circuitId' => csubJobMatchCircuitId 'nasPort' => csubJobMatchNasPort 'domain' => csubJobMatchDomain 'username' => csubJobMatchUsername 'acctSessionId' => csubJobMatchAcctSessionId 'dnis' => csubJobMatchDnis 'media' => csubJobMatchMedia 'mlpNegotiated' => csubJobMatchMlpNegotiated 'protocol' => csubJobMatchProtocol 'serviceName' => csubJobMatchServiceName 'dhcpClass' => csubJobMatchDhcpClass 'tunnelName' => csubJobMatchTunnelName Observe that the bit 'ifIndex' has no meaning, as subscriber session jobs do not match against this subscriber session identity.")
csubJobMatchOtherParams = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 2), Bits().clone(namedValues=NamedValues(("danglingDuration", 0), ("state", 1), ("authenticated", 2), ("redundancyMode", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchOtherParams.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchOtherParams.setDescription("This object specifies other parameters relating to subscriber sessions a subscriber session job may match against. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is invalid. If the bit is '1', then the value of the corresponding column represents the value of the parameter identity the system should match against for the corresponding subscriber session job. The following list specifies the mappings between bits and the columns: 'danglingDuration' => csubJobMatchDanglingDuration 'state' => csubJobMatchState 'authenticated' => csubJobMatchAuthenticated 'redundancyMode' => csubJobMatchRedundancyMode")
csubJobMatchSubscriberLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 3), SubscriberLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchSubscriberLabel.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchSubscriberLabel.setDescription("This object specifies the subscriber label that the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'subscriberLabel' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 4), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchMacAddress.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchMacAddress.setDescription("This object specifies the MAC address that the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'macAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchNativeVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 5), SubscriberVRF()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchNativeVrf.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchNativeVrf.setDescription("This object specifies the native VRF the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'nativeVrf' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchNativeIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 6), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchNativeIpAddrType.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchNativeIpAddrType.setDescription("This object specifies the type of Internet address specified by csubJobMatchNativeIpAddr and csubJobMatchNativeIpMask. This value is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchNativeIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 7), InetAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchNativeIpAddr.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchNativeIpAddr.setDescription("This object specifies the native IP address that the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchNativeIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 8), InetAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchNativeIpMask.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchNativeIpMask.setDescription("This object specifies the mask used when matching the native IP address against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'nativeIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDomainVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 9), SubscriberVRF()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDomainVrf.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDomainVrf.setDescription("This object specifies the domain VRF the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'domainVrf' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDomainIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 10), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDomainIpAddrType.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDomainIpAddrType.setDescription("This object specifies the type of Internet address specified by csubJobMatchDomainIpAddr and csubJobMatchDomainIpMask. This value is valid only if the 'domainIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDomainIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 11), InetAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDomainIpAddr.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDomainIpAddr.setDescription("This object specifies the domain IP address that the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'domainIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDomainIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 12), InetAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDomainIpMask.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDomainIpMask.setDescription("This object specifies the mask used when matching the domain IP address against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'domainIpAddress' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchPbhk = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 13), SubscriberPbhk().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchPbhk.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchPbhk.setDescription("This object specifies the PBHK that the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'pbhk' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 14), SubscriberRemoteId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchRemoteId.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchRemoteId.setDescription("This object specifies the Remote-Id the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'remoteId' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 15), SubscriberCircuitId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchCircuitId.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchCircuitId.setDescription("This object specifies the Circuit-Id the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'circuitId' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchNasPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 16), SubscriberNasPort().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchNasPort.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchNasPort.setDescription("This object specifies the NAS port-identifier the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'nasPort' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 17), SubscriberDomain()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDomain.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDomain.setDescription("This object specifies the domain the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'domain' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 18), SubscriberUsername()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchUsername.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchUsername.setDescription("This object specifies the username the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'username' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchAcctSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 20), SubscriberAcctSessionId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchAcctSessionId.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchAcctSessionId.setDescription("This object specifies the accounting session identifier the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'accountingSid' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDnis = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 21), SubscriberDnis()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDnis.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDnis.setDescription("This object specifies the DNIS number the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'dnis' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 22), SubscriberMediaType().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchMedia.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchMedia.setDescription("This object specifies the media type the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'media' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchMlpNegotiated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchMlpNegotiated.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchMlpNegotiated.setDescription("This object specifies the MLP negotiated flag the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'mlpNegotiated' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 24), SubscriberProtocolType().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchProtocol.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchProtocol.setDescription("This object specifies the protocol type the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'protocol' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 25), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchServiceName.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchServiceName.setDescription("This object specifies the service name the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'serviceName' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDhcpClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 26), SubscriberDhcpClass()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDhcpClass.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDhcpClass.setDescription("This object specifies the DHCP class name the system matches against subscriber sessions in the process of executing a subscriber session job. This value is valid only if the 'dhcpClass' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 27), SubscriberTunnelName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchTunnelName.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchTunnelName.setDescription("This object specifies the tunnel name the system matches against subscriber session in the process of executing a subscriber session job. This value is valid only if the 'tunnelName' bit of the corresponding instance of csubJobMatchIdentities is '1'.")
csubJobMatchDanglingDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchDanglingDuration.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchDanglingDuration.setDescription("This object specifies the minimum interval of time a subscriber session can remain dangling in order for the system to consider it a match in the process of executing a subscriber session job. A 'dangling' subscriber session is one in the PENDING state. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This value is valid only if the 'danglingDuration' bit of the corresponding instance of csubJobMatchOtherParams is '1'.")
csubJobMatchState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 29), SubSessionState().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchState.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchState.setDescription("This object specifies the state of a subscriber session in order for the system to consider a match in the process of executing a subscriber session job. The value 'other' is not valid and an implementation should not allow it to be written to this column. This value is valid only if the 'state' bit of the corresponding instance of csubJobMatchOtherParams is '1'.")
csubJobMatchAuthenticated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 30), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchAuthenticated.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchAuthenticated.setDescription("This object specifies whether a subscriber session should be unauthenticated for the system to consider a match in the process of executing a subscriber session job. If this column is 'false', then the subscriber session job matches subscriber sessions that are unauthenticated. If this column is 'true', then the subscriber session job matches subscriber session that are authenticated. This value is valid only if the 'authenticated' bit of the corresponding instance of csubJobMatchParams is '1'.")
csubJobMatchRedundancyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 8, 1, 31), SubSessionRedundancyMode().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobMatchRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchRedundancyMode.setDescription("This object specifies the redudancy mode of the subscriber session in order for the system to consider a match in the process of executing a subscriber session job. The value 'other' is not valid and an implementation should not allow it to be written to this column. This value is valid only if the 'redundancyMode' bit of the corresponding instance of csubJobMatchOtherParams is '1'.")
csubJobQueryParamsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9), )
if mibBuilder.loadTexts: csubJobQueryParamsTable.setStatus('current')
if mibBuilder.loadTexts: csubJobQueryParamsTable.setDescription("This table contains subscriber session job parameters describing query parameters. This table has a sparse-dependent relationship on the csubJobTable, containing a row for each job having a csubJobType of 'query'.")
csubJobQueryParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobId"))
if mibBuilder.loadTexts: csubJobQueryParamsEntry.setStatus('current')
if mibBuilder.loadTexts: csubJobQueryParamsEntry.setDescription("An entry describes a set of subscriber session query parameters. The system automatically creates an entry when the EMS/NMS sets the corresponding instance of csubJobType to 'query'. Likewise, the system automatically destroys an entry under the following circumstances: 1) The EMS/NMS destroys the corresponding row in the csubJobTable. 2) The EMS/NMS sets the corresponding instance of csubJobType to 'noop' or 'clear'.")
csubJobQuerySortKey1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9, 1, 1), SubSessionIdentity().clone('subscriberLabel')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobQuerySortKey1.setStatus('current')
if mibBuilder.loadTexts: csubJobQuerySortKey1.setDescription("This object specifies the first subscriber identity that the system uses when sorting subscriber sessions into the final report corresponding to a subscriber session query. It is not valid to set this column to 'other' or 'ifIndex'.")
csubJobQuerySortKey2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9, 1, 2), SubSessionIdentity().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobQuerySortKey2.setStatus('current')
if mibBuilder.loadTexts: csubJobQuerySortKey2.setDescription("This object specifies the second subscriber identity that the system uses when sorting subscriber sessions into the final report corresponding to a subscriber session query. If it is the desire to have the final report sorted on a single subscriber identity, then this column should be 'other'.")
csubJobQuerySortKey3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9, 1, 3), SubSessionIdentity().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csubJobQuerySortKey3.setStatus('current')
if mibBuilder.loadTexts: csubJobQuerySortKey3.setDescription("This object specifies the third subscriber identity that the system uses when sorting subscriber sessions into the final report corresponding to a subscriber session query. If it is the desire to have the final report sorted on one or two subscriber identities, then this column should be 'other'.")
csubJobQueryResultingReportSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 9, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobQueryResultingReportSize.setStatus('current')
if mibBuilder.loadTexts: csubJobQueryResultingReportSize.setDescription("This object indicates the number of subscriber sessions that matched the corresponding subscriber session query. The value of this column should be '0' unless the corresponding value of csubJobState is 'finished'. The value of this column should be '0' after the EMS/NMS sets the corresponding csubJobControl to 'release'.")
csubJobQueueTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 10), )
if mibBuilder.loadTexts: csubJobQueueTable.setStatus('current')
if mibBuilder.loadTexts: csubJobQueueTable.setDescription('This table lists the subscriber session jobs currently pending in the subscriber session job queue.')
csubJobQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 10, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQueueNumber"))
if mibBuilder.loadTexts: csubJobQueueEntry.setStatus('current')
if mibBuilder.loadTexts: csubJobQueueEntry.setDescription("An entry describing an subscriber session job in the subscriber session job queue. The system creates an entry in this table when it places a subscriber session job on the subscriber session job queue. It does this when the EMS/NMS sets an instance of csubJobControl to 'start' and the system is already executing a subscriber session job. Likewise, the system destroys an entry when it removes it from the queue. This occurs under the following circumstances: 1) The system has finished executing a job, for whatever reason, and is ready to start executing the job at the head of the queue. 2) The EMS/NMS has set an instance of csubJobControl to 'abort' for a job that was on the queue.")
csubJobQueueNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: csubJobQueueNumber.setStatus('current')
if mibBuilder.loadTexts: csubJobQueueNumber.setDescription("This object indicates an positive, integer-value that uniquely identifies the entry in the table. The value of this object starts at '1' and monotonically increases for each subscriber session job inserted into the subscriber session job queue. If the value of this object is '4294967295', the system will reset it to '1' when it inserts the next subscriber session job into the subscriber session job queue.")
csubJobQueueJobId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 10, 1, 2), SubscriberJobIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobQueueJobId.setStatus('current')
if mibBuilder.loadTexts: csubJobQueueJobId.setDescription('This object indicates the identifier associated with the subscriber session job.')
csubJobReportTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 11), )
if mibBuilder.loadTexts: csubJobReportTable.setStatus('current')
if mibBuilder.loadTexts: csubJobReportTable.setDescription("This table contains the reports corresponding to subscriber session jobs that have a csubJobType of 'query' and csubJobState of 'finished'. This table has an expansion dependent relationship on the csubJobTable, containing zero or more rows for each job.")
csubJobReportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 11, 1), ).setIndexNames((0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobId"), (0, "CISCO-SUBSCRIBER-SESSION-MIB", "csubJobReportId"))
if mibBuilder.loadTexts: csubJobReportEntry.setStatus('current')
if mibBuilder.loadTexts: csubJobReportEntry.setDescription("An entry describes a subscriber session that satisfied the match criteria specified by the corresponding job. The system creates an entry for each subscriber session that satisfied the specified match criteria of a subscriber session job having a csubJobType of 'query'. However, it does not create these entries until after the system has successfully executed the subscriber session job. The system destroys an entry under the following circumstances: 1) The corresponding subscriber session job has been destroyed by the EMS/NMS. 2) The value of csubJobMaxLife is non-zero and the age of the report has reached the specified maximum life. 3) The EMS/NMS has set the corresponding instance of csubJobControl to 'release'. 4) The EMS/NMS has restarted the corresponding subscriber session job (i.e., has set the corresponding instance of csubJobControl to 'start').")
csubJobReportId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: csubJobReportId.setStatus('current')
if mibBuilder.loadTexts: csubJobReportId.setDescription('This object indicates an arbitrary, positive, integer-value that uniquely identifies this entry in a report. This auxiliary value is necessary, as the corresponding subscriber session job can specify up to three subscriber identities on which to sort the subscriber sessions that end up in the final report.')
csubJobReportSession = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 3, 11, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csubJobReportSession.setStatus('current')
if mibBuilder.loadTexts: csubJobReportSession.setDescription("This object indicates the ifIndex-value assigned to the subscriber session that satisfied the match criteria specified by the corresponding subscriber session job having a csubJobType of 'query'.")
csubAggStatsThreshNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 786, 1, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csubAggStatsThreshNotifEnable.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsThreshNotifEnable.setDescription('This object enables or disables the generation of any of the csubAggStats* threshold notifications.')
csubJobFinishedNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 786, 0, 1)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobStartedTime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedTime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedReason"))
if mibBuilder.loadTexts: csubJobFinishedNotify.setStatus('current')
if mibBuilder.loadTexts: csubJobFinishedNotify.setDescription("The system generates this notification when the system finishes executing a subscriber session job, provided the value of csubJobFinishedNotifyEnable is 'true'. The notification indicates the following additional data: csubJobStartedTime The value of sysUpTime when the system started executing the subscriber session job. csubJobFinishedTime The value of sysUpTime when the system finished executing the subscriber session job, for whatever reason. csubJobFinishedReason The reason why the system finished executing the subscriber session job.")
csubSessionRisingNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 786, 0, 2)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRisingThresh"))
if mibBuilder.loadTexts: csubSessionRisingNotif.setStatus('current')
if mibBuilder.loadTexts: csubSessionRisingNotif.setDescription("This notification is generated when the value of csubAggStatsThreshNotifEnable is 'true' AND the value of csubSessionRisingThresh is non-zero AND the current value csubAggStatsUpSessions is greater than or equal to the corresponding value of csubSessionRisingThresh and the previous sample of csubAggStatsUpSessions was less than csubSessionRisingThresh.")
csubSessionFallingNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 786, 0, 3)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionFallingThresh"))
if mibBuilder.loadTexts: csubSessionFallingNotif.setStatus('current')
if mibBuilder.loadTexts: csubSessionFallingNotif.setDescription("This notification is generated when the value of csubAggStatsThreshNotifEnable is 'true' AND the value of csubSessionFallingThresh is non-zero AND the current value csubAggStatsUpSessions is less than or equal to the corresponding value of csubSessionFallingThresh and the previous sample of csubAggStatsUpSessions was greater than csubSessionFallingThresh.")
csubSessionDeltaPercentFallingThreshNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 786, 0, 4)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDeltaPercentFallingThresh"))
if mibBuilder.loadTexts: csubSessionDeltaPercentFallingThreshNotif.setStatus('current')
if mibBuilder.loadTexts: csubSessionDeltaPercentFallingThreshNotif.setDescription("This notification is generated when the value of csubAggStatsThreshNotifEnable is 'true' AND the value of csubSessionDeltaPercentFallingThresh is non-zero AND If the delta_percent value of the current evaluation interval is greater than the value of csubSessionDeltaPercentFallingThresh. The delta as a percentage of csubAggStatsUpSessions (delta_percent) is calculated as follows: current value of csubAggStatsUpSessions = value(n) previous sampled value of csubAggStatsUpSessions = value(n-1) delta_percent = ((value(n-1) - value(n)) / value(n-1)) * 100")
ciscoSubscriberSessionMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 1))
ciscoSubscriberSessionMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2))
ciscoSubscriberSessionR1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 1, 1)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchParamsGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQueryParamsGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobNotifGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQueueGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSubscriberSessionR1Compliance = ciscoSubscriberSessionR1Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoSubscriberSessionR1Compliance.setDescription('This compliance state specifies the minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO-SUSBCRIBER-SESSION-MIB.')
ciscoSubscriberSessionR2Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 1, 2)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsThreshGroup"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSubscriberSessionR2Compliance = ciscoSubscriberSessionR2Compliance.setStatus('current')
if mibBuilder.loadTexts: ciscoSubscriberSessionR2Compliance.setDescription('This compliance state specifies the new table called csubAggStatsThreshEntry')
csubSessionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 1)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionIpAddrAssignment"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionState"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionAuthenticated"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRedundancyMode"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionCreationTime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDerivedCfg"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionAvailableIdentities"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionSubscriberLabel"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionMacAddress"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionNativeVrf"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionNativeIpAddrType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionNativeIpAddr"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionNativeIpMask"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDomainVrf"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDomainIpAddrType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDomainIpAddr"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDomainIpMask"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionPbhk"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRemoteId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionCircuitId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionNasPort"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDomain"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionUsername"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionAcctSessionId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDnis"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionMedia"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionMlpNegotiated"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionProtocol"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDhcpClass"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionTunnelName"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubSessionGroup = csubSessionGroup.setStatus('current')
if mibBuilder.loadTexts: csubSessionGroup.setDescription('This group contains objects that describe subscriber sessions.')
csubAggStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 2)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsPendingSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsAuthSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsRedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsHighUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsAvgSessionUptime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsAvgSessionRPM"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsAvgSessionRPH"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsThrottleEngagements"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsTotalCreatedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsTotalFailedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsTotalUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsTotalAuthSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsTotalDiscSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsGroup = csubAggStatsGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsGroup.setDescription('This group contains objects describing aggregated statistics relating to subscriber sessions maintained by a system.')
csubAggStatsCurrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 3)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrTimeElapsed"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrValidIntervals"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrInvalidIntervals"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrCreatedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrFailedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrAuthSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsCurrDiscSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsCurrGroup = csubAggStatsCurrGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsCurrGroup.setDescription('This group contains objects describing aggregated statistics for the current 15-minute performance data collection interval.')
csubAggStatsIntGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 4)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntValid"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntCreatedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntFailedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntAuthSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsIntDiscSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsIntGroup = csubAggStatsIntGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsIntGroup.setDescription('This group contains objects describing aggregated statistics for as many as 96 previous 15-minute performance data collection intervals.')
csubAggStatsDayGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 5)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayCreatedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayFailedSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayUpSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayAuthSessions"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsDayDiscSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsDayGroup = csubAggStatsDayGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsDayGroup.setDescription('This group contains objects describing aggregated statistics for the last 24-hour performance data collection interval (which ends with the last 15-minute performance data collection interval.')
csubJobGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 6)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedNotifyEnable"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobIndexedAttributes"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobIdNext"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMaxNumber"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMaxLife"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobCount"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobStatus"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobStorage"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobControl"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobState"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobStartedTime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedTime"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubJobGroup = csubJobGroup.setStatus('current')
if mibBuilder.loadTexts: csubJobGroup.setDescription('This group contains objects describing subscriber session jobs.')
csubJobMatchParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 7)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchIdentities"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchOtherParams"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchSubscriberLabel"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchMacAddress"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchNativeVrf"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchNativeIpAddrType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchNativeIpAddr"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchNativeIpMask"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDomainVrf"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDomainIpAddrType"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDomainIpAddr"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDomainIpMask"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchPbhk"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchRemoteId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchCircuitId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchNasPort"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDomain"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchUsername"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchAcctSessionId"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDnis"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchMedia"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchMlpNegotiated"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchProtocol"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchServiceName"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDhcpClass"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchTunnelName"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchDanglingDuration"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchState"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchAuthenticated"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobMatchRedundancyMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubJobMatchParamsGroup = csubJobMatchParamsGroup.setStatus('current')
if mibBuilder.loadTexts: csubJobMatchParamsGroup.setDescription("This group contains objects describing match parameters used by 'query' and 'clear' subscriber session jobs.")
csubJobQueryParamsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 8)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQuerySortKey1"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQuerySortKey2"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQuerySortKey3"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQueryResultingReportSize"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobReportSession"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubJobQueryParamsGroup = csubJobQueryParamsGroup.setStatus('current')
if mibBuilder.loadTexts: csubJobQueryParamsGroup.setDescription("This group contains objects describing parameters used by the 'query' subscriber session jobs.")
csubJobQueueGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 9)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobQueueJobId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubJobQueueGroup = csubJobQueueGroup.setStatus('current')
if mibBuilder.loadTexts: csubJobQueueGroup.setDescription('This group contains objects describing the subscriber session job queue.')
csubJobNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 10)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubJobFinishedNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubJobNotifGroup = csubJobNotifGroup.setStatus('current')
if mibBuilder.loadTexts: csubJobNotifGroup.setDescription('This group contains notifications indicating events relating to subscriber session jobs.')
csubAggStatsThreshGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 11)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRisingThresh"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionFallingThresh"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDeltaPercentFallingThresh"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionThreshEvalInterval"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubAggStatsThreshNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsThreshGroup = csubAggStatsThreshGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsThreshGroup.setDescription('This group contains objects describing the subscriber session aggregation stats thresholds.')
csubAggStatsNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 786, 2, 2, 12)).setObjects(("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionRisingNotif"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionFallingNotif"), ("CISCO-SUBSCRIBER-SESSION-MIB", "csubSessionDeltaPercentFallingThreshNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    csubAggStatsNotifGroup = csubAggStatsNotifGroup.setStatus('current')
if mibBuilder.loadTexts: csubAggStatsNotifGroup.setDescription('This group contains notifications indicating events relating to subscriber session aggregation stats.')
mibBuilder.exportSymbols("CISCO-SUBSCRIBER-SESSION-MIB", csubSessionDhcpClass=csubSessionDhcpClass, csubJob=csubJob, csubJobMatchNativeIpMask=csubJobMatchNativeIpMask, csubAggStatsIntDiscSessions=csubAggStatsIntDiscSessions, csubSessionMlpNegotiated=csubSessionMlpNegotiated, csubAggStatsSessionType=csubAggStatsSessionType, csubAggStatsIntAuthSessions=csubAggStatsIntAuthSessions, csubAggStatsTable=csubAggStatsTable, csubJobFinishedNotify=csubJobFinishedNotify, ciscoSubscriberSessionMIBCompliances=ciscoSubscriberSessionMIBCompliances, csubAggStatsNotifGroup=csubAggStatsNotifGroup, csubSessionSubscriberLabel=csubSessionSubscriberLabel, csubSessionDnis=csubSessionDnis, csubAggStatsTotalAuthSessions=csubAggStatsTotalAuthSessions, csubJobReportEntry=csubJobReportEntry, csubJobMatchIdentities=csubJobMatchIdentities, csubAggStatsGroup=csubAggStatsGroup, csubJobQueryParamsGroup=csubJobQueryParamsGroup, csubJobMatchParamsGroup=csubJobMatchParamsGroup, ciscoSubscriberSessionR2Compliance=ciscoSubscriberSessionR2Compliance, csubJobMatchMacAddress=csubJobMatchMacAddress, csubAggStatsUnAuthSessions=csubAggStatsUnAuthSessions, csubAggStatsDiscontinuityTime=csubAggStatsDiscontinuityTime, csubAggStatsTotalUpSessions=csubAggStatsTotalUpSessions, csubJobQueryParamsEntry=csubJobQueryParamsEntry, csubAggThresh=csubAggThresh, csubJobMatchNativeIpAddrType=csubJobMatchNativeIpAddrType, csubJobQueueJobId=csubJobQueueJobId, csubSessionIfIndex=csubSessionIfIndex, csubAggStatsCurrFailedSessions=csubAggStatsCurrFailedSessions, ciscoSubscriberSessionMIBConform=ciscoSubscriberSessionMIBConform, csubJobStatus=csubJobStatus, csubJobNotifGroup=csubJobNotifGroup, csubJobMatchPbhk=csubJobMatchPbhk, ciscoSubscriberSessionMIBNotifs=ciscoSubscriberSessionMIBNotifs, csubSessionDerivedCfg=csubSessionDerivedCfg, csubSessionLastChanged=csubSessionLastChanged, csubSessionTable=csubSessionTable, csubSessionTunnelName=csubSessionTunnelName, csubSessionMedia=csubSessionMedia, csubJobMatchNasPort=csubJobMatchNasPort, csubJobGroup=csubJobGroup, csubAggStatsThrottleEngagements=csubAggStatsThrottleEngagements, csubSessionAcctSessionId=csubSessionAcctSessionId, csubJobQueryResultingReportSize=csubJobQueryResultingReportSize, csubSessionDeltaPercentFallingThresh=csubSessionDeltaPercentFallingThresh, csubJobQueueTable=csubJobQueueTable, csubJobQueueGroup=csubJobQueueGroup, csubAggStatsDayCreatedSessions=csubAggStatsDayCreatedSessions, csubAggStatsAvgSessionRPH=csubAggStatsAvgSessionRPH, csubJobType=csubJobType, csubAggStatsCurrGroup=csubAggStatsCurrGroup, csubJobControl=csubJobControl, csubSessionByTypeTable=csubSessionByTypeTable, csubJobMatchOtherParams=csubJobMatchOtherParams, csubAggStatsIntTable=csubAggStatsIntTable, csubJobMatchDomainIpAddr=csubJobMatchDomainIpAddr, csubSessionNativeIpAddr=csubSessionNativeIpAddr, csubSession=csubSession, csubSessionRisingThresh=csubSessionRisingThresh, csubSessionState=csubSessionState, csubSessionAvailableIdentities=csubSessionAvailableIdentities, csubSessionFallingThresh=csubSessionFallingThresh, csubJobMatchNativeVrf=csubJobMatchNativeVrf, csubAggStatsTotalCreatedSessions=csubAggStatsTotalCreatedSessions, csubSessionGroup=csubSessionGroup, csubJobQuerySortKey1=csubJobQuerySortKey1, csubJobMatchDanglingDuration=csubJobMatchDanglingDuration, csubAggStatsIntUpSessions=csubAggStatsIntUpSessions, csubJobMatchNativeIpAddr=csubJobMatchNativeIpAddr, csubJobFinishedNotifyEnable=csubJobFinishedNotifyEnable, ciscoSubscriberSessionMIB=ciscoSubscriberSessionMIB, csubAggStatsThreshEntry=csubAggStatsThreshEntry, csubSessionDomainIpMask=csubSessionDomainIpMask, csubSessionByType=csubSessionByType, csubAggStatsIntCreatedSessions=csubAggStatsIntCreatedSessions, csubJobMatchCircuitId=csubJobMatchCircuitId, csubJobMatchServiceName=csubJobMatchServiceName, csubSessionRemoteId=csubSessionRemoteId, csubJobIdNext=csubJobIdNext, csubJobQuerySortKey2=csubJobQuerySortKey2, csubJobMatchParamsTable=csubJobMatchParamsTable, csubJobMatchDomainIpAddrType=csubJobMatchDomainIpAddrType, csubJobTable=csubJobTable, csubJobMatchMlpNegotiated=csubJobMatchMlpNegotiated, csubAggStatsUpSessions=csubAggStatsUpSessions, csubSessionRedundancyMode=csubSessionRedundancyMode, csubAggStatsIntValid=csubAggStatsIntValid, csubSessionDomainVrf=csubSessionDomainVrf, csubJobFinishedTime=csubJobFinishedTime, csubSessionEntry=csubSessionEntry, csubJobMatchSubscriberLabel=csubJobMatchSubscriberLabel, csubJobMatchUsername=csubJobMatchUsername, csubAggStatsCurrValidIntervals=csubAggStatsCurrValidIntervals, SubscriberJobIdentifierOrZero=SubscriberJobIdentifierOrZero, csubAggStatsLightWeightSessions=csubAggStatsLightWeightSessions, csubJobQueueNumber=csubJobQueueNumber, csubAggStatsCurrInvalidIntervals=csubAggStatsCurrInvalidIntervals, csubJobStorage=csubJobStorage, csubJobState=csubJobState, csubSessionDomainIpAddr=csubSessionDomainIpAddr, csubAggStatsCurrTimeElapsed=csubAggStatsCurrTimeElapsed, csubJobMatchAcctSessionId=csubJobMatchAcctSessionId, csubJobEntry=csubJobEntry, csubAggStatsTotalDiscSessions=csubAggStatsTotalDiscSessions, csubJobQueueEntry=csubJobQueueEntry, csubJobMatchDhcpClass=csubJobMatchDhcpClass, csubAggStatsThreshTable=csubAggStatsThreshTable, csubSessionFallingNotif=csubSessionFallingNotif, csubSessionNativeIpAddr2=csubSessionNativeIpAddr2, csubAggStatsDayFailedSessions=csubAggStatsDayFailedSessions, csubSessionNativeVrf=csubSessionNativeVrf, csubJobQueryParamsTable=csubJobQueryParamsTable, csubJobMatchMedia=csubJobMatchMedia, csubJobMatchRedundancyMode=csubJobMatchRedundancyMode, csubJobMatchDnis=csubJobMatchDnis, csubSessionMacAddress=csubSessionMacAddress, csubSessionProtocol=csubSessionProtocol, ciscoSubscriberSessionMIBObjects=ciscoSubscriberSessionMIBObjects, csubSessionType=csubSessionType, csubAggStatsDayUpSessions=csubAggStatsDayUpSessions, csubAggStatsCurrCreatedSessions=csubAggStatsCurrCreatedSessions, csubAggStatsTotalFlowsUp=csubAggStatsTotalFlowsUp, csubJobMatchDomain=csubJobMatchDomain, csubJobCount=csubJobCount, csubJobMatchParamsEntry=csubJobMatchParamsEntry, csubSessionNativeIpMask=csubSessionNativeIpMask, csubAggStatsPoint=csubAggStatsPoint, csubAggStatsDayGroup=csubAggStatsDayGroup, csubJobQuerySortKey3=csubJobQuerySortKey3, csubJobMatchRemoteId=csubJobMatchRemoteId, csubJobReportTable=csubJobReportTable, csubJobMatchTunnelName=csubJobMatchTunnelName, ciscoSubscriberSessionR1Compliance=ciscoSubscriberSessionR1Compliance, csubSessionIpAddrAssignment=csubSessionIpAddrAssignment, csubJobMaxNumber=csubJobMaxNumber, csubJobMatchState=csubJobMatchState, csubAggStatsAvgSessionUptime=csubAggStatsAvgSessionUptime, ciscoSubscriberSessionMIBGroups=ciscoSubscriberSessionMIBGroups, csubJobMatchDomainIpMask=csubJobMatchDomainIpMask, csubAggStatsEntry=csubAggStatsEntry, csubJobMatchProtocol=csubJobMatchProtocol, csubSessionDeltaPercentFallingThreshNotif=csubSessionDeltaPercentFallingThreshNotif, csubJobReportSession=csubJobReportSession, csubJobStartedTime=csubJobStartedTime, PYSNMP_MODULE_ID=ciscoSubscriberSessionMIB, csubAggStatsTotalLightWeightSessions=csubAggStatsTotalLightWeightSessions, csubSessionDomain=csubSessionDomain, csubAggStatsThreshNotifEnable=csubAggStatsThreshNotifEnable, csubSessionRisingNotif=csubSessionRisingNotif, csubAggStats=csubAggStats, csubSessionUsername=csubSessionUsername, csubSessionPbhk=csubSessionPbhk, csubJobFinishedReason=csubJobFinishedReason, csubAggStatsCurrAuthSessions=csubAggStatsCurrAuthSessions, csubSessionCreationTime=csubSessionCreationTime, csubSessionLocationIdentifier=csubSessionLocationIdentifier, csubAggStatsPointType=csubAggStatsPointType, csubAggStatsPendingSessions=csubAggStatsPendingSessions, csubAggStatsAuthSessions=csubAggStatsAuthSessions, csubSessionNasPort=csubSessionNasPort, csubSessionCircuitId=csubSessionCircuitId, csubAggStatsRedSessions=csubAggStatsRedSessions, csubAggStatsAvgSessionRPM=csubAggStatsAvgSessionRPM, csubAggStatsDayAuthSessions=csubAggStatsDayAuthSessions, csubAggStatsCurrUpSessions=csubAggStatsCurrUpSessions, csubSessionThreshEvalInterval=csubSessionThreshEvalInterval, csubAggStatsThreshGroup=csubAggStatsThreshGroup, csubSessionServiceIdentifier=csubSessionServiceIdentifier, SubscriberJobIdentifier=SubscriberJobIdentifier, csubAggStatsDayDiscSessions=csubAggStatsDayDiscSessions, csubSessionNativeIpAddrType2=csubSessionNativeIpAddrType2, csubAggStatsIntFailedSessions=csubAggStatsIntFailedSessions, csubJobMaxLife=csubJobMaxLife, csubJobReportId=csubJobReportId, csubAggStatsIntEntry=csubAggStatsIntEntry, csubAggStatsCurrDiscSessions=csubAggStatsCurrDiscSessions, csubJobId=csubJobId, csubJobMatchAuthenticated=csubJobMatchAuthenticated, csubSessionByTypeEntry=csubSessionByTypeEntry, csubJobIndexedAttributes=csubJobIndexedAttributes, csubAggStatsIntNumber=csubAggStatsIntNumber, csubSessionDomainIpAddrType=csubSessionDomainIpAddrType, csubSessionAuthenticated=csubSessionAuthenticated, csubSessionNativeIpMask2=csubSessionNativeIpMask2, csubAggStatsTotalFailedSessions=csubAggStatsTotalFailedSessions, csubAggStatsIntGroup=csubAggStatsIntGroup, csubSessionNativeIpAddrType=csubSessionNativeIpAddrType, csubAggStatsCurrFlowsUp=csubAggStatsCurrFlowsUp, csubAggStatsHighUpSessions=csubAggStatsHighUpSessions, csubJobMatchDomainVrf=csubJobMatchDomainVrf)

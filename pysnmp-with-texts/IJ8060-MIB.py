#
# PySNMP MIB module IJ8060-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IJ8060-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:53:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Unsigned32, MibIdentifier, NotificationType, TimeTicks, Counter64, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, ObjectIdentity, Integer32, Bits, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Unsigned32", "MibIdentifier", "NotificationType", "TimeTicks", "Counter64", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "ObjectIdentity", "Integer32", "Bits", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
dm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2))
class DisplayString(OctetString):
    pass

device = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1))
device_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1)).setLabel("device-system")
status_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2)).setLabel("status-system")
processing_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3)).setLabel("processing-subsystem")
accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16))
printer_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1)).setLabel("printer-accounting")
printed_media_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1)).setLabel("printed-media-usage")
print_meter_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14)).setLabel("print-meter-usage")
scanner_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2)).setLabel("scanner-accounting")
scanned_media_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1)).setLabel("scanned-media-usage")
printer_color_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3)).setLabel("printer-color-accounting")
printed_media_color_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3, 1)).setLabel("printed-media-color-usage")
source_tray_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 5)).setLabel("source-tray-accounting")
source_tray_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 5, 1)).setLabel("source-tray-usage")
destination_bin_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 6)).setLabel("destination-bin-accounting")
destination_bin_usage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 6, 1)).setLabel("destination-bin-usage")
destination_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4)).setLabel("destination-subsystem")
print_engine = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1)).setLabel("print-engine")
print_media = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8)).setLabel("print-media")
media_size = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 5)).setLabel("media-size")
control_panel_display = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 65)).setLabel("control-panel-display")
settings_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1)).setLabel("settings-system")
job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6))
settings_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1)).setLabel("settings-job")
operating_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 19)).setLabel("operating-system")
pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3))
settings_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1)).setLabel("settings-pdl")
status_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2)).setLabel("status-pdl")
background_message = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37)).setLabel("background-message")
background_message1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 1)).setLabel("background-message1")
background_message2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 2)).setLabel("background-message2")
errorlog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11))
error1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1))
error2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2))
error3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3))
error4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4))
error5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5))
error6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6))
error7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7))
error8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8))
error9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9))
error10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10))
error11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11))
error12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12))
error13 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13))
error14 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14))
error15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15))
error16 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16))
error17 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17))
error18 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18))
error19 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19))
error20 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20))
error21 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21))
error22 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22))
error23 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23))
error24 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24))
error25 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25))
error26 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26))
error27 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27))
error28 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28))
error29 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29))
error30 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30))
error31 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31))
error32 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32))
error33 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33))
error34 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34))
error35 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35))
error36 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36))
error37 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37))
error38 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38))
error39 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39))
error40 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40))
error41 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41))
error42 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42))
error43 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43))
error44 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44))
error45 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45))
error46 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46))
error47 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47))
error48 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48))
error49 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49))
error50 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50))
warninglog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22))
warning1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 1))
warning2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 2))
warning3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 3))
warning4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 4))
warning5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 5))
warning6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 6))
warning7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 7))
warning8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 8))
warning9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 9))
warning10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 10))
warning11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 11))
warning12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 12))
warning13 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 13))
warning14 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 14))
warning15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 15))
warning16 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 16))
warning17 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 17))
warning18 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 18))
warning19 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 19))
warning20 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 20))
warning21 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 21))
warning22 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 22))
warning23 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 23))
warning24 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 24))
warning25 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 25))
warning26 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 26))
warning27 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 27))
warning28 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 28))
warning29 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 29))
warning30 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 30))
warning31 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 31))
warning32 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 32))
warning33 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 33))
warning34 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 34))
warning35 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 35))
warning36 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 36))
warning37 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 37))
warning38 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 38))
warning39 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 39))
warning40 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 40))
warning41 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 41))
warning42 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 42))
warning43 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 43))
warning44 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 44))
warning45 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 45))
warning46 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 46))
warning47 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 47))
warning48 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 48))
warning49 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 49))
warning50 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 50))
display = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 20))
display_status = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 20, 1)).setLabel("display-status")
id = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4))
web_server = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 6)).setLabel("web-server")
settings_web_server = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 6, 1)).setLabel("settings-web-server")
security = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 23))
settings_security = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 23, 1)).setLabel("settings-security")
pdl_postscript = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4)).setLabel("pdl-postscript")
settings_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1)).setLabel("settings-prt-eng")
status_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2)).setLabel("status-prt-eng")
intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3))
settings_intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1)).setLabel("settings-intray")
imaging = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6))
ph = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7))
settings_ph = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 1)).setLabel("settings-ph")
pdl_pcl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3)).setLabel("pdl-pcl")
pdl_pdf = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 15)).setLabel("pdl-pdf")
fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7)).setLabel("fax-proc-sub")
status_fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2)).setLabel("status-fax-proc-sub")
foreign_interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 8)).setLabel("foreign-interface")
source_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2)).setLabel("source-subsystem")
scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2))
settings_scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1)).setLabel("settings-scanner")
settings_fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1)).setLabel("settings-fax-proc-sub")
active_print_jobs = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2)).setLabel("active-print-jobs")
job_being_parsed = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1)).setLabel("job-being-parsed")
job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5)).setLabel("job-info")
job_info_attribute = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23)).setLabel("job-info-attribute")
job_info_accounting = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28)).setLabel("job-info-accounting")
held_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7)).setLabel("held-job")
held_job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1)).setLabel("held-job-info")
held_job_control = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2)).setLabel("held-job-control")
mio = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3))
mio1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1))
mio4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 4))
usb_interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9)).setLabel("usb-interface")
usb = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2))
io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1))
settings_io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1)).setLabel("settings-io")
ports = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3))
port1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1))
remote_procedure_call = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13)).setLabel("remote-procedure-call")
settings_rpc = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 1)).setLabel("settings-rpc")
status_rpc = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2)).setLabel("status-rpc")
file_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10)).setLabel("file-system")
settings_file_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1)).setLabel("settings-file-system")
file_systems = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3)).setLabel("file-systems")
file_system2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 2)).setLabel("file-system2")
file_system3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 3)).setLabel("file-system3")
file_system4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 4)).setLabel("file-system4")
resource_manager = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12)).setLabel("resource-manager")
mass_storage_resources = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3)).setLabel("mass-storage-resources")
mass_storage_block_driver = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15)).setLabel("mass-storage-block-driver")
settings_mass_storage_bd = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15, 1)).setLabel("settings-mass-storage-bd")
status_mass_storage_bd = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15, 2)).setLabel("status-mass-storage-bd")
device_configure = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 32)).setLabel("device-configure")
phd = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5))
phd1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 1))
phd2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2))
printer_calibration_dhalf = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 37)).setLabel("printer-calibration-dhalf")
printer_calibration_cpr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 38)).setLabel("printer-calibration-cpr")
intrays = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3))
intray1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1))
intray2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2))
intray3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3))
intray5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 5))
intray6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 6))
outbin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4))
settings_outbin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 1)).setLabel("settings-outbin")
outbins = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3))
outbin1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1))
outbin2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2))
outbin3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3))
outbin4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4))
outbin5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5))
ph_devices = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3)).setLabel("ph-devices")
ph2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 2))
settings_print_media = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 1)).setLabel("settings-print-media")
media_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3)).setLabel("media-info")
media1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1))
media2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2))
media3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3))
media4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4))
media5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5))
media6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6))
media7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7))
media8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8))
media9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9))
media10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10))
media11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11))
media12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12))
media13 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13))
media14 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14))
media15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15))
media16 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 16))
media17 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 17))
media18 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 18))
media19 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 19))
media_types = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 8)).setLabel("media-types")
media_counts = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 7)).setLabel("media-counts")
consumables = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10))
consumables_1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 1)).setLabel("consumables-1")
consumable_status = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 1, 1)).setLabel("consumable-status")
consumable_string = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 8)).setLabel("consumable-string")
consumables_status = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 5)).setLabel("consumables-status")
consumables_life = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 5, 1)).setLabel("consumables-life")
webserver_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 9)).setLabel("webserver-proc-sub")
settings_webserver = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 9, 1)).setLabel("settings-webserver")
firmware_download = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18)).setLabel("firmware-download")
upgradable_devices = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20)).setLabel("upgradable-devices")
perm_store_init_occurred = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 10), OctetString()).setLabel("perm-store-init-occurred").setMaxAccess("readonly")
if mibBuilder.loadTexts: perm_store_init_occurred.setStatus('optional')
if mibBuilder.loadTexts: perm_store_init_occurred.setDescription('This object will set the cAllPermDevices bit when a full perm storage initialization occurs (as would be the case for a brand new system or as a result of a powerup key sequence or <<hidden>> object request). If only one device was initialized (as would be the case if a disk were added to an existing system or a formatter were swapped out), then only the appropriate collection bits will be returned. If there are no collection bits set then this indicates that no initialization took place.')
printed_media_simplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("printed-media-simplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_simplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_simplex_count.setDescription("Total number of simplex pages printed in this media size. Additional information: The 5 usage (simplex/duplex count, simplex/duplex click charge and paper size total) objects described here and below detail the usage for the printer for each paper size defined in the PCL Implementor's Guide and in the Media Size Table in the hpmib.txt. The OID binding is based on the click attribute and paper size. For example: The format for the OID is as follows: 3.4.1.5.x.y <-----> | | | | \\ / | paper size / \\ PRINTER-CLICK_TOTALS ROOT \\ OID click attribute 1..5 x values are 1..5: 1) simplex count 2) simplex click charge 3) duplex count 4) duplex click charge 5) printer or scanner paper size total (i.e. depends if the root OID is referrring to the printer or scanner). y : paper size as defined in the Media Size Table in the hpmib.txt ")
printed_media_simplex_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 2), OctetString()).setLabel("printed-media-simplex-charge").setMaxAccess("readwrite")
if mibBuilder.loadTexts: printed_media_simplex_charge.setStatus('optional')
if mibBuilder.loadTexts: printed_media_simplex_charge.setDescription('Charge for each simplex page printed in this media size. Additional information: This is a volatile set of charge values that will always reset to the default values after a power-cycle. The default values represent a ratio of the page size as compared to a letter or A4 page size. Setting this object has the effect of altering PRINTED-MEDIA-DUPLEX-CHARGE to have a value that is twice that of the simplex charge.')
printed_media_duplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("printed-media-duplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_duplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_duplex_count.setDescription('Total number of duplex pages printed in this media size.')
printed_media_duplex_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 4), OctetString()).setLabel("printed-media-duplex-charge").setMaxAccess("readwrite")
if mibBuilder.loadTexts: printed_media_duplex_charge.setStatus('optional')
if mibBuilder.loadTexts: printed_media_duplex_charge.setDescription('Charge for each duplex page printed in this media size. Additional information: The click charges for duplex printed media.')
printed_media_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 5), OctetString()).setLabel("printed-media-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_total_charge.setStatus('optional')
if mibBuilder.loadTexts: printed_media_total_charge.setDescription('The total charge for pages printed in this media size.')
printed_media_maximum_pixels_per_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 6), Integer32()).setLabel("printed-media-maximum-pixels-per-page").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_maximum_pixels_per_page.setStatus('optional')
if mibBuilder.loadTexts: printed_media_maximum_pixels_per_page.setDescription('The number of pixels required to completely fill a page of this media size. The device POS will specify the resolution at which this pixel count was calculated. Additional information: The number of pixels required to fill a page of a specific media size. The OID binding is the media size you to query for. Only media sizes which the printer supports will be available.')
printed_media_combined_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 7), OctetString()).setLabel("printed-media-combined-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_combined_total.setStatus('optional')
if mibBuilder.loadTexts: printed_media_combined_total.setDescription('Total number of letter equivalently weighted pages both color and mono combined with this printer. Additional information: The combined total per page size of simplex and duplex color pages plus simplex and duplex mono pages.')
printed_media_dimplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("printed-media-dimplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_dimplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_dimplex_count.setDescription('Total number of mono dimplex pages printed in this media size. A dimplex page is one that has been printed in duplex mode but the back side is blank. Dimplex pages occur when the printer firmware inserts a blank page in order to complete a duplexed job which is sent to the printer with an odd number of pages.')
usage_printer_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 2), OctetString()).setLabel("usage-printer-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_total_charge.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_total_charge.setDescription('Total printer charge for all paper sizes printed.')
usage_staple_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("usage-staple-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_staple_count.setStatus('optional')
if mibBuilder.loadTexts: usage_staple_count.setDescription('Total number of staples used.')
usage_instructions_line1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("usage-instructions-line1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: usage_instructions_line1.setStatus('optional')
if mibBuilder.loadTexts: usage_instructions_line1.setDescription('The first line of usage instructions for the device user.Appears on Line 1 of the usage page.')
usage_instructions_line2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("usage-instructions-line2").setMaxAccess("readwrite")
if mibBuilder.loadTexts: usage_instructions_line2.setStatus('optional')
if mibBuilder.loadTexts: usage_instructions_line2.setDescription('The second line of usage instructions for the device user.Appears on Line 1 of the usage page.')
usage_instructions_line3 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("usage-instructions-line3").setMaxAccess("readwrite")
if mibBuilder.loadTexts: usage_instructions_line3.setStatus('optional')
if mibBuilder.loadTexts: usage_instructions_line3.setDescription('The third line of usage instructions for the device user.Appears on Line 1 of the usage page.')
usage_instructions_line4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("usage-instructions-line4").setMaxAccess("readwrite")
if mibBuilder.loadTexts: usage_instructions_line4.setStatus('optional')
if mibBuilder.loadTexts: usage_instructions_line4.setDescription('The fourth line of usage instructions for the device user.Appears on Line 1 of the usage page.')
source_tray_usage_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 10), Integer32()).setLabel("source-tray-usage-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: source_tray_usage_total.setStatus('optional')
if mibBuilder.loadTexts: source_tray_usage_total.setDescription('This object reports the total source tray usage for the life of the printer. This value is reported on the usage page.')
destination_bin_usage_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 11), Integer32()).setLabel("destination-bin-usage-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: destination_bin_usage_total.setStatus('optional')
if mibBuilder.loadTexts: destination_bin_usage_total.setDescription('This object reports the total destination bin usage for the life of the printer. This value is reported on the usage page.')
usage_printer_mono_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 12), OctetString()).setLabel("usage-printer-mono-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_mono_total_charge.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_mono_total_charge.setDescription('Total printer charge for all paper sizes printed in monochrome only. Additional information: This is the total charge over the range of all supported media sizes for duplex and simplex mono pages.')
usage_printer_color_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 13), OctetString()).setLabel("usage-printer-color-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_color_total_charge.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_color_total_charge.setDescription('Total printer charge for all paper sizes printed in color only. Additional information: This is the total charge over the range of all supported media sizes for duplex and simplex color pages.')
print_meter_usage_threshold = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10000, 350000))).setLabel("print-meter-usage-threshold").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_usage_threshold.setStatus('optional')
if mibBuilder.loadTexts: print_meter_usage_threshold.setDescription('A value indicating the threshold value for this category of pages. The device POS will indicate the units of measure for this threshold value. Additional information: This usage threshold represents the number of 600dpi color pixels requested for a given image. The OID bindings for this object are as follows: 1 = Professional (BEST) - Full Color > 90K color pixels 2 = Professional (BEST) - Accent Color <= 90K color pixels 3 = General Office (GOOD) - Full Color > 90K color pixels 4 = General Office (GOOD) - Accent Color <= 90K color pixels These objects are normally read-only.')
print_meter_print_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ePrintQualityMono", 1), ("ePrintQualityGood", 2), ("ePrintQualityBest", 3)))).setLabel("print-meter-print-quality").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_print_quality.setStatus('optional')
if mibBuilder.loadTexts: print_meter_print_quality.setDescription('This enumeration describes the selected print quality for this category of printed pages.')
print_meter_simplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-simplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_simplex_count.setStatus('optional')
if mibBuilder.loadTexts: print_meter_simplex_count.setDescription("Total number of simplex pages printed for this category of printed pages. Additional information: The usage (simplex/duplex/dimplex count and charge objects described here and below detail the usage for the printer for each catagory of threshold/PQ and media size - as defined in the PCL Implementor's Guide and in the Media Size Table in the hpmib.txt. The OID bindings are based on the coverage threshold/PQ and media size. For example: The format for the OID is as follows: 1.1.16.7.1.1.m.n <----------> | | | | | / | \\ Base OID | media size [1..32768] \\ \\ Threshold/PQ Category [1..4] m - Threshold/PQ values are 1..4: 1) Color Threshold 1 - Print Quality Best 2) Color Threshold 2 - Print Quality Best 3) Color Threshold 1 - Print Quality Good 4) Color Threshold 2 - Print Quality Good n - media size integer as defined in the Media Size Table in the hpmib.txt. The sum of all PML object values with the same base OID and 'm' value for a given media size will be returned by the corresponding PRINTED-MEDIA-COLOR-XXX-COUNT/CHARGE object.")
print_meter_duplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-duplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_duplex_count.setStatus('optional')
if mibBuilder.loadTexts: print_meter_duplex_count.setDescription('Total number of duplex pages printed for this category of printed pages.')
print_meter_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 6), OctetString()).setLabel("print-meter-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_total_charge.setStatus('optional')
if mibBuilder.loadTexts: print_meter_total_charge.setDescription('Total number of simplex plus duplex pages printed multiplied by the unit charge for each given media size for this category of printed pages.')
print_meter_dimplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-dimplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_dimplex_count.setStatus('optional')
if mibBuilder.loadTexts: print_meter_dimplex_count.setDescription('Total number of dimplex pages printed for this category of printed pages.')
print_meter_simplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-simplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_simplex_total.setStatus('optional')
if mibBuilder.loadTexts: print_meter_simplex_total.setDescription('Total number of simplex pages printed for this category of printed pages.')
print_meter_duplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-duplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_duplex_total.setStatus('optional')
if mibBuilder.loadTexts: print_meter_duplex_total.setDescription('Total number of duplex pages printed for this category of printed pages.')
print_meter_category_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 10), OctetString()).setLabel("print-meter-category-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_category_total.setStatus('optional')
if mibBuilder.loadTexts: print_meter_category_total.setDescription('Total number of simplex plus duplex pages printed for this category of printed pages.')
print_meter_dimplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 14, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("print-meter-dimplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_meter_dimplex_total.setStatus('optional')
if mibBuilder.loadTexts: print_meter_dimplex_total.setDescription('Total number of dimplex pages printed for this category of printed pages.')
usage_printer_mono_simplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 15), Integer32()).setLabel("usage-printer-mono-simplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_mono_simplex_total.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_mono_simplex_total.setDescription('This object reports the total of monochrome simplex pages printed on this device. This value is the sum of all PRINTED-MEDIA-SIMPLEX-COUNT.n counter values.')
usage_printer_mono_duplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 16), Integer32()).setLabel("usage-printer-mono-duplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_mono_duplex_total.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_mono_duplex_total.setDescription('This object reports the total of monochrome duplex pages printed on this device. This value is the sum of all PRINTED-MEDIA-DUPLEX-COUNT.n counter values.')
usage_printer_mono_dimplex_total = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 1, 17), Integer32()).setLabel("usage-printer-mono-dimplex-total").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_printer_mono_dimplex_total.setStatus('optional')
if mibBuilder.loadTexts: usage_printer_mono_dimplex_total.setDescription('This object reports the total of monochrome dimplex pages printed on this device. This value is the sum of all PRINTED-MEDIA-DIMPLEX-COUNT.n counter values.')
scanned_media_simplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1, 1), Integer32()).setLabel("scanned-media-simplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanned_media_simplex_count.setStatus('optional')
if mibBuilder.loadTexts: scanned_media_simplex_count.setDescription("Total number of simplex pages scanned, for this media size. Additional information: The 5 usage (simplex/duplex count, simplex/duplex click charge and paper size total) objects described here and below detail the usage for the scanner for each paper size defined in the PCL Implementor's Guide and in the Media Size Table in the hpmib.txt. The OID binding is based on the click attribute and paper size. For example: The format for the OID is as follows: 3.4.1.5.x.y <-----> | | | | \\ / | paper size / \\ PRINTER-CLICK_TOTALS ROOT \\ OID click attribute 1..5 x values are 1..5: 1) simplex count 2) simplex click charge 3) duplex count 4) duplex click charge 5) printer or scanner paper size total (i.e. depends if the root OID is referrring to the printer or scanner). y : paper size as defined in the Media Size Table in the hpmib.txt The click charge objects are of data type real and have a single digit of precision. Setting these objects to more than a single digit of precision will cause truncation at a single digit, for example, if click charge is set to 15.475 and later retrieved with a get, the value will be 15.400 for this object.")
scanned_media_simplex_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1, 2), OctetString()).setLabel("scanned-media-simplex-charge").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanned_media_simplex_charge.setStatus('optional')
if mibBuilder.loadTexts: scanned_media_simplex_charge.setDescription('Charge for each simplex page printed in this media size. Additional information: This is a volatile set of charge values that will always reset to the default values after a power-cycle. The default values represent a ratio of the page size as compared to a letter or A4 page size. Setting this object has the effect of altering SCANNED-MEDIA-DUPLEX-CHARGE to have a value that is twice that of the simplex charge.')
scanned_media_duplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 930576247))).setLabel("scanned-media-duplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanned_media_duplex_count.setStatus('optional')
if mibBuilder.loadTexts: scanned_media_duplex_count.setDescription('Total number of duplex pages scanned, for this media size.')
scanned_media_duplex_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1, 4), OctetString()).setLabel("scanned-media-duplex-charge").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanned_media_duplex_charge.setStatus('optional')
if mibBuilder.loadTexts: scanned_media_duplex_charge.setDescription('Charge for each duplex page scanned, for this media size. Additional information: Setting this object has the effect of also altering the corresponding value for SCANNED-MEDIA-SIMPLEX-CHARGE with exactly half the value of the Duplex charge. Since the simplex charge is always half the duplex charge - this means that the first decimal place of the duplex charge must be evenly divisible by 2. This means that a Set operation to this object with a value of 2.3 will generate a PML response of OK_NEAREST_LEGAL_VALUE_SUBSTITUTED and the value written will snap to 2.2. The simplex charge will also take on a value of 1.1. The snap behavior for this object will always be as follows based on the first decimal place: if even then accept, otherwise snap to the next lower tenth.')
scanned_media_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 1, 5), OctetString()).setLabel("scanned-media-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanned_media_total_charge.setStatus('optional')
if mibBuilder.loadTexts: scanned_media_total_charge.setDescription('The total charge for pages scanned, for this media size.')
usage_scanner_total_charge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 2, 2), OctetString()).setLabel("usage-scanner-total-charge").setMaxAccess("readonly")
if mibBuilder.loadTexts: usage_scanner_total_charge.setStatus('optional')
if mibBuilder.loadTexts: usage_scanner_total_charge.setDescription('Total scanner charge or cost for all paper sizes scanned.')
printed_media_color_simplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3, 1, 1), Integer32()).setLabel("printed-media-color-simplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_color_simplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_color_simplex_count.setDescription('Total number of color simplex pages printed in this media size.')
printed_media_color_duplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3, 1, 3), Integer32()).setLabel("printed-media-color-duplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_color_duplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_color_duplex_count.setDescription('Total number of color duplex pages printed in this media size.')
printed_media_color_total_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3, 1, 5), OctetString()).setLabel("printed-media-color-total-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_color_total_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_color_total_count.setDescription('The total count for color pages printed in this media size.')
printed_media_color_dimplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 3, 1, 6), Integer32()).setLabel("printed-media-color-dimplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printed_media_color_dimplex_count.setStatus('optional')
if mibBuilder.loadTexts: printed_media_color_dimplex_count.setDescription('Total number of color dimplex pages printed in this media size. A color dimplex page is a color page that has been printed in duplex mode but the back side is blank. Dimplex pages occur when the printer firmware inserts a blank page in order to complete a duplexed job which is sent to the printer with an odd number of pages.')
source_tray_usage_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 5, 1, 1), Integer32()).setLabel("source-tray-usage-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: source_tray_usage_count.setStatus('optional')
if mibBuilder.loadTexts: source_tray_usage_count.setDescription('Total number of pages printed from this source tray. Additional information: This object will track how many images have been printed with the original source tray as one of the following: 1. Envelope Feeder 2. Manual Feed Tray 3. Tray 1 4. Tray 2 5. Tray 3 6. Tray 4 7. Tray 5 8. External Tray 9. Other')
destination_bin_usage_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 16, 6, 1, 1), Integer32()).setLabel("destination-bin-usage-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: destination_bin_usage_count.setStatus('optional')
if mibBuilder.loadTexts: destination_bin_usage_count.setDescription('Total number of pages printed to this destination bin. Additional information: This object will track how many images have been printed with the original destination bin as one of the following: 1. Face Down Bin 2. Face Up Bin 3. Bin 1 4. Bin 2 5. Bin 3 6. Bin 4 7. Bin 5 8. Other')
media_size_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 5, 1), Integer32()).setLabel("media-size-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media_size_count.setStatus('optional')
if mibBuilder.loadTexts: media_size_count.setDescription("The number of impressions printed on sheets of this media size. The device POS should state whether this value is lost across a power cycle or is kept in permanent storage. Additional information: The value of this object is persistent across a power cycle. The index for these objects, the last number of the OID, uniquely identifies the paper size. This value corresponds to the page sizes listed below. These values are also documented in the PCL Implementor's Guide and the PML Master MIB. 1 US-Executive 2 US-Letter 3 US-Legal 10 Foolscap 11 Ledger 15 Statement 17 ROC 16K 19 eROC8K 25 ISO and JIS A5 26 ISO and JIS A4 27 ISO and JIS A3 36 RA4 37 SRA4\\ 38 SRA3 39 RA3 44 JIS B6 45 JIS B5 46 JIS B4 72 Japanese Postcard Double 74 4x6 75 5x8 101 Custom 120 Tabloid Extended 12x18 122 5x7 32767 Unknown Paper Size")
localization_languages_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 52), OctetString()).setLabel("localization-languages-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: localization_languages_supported.setStatus('optional')
if mibBuilder.loadTexts: localization_languages_supported.setDescription('The list of languages supported by the device. The languages are primarily, but not limited to, two character codes from ISO 639, each separated by a comma character. Additional information: This string will always be in the Roman-8 character set. See prtLocalizationLanguage for details about each language value.')
localization_countries_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 53), OctetString()).setLabel("localization-countries-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: localization_countries_supported.setStatus('optional')
if mibBuilder.loadTexts: localization_countries_supported.setDescription('The list of countries supported by the device. The countries are primarily, but not limited to, two character codes from ISO 3166, each separated by a comma character. Additional information: This string will always be in the Roman-8 character set. See prtLocalizationCountry for details about each country value.')
control_panel_button_press = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9))).clone(namedValues=NamedValues(("eGoButton", 1), ("eCancelJobButton", 9)))).setLabel("control-panel-button-press").setMaxAccess("writeonly")
if mibBuilder.loadTexts: control_panel_button_press.setStatus('optional')
if mibBuilder.loadTexts: control_panel_button_press.setDescription('Writing this object simulates pressing a button on the control panel. Reading it will return the last key pressed either on the control panel or via PML. The device POS will specify which keys are supported.')
control_panel_display_contents_change_counter = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 63), Integer32()).setLabel("control-panel-display-contents-change-counter").setMaxAccess("readonly")
if mibBuilder.loadTexts: control_panel_display_contents_change_counter.setStatus('optional')
if mibBuilder.loadTexts: control_panel_display_contents_change_counter.setDescription('A counter which increments whenever the contents of the front panel display changes. This object is implemented as a 32-bit signed integer which rolls over to zero when it reaches a maximum value.')
control_panel_display_contents_crc = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 64), Integer32()).setLabel("control-panel-display-contents-crc").setMaxAccess("readonly")
if mibBuilder.loadTexts: control_panel_display_contents_crc.setStatus('optional')
if mibBuilder.loadTexts: control_panel_display_contents_crc.setDescription('Reading this object returns a 32-bit Cyclical Redundancy Check (CRC) which represents the current contents of the display. Additional information: This object has been implimented as an 32-bit CRC for this product.')
control_panel_display_graphical_contents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 65, 1), OctetString()).setLabel("control-panel-display-graphical-contents").setMaxAccess("readonly")
if mibBuilder.loadTexts: control_panel_display_graphical_contents.setStatus('optional')
if mibBuilder.loadTexts: control_panel_display_graphical_contents.setDescription('Reading this object returns a graphical file format image representing the current pixel content of the display. The device POS will specify the expected screen resolution, color depth of the display and graphics file format for a given product (eg. 160x64x1 GIF format OR 640x240x4 JPEG format). If the image is large enough that it needs to be returned in multiple objects then each array object will contain a portion of the image. The image will then need to be reconstructed by a host application. An application that needs to determine if their is an additional object to be retreived will need to perform a GETNEXT operation until there are no more objects in the sub-tree. Additional information: This object returns a GIF image that represents the current contents of the 640x240x2 control panel display. Most display images require more than one instance of this object in order to retreive the complete GIF image.')
control_panel_key_press = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("control-panel-key-press").setMaxAccess("writeonly")
if mibBuilder.loadTexts: control_panel_key_press.setStatus('optional')
if mibBuilder.loadTexts: control_panel_key_press.setDescription('Writing this object simulates pressing a key on the control panel. Reading it will return the last key pressed either on the control panel or via PML. This object obsoletes/replaces CONTROL-PANEL-BUTTON-PRESS object which was unable to represent each of the possible key combinations of our current control panels (ie. Full QWERTY keyboard). The device POS will specify the full range of keys supported by this object. Additional information: >>>>This object is write-only for hw_rom variant but it is read-write for all other variants.<<<<< Writing this object simulates pressing a key on the control panel. Reading it will return the last key pressed either on the control panel or via PML. This object obsoletes/replaces CONTROL-PANEL-BUTTON-PRESS object which was unable to represent each of the possible key combinations of our current control panels (ie. Full QWERTY keyboard). The device POS will specify the full range of keys supported by this object. The implementation of this object supports the Unified Key Encoding Scheme.')
energy_star = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 1), Integer32()).setLabel("energy-star").setMaxAccess("readwrite")
if mibBuilder.loadTexts: energy_star.setStatus('optional')
if mibBuilder.loadTexts: energy_star.setDescription('Returns or changes the Energy Star sleep value. If the value is greater than zero, then the device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. A value of zero means Energy Star is disabled and the device will not go to sleep based on print engine idle time. The value must be non-negative. Additional information: Returns or changes the Energy Star sleep value. The device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. InkJet supports values of 0, 60, 900, 1800, 3600, 5400, 7200, 14400 seconds. A value of 0 means never enter sleep mode based on the print engine idle time. Setting to an unsupported value causes the printer to substitute a value (listed below) and to return <noError> status. Setting this value when the printer is in sleep mode will not cause it to wakeup unless it is set to 0. The values are as follow: <=0 snap to 0 >=1 and <= 479 snap to 60 (1 minute) >=480 and <= 1349 snap to 900 (15 minutes) >=1350 and <= 2249 snap to 1800 (30 minutes) >=2250 and <= 3149 snap to 2700 (45 minutes) >=3150 and <= 4499 snap to 3600 (1 hour) >=4500 and <= 6299 snap to 5400 (90 minutes) >=2700 and <= 5399 snap to 3600 (1 hour) >=5400 and <= 10799 snap to 7200 (2 hours) >=10800 snap to 14400 (4 hours).')
sleep_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("sleep-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: sleep_mode.setStatus('optional')
if mibBuilder.loadTexts: sleep_mode.setDescription("Returns eTrue if the device is in energy saving sleep mode, otherwise returns eFalse. Setting SLEEP-MODE to eFalse causes the device to wake up, if it is in sleep mode. Setting SLEEP-MODE to eTrue causes the device to go into sleep mode. Additional information: This object returns eTrue if the device is in energy saving sleep mode, otherwise it returns eFalse. Setting this object to eTrue while the printer is awake will not change the printer's current state and will return <genErr> status. NOTE: This object should behave this way when the printer does not have an instant-on fuser. Setting this object to eTrue while printer is already in Sleep Mode will not change the printer's current state and will return <noError> status. Setting this object to eFalse while printer is already awake will not change the printer's current state and will return <noError> status. Setting this object to eFalse while the printer is asleep causes the device to wake up. ")
power_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ePowerStateAwake", 1), ("ePowerStatePowerSave", 2), ("ePowerStateSleep", 3), ("ePowerStateOff", 4), ("ePowerStateTransitioningToAwake", 5), ("ePowerStateTransitioningToPowerSave", 6), ("ePowerStateTransitioningToSleep", 7), ("ePowerStateTransitioningToOff", 8)))).setLabel("power-state").setMaxAccess("readwrite")
if mibBuilder.loadTexts: power_state.setStatus('optional')
if mibBuilder.loadTexts: power_state.setDescription("This object is used to inquire about and to control the 'power state' of the device. The exact meaning of each enumeration may vary from device to device, but the general interpretation is as follows: ePowerStateAwake: The device is idle (immediately ready to process a job) or processing a job. ePowerStatePowerSave: The device is in a low power state and will not be immediately available to process an incoming job. A 'warm-up time' of several seconds can be expected. ePowerStateSleep: The device is in a sleep state. It uses less power than when in the power save state. It can also be expected to need a substantially longer warm-up time than when in the power save state. ePowerStateOff: The device is powered off. Note that when the device is powered off then SNMP/PML requests obviously cannot be honored. Therefore ePowerStateOff will likely never be returned from a PML get operation. However, ePowerStateOff could potentially be used in a PML set operation to power down the device if it has a software/firmware controllable power switch. For a given product it may not be possible to have the device enter the requested state due to the current state of the device. E.g., it may not be possible to enter the power save state if the device currently is in the sleep state. In this case a set operation will have an execution outcome of <genErr>. The same execution outcome can be expected if the device is processing a job and an attempt is made to e.g. bring the device into the power save state or the sleep state. A get operation on the object returns the current power state of the device. While the device is transitioning from one state to another one of the values ePowerStateTransitioningToAwake, ePowerStateTransitioningToPowerSave, ePowerStateTransitioningToSleep or ePowerStateTransitioningToOff will be returned from a PML get operation. An attempt to perform a PML set with any of these four values will yield <badValue>. Additional information: nothing beyond old description")
factory_reset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 68), Integer32()).setLabel("factory-reset").setMaxAccess("writeonly")
if mibBuilder.loadTexts: factory_reset.setStatus('optional')
if mibBuilder.loadTexts: factory_reset.setDescription('writing an integer 0 will do factory reset on system variables, MFP Settings and the .NET database without a reboot. Additional information: nothing beyond old description')
on_off_line = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOnline", 1), ("eOffline", 2), ("eOfflineAtEndOfJob", 3)))).setLabel("on-off-line").setMaxAccess("readwrite")
if mibBuilder.loadTexts: on_off_line.setStatus('optional')
if mibBuilder.loadTexts: on_off_line.setDescription("To bring the PDL processing sub-system on or off line. If the device is a printer, then the printer does not process print job data when the printer is off line. PML communication persists. Additional information: When the printer is in the Offline state, printing will stop as soon as possible (no more sheets of media are pulled from input trays). The I/O is taken offline also. Setting to eOnline has the following affect: Printer will immediately go to or remain in the Online state; <noError> status is returned. If the printer's current state is Offline with a pending error condition that prevents the printer from going to the Online state, the printer will remain in the Offline state; <genErr> status is returned (see the Control Panel ERS for a list of error conditions). Setting to eOffline has the following affect: Printer will immediately go to or remain in the Offline state; <noError> status is returned. If pages are being printed, those pages will complete with the printer in the Offline state. Setting to eOfflineAtEndOfJob has the following affect: If not in a job or already in the Offline state, the printer will immediately go to or remain in the Offline state; <noError> status is returned. If in a job and the current state is Online, the printer will remain in the Online state, with the value of this object as eOfflineAtEndOfJob, until the end of the job; <noError> status is returned. At the end of the job, the printer goes to the Offline state and the value of this object becomes eOffline. Setting this object to eOffline or eOnline before the end of the job causes the action for that value to be taken immediately.")
pysmi_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eInitiateAction", 1), ("eRetry", 2), ("eRetryAndCheck", 3), ("eUseLoadedMedia", 4), ("eEjectAndWait", 5), ("eSelectMediaSize", 6)))).setLabel("continue").setMaxAccess("writeonly")
if mibBuilder.loadTexts: pysmi_continue.setStatus('optional')
if mibBuilder.loadTexts: pysmi_continue.setDescription("A device can support a class of errors called continuable errors. When a continuable error is encountered, the device requires a continue event to occur before the device will continue operation. One continue event is setting the CONTINUE object to eInitiateAction. Devices can support other continue events, like auto-continue. A continue event causes the continuable error to be acknowledged, thus allowing the device to continue. Each device needs to list the continuable errors. If the device doesn't currently have an unacknowledged continuable error, the response will contain <genErr>. Additional information: See the CLEARABLE-WARNING and AUTO-CONTINUE objects for the errors that this object will clear.")
auto_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("auto-continue").setMaxAccess("readwrite")
if mibBuilder.loadTexts: auto_continue.setStatus('optional')
if mibBuilder.loadTexts: auto_continue.setDescription('Indicates if the device will automatically continue after encountering a continuable error. If AUTO-CONTINUE is set to eOn, the device will automatically generate continue event to acknowledge continuable errors. If AUTO-CONTINUE is set to eOff, then some other continue event will have to acknowledge the continuable error. Additional information: If this is set to eOn the device displays an error message and goes offline for ten seconds. After ten seconds the printer automatically returns to the online state. If this is set to eOff then the device displays an error message and goes offline. It remains offline until the operator presses the GO key or until the CONTINUE object is set. If the printer is not idle, the new value may not take effect until a job boundary is reached. If a get is done on this object before the job boundary is reached, the value last set will be returned.')
cancel_job = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setLabel("cancel-job").setMaxAccess("writeonly")
if mibBuilder.loadTexts: cancel_job.setStatus('optional')
if mibBuilder.loadTexts: cancel_job.setDescription("Cancels the print job whose ID matches the value written to the CANCEL-JOB object. The host first learns the job ID using the CURRENT-JOB-PARSING-ID command. If the printer has completely processed the job, the printer responds with <badValue>. If the value of the CURRENT-JOB-PARSING-ID is smaller than the value written to the CANCEL-JOB object, then the printer responds with <badValue>. When read, returns the value of the last job ID what was canceled, or -1 to indicate no job has been canceled. Additional information: If the value written matches the ID of a job that is currently being canceled (for any reason), the printer responds with <noError>. It uses job ID's in the range of -1..32767. Because the ID number can wrap to zero, CURRENT-JOB-PARSING-ID may be smaller than the value written to this object; when this occurs, no error will result as long as the ID is for a currently processing job. This object is write only, so the comment in the general description stating the job ID will be returned on a read does not apply. A -1 represents the current job")
os_execute_file = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 19, 1), OctetString()).setLabel("os-execute-file").setMaxAccess("writeonly")
if mibBuilder.loadTexts: os_execute_file.setStatus('optional')
if mibBuilder.loadTexts: os_execute_file.setDescription("This object's input is a null-terminated string representing a fully-qualified path name for an executable file. This object causes the file to be executed by the OS. Additional information: This object's input is a null-terminated string of two or more whitespace-separated tokens. The first token is a path to a directory to make the current working directory. The second token is a path to an executable file to be executed. Any remaining whitespace-separated tokens are optional and will be passed as parameters to the executable. The paths to the directory and executable can be either PJL style (e.g., 1:\\app\\example) or UNIX-style (e.g., /hpmnt/dsk_ide1a/app/example). The executable is run in a separate process.")
form_feed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("form-feed").setMaxAccess("writeonly")
if mibBuilder.loadTexts: form_feed.setStatus('optional')
if mibBuilder.loadTexts: form_feed.setDescription('Instructs the PDL processing sub-system to finishing processing the current page of the current job. Form feed is also known as close page or eject page. If the PDL processing sub-system is in a FORM-FEED-NEEDED state, this causes the device to flush or finish processing the current page of the current job. If the device is not in the FORM-FEED-NEEDED state, an <genErr> will occur.')
form_feed_needed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("form-feed-needed").setMaxAccess("readonly")
if mibBuilder.loadTexts: form_feed_needed.setStatus('optional')
if mibBuilder.loadTexts: form_feed_needed.setDescription("Indicates if the PDL processing sub-system has made marks on the current page and the source subsystem has been idle for a device specific amount of time. Additional information: InkJet will set this object to eTrue when it has made marks on the current page, the IO-TIMEOUT has expired while PCL was running in `backward-compatibility mode' (which is caused by jobs consisting purely of PCL data with no prepended PJL commands), and no data is pending on another I/O. Once it is set to eTrue, more data on the same I/O will cause this object to be set to eFalse, until the above conditions are met again.")
background_status_msg_higher_priority = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setLabel("background-status-msg-higher-priority").setMaxAccess("readwrite")
if mibBuilder.loadTexts: background_status_msg_higher_priority.setStatus('optional')
if mibBuilder.loadTexts: background_status_msg_higher_priority.setDescription("The string displayed on the device's front panel in place of the printer's built-in background status string. It would alternate with warning messages and would overwrite highest Regular Priority Status message such as PAUSED. The object could be used to display higher priority third party messages which are important to be displayed even if printer is offline. This would not overwrite any HighStatus or Error type message. Additional information: This object allows a message to be displayed when it is the highest priority message. Setting this object does not guarantee the message will be displayed; and reading it returns the value last written, not the currently displayed message (use prtConsoleDisplayBufferText to read the display). The priority assigned for displaying this message is lower than the PAUSED message. In other words, this messages can replace all the regular priority status messages as EPOffline is the highest regular status priority. To clear the message, write a null string to BACKGROUND-STATUS-MSG-HIGHER-PRIORITY.")
background_status_msg_line1_part1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setLabel("background-status-msg-line1-part1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: background_status_msg_line1_part1.setStatus('optional')
if mibBuilder.loadTexts: background_status_msg_line1_part1.setDescription("The string displayed on the device's front panel in place of the printer's built-in background status string. An example built-in background status string is '00 READY'. Additional information: The display size for the Inkjet printers is 2 X 16. The value of this object and the current value of BACKGROUND-STATUS-MSG-LINE2-PART1 are displayed together on the 2-line display, but they must be set independently. If line 2 has been set, and the next message to be displayed only requires line 1, BACKGROUND-STATUS-MSG-LINE2-PART1 must be set to the null string to clear it. This object allows a message to be displayed when it is the highest priority message. Setting this object does not guarantee the message will be displayed; and reading it returns the value last written, not the currently displayed message (use prtConsoleDisplayBufferText to read the display). The priority assigned for displaying this message is one lower than the READY message. In other words, the only message that can be replaced by these objects is the READY message. To clear the message, write a null string to both this object and BACKGROUND-STATUS-MSG-LINE2-PART1.")
background_status_msg_line2_part1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setLabel("background-status-msg-line2-part1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: background_status_msg_line2_part1.setStatus('optional')
if mibBuilder.loadTexts: background_status_msg_line2_part1.setDescription("The string displayed on the device's front panel in place of the printer's built-in background status string. An example built-in background status string is '00 READY'. Additional information: See BACKGROUND-STATUS-MSG-LINE1-PART1")
error_log_clear = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eClearErrorLog", 1)))).setLabel("error-log-clear").setMaxAccess("writeonly")
if mibBuilder.loadTexts: error_log_clear.setStatus('optional')
if mibBuilder.loadTexts: error_log_clear.setDescription("Setting this object clears all the entries in the error log sub-tree. Additional information: Setting this object removes all errors that have been stored in the printer's non-volatile memory.")
clearable_warning = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("eOn", 2), ("eJob", 3)))).setLabel("clearable-warning").setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearable_warning.setStatus('optional')
if mibBuilder.loadTexts: clearable_warning.setDescription('Returns or controls how the device will track clearable warnings. A clearable warning indicates a transient event in the device. The device will continue after the transient event occurs. If CLEARABLE-WARNING is eOff, the device does not track clearable warnings. If CLEARABLE-WARNING is eOn, all clearable warnings will be tracked until cleared (acknowledged). If CLEARABLE-WARNING is eJob, a clearable warning generated due to an event that occurs because of the print job being processed will be automatically cleared when the device has finished processing the job. Example clearable warning events include the device altering resolution or page protection due to memory constraints. The POS will document what transient events are treated as clearable warnings. Additional information: If set to eOn, the warning is displayed until the GO key is pressed or the CONTINUE object is set. If set to eJob, the warning is displayed until the end of the job in which it was generated.')
error1_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 1), Integer32()).setLabel("error1-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error1_time_stamp.setDescription("Contains some sort of time stamp indicating when error 1 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: This item contains the engine page count when the error occurred. If there is currently no error entry for this object, a '0' will be returned. Note that '0' may also be returned when there is a valid error, but a current page count was unavailable. If ERROR1-CODE object also returns '0', then an error has not yet been logged for this object. See ERROR1-CODE for an explanation of the order used for storing errors.")
error1_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 2), Integer32()).setLabel("error1-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_code.setStatus('optional')
if mibBuilder.loadTexts: error1_code.setDescription("Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: Returns a device specific error code. If the error code returned is '0', then the printer has not yet logged an error for this object. When the maximum number of errors is reached (30 on InkJet printers), and a new error occurs, the error in ERROR1-CODE will be replaced by the one in ERROR2-CODE, and so on until the last error object will be given the value of the new error. The error number is returned in the upper 16 bits. If it is 68, 69, 79, or 80, then the sub code is returned in the lower 16 bits (eg. 68 001C, where the subcode is already a hexadecimal value). If the error number is any other number, then the 1st sub code (XX) will be in bits 15-8 and the 2nd sub code (YY) will be in bits 7-0 (eg. 55.04.02) where XX=04 and YY=02). See the Control Panel ERS for specific information about the meaning of each code. Example: If the error is 68 001A, then the value returned will be 4456474. To break it down: 4456474 = 0x0044001A The upper 16 bits: 0x0044 = 68 The lower 16 bits: 0x001A = 001A Which is the error: 68 001A Example: If the error is 55.04.241, then the error code will be 3605745. To break it down: 3605745 = 0x003704F1 The upper 16 bits: 0x0037 = 55 The upper byte of the lower 16 bits: 0x04 = 04 The lower byte of the lower 16 bits: 0xF1 = 241 Which is the error: 55.04.241")
error1_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 3), OctetString()).setLabel("error1-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_date_time.setStatus('optional')
if mibBuilder.loadTexts: error1_date_time.setDescription("This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: This item contains the date and the time when the error occurred. It returns the date and the time at which the error occured in hexadecimal. For instance, if date is 2004-Jul-13 and time is 03:15 am when the error was logged, then we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month 07 0d(hex) - corresponds to date 13 03(hex) - corresponds to hour- 03 0f(hex) - corresponds to min- 15. If there is currently no error entry , '00 00 00 00 00' will be returned. See ERROR1-CODE for an explanation of the order used for storing errors.")
error2_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 1), Integer32()).setLabel("error2-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error2_time_stamp.setDescription('Contains some sort of time stamp indicating when error 2 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error2_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 2), Integer32()).setLabel("error2-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_code.setStatus('optional')
if mibBuilder.loadTexts: error2_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error2_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 3), OctetString()).setLabel("error2-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_date_time.setStatus('optional')
if mibBuilder.loadTexts: error2_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error3_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 1), Integer32()).setLabel("error3-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error3_time_stamp.setDescription('Contains some sort of time stamp indicating when error 3 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error3_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 2), Integer32()).setLabel("error3-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_code.setStatus('optional')
if mibBuilder.loadTexts: error3_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error3_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 3), OctetString()).setLabel("error3-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_date_time.setStatus('optional')
if mibBuilder.loadTexts: error3_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error4_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 1), Integer32()).setLabel("error4-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error4_time_stamp.setDescription('Contains some sort of time stamp indicating when error 4 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error4_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 2), Integer32()).setLabel("error4-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_code.setStatus('optional')
if mibBuilder.loadTexts: error4_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error4_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 3), OctetString()).setLabel("error4-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_date_time.setStatus('optional')
if mibBuilder.loadTexts: error4_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error5_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 1), Integer32()).setLabel("error5-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error5_time_stamp.setDescription('Contains some sort of time stamp indicating when error 5 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error5_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 2), Integer32()).setLabel("error5-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_code.setStatus('optional')
if mibBuilder.loadTexts: error5_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error5_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 3), OctetString()).setLabel("error5-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_date_time.setStatus('optional')
if mibBuilder.loadTexts: error5_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error6_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 1), Integer32()).setLabel("error6-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error6_time_stamp.setDescription('Contains some sort of time stamp indicating when error 6 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error6_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 2), Integer32()).setLabel("error6-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_code.setStatus('optional')
if mibBuilder.loadTexts: error6_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error6_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 3), OctetString()).setLabel("error6-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_date_time.setStatus('optional')
if mibBuilder.loadTexts: error6_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error7_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 1), Integer32()).setLabel("error7-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error7_time_stamp.setDescription('Contains some sort of time stamp indicating when error 7 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error7_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 2), Integer32()).setLabel("error7-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_code.setStatus('optional')
if mibBuilder.loadTexts: error7_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error7_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 3), OctetString()).setLabel("error7-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_date_time.setStatus('optional')
if mibBuilder.loadTexts: error7_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error8_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 1), Integer32()).setLabel("error8-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error8_time_stamp.setDescription('Contains some sort of time stamp indicating when error 8 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error8_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 2), Integer32()).setLabel("error8-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_code.setStatus('optional')
if mibBuilder.loadTexts: error8_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error8_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 3), OctetString()).setLabel("error8-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_date_time.setStatus('optional')
if mibBuilder.loadTexts: error8_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error9_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 1), Integer32()).setLabel("error9-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error9_time_stamp.setDescription('Contains some sort of time stamp indicating when error 9 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error9_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 2), Integer32()).setLabel("error9-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_code.setStatus('optional')
if mibBuilder.loadTexts: error9_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error9_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 3), OctetString()).setLabel("error9-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_date_time.setStatus('optional')
if mibBuilder.loadTexts: error9_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error10_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 1), Integer32()).setLabel("error10-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error10_time_stamp.setDescription('Contains some sort of time stamp indicating when error 10 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error10_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 2), Integer32()).setLabel("error10-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_code.setStatus('optional')
if mibBuilder.loadTexts: error10_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error10_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 3), OctetString()).setLabel("error10-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_date_time.setStatus('optional')
if mibBuilder.loadTexts: error10_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error11_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11, 1), Integer32()).setLabel("error11-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error11_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error11_time_stamp.setDescription('Contains some sort of time stamp indicating when error 11 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error11_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11, 2), Integer32()).setLabel("error11-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error11_code.setStatus('optional')
if mibBuilder.loadTexts: error11_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error11_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11, 3), OctetString()).setLabel("error11-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error11_date_time.setStatus('optional')
if mibBuilder.loadTexts: error11_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error12_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12, 1), Integer32()).setLabel("error12-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error12_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error12_time_stamp.setDescription('Contains some sort of time stamp indicating when error 12 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error12_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12, 2), Integer32()).setLabel("error12-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error12_code.setStatus('optional')
if mibBuilder.loadTexts: error12_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error12_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12, 3), OctetString()).setLabel("error12-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error12_date_time.setStatus('optional')
if mibBuilder.loadTexts: error12_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error13_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13, 1), Integer32()).setLabel("error13-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error13_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error13_time_stamp.setDescription('Contains some sort of time stamp indicating when error 13 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error13_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13, 2), Integer32()).setLabel("error13-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error13_code.setStatus('optional')
if mibBuilder.loadTexts: error13_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error13_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13, 3), OctetString()).setLabel("error13-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error13_date_time.setStatus('optional')
if mibBuilder.loadTexts: error13_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error14_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14, 1), Integer32()).setLabel("error14-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error14_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error14_time_stamp.setDescription('Contains some sort of time stamp indicating when error 14 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error14_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14, 2), Integer32()).setLabel("error14-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error14_code.setStatus('optional')
if mibBuilder.loadTexts: error14_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error14_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14, 3), OctetString()).setLabel("error14-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error14_date_time.setStatus('optional')
if mibBuilder.loadTexts: error14_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error15_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15, 1), Integer32()).setLabel("error15-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error15_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error15_time_stamp.setDescription('Contains some sort of time stamp indicating when error 15 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error15_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15, 2), Integer32()).setLabel("error15-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error15_code.setStatus('optional')
if mibBuilder.loadTexts: error15_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error15_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15, 3), OctetString()).setLabel("error15-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error15_date_time.setStatus('optional')
if mibBuilder.loadTexts: error15_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error16_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16, 1), Integer32()).setLabel("error16-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error16_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error16_time_stamp.setDescription('Contains some sort of time stamp indicating when error 16 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error16_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16, 2), Integer32()).setLabel("error16-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error16_code.setStatus('optional')
if mibBuilder.loadTexts: error16_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error16_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16, 3), OctetString()).setLabel("error16-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error16_date_time.setStatus('optional')
if mibBuilder.loadTexts: error16_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error17_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17, 1), Integer32()).setLabel("error17-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error17_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error17_time_stamp.setDescription('Contains some sort of time stamp indicating when error 17 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error17_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17, 2), Integer32()).setLabel("error17-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error17_code.setStatus('optional')
if mibBuilder.loadTexts: error17_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error17_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17, 3), OctetString()).setLabel("error17-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error17_date_time.setStatus('optional')
if mibBuilder.loadTexts: error17_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error18_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18, 1), Integer32()).setLabel("error18-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error18_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error18_time_stamp.setDescription('Contains some sort of time stamp indicating when error 18 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error18_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18, 2), Integer32()).setLabel("error18-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error18_code.setStatus('optional')
if mibBuilder.loadTexts: error18_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error18_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18, 3), OctetString()).setLabel("error18-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error18_date_time.setStatus('optional')
if mibBuilder.loadTexts: error18_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error19_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19, 1), Integer32()).setLabel("error19-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error19_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error19_time_stamp.setDescription('Contains some sort of time stamp indicating when error 19 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error19_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19, 2), Integer32()).setLabel("error19-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error19_code.setStatus('optional')
if mibBuilder.loadTexts: error19_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error19_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19, 3), OctetString()).setLabel("error19-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error19_date_time.setStatus('optional')
if mibBuilder.loadTexts: error19_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error20_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20, 1), Integer32()).setLabel("error20-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error20_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error20_time_stamp.setDescription('Contains some sort of time stamp indicating when error 20 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error20_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20, 2), Integer32()).setLabel("error20-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error20_code.setStatus('optional')
if mibBuilder.loadTexts: error20_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error20_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20, 3), OctetString()).setLabel("error20-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error20_date_time.setStatus('optional')
if mibBuilder.loadTexts: error20_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error21_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21, 1), Integer32()).setLabel("error21-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error21_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error21_time_stamp.setDescription('Contains some sort of time stamp indicating when error 21 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error21_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21, 2), Integer32()).setLabel("error21-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error21_code.setStatus('optional')
if mibBuilder.loadTexts: error21_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error21_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21, 3), OctetString()).setLabel("error21-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error21_date_time.setStatus('optional')
if mibBuilder.loadTexts: error21_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error22_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22, 1), Integer32()).setLabel("error22-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error22_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error22_time_stamp.setDescription('Contains some sort of time stamp indicating when error 22 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error22_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22, 2), Integer32()).setLabel("error22-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error22_code.setStatus('optional')
if mibBuilder.loadTexts: error22_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error22_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22, 3), OctetString()).setLabel("error22-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error22_date_time.setStatus('optional')
if mibBuilder.loadTexts: error22_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error23_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23, 1), Integer32()).setLabel("error23-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error23_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error23_time_stamp.setDescription('Contains some sort of time stamp indicating when error 23 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error23_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23, 2), Integer32()).setLabel("error23-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error23_code.setStatus('optional')
if mibBuilder.loadTexts: error23_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error23_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23, 3), OctetString()).setLabel("error23-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error23_date_time.setStatus('optional')
if mibBuilder.loadTexts: error23_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error24_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24, 1), Integer32()).setLabel("error24-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error24_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error24_time_stamp.setDescription('Contains some sort of time stamp indicating when error 24 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error24_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24, 2), Integer32()).setLabel("error24-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error24_code.setStatus('optional')
if mibBuilder.loadTexts: error24_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error24_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24, 3), OctetString()).setLabel("error24-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error24_date_time.setStatus('optional')
if mibBuilder.loadTexts: error24_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error25_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25, 1), Integer32()).setLabel("error25-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error25_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error25_time_stamp.setDescription('Contains some sort of time stamp indicating when error 25 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error25_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25, 2), Integer32()).setLabel("error25-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error25_code.setStatus('optional')
if mibBuilder.loadTexts: error25_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error25_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25, 3), OctetString()).setLabel("error25-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error25_date_time.setStatus('optional')
if mibBuilder.loadTexts: error25_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error26_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26, 1), Integer32()).setLabel("error26-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error26_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error26_time_stamp.setDescription('Contains some sort of time stamp indicating when error 26 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error26_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26, 2), Integer32()).setLabel("error26-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error26_code.setStatus('optional')
if mibBuilder.loadTexts: error26_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error26_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26, 3), OctetString()).setLabel("error26-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error26_date_time.setStatus('optional')
if mibBuilder.loadTexts: error26_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error27_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27, 1), Integer32()).setLabel("error27-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error27_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error27_time_stamp.setDescription('Contains some sort of time stamp indicating when error 27 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error27_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27, 2), Integer32()).setLabel("error27-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error27_code.setStatus('optional')
if mibBuilder.loadTexts: error27_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error27_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27, 3), OctetString()).setLabel("error27-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error27_date_time.setStatus('optional')
if mibBuilder.loadTexts: error27_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error28_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28, 1), Integer32()).setLabel("error28-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error28_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error28_time_stamp.setDescription('Contains some sort of time stamp indicating when error 28 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error28_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28, 2), Integer32()).setLabel("error28-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error28_code.setStatus('optional')
if mibBuilder.loadTexts: error28_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error28_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28, 3), OctetString()).setLabel("error28-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error28_date_time.setStatus('optional')
if mibBuilder.loadTexts: error28_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error29_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29, 1), Integer32()).setLabel("error29-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error29_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error29_time_stamp.setDescription('Contains some sort of time stamp indicating when error 29 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error29_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29, 2), Integer32()).setLabel("error29-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error29_code.setStatus('optional')
if mibBuilder.loadTexts: error29_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error29_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29, 3), OctetString()).setLabel("error29-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error29_date_time.setStatus('optional')
if mibBuilder.loadTexts: error29_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error30_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30, 1), Integer32()).setLabel("error30-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error30_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error30_time_stamp.setDescription('Contains some sort of time stamp indicating when error 30 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error30_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30, 2), Integer32()).setLabel("error30-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error30_code.setStatus('optional')
if mibBuilder.loadTexts: error30_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error30_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30, 3), OctetString()).setLabel("error30-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error30_date_time.setStatus('optional')
if mibBuilder.loadTexts: error30_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error31_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31, 1), Integer32()).setLabel("error31-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error31_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error31_time_stamp.setDescription('Contains some sort of time stamp indicating when error 31 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error31_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31, 2), Integer32()).setLabel("error31-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error31_code.setStatus('optional')
if mibBuilder.loadTexts: error31_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error31_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31, 3), OctetString()).setLabel("error31-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error31_date_time.setStatus('optional')
if mibBuilder.loadTexts: error31_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error32_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32, 1), Integer32()).setLabel("error32-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error32_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error32_time_stamp.setDescription('Contains some sort of time stamp indicating when error 32 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error32_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32, 2), Integer32()).setLabel("error32-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error32_code.setStatus('optional')
if mibBuilder.loadTexts: error32_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error32_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32, 3), OctetString()).setLabel("error32-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error32_date_time.setStatus('optional')
if mibBuilder.loadTexts: error32_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error33_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33, 1), Integer32()).setLabel("error33-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error33_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error33_time_stamp.setDescription('Contains some sort of time stamp indicating when error 33 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error33_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33, 2), Integer32()).setLabel("error33-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error33_code.setStatus('optional')
if mibBuilder.loadTexts: error33_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error33_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33, 3), OctetString()).setLabel("error33-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error33_date_time.setStatus('optional')
if mibBuilder.loadTexts: error33_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error34_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34, 1), Integer32()).setLabel("error34-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error34_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error34_time_stamp.setDescription('Contains some sort of time stamp indicating when error 34 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error34_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34, 2), Integer32()).setLabel("error34-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error34_code.setStatus('optional')
if mibBuilder.loadTexts: error34_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error34_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34, 3), OctetString()).setLabel("error34-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error34_date_time.setStatus('optional')
if mibBuilder.loadTexts: error34_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error35_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35, 1), Integer32()).setLabel("error35-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error35_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error35_time_stamp.setDescription('Contains some sort of time stamp indicating when error 35 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error35_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35, 2), Integer32()).setLabel("error35-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error35_code.setStatus('optional')
if mibBuilder.loadTexts: error35_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error35_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35, 3), OctetString()).setLabel("error35-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error35_date_time.setStatus('optional')
if mibBuilder.loadTexts: error35_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error36_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36, 1), Integer32()).setLabel("error36-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error36_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error36_time_stamp.setDescription('Contains some sort of time stamp indicating when error 36 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error36_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36, 2), Integer32()).setLabel("error36-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error36_code.setStatus('optional')
if mibBuilder.loadTexts: error36_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error36_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36, 3), OctetString()).setLabel("error36-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error36_date_time.setStatus('optional')
if mibBuilder.loadTexts: error36_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error37_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37, 1), Integer32()).setLabel("error37-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error37_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error37_time_stamp.setDescription('Contains some sort of time stamp indicating when error 37 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error37_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37, 2), Integer32()).setLabel("error37-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error37_code.setStatus('optional')
if mibBuilder.loadTexts: error37_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error37_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37, 3), OctetString()).setLabel("error37-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error37_date_time.setStatus('optional')
if mibBuilder.loadTexts: error37_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error38_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38, 1), Integer32()).setLabel("error38-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error38_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error38_time_stamp.setDescription('Contains some sort of time stamp indicating when error 38 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error38_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38, 2), Integer32()).setLabel("error38-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error38_code.setStatus('optional')
if mibBuilder.loadTexts: error38_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error38_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38, 3), OctetString()).setLabel("error38-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error38_date_time.setStatus('optional')
if mibBuilder.loadTexts: error38_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error39_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39, 1), Integer32()).setLabel("error39-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error39_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error39_time_stamp.setDescription('Contains some sort of time stamp indicating when error 39 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error39_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39, 2), Integer32()).setLabel("error39-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error39_code.setStatus('optional')
if mibBuilder.loadTexts: error39_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error39_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39, 3), OctetString()).setLabel("error39-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error39_date_time.setStatus('optional')
if mibBuilder.loadTexts: error39_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error40_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40, 1), Integer32()).setLabel("error40-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error40_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error40_time_stamp.setDescription('Contains some sort of time stamp indicating when error 40 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error40_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40, 2), Integer32()).setLabel("error40-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error40_code.setStatus('optional')
if mibBuilder.loadTexts: error40_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error40_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40, 3), OctetString()).setLabel("error40-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error40_date_time.setStatus('optional')
if mibBuilder.loadTexts: error40_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error41_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41, 1), Integer32()).setLabel("error41-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error41_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error41_time_stamp.setDescription('Contains some sort of time stamp indicating when error 41 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error41_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41, 2), Integer32()).setLabel("error41-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error41_code.setStatus('optional')
if mibBuilder.loadTexts: error41_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error41_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41, 3), OctetString()).setLabel("error41-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error41_date_time.setStatus('optional')
if mibBuilder.loadTexts: error41_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error42_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42, 1), Integer32()).setLabel("error42-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error42_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error42_time_stamp.setDescription('Contains some sort of time stamp indicating when error 42 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error42_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42, 2), Integer32()).setLabel("error42-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error42_code.setStatus('optional')
if mibBuilder.loadTexts: error42_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error42_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42, 3), OctetString()).setLabel("error42-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error42_date_time.setStatus('optional')
if mibBuilder.loadTexts: error42_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error43_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43, 1), Integer32()).setLabel("error43-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error43_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error43_time_stamp.setDescription('Contains some sort of time stamp indicating when error 43 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error43_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43, 2), Integer32()).setLabel("error43-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error43_code.setStatus('optional')
if mibBuilder.loadTexts: error43_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error43_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43, 3), OctetString()).setLabel("error43-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error43_date_time.setStatus('optional')
if mibBuilder.loadTexts: error43_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error44_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44, 1), Integer32()).setLabel("error44-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error44_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error44_time_stamp.setDescription('Contains some sort of time stamp indicating when error 44 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error44_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44, 2), Integer32()).setLabel("error44-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error44_code.setStatus('optional')
if mibBuilder.loadTexts: error44_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error44_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44, 3), OctetString()).setLabel("error44-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error44_date_time.setStatus('optional')
if mibBuilder.loadTexts: error44_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error45_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45, 1), Integer32()).setLabel("error45-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error45_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error45_time_stamp.setDescription('Contains some sort of time stamp indicating when error 45 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error45_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45, 2), Integer32()).setLabel("error45-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error45_code.setStatus('optional')
if mibBuilder.loadTexts: error45_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error45_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45, 3), OctetString()).setLabel("error45-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error45_date_time.setStatus('optional')
if mibBuilder.loadTexts: error45_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error46_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46, 1), Integer32()).setLabel("error46-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error46_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error46_time_stamp.setDescription('Contains some sort of time stamp indicating when error 46 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error46_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46, 2), Integer32()).setLabel("error46-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error46_code.setStatus('optional')
if mibBuilder.loadTexts: error46_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error46_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46, 3), OctetString()).setLabel("error46-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error46_date_time.setStatus('optional')
if mibBuilder.loadTexts: error46_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error47_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47, 1), Integer32()).setLabel("error47-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error47_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error47_time_stamp.setDescription('Contains some sort of time stamp indicating when error 47 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error47_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47, 2), Integer32()).setLabel("error47-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error47_code.setStatus('optional')
if mibBuilder.loadTexts: error47_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error47_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47, 3), OctetString()).setLabel("error47-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error47_date_time.setStatus('optional')
if mibBuilder.loadTexts: error47_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error48_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48, 1), Integer32()).setLabel("error48-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error48_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error48_time_stamp.setDescription('Contains some sort of time stamp indicating when error 48 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error48_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48, 2), Integer32()).setLabel("error48-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error48_code.setStatus('optional')
if mibBuilder.loadTexts: error48_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error48_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48, 3), OctetString()).setLabel("error48-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error48_date_time.setStatus('optional')
if mibBuilder.loadTexts: error48_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error49_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49, 1), Integer32()).setLabel("error49-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error49_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error49_time_stamp.setDescription('Contains some sort of time stamp indicating when error 49 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error49_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49, 2), Integer32()).setLabel("error49-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error49_code.setStatus('optional')
if mibBuilder.loadTexts: error49_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error49_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49, 3), OctetString()).setLabel("error49-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error49_date_time.setStatus('optional')
if mibBuilder.loadTexts: error49_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
error50_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50, 1), Integer32()).setLabel("error50-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error50_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error50_time_stamp.setDescription('Contains some sort of time stamp indicating when error 50 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error50_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50, 2), Integer32()).setLabel("error50-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error50_code.setStatus('optional')
if mibBuilder.loadTexts: error50_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error50_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50, 3), OctetString()).setLabel("error50-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: error50_date_time.setStatus('optional')
if mibBuilder.loadTexts: error50_date_time.setDescription('This item contains the date and the time at which an error occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See ERROR1-DATE-TIME.')
warning1_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 1, 1), Integer32()).setLabel("warning1-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning1_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning1_time_stamp.setDescription("Contains some sort of time stamp indicating when warning 1 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: This item contains the engine page count when the WARNING occurred. If there is currently no WARNING entry for this object, a '0' will be returned. Note that '0' may also be returned when there is a valid WARNING, but a current page count was unavailable. If WARNING1-CODE object also returns '0', then an WARNING has not yet been logged for this object. See WARNING1-CODE for an explanation of the order used for storing WARNINGs.")
warning1_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 1, 2), Integer32()).setLabel("warning1-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning1_code.setStatus('optional')
if mibBuilder.loadTexts: warning1_code.setDescription("Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: Returns a device specific WARNING code. If the WARNING code returned is '0', then the printer has not yet logged an WARNING for this object. When the maximum number of WARNINGs is reached (30 on InkJet printers), and a new WARNING occurs, the WARNING in WARNING1-CODE will be replaced by the one in WARNING2-CODE, and so on until the last WARNING object will be given the value of the new WARNING. The WARNING number is returned in the upper 16 bits. If it is 68, 69, 79, or 80, then the sub code is returned in the lower 16 bits (eg. 68 001C, where the subcode is already a hexadecimal value). If the WARNING number is any other number, then the 1st sub code (XX) will be in bits 15-8 and the 2nd sub code (YY) will be in bits 7-0 (eg. 55.04.02) where XX=04 and YY=02). See the Control Panel ERS for specific information about the meaning of each code. Example: If the WARNING is 68 001A, then the value returned will be 4456474. To break it down: 4456474 = 0x0044001A The upper 16 bits: 0x0044 = 68 The lower 16 bits: 0x001A = 001A Which is the WARNING: 68 001A Example: If the WARNING is 55.04.241, then the WARNING code will be 3605745. To break it down: 3605745 = 0x003704F1 The upper 16 bits: 0x0037 = 55 The upper byte of the lower 16 bits: 0x04 = 04 The lower byte of the lower 16 bits: 0xF1 = 241 Which is the WARNING: 55.04.241")
warning1_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 1, 3), OctetString()).setLabel("warning1-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning1_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning1_date_time.setDescription("This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: This item contains the date and the time when the WARNING occurred. It returns the date and the time at which the WARNING occured in hexadecimal. For instance, if date is 2004-Jul-13 and time is 03:15 am when the WARNING was logged, then we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month 07 0d(hex) - corresponds to date 13 03(hex) - corresponds to hour- 03 0f(hex) - corresponds to min- 15. If there is currently no WARNING entry , '00 00 00 00 00' will be returned. See WARNING1-CODE for an explanation of the order used for storing WARNINGs.")
warning2_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 2, 1), Integer32()).setLabel("warning2-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning2_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning2_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 2 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning2_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 2, 2), Integer32()).setLabel("warning2-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning2_code.setStatus('optional')
if mibBuilder.loadTexts: warning2_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning2_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 2, 3), OctetString()).setLabel("warning2-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning2_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning2_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning3_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 3, 1), Integer32()).setLabel("warning3-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning3_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning3_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 3 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning3_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 3, 2), Integer32()).setLabel("warning3-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning3_code.setStatus('optional')
if mibBuilder.loadTexts: warning3_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning3_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 3, 3), OctetString()).setLabel("warning3-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning3_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning3_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning4_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 4, 1), Integer32()).setLabel("warning4-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning4_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning4_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 4 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning4_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 4, 2), Integer32()).setLabel("warning4-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning4_code.setStatus('optional')
if mibBuilder.loadTexts: warning4_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning4_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 4, 3), OctetString()).setLabel("warning4-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning4_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning4_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning5_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 5, 1), Integer32()).setLabel("warning5-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning5_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning5_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 5 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning5_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 5, 2), Integer32()).setLabel("warning5-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning5_code.setStatus('optional')
if mibBuilder.loadTexts: warning5_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning5_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 5, 3), OctetString()).setLabel("warning5-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning5_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning5_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning6_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 6, 1), Integer32()).setLabel("warning6-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning6_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning6_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 6 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning6_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 6, 2), Integer32()).setLabel("warning6-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning6_code.setStatus('optional')
if mibBuilder.loadTexts: warning6_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning6_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 6, 3), OctetString()).setLabel("warning6-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning6_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning6_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning7_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 7, 1), Integer32()).setLabel("warning7-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning7_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning7_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 7 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning7_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 7, 2), Integer32()).setLabel("warning7-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning7_code.setStatus('optional')
if mibBuilder.loadTexts: warning7_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning7_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 7, 3), OctetString()).setLabel("warning7-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning7_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning7_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning8_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 8, 1), Integer32()).setLabel("warning8-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning8_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning8_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 8 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning8_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 8, 2), Integer32()).setLabel("warning8-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning8_code.setStatus('optional')
if mibBuilder.loadTexts: warning8_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning8_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 8, 3), OctetString()).setLabel("warning8-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning8_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning8_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning9_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 9, 1), Integer32()).setLabel("warning9-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning9_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning9_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 9 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning9_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 9, 2), Integer32()).setLabel("warning9-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning9_code.setStatus('optional')
if mibBuilder.loadTexts: warning9_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning9_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 9, 3), OctetString()).setLabel("warning9-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning9_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning9_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning10_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 10, 1), Integer32()).setLabel("warning10-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning10_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning10_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 10 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning10_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 10, 2), Integer32()).setLabel("warning10-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning10_code.setStatus('optional')
if mibBuilder.loadTexts: warning10_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning10_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 10, 3), OctetString()).setLabel("warning10-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning10_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning10_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning11_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 11, 1), Integer32()).setLabel("warning11-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning11_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning11_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 11 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning11_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 11, 2), Integer32()).setLabel("warning11-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning11_code.setStatus('optional')
if mibBuilder.loadTexts: warning11_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning11_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 11, 3), OctetString()).setLabel("warning11-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning11_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning11_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning12_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 12, 1), Integer32()).setLabel("warning12-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning12_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning12_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 12 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning12_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 12, 2), Integer32()).setLabel("warning12-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning12_code.setStatus('optional')
if mibBuilder.loadTexts: warning12_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning12_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 12, 3), OctetString()).setLabel("warning12-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning12_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning12_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning13_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 13, 1), Integer32()).setLabel("warning13-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning13_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning13_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 13 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning13_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 13, 2), Integer32()).setLabel("warning13-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning13_code.setStatus('optional')
if mibBuilder.loadTexts: warning13_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning13_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 13, 3), OctetString()).setLabel("warning13-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning13_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning13_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning14_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 14, 1), Integer32()).setLabel("warning14-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning14_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning14_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 14 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning14_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 14, 2), Integer32()).setLabel("warning14-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning14_code.setStatus('optional')
if mibBuilder.loadTexts: warning14_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning14_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 14, 3), OctetString()).setLabel("warning14-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning14_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning14_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning15_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 15, 1), Integer32()).setLabel("warning15-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning15_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning15_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 15 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning15_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 15, 2), Integer32()).setLabel("warning15-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning15_code.setStatus('optional')
if mibBuilder.loadTexts: warning15_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning15_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 15, 3), OctetString()).setLabel("warning15-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning15_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning15_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning16_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 16, 1), Integer32()).setLabel("warning16-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning16_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning16_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 16 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning16_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 16, 2), Integer32()).setLabel("warning16-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning16_code.setStatus('optional')
if mibBuilder.loadTexts: warning16_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning16_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 16, 3), OctetString()).setLabel("warning16-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning16_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning16_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning17_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 17, 1), Integer32()).setLabel("warning17-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning17_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning17_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 17 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning17_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 17, 2), Integer32()).setLabel("warning17-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning17_code.setStatus('optional')
if mibBuilder.loadTexts: warning17_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning17_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 17, 3), OctetString()).setLabel("warning17-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning17_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning17_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning18_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 18, 1), Integer32()).setLabel("warning18-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning18_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning18_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 18 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning18_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 18, 2), Integer32()).setLabel("warning18-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning18_code.setStatus('optional')
if mibBuilder.loadTexts: warning18_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning18_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 18, 3), OctetString()).setLabel("warning18-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning18_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning18_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning19_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 19, 1), Integer32()).setLabel("warning19-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning19_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning19_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 19 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning19_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 19, 2), Integer32()).setLabel("warning19-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning19_code.setStatus('optional')
if mibBuilder.loadTexts: warning19_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning19_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 19, 3), OctetString()).setLabel("warning19-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning19_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning19_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning20_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 20, 1), Integer32()).setLabel("warning20-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning20_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning20_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 20 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning20_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 20, 2), Integer32()).setLabel("warning20-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning20_code.setStatus('optional')
if mibBuilder.loadTexts: warning20_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning20_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 20, 3), OctetString()).setLabel("warning20-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning20_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning20_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning21_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 21, 1), Integer32()).setLabel("warning21-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning21_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning21_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 21 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning21_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 21, 2), Integer32()).setLabel("warning21-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning21_code.setStatus('optional')
if mibBuilder.loadTexts: warning21_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning21_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 21, 3), OctetString()).setLabel("warning21-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning21_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning21_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning22_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 22, 1), Integer32()).setLabel("warning22-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning22_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning22_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 22 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning22_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 22, 2), Integer32()).setLabel("warning22-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning22_code.setStatus('optional')
if mibBuilder.loadTexts: warning22_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning22_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 22, 3), OctetString()).setLabel("warning22-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning22_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning22_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning23_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 23, 1), Integer32()).setLabel("warning23-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning23_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning23_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 23 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning23_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 23, 2), Integer32()).setLabel("warning23-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning23_code.setStatus('optional')
if mibBuilder.loadTexts: warning23_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning23_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 23, 3), OctetString()).setLabel("warning23-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning23_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning23_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning24_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 24, 1), Integer32()).setLabel("warning24-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning24_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning24_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 24 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning24_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 24, 2), Integer32()).setLabel("warning24-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning24_code.setStatus('optional')
if mibBuilder.loadTexts: warning24_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning24_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 24, 3), OctetString()).setLabel("warning24-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning24_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning24_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning25_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 25, 1), Integer32()).setLabel("warning25-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning25_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning25_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 25 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning25_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 25, 2), Integer32()).setLabel("warning25-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning25_code.setStatus('optional')
if mibBuilder.loadTexts: warning25_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning25_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 25, 3), OctetString()).setLabel("warning25-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning25_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning25_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning26_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 26, 1), Integer32()).setLabel("warning26-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning26_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning26_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 26 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning26_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 26, 2), Integer32()).setLabel("warning26-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning26_code.setStatus('optional')
if mibBuilder.loadTexts: warning26_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning26_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 26, 3), OctetString()).setLabel("warning26-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning26_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning26_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning27_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 27, 1), Integer32()).setLabel("warning27-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning27_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning27_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 27 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning27_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 27, 2), Integer32()).setLabel("warning27-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning27_code.setStatus('optional')
if mibBuilder.loadTexts: warning27_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning27_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 27, 3), OctetString()).setLabel("warning27-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning27_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning27_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning28_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 28, 1), Integer32()).setLabel("warning28-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning28_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning28_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 28 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning28_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 28, 2), Integer32()).setLabel("warning28-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning28_code.setStatus('optional')
if mibBuilder.loadTexts: warning28_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning28_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 28, 3), OctetString()).setLabel("warning28-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning28_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning28_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning29_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 29, 1), Integer32()).setLabel("warning29-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning29_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning29_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 29 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning29_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 29, 2), Integer32()).setLabel("warning29-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning29_code.setStatus('optional')
if mibBuilder.loadTexts: warning29_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning29_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 29, 3), OctetString()).setLabel("warning29-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning29_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning29_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning30_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 30, 1), Integer32()).setLabel("warning30-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning30_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning30_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 30 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning30_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 30, 2), Integer32()).setLabel("warning30-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning30_code.setStatus('optional')
if mibBuilder.loadTexts: warning30_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning30_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 30, 3), OctetString()).setLabel("warning30-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning30_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning30_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning31_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 31, 1), Integer32()).setLabel("warning31-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning31_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning31_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 31 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning31_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 31, 2), Integer32()).setLabel("warning31-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning31_code.setStatus('optional')
if mibBuilder.loadTexts: warning31_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning31_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 31, 3), OctetString()).setLabel("warning31-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning31_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning31_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning32_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 32, 1), Integer32()).setLabel("warning32-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning32_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning32_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 32 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning32_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 32, 2), Integer32()).setLabel("warning32-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning32_code.setStatus('optional')
if mibBuilder.loadTexts: warning32_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning32_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 32, 3), OctetString()).setLabel("warning32-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning32_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning32_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning33_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 33, 1), Integer32()).setLabel("warning33-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning33_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning33_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 33 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning33_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 33, 2), Integer32()).setLabel("warning33-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning33_code.setStatus('optional')
if mibBuilder.loadTexts: warning33_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning33_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 33, 3), OctetString()).setLabel("warning33-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning33_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning33_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning34_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 34, 1), Integer32()).setLabel("warning34-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning34_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning34_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 34 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning34_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 34, 2), Integer32()).setLabel("warning34-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning34_code.setStatus('optional')
if mibBuilder.loadTexts: warning34_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning34_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 34, 3), OctetString()).setLabel("warning34-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning34_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning34_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning35_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 35, 1), Integer32()).setLabel("warning35-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning35_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning35_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 35 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning35_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 35, 2), Integer32()).setLabel("warning35-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning35_code.setStatus('optional')
if mibBuilder.loadTexts: warning35_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning35_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 35, 3), OctetString()).setLabel("warning35-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning35_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning35_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning36_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 36, 1), Integer32()).setLabel("warning36-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning36_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning36_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 36 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning36_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 36, 2), Integer32()).setLabel("warning36-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning36_code.setStatus('optional')
if mibBuilder.loadTexts: warning36_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning36_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 36, 3), OctetString()).setLabel("warning36-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning36_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning36_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning37_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 37, 1), Integer32()).setLabel("warning37-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning37_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning37_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 37 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning37_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 37, 2), Integer32()).setLabel("warning37-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning37_code.setStatus('optional')
if mibBuilder.loadTexts: warning37_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning37_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 37, 3), OctetString()).setLabel("warning37-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning37_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning37_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning38_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 38, 1), Integer32()).setLabel("warning38-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning38_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning38_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 38 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning38_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 38, 2), Integer32()).setLabel("warning38-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning38_code.setStatus('optional')
if mibBuilder.loadTexts: warning38_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning38_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 38, 3), OctetString()).setLabel("warning38-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning38_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning38_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning39_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 39, 1), Integer32()).setLabel("warning39-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning39_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning39_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 39 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning39_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 39, 2), Integer32()).setLabel("warning39-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning39_code.setStatus('optional')
if mibBuilder.loadTexts: warning39_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning39_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 39, 3), OctetString()).setLabel("warning39-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning39_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning39_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning40_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 40, 1), Integer32()).setLabel("warning40-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning40_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning40_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 40 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning40_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 40, 2), Integer32()).setLabel("warning40-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning40_code.setStatus('optional')
if mibBuilder.loadTexts: warning40_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning40_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 40, 3), OctetString()).setLabel("warning40-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning40_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning40_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning41_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 41, 1), Integer32()).setLabel("warning41-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning41_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning41_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 41 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning41_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 41, 2), Integer32()).setLabel("warning41-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning41_code.setStatus('optional')
if mibBuilder.loadTexts: warning41_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning41_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 41, 3), OctetString()).setLabel("warning41-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning41_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning41_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning42_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 42, 1), Integer32()).setLabel("warning42-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning42_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning42_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 42 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning42_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 42, 2), Integer32()).setLabel("warning42-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning42_code.setStatus('optional')
if mibBuilder.loadTexts: warning42_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning42_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 42, 3), OctetString()).setLabel("warning42-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning42_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning42_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning43_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 43, 1), Integer32()).setLabel("warning43-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning43_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning43_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 43 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning43_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 43, 2), Integer32()).setLabel("warning43-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning43_code.setStatus('optional')
if mibBuilder.loadTexts: warning43_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning43_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 43, 3), OctetString()).setLabel("warning43-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning43_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning43_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning44_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 44, 1), Integer32()).setLabel("warning44-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning44_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning44_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 44 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning44_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 44, 2), Integer32()).setLabel("warning44-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning44_code.setStatus('optional')
if mibBuilder.loadTexts: warning44_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning44_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 44, 3), OctetString()).setLabel("warning44-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning44_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning44_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning45_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 45, 1), Integer32()).setLabel("warning45-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning45_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning45_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 45 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning45_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 45, 2), Integer32()).setLabel("warning45-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning45_code.setStatus('optional')
if mibBuilder.loadTexts: warning45_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning45_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 45, 3), OctetString()).setLabel("warning45-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning45_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning45_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning46_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 46, 1), Integer32()).setLabel("warning46-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning46_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning46_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 46 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning46_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 46, 2), Integer32()).setLabel("warning46-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning46_code.setStatus('optional')
if mibBuilder.loadTexts: warning46_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning46_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 46, 3), OctetString()).setLabel("warning46-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning46_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning46_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning47_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 47, 1), Integer32()).setLabel("warning47-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning47_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning47_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 47 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning47_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 47, 2), Integer32()).setLabel("warning47-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning47_code.setStatus('optional')
if mibBuilder.loadTexts: warning47_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning47_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 47, 3), OctetString()).setLabel("warning47-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning47_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning47_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning48_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 48, 1), Integer32()).setLabel("warning48-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning48_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning48_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 48 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning48_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 48, 2), Integer32()).setLabel("warning48-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning48_code.setStatus('optional')
if mibBuilder.loadTexts: warning48_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning48_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 48, 3), OctetString()).setLabel("warning48-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning48_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning48_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning49_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 49, 1), Integer32()).setLabel("warning49-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning49_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning49_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 49 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning49_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 49, 2), Integer32()).setLabel("warning49-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning49_code.setStatus('optional')
if mibBuilder.loadTexts: warning49_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning49_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 49, 3), OctetString()).setLabel("warning49-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning49_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning49_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
warning50_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 50, 1), Integer32()).setLabel("warning50-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning50_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: warning50_time_stamp.setDescription('Contains some sort of time stamp indicating when warning 50 occurred. Example time stamps include the actual time the warning occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See WARNING1-TIME-STAMP.')
warning50_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 50, 2), Integer32()).setLabel("warning50-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning50_code.setStatus('optional')
if mibBuilder.loadTexts: warning50_code.setDescription('Contains a device specific warning code. Each device POS should list what warnings are logged to the warning log and the meaning of each supported warning code value. Additional information: See WARNING1-CODE.')
warning50_date_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 22, 50, 3), OctetString()).setLabel("warning50-date-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: warning50_date_time.setStatus('optional')
if mibBuilder.loadTexts: warning50_date_time.setDescription('This item contains the date and the time at which an warning occurred. The values returned will be in hexadecimal. If the date is 2004-Jul-13 and the time is 03:15 a.m., we get 04 07 0d 03 0f where, 04 (hex) - corresponds to the year 2004. 07 (hex) - corresponds to month, 07 0d (hex) - corresponds to date, 13 03 (hex) - corresponds to hour, 3 a.m. 0f (hex) - corresponds to min, 15. Additional information: See WARNING1-DATE-TIME.')
display_long_grain_optimization_warning = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDoNotDisplay", 1), ("eDisplay", 2)))).setLabel("display-long-grain-optimization-warning").setMaxAccess("readwrite")
if mibBuilder.loadTexts: display_long_grain_optimization_warning.setStatus('optional')
if mibBuilder.loadTexts: display_long_grain_optimization_warning.setDescription('Display or DoNotDisplay the warning message on control panel of long grain optimiation. Additional information: nothing beyond old description')
powersave_enable_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ePowerSaveOff", 1), ("ePowerSaveUseSleepDelay", 2), ("ePowerSaveUseSleepSchedule", 3), ("ePowerSaveMaximize", 4), ("ePowerSaveCustom", 5)))).setLabel("powersave-enable-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: powersave_enable_type.setStatus('optional')
if mibBuilder.loadTexts: powersave_enable_type.setDescription('ePowerSaveOff - printer stays awake all the time, can only sleep if sleep button is hit. ePowerSaveUseSleepDelay - use sleep delay the old way, sleep schedule is ignored . ePowerSaveUseSleepSchedule - sleep delay time is ignored, stay awake in wake period, sleep in 15 minutes in sleep period. ePowerSaveMaximize - set the sleep delay to 15 minutes, so wether in wake or sleep period it will sleep in 15 minutes. ePowerSaveCustom - set the sleep delay to 45 minutes, use sleep delay during wake period, sleep in 15 minutes in sleep period. Additional information: nothing beyond old description')
install_date = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setLabel("install-date").setMaxAccess("readwrite")
if mibBuilder.loadTexts: install_date.setStatus('optional')
if mibBuilder.loadTexts: install_date.setDescription("Identifies the date that the device was installed. The format of the string is 'YYYYMMDDHHmmZ'. Where: YYYY is the year. MM is the month (1-12). DD is the day (1-31). HH is the hour of the day (0-23). mm are the minutes (0-59). 'Z' designates Greenwich Mean Time; if 'Z' not specified, value is local time. Device POS must specify the conditions for setting this object. Additional information: Setting the <<hidden>> object will enable setting this object.")
timestamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: timestamp.setStatus('optional')
if mibBuilder.loadTexts: timestamp.setDescription("Sets the printer's current time in (UTC). The format of the string is 'YYYYMMDDHHMMSS'. Where YYYY is the year. MM is the month (1-12) DD is the day of the month (1-31) HH is the hour of the day (0-23) MM is the minutes (0-59) SS is the seconds (0-59) Device POS must specify the conditions for setting this object.")
service_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setLabel("service-id").setMaxAccess("readwrite")
if mibBuilder.loadTexts: service_id.setStatus('optional')
if mibBuilder.loadTexts: service_id.setDescription("A read of this object will return the current SERVICE ID value in the printer. The format is 'YYDDD' where: YY = calendar year - 1990 DDD = (calendar month - 1) * 30 + (calendar day of the month or 30, if > 30) A write of this object will only succeed if the MANUFACTURING-CONTROL PML object has been set with the correct <<hidden>>. If the write operation is not allowed, this object will return an <genErr> status. Additional information: Setting the <<hidden>> object will enable setting this object.")
show_address = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eAuto", 3)))).setLabel("show-address").setMaxAccess("readwrite")
if mibBuilder.loadTexts: show_address.setStatus('optional')
if mibBuilder.loadTexts: show_address.setDescription('If this object is set to eAuto, and the device has an IP address, the IP address of the device will be shown with the READY message. If this object is set to eOff, the IP address will not be shown.')
serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setLabel("serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: serial_number.setStatus('optional')
if mibBuilder.loadTexts: serial_number.setDescription('Identifies the serial number for the device. If the SERIAL-NUMBER object is set by the user, then setting the object does not need to be protected. If the SERIAL-NUMBER object is set at the factory, then the <<hidden>> object must be set correctly before the SERIAL-NUMBER object is writable. If this is a writable object, the POS should indicate the maximum supported string length. If possible, encode the serial number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: This value IS AFFECTED BY NVRAM resets, it is set to the default value of XXXXXXXXXX, when a NVRAM init is done.')
fw_rom_datecode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 5), OctetString()).setLabel("fw-rom-datecode").setMaxAccess("readonly")
if mibBuilder.loadTexts: fw_rom_datecode.setStatus('optional')
if mibBuilder.loadTexts: fw_rom_datecode.setDescription('Identifies the base system firmware date code. The date code will be encoded in the yyyymmdd format. There may be several versions of the base system firmware. The date code associated with the version of the base system firmware that is being used is reported. There may be other date code objects for other specific modules such as fonts, localization modules, etc.; these other datecode objects are device specific.')
fw_rom_revision = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 6), OctetString()).setLabel("fw-rom-revision").setMaxAccess("readonly")
if mibBuilder.loadTexts: fw_rom_revision.setStatus('optional')
if mibBuilder.loadTexts: fw_rom_revision.setDescription('This identifies the system code firmware ROM revision code. The format for a revision is major_revision.minor_revision. There may be other ROM revision code objects for other specific ROMs such as font ROMs, localization ROMs, etc; these other ROM revision code objects are device specific.')
device_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setLabel("device-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_name.setStatus('optional')
if mibBuilder.loadTexts: device_name.setDescription('User defined device name. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <OKNearestLegal ValueSubstituted>.Additional information: The maximum supported string length is 32 characters. If the user entered string is too long, the device will store the first 32 characters and will return the <noError> status.')
device_location = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 11), OctetString()).setLabel("device-location").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_location.setStatus('optional')
if mibBuilder.loadTexts: device_location.setDescription('User defined device location. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <OKNearestLegal ValueSubstituted>.Additional information: The maximum supported string length is 16 characters. If the user entered string is too long, the device will store the first 16 characters and will return the <noError> status.')
asset_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 12), OctetString()).setLabel("asset-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: asset_number.setStatus('optional')
if mibBuilder.loadTexts: asset_number.setDescription('User defined asset number. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <OKNearestLegal ValueSubstituted>.Additional information: The maximum supported string length is 8 characters. If the user entered string is too long, the device will store the first 8 characters and will return the <noError> status.')
ews_request_control_panel_supplies_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("ews-request-control-panel-supplies-status").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ews_request_control_panel_supplies_status.setStatus('optional')
if mibBuilder.loadTexts: ews_request_control_panel_supplies_status.setDescription('System variable EWS_REQUEST_CONTROL_PANEL_SUPPPLIES_STATUS requires a PML interface so that WJA can directly access it without needing EWS support for that. Additional information: If this object is set to eEnable, the Supplies Status messages will not be shown on the CP.')
supports_pjl_user_groups = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eTrue", 2)))).setLabel("supports-pjl-user-groups").setMaxAccess("readonly")
if mibBuilder.loadTexts: supports_pjl_user_groups.setStatus('optional')
if mibBuilder.loadTexts: supports_pjl_user_groups.setDescription('Returns eTrue if the device is able to process PJL user group variables. See the PJL Technical Reference for the proper syntax for setting these variables. Because there may be many user groups in some environments, this object allows a client application to optimize the print job by including user groups only when the device is able to process them. Additional information: This device will always return eTrue.')
default_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 4), Integer32()).setLabel("default-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_copies.setStatus('optional')
if mibBuilder.loadTexts: default_copies.setDescription('Returns or changes default copies. Default copies is the default values used by the PDL to control the number of copies of each page in the print job that are printed. The print job can override this value. The list of supported values should be documented in the device POS. Additional information: The supported values are 1 through 32000. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snaps are as follows: <1 snaps to 1 >999 snaps to 32000')
default_lines_per_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 11), Integer32()).setLabel("default-lines-per-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_lines_per_page.setStatus('optional')
if mibBuilder.loadTexts: default_lines_per_page.setDescription('Returns or changes the default number of lines per page. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return the <noError>. Additional information: The supported values in InkJet are 5 to 128. Setting to an unsupported value causes the the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: <5 snaps to 5 >128 snaps to 128')
default_vmi = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 12), Integer32()).setLabel("default-vmi").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vmi.setStatus('optional')
if mibBuilder.loadTexts: default_vmi.setDescription('Returns or changes the default vertical motion index. The unit of measure for VMI is centipoints per line. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>.')
default_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 15, 17, 19, 24, 25, 26, 27, 36, 37, 39, 44, 45, 46, 74, 75, 101, 120, 122, 32767))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eLedger", 11), ("eStatement", 15), ("eROC16K", 17), ("eROC8K", 19), ("eISOandJISA6", 24), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eISORA4", 36), ("eISOSRA4", 37), ("eISORA3", 39), ("eJISB6", 44), ("eJISB5", 45), ("eJISB4", 46), ("eIndexCard4x6", 74), ("eIndexCard5x8", 75), ("eCustom", 101), ("eTabloidExtra", 120), ("eIndexCard5x7", 122), ("eUnknownMediaSize", 32767)))).setLabel("default-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_size.setStatus('optional')
if mibBuilder.loadTexts: default_media_size.setDescription("This indicates the default media size. A write of an unsupported value causes an <ErrorInvalidOrUnsupported Value>. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. (for a full list of media size enums see the end of this file) ")
cold_reset_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("cold-reset-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: cold_reset_media_size.setStatus('optional')
if mibBuilder.loadTexts: cold_reset_media_size.setDescription('Returns or sets the media size that is used as the DEFAULT-MEDIA-SIZE when a cold reset occurs.')
reprint = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2), ("eAuto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reprint.setStatus('optional')
if mibBuilder.loadTexts: reprint.setDescription('Returns or changes the reprint (jam recovery) setting. If eOn, then the device will reprint pages jammed pages. If eOff, the device will not attempt to reprint jammed pages. If eAuto, a device dependent algorithm (which should be documented in the POS) will be used to determine if the page gets reprinted. This object controls all PDLs, unless a specific PDL supports its own reprint control mechanism. To date, only PostScript has a PDL reprint control mechanism.')
postscript_defer_media = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("postscript-defer-media").setMaxAccess("readwrite")
if mibBuilder.loadTexts: postscript_defer_media.setStatus('optional')
if mibBuilder.loadTexts: postscript_defer_media.setDescription('This object will be used to enable or disable the use of the Adobe Postscript Paper Handling Model in the printer firmware. By default it is enabled which means that PostScript will always defer the media selection to HP Paper Handling Model. Additional information: nothing beyond old description')
duplex_blank_pages = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDuplexBlankPagesAuto", 1), ("eDuplexBlankPagesYes", 2)))).setLabel("duplex-blank-pages").setMaxAccess("readwrite")
if mibBuilder.loadTexts: duplex_blank_pages.setStatus('optional')
if mibBuilder.loadTexts: duplex_blank_pages.setDescription("When the value of the system variable is set to eDuplexBlankPagesAuto, it means to Smart Duplex in any of the specified conditions. This selection is logically equivalent to 'NO, do not duplex blank pages if not duplexing them obtains a performance enhancement'. When the value of the system variable is set to eDuplexBlankPagesYes, it means to disable Smart Duplexing. Additional information: When the value of the system variable is set to eDuplexBlankPagesAuto, it means to Smart Duplex in any of the specified conditions. This selection is logically equivalent to 'NO, do not duplex blank pages if not duplexing them obtains a performance enhancement'. When the value of the system variable is set to eDuplexBlankPagesYes, it means to disable Smart Duplexing. This PML object setting is only valid when the job has not requested a source tray. If the source tray has not been requested and setting is YES, then we disable smart duplexing. If the source tray has not been requested and setting is AUTO, then we do smart duplexing in some cases")
total_engine_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 5), Integer32()).setLabel("total-engine-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: total_engine_page_count.setStatus('optional')
if mibBuilder.loadTexts: total_engine_page_count.setDescription('Total number of pages printed by the device. POS indicates if the total engine page count is kept in NVRAM, and the maximum supported value before the page count rolls over to zero. Additional information: nothing beyond old description')
tray_prompt = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDoNotDisplay", 1), ("eDisplay", 2)))).setLabel("tray-prompt").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray_prompt.setStatus('optional')
if mibBuilder.loadTexts: tray_prompt.setDescription("If this object is set to eDisplay, whenever a paper tray is opened, refilled, and closed in a printer, the end user is prompted with a message 'To change size or type press check' on the control panel. If this object is set to eDoNotDisplay, then the end user will not be prompted with this message whenever a paper tray is opened, refilled, and closed in a printer. Additional information: Whenever a paper tray is opened and closed, the user is provided with two options Display and Do Not Display, through the menu item Size/Type Prompt.On selecting Display he chooses to get prompted with the message to change the size or type of paper. Whereas he is not prompted with this message in case he chooses Do Not Display.")
print_quality_level = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eDraftPQ", 1), ("eNormal", 2), ("eBestPQ", 3)))).setLabel("print-quality-level").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_quality_level.setStatus('optional')
if mibBuilder.loadTexts: print_quality_level.setDescription('Returns or sets the print quality level. This value is used when print jobs do not indicate the desired print quality. Additional information: nothing beyond old description')
tray_disable_use_instead = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("tray-disable-use-instead").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray_disable_use_instead.setStatus('optional')
if mibBuilder.loadTexts: tray_disable_use_instead.setDescription("If this object is set to eEnabled, the paper mount message that is normally posted('To use another tray....') is turned off thereby disallowing the user to specify another tray from which paper can be taken for printing. However, on setting this object to eDisabled the paper mount message is posted allowing the user to specify another tray for paper feed. Additional information: The feature provides a menu item under TRAY BEHAVIOUR, i.e USE ANOTHER TRAY which has two options ENABLED and DISABLED. Whenever the menu item is set to ENABLED, it provides the user with the ability to select another tray from which paper could be provided for the job. However on selecting DISABLED forces the user to provide paper through the same tray, after the paper mount message is posted, in either cases.")
email_service_operational = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 111), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eNonOperational", 1), ("eOperational", 2)))).setLabel("email-service-operational").setMaxAccess("readonly")
if mibBuilder.loadTexts: email_service_operational.setStatus('optional')
if mibBuilder.loadTexts: email_service_operational.setDescription('To check if Email service is operational on the device. Email is operational if email feature is enabled on the device and the SMTP gateway is configured.')
web_proxy_config_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("eOff", 0), ("eOn", 1)))).setLabel("web-proxy-config-enable").setMaxAccess("readonly")
if mibBuilder.loadTexts: web_proxy_config_enable.setStatus('optional')
if mibBuilder.loadTexts: web_proxy_config_enable.setDescription("This object is a binary enumeration which the peripheral uses to inform the JetDirect card that the Jet-Direct card embedded web server should display the web proxy configuration settings. The Jet Direct card web server will display the if and only if this object is both implemented and set to eOn. A peripheral may implement this object in order to have another host, like a JetDirect card, include a reference to the peripheral's web content. The peripheral will read the proxy configuration using the XIP2 sysInfo Get methods.")
pcl_total_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 5), Integer32()).setLabel("pcl-total-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: pcl_total_page_count.setStatus('optional')
if mibBuilder.loadTexts: pcl_total_page_count.setDescription('Total number of PCL pages printed by the device. Additional information: In InkJet the PCL page count is kept in NVRAM, and the NVRAM value is updated at least every 10 pages. NOTE: The value returned by this object will be incremented every page but if power is lost between NVRAM updates, up to 9 pages of the page count may be lost. The page count counter will be reset to zero after 16,777,215 (2^24-1) pages. The page count is incremented when a sheet of media is pulled from an input tray. A duplex printed sheet will cause this counter to be incremented by two.')
pcl_default_font_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 11, 12, 13, 14))).clone(namedValues=NamedValues(("eInternal", 1), ("ePermanentSoft", 2), ("eRomSimm2", 11), ("eRomSimm3", 12), ("eRomSimm4", 13), ("eRomSimm5", 14)))).setLabel("pcl-default-font-source").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_source.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_source.setDescription('Returns or changes the value of the default font source variable in NVRAM.')
pcl_default_font_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setLabel("pcl-default-font-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_number.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_number.setDescription('Returns or changes the value of the default font number variable in NVRAM. Writing an unsupported value causes the printer to generate an <badValue>. Additional information: Valid numbers or 0 - 255, but only font numbers that are included in the PCL FONT LIST are selectable.')
postscript_total_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 5), Integer32()).setLabel("postscript-total-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: postscript_total_page_count.setStatus('optional')
if mibBuilder.loadTexts: postscript_total_page_count.setDescription('Total number of PostScript pages printed by the device. Additional information: This object is only supported if the PostScript option is installed. In InkJet the count is kept in NVRAM, and the NVRAM value is updated at least every 10 sheets. NOTE: The value returned by this object will be incremented every sheet but if power is lost between NVRAM updates up to 9 sheets of the count may be lost. The counter will be reset to zero after 16,777,215 (2^24-1) pages. ')
postscript_print_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("postscript-print-errors").setMaxAccess("readwrite")
if mibBuilder.loadTexts: postscript_print_errors.setStatus('optional')
if mibBuilder.loadTexts: postscript_print_errors.setDescription('Returns or changes the value of the print PostScript errors setting. If eOn, PostScript prints an error page showing the error encountered and the stack at the time of the error. Additional information: This object is only supported if the PostScript option is installed.')
pdf_version = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 15, 1), OctetString()).setLabel("pdf-version").setMaxAccess("readonly")
if mibBuilder.loadTexts: pdf_version.setStatus('optional')
if mibBuilder.loadTexts: pdf_version.setDescription('Contains version of PDF that is supported on the device.')
pdf_total_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 15, 2), Integer32()).setLabel("pdf-total-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: pdf_total_page_count.setStatus('optional')
if mibBuilder.loadTexts: pdf_total_page_count.setDescription('Total number of PDF pages printed by the device.')
pdf_enabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ePDFNotEnabled", 1), ("ePDFEnabled", 2)))).setLabel("pdf-enabled").setMaxAccess("readonly")
if mibBuilder.loadTexts: pdf_enabled.setStatus('optional')
if mibBuilder.loadTexts: pdf_enabled.setDescription('Used to tell whether the device supports PDF.')
pdf_print_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 15, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("pdf-print-errors").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pdf_print_errors.setStatus('optional')
if mibBuilder.loadTexts: pdf_print_errors.setDescription('Returns or changes the value of the print PDF errors setting. If eOn, PDF prints an error page showing the error encountered and the stack at the time of the error.')
pcfax_send_enabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("pcfax-send-enabled").setMaxAccess("readonly")
if mibBuilder.loadTexts: pcfax_send_enabled.setStatus('optional')
if mibBuilder.loadTexts: pcfax_send_enabled.setDescription('To check if PC Fax Send is enabled on the device. Also used by administrators to enable or disable PC Fax Send on the device')
pcfax_send_operational = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eNonOperational", 1), ("eOperational", 2)))).setLabel("pcfax-send-operational").setMaxAccess("readonly")
if mibBuilder.loadTexts: pcfax_send_operational.setStatus('optional')
if mibBuilder.loadTexts: pcfax_send_operational.setDescription('To check if a fax can be sent from a PC to the device. This checks if a Fax service is supported on the MFP and if the administrator has enabled PC Fax Send for the device. Additional return types may be supported later to indicate why PC Fax Send is not operational on the device')
fax_notification_available = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eNotAvailable", 1), ("eAvailable", 2)))).setLabel("fax-notification-available").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_notification_available.setStatus('optional')
if mibBuilder.loadTexts: fax_notification_available.setDescription('To check if the embedded Fax accessory or the Fax Service available on the device supports Notification for Faxes Sent')
fax_billing_code_enabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-billing-code-enabled").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_billing_code_enabled.setStatus('optional')
if mibBuilder.loadTexts: fax_billing_code_enabled.setDescription('To check if Billing Code is enabled on the device for Faxes sent')
fax_billing_code_minlength = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 17), Integer32()).setLabel("fax-billing-code-minlength").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_billing_code_minlength.setStatus('optional')
if mibBuilder.loadTexts: fax_billing_code_minlength.setDescription('The Minimum number of Billing Code digits that has to be specified for Faxes sent from the device. Range: 1 - 16')
fax_billing_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 18), OctetString()).setLabel("fax-billing-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_billing_code.setStatus('optional')
if mibBuilder.loadTexts: fax_billing_code.setDescription('The actual Billing Code applicable for Faxes sent from the device')
fih_extra_pulses_feature = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisable", 1), ("eEnable", 2)))).setLabel("fih-extra-pulses-feature").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fih_extra_pulses_feature.setStatus('optional')
if mibBuilder.loadTexts: fih_extra_pulses_feature.setDescription('This object allows one to get/set the setting of the FIH EXTRA PULSES FEATURE item. This either turns the feature on or off based on customer requirement.')
scanner_accessory_adf_sheet_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setLabel("scanner-accessory-adf-sheet-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_adf_sheet_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_adf_sheet_count.setDescription('Total number of sheets that have been fed through the Automatic Document Feed (ADF) accessory. Additional information: The Automatic Document Feed (ADF) count is incremented each time a sheet feeds through the ADF. The value will be updated at the end of every scan job. ')
scanner_accessory_flatbed_scan_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setLabel("scanner-accessory-flatbed-scan-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_flatbed_scan_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_flatbed_scan_count.setDescription('Total number of scans performed by a flatbed scanner accessory. Additional information: The count is only incremented when a sheet is scanned on the FLATBED. The return value of this object will reset to the lower multiple of 10 at a power cycle. The value will be updated at the end of every scan job. ')
scanner_accessory_adf_one_sided_sheet_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 59), Integer32()).setLabel("scanner-accessory-adf-one-sided-sheet-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_adf_one_sided_sheet_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_adf_one_sided_sheet_count.setDescription('This item is incremented by 1 for each sheet that is scanned through the ADF in 1-sided scan mode. Additional information: The value will be updated at the end of every scan job. ')
scanner_accessory_adf_two_sided_sheet_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 60), Integer32()).setLabel("scanner-accessory-adf-two-sided-sheet-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_adf_two_sided_sheet_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_adf_two_sided_sheet_count.setDescription('This item is incremented by 2 for each sheet that is scanned through the ADF in 2-sided scan mode. Additional information: The value will be updated at the end of every scan job. ')
scanner_accessory_copy_job_scan_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 61), Integer32()).setLabel("scanner-accessory-copy-job-scan-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_copy_job_scan_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_copy_job_scan_count.setDescription('This relates to the number of pages scanned for copying. This item is incremented by 2 for each sheet scanned through the ADF in 2-sided scan mode, and it is incremented by 1 for flatbed scans. Scanning for testing and calibration purposes are NOT TO BE INCLUDED in this count. Additional information: The value will be updated at the end of every scan job. ')
scanner_accessory_send_job_scan_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 62), Integer32()).setLabel("scanner-accessory-send-job-scan-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_accessory_send_job_scan_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_accessory_send_job_scan_count.setDescription('This relates to the number of pages scanned for fax/send. This item is incremented by 2 for each sheet scanned through the ADF in 2-sided scan mode, and it is incremented by 1 for flatbed scans. Scanning for testing and calibration purposes are NOT TO BE INCLUDED in this count. Additional information: The value will be updated at the end of every scan job. ')
scan_to_folder_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 89), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setLabel("scan-to-folder-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_to_folder_count.setStatus('optional')
if mibBuilder.loadTexts: scan_to_folder_count.setDescription('The number of scan-to-folder scan jobs. Additional information: The number of scan-to-folder scan jobs.')
fax_job_scan_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 90), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setLabel("fax-job-scan-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_job_scan_count.setStatus('optional')
if mibBuilder.loadTexts: fax_job_scan_count.setDescription('The number of fax scan jobs. Additional information: The number of fax scan jobs.')
fax_print_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 32), Integer32()).setLabel("fax-print-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_print_page_count.setStatus('optional')
if mibBuilder.loadTexts: fax_print_page_count.setDescription('This object tracks the page count for the pages sent to the print engine for fax jobs. In order to write this object <<hidden>> must be set correctly. Additional information: Returns the number of fax pages printed.')
collated_originals_support = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 42), OctetString()).setLabel("collated-originals-support").setMaxAccess("readonly")
if mibBuilder.loadTexts: collated_originals_support.setStatus('optional')
if mibBuilder.loadTexts: collated_originals_support.setDescription("Indicates that the printer can create multiple, collated 'originals' of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or 'mopies'. This is the base functionality required by the other collection items. cProofAndHold - The printer saves a copy of the job while printing the first mopy. Later, this held job can be released and the rest of the mopies will print. cSecurityPrint - The printer spools the job and holds the job until the user releases the job by entering a <<hidden>> at the printer's control panel. cAutoHighlight - The printer prints the job a number of times with a mail distribution list prepended to each job. A different mailing address is highlighted on each mopy. cCollatedAtSpeed - The printer can create multiple collated copies where all copies after the original are printed at engine speed. Additional information: Indicates that the printer can create multiple, collated originals of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or mopies. This is the base functionality required by the other collection items. Without disk, this object will not exist. This will be set at boot-up initialization. If the disk fails, in any way, then the disk error functionality will handle the situation. A color printer that only has a RAMDISK installed is treated like there is no disk and therefore this object will not exist. The value of this object will be: !cCollatedOriginals - Only FLASH installed cCollatedOriginals - IDE is installed combined with/without FLASH cCollatedOriginals - RAMDISK is On combined with/without FLASH")
host_application_available_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 59), Integer32()).setLabel("host-application-available-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: host_application_available_memory.setStatus('optional')
if mibBuilder.loadTexts: host_application_available_memory.setDescription('Returns the amount of memory, in bytes, that the device has available for job-related processing or resources. Also known as driver work space (DWS) memory.')
job_info_change_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("job-info-change-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_change_id.setStatus('optional')
if mibBuilder.loadTexts: job_info_change_id.setDescription('Returns the current value of an object in the job-info sub-tree whose value has changed. Define the object identifier for the object whose value has changed as job-info.required-field.optional-field.job-id. job-info represents the OID prefix of all objects in the job-info sub-tree. Required-field represents the OID field value that follows the job-info prefix. Since some objects in the job-info sub-tree have two OID fields between the job-info prefix and the job-id, the optional-field represents the OID field between the required-field and the job-id field, if present. Using this definition, the format for the JOB-INFO-CHANGE-ID binary value can be described as follows: Bytes 0-3 : required-field Bytes 4-7 : optional-field, or all zeros if there is no optional field Bytes 8-11: Job ID. Bytes 12-n : The value of the object job-info. required-field.optional-field.job-id. All multi-byte values stored in Motorola (big-endian) format, where the most significant byte occurs first. Additional information: InkJet will use this object to report changes to the job-info-pages-printed and job-info-state objects. The required-field (bytes 0 through 3) will designate whether the change to be reported involves the pages printed (13) or job state (15). The optional-field (bytes 4 through 7) will always be zeroes. The value-field (bytes 12 through 15) will contain the new value for pages printed or job state cast to a 32-bit integer. Note: It is possible that traps generated by this object have the same value. This is caused by the architecture of the InkJet System. In the InkJet System, it is highly probable that the object value will change so rapidly that when the trap is processed, PML will read the same value twice. This is timing related and will generally be seen at the end of a job.')
hold_job_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 10), Integer32()).setLabel("hold-job-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: hold_job_timeout.setStatus('optional')
if mibBuilder.loadTexts: hold_job_timeout.setDescription('The time, in minutes, that the printer will wait before automatically deleting a held job. This allows the printer to automatically clean up jobs that have been forgotten (held but never released). Additional information: This only applies to temporary held jobs, i.e., HOLD=ON or PROOF. This is a global timer that only affects the jobs that are sent after it is set. A value of 0 means never delete the jobs. Setting it to an unsupported value causes the printer to substitute a value (listed below) and to return <noError> status. Smokey supports values of 0, 60, 240, 1440, and 10080 The values are as follows: <=0 snap to 0 (disabled) >=1 and <=150 snap to 60 (60 minutes) >=151 and <=840 snap to 240 (4 hours) >=841 and <=2880 snap to 1440 (1 day) >=2881 snap to 10080 (1 week)')
current_job_parsing_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setLabel("current-job-parsing-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: current_job_parsing_id.setStatus('optional')
if mibBuilder.loadTexts: current_job_parsing_id.setDescription("Contains the printer assigned job identification for the job currently being processed by the processing PDL sub-system. The job ID is a monotonically increasing number. The job ID may be reset to zero at power-up and may roll over to zero after reaching some maximum value. Additional information: A value of -1 is returned when the printer is not parsing a job. When data for a new job is detected, this object is updated (the job may or may not turn out to be a Null Job); however, the trap does not occur until the printer determines that it is not a Null Job. (A job is considered to be a 'null job' if it has no name or job attribute, causes no pages to be printed, and consumes MIN_JOB_SIZE (9) or fewer bytes.) A trapped value will differ from the previous value by one or more. See the Job Boundary ERS for details on what constitutes a job boundary. Some job-info- objects are created when the first data bytes are received. If the printer determines that the job is a Null Job, the job-info- objects related to the Null Job are deleted. InkJet retains the job-info- objects for the MAX_JOBS_IN_LIST (32) most recent jobs that are not Null Jobs. The first job received after power-up will have job ID 1, and the job ID will increment to 2,147,483,647 before rolling to zero. To distinguish whether a power cycle or a rollover causes a reduction in the job ID value, the object prtGeneralConfigChanges can be watched and if it increments at the same time as the drop is observed in the value of CURRENT-JOB-PARSING-ID, then a power cycle is the most likely cause.")
job_info_name1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 1), OctetString()).setLabel("job-info-name1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name1.setStatus('optional')
if mibBuilder.loadTexts: job_info_name1.setDescription("Contains the first part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: The job name is the string specified by the NAME= parameter of the @PJL JOB command which allows a maximum of 80 characters. The first 40 characters are in this object and the second 40 are in job-info-name2. The symbol set is Roman-8. When jobs are nested, the value assigned to this object is the name provided by the most recent @PJL JOB NAME= command. If no name is provided, a null string is returned.")
job_info_name2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 2), OctetString()).setLabel("job-info-name2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name2.setStatus('optional')
if mibBuilder.loadTexts: job_info_name2.setDescription("Contains the second part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: See job-info-name1.")
job_info_stage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 10), OctetString()).setLabel("job-info-stage").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_stage.setStatus('optional')
if mibBuilder.loadTexts: job_info_stage.setDescription("Indicates what printer sub-systems are currently processing this print job. The last OID field for this dynamic object contains the job ID. cSourceSubsystem - some of the job is in the printer I/O subsystem. cProcessingSubsystem - some of the job is in the printer imaging processing subsystem. cDestinationSubsystem - some of the job is being printed. Additional information: For InkJet, cSourceSubsystem and cProcessingSubsystem will always be set and cleared together. They are set when the beginning of the job is detected, and they are cleared when the end of the job is parsed. A non-printing job will never set cDestinationSubsystem. When a page is ready to be printed (the intermediate has been built and the page is `closed' by the personality), cDestinationSubsystem will be set even if a page of a previous job is currently being printed. cDestinationSubsystem remains set until the last page of the job has finished printing. If a page requires extensive processing and allows all the previous pages of a job to complete printing, cDestinationSubsystem will remain set until the last page of the job has finished printing.")
job_info_io_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 11), Integer32()).setLabel("job-info-io-source").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_io_source.setStatus('optional')
if mibBuilder.loadTexts: job_info_io_source.setDescription('Indicates which I/O source, the print job was received over. The value maps to port numbering scheme supported in the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree.')
job_info_pages_processed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 12), Integer32()).setLabel("job-info-pages-processed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_processed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_processed.setDescription("Indicates the number of pages processed by the processing subsystem. If neither the cSourceSubsystem or the cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages processed for this job. The last OID field for this dynamic object contains the job ID. Additional information: This object is incremented by one when a page is processed (`closed' by the personality), regardless of the number of pages that are printed as a result of the single page processed. In other words, it does not matter how many identical copies of a page are printed or no pages may be printed if operating in silent run mode, this count is incremented exactly once. A page is considered processed when all of the input data has been processed for a page (that is, when the intermediate has been produced, and the personality has `closed' the page. At this time, the image of the page is not necessarily completely formed.)")
job_info_pages_printed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 13), Integer32()).setLabel("job-info-pages-printed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_printed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_printed.setDescription('Indicates the number of pages printed by the destination subsystem. If none of the cSourceSubsystem, cProcessingSubsystem or cDestinationSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages printed for this job. This value may increase by two each time for duplex jobs. The last OID field for this dynamic object contains the job ID. Additional information: If multiple copies of a page are printed, each copy is counted individually.')
job_info_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 14), Integer32()).setLabel("job-info-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_size.setStatus('optional')
if mibBuilder.loadTexts: job_info_size.setDescription('Indicates the number of bytes of data processed by the processing subsystem. If neither of the cSourceSubsystem or cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the size of this job, in bytes. The last OID field for this dynamic object contains the job ID. Additional information: This count may be incremented by values other than one as blocks of data are processed; blocks of data (which may be as large as 2K bytes) will be processed in a varying amount of time. During the processing of a job and even when a job completes, an exact count of the number of I/O bytes processed by the job is not necessarily to be expected.')
job_info_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 7, 10, 11, 12, 13))).clone(namedValues=NamedValues(("eAborted", 3), ("eWaitingForResources", 4), ("ePrinted", 5), ("eTerminating", 7), ("eCancelled", 10), ("eProcessing", 11), ("eScanning", 12), ("eSending", 13)))).setLabel("job-info-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_state.setStatus('optional')
if mibBuilder.loadTexts: job_info_state.setDescription('Indicates the state of the job. The last OID field for this dynamic object contains the job ID. eAborted - the print job was aborted. eWaitingForResources - the print job requires resources that are not currently available. Example resources that can cause the job to wait include the print engine or PDL processor being unavailable. The print engine could be unavailable due to paper out, paper jam, staple out, stapler jam, marking agent low, output bin full, etc. The PDL processor could be unavailable due to an off-line condition. Each printer specific object specification should state which conditions cause a job to be waiting for resources and also state which objects can be retrieved by an application to determine the exact cause of a resource being unavailable. ePrinted - the job has printed. The related JOB-INFO- OUTCOME object indicates if any problems were encountered while the job was processed. eRetained - the job can be reprinted. eTerminating - the job was aborted or cancelled and is currently is terminating. eInterrupted - the job has been interrupted. The job can be continued. ePaused - the job has been paused. The job can be continuted. eCancelled - the job has been cancelled. eProcessing - the job is currently being printed normally. ')
job_info_outcome = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eOk", 3)))).setLabel("job-info-outcome").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outcome.setStatus('optional')
if mibBuilder.loadTexts: job_info_outcome.setDescription('Indicates if any warning or error conditions were encountered while processing the assoicated job. The last OID field for this dynamic object contains the job ID. Additional information: In InkJet, warnings and errors are not recorded in this object. Although no meaningful information can be obtained from this object, it is kept around for the compatibility needs of existing software.')
job_info_attr_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_1.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_1.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. Attribute objects are saved sequentially, starting with 1, after the start of a job. If more attributes are set than there are objects to store them, the excess JOBATTR values are ignored. If the corresponding SET JOBATTR= command has not been received when a get is done for this object, a status of <noSuchName> will be returned.')
job_info_attr_2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_2.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_2.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_3 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-3").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_3.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_3.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-4").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_4.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_4.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_5 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_5.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_5.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_6 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-6").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_6.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_6.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_7 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-7").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_7.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_7.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_8 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-8").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_8.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_8.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_9 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_9.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_9.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_10 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-10").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_10.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_10.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_11 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-11").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_11.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_11.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_12 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-12").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_12.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_12.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_13 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-13").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_13.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_13.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_14 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-14").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_14.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_14.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_15 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-15").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_15.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_15.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_16 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-16").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_16.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_16.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_accounting_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11, 17, 18, 19, 25, 26, 27, 45, 46, 65, 72, 80, 81, 90, 91, 100, 101, 258, 282, 32767))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eROC16K", 17), ("eJISExecutive", 18), ("eROC8K", 19), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eJISB5", 45), ("eJISB4", 46), ("eISOB5", 65), ("eJapansePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101), ("eUSLetterR", 258), ("eISOandJISA4R", 282), ("eUnknownMediaSize", 32767)))).setLabel("job-info-accounting-media-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_media_size.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_media_size.setDescription('Contains the media size of the printed job. The media size of the first page will decide the media size of the entire job. The return value of this object will only be valid when the printer finishes printing the entire job.')
job_info_accounting_media_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54))).clone(namedValues=NamedValues(("eUnknownMedia", 1), ("eStandardType", 2), ("ePreprinted", 3), ("eBond", 4), ("eLetterhead", 5), ("eTransparency", 7), ("eLabels", 8), ("eRecycled", 9), ("eColored", 10), ("eCardStock", 11), ("eRough", 12), ("ePrepunched", 13), ("eHeavy", 14), ("eUserType1", 16), ("eUserType2", 17), ("eUserType3", 18), ("eUserType4", 19), ("eUserType5", 20), ("eHPIJTrans", 45), ("eHPSnowman160", 46), ("eHPSnowman220", 47), ("eHPPremMatte", 48), ("eHPBrochMatte", 49), ("eHPCoverMatte", 50), ("eMatte", 51), ("eCoverMatte", 52), ("eHPOfficePaper", 53), ("eHPOfficePaperEU", 54)))).setLabel("job-info-accounting-media-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_media_type.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_media_type.setDescription('Contains the media type of the printed job. The media type of the first page will decide the media type of the entire job. The return value of this object will only be valid when the printer finishes printing the entire job.')
job_info_accounting_finishing_options = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eNoFinish", 1), ("eOffset", 2), ("ePunch", 3), ("eStapler", 4), ("eFinisher", 5)))).setLabel("job-info-accounting-finishing-options").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_finishing_options.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_finishing_options.setDescription('Contains the finishing option used on the printed job. The finishing option specified for the first page will decide the finishing option of the entire job. The return value of this object will only be valid when the printer finishes printing the entire job.')
job_info_accounting_media_simplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 4), Integer32()).setLabel("job-info-accounting-media-simplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_media_simplex_count.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_media_simplex_count.setDescription('Contains the total number of simplex pages printed in a particular job.')
job_info_accounting_media_duplex_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 5), Integer32()).setLabel("job-info-accounting-media-duplex-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_media_duplex_count.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_media_duplex_count.setDescription('Contains the total number of duplex pages printed in a particular job.')
job_info_accounting_grayscale_impression_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 6), Integer32()).setLabel("job-info-accounting-grayscale-impression-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_grayscale_impression_count.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_grayscale_impression_count.setDescription('Contains the total number of monochrome pages printed in a particular job.')
job_info_accounting_color_impression_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 7), Integer32()).setLabel("job-info-accounting-color-impression-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_color_impression_count.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_color_impression_count.setDescription('Contains the total number of color pages printed in a particular job.')
job_info_accounting_black_dots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 8), Integer32()).setLabel("job-info-accounting-black-dots").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_black_dots.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_black_dots.setDescription('Contains the total number of black pixels used in a particular job.')
job_info_accounting_yellow_dots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 9), Integer32()).setLabel("job-info-accounting-yellow-dots").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_yellow_dots.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_yellow_dots.setDescription('Contains the total number of yellow pixels used in a particular job.')
job_info_accounting_cyan_dots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 10), Integer32()).setLabel("job-info-accounting-cyan-dots").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_cyan_dots.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_cyan_dots.setDescription('Contains the total number of cyan pixels used in a particular job.')
job_info_accounting_magenta_dots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 11), Integer32()).setLabel("job-info-accounting-magenta-dots").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_magenta_dots.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_magenta_dots.setDescription('Contains the total number of magenta pixels used in a particular job.')
job_info_accounting_job_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1000))).clone(namedValues=NamedValues(("ePrintJob", 1), ("eIPPJob", 2), ("eCopyJob", 3), ("eCopyInterruptJob", 4), ("eJetSendJob", 5), ("eInternalPage", 6), ("eCleaningPage", 7), ("eAutoCleaningPage", 8), ("eDigitalSendJob", 9), ("eWebPrintJob", 10), ("eFaxPrintJob", 11), ("eRetrievedJob", 12), ("ePhotoCardPrintJob", 13), ("eUnknownJob", 1000)))).setLabel("job-info-accounting-job-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_job_type.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_job_type.setDescription('Keeps track of what type of job is processed. ')
job_info_accounting_fixer_dots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 28, 33), Integer32()).setLabel("job-info-accounting-fixer-dots").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_accounting_fixer_dots.setStatus('optional')
if mibBuilder.loadTexts: job_info_accounting_fixer_dots.setDescription('Contains the total number of fixer pixels used in a particular job.')
held_job_user_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("held-job-user-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_user_name.setStatus('optional')
if mibBuilder.loadTexts: held_job_user_name.setDescription('User name that is obtained by the driver through some internal method or from user input. Additional information: The following is a general description for all the JOB-MANAGEMENT objects described below. These object describe the attributes of the dynamic list containing all the stored jobs on the disk available for printing or deleting via the job-management feature. The jobs on this list are not deleted from the disk unless explicitly specified by the user. A print job may be specified for retention by PJL commands in the data stream. Following is a list of the PJL commands (i.e. these comments describe the PJL implementation and in some cases do not reflect the PML implementation.): @PJL SET HOLD=OFF|ON|PROOF|STORE|PRINT GENERAL DESCRIPTION: This variable specifies the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. OFF: The job is printed but not retained on disk after printing. This is the default value. ON: This setting may be thought of as free proof-and-hold. The requested number of copies will be printed and the job will be temporarily stored on disk. The job will then be available for printing additional copies through the control panel and through PML. There will be a limit to the number of these temporary jobs that may be stored, and when the limit is exceeded the oldest job will be removed from the disk. PROOF: One copy of the job is printed and remaining copies are stored on disk. The job is then available to select for printing via the control panel menus or PML. The job will be deleted from the disk when the disk space is needed for another proof and hold job but only after the additional copies have been printed. It will also be deleted when the user sends down another proof and hold job with the same job name, or the user explicitly deletes the job. STORE: The job is not printed immediately but is retained on disk. The job is available to select for printing via the control panel DEFAULT VALUE: OFF The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET USERNAME=<80 bytes> GENERAL DESCRIPTION: Eighty-character user name that is obtained by the driver through some internal method or from user input. If the job stream does not contain a USERNAME the default value will be NO USER NAME. The driver is responsible for determining the size of the printers control panel and sending a string of appropriate length. DEFAULT VALUE: NO USER NAME The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and, INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET JOBNAME=<80 bytes> GENERAL DESCRIPTION: Eighty-character job name that may be generated by the driver or obtained from user input. This value may be used in conjunction with the USERNAME to select a job from the front panel. If the job stream does not contain a JOBNAME, the printer will assume no job name; each subsequent job that is sent down by the same user would replace the users last job on disk. The driver is responsible for determining the size of the printers control panel and sending a string of appropriate length. NOTE: The limit of 80 bytes is a PJL limit. The limit for PML will be 40 bytes. DEFAULT VALUE: NULL STRING The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET HOLDTYPE=PUBLIC|PRIVATE GENERAL DESCRIPTION: This variable specifies the privacy level of the job. PUBLIC: The job does not require a PIN in order to be released for printing. This is the default value. PRIVATE: The job requires a PIN in order to be released for printing. The PIN is specified by the HOLDKEY variable. If the HOLDTYPE is set to PRIVATE, a HOLDKEY value must be specified. If no HOLDKEY is specified, the job will be considered PUBLIC. DEFAULT VALUE: PUBLIC The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET HOLDKEY=4 digits, 0000...9999 GENERAL DESCRIPTION: A 4-digit string, each digit 0-9, that is specified in the job stream and then required to be entered in order to release the job for printing. If a HOLDTYPE is PRIVATE, a HOLDKEY value must be specified. If no HOLDKEY value is specified, a job will be considered PUBLIC. DEFAULT VALUE: NULL STRING The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. The format for the OID is as follows: 3.4.1.6.x.y <-----> | | | | \\ / | job-id in the system / \\ PML_JOB_MGNT_ROOT_OID \\ job attribute 1..6 x values are 1..6: 1) user-name: user name that is obtained by the driver through some internal method or from user input. 2) job-name: job name may be generated by the driver or obtained from user input. 3) hold: indicates the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. There are 4 options: OFF: The job is printed but not retained on the disk. ON: The job is printed and stored temporarily on the disk. STORE: The job is not printed but stored on the disk. PROOF: One copy of the job is printed and the remaining copies are stored on the disk. 4) holdtype: The variable specifies the security level of the job. PUBLIC: The job does not require a PIN in order to release the job for printing. PRIVATE: The job requires a PIN in order to be released for printing. 5) quantity: number of copies to print. Valid values are 0..999. 6) pin: A 4 digit string, each digit is 0-9, that is specified in the job stream and then required to be entered in order to release the job for printing. y : an unsigned 32-bit number which uniquely identifies the job. The job id for the job remains the same for the job until it is deleted from the held jobs list. For example, the OID below is asking for the user name of the job whose id is 3. The application would issue: OID get 3.4.1.6.1.3 For example, the <getnext> OID values sequence is as follows: OID returned OID getnext 3.4.1.6 3.4.1.6.1.1 getnext 3.4.1.6.1.1 3.4.1.6.1.2 getnext 3.4.1.6.2.1 3.4.1.6.2.2 *** getnext 3.4.1.6.1.6 3.4.1.6.1.7 getnext 3.4.1.6.2.1 3.4.1.6.2.2 getnext 3.4.1.6.5.2828 3.4.1.6.6.1 NOTE: for example above, job id 2828 is the last job in the list of held jobs. *** Also supported is <getnext> on the job attributes: OID returned OID getnext 3.4.1.6.1 3.4.1.6.1.1 getnext 3.4.1.6.6 3.4.1.6.6.1')
held_job_job_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("held-job-job-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_job_name.setStatus('optional')
if mibBuilder.loadTexts: held_job_job_name.setDescription('The job name may be generated by the driver or obtained from user input.')
held_job_retention = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eHoldOff", 1), ("eHoldOn", 2), ("eHoldStore", 3), ("eHoldProof", 4)))).setLabel("held-job-retention").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_retention.setStatus('optional')
if mibBuilder.loadTexts: held_job_retention.setDescription('Indicates the retention classification of the job. The values indicate whether the job is printed immediately or stored. There are 4 options: eHoldOff: The job is printed but not retained on the disk. eHoldOn: The job is printed and stored temporarily on the disk. eHoldStore: The job is not printed but stored on the disk. eHoldProof: One copy of the job is printed and the remaining copies are stored on the disk. ')
held_job_security = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eHoldTypePublic", 1), ("eHoldTypePrivate", 2)))).setLabel("held-job-security").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_security.setStatus('optional')
if mibBuilder.loadTexts: held_job_security.setDescription('The variable specifies the security level of the job. eHoldTypePublic: The job does not require a PIN in order to release the job for printing. eHoldTypePrivate: The job requires a PIN in order to be released for printing. ')
held_job_quantity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setLabel("held-job-quantity").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_quantity.setStatus('optional')
if mibBuilder.loadTexts: held_job_quantity.setDescription('Number of copies to print.')
held_job_pin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setLabel("held-job-pin").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_pin.setStatus('optional')
if mibBuilder.loadTexts: held_job_pin.setDescription('A string that is specified in the job stream and then required to be entered in order to release the job for printing. PIN stands for Personal Identification Number. Additional information: Must be a 4 digit string, each digit must be 0..9 or a null string if there is no pin. For security purposes, you can no longer get the value of the PIN.')
held_job_print = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setLabel("held-job-print").setMaxAccess("writeonly")
if mibBuilder.loadTexts: held_job_print.setStatus('optional')
if mibBuilder.loadTexts: held_job_print.setDescription('Instructs the printer to schedule the specified held job for printing with the specified number of copies. The job-id is used to identify which job to print. A held job can also be printed from the control panel. Additional information: Bytes 0-3 is the job id of the job to print. Bytes 4-7 is the number of copies to print. Bytes 8-11 (optional) contain the PIN for a Private job. ')
held_job_delete = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 2), Integer32()).setLabel("held-job-delete").setMaxAccess("writeonly")
if mibBuilder.loadTexts: held_job_delete.setStatus('optional')
if mibBuilder.loadTexts: held_job_delete.setDescription('Instructs the printer to delete the specified held job from the list. The job-id is used to identify which job to delete. A held job can also be deleted from the control panel. Additional information: Setting this to a value that is not a Held Job on the system or is a Private Held Job returns <ErrUnsupValue>. To delete a private Held Job, you must use the PML object HELD-JOB-PRINT with a quantity of 0 and supply the correct HELD-JOB-PIN with the request. (See HELD-JOB-PRINT)')
held_job_set_queue_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("held-job-set-queue-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_set_queue_size.setStatus('optional')
if mibBuilder.loadTexts: held_job_set_queue_size.setDescription('Sets the maximum number of jobs which can be stored in the held job list. Additional information: Sets the size of the temporary job lists queue.')
held_job_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("held-job-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: held_job_enable.setStatus('optional')
if mibBuilder.loadTexts: held_job_enable.setDescription('Enables or disables Job Retention (Job Hold). The valid values are eDisabled and eEnabled. (Specifying an invalid mode causes an <badValue> error to be returned.) When eDisabled is specified all Job Retention (Hold, Proof, Store, PIN Printing) is disabled. When eEnabled is specified, the Job Retention characteristics of a given job are defined by the PJL variable SET HOLD. Additional information: When disabled, held jobs are not removed, but must be explicitly removed through the Control Panel or the PML object HELD-JOB-DELETE.')
date_display = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6))).clone(namedValues=NamedValues(("eDateDisplayMMM-DD-YYYY", 4), ("eDateDisplayDD-MMM-YYYY", 5), ("eDateDisplayYYYY-MMM-DD", 6)))).setLabel("date-display").setMaxAccess("readwrite")
if mibBuilder.loadTexts: date_display.setStatus('optional')
if mibBuilder.loadTexts: date_display.setDescription('Controls front-panel date display format. Additional information: Controls front-panel date display format.')
date_and_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 17), OctetString()).setLabel("date-and-time").setMaxAccess("readwrite")
if mibBuilder.loadTexts: date_and_time.setStatus('optional')
if mibBuilder.loadTexts: date_and_time.setDescription('A C structure containing the following fields: typedef struct { ubyte yr; /* year: 0 to 99 */ ubyte mon; /* month: 1 to 12 */ ubyte day; /* day: 1 to 31 */ ubyte wday; /* Day of week: 1 to 07 */ ubyte hr; /* hour: 0 to 23 */ ubyte min; /* minute: 0 to 59 */ ubyte sec; /* second: 0 to 59 */ } date_t; where ubyte is an unsigned byte (0-255). Additional information: A C structure containing the following fields: typedef struct { ubyte yr; /* year: 3 to 99 */ ubyte mon; /* month: 1 to 12 */ ubyte day; /* day: 1 to 31 */ ubyte wday; /* Day of week: 1 to 07 */ ubyte hr; /* hour: 0 to 23 */ ubyte min; /* minute: 0 to 59 */ ubyte sec; /* second: 0 to 59 */ } date_t; where ubyte is an unsigned byte (0-255).')
time_display = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eTimeDisplayTwelveHour", 1), ("eTimeDisplayTwentyFourHour", 2)))).setLabel("time-display").setMaxAccess("readwrite")
if mibBuilder.loadTexts: time_display.setStatus('optional')
if mibBuilder.loadTexts: time_display.setDescription('Controls front-panel time display format. Set to eTimeDisplayTwelveHour for AM/PM display. Set to eTimeDisplayTwentyFourHour for military-type display. Additional information: Controls front-panel time display format. Set to eTimeDisplayTwelveHour for AM/PM display. Set to eTimeDisplayTwentyFourHour for military-type display.')
rtc_time_zone = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75))).clone(namedValues=NamedValues(("eTzDateline", 1), ("eTzSamoa", 2), ("eTzHawaiian", 3), ("eTzAlaskan", 4), ("eTzPacific", 5), ("eTzUSMountain", 6), ("eTzMexico2", 7), ("eTzMountain", 8), ("eTzCentralAmerica", 9), ("eTzCentral", 10), ("eTzMexico", 11), ("eTzCanadaCentral", 12), ("eTzSAPacific", 13), ("eTzEastern", 14), ("eTzUSEastern", 15), ("eTzAtlantic", 16), ("eTzSAWestern", 17), ("eTzPacificSA", 18), ("eTzNewfoundland", 19), ("eTzESouthAmerica", 20), ("eTzSAEastern", 21), ("eTzGreenland", 22), ("eTzMidAtlantic", 23), ("eTzAzores", 24), ("eTzCapeVerde", 25), ("eTzGreenwich", 26), ("eTzGMT", 27), ("eTzWEurope", 28), ("eTzCentralEurope", 29), ("eTzRomance", 30), ("eTzCentralEuropean", 31), ("eTzWCentralAfrica", 32), ("eTzGTB", 33), ("eTzEeurope", 34), ("eTzEgypt", 35), ("eTzSouthAfrica", 36), ("eTzFLE", 37), ("eTzJerusalem", 38), ("eTzArabic", 39), ("eTzArab", 40), ("eTzRussian", 41), ("eTzEAfrica", 42), ("eTzIran", 43), ("eTzArabian", 44), ("eTzCaucasus", 45), ("eTzAfghanistan", 46), ("eTzEkaterinburg", 47), ("eTzWestAsia", 48), ("eTzIndia", 49), ("eTzNepal", 50), ("eTzNCentralAsia", 51), ("eTzCentralAsia", 52), ("eTzSriLanka", 53), ("eTzMyanmar", 54), ("eTzSEAsia", 55), ("eTzNorthAsia", 56), ("eTzChina", 57), ("eTzNorthAsiaEast", 58), ("eTzMalayPeninsula", 59), ("eTzWAustralia", 60), ("eTzTaipei", 61), ("eTzTokyo", 62), ("eTzKorea", 63), ("eTzYakutsk", 64), ("eTzCenAustralia", 65), ("eTzAUSCentral", 66), ("eTzEAustralia", 67), ("eTzAUSEastern", 68), ("eTzWestPacific", 69), ("eTzTasmania", 70), ("eTzVladivostok", 71), ("eTzCentralPacific", 72), ("eTzNewZealand", 73), ("eTzFiji", 74), ("eTzTonga", 75)))).setLabel("rtc-time-zone").setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtc_time_zone.setStatus('optional')
if mibBuilder.loadTexts: rtc_time_zone.setDescription("Controls the time zone, which can be chosen from a list of time zones similar to the one used by Microsoft Windows operating system: eTzDateline -12:00 International Date Line West eTzSamoa -11:00 Midway Island, Samoa eTzHawaiian -10:00 Hawaii eTzAlaskan -09:00 Alaska eTzPacific -08:00 Pacific Time (US & Canada); Tijuana eTzUSMountain -07:00 Arizona eTzMexico2 -07:00 Chihuahua, La Paz, Mazatlan eTzMountain -07:00 Mountain Time (US & Canada) eTzCentralAmerica -06:00 Central America eTzCentral -06:00 Central Time (US & Canada) eTzMexico -06:00 Guadalajara, Mexico City, Monterrey eTzCanadaCentral -06:00 Saskatchewan eTzSAPacific -05:00 Bogota, Lima, Quito eTzEastern -05:00 Eastern Time (US & Canada) eTzUSEastern -05:00 Indiana (East) eTzAtlantic -04:00 Atlantic Time (Canada) eTzSAWestern -04:00 Caracas, La Paz eTzPacificSA -04:00 Santiago eTzNewfoundland -03:30 Newfoundland eTzESouthAmerica -03:00 Brasilia eTzSAEastern -03:00 Buenos Aires, Georgetown eTzGreenland -03:00 Greenland eTzMidAtlantic -02:00 Mid-Atlantic eTzAzores -01:00 Azores eTzCapeVerde -01:00 Cape Verde Is. eTzGreenwich 00:00 Casablanca, Monrovia eTzGMT 00:00 Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London eTzWEurope +01:00 Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna eTzCentralEurope +01:00 Belgrade, Bratislava, Budapest, Ljubljana, Prague eTzRomance +01:00 Brussels, Copenhagen, Madrid, Paris eTzCentralEuropean +01:00 Sarajevo, Skopje, Warsaw, Zagreb eTzWCentralAfrica +01:00 West Central Africa eTzGTB +02:00 Athens, Beirut, Istanbul, Minsk eTzEeurope +02:00 Bucharest eTzEgypt +02:00 Cairo eTzSouthAfrica +02:00 Harare, Pretoria eTzFLE +02:00 Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius eTzJerusalem +02:00 Jerusalem eTzArabic +03:00 Baghdad eTzArab +03:00 Kuwait, Riyadh eTzRussian +03:00 Moscow, St. Petersburg, Volgograd eTzEAfrica +03:00 Nairobi eTzIran +03:30 Tehran eTzArabian +04:00 Abu Dhabi, Muscat eTzCaucasus +04:00 Baku, Tbilisi, Yerevan eTzAfghanistan +04:30 Kabul eTzEkaterinburg +05:00 Ekaterinburg eTzWestAsia +05:00 Islamabad, Karachi, Tashkent eTzIndia +05:30 Chennai, Kolkata, Mumbai, New Delhi eTzNepal +05:45 Kathmandu eTzNCentralAsia +06:00 Almaty, Novosibirsk eTzCentralAsia +06:00 Astana, Dhaka eTzSriLanka +06:00 Sri Jayawardenepura eTzMyanmar +06:30 Rangoon eTzSEAsia +07:00 Bangkok, Hanoi, Jakarta eTzNorthAsia +07:00 Krasnoyarsk eTzChina +08:00 Beijing, Chongqing, Hong Kong, Urumqi eTzNorthAsiaEast +08:00 Irkutsk, Ulaan Bataar eTzMalayPeninsula +08:00 Kuala Lumpur, Singapore eTzWAustralia +08:00 Perth eTzTaipei +08:00 Taipei eTzTokyo +09:00 Osaka, Sapporo, Tokyo eTzKorea +09:00 Seoul eTzYakutsk +09:00 Yakutsk eTzCenAustralia +09:30 Adelaide eTzAUSCentral +09:30 Darwin eTzEAustralia +10:00 Brisbane eTzAUSEastern +10:00 Canberra, Melbourne, Sydney eTzWestPacific +10:00 Guam, Port Moresby eTzTasmania +10:00 Hobart eTzVladivostok +10:00 Vladivostok eTzCentralPacific +11:00 Magadan, Solomon Is., New Caledonia eTzNewZealand +12:00 Auckland, Wellington eTzFiji +12:00 Fiji, Kamchatka, MarshallIs. eTzTonga +13:00 Nuku'alofa Additional information: Controls the time zone, which can be chosen from a list of time zones similar to the one used by Microsoft Windows operating system: eTzDateline -12:00 International Date Line West eTzSamoa -11:00 Midway Island, Samoa eTzHawaiian -10:00 Hawaii eTzAlaskan -09:00 Alaska eTzPacific -08:00 Pacific Time (US & Canada); Tijuana eTzUSMountain -07:00 Arizona eTzMexico2 -07:00 Chihuahua, La Paz, Mazatlan eTzMountain -07:00 Mountain Time (US & Canada) eTzCentralAmerica -06:00 Central America eTzCentral -06:00 Central Time (US & Canada) eTzMexico -06:00 Guadalajara, Mexico City, Monterrey eTzCanadaCentral -06:00 Saskatchewan eTzSAPacific -05:00 Bogota, Lima, Quito eTzEastern -05:00 Eastern Time (US & Canada) eTzUSEastern -05:00 Indiana (East) eTzAtlantic -04:00 Atlantic Time (Canada) eTzSAWestern -04:00 Caracas, La Paz eTzPacificSA -04:00 Santiago eTzNewfoundland -03:30 Newfoundland eTzESouthAmerica -03:00 Brasilia eTzSAEastern -03:00 Buenos Aires, Georgetown eTzGreenland -03:00 Greenland eTzMidAtlantic -02:00 Mid-Atlantic eTzAzores -01:00 Azores eTzCapeVerde -01:00 Cape Verde Is. eTzGreenwich 00:00 Casablanca, Monrovia eTzGMT 00:00 Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London eTzWEurope +01:00 Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna eTzCentralEurope +01:00 Belgrade, Bratislava, Budapest, Ljubljana, Prague eTzRomance +01:00 Brussels, Copenhagen, Madrid, Paris eTzCentralEuropean +01:00 Sarajevo, Skopje, Warsaw, Zagreb eTzWCentralAfrica +01:00 West Central Africa eTzGTB +02:00 Athens, Beirut, Istanbul, Minsk eTzEeurope +02:00 Bucharest eTzEgypt +02:00 Cairo eTzSouthAfrica +02:00 Harare, Pretoria eTzFLE +02:00 Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius eTzJerusalem +02:00 Jerusalem eTzArabic +03:00 Baghdad eTzArab +03:00 Kuwait, Riyadh eTzRussian +03:00 Moscow, St. Petersburg, Volgograd eTzEAfrica +03:00 Nairobi eTzIran +03:30 Tehran eTzArabian +04:00 Abu Dhabi, Muscat eTzCaucasus +04:00 Baku, Tbilisi, Yerevan eTzAfghanistan +04:30 Kabul eTzEkaterinburg +05:00 Ekaterinburg eTzWestAsia +05:00 Islamabad, Karachi, Tashkent eTzIndia +05:30 Chennai, Kolkata, Mumbai, New Delhi eTzNepal +05:45 Kathmandu eTzNCentralAsia +06:00 Almaty, Novosibirsk eTzCentralAsia +06:00 Astana, Dhaka eTzSriLanka +06:00 Sri Jayawardenepura eTzMyanmar +06:30 Rangoon eTzSEAsia +07:00 Bangkok, Hanoi, Jakarta eTzNorthAsia +07:00 Krasnoyarsk eTzChina +08:00 Beijing, Chongqing, Hong Kong, Urumqi eTzNorthAsiaEast +08:00 Irkutsk, Ulaan Bataar eTzMalayPeninsula +08:00 Kuala Lumpur, Singapore eTzWAustralia +08:00 Perth eTzTaipei +08:00 Taipei eTzTokyo +09:00 Osaka, Sapporo, Tokyo eTzKorea +09:00 Seoul eTzYakutsk +09:00 Yakutsk eTzCenAustralia +09:30 Adelaide eTzAUSCentral +09:30 Darwin eTzEAustralia +10:00 Brisbane eTzAUSEastern +10:00 Canberra, Melbourne, Sydney eTzWestPacific +10:00 Guam, Port Moresby eTzTasmania +10:00 Hobart eTzVladivostok +10:00 Vladivostok eTzCentralPacific +11:00 Magadan, Solomon Is., New Caledonia eTzNewZealand +12:00 Auckland, Wellington eTzFiji +12:00 Fiji, Kamchatka, Marshall Is. eTzTonga +13:00 Nuku'alofa")
automatic_daylight_savings = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("automatic-daylight-savings").setMaxAccess("readwrite")
if mibBuilder.loadTexts: automatic_daylight_savings.setStatus('optional')
if mibBuilder.loadTexts: automatic_daylight_savings.setDescription("Determines whether or not the automatic adjustment for daylight savings time is enabled. If it's enabled the device local time will be automatically adjusted for DST period. Additional information: Determines whether or not the automatic adjustment for daylight savings time is enabled. If its enabled the device local time will be automatically adjusted for DST period")
daylight_savings_start = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 101), OctetString()).setLabel("daylight-savings-start").setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylight_savings_start.setStatus('optional')
if mibBuilder.loadTexts: daylight_savings_start.setDescription('A C structure containing the following fields: typedef struct { ubyte hour; /* hour: 0 to 23 */ ubyte weekday; /* weekday: 0(Sunday) to 6 */ ubyte occurrence; /* occurrence in the month: 1 to 5 */ ubyte month; /* month: 1 to 12 */ } dst; where ubyte is an unsigned byte (0-255). Additional information: A C structure containing the following fields: typedef struct { ubyte hour; /* hour: 0 to 23 */ ubyte weekday; /* weekday: 0(Sunday) to 6 */ ubyte occurrence; /* occurrence in the month: 1 to 5 */ ubyte month; /* month: 1 to 12 */ } dst; where ubyte is an unsigned byte (0-255).')
daylight_savings_end = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 102), OctetString()).setLabel("daylight-savings-end").setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylight_savings_end.setStatus('optional')
if mibBuilder.loadTexts: daylight_savings_end.setDescription('A C structure containing the following fields: typedef struct { ubyte hour; /* hour: 0 to 23 */ ubyte weekday; /* weekday: 0(Sunday) to 6 */ ubyte occurrence; /* occurrence in the month: 1 to 5 */ ubyte month; /* month: 1 to 12 */ } dst; where ubyte is an unsigned byte (0-255). Additional information: A C structure containing the following fields: typedef struct { ubyte hour; /* hour: 0 to 23 */ ubyte weekday; /* weekday: 0(Sunday) to 6 */ ubyte occurrence; /* occurrence in the month: 1 to 5 */ ubyte month; /* month: 1 to 12 */ } dst; where ubyte is an unsigned byte (0-255).')
daylight_savings_offset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 103), Integer32()).setLabel("daylight-savings-offset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylight_savings_offset.setStatus('optional')
if mibBuilder.loadTexts: daylight_savings_offset.setDescription('Controls the offset in minutes to be added to the time when DST is in effect. Additional information: Controls the offset in minutes to be added to the time when DST is in effect')
daylight_savings_reset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eResetToDefault", 1), ("eCustomized", 2)))).setLabel("daylight-savings-reset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylight_savings_reset.setStatus('optional')
if mibBuilder.loadTexts: daylight_savings_reset.setDescription('This object is used to reset (set back to factory default for the current time zone) or read the current status of the DST settings. When Set to eResetToDefault, this object can be used to reset all the DST related objects back to their factory default values. Setting this object with an enumerated value of eCustomized has no effect. When a Get operation is performed on this object it will return a value eResetToDefault if all DST settings are still set to they factory value. It will return eCustomized if any DST parameter has been set to a custom value. Additional information: This object is used to reset (set back to factory default for the current time zone) or read the current status of the DST settings. When Set to eResetToDefault, this object can be used to reset all the DST related objects back to their factory default values. Setting this object with an enumerated value of eCustomized has no effect. When a Get operation is performed on this object it will return a value eResetToDefault if all DST settings are still set to they factory value. It will return eCustomized if any DST parameter has been set to a custom value.')
direct_connect_ports_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2), ("eUnSupported", 3)))).setLabel("direct-connect-ports-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: direct_connect_ports_enable.setStatus('optional')
if mibBuilder.loadTexts: direct_connect_ports_enable.setDescription('This object specifies whether all direct connect ports (parallel and USB) are available or ignored. JetDirect, embedded network connectivity, and third party add-on cards (such as Firewire) will be unaffected by setting this object.')
mio1_model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 2), OctetString()).setLabel("mio1-model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_model_name.setStatus('optional')
if mibBuilder.loadTexts: mio1_model_name.setDescription('Returns product information identifying the I/O card. Example: XXXX.')
mio1_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 3), OctetString()).setLabel("mio1-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: mio1_manufacturing_info.setDescription('Returns information describing the manufacture of the I/O card installed in MIO/EIO slot 1. May include serial number and firmware revision. Additional information: The format of the string returned is determined by the manufacturer of the EIO device. There is no standard for content of the string.')
mio1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 8, 12))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eDiskDrive", 8), ("eIOCard", 12)))).setLabel("mio1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_type.setStatus('optional')
if mibBuilder.loadTexts: mio1_type.setDescription('Returns an indication of the type of option installed in MIO/EIO slot 1. See SIMM1-TYPE for an explanation of the enumerations.')
mio4_model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 4, 2), OctetString()).setLabel("mio4-model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio4_model_name.setStatus('optional')
if mibBuilder.loadTexts: mio4_model_name.setDescription('Returns product information identifying the I/O card. Example: XXXX. Additional information: Returns a string describing the firmware version of the embedded JDI LAN card.')
mio4_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 4, 3), OctetString()).setLabel("mio4-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio4_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: mio4_manufacturing_info.setDescription('Returns information describing the manufacture of the I/O card installed in MIO/EIO interface 4. May include serial number and firmware revision. Additional information: Returns a string describing the embedded JDI LAN card.')
mio4_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 12))).clone(namedValues=NamedValues(("eEmpty", 1), ("eIOCard", 12)))).setLabel("mio4-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio4_type.setStatus('optional')
if mibBuilder.loadTexts: mio4_type.setDescription('Returns an indication of the type of option installed in MIO/EIO interface 4. See SIMM1-TYPE for an explanation of the enumerations. Additional information: Returns eEmpty if the embedded JDI LAN card is disabled. Returns eIOCard if the embedded JDI LAN card is enabled.')
usb_host_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("usb-host-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_host_supported.setStatus('optional')
if mibBuilder.loadTexts: usb_host_supported.setDescription('The USB Host protocol is supported by the device when the value returned is eTrue. The USB Host protocol is not supported when the value returned is eFalse.')
usb_serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 1), OctetString()).setLabel("usb-serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_serial_number.setStatus('optional')
if mibBuilder.loadTexts: usb_serial_number.setDescription('Returns the serial number of a connected USB device as defined in the Standard Device Descriptor of the Universal Serial Bus Specification Version 2.0.')
usb_manufacturer_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 2), OctetString()).setLabel("usb-manufacturer-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_manufacturer_name.setStatus('optional')
if mibBuilder.loadTexts: usb_manufacturer_name.setDescription('Returns the description of the manufacturer of a connected USB device as defined in the Standard Device Descriptor of the Universal Serial Bus Specification Version 2.0.')
usb_product_description = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 3), OctetString()).setLabel("usb-product-description").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_product_description.setStatus('optional')
if mibBuilder.loadTexts: usb_product_description.setDescription('Returns the product description of a connected USB device as defined in the Standard Device Descriptor of the Universal Serial Bus Specification Version 2.0.')
usb_vendor_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 4), Integer32()).setLabel("usb-vendor-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_vendor_id.setStatus('optional')
if mibBuilder.loadTexts: usb_vendor_id.setDescription('Returns the Vendor ID of a connected USB device as defined in the Standard Device Descriptor of the Universal Serial Bus Specification Version 2.0. The value will be in the range 0..65535.')
usb_product_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 5), Integer32()).setLabel("usb-product-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_product_id.setStatus('optional')
if mibBuilder.loadTexts: usb_product_id.setDescription('Returns the Product ID of a connected USB device as defined in the Standard Device Descriptor of the Universal Serial Bus Specification Version 2.0. The value will be in the range 0..65535.')
usb_device_kind = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eUSBStorageDevice", 1), ("eUSBNonStorageDevice", 2), ("eUSBCompositeDevice", 3), ("eUSBUnsupportedDevice", 4)))).setLabel("usb-device-kind").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_device_kind.setStatus('optional')
if mibBuilder.loadTexts: usb_device_kind.setDescription('The USB-DEVICE-KIND object classifies a USB device into one of four broad categories: \\ eUSBStorageDevice(1): The USB device is strictly a device for storing data. \\ eUSBNonStorageDevice(2): The USB device has no storage capability (e.g., a card reader). \\ eUSBCompositeDevice(3): The USB device has storage capability and additional functionality normally not associated with a storage device. \\ eUSBUnsupportedDevice(4): The USB device was detected, but no driver exists for the device or the device draws more current than allowed. \\')
usb_driver_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 9, 2, 7), OctetString()).setLabel("usb-driver-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: usb_driver_name.setStatus('optional')
if mibBuilder.loadTexts: usb_driver_name.setDescription('Returns the name of the low-level USB driver supporting this device.')
io_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300))).setLabel("io-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: io_timeout.setStatus('optional')
if mibBuilder.loadTexts: io_timeout.setDescription('The amount of time, in seconds, to wait for more print job data to be received before an I/O timeout occurs. The I/O channel being timed is the I/O channel that received the data associated with the current print job. If an I/O timeout occurs, the PDL processing sub-system assumes all the data associated with the current print job has been received, and processes the end of job in a PDL specific manner. The POS specifies the supported values. Additional information: If an I/O timeout occurs,the PDL processing sub-system will consider it an end of job condition only if there is data from another I/O subsystem waiting to be processed. The supported values are 5 to 300 seconds. Setting to a value outside the supported range returns <noError> status and the value will be snapped to the nearest supported value.')
io_switch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eYes", 1)))).setLabel("io-switch").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_switch.setStatus('optional')
if mibBuilder.loadTexts: io_switch.setDescription('Indicates if the device will switch between I/O channels when a job boundary is encountered and print job data is available on another I/O channel.')
port1_parallel_speed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eSlow", 1), ("eFast", 2)))).setLabel("port1-parallel-speed").setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1_parallel_speed.setStatus('optional')
if mibBuilder.loadTexts: port1_parallel_speed.setDescription('Returns or changes the maximum parallel I/O port speed, for port 1. This object is only supported if this port is a parallel port. An eSlow setting causes a 10 us busy pulse per received byte of data. An eFast setting causes a 1.5 us busy pulse per received byte of data. In rare cases, setting this value to eFast can cause the parallel port to no longer transfer data reliably. Additional information: When the value of this object is changed, it takes effect immediately. It is recommended that the printer be offline and not in a job when this object is changed.')
port1_parallel_bidirectionality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eUnidirectional", 1), ("eBidirectional", 2)))).setLabel("port1-parallel-bidirectionality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1_parallel_bidirectionality.setStatus('optional')
if mibBuilder.loadTexts: port1_parallel_bidirectionality.setDescription('Returns or changes whether the parallel I/O port supports bidirectional communication for port 1. This object is only supported if this port is a parallel port. Additional information: A get on this object returns the current mode for the parallel port. Setting this object specifies whether or not bidirectional communications will be allowed.')
rpc_bind_protocol_address = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 1, 2), OctetString()).setLabel("rpc-bind-protocol-address").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_bind_protocol_address.setStatus('optional')
if mibBuilder.loadTexts: rpc_bind_protocol_address.setDescription('Array of Berkeley sockets style protocol addresses used to bind RPC to a communications protocol family. Setting an instance of this array object to a zero length binary value disables the transport protocol indicated by that instance. All multi-bytes fields are in network (or big-endian) order. Bytes 1 and 2 indicate the transport protocol. Some of the transport protocol mapping information can be found in RFC 1010 Assigned Numbers. A list of interesting transport protocol number mappings include: <table> Protocol | Number ---------+------- UDP/IP | 17 IPX | 1000 MLC | 4660 </table> Bytes 3 and 4 indicate the address family. The address family uses the same mapping as the BSD sockets address family. A list of interesting address family mappings include: <table> Address Family | Number ---------------+------- Internet | 2 NetWare | 6 MLC | 22136 </table> The format the fifth and following bytes is dependent on the address family. For the Internet address family, bytes 5 and 6 contain the port number, bytes 7 through 10 contain the IP address, and the following eight bytes are unused. For NetWare, bytes 5 through 8 are the network number, bytes 9 through 14 are the node number, and bytes 15 and 16 are the socket number. Additional information: The length of the binary value is zero if the instance of an object in the rpc-bind-protocol-address array is not in use. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
rpc_bound_protocol_address = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2, 3), OctetString()).setLabel("rpc-bound-protocol-address").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_bound_protocol_address.setStatus('optional')
if mibBuilder.loadTexts: rpc_bound_protocol_address.setDescription('An array of Berkeley sockets style protocol addresses that the NFS service has been bound to successful. The format is that same as the array of RPC-BIND-PROTOCOL-ADDRESS of objects. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
file_system_max_open_files = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 2), Integer32()).setLabel("file-system-max-open-files").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_max_open_files.setStatus('optional')
if mibBuilder.loadTexts: file_system_max_open_files.setDescription('The number of open files allowed at one time. Opening a file when the maximum number of files are currently open will fail. Additional information: Indicates the number of open files a personality (e.g. PCL or PostScript) is guaranteed to be able to open before the file system runs out of file handles. This object is between 1 and 500. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
file_system_set_system_partition_writeable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 6), OctetString()).setLabel("file-system-set-system-partition-writeable").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system_set_system_partition_writeable.setStatus('optional')
if mibBuilder.loadTexts: file_system_set_system_partition_writeable.setDescription('This object allows the system partition to be written to. It consists of a C structure containing the following fields: typedef struct { ubyte <<hidden>>[8]; ubyte volumenumber; } fs_writeable_system_partition_t; which is described below: Bytes 0 - 7: contain the <<hidden>> Byte 8 : is the volume number Access to this command is controlled by the <<hidden>>. If the <<hidden>> supplied is incorrect the command will fail. The volumenumber is a volume number of an existing system partition. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed. Returns <badValue> if the <<hidden>> is incorrect or if the volume requested is not present.')
file_system_set_system_partition_readonly = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 7), Integer32()).setLabel("file-system-set-system-partition-readonly").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system_set_system_partition_readonly.setStatus('optional')
if mibBuilder.loadTexts: file_system_set_system_partition_readonly.setDescription('Changes a system partition to be READ-ONLY. The value is the volume number to change. If the volume number specified is NOT a system partition an error is returned. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed. Returns <badValue> if the volume requested is not present.')
file_system_delete_files = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 8), OctetString()).setLabel("file-system-delete-files").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system_delete_files.setStatus('optional')
if mibBuilder.loadTexts: file_system_delete_files.setDescription('Setting this object causes the specified filename to be deleted, after first validating that the authentication data is correct for the specified user ID. The format for this object is a C structure: typedef struct { sint32 UserId; uint16 AuthenticationDataLen ubyte AuthenticationData[] char Filename[]; } fs_delete_files_t; which is described below: Bytes 0 - 3: contains a user id represented as a multi-byte value that is stored in big-endian format, where the most significant byte occurs first. Bytes 4 - 5 : Length of the Athentication data that follows starting at offset 6. Stored as a multi-byte value that is stored in big-endian format, where the most significant byte occurs first. Bytes 6 - 6+AuthenticationDataLen : a ubyte array containing the Authentication data used to verify access for this operation. Bytes starting at offset (6+AuthenticationDataLen+1): A null terminated character array representing the ASCII file name to be deleted. The length of the string will be limited by the remaining space in the object. This string represents a fully-qualified path name which may specify a filename or a regular expression that may match multiple files (e.g <path>/*.exe). Access to this command is controlled by the UserId and the authentication data. If the UserID or authentication data supplied is incorrect the command will fail. The device POS will specify any limitations to the length of the filename string, what constitutes a correct user ID, what constitutes correct authentication data, and the significance of any return values. Additional information: Setting this object causes the specified filename to be deleted, after first validating that the authentication data is correct for the specified user ID. This object is always present. The format for this object is a C structure: typedef struct { sint32 UserId; uint16 AuthenticationDataLen ubyte AuthenticationData[] char Filename[]; } fs_delete_files_t; Bytes 0 - 3: contains a user id represented as a multi-byte value that is stored in big-endian format, where the most significant byte occurs first. Bytes 4 - 5 : Length of the authentication data that follows starting at offset 6. Stored as a multi-byte value that is stored in big-endian format, where the most significant byte occurs first. Bytes 6 - 6+AuthenticationDataLen : a ubyte array containing the authentication data used to verify access for this operation. Bytes starting at offset (6+AuthenticationDataLen+1): A null terminated character array representing the ASCII file name to be deleted. The length of the string will be limited by the remaining space in the object. This string represents a fully-qualified path name which may specify a filename or a file-type regular expression that may match multiple files (e.g., <path>/*.exe). Access to this command is controlled by the UserId and the authentication data. If the UserID or authentication data supplied is incorrect the command will fail. The device POS will specify any limitations to the length of the filename string, what constitutes a correct user ID, what constitutes correct authentication data, and the significance of any return values.')
file_system_external_access_capabilities = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 10), OctetString()).setLabel("file-system-external-access-capabilities").setMaxAccess("readwrite")
if mibBuilder.loadTexts: file_system_external_access_capabilities.setStatus('optional')
if mibBuilder.loadTexts: file_system_external_access_capabilities.setDescription("This object is used to control access to the file system of the device. It is always readable. It is writable when <<hidden>> is not the empty string, and a successful write to that object with the current <<hidden>> has preceded the write to this object. In other words, the <<hidden>> must be in the 'authenticated state' for a write on FILE-SYSTEM-EXTERNAL-ACCESS-CAPABILITIES to succeed. After the object has successfully been written to, it becomes read-only, and the <<hidden>> object exits the authenticated state. <<hidden>> must then be written to again with the current <<hidden>> in order to make another write operation on FILE-SYSTEM-EXTERNAL-ACCESS-CAPABILITIES possible. cDisablePJLFileSystemAccess - All file system access through PJL will be disabled. cDisablePMLFileSystemWrite - All file-systems-related PML objects such as FILE-SYSTEM-DELETE-FILES or hrPartitionLabel become read-only. For objects that are normally write-only this means that no successful operations can now be performed on them. cDisableNFSFileSystemAccess - All NFS file system access will be disabled. cDisablePSFileSystemAccess - All file system access through PostScript will be disabled. cDisableEWSFileSystemAccess - All access to the file system by the Embedded Web Server will be disabled. ")
file_system_erase_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 11), OctetString()).setLabel("file-system-erase-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: file_system_erase_mode.setStatus('optional')
if mibBuilder.loadTexts: file_system_erase_mode.setDescription('This object is used to control how file data is handled when files are deleted. It is always readable. It is writable when <<hidden>> is the empty string or when a write to <<hidden>> with the current <<hidden>> has preceeded the write to the object. When <<hidden>> is not the empty string then this object becomes read-only after a successful write to it. <<hidden>> must then be written to again with the current <<hidden>> in order to make another write operation on the object possible. If the <<hidden>> is incorrectly set, this object becomes read-only until the <<hidden>> is correctly set. The logical settings for this object are: NonSecureFastErase - When a file is deleted, only the reference to it in the file system tables is removed. No file data is overwritten. This is the default setting. This is the setting when both bits in the collection are set to 0. SecureFastErase - File information is overwritten with identical, random character pattern when it is deleted. This is the setting when cEraseMode0 is set to 1 and cEraseMode1 is set to 0. SecureSanitizeErase - Secure, repetitive algorithm used to overwrite all deleted file information and remove any residual data persistence. A random character is written to all bytes of deleted sectors. Then the complement of that character and finally, another random character is written. This is the setting when cEraseMode0 is set to 0 and cEraseMode1 is set to 1. Note that an error will be returned for an attempt to set both bits of the collection to 1.')
file_system_wipe_disk = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 12), Integer32()).setLabel("file-system-wipe-disk").setMaxAccess("readwrite")
if mibBuilder.loadTexts: file_system_wipe_disk.setStatus('optional')
if mibBuilder.loadTexts: file_system_wipe_disk.setDescription("This object is a non-leaf node which will have one leaf node under it for each file system in the printer. The leaf nodes will be in a 1-to-1 correspondence with the hrDeviceIndex objects. This object specifies for each leaf node whether the file system on the device is going to be erased according to the setting of the FILE-SYSTEM-ERASE-MODE referenced by the corresponding hrDeviceIndex. A file system will be overwritten on system reboot if this object is set to 1. It will be unchanged if this object is set to 0. If this object's value is -1 then the file system cannot be wiped. If the file system contains the permstore, the permstore will be saved off and restored after the file-system wipe is completed. This object is always readable. It is writable when <<hidden>> is the empty string or when a write to <<hidden>> with the current <<hidden>> has preceeded the write to the object. When <<hidden>> is not the empty string then this object becomes read-only after a successful write to it. <<hidden>> must then be written to again with the current <<hidden>> in order to make another write operation on the object possible. If the <<hidden>> is incorrectly set, this object becomes read-only until the <<hidden>> is correctly set.")
file_system_wipe_disk_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 13), Integer32()).setLabel("file-system-wipe-disk-status").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_wipe_disk_status.setStatus('optional')
if mibBuilder.loadTexts: file_system_wipe_disk_status.setDescription('This object is a non-leaf node which will have one leaf node under it for each file system in the printer. The leaf nodes will be in a 1-to-1 correspondence with the hrDeviceIndex objects. This object specifies for each leaf node the status of a disk wipe in progress. A return value of -1 indicates that no disk wipe is in progress. A return value in the range of 0 to 100 indicates the percent done for a disk wipe in progress. All other values are illegal.')
file_system2_initialize_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eInitializing", 2)))).setLabel("file-system2-initialize-volume").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system2_initialize_volume.setStatus('optional')
if mibBuilder.loadTexts: file_system2_initialize_volume.setDescription('Setting this object to eInitializing causes file system 2 to be initialized. Reading this object indicates if the file system is currently being initialized. Additional information: The hrDeviceIndex value for the mass storage device is the same value that is used to index into the FILE-SYSTEM sub-tree. Since this product supports up to 3 physical mass storage device, and since the hrDeviceIndex for the mass storage devices will start at 2 if the mass storage device is installed, the FILE-SYSTEM2-INITIALIZE-VOLUME object will be the object that allows the mass storage device to be initialized that is the 1st device.')
file_system3_initialize_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eInitializing", 2)))).setLabel("file-system3-initialize-volume").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system3_initialize_volume.setStatus('optional')
if mibBuilder.loadTexts: file_system3_initialize_volume.setDescription('Setting this object to eInitializing causes file system 3 to be initialized. Reading this object indicates if the file system is currently being initialized. Additional information: The hrDeviceIndex value for the mass storage device is the same value that is used to index into the FILE-SYSTEM sub-tree. Since this product supports up to 3 physical mass storage device, and since the hrDeviceIndex for the mass storage devices will start at 2 if the mass storage device is installed, the FILE-SYSTEM3-INITIALIZE-VOLUME object will be the object that allows the mass storage device to be initialized that is the 2nd device.')
file_system4_initialize_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eInitializing", 2)))).setLabel("file-system4-initialize-volume").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system4_initialize_volume.setStatus('optional')
if mibBuilder.loadTexts: file_system4_initialize_volume.setDescription('Setting this object to eInitializing causes file system 4 to be initialized. Reading this object indicates if the file system is currently being initialized. Additional information: The hrDeviceIndex value for the mass storage device is the same value that is used to index into the FILE-SYSTEM sub-tree. Since this product supports up to 3 physical mass storage devices, and since the hrDeviceIndex for the mass storage devices will start at 2 if the mass storage device is installed, the FILE-SYSTEM4-INITIALIZE-VOLUME object will be the object that allows the mass storage device to be initialized that is the 3rd device.')
mass_storage_resource_change_counter = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3, 1), Integer32()).setLabel("mass-storage-resource-change-counter").setMaxAccess("readonly")
if mibBuilder.loadTexts: mass_storage_resource_change_counter.setStatus('optional')
if mibBuilder.loadTexts: mass_storage_resource_change_counter.setDescription('A counter which changes when a mass storage based resource has been added or deleted. Additional information: The value of this counter changes each time the MASS-STORAGE-RESOURCE-CHANGED object is set to eTrue. The value also changes when the mass storage device is initialized. However, the value does not change when a mass storage device is removed and a different mass storage device is installed. Initializing all volumes sets this object back to the factory default value. A reboot sets this object back to the factory devalut value. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
mass_storage_resource_changed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eTrue", 2)))).setLabel("mass-storage-resource-changed").setMaxAccess("writeonly")
if mibBuilder.loadTexts: mass_storage_resource_changed.setStatus('optional')
if mibBuilder.loadTexts: mass_storage_resource_changed.setDescription('Setting to eTrue causes MASS-STORAGE-RESOURCE-CHANGE-COUNTER to be incremented. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
ram_disk_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eAuto", 3)))).setLabel("ram-disk-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ram_disk_mode.setStatus('optional')
if mibBuilder.loadTexts: ram_disk_mode.setDescription('Returns or controls RAM disk support. eOFF turns off the RAM disk functionality. eOn turns on the RAM disk functionality and creates a RAM disk whose size is controlled by the RAM-DISK-SIZE object. eAuto turns on the RAM disk functionality and creates a RAM disk size determined by the printer based on installed options and other memory related settings. Additional information: Returns or controls RAM disk support. eOFF turns off the RAM disk functionality. eAuto turns on the RAM disk functionality and creates a RAM disk size determined by the printer based on the amount of installed memory.')
ram_disk_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15, 1, 2), Integer32()).setLabel("ram-disk-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: ram_disk_size.setStatus('optional')
if mibBuilder.loadTexts: ram_disk_size.setDescription('Returns or controls the size of the RAM disk. The device POS specifies the minimum memory requirements. The object MAXIMUM-RAM-DISK-MEMORY specifies the maximum memory available for the RAM disk. Additional information: Returns the size of the RAM disk.')
maximum_ram_disk_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 15, 2, 1), Integer32()).setLabel("maximum-ram-disk-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: maximum_ram_disk_memory.setStatus('optional')
if mibBuilder.loadTexts: maximum_ram_disk_memory.setDescription("This object's name is misleading. This object does not return the maximum configurable RAM disk size. Instead, it returns the maximum amount of memory, in bytes, that can used to increase the size of the RAM disk. Additional information: This object returns the maximum amount of additional memory that is available for increasing the size of the RAM disk.")
mono_color_switching_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eAutoSwitch", 1), ("eMostlyColor", 2), ("eMostlyMono", 3)))).setLabel("mono-color-switching-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: mono_color_switching_mode.setStatus('optional')
if mibBuilder.loadTexts: mono_color_switching_mode.setDescription('This object allows the user to view/change the color/mono switching mode for a device. Additional information: This object allows the user to view/change the color/mono switching mode for a device. The behavior of each setting may vary depending on the device. The value will be stored in NVRAM')
device_configure_printer_parameters = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 32, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setLabel("device-configure-printer-parameters").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_configure_printer_parameters.setStatus('optional')
if mibBuilder.loadTexts: device_configure_printer_parameters.setDescription('Allow the printer to be configured as a duplex or simplex printer. There will be a <<hidden>> encoded in this string and decoded by the printer firmware. If the <<hidden>> check passes the printer will be configured accordingly. Additional information: Used to configure engines for duplex enabled or not. Encoded configuration string is passed in, which is decoded by firmware. Firmware verifies config. string is valid, and retrieves device Configuration data. Expandable to accommodate future products configuration needs.')
job_input_auto_continue_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 3600))).setLabel("job-input-auto-continue-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setDescription('The number of seconds the device waits after a job related continuable error occurs before automatically continuing. An example job related continuable error is the job requesting a media size that is not available. After the timeout expires, the device will continue processing the job as if a continue event occurred, such as the front panel continue key being pressed. If the value is -1, the device does not automatically continue after a job related continuable error occurs. If the value is 0, the device immediately continues. If the value is greater than 0, the value represents the timeout value in seconds. Additional information: The number of seconds the device waits after a job related continuable error occurs before automatically continuing. An example job related continuable error is the job requesting a media size that is not available. After the timeout expires, the device will continue processing the job accourding to the action defined by JOB-INPUT-AUTO-CONTINUE-MODE. If the value is -1, the device does not automatically continue after a job related continuable error occurs. If the value is 0, the device immediately continues. If the value is greater than 0, the value represents the timeout value in seconds. The data for this object is stored in NVRAM.')
job_input_auto_continue_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 36), OctetString()).setLabel("job-input-auto-continue-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_input_auto_continue_mode.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_mode.setDescription('Returns or sets the device behavior when the desired media is not currently available. cCancelJob - The device cancels the job. The device POS should explain what happens if this item is not the only item in the collection. cAutoMediaSizeOverride - The device is allowed to substitute a different size media. cAutoMediaNameOverride - The device is allowed to substitute a different media name. cUSMediaSizeOverride - The device is allowed to substitute US media sizes (letter, etc.) for ISO media sizes (A4, etc.). cISOMediaSizeOverride - The device is allowed to substitute ISO media sizes (A4, etc.) for US media sizes (letter, etc.). Additional information: Returns or sets the device behavior when the desired media is not currently available. cCancelJob - The device cancels the job regardless of other item settings. cAutoMediaSizeOverride - The device is allowed to substitute a different size media. cAutoMediaNameOverride - The device is allowed to substitute a different media name. -- cUSMediaSizeOverride - The device is allowed to substitute -- US media sizes (letter, etc.) for ISO media sizes -- (A4, etc.). -- cISOMediaSizeOverride - The device is allowed to substitute -- ISO media sizes (A4, etc.) for US media sizes -- (letter, etc.). At least one bit of the collection must be set; setting this object to zero will cause a status of <badValue> to be returned. This object describes the action that is performed when the JOB-INPUT-AUTO-CONTINUE-TIMEOUT expires. ')
job_output_auto_continue_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 3600))).setLabel("job-output-auto-continue-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_output_auto_continue_timeout.setStatus('optional')
if mibBuilder.loadTexts: job_output_auto_continue_timeout.setDescription('Returns or sets the time that the printer will wait after an output bin becomes full and the printer is trying to deliver a sheet of media to that output bin. When the timeout expires, the job is processed according to the OUTBINn-OVERRIDE-MODE. A value of -1 indicates that the printer will wait for a continue event. A non-negative value is the number of seconds to wait. Additional information: Returns or sets the time that the printer will wait after an output bin becomes full and the printer is trying to deliver a sheet of media to that output bin. When the timeout expires, the job is processed according to the OUTBINn-OVERRIDE-MODE. A value of -1 indicates that the printer will wait for a continue event. A non- negative value is the number of seconds to wait.')
model_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 1), OctetString()).setLabel("model-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_number.setStatus('optional')
if mibBuilder.loadTexts: model_number.setDescription('Identifies the device model number as listed in the HP corporate price list (e.g. C2121A for DeskJet 500C). The string is as specific as possible. Products should note in POS if the model number on the CPL changes but the device reports the previous model number. If the model number changes based on the installed options, the POS should indicate if only the base model number is returned, or if the device senses the installed options and returns the correct model number. If possible, encode the model number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: Identifies the device model number as listed in the HP corporate price list (e.g. C2121A for DeskJet 500C). The string is as specific as possible. The value of this object does not change based on the installed options. The default of this object is the same on all InkJet printers.')
model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setLabel("model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_name.setStatus('optional')
if mibBuilder.loadTexts: model_name.setDescription("Identifies the device model name (e.g. ''DeskJet 1200C''). The string is as specific as possible. Capitalization and spacing should match family naming conventions. Products should note in POS if the model name on the HP corporate price list changes but the device reports the previous device name. If the model name changes based on the installed options, the POS should indicate if only the base model name is returned, or if the device senses the installed options and returns the correct model name. If possible, encode the model name in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: Since the value of this object is frequently used in displaying a list of printers, it is kept relatively short in case systems have limited width for their display area. The model name does not change based on sensing of installed options.")
formatter_serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 20), OctetString()).setLabel("formatter-serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: formatter_serial_number.setStatus('optional')
if mibBuilder.loadTexts: formatter_serial_number.setDescription('This object returns the formatter serial number for the device. The value returned from this object is the FORMATTERNUMBER system variable. If possible, encode the serial number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: Returns the formatter serial number, prefixed with the PML_UNICODE_PREFIX..')
phd1_diagnostics_nvram_data = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 1, 9), OctetString()).setLabel("phd1-diagnostics-nvram-data").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd1_diagnostics_nvram_data.setStatus('optional')
if mibBuilder.loadTexts: phd1_diagnostics_nvram_data.setDescription('The NVRAM Diagnostics information consist of e-serial number, born-on date, manufacturing date, page counter, finisher counter, jam rate history, event log, and any other device-specific information that the PHD1 stores in NVRAM. This information will be returned as a string with XML format within XML tags. Additional information: The NVRAM Diagnostics information consist of e-serial number, born-on date, manufacturing date, page counter, finisher counter, jam rate history, event log, and any other device-specific information that the PHD2 stores in NVRAM. This information will be returned as a string with XML format within XML tags.')
phd2_model = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 1), OctetString()).setLabel("phd2-model").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_model.setStatus('optional')
if mibBuilder.loadTexts: phd2_model.setDescription('Returns product information identifying PHD device 2. Example: XXXX. Additional information: Returns product information identifying the first paper handling device in the device chaing, PHD device 2. If PDH device 2 does not exist, ERROR-UNKNOWN-OBJECT-IDENTIFIER will be returned.')
phd2_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 2), OctetString()).setLabel("phd2-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: phd2_manufacturing_info.setDescription('Returns information describing the manufacture of PHD 2. May include serial number and firmware revision. Additional information: Returns information describing the manufacture of PHD 2. If PHD 2 does not exist, ERROR-UNKNOWN-OBJECT-IDENTIFIER will be returned.')
phd2_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 10, 11, 13))).clone(namedValues=NamedValues(("eUnknown", 2), ("eInputPHD", 10), ("eOutputPHD", 11), ("eBindingPHD", 13)))).setLabel("phd2-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_type.setStatus('optional')
if mibBuilder.loadTexts: phd2_type.setDescription('Returns an indication of the type of option installed in PHD interface 2. See SIMM1-TYPE for an explanation of the enumerations. Additional information: Returns an indication of the type of option installed in PHD interface 2. If PHD 2 does not exist, ERROR-UNKNOWN-OBJECT-IDENTIFIER will be returned.')
phd2_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 4), Integer32()).setLabel("phd2-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_capacity.setStatus('optional')
if mibBuilder.loadTexts: phd2_capacity.setDescription('Returns an indication of the capacity of the installed option. See SIMM1-CAPACITY for an explanation of the meaning of the value of this object. Additional information: Returns an indication of the capacity of the installed option. For eInputPHD or eOutputPHD, or eBindingPHD the number of input trays or output bins is returned. If PHD 2 does not exist, ERROR-UNKNOWN-OBJECT-IDENTIFIER will be returned.')
default_media_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 22), OctetString()).setLabel("default-media-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_name.setStatus('optional')
if mibBuilder.loadTexts: default_media_name.setDescription('Returns or sets the media name that is used until the media name is changed by a print job command. Additional information: Returns or sets the media name that is used until the media name is changed by a print job command. This string must be one of the MEDIAn-NAME objects. This object is localized if the corresponding MEDIAn-NAME object is localized. The data for this object is stored in NVRAM.')
override_media_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 2), OctetString()).setLabel("override-media-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: override_media_name.setStatus('optional')
if mibBuilder.loadTexts: override_media_name.setDescription('Sets a string identifying the media name that is to be used in place of the currently requested media. The substitution will continue until another media is selected. If set to a named media that is not currently available the requested media is not overridden. Additional information: When a request is received to print on a size and type of media that is not currently available, this object contains the desired media name as set by the print job. This object should be set to a media name that is currently available in the printer. If a paper mount request is not pending, attempting to get or set this object will cause <noSuchName> to be returned. Setting this object to a string other than one of the MEDIAn-NAME objects (MEDIA-NAMES-AVAILABLE is applied) will cause a status of <badValue> to be returned.')
override_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11, 17, 18, 19, 25, 26, 27, 36, 37, 39, 45, 46, 65, 72, 74, 75, 80, 81, 90, 91, 100, 101, 120, 122, 258, 282, 32767))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eROC16K", 17), ("eJISExecutive", 18), ("eROC8K", 19), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eISORA4", 36), ("eISOSRA4", 37), ("eISORA3", 39), ("eJISB5", 45), ("eJISB4", 46), ("eISOB5", 65), ("eJapanesePostcardDouble", 72), ("eIndexCard4x6", 74), ("eIndexCard5x8", 75), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101), ("eTabloidExtra", 120), ("eIndexCard5x7", 122), ("eUSLetterR", 258), ("eISOandJISA4R", 282), ("eUnknownMediaSize", 32767)))).setLabel("override-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: override_media_size.setStatus('optional')
if mibBuilder.loadTexts: override_media_size.setDescription('Sets the media size that is to be used in place of the currently requested media size. Additional information: When a request is received to print on a size and type of media that is not currently available, this object contains the desired size as set by the print job. This object should be set to a media size that is currently available to the printer. If a paper mount request is not pending, attempting to get or set this object will cause <noSuchName> to be returned.')
finisher_image_rotation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 31), OctetString()).setLabel("finisher-image-rotation").setMaxAccess("readwrite")
if mibBuilder.loadTexts: finisher_image_rotation.setStatus('optional')
if mibBuilder.loadTexts: finisher_image_rotation.setDescription('This PML object will provide the additional image rotation that is applied to a printed job depending on the presence or absence of a finisher device or the value of the SVM_ALWAYS_MATCH_OUTPUT_ORIENTATION variable. Additional information: This PML object will provide the additional image rotation that is applied to a printed job depending on the presence or absence of a finisher device and/or the state of the IMAGE ROTATION menu element.')
total_color_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 7), Integer32()).setLabel("total-color-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: total_color_page_count.setStatus('optional')
if mibBuilder.loadTexts: total_color_page_count.setDescription('Total number of color pages printed by the device. Additional information: Total number of color pages printed by the device. The valid range of this object is 0 to 2^24-1. When the number of color pages printed exceeds the maximum color page count, the value will roll to zero. A duplexed sheet of media will cause the counter to be incremented by two.')
duplex_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 22), Integer32()).setLabel("duplex-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: duplex_page_count.setStatus('optional')
if mibBuilder.loadTexts: duplex_page_count.setDescription('Total number of sheets of media that have been duplex printed. A sheet is counted if it travels through the duplex page path, regardless of whether or not marks are made on the page. The POS will indicate if the value is kept in NVRAM. Additional information: Total number of sheets of media that have been duplex printed. A sheet is counted if it travels through the duplex page path, regardless of whether or not marks are made on the page. This value is kept in NVRAM however the NVRAM value is only updated every 10 sheets. NOTE: The value returned by this object will be incremented every sheet but if power is lost between NVRAM updates up to 9 sheets of the count may be lost. The counter will be reset to zero after 16,777,215 (2^24-1) pages. ')
print_engine_revision = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setLabel("print-engine-revision").setMaxAccess("readonly")
if mibBuilder.loadTexts: print_engine_revision.setStatus('optional')
if mibBuilder.loadTexts: print_engine_revision.setDescription('Print engine revision string. Additional information: Print engine revision string. The symbol set for this string is Roman-8. ')
printer_cal_dhalf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 37, 1), Integer32()).setLabel("printer-cal-dhalf-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printer_cal_dhalf_page_count.setStatus('optional')
if mibBuilder.loadTexts: printer_cal_dhalf_page_count.setDescription("Provides the page count when the last DHALF calibration occurred. A '-1' indicates that a calibration of this kind has not taken place yet. This object exists (and is meaningful) only in color printers. Additional information: Provides the page count when last DHALF calibration occurred. A -1 indicates that a calibration of this kind has not taken place yet. This object exists (and is meaningful) only in color printers.")
printer_cal_dhalf_utc = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 37, 2), Integer32()).setLabel("printer-cal-dhalf-utc").setMaxAccess("readonly")
if mibBuilder.loadTexts: printer_cal_dhalf_utc.setStatus('optional')
if mibBuilder.loadTexts: printer_cal_dhalf_utc.setDescription('Provides the time (in UTC - Universal Time Code format) when the last DHALF calibration occurred. This value could be zero if no calibration has taken place or if the printer lacked real-time. This object exists (and is meaningful) only in color printers. Additional information: Provides the time (in UTC - Universal Time Code format) when last DHALF calibration occurred. This value could be zero if no calibration has taken place and / or if the printer lacked real-time. This object exists (and is meaningful) only in color printers.')
printer_cal_cpr_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 38, 1), Integer32()).setLabel("printer-cal-cpr-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: printer_cal_cpr_page_count.setStatus('optional')
if mibBuilder.loadTexts: printer_cal_cpr_page_count.setDescription("Provides the page count when last CPR calibration occurred. A '-1' indicates that a calibration of this kind has not taken place yet. This object exists (and is meaningful) only in color printers. Additional information: Provides the page count when last CPR calibration occurred. A -1 indicates that a calibration of this kind has not taken place yet. This object exists (and is meaningful) only in color printers.")
printer_cal_cpr_utc = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 38, 2), Integer32()).setLabel("printer-cal-cpr-utc").setMaxAccess("readonly")
if mibBuilder.loadTexts: printer_cal_cpr_utc.setStatus('optional')
if mibBuilder.loadTexts: printer_cal_cpr_utc.setDescription('Provides the time (in UTC - Universal Time Code format) when the last CPR calibration occurred. This value could be zero if no calibration has taken place or if the printer lacked real-time. This object exists (and is meaningful) only in color printers. Additional information: Provides the time (in UTC - Universal Time Code format) when last CPR calibration occurred. This value could be zero if no calibration has taken place and / or if the printer lacked real-time. This object exists (and is meaningful) only in color printers.')
input_tray_auto_select = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("input-tray-auto-select").setMaxAccess("readwrite")
if mibBuilder.loadTexts: input_tray_auto_select.setStatus('optional')
if mibBuilder.loadTexts: input_tray_auto_select.setDescription('Indicates if the device will automatically try to load media from the next input media tray in the auto-select sequence (defined by each device) when it cannot load media from the current tray. Locked trays will not be permitted in the auto-select sequence. This object has no meaning if there is only one unlocked input media tray. Additional information: Indicates if the device will automatically try to load media from the next input media tray in the auto-select sequence (defined by each device) when it cannot load media from the current tray. Locked trays will not be permitted in the auto-select sequence. This object has no meaning if there is only one unlocked input media tray.')
custom_paper_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 8), Integer32()).setLabel("custom-paper-feed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_feed_dim.setDescription("Sets the printer's custom paper dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: Get/Set custom paper dimension (height). The return/set value is either in micrometers or 10,000ths of inches. A tray has to be in custom switch or without media size sensor to be able to set the custom dimension. If it is successfully setting the dimension value, the size of a tray is set to CUSTOM. If the current XFeed value is greater than the new Feed value, the firmware will silently set the XFeed to match the new Feed value.")
custom_paper_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 9), Integer32()).setLabel("custom-paper-xfeed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setDescription("Sets the printer's custom paper dimension in the cross-feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: Get/Set custom paper dimension (width). The return/set value is either in micrometers or 10,000ths of inches. A tray has to be in custom switch or without media size sensor to be able to set the custom dimension. If it is successfully setting the dimension value, the size of a tray is set to CUSTOM. If the new XFeed Dim is greater than the current Feed Dim, INVALID_OR_UNSUPPORTED_VALUE is returned.")
default_custom_paper_dim_unit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("eTenThousandthsOfInches", 3), ("eMicrometers", 4)))).setLabel("default-custom-paper-dim-unit").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_custom_paper_dim_unit.setStatus('optional')
if mibBuilder.loadTexts: default_custom_paper_dim_unit.setDescription("The units of measure used to specify the width and height of the printer's default custom paper size. The unit of measure of eTenThousandthsOfInches is 0.0001 inches. Additional information: The units of measure used to specify the width and height of the printer's default custom paper size. The unit of measure of eTenThousandthsOfInches is 0.0001 inches.")
default_custom_paper_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 11), Integer32()).setLabel("default-custom-paper-feed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_custom_paper_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: default_custom_paper_feed_dim.setDescription("Sets the printer's default custom paper size dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of DEFAULT-CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: Sets the printer's default custom paper size dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of DEFAULT-CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product.")
default_custom_paper_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 12), Integer32()).setLabel("default-custom-paper-xfeed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_custom_paper_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: default_custom_paper_xfeed_dim.setDescription("Sets the printer's default custom paper size dimension in the cross-feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of DEFAULT-CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: Sets the printer's default custom paper size dimension in the cross-feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of DEFAULT-CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product.")
input_tray_max_media_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 14), Integer32()).setLabel("input-tray-max-media-feed-dim").setMaxAccess("readonly")
if mibBuilder.loadTexts: input_tray_max_media_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: input_tray_max_media_feed_dim.setDescription("The maximum physical media size in the feed direction of this input device expressed in units of measure specified by INPUT- TRAY-MIN-MAX-DIM-UNIT. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Additional information: The maximum physical media size in the feed direction of this input device expressed in units of measure specified by PrtInputDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://bldlabs.boi.hp.com/BLDPrinterLab/Project/PrinterManagement, for more details in the original format of the Standard Printer MIB.")
input_tray_max_media_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 15), Integer32()).setLabel("input-tray-max-media-xfeed-dim").setMaxAccess("readonly")
if mibBuilder.loadTexts: input_tray_max_media_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: input_tray_max_media_xfeed_dim.setDescription("The maximum physical media size across the feed direction of a particular input device expressed in units of measure specified by INPUT-TRAY-MIN-MAX-DIM-UNIT. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Additional information: The maximum physical media size across the feed direction of this input device expressed in units of measure specified by PrtInputDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://bldlabs.boi.hp.com/BLDPrinterLab/Project/PrinterManagement, f or more details in the original format of the Standard Printer MIB.")
input_tray_min_media_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 16), Integer32()).setLabel("input-tray-min-media-feed-dim").setMaxAccess("readonly")
if mibBuilder.loadTexts: input_tray_min_media_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: input_tray_min_media_feed_dim.setDescription("The minimum physical media size in the feed direction of a particular input device expressed in units of measure specified by PrtInputMinMaxDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Additional information: The minimum physical media size in the feed direction of this input device expressed in units of measure specified by PrtInputDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://bldlabs.boi.hp.com/BLDPrinterLab/Project/PrinterManagement, for more details in the original format of the Standard Printer MIB.")
input_tray_min_media_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 17), Integer32()).setLabel("input-tray-min-media-xfeed-dim").setMaxAccess("readonly")
if mibBuilder.loadTexts: input_tray_min_media_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: input_tray_min_media_xfeed_dim.setDescription("The minimum physical media size across the feed direction of a particular input device expressed in units of measure specified by PrtInputMinMaxDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Additional information: The minimum physical media size across the feed direction of this input device expressed in units of measure specified by PrtInputDimUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://bldlabs.boi.hp.com/BLDPrinterLab/Project/PrinterManagement, for more details in the original format of the Standard Printer MIB.")
tray1_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 15, 17, 19, 25, 26, 27, 36, 37, 39, 44, 45, 46, 74, 75, 101, 120, 122, 32764, 32765))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eLedger", 11), ("eStatement", 15), ("eROC16K", 17), ("eROC8K", 19), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eISORA4", 36), ("eISOSRA4", 37), ("eISORA3", 39), ("eJISB6", 44), ("eJISB5", 45), ("eJISB4", 46), ("eIndexCard4x6", 74), ("eIndexCard5x8", 75), ("eCustom", 101), ("eTabloidExtra", 120), ("eIndexCard5x7", 122), ("eAnyCustomSize", 32764), ("eAnySize", 32765)))).setLabel("tray1-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray1_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray1_media_size_loaded.setDescription("Returns the media size that is currently configuredconfigured in tray #1. This object can be set to indicate the media size currently loaded, if the printer supports input trays that can not sense the media size. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configuredconfigured in tray #1. This object can be set to indicate the media size currently loaded, if the printer supports input trays that can not sense the media size. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document.")
tray1_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 12), Integer32()).setLabel("tray1-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray1_phd.setStatus('optional')
if mibBuilder.loadTexts: tray1_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray. Additional information: Provides the number of the Paper Handling Device that contains this input tray.')
tray2_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 15, 25, 26, 27, 45, 46))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eLedger", 11), ("eStatement", 15), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eJISB5", 45), ("eJISB4", 46)))).setLabel("tray2-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray2_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray2_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #2. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configured in tray #2.")
tray2_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2, 12), Integer32()).setLabel("tray2-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray2_phd.setStatus('optional')
if mibBuilder.loadTexts: tray2_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray. Additional information: Provides the number of the Paper Handling Device that contains this input tray.')
tray3_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 15, 25, 26, 27, 45, 46))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eLedger", 11), ("eStatement", 15), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eJISB5", 45), ("eJISB4", 46)))).setLabel("tray3-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray3_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray3_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #3. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configured in tray #3.")
tray3_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3, 12), Integer32()).setLabel("tray3-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray3_phd.setStatus('optional')
if mibBuilder.loadTexts: tray3_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray. Additional information: Provides the number of the Paper Handling Device that contains this input tray.')
tray5_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("tray5-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray5_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray5_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #5. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configured in tray #5.")
tray5_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 5, 12), Integer32()).setLabel("tray5-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray5_phd.setStatus('optional')
if mibBuilder.loadTexts: tray5_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray. Additional information: Provides the number of the Paper Handling Device that contains this input tray.')
tray6_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("tray6-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray6_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray6_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #5. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configured in tray #5.")
tray6_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 6, 12), Integer32()).setLabel("tray6-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray6_phd.setStatus('optional')
if mibBuilder.loadTexts: tray6_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray. Additional information: Provides the number of the Paper Handling Device that contains this input tray.')
overflow_bin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 1, 4), Integer32()).setLabel("overflow-bin").setMaxAccess("readwrite")
if mibBuilder.loadTexts: overflow_bin.setStatus('optional')
if mibBuilder.loadTexts: overflow_bin.setDescription('Returns or sets the bin that will be used for additional sheets of media when the current bin is full and printing is allowed to continue. Additional information: Returns or sets the bin that will be used for additional sheets of media when the current bin is full and printing is allowed to continue. The data for this object is stored in NVRAM.')
outbin1_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1, 9), OctetString()).setLabel("outbin1-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin1_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin1_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job, regardless of other bit settings. cOutbinFullOverride - The device sends subsequent media to the overflow bin. If this bin is the overflow bin, this bit is ignored. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait).')
outbin1_maximum_binding = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1, 10), Integer32()).setLabel("outbin1-maximum-binding").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin1_maximum_binding.setStatus('optional')
if mibBuilder.loadTexts: outbin1_maximum_binding.setDescription('The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE. Additional information: The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE.')
outbin1_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1, 11), Integer32()).setLabel("outbin1-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin1_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin1_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin. Additional information: Provides the number of the Paper Handling Device that contains this output bin.')
outbin1_error_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1, 12), OctetString()).setLabel("outbin1-error-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin1_error_info.setStatus('optional')
if mibBuilder.loadTexts: outbin1_error_info.setDescription("A device specific description of the last error encountered for output bin 1. Each POS should document the meaning of all supported error information. Additional information: This is a description of the current error state of a finishing device. (ie stapler). If the bin does not support any finishing capabilities then the object will return <badValue>. The possible return values are as follows: Byte1, Byte2, and Byte3 should be 0x00. as they are reserved for future use. Byte4 is a bit field that can be interpreted as follows: bit 0 - unused bit 1 - eBinderOut Out of staples bit 2 - eBinderLimit Too many pages to finish bit 3 - eBinderJam Staple jammed in stapler bit 4 - eBinderAlign Pages aren't aligned correctly to finish. bit 5 - unused bit 6 - unused bit 7 - unused NOTE: Because HP is marketing a device with a max of 16 bins the OUTBIN-MAXIMUM-BINDING objects are 3-18 but the external device specification requires support of up to 315 output bins. Therefore if these bins exist above 16, then the coresponding objects will also exist OUTBIN19-MAXIMUM-BINDING ... OUTBIN317-MAXIMUM-BINDING")
outbin2_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2, 9), OctetString()).setLabel("outbin2-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin2_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin2_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job, regardless of other bit settings. cOutbinFullOverride - The device sends subsequent media to the overflow bin. If this bin is the overflow bin, this bit is ignored. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait).')
outbin2_maximum_binding = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2, 10), Integer32()).setLabel("outbin2-maximum-binding").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin2_maximum_binding.setStatus('optional')
if mibBuilder.loadTexts: outbin2_maximum_binding.setDescription('The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE. Additional information: The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE.')
outbin2_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2, 11), Integer32()).setLabel("outbin2-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin2_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin2_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin. Additional information: Provides the number of the Paper Handling Device that contains this output bin.')
outbin2_error_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2, 12), OctetString()).setLabel("outbin2-error-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin2_error_info.setStatus('optional')
if mibBuilder.loadTexts: outbin2_error_info.setDescription("A device specific description of the last error encountered for output bin 2. Each POS should document the meaning of all supported error information. Additional information: This is a description of the current error state of a finishing device. (ie stapler). If the bin does not support any finishing capabilities then the object will return <badValue>. The possible return values are as follows: Byte1, Byte2, and Byte3 should be 0x00. as they are reserved for future use. Byte4 is a bit field that can be interpreted as follows: bit 0 - unused bit 1 - eBinderOut Out of staples bit 2 - eBinderLimit Too many pages to finish bit 3 - eBinderJam Staple jammed in stapler bit 4 - eBinderAlign Pages aren't aligned correctly to finish. bit 5 - unused bit 6 - unused bit 7 - unused NOTE: Because HP is marketing a device with a max of 16 bins the OUTBIN-MAXIMUM-BINDING objects are 3-18 but the external device specification requires support of up to 315 output bins. Therefore if these bins exist above 16, then the coresponding objects will also exist OUTBIN19-MAXIMUM-BINDING ... OUTBIN317-MAXIMUM-BINDING")
outbin3_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 9), OctetString()).setLabel("outbin3-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin3_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin3_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job, regardless of other bit settings. cOutbinFullOverride - The device sends subsequent media to the overflow bin. If this bin is the overflow bin, this bit is ignored. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait).')
outbin3_maximum_binding = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 10), Integer32()).setLabel("outbin3-maximum-binding").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin3_maximum_binding.setStatus('optional')
if mibBuilder.loadTexts: outbin3_maximum_binding.setDescription('The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE. Additional information: The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE.')
outbin3_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 11), Integer32()).setLabel("outbin3-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin3_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin3_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin. Additional information: Provides the number of the Paper Handling Device that contains this output bin.')
outbin3_error_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 12), OctetString()).setLabel("outbin3-error-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin3_error_info.setStatus('optional')
if mibBuilder.loadTexts: outbin3_error_info.setDescription("A device specific description of the last error encountered for output bin 3. Each POS should document the meaning of all supported error information. Additional information: This is a description of the current error state of a finishing device. (ie stapler). If the bin does not support any finishing capabilities then the object will return <badValue>. The possible return values are as follows: Byte1, Byte2, and Byte3 should be 0x00. as they are reserved for future use. Byte4 is a bit field that can be interpreted as follows: bit 0 - unused bit 1 - eBinderOut Out of staples bit 2 - eBinderLimit Too many pages to finish bit 3 - eBinderJam Staple jammed in stapler bit 4 - eBinderAlign Pages aren't aligned correctly to finish. bit 5 - unused bit 6 - unused bit 7 - unused NOTE: Because HP is marketing a device with a max of 16 bins the OUTBIN-MAXIMUM-BINDING objects are 3-18 but the external device specification requires support of up to 315 output bins. Therefore if these bins exist above 16, then the coresponding objects will also exist OUTBIN19-MAXIMUM-BINDING ... OUTBIN317-MAXIMUM-BINDING")
outbin4_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 9), OctetString()).setLabel("outbin4-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin4_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin4_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job, regardless of other bit settings. cOutbinFullOverride - The device sends subsequent media to the overflow bin. If this bin is the overflow bin, this bit is ignored. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait).')
outbin4_maximum_binding = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 10), Integer32()).setLabel("outbin4-maximum-binding").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin4_maximum_binding.setStatus('optional')
if mibBuilder.loadTexts: outbin4_maximum_binding.setDescription('The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE. Additional information: The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE.')
outbin4_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 11), Integer32()).setLabel("outbin4-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin4_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin4_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin. Additional information: Provides the number of the Paper Handling Device that contains this output bin.')
outbin4_error_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 12), OctetString()).setLabel("outbin4-error-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin4_error_info.setStatus('optional')
if mibBuilder.loadTexts: outbin4_error_info.setDescription("A device specific description of the last error encountered for output bin 4. Each POS should document the meaning of all supported error information. Additional information: This is a description of the current error state of a finishing device. (ie stapler). If the bin does not support any finishing capabilities then the object will return <badValue>. The possible return values are as follows: Byte1, Byte2, and Byte3 should be 0x00. as they are reserved for future use. Byte4 is a bit field that can be interpreted as follows: bit 0 - unused bit 1 - eBinderOut Out of staples bit 2 - eBinderLimit Too many pages to finish bit 3 - eBinderJam Staple jammed in stapler bit 4 - eBinderAlign Pages aren't aligned correctly to finish. bit 5 - unused bit 6 - unused bit 7 - unused NOTE: Because HP is marketing a device with a max of 16 bins the OUTBIN-MAXIMUM-BINDING objects are 3-18 but the external device specification requires support of up to 315 output bins. Therefore if these bins exist above 16, then the coresponding objects will also exist OUTBIN19-MAXIMUM-BINDING ... OUTBIN317-MAXIMUM-BINDING")
outbin5_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 9), OctetString()).setLabel("outbin5-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin5_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin5_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job, regardless of other bit settings. cOutbinFullOverride - The device sends subsequent media to the overflow bin. If this bin is the overflow bin, this bit is ignored. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait).')
outbin5_maximum_binding = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 10), Integer32()).setLabel("outbin5-maximum-binding").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin5_maximum_binding.setStatus('optional')
if mibBuilder.loadTexts: outbin5_maximum_binding.setDescription('The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE. Additional information: The maximum number of sheets of 20 pound paper that can be bound by the binding device that serves this output bin. If a job exceeds this number and the job has requested binding, cBindingError will be set in NOT- READY-DESTINATION-PRINT-ENGINE.')
outbin5_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 11), Integer32()).setLabel("outbin5-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin5_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin5_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin. Additional information: Provides the number of the Paper Handling Device that contains this output bin.')
outbin5_error_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 12), OctetString()).setLabel("outbin5-error-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin5_error_info.setStatus('optional')
if mibBuilder.loadTexts: outbin5_error_info.setDescription("A device specific description of the last error encountered for output bin 5. Each POS should document the meaning of all supported error information. Additional information: This is a description of the current error state of a finishing device. (ie stapler). If the bin does not support any finishing capabilities then the object will return <badValue>. The possible return values are as follows: Byte1, Byte2, and Byte3 should be 0x00. as they are reserved for future use. Byte4 is a bit field that can be interpreted as follows: bit 0 - unused bit 1 - eBinderOut Out of staples bit 2 - eBinderLimit Too many pages to finish bit 3 - eBinderJam Staple jammed in stapler bit 4 - eBinderAlign Pages aren't aligned correctly to finish. bit 5 - unused bit 6 - unused bit 7 - unused NOTE: Because HP is marketing a device with a max of 16 bins the OUTBIN-MAXIMUM-BINDING objects are 3-18 but the external device specification requires support of up to 315 output bins. Therefore if these bins exist above 16, then the coresponding objects will also exist OUTBIN19-MAXIMUM-BINDING ... OUTBIN317-MAXIMUM-BINDING")
phd2_device_specific_command = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 2, 2), OctetString()).setLabel("phd2-device-specific-command").setMaxAccess("writeonly")
if mibBuilder.loadTexts: phd2_device_specific_command.setStatus('optional')
if mibBuilder.loadTexts: phd2_device_specific_command.setDescription('This object is used to send device-specific data to the paper handling device. The meaning of the device-specific command is dependent on the paper handling device and must be specified in the POS. If the paper handling device does not accept the command, then an <badValue> will be returned. If the device accepts the command, it may still be processing the command after the response has been returned. Depending on the device, the application may need to query PHDx-DEVICE-MEMORY to see when the command has completed. Additional information: This object is used to send device-specific data to the paper handling device. The meaning of the device- specific command is dependent on the paper handling device and must be specified in the POS. If the paper handling device does not accept the command, then an <badValue> will be returned. If the device accepts the command, it may still be processing the command after the response has been returned. Depending on the device, the application may need to query PHDx-DEVICE-MEMORY to see when the command has completed.')
media_names_available = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 1, 1), OctetString()).setLabel("media-names-available").setMaxAccess("readwrite")
if mibBuilder.loadTexts: media_names_available.setStatus('optional')
if mibBuilder.loadTexts: media_names_available.setDescription('The value of this object controls which of the MEDIAx-NAME objects are supported. If a bit is set to zero, then attempting to get or set the corresponding MEDIAx-NAME objects will return <noSuchName>. Additional information: Setting a bit to one will cause the corresponding MEDIAn- objects to be available (attempting to access an unavailable object will return <noSuchName>). MEDIA1- objects are always present, as this is the default media. If this object is set to a value that does not include cMediaName2Available, that bit will be set and a status of <noError> will be returned.')
north_edge_offset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 1, 2), Integer32()).setLabel("north-edge-offset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: north_edge_offset.setStatus('optional')
if mibBuilder.loadTexts: north_edge_offset.setDescription('Returns or sets the number of 300 dpi dots by which the image is shifted. Shift is relative to the leading edge of the medium as the medium flows through the marking engine with the side to be imaged facing the observer. The leading edge is the North edge and the other edges are defined by the normal compass layout of directions with the compass facing the observer. The adjustment is for all pages printed. A positive value moves the image away from the leading edge of the medium. A negative value moves the image closer to the leading edge of the medium. The value 0 will return the image to its factory default position. Additional information: Returns or sets the number of 300 dpi dots by which the image is shifted. Shift is relative to the leading edge of the medium as the medium flows through the marking engine with the side to be imaged facing the observer. The leading edge is the North edge and the other edges are defined by the normal compass layout of directions with the compass facing the ob server. The adjustment is for all pages printed. A positive value moves the image away from the leading edge of the medium. A negative value moves the image closer to the leading edge of the medium. The value 0 will return the image to its factory default position. The value of this object is stored in NVRAM.')
media1_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media1-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_name.setStatus('optional')
if mibBuilder.loadTexts: media1_name.setDescription('Media 1 name. Additional information: The order of these objects is determined by the order of SysOD_MediaTypeEnum. The symbol set for this string is Roman-8. ')
media1_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media1-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_short_name.setStatus('optional')
if mibBuilder.loadTexts: media1_short_name.setDescription("Length restricted version of the media name 1. The length restriction is required to allow the media name to be displayed on the device's control panel. The device POS must state the maximum number of characters allowed. If the device also has a limitation on what characters in a character set can be used (e.g. only uppercase characters allowed), the POS should also state character restrictions. Additional information: The order of these objects is determined by the order of SysOD_MediaTypeEnum. Length restricted version of the media name 1. The length restriction is required to allow the media name to be displayed on the device's control panel. The maximum supported string length is 9 characters. If the user entered string is too long, the device will store the first 9 characters and will return the <noError> status. The characters must be in the range 20H to 7FH except 5C cannot be used. The default symbol set is Roman-8 for English; additional legal symbol sets are ISOLatin5, ISOLatin2 and Windows31J. Setting this object with characters outside of the range or of an illegal symbol set will cause an error status of <badValue> to be returned. This string is localized according to prtConsoleLocalization. If this object represents a standard type, and the user attempts to set the object, 'OK Nearest Legal Value Substituted' will be returned, and the standard value is retained. If this object represents a user defined type, and the user attempts to set the object, then the set will be successfull.")
media1_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 3), Integer32()).setLabel("media1-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_page_count.setStatus('optional')
if mibBuilder.loadTexts: media1_page_count.setDescription('Number of sheets of media 1 that have been printed. The device POS should state whether this value is lost across a power cycle or kept in NVRAM. Additional information: Number of sheets of media 1 that have been printed. This page count is saved in NVRAM after every 10 pages. The maximum value is 4,294,967,295 which will never be reached in normal operation. The page count is incremented when a sheet of media is pulled from an input tray. A duplex printed sheet will cause this counter to be incremented by one.')
media2_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media2-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_name.setStatus('optional')
if mibBuilder.loadTexts: media2_name.setDescription('Media 2 name. Additional information: See MEDIA1-NAME.')
media2_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media2-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_short_name.setStatus('optional')
if mibBuilder.loadTexts: media2_short_name.setDescription('Length restricted version of the media name 2. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media2_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 3), Integer32()).setLabel("media2-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_page_count.setStatus('optional')
if mibBuilder.loadTexts: media2_page_count.setDescription('Number of sheets of media 2 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media3_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media3-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_name.setStatus('optional')
if mibBuilder.loadTexts: media3_name.setDescription('Media 3 name. Additional information: See MEDIA1-NAME.')
media3_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media3-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_short_name.setStatus('optional')
if mibBuilder.loadTexts: media3_short_name.setDescription('Length restricted version of the media name 3. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media3_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 3), Integer32()).setLabel("media3-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_page_count.setStatus('optional')
if mibBuilder.loadTexts: media3_page_count.setDescription('Number of sheets of media 3 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media4_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media4-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_name.setStatus('optional')
if mibBuilder.loadTexts: media4_name.setDescription('Media 4 name. Additional information: See MEDIA1-NAME.')
media4_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media4-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_short_name.setStatus('optional')
if mibBuilder.loadTexts: media4_short_name.setDescription('Length restricted version of the media name 4. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media4_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 3), Integer32()).setLabel("media4-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_page_count.setStatus('optional')
if mibBuilder.loadTexts: media4_page_count.setDescription('Number of sheets of media 4 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media5_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media5-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_name.setStatus('optional')
if mibBuilder.loadTexts: media5_name.setDescription('Media 5 name. Additional information: See MEDIA1-NAME.')
media5_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media5-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_short_name.setStatus('optional')
if mibBuilder.loadTexts: media5_short_name.setDescription('Length restricted version of the media name 5. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media5_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 3), Integer32()).setLabel("media5-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_page_count.setStatus('optional')
if mibBuilder.loadTexts: media5_page_count.setDescription('Number of sheets of media 5 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media6_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media6-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_name.setStatus('optional')
if mibBuilder.loadTexts: media6_name.setDescription('Media 6 name. Additional information: See MEDIA1-NAME.')
media6_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media6-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_short_name.setStatus('optional')
if mibBuilder.loadTexts: media6_short_name.setDescription('Length restricted version of the media name 6. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media6_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 3), Integer32()).setLabel("media6-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_page_count.setStatus('optional')
if mibBuilder.loadTexts: media6_page_count.setDescription('Number of sheets of media 6 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media7_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media7-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_name.setStatus('optional')
if mibBuilder.loadTexts: media7_name.setDescription('Media 7 name. Additional information: See MEDIA1-NAME.')
media7_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media7-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_short_name.setStatus('optional')
if mibBuilder.loadTexts: media7_short_name.setDescription('Length restricted version of the media name 7. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media7_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 3), Integer32()).setLabel("media7-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_page_count.setStatus('optional')
if mibBuilder.loadTexts: media7_page_count.setDescription('Number of sheets of media 7 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media8_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media8-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_name.setStatus('optional')
if mibBuilder.loadTexts: media8_name.setDescription('Media 8 name. Additional information: See MEDIA1-NAME.')
media8_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media8-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_short_name.setStatus('optional')
if mibBuilder.loadTexts: media8_short_name.setDescription('Length restricted version of the media name 8. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media8_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 3), Integer32()).setLabel("media8-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_page_count.setStatus('optional')
if mibBuilder.loadTexts: media8_page_count.setDescription('Number of sheets of media 8 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media9_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media9-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_name.setStatus('optional')
if mibBuilder.loadTexts: media9_name.setDescription('Media 9 name. Additional information: See MEDIA1-NAME.')
media9_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media9-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_short_name.setStatus('optional')
if mibBuilder.loadTexts: media9_short_name.setDescription('Length restricted version of the media name 9. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media9_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 3), Integer32()).setLabel("media9-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_page_count.setStatus('optional')
if mibBuilder.loadTexts: media9_page_count.setDescription('Number of sheets of media 9 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media10_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media10-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_name.setStatus('optional')
if mibBuilder.loadTexts: media10_name.setDescription('Media 10 name. Additional information: See MEDIA1-NAME.')
media10_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media10-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_short_name.setStatus('optional')
if mibBuilder.loadTexts: media10_short_name.setDescription('Length restricted version of the media name 10. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media10_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 3), Integer32()).setLabel("media10-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_page_count.setStatus('optional')
if mibBuilder.loadTexts: media10_page_count.setDescription('Number of sheets of media 10 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media11_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media11-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_name.setStatus('optional')
if mibBuilder.loadTexts: media11_name.setDescription('Media 11 name. Additional information: See MEDIA1-NAME.')
media11_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media11-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_short_name.setStatus('optional')
if mibBuilder.loadTexts: media11_short_name.setDescription('Length restricted version of the media name 11. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media11_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 3), Integer32()).setLabel("media11-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_page_count.setStatus('optional')
if mibBuilder.loadTexts: media11_page_count.setDescription('Number of sheets of media 11 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media12_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media12-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_name.setStatus('optional')
if mibBuilder.loadTexts: media12_name.setDescription('Media 12 name. Additional information: See MEDIA1-NAME.')
media12_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media12-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_short_name.setStatus('optional')
if mibBuilder.loadTexts: media12_short_name.setDescription('Length restricted version of the media name 12. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media12_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 3), Integer32()).setLabel("media12-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_page_count.setStatus('optional')
if mibBuilder.loadTexts: media12_page_count.setDescription('Number of sheets of media 12 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media13_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media13-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_name.setStatus('optional')
if mibBuilder.loadTexts: media13_name.setDescription('Media 13 name. Additional information: See MEDIA1-NAME.')
media13_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media13-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_short_name.setStatus('optional')
if mibBuilder.loadTexts: media13_short_name.setDescription('Length restricted version of the media name 13. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media13_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 3), Integer32()).setLabel("media13-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_page_count.setStatus('optional')
if mibBuilder.loadTexts: media13_page_count.setDescription('Number of sheets of media 13 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media14_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media14-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_name.setStatus('optional')
if mibBuilder.loadTexts: media14_name.setDescription('Media 14 name. Additional information: See MEDIA1-NAME.')
media14_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media14-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_short_name.setStatus('optional')
if mibBuilder.loadTexts: media14_short_name.setDescription('Length restricted version of the media name 14. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media14_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 3), Integer32()).setLabel("media14-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_page_count.setStatus('optional')
if mibBuilder.loadTexts: media14_page_count.setDescription('Number of sheets of media 14 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media15_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media15-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_name.setStatus('optional')
if mibBuilder.loadTexts: media15_name.setDescription('Media 15 name. Additional information: See MEDIA1-NAME.')
media15_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media15-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_short_name.setStatus('optional')
if mibBuilder.loadTexts: media15_short_name.setDescription('Length restricted version of the media name 15. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media15_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 3), Integer32()).setLabel("media15-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_page_count.setStatus('optional')
if mibBuilder.loadTexts: media15_page_count.setDescription('Number of sheets of media 15 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media16_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 16, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media16-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media16_name.setStatus('optional')
if mibBuilder.loadTexts: media16_name.setDescription('Media 16 name. Additional information: See MEDIA1-NAME.')
media16_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 16, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media16-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media16_short_name.setStatus('optional')
if mibBuilder.loadTexts: media16_short_name.setDescription('Length restricted version of the media name 16. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media16_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 16, 3), Integer32()).setLabel("media16-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media16_page_count.setStatus('optional')
if mibBuilder.loadTexts: media16_page_count.setDescription('Number of sheets of media 16 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media17_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 17, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media17-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media17_name.setStatus('optional')
if mibBuilder.loadTexts: media17_name.setDescription('Media 17 name. Additional information: See MEDIA1-NAME.')
media17_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 17, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media17-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media17_short_name.setStatus('optional')
if mibBuilder.loadTexts: media17_short_name.setDescription('Length restricted version of the media name 17. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media17_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 17, 3), Integer32()).setLabel("media17-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media17_page_count.setStatus('optional')
if mibBuilder.loadTexts: media17_page_count.setDescription('Number of sheets of media 17 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media18_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 18, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media18-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media18_name.setStatus('optional')
if mibBuilder.loadTexts: media18_name.setDescription('Media 18 name. Additional information: See MEDIA1-NAME.')
media18_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 18, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media18-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media18_short_name.setStatus('optional')
if mibBuilder.loadTexts: media18_short_name.setDescription('Length restricted version of the media name 18. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media18_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 18, 3), Integer32()).setLabel("media18-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media18_page_count.setStatus('optional')
if mibBuilder.loadTexts: media18_page_count.setDescription('Number of sheets of media 18 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media19_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 19, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setLabel("media19-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media19_name.setStatus('optional')
if mibBuilder.loadTexts: media19_name.setDescription('Media 19 name. Additional information: See MEDIA1-NAME.')
media19_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 19, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 9))).setLabel("media19-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media19_short_name.setStatus('optional')
if mibBuilder.loadTexts: media19_short_name.setDescription('Length restricted version of the media name 19. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media19_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 19, 3), Integer32()).setLabel("media19-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media19_page_count.setStatus('optional')
if mibBuilder.loadTexts: media19_page_count.setDescription('Number of sheets of media 19 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media_number_of_type_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 8, 1), Integer32()).setLabel("media-number-of-type-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: media_number_of_type_supported.setStatus('optional')
if mibBuilder.loadTexts: media_number_of_type_supported.setDescription('Indicates the maximum number of supported media types. Additional information: Indicates the number of supported media type. This also indicates which bit in MEDIA-NAMES-AVAILABLE is significant')
non_assured_oht_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 7, 1), Integer32()).setLabel("non-assured-oht-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: non_assured_oht_page_count.setStatus('optional')
if mibBuilder.loadTexts: non_assured_oht_page_count.setDescription('This is a count of the number of invalid (non-HP Laser Jet) transparencies that have been printed on. This value is incremented every time an invalid OHT is printed on It is reset whenever the fuser count is set to 0. Additional information: This is a count of the number of invalid (non HP Laser Jet) transparencies that have been printed on. This value is incremented every time an invalid OHT is printed on. It is reset whenever the fuser count is set to 0.')
media_size_west_edge_first_side_offset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 5, 2), Integer32()).setLabel("media-size-west-edge-first-side-offset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: media_size_west_edge_first_side_offset.setStatus('optional')
if mibBuilder.loadTexts: media_size_west_edge_first_side_offset.setDescription('Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). The adjustment is for the first printed side of the medium only. A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. Additional information: Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). The adjustment is for the first printed side of the medium only. A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. The values in the sub array index are from the media size table in the hpmib. This adjustment is done on a paper size by paper size basis. The standard PCL5 codes for paper size are used for the value used in the OID. Please see S_ARRAY_SUB1 for legal ')
media_size_west_edge_second_side_offset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 5, 3), Integer32()).setLabel("media-size-west-edge-second-side-offset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: media_size_west_edge_second_side_offset.setStatus('optional')
if mibBuilder.loadTexts: media_size_west_edge_second_side_offset.setDescription('Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). The adjustment is for the second printed side of the medium only. A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. Additional information: Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). The adjustment is for the second printed side of the medium only. A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. The values in the sub array index are from the media size table in the hpmib. This adjustment is done on a paper size by paper size basis. The standard PCL5 codes for paper size are used for the value used in the OID. Please see S_ARRAY_SUB1 for legal values. The data for this object is stored in NVRAM.')
media_size_west_edge_side_offset_by_tray = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 5, 4), Integer32()).setLabel("media-size-west-edge-side-offset-by-tray").setMaxAccess("readwrite")
if mibBuilder.loadTexts: media_size_west_edge_side_offset_by_tray.setStatus('optional')
if mibBuilder.loadTexts: media_size_west_edge_side_offset_by_tray.setDescription('Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. Each OID binding corresponds to a valid tray number for this product. There can be a maximum of 15 trays, a combination of internal and external trays. Products that support other combinations of trays will specify this information in the device pos. The data for this object is stored in NVRAM. Additional information: Returns or sets the number of 300 dpi dots by which the image is shifted relative to the west edge of the medium (see NORTH-EDGE-OFFSET). A positive value moves the image away from the west edge of the medium. A negative value moves the image closer to the west edge of the medium. The value 0 will return the image to its factory default position. Each OID binding corresponds to a valid tray number for this product. There can be a maximum of 15 trays, a combination of internal and external trays. Products that support other combinations of trays will specify this information in the device pos. The data for this object is stored in NVRAM.')
control_panel_supplies_status_message = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eShow", 1), ("eDontShow", 2)))).setLabel("control-panel-supplies-status-message").setMaxAccess("readwrite")
if mibBuilder.loadTexts: control_panel_supplies_status_message.setStatus('optional')
if mibBuilder.loadTexts: control_panel_supplies_status_message.setDescription('This PML object can be used to enable or disable supplies status messages from being displayed on the control panel. eShow - show the status messages on the control panel. eDontShow - do not show the status messages on the control panel. Additional information: . This PML Object can be used to enable or disable the supplies status messages from being displayed on the control panel. eShow Show the status messages on the control panel. eDontShow Do not show the status messages on the control panel.')
configurable_low_threshold_setting = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("configurable-low-threshold-setting").setMaxAccess("readwrite")
if mibBuilder.loadTexts: configurable_low_threshold_setting.setStatus('optional')
if mibBuilder.loadTexts: configurable_low_threshold_setting.setDescription('This PML object can be used to configure the low threshold for supplies. Additional information: This PML object can be used to configure the Low Threshold for Supplies.')
cartridge_out_override_control = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 27), Integer32()).setLabel("cartridge-out-override-control").setMaxAccess("writeonly")
if mibBuilder.loadTexts: cartridge_out_override_control.setStatus('optional')
if mibBuilder.loadTexts: cartridge_out_override_control.setDescription('This PML object is used to control Cartridge Out Override feature. Additional information: This object is used for the following purposes: 1. Set MarkEmptyOverride for a given cartridge. 2. Set/clear NonHPEnabled for a given cartridge. 3. Query internal variable SupplyUserConfirm for a given cartridge. 4. Query internal variable ConfirmedNonHP for a given cartridge.')
consumable_status_capacity_units = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("eMilliliter", 4)))).setLabel("consumable-status-capacity-units").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_status_capacity_units.setStatus('optional')
if mibBuilder.loadTexts: consumable_status_capacity_units.setDescription('This object is used to report the usage units used by the CONSUMABLE-STATUS-TOTAL-CAPACITY object. Additional information: Defines the units for the total capacity of a supply, which is given by CONSUMABLE-STATUS-TOTAL-CAPACITY')
consumable_status_total_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("consumable-status-total-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_status_total_capacity.setStatus('optional')
if mibBuilder.loadTexts: consumable_status_total_capacity.setDescription('This object is used to report the total capacity of a new consumable of this type. The PML object CONSUMABLE-STATUS-CAPACITY-UNITS can be used to determine the units of measure for this PML object. Additional information: Return capacity of cartridge in units defined in CONSUMABLE-STATUS-CAPACITY-UNITS.')
consumable_status_expiration_date = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 1, 1, 79), OctetString()).setLabel("consumable-status-expiration-date").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_status_expiration_date.setStatus('mandatory')
if mibBuilder.loadTexts: consumable_status_expiration_date.setDescription('Indicates the ink cartridge expiration date in yyyymmdd format. An unknown date is represented by the date 00000000. Additional information: Indicates the ink cartridge expiration date in yyyymmdd format. An unknown date is represented by the date 00000000')
consumable_string_information = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 8, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 287))).setLabel("consumable-string-information").setMaxAccess("readwrite")
if mibBuilder.loadTexts: consumable_string_information.setStatus('optional')
if mibBuilder.loadTexts: consumable_string_information.setDescription('This object is used to read and write the string value that describes the consumable information.')
consumable_string_information_reset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ePresetToNVRAM", 1), ("eCustomized", 2)))).setLabel("consumable-string-information-reset").setMaxAccess("readwrite")
if mibBuilder.loadTexts: consumable_string_information_reset.setStatus('optional')
if mibBuilder.loadTexts: consumable_string_information_reset.setDescription('This object is used to reset (set back to factory default) or read the current status of the corresponding information string. When Set to eResetToDefault, this object can be used to reset the corresponding information object back to its factory default value. Setting this object with an enumerated value of eCustomized has no effect. When a Get operation is performed on this object it will return a value eResetToDefault if still set to its factory value. It will return eCustomized if the corresponding information value has been set to a custom value. Additional information: This object returns ePresetToNVRAM(1) if CONSUMABLE-STRING-INFORMATION is currently set to the default string. It will return eCustomized(2) otherwise. However, we can explicitly set this object only to ePresetToNVRAM(1) and not eCustomized(2).')
consumable_reorder_url = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("consumable-reorder-url").setMaxAccess("readwrite")
if mibBuilder.loadTexts: consumable_reorder_url.setStatus('optional')
if mibBuilder.loadTexts: consumable_reorder_url.setDescription('This object is used to read and write the URL that can be used to reorder consumables for this device. This URL is set at the factory but can be updated by a reseller or third party. Additional information: The URL can be up to 64 characters long.')
consumable_current_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 7), OctetString()).setLabel("consumable-current-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_current_state.setStatus('optional')
if mibBuilder.loadTexts: consumable_current_state.setDescription("This PML object returns the current state of the particular consumable. cAuthLevel1 - Consumable is at Authentication Level 1 cAuthLevel2 - Consumable is at Authentication Level 2 cAuthLevel3 - Consumable is at Authentication Level 3 cAuthLevel4 - Consumable is at Authentication Level 4 cAuthLevel5 - Consumable is at Authentication Level 5 cGenuineHPUnsupported - Cartridge is GenuineHP intended for another product cDefectiveMemory - Cartridge has a defective memory tag cMissingMemory - Memory tag is missing from the cartridge cLowCondition - Consumable has reached the engine low threshold cOutCondition - Consumable has reached its out threshold cIncorrect - Cartridge inserted is not the correct one cMissing - Consumable is missing from the printer cConfigurableLow - Consumable has reached the configurable low threshold value cStatusArevalid - The status reported on other bits are valid only if the bit is set to 1. If it is 0, the values are invalid. cExpired - Is the cartridge expired, which is determined by the formatter. cFailure - Cartridge has failed determined by the engine. cLeak - Cartridge has a leak as determined by the engine. cUnknownManufacturer - the brand of the cartridge is unknown as determined by the engine. cUnsupported --- Cartridge is not supported as determined by the engine. These are the possible states and whenever the consumable is in any of these states, the appropriate bit will be set. The cLowCondition will be set when the consumable reaches the engine low threshold, and cConfigurableLow will be set when the consumable reaches the Configurable Low threshold value. For non-cartridge supplies only cLowCondition, cOutCondition, and cMissing will be supported. Additional information: This object returns the current state of the particular consumable. cAuthLevel1 - HP genuine cAuthLevel2 - Condor's Non-HP (Canon's Clone) cAuthLevel3 - refilled cAuthLevel5 - Condor's ApprovedOEM cOutCondition - empty cMissing - not installed cConfigurableLow - configurable low cExpired - cartridge, determined by formatter cFailure - failure cLeak - leak cUnknownManufacturer - Non-HP cartridge which has not been enabled cUnsupported - something wrong on a new cartridge, not compatable cStatusAreValid - The Status reported on other bits are valid only if this bit is set to 1. If it is 0, the values are invalid. These are the possible states and whenever a Consumable is in any of these states, the appropriate bit will be set.")
consumable_notification_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 10), OctetString()).setLabel("consumable-notification-status").setMaxAccess("readwrite")
if mibBuilder.loadTexts: consumable_notification_status.setStatus('optional')
if mibBuilder.loadTexts: consumable_notification_status.setDescription("This object is used to read and write the various status flags supported by this consumable. For gandalf the collection bits supported include: cClient1ReorderNotificationSent - indicates whether EWS (Embedded Web Server) has already sent the reorder notification e-mail for this consumable. This bit can be both read and written. cClient2ReorderNotificationSent - indicates whether WJA (Web Jet Admin) has already sent the reorder notification e-mail for this consumable. This bit can be both read and written. cClient3ReorderNotificationSent - for future implementation cClient4ReorderNotificationSent - for future implementation cClient5ReorderNotificationSent - for future implementation cClient1ReplaceNotificationSent - indicates whether EWS (Embedded Web Server) has already sent the replace notification e-mail for this consumable. This bit can be both read and written. cClient2ReplaceNotificationSent - indicates whether WJA (Web Jet Admin) has already sent the replace notification e-mail for this consumable. This bit can be both read and written. cClient3ReplaceNotificationSent - for future implementation cClient4ReplaceNotificationSent - for future implementation cClient5ReplaceNotificationSent - for future implementation Additional information: This object will have 1 sub arrays for the consumable. The client1 and 2 currently are assingned to EWS and WJA the remaining client are reserved for the future third party pml tools. A client is requiered to set only his assigned bit for reorder or replace notification. A client using other client's bit for reorder replace will result in the other client being not able to set the notification. Ex: For EWS ReOrderNotification it will send 0x00010000 and For EWS ReplaceNotification it will send 0x00000001 For WJA ReOrderNotification it will send 0x00020000 and For WJA ReplaceNotification it will send 0x00000002")
consumable_pages_printed_with_supply = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 11), Integer32()).setLabel("consumable-pages-printed-with-supply").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_pages_printed_with_supply.setStatus('optional')
if mibBuilder.loadTexts: consumable_pages_printed_with_supply.setDescription("This PML object returns the number of pages printed with a cartridge consumable. This PML object returns the value that should be displayed under 'Pages Printed With This Supply' for cartridges in color products. Additional information: This PML object returns the number of pages printed with a Cartridge Consumable. This PML object returns the value that should be displayed underPages Printed With This Supply for Cartridges in Color products.")
consumable_life_usage_units_remaining = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 5, 1, 1), Integer32()).setLabel("consumable-life-usage-units-remaining").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_life_usage_units_remaining.setStatus('optional')
if mibBuilder.loadTexts: consumable_life_usage_units_remaining.setDescription('This object reports the current estimate of the number of usage units that remain before this supply is depleted. An installed supply that cannot report such a number will return a value of -2. It is the reponsibility of the host application to query each supply in order to determine an overall device USAGE-UNITS-REMAINING number - the lowest value returned. The unit of measure for this life estimate is determined by reading the corresponding CONSUMABLE-LIFE-USAGE-UNITS object. Additional information: This object will return the Pages or Estimated Pages remaining for the speciffic supply requested by the leaf node of this object.')
consumable_life_usage_units = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ePagesRemaining", 1), ("eEstimatedPagesRemaining", 2)))).setLabel("consumable-life-usage-units").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_life_usage_units.setStatus('optional')
if mibBuilder.loadTexts: consumable_life_usage_units.setDescription('This object reports current usage units in use by the corresponding CONSUMABLE-LIFE-USAGE-UNITS-REMAINING object. Additional information: This object returns the units that CONSUMABLE-LIFE-USAGE-UNITS-REMAINING is returned in. Either ePagesRemaining(1) or eEstimatedPagesRemaining(2).')
consumable_life_low_threshold = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 10, 5, 1, 3), Integer32()).setLabel("consumable-life-low-threshold").setMaxAccess("readonly")
if mibBuilder.loadTexts: consumable_life_low_threshold.setStatus('optional')
if mibBuilder.loadTexts: consumable_life_low_threshold.setDescription('This object is used to report and modify a threshold value indicating the point in the life of a consumable or supply at which a transition to a LOW state will occur.')
default_vertical_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 8), Integer32()).setLabel("default-vertical-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vertical_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_vertical_black_resolution.setDescription('Returns or changes the value of the default vertical black resolution. The units are dots per inch. Additional information: In InkJet changing this OID also causes DEFAULT-HORIZONTAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are: Grizzly: 300, 600, 1200 Color Products: 600 Cayenne: 300, 600 Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: Grizzly: 450 >= n < 900 snaps to 600 n >= 900 snaps to 1200 Color Products: n snaps to 600 Cayenne: n < 450 snaps to 300 n >=450 snaps to 600 ')
default_horizontal_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 9), Integer32()).setLabel("default-horizontal-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_horizontal_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_horizontal_black_resolution.setDescription('Returns or changes the value of the default horizontal black resolution. The units are dots per inch. Additional information: In InkJet changing this object also causes DEFAULT-VERTICAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are: Grizzly: 300, 600, 1200 Color Products: 600 Cayenne: 300, 600 Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: Grizzly: n < 450 snaps to 300 450 >= n < 900 snaps to 600 n >= 900 snaps to 1200 Color Products: n snaps to 600 Cayenne: n < 450 snaps to 300 n >=450 snaps to 600 ')
default_page_protect = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eOn", 2)))).setLabel("default-page-protect").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_page_protect.setStatus('optional')
if mibBuilder.loadTexts: default_page_protect.setDescription('Returns or changes the default page protection behavior. If eOff, the device does not reserve memory for holding the entire raster form of a processed page. If eOn, then memory is reserved. If eAuto, the device determines the amount of memory to reserve. Additional information: Setting to eOn causes MET to be more conservative, but it will not allocate memory to hold an entire rasterized page.')
default_bits_per_pixel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 39), Integer32()).setLabel("default-bits-per-pixel").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_bits_per_pixel.setStatus('optional')
if mibBuilder.loadTexts: default_bits_per_pixel.setDescription('Controls the number of levels used (per pixel) when printing grayscale or color images.')
web_server_url = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 9, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("web-server-url").setMaxAccess("readwrite")
if mibBuilder.loadTexts: web_server_url.setStatus('optional')
if mibBuilder.loadTexts: web_server_url.setDescription('A Universal Resource Locator (URL) from which the Embedded Web Server can be configured. Any limitation on the size of this URL will be specified in the device POS.')
web_server_security = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 9, 1, 3), OctetString()).setLabel("web-server-security").setMaxAccess("readwrite")
if mibBuilder.loadTexts: web_server_security.setStatus('optional')
if mibBuilder.loadTexts: web_server_security.setDescription('Each collection bit represents a device or Embedded Web Server feature that can be enabled or disabled via this object.')
firmware_download_write_status_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("firmware-download-write-status-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_write_status_supported.setStatus('optional')
if mibBuilder.loadTexts: firmware_download_write_status_supported.setDescription('This object provides information on whether the printer has the ability to communicate the write-status of the firmware download while the download is taking place.')
firmware_download_write_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 2), Integer32()).setLabel("firmware-download-write-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_write_time.setStatus('optional')
if mibBuilder.loadTexts: firmware_download_write_time.setDescription('If the design of the firmware-download implementation does not allow PML interaction during the download process, this value provides an estimation of the time where the printer will not be able to engage in PML communication. Additional information: If the design of the firmware-download implementation does not allow PML interaction during the download process, this value provides an estimation of the time where the printer will not be able to engage in PML communication. The calculated time is expected to be 140 secs. However, this time may increase as high as 280 secs as the flash part nears the maximum flash count.')
firmware_download_write_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 3), Integer32()).setLabel("firmware-download-write-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_write_count.setStatus('optional')
if mibBuilder.loadTexts: firmware_download_write_count.setDescription('Tells the number of times that firmware has been downloaded to the flash part. Additional information: Tells the number of times that firmware has been downloaded to the flash part. The default value will vary depending on how many times the firmware is rolled before shipping.')
firmware_download_current_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("eIdle", 1), ("eReceivingImage", 2), ("eReceivedImageError", 3), ("eVerifyingImage", 4), ("eVerifiedImageError", 5), ("eWritingImage", 6), ("eWritingImageError", 7), ("eDownloadComplete", 8), ("eOKtoShutDown", 9), ("eCancelDownload", 10), ("eShuttingDown", 11)))).setLabel("firmware-download-current-state").setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmware_download_current_state.setStatus('optional')
if mibBuilder.loadTexts: firmware_download_current_state.setDescription('Provides the current or last reportable state of the firmware download process. The current state may not necessarily be the current state, but could be the post-mortem state.')
firmware_download_maximum_write_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 5), Integer32()).setLabel("firmware-download-maximum-write-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_maximum_write_count.setStatus('optional')
if mibBuilder.loadTexts: firmware_download_maximum_write_count.setDescription('Reports the manufacturer specified number of times that firmware can be downloaded to the flash part. A value of -1 means that there is no limit. A value of 0 means that downloading firmware is not permitted by this part. Any other positive integer value corresponds to the number of times that firmware can be downloaded to the flash part. Additional information: Reports the manufacturer specified number of times that firmware can be downloaded to the flash part. A value of -1 means that there is no limit. A value of 0 means that downloading firmware is not permitted by this part. Any other positive integer value corresponds to the number of times that firmware can be downloaded to the flash part. The current maximum write count is 500. This may change as flash technology evolves.')
firmware_download_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 6), OctetString()).setLabel("firmware-download-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_name.setStatus('mandatory')
if mibBuilder.loadTexts: firmware_download_name.setDescription('This returns the name of the printer. This should match the name in the header of the upgrade image being sent to the flash part. If the name does not match with the name returned then the image that we are attempting to download does not upgrade the printer firmware. Additional information: This object returns the HP name of the printer. This should match what is in the PJL header of the RFU job Web Jet Admin uses this to ensure the printer is available to be upgraded.')
firmware_download_version = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 18, 7), OctetString()).setLabel("firmware-download-version").setMaxAccess("readonly")
if mibBuilder.loadTexts: firmware_download_version.setStatus('mandatory')
if mibBuilder.loadTexts: firmware_download_version.setDescription('This object will return a string value representing the current revision of firmware that the printer is operating with. This is used to determine if code needs to be upgraded when an firmware bundle comes in, in an upgrade job. Additional information: Web Jet Admin uses the version string that is returned to determine what peices of an RFU bundle need to be upgraded when an RFU job is being built. This objects will return the version string of the printer.')
upgradable_devices_write_status_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("upgradable-devices-write-status-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_write_status_supported.setStatus('optional')
if mibBuilder.loadTexts: upgradable_devices_write_status_supported.setDescription('This object provides information on whether the upgradable device has the ability to communicate the write-status of the upgrade while the upgrade is taking place.')
upgradable_devices_write_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 2), Integer32()).setLabel("upgradable-devices-write-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_write_time.setStatus('optional')
if mibBuilder.loadTexts: upgradable_devices_write_time.setDescription('If the design of the device upgrade implementation does not allow PML interaction during the download process, this value provides an estimation of the time where the device will not be able to engage in PML communication. The time returned will depend upon what device is attempting to be upgraded.')
upgradable_devices_write_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 3), Integer32()).setLabel("upgradable-devices-write-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_write_count.setStatus('optional')
if mibBuilder.loadTexts: upgradable_devices_write_count.setDescription('Tells the number of times that firmware for device X has been downloaded to the flash part. The default value will vary depending on how many times the firmware is rolled before shipping.')
upgradable_devices_current_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("eIdle", 1), ("eReceivedImage", 2), ("eReceivedImageError", 3), ("eVerifiedImage", 4), ("eVerifiedImageError", 5), ("eWritingImage", 6), ("eWritingImageError", 7), ("eUpgradeComplete", 8), ("eUpgradeSkipped", 9)))).setLabel("upgradable-devices-current-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_current_state.setStatus('optional')
if mibBuilder.loadTexts: upgradable_devices_current_state.setDescription('Provides the current or last reportable state of the device upgrade process. The current state may not necessarily be the current state, but could be the post-mortem state.')
upgradable_devices_max_write_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 5), Integer32()).setLabel("upgradable-devices-max-write-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_max_write_count.setStatus('optional')
if mibBuilder.loadTexts: upgradable_devices_max_write_count.setDescription('Reports the manufacturer specified number of times that firmware for device X can be downloaded to the flash part. A value of -1 means that there is no limit. A value of 0 means that downloading firmware is not permitted by this part. Any other positive integer value corresponds to the number of times that the firmware for device X can be downloaded to the flash part. The current maximum write count is 500. This may change as flash technology evolves.')
upgradable_devices_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 6), OctetString()).setLabel("upgradable-devices-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_name.setStatus('mandatory')
if mibBuilder.loadTexts: upgradable_devices_name.setDescription('This returns the name of the upgradable device. This should match the name in the header of the upgrade image being sent to the flash part. If the name does not match with any of the names returned then the device that we are attempting to upgrade is unavailable for upgrading. Additional information: This object returns the HP name of the printer and the upgradable devices. There is one Name object per upgradable device. This should match what is in the PJL header of the RFU job Web Jet Admin uses this to ensure the printer or device is available to be upgraded.')
upgradable_devices_version = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 7), OctetString()).setLabel("upgradable-devices-version").setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradable_devices_version.setStatus('mandatory')
if mibBuilder.loadTexts: upgradable_devices_version.setDescription('This object will return a string value representing the current revision of firmware that device X is operating with. This is used to determine if code needs to be upgraded when a firmware bundle comes in, in an upgrade job. Additional information: Web Jet Admin uses the version string that is returned to determine what peices of an RFU bundle need to be upgraded when an RFU job is being built. This internal object will return the current version string of the printer or device that it corresponds to.')
remote_upgrade_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 20, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("remote-upgrade-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: remote_upgrade_enable.setStatus('mandatory')
if mibBuilder.loadTexts: remote_upgrade_enable.setDescription('Enables or disables the ability to upgrade the firmware associated with any device that is available to be upgraded. This will be set to on or off at the RFU level in that if this mode is on any available device can be upgraded and if this mode is off none of the devices can be upgraded. There is not an individual mode for each device. Trying to set this to a value other than eOn or eOff will cause an UnsupportedValue error to occur.')
mibBuilder.exportSymbols("IJ8060-MIB", held_job_control=held_job_control, id=id, daylight_savings_start=daylight_savings_start, warning9_code=warning9_code, phd2_device_specific_command=phd2_device_specific_command, media7_page_count=media7_page_count, error37_code=error37_code, default_custom_paper_xfeed_dim=default_custom_paper_xfeed_dim, error7_code=error7_code, usb_device_kind=usb_device_kind, finisher_image_rotation=finisher_image_rotation, error5_code=error5_code, media3_name=media3_name, media9_name=media9_name, warning28_date_time=warning28_date_time, error6=error6, warning42=warning42, settings_outbin=settings_outbin, warning43_time_stamp=warning43_time_stamp, current_job_parsing_id=current_job_parsing_id, file_system2_initialize_volume=file_system2_initialize_volume, media4=media4, print_meter_usage_threshold=print_meter_usage_threshold, warning14_code=warning14_code, duplex_page_count=duplex_page_count, media18_short_name=media18_short_name, phd2_capacity=phd2_capacity, pcl_default_font_source=pcl_default_font_source, error9_date_time=error9_date_time, warning32_date_time=warning32_date_time, error20=error20, warning39_time_stamp=warning39_time_stamp, postscript_total_page_count=postscript_total_page_count, warning41_code=warning41_code, error36=error36, media5=media5, printer_accounting=printer_accounting, firmware_download_version=firmware_download_version, error34=error34, device_system=device_system, background_status_msg_higher_priority=background_status_msg_higher_priority, phd=phd, job_info_attr_5=job_info_attr_5, error14_date_time=error14_date_time, input_tray_max_media_feed_dim=input_tray_max_media_feed_dim, mio4_model_name=mio4_model_name, default_lines_per_page=default_lines_per_page, media19_short_name=media19_short_name, printed_media_simplex_charge=printed_media_simplex_charge, destination_subsystem=destination_subsystem, warning28=warning28, warning7_time_stamp=warning7_time_stamp, tray2_media_size_loaded=tray2_media_size_loaded, warning29_code=warning29_code, error36_date_time=error36_date_time, error27=error27, warning30_time_stamp=warning30_time_stamp, error34_time_stamp=error34_time_stamp, job_info_name1=job_info_name1, media14_short_name=media14_short_name, upgradable_devices_name=upgradable_devices_name, job_info=job_info, consumable_string_information=consumable_string_information, warning10_time_stamp=warning10_time_stamp, media4_page_count=media4_page_count, job_info_attr_7=job_info_attr_7, error39_date_time=error39_date_time, warning14_time_stamp=warning14_time_stamp, error22_code=error22_code, warning11_code=warning11_code, job=job, web_server=web_server, error10_code=error10_code, error18_date_time=error18_date_time, device_name=device_name, error15_time_stamp=error15_time_stamp, error14_time_stamp=error14_time_stamp, warning31_time_stamp=warning31_time_stamp, warning26_date_time=warning26_date_time, warning32_code=warning32_code, job_info_accounting_cyan_dots=job_info_accounting_cyan_dots, warning44_time_stamp=warning44_time_stamp, scanner_accessory_send_job_scan_count=scanner_accessory_send_job_scan_count, usage_instructions_line4=usage_instructions_line4, warning45_time_stamp=warning45_time_stamp, error41_date_time=error41_date_time, settings_webserver=settings_webserver, error28_code=error28_code, job_info_attr_15=job_info_attr_15, mass_storage_resource_changed=mass_storage_resource_changed, error7_time_stamp=error7_time_stamp, error23_time_stamp=error23_time_stamp, error25_code=error25_code, pcfax_send_operational=pcfax_send_operational, media15_page_count=media15_page_count, on_off_line=on_off_line, error20_date_time=error20_date_time, mio4_type=mio4_type, error31_time_stamp=error31_time_stamp, printer_cal_dhalf_utc=printer_cal_dhalf_utc, error44=error44, warning24_time_stamp=warning24_time_stamp, outbin=outbin, intray3=intray3, outbins=outbins, media11_short_name=media11_short_name, warning40_time_stamp=warning40_time_stamp, warning45_code=warning45_code, error11=error11, warning44=warning44, media8=media8, operating_system=operating_system, tray2_phd=tray2_phd, usb_product_description=usb_product_description, job_info_accounting=job_info_accounting, error26=error26, default_custom_paper_feed_dim=default_custom_paper_feed_dim, localization_languages_supported=localization_languages_supported, warning34_time_stamp=warning34_time_stamp, port1_parallel_speed=port1_parallel_speed, warning30_code=warning30_code, job_info_accounting_media_size=job_info_accounting_media_size, outbin5=outbin5, rpc_bound_protocol_address=rpc_bound_protocol_address, job_info_state=job_info_state, job_info_accounting_finishing_options=job_info_accounting_finishing_options, error32_date_time=error32_date_time, warning38_time_stamp=warning38_time_stamp, error45_code=error45_code, error47=error47, warning1=warning1, print_meter_total_charge=print_meter_total_charge, warning18_time_stamp=warning18_time_stamp, default_media_size=default_media_size, phd1=phd1, media6_name=media6_name, outbin2_maximum_binding=outbin2_maximum_binding, media12=media12, job_info_attr_16=job_info_attr_16, outbin4_maximum_binding=outbin4_maximum_binding, warning12_code=warning12_code, ph2=ph2, warning21=warning21, fax_proc_sub=fax_proc_sub, warning3_code=warning3_code, warning45=warning45, pdl_pcl=pdl_pcl, error4_time_stamp=error4_time_stamp, error33=error33, job_info_pages_printed=job_info_pages_printed, printed_media_usage=printed_media_usage, media10_short_name=media10_short_name, warning23_time_stamp=warning23_time_stamp, job_info_attr_9=job_info_attr_9, media11_name=media11_name, settings_file_system=settings_file_system, warning20_date_time=warning20_date_time, error48_date_time=error48_date_time, error2_code=error2_code, port1=port1, accounting=accounting, warning11_time_stamp=warning11_time_stamp, phd2_manufacturing_info=phd2_manufacturing_info, outbin2_error_info=outbin2_error_info, error47_date_time=error47_date_time, error48_code=error48_code, warning4_code=warning4_code, error49=error49, print_meter_dimplex_count=print_meter_dimplex_count, pdl_postscript=pdl_postscript, warning29_date_time=warning29_date_time, mass_storage_resource_change_counter=mass_storage_resource_change_counter, errorlog=errorlog, firmware_download=firmware_download, email_service_operational=email_service_operational, warning49_time_stamp=warning49_time_stamp, media1_name=media1_name, error21_date_time=error21_date_time, media1=media1, outbin4=outbin4, warning18_date_time=warning18_date_time, held_job_delete=held_job_delete, file_system_wipe_disk=file_system_wipe_disk, phd2_model=phd2_model, rpc_bind_protocol_address=rpc_bind_protocol_address, settings_prt_eng=settings_prt_eng, file_system3_initialize_volume=file_system3_initialize_volume, warning33=warning33, media6=media6, error21=error21, print_meter_print_quality=print_meter_print_quality, warning2_code=warning2_code, settings_security=settings_security, warning24=warning24, error15_date_time=error15_date_time, error42_time_stamp=error42_time_stamp, warning44_date_time=warning44_date_time, reprint=reprint, media_names_available=media_names_available, error31_code=error31_code, error3_time_stamp=error3_time_stamp, error16_code=error16_code, media17_short_name=media17_short_name, job_info_accounting_media_type=job_info_accounting_media_type, error10_date_time=error10_date_time, warning27_code=warning27_code, held_job_enable=held_job_enable, error38_code=error38_code, job_output_auto_continue_timeout=job_output_auto_continue_timeout, warning34_date_time=warning34_date_time, DisplayString=DisplayString, media17_page_count=media17_page_count, warning1_code=warning1_code, pdl=pdl, consumable_reorder_url=consumable_reorder_url, print_meter_dimplex_total=print_meter_dimplex_total, warning47_code=warning47_code, destination_bin_usage_count=destination_bin_usage_count, warning15_code=warning15_code, default_page_protect=default_page_protect, warning36_date_time=warning36_date_time, warning39_code=warning39_code, time_display=time_display, error49_date_time=error49_date_time, mass_storage_block_driver=mass_storage_block_driver, warning8_time_stamp=warning8_time_stamp, warning44_code=warning44_code, scanner_accessory_copy_job_scan_count=scanner_accessory_copy_job_scan_count, warning2=warning2, error16_date_time=error16_date_time, input_tray_min_media_feed_dim=input_tray_min_media_feed_dim, cancel_job=cancel_job, warning42_date_time=warning42_date_time, error5=error5, error49_code=error49_code, tray6_media_size_loaded=tray6_media_size_loaded, remote_upgrade_enable=remote_upgrade_enable, settings_rpc=settings_rpc, consumable_notification_status=consumable_notification_status, source_subsystem=source_subsystem, warning20=warning20, error41=error41, warning35=warning35, media7_name=media7_name, status_mass_storage_bd=status_mass_storage_bd, error6_code=error6_code, control_panel_display=control_panel_display, warning37=warning37, error4=error4, form_feed_needed=form_feed_needed, warning49_date_time=warning49_date_time, error14=error14, processing_subsystem=processing_subsystem, error35_date_time=error35_date_time)
mibBuilder.exportSymbols("IJ8060-MIB", scanned_media_simplex_charge=scanned_media_simplex_charge, source_tray_usage=source_tray_usage, error5_date_time=error5_date_time, warning38_date_time=warning38_date_time, warning10=warning10, warning19=warning19, perm_store_init_occurred=perm_store_init_occurred, warning21_time_stamp=warning21_time_stamp, pcl_default_font_number=pcl_default_font_number, warning32=warning32, error24_time_stamp=error24_time_stamp, settings_fax_proc_sub=settings_fax_proc_sub, print_meter_simplex_count=print_meter_simplex_count, warning33_time_stamp=warning33_time_stamp, tray3_phd=tray3_phd, error18_time_stamp=error18_time_stamp, outbin5_error_info=outbin5_error_info, error30_time_stamp=error30_time_stamp, outbin5_phd=outbin5_phd, settings_web_server=settings_web_server, error28_date_time=error28_date_time, warning26=warning26, status_prt_eng=status_prt_eng, held_job_set_queue_size=held_job_set_queue_size, firmware_download_write_status_supported=firmware_download_write_status_supported, held_job=held_job, warning49_code=warning49_code, io_timeout=io_timeout, warning3_date_time=warning3_date_time, job_info_accounting_color_impression_count=job_info_accounting_color_impression_count, warning31_date_time=warning31_date_time, media11_page_count=media11_page_count, error45=error45, warning18=warning18, settings_io=settings_io, error40_code=error40_code, job_info_attr_3=job_info_attr_3, error37=error37, ph=ph, warning31_code=warning31_code, job_info_size=job_info_size, media6_short_name=media6_short_name, error3_code=error3_code, warning7_code=warning7_code, default_horizontal_black_resolution=default_horizontal_black_resolution, usb=usb, consumables_1=consumables_1, upgradable_devices_max_write_count=upgradable_devices_max_write_count, usage_scanner_total_charge=usage_scanner_total_charge, webserver_proc_sub=webserver_proc_sub, job_info_attr_12=job_info_attr_12, pdf_print_errors=pdf_print_errors, file_system_external_access_capabilities=file_system_external_access_capabilities, rtc_time_zone=rtc_time_zone, postscript_print_errors=postscript_print_errors, destination_bin_usage=destination_bin_usage, phd2=phd2, media2=media2, error9_time_stamp=error9_time_stamp, file_system_set_system_partition_readonly=file_system_set_system_partition_readonly, ram_disk_size=ram_disk_size, media13_name=media13_name, media15_name=media15_name, background_status_msg_line2_part1=background_status_msg_line2_part1, print_engine_revision=print_engine_revision, fw_rom_revision=fw_rom_revision, outbin3_maximum_binding=outbin3_maximum_binding, job_info_attr_8=job_info_attr_8, error7=error7, file_system4_initialize_volume=file_system4_initialize_volume, file_system3=file_system3, media15=media15, scanner_accounting=scanner_accounting, job_input_auto_continue_timeout=job_input_auto_continue_timeout, media_size_west_edge_first_side_offset=media_size_west_edge_first_side_offset, error12_date_time=error12_date_time, warning27=warning27, mio4=mio4, auto_continue=auto_continue, warning1_time_stamp=warning1_time_stamp, warning21_date_time=warning21_date_time, warning6=warning6, error23_code=error23_code, warning43_code=warning43_code, job_info_accounting_job_type=job_info_accounting_job_type, custom_paper_xfeed_dim=custom_paper_xfeed_dim, error29=error29, north_edge_offset=north_edge_offset, scanner_accessory_flatbed_scan_count=scanner_accessory_flatbed_scan_count, direct_connect_ports_enable=direct_connect_ports_enable, settings_intray=settings_intray, model_name=model_name, warning34_code=warning34_code, print_meter_usage=print_meter_usage, pdl_pdf=pdl_pdf, printed_media_dimplex_count=printed_media_dimplex_count, control_panel_display_contents_crc=control_panel_display_contents_crc, intray6=intray6, warning23_date_time=warning23_date_time, default_vertical_black_resolution=default_vertical_black_resolution, warning17_code=warning17_code, fih_extra_pulses_feature=fih_extra_pulses_feature, warning24_date_time=warning24_date_time, media3=media3, usb_serial_number=usb_serial_number, file_system_set_system_partition_writeable=file_system_set_system_partition_writeable, media8_name=media8_name, job_info_change_id=job_info_change_id, media13_short_name=media13_short_name, warning46_time_stamp=warning46_time_stamp, media9_page_count=media9_page_count, media17=media17, media15_short_name=media15_short_name, media16=media16, consumable_life_low_threshold=consumable_life_low_threshold, outbin1_override_mode=outbin1_override_mode, printed_media_maximum_pixels_per_page=printed_media_maximum_pixels_per_page, media_number_of_type_supported=media_number_of_type_supported, media16_page_count=media16_page_count, error18=error18, error35_time_stamp=error35_time_stamp, source_tray_accounting=source_tray_accounting, clearable_warning=clearable_warning, fax_notification_available=fax_notification_available, printer_cal_cpr_utc=printer_cal_cpr_utc, warning14=warning14, phd1_diagnostics_nvram_data=phd1_diagnostics_nvram_data, settings_scanner=settings_scanner, automatic_daylight_savings=automatic_daylight_savings, warning35_code=warning35_code, job_info_attr_10=job_info_attr_10, device_configure=device_configure, media_counts=media_counts, serial_number=serial_number, warning36_time_stamp=warning36_time_stamp, usage_printer_color_total_charge=usage_printer_color_total_charge, warning38_code=warning38_code, usage_printer_mono_dimplex_total=usage_printer_mono_dimplex_total, media14_name=media14_name, warning5=warning5, job_info_outcome=job_info_outcome, warning1_date_time=warning1_date_time, warning24_code=warning24_code, hold_job_timeout=hold_job_timeout, error43_time_stamp=error43_time_stamp, job_info_attribute=job_info_attribute, error30_date_time=error30_date_time, job_info_attr_4=job_info_attr_4, tray1_media_size_loaded=tray1_media_size_loaded, error12_time_stamp=error12_time_stamp, warning3_time_stamp=warning3_time_stamp, display=display, error42=error42, warning13=warning13, error36_time_stamp=error36_time_stamp, warning20_time_stamp=warning20_time_stamp, print_quality_level=print_quality_level, date_display=date_display, print_meter_category_total=print_meter_category_total, model_number=model_number, warning40=warning40, warning48_date_time=warning48_date_time, warning5_code=warning5_code, timestamp=timestamp, printed_media_total_charge=printed_media_total_charge, tray1_phd=tray1_phd, fax_billing_code_minlength=fax_billing_code_minlength, job_info_name2=job_info_name2, settings_ph=settings_ph, warning13_date_time=warning13_date_time, daylight_savings_offset=daylight_savings_offset, outbin5_maximum_binding=outbin5_maximum_binding, warning6_time_stamp=warning6_time_stamp, input_tray_max_media_xfeed_dim=input_tray_max_media_xfeed_dim, held_job_info=held_job_info, error17_date_time=error17_date_time, warning11_date_time=warning11_date_time, file_system_wipe_disk_status=file_system_wipe_disk_status, control_panel_display_contents_change_counter=control_panel_display_contents_change_counter, total_engine_page_count=total_engine_page_count, held_job_job_name=held_job_job_name, ph_devices=ph_devices, printer_calibration_dhalf=printer_calibration_dhalf, web_server_url=web_server_url, firmware_download_current_state=firmware_download_current_state, warning4_time_stamp=warning4_time_stamp, outbin1_error_info=outbin1_error_info, error43_code=error43_code, device_configure_printer_parameters=device_configure_printer_parameters, media3_page_count=media3_page_count, job_info_attr_13=job_info_attr_13, warning31=warning31, error39_time_stamp=error39_time_stamp, warning22=warning22, error48_time_stamp=error48_time_stamp, warning6_code=warning6_code, warning23=warning23, error48=error48, error31_date_time=error31_date_time, error44_date_time=error44_date_time, error2_date_time=error2_date_time, warning43=warning43, powersave_enable_type=powersave_enable_type, outbin1_phd=outbin1_phd, upgradable_devices_write_time=upgradable_devices_write_time, job_info_accounting_black_dots=job_info_accounting_black_dots, error3_date_time=error3_date_time, pdf_enabled=pdf_enabled, outbin3_error_info=outbin3_error_info, warning27_date_time=warning27_date_time, outbin4_phd=outbin4_phd, settings_mass_storage_bd=settings_mass_storage_bd, warning35_time_stamp=warning35_time_stamp, upgradable_devices_write_count=upgradable_devices_write_count, override_media_name=override_media_name, host_application_available_memory=host_application_available_memory, outbin1=outbin1, printer_color_accounting=printer_color_accounting, error38_time_stamp=error38_time_stamp, job_info_attr_6=job_info_attr_6, control_panel_key_press=control_panel_key_press, job_info_accounting_media_duplex_count=job_info_accounting_media_duplex_count, error27_code=error27_code, file_system_delete_files=file_system_delete_files, warning15_time_stamp=warning15_time_stamp, warning22_date_time=warning22_date_time, warning34=warning34, error4_code=error4_code, total_color_page_count=total_color_page_count, scanned_media_duplex_charge=scanned_media_duplex_charge, power_state=power_state, warning16_time_stamp=warning16_time_stamp, media10_page_count=media10_page_count, error38_date_time=error38_date_time, consumable_life_usage_units_remaining=consumable_life_usage_units_remaining, warning46_date_time=warning46_date_time, warning8_date_time=warning8_date_time, error30=error30, error13=error13, warning33_date_time=warning33_date_time, warning25_time_stamp=warning25_time_stamp, warning25=warning25, install_date=install_date, control_panel_display_graphical_contents=control_panel_display_graphical_contents, error22_time_stamp=error22_time_stamp, warning4=warning4, held_job_retention=held_job_retention, printer_calibration_cpr=printer_calibration_cpr, consumable_string=consumable_string, intray2=intray2, tray3_media_size_loaded=tray3_media_size_loaded, media10_name=media10_name, error34_date_time=error34_date_time, warning37_code=warning37_code)
mibBuilder.exportSymbols("IJ8060-MIB", held_job_pin=held_job_pin, usb_product_id=usb_product_id, error17=error17, printed_media_duplex_count=printed_media_duplex_count, default_bits_per_pixel=default_bits_per_pixel, printer_cal_cpr_page_count=printer_cal_cpr_page_count, warning12_date_time=warning12_date_time, error44_time_stamp=error44_time_stamp, warning43_date_time=warning43_date_time, fax_print_page_count=fax_print_page_count, ram_disk_mode=ram_disk_mode, outbin3=outbin3, error37_date_time=error37_date_time, media4_name=media4_name, tray5_phd=tray5_phd, io=io, held_job_security=held_job_security, error34_code=error34_code, hp=hp, cartridge_out_override_control=cartridge_out_override_control, error50=error50, phd2_type=phd2_type, warning37_date_time=warning37_date_time, destination_bin_usage_total=destination_bin_usage_total, error4_date_time=error4_date_time, media8_page_count=media8_page_count, usb_interface=usb_interface, error1_code=error1_code, fax_job_scan_count=fax_job_scan_count, file_system_erase_mode=file_system_erase_mode, web_proxy_config_enable=web_proxy_config_enable, error2=error2, media19=media19, error36_code=error36_code, upgradable_devices_write_status_supported=upgradable_devices_write_status_supported, web_server_security=web_server_security, warning10_code=warning10_code, error5_time_stamp=error5_time_stamp, warning19_date_time=warning19_date_time, error29_time_stamp=error29_time_stamp, warning16_code=warning16_code, outbin5_override_mode=outbin5_override_mode, os_execute_file=os_execute_file, error31=error31, form_feed=form_feed, error19_code=error19_code, error26_date_time=error26_date_time, error16_time_stamp=error16_time_stamp, warning7_date_time=warning7_date_time, background_message1=background_message1, error8_date_time=error8_date_time, warning17_date_time=warning17_date_time, default_vmi=default_vmi, default_media_name=default_media_name, media13_page_count=media13_page_count, warning18_code=warning18_code, control_panel_supplies_status_message=control_panel_supplies_status_message, media18_name=media18_name, media_size_west_edge_side_offset_by_tray=media_size_west_edge_side_offset_by_tray, consumable_status=consumable_status, error20_code=error20_code, file_systems=file_systems, error50_date_time=error50_date_time, warning22_code=warning22_code, error27_date_time=error27_date_time, media12_page_count=media12_page_count, pcfax_send_enabled=pcfax_send_enabled, media19_page_count=media19_page_count, media13=media13, collated_originals_support=collated_originals_support, consumable_status_expiration_date=consumable_status_expiration_date, firmware_download_write_time=firmware_download_write_time, outbin2=outbin2, error24=error24, warning9_date_time=warning9_date_time, media5_short_name=media5_short_name, error29_code=error29_code, warning9=warning9, error13_time_stamp=error13_time_stamp, localization_countries_supported=localization_countries_supported, scan_to_folder_count=scan_to_folder_count, media17_name=media17_name, error46_code=error46_code, warning16_date_time=warning16_date_time, error25_time_stamp=error25_time_stamp, default_custom_paper_dim_unit=default_custom_paper_dim_unit, print_meter_duplex_total=print_meter_duplex_total, consumable_string_information_reset=consumable_string_information_reset, usage_printer_mono_total_charge=usage_printer_mono_total_charge, intray5=intray5, warning50_date_time=warning50_date_time, error42_date_time=error42_date_time, supports_pjl_user_groups=supports_pjl_user_groups, pcl_total_page_count=pcl_total_page_count, usage_instructions_line3=usage_instructions_line3, fax_billing_code_enabled=fax_billing_code_enabled, source_tray_usage_count=source_tray_usage_count, warning42_code=warning42_code, error27_time_stamp=error27_time_stamp, error6_date_time=error6_date_time, consumable_current_state=consumable_current_state, intray1=intray1, remote_procedure_call=remote_procedure_call, error33_code=error33_code, pdf_total_page_count=pdf_total_page_count, background_status_msg_line1_part1=background_status_msg_line1_part1, warning49=warning49, error1_date_time=error1_date_time, printed_media_duplex_charge=printed_media_duplex_charge, error40_time_stamp=error40_time_stamp, error45_time_stamp=error45_time_stamp, warning5_time_stamp=warning5_time_stamp, warning33_code=warning33_code, error7_date_time=error7_date_time, error13_code=error13_code, status_fax_proc_sub=status_fax_proc_sub, overflow_bin=overflow_bin, outbin3_override_mode=outbin3_override_mode, printed_media_color_duplex_count=printed_media_color_duplex_count, device=device, warning36_code=warning36_code, error3=error3, warning12_time_stamp=warning12_time_stamp, asset_number=asset_number, error39=error39, printed_media_simplex_count=printed_media_simplex_count, media_size_count=media_size_count, mio=mio, job_info_accounting_yellow_dots=job_info_accounting_yellow_dots, warning2_date_time=warning2_date_time, pysmi_continue=pysmi_continue, ports=ports, media9=media9, scanner_accessory_adf_one_sided_sheet_count=scanner_accessory_adf_one_sided_sheet_count, cold_reset_media_size=cold_reset_media_size, dm=dm, held_job_quantity=held_job_quantity, error28=error28, media16_name=media16_name, non_assured_oht_page_count=non_assured_oht_page_count, security=security, warning35_date_time=warning35_date_time, ews_request_control_panel_supplies_status=ews_request_control_panel_supplies_status, media7_short_name=media7_short_name, consumable_pages_printed_with_supply=consumable_pages_printed_with_supply, job_info_accounting_magenta_dots=job_info_accounting_magenta_dots, warning28_time_stamp=warning28_time_stamp, error15=error15, warning13_code=warning13_code, io_switch=io_switch, error32=error32, warning30=warning30, resource_manager=resource_manager, firmware_download_maximum_write_count=firmware_download_maximum_write_count, warning46_code=warning46_code, warning22_time_stamp=warning22_time_stamp, job_info_io_source=job_info_io_source, scanner=scanner, sleep_mode=sleep_mode, media1_page_count=media1_page_count, warning39=warning39, error41_time_stamp=error41_time_stamp, usage_instructions_line1=usage_instructions_line1, intrays=intrays, error40=error40, consumables_status=consumables_status, error10=error10, tray6_phd=tray6_phd, error14_code=error14_code, warning10_date_time=warning10_date_time, error46_time_stamp=error46_time_stamp, fax_billing_code=fax_billing_code, daylight_savings_end=daylight_savings_end, media5_page_count=media5_page_count, warning8=warning8, foreign_interface=foreign_interface, upgradable_devices_version=upgradable_devices_version, warning13_time_stamp=warning13_time_stamp, status_rpc=status_rpc, warning29_time_stamp=warning29_time_stamp, print_engine=print_engine, error50_time_stamp=error50_time_stamp, configurable_low_threshold_setting=configurable_low_threshold_setting, mass_storage_resources=mass_storage_resources, error21_code=error21_code, warning19_code=warning19_code, warning41_time_stamp=warning41_time_stamp, job_info_accounting_grayscale_impression_count=job_info_accounting_grayscale_impression_count, warning2_time_stamp=warning2_time_stamp, error12=error12, error18_code=error18_code, error42_code=error42_code, printer_cal_dhalf_page_count=printer_cal_dhalf_page_count, error8_time_stamp=error8_time_stamp, warning11=warning11, job_info_attr_1=job_info_attr_1, error25=error25, imaging=imaging, error38=error38, media7=media7, warning5_date_time=warning5_date_time, warning41_date_time=warning41_date_time, error33_time_stamp=error33_time_stamp, printed_media_color_usage=printed_media_color_usage, media1_short_name=media1_short_name, consumables=consumables, scanned_media_duplex_count=scanned_media_duplex_count, warning42_time_stamp=warning42_time_stamp, error43_date_time=error43_date_time, mono_color_switching_mode=mono_color_switching_mode, mio1=mio1, error11_code=error11_code, outbin2_phd=outbin2_phd, upgradable_devices=upgradable_devices, media2_page_count=media2_page_count, firmware_download_name=firmware_download_name, settings_system=settings_system, destination_bin_accounting=destination_bin_accounting, error16=error16, warning3=warning3, job_being_parsed=job_being_parsed, media_size=media_size, control_panel_button_press=control_panel_button_press, error9=error9, error9_code=error9_code, error11_date_time=error11_date_time, error26_time_stamp=error26_time_stamp, error24_date_time=error24_date_time, warning25_date_time=warning25_date_time, warning25_code=warning25_code, date_and_time=date_and_time, error12_code=error12_code, print_media=print_media, media19_name=media19_name, error50_code=error50_code, default_copies=default_copies, background_message2=background_message2, media9_short_name=media9_short_name, warning50=warning50, warning26_time_stamp=warning26_time_stamp, warning36=warning36, job_info_attr_14=job_info_attr_14, consumable_life_usage_units=consumable_life_usage_units, error40_date_time=error40_date_time, warning48_code=warning48_code, device_location=device_location, energy_star=energy_star, warning23_code=warning23_code, printed_media_combined_total=printed_media_combined_total, media4_short_name=media4_short_name, error35_code=error35_code, scanned_media_simplex_count=scanned_media_simplex_count, held_job_print=held_job_print, error11_time_stamp=error11_time_stamp)
mibBuilder.exportSymbols("IJ8060-MIB", held_job_user_name=held_job_user_name, media3_short_name=media3_short_name, warning19_time_stamp=warning19_time_stamp, error22=error22, custom_paper_feed_dim=custom_paper_feed_dim, warning6_date_time=warning6_date_time, usage_printer_total_charge=usage_printer_total_charge, active_print_jobs=active_print_jobs, error28_time_stamp=error28_time_stamp, scanner_accessory_adf_sheet_count=scanner_accessory_adf_sheet_count, interface=interface, job_info_pages_processed=job_info_pages_processed, settings_pdl=settings_pdl, media_types=media_types, error23=error23, mio1_manufacturing_info=mio1_manufacturing_info, error32_time_stamp=error32_time_stamp, error6_time_stamp=error6_time_stamp, error45_date_time=error45_date_time, error1=error1, input_tray_auto_select=input_tray_auto_select, background_message=background_message, mio1_type=mio1_type, error46_date_time=error46_date_time, error10_time_stamp=error10_time_stamp, scanned_media_usage=scanned_media_usage, service_id=service_id, error47_time_stamp=error47_time_stamp, warning47_date_time=warning47_date_time, media12_short_name=media12_short_name, usage_staple_count=usage_staple_count, error41_code=error41_code, error2_time_stamp=error2_time_stamp, media18=media18, error35=error35, warning48_time_stamp=warning48_time_stamp, usb_vendor_id=usb_vendor_id, printed_media_color_total_count=printed_media_color_total_count, warning45_date_time=warning45_date_time, usage_printer_mono_duplex_total=usage_printer_mono_duplex_total, media14=media14, consumable_status_capacity_units=consumable_status_capacity_units, mio1_model_name=mio1_model_name, daylight_savings_reset=daylight_savings_reset, media18_page_count=media18_page_count, error15_code=error15_code, error8_code=error8_code, port1_parallel_bidirectionality=port1_parallel_bidirectionality, error_log_clear=error_log_clear, warning27_time_stamp=warning27_time_stamp, warning9_time_stamp=warning9_time_stamp, job_info_attr_11=job_info_attr_11, warninglog=warninglog, formatter_serial_number=formatter_serial_number, media_info=media_info, media16_short_name=media16_short_name, outbin2_override_mode=outbin2_override_mode, warning48=warning48, error30_code=error30_code, media14_page_count=media14_page_count, error24_code=error24_code, warning17_time_stamp=warning17_time_stamp, usb_driver_name=usb_driver_name, error32_code=error32_code, file_system=file_system, scanned_media_total_charge=scanned_media_total_charge, warning39_date_time=warning39_date_time, warning8_code=warning8_code, warning40_code=warning40_code, warning50_code=warning50_code, media2_name=media2_name, consumable_status_total_capacity=consumable_status_total_capacity, outbin3_phd=outbin3_phd, media2_short_name=media2_short_name, warning32_time_stamp=warning32_time_stamp, warning37_time_stamp=warning37_time_stamp, error13_date_time=error13_date_time, factory_reset=factory_reset, upgradable_devices_current_state=upgradable_devices_current_state, error37_time_stamp=error37_time_stamp, warning30_date_time=warning30_date_time, media_size_west_edge_second_side_offset=media_size_west_edge_second_side_offset, error49_time_stamp=error49_time_stamp, warning46=warning46, error17_code=error17_code, warning16=warning16, media10=media10, outbin4_error_info=outbin4_error_info, error46=error46, job_info_attr_2=job_info_attr_2, job_info_accounting_media_simplex_count=job_info_accounting_media_simplex_count, warning38=warning38, error23_date_time=error23_date_time, error44_code=error44_code, pdf_version=pdf_version, warning41=warning41, media11=media11, usb_manufacturer_name=usb_manufacturer_name, error20_time_stamp=error20_time_stamp, job_info_stage=job_info_stage, mio4_manufacturing_info=mio4_manufacturing_info, media5_name=media5_name, settings_job=settings_job, warning21_code=warning21_code, scanner_accessory_adf_two_sided_sheet_count=scanner_accessory_adf_two_sided_sheet_count, error33_date_time=error33_date_time, error19=error19, display_long_grain_optimization_warning=display_long_grain_optimization_warning, fw_rom_datecode=fw_rom_datecode, source_tray_usage_total=source_tray_usage_total, error43=error43, error25_date_time=error25_date_time, error8=error8, tray_disable_use_instead=tray_disable_use_instead, warning47=warning47, intray=intray, usb_host_supported=usb_host_supported, job_input_auto_continue_mode=job_input_auto_continue_mode, warning29=warning29, printed_media_color_dimplex_count=printed_media_color_dimplex_count, warning20_code=warning20_code, show_address=show_address, file_system_max_open_files=file_system_max_open_files, outbin4_override_mode=outbin4_override_mode, settings_print_media=settings_print_media, file_system2=file_system2, usage_instructions_line2=usage_instructions_line2, warning28_code=warning28_code, duplex_blank_pages=duplex_blank_pages, override_media_size=override_media_size, warning50_time_stamp=warning50_time_stamp, error39_code=error39_code, warning17=warning17, status_system=status_system, warning47_time_stamp=warning47_time_stamp, print_meter_simplex_total=print_meter_simplex_total, warning4_date_time=warning4_date_time, media8_short_name=media8_short_name, error19_time_stamp=error19_time_stamp, warning7=warning7, tray_prompt=tray_prompt, error29_date_time=error29_date_time, error1_time_stamp=error1_time_stamp, postscript_defer_media=postscript_defer_media, error19_date_time=error19_date_time, warning26_code=warning26_code, warning14_date_time=warning14_date_time, warning40_date_time=warning40_date_time, media12_name=media12_name, status_pdl=status_pdl, error17_time_stamp=error17_time_stamp, job_info_accounting_fixer_dots=job_info_accounting_fixer_dots, printed_media_color_simplex_count=printed_media_color_simplex_count, error26_code=error26_code, warning15=warning15, error21_time_stamp=error21_time_stamp, tray5_media_size_loaded=tray5_media_size_loaded, firmware_download_write_count=firmware_download_write_count, warning12=warning12, input_tray_min_media_xfeed_dim=input_tray_min_media_xfeed_dim, media6_page_count=media6_page_count, warning15_date_time=warning15_date_time, file_system4=file_system4, usage_printer_mono_simplex_total=usage_printer_mono_simplex_total, display_status=display_status, error22_date_time=error22_date_time, consumables_life=consumables_life, print_meter_duplex_count=print_meter_duplex_count, outbin1_maximum_binding=outbin1_maximum_binding, maximum_ram_disk_memory=maximum_ram_disk_memory, error47_code=error47_code)

#
# PySNMP MIB module CISCO-IPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IPSEC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
iso, Gauge32, NotificationType, Integer32, ModuleIdentity, ObjectIdentity, Bits, TimeTicks, Counter32, MibIdentifier, Counter64, IpAddress, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "NotificationType", "Integer32", "ModuleIdentity", "ObjectIdentity", "Bits", "TimeTicks", "Counter32", "MibIdentifier", "Counter64", "IpAddress", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
ciscoIPsecMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 62))
if mibBuilder.loadTexts: ciscoIPsecMIB.setLastUpdated('200008071139Z')
if mibBuilder.loadTexts: ciscoIPsecMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIPsecMIB.setContactInfo(' Cisco Systems Enterprise Business Management Unit Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-ipsecurity@cisco.com')
if mibBuilder.loadTexts: ciscoIPsecMIB.setDescription("The MIB module for modeling Cisco-specific IPsec attributes Overview of Cisco IPsec MIB MIB description This MIB models the Cisco implementation-specific attributes of a Cisco entity that implements IPsec. This MIB is complementary to the standard IPsec MIB proposed jointly by Tivoli and Cisco. The ciscoIPsec MIB provides the operational information on Cisco's IPsec tunnelling implementation. The following entities are managed: 1) ISAKMP Group: a) ISAKMP global parameters b) ISAKMP Policy Table 2) IPSec Group: a) IPSec Global Parameters b) IPSec Global Traffic Parameters c) Cryptomap Group - Cryptomap Set Table - Cryptomap Table - CryptomapSet Binding Table 3) System Capacity & Capability Group: a) Capacity Parameters b) Capability Parameters 4) Trap Control Group 5) Notifications Group")
class CIPsecLifetime(TextualConvention, Gauge32):
    description = 'Value in units of seconds'
    status = 'current'
    subtypeSpec = Gauge32.subtypeSpec + ValueRangeConstraint(120, 86400)

class CIPsecLifesize(TextualConvention, Gauge32):
    description = 'Value in units of kilobytes'
    status = 'current'
    subtypeSpec = Gauge32.subtypeSpec + ValueRangeConstraint(2560, 536870912)

class CIPsecNumCryptoMaps(TextualConvention, Gauge32):
    description = 'Integral units representing count of cryptomaps'
    status = 'current'
    subtypeSpec = Gauge32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class CryptomapType(TextualConvention, Integer32):
    description = 'The type of a cryptomap entry. Cryptomap is a unit of IOS IPSec policy specification.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("cryptomapTypeNONE", 0), ("cryptomapTypeMANUAL", 1), ("cryptomapTypeISAKMP", 2), ("cryptomapTypeCET", 3), ("cryptomapTypeDYNAMIC", 4), ("cryptomapTypeDYNAMICDISCOVERY", 5))

class CryptomapSetBindStatus(TextualConvention, Integer32):
    description = "The status of the binding of a cryptomap set to the specified interface. The value qhen queried is always 'attached'. When set to 'detached', the cryptomap set if detached from the specified interface. Setting the value to 'attached' will result in SNMP General Error."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("attached", 1), ("detached", 2))

class IPSIpAddress(TextualConvention, OctetString):
    description = 'An IP V4 or V6 Address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )
class IkeHashAlgo(TextualConvention, Integer32):
    description = 'The hash algorithm used in IPsec Phase-1 IKE negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("md5", 2), ("sha", 3))

class IkeAuthMethod(TextualConvention, Integer32):
    description = 'The authentication method used in IPsec Phase-1 IKE negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("preSharedKey", 2), ("rsaSig", 3), ("rsaEncrypt", 4), ("revPublicKey", 5))

class IkeIdentityType(TextualConvention, Integer32):
    description = 'The type of identity used by the local entity to identity itself to the peer with which it performs IPSec Main Mode negotiations. This type decides the content of the Identification payload in the Main Mode of IPSec tunnel setup.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("isakmpIdTypeUNKNOWN", 0), ("isakmpIdTypeADDRESS", 1), ("isakmpIdTypeHOSTNAME", 2))

class DiffHellmanGrp(TextualConvention, Integer32):
    description = 'The Diffie Hellman Group used in negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("dhGroup1", 2), ("dhGroup2", 3))

class EncryptAlgo(TextualConvention, Integer32):
    description = 'The encryption algorithm used in negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("des", 2), ("des3", 3))

class TrapStatus(TextualConvention, Integer32):
    description = 'The administrative status for sending a TRAP.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

ciscoIPsecMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1))
ciscoIPsecMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 2))
ciscoIPsecMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 3))
cipsIsakmpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1))
cipsIPsecGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2))
cipsIPsecGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1))
cipsIPsecStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 2))
cipsCryptomapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3))
cipsSysCapacityGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 3))
cipsTrapCntlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4))
cipsIsakmpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpEnabled.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpEnabled.setDescription('The value of this object is TRUE if ISAKMP has been enabled on the managed entity. Otherise the value of this object is FALSE.')
cipsIsakmpIdentity = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 2), IkeIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpIdentity.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpIdentity.setDescription('The value of this object is shows the type of identity used by the managed entity in ISAKMP negotiations with another peer.')
cipsIsakmpKeepaliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpKeepaliveInterval.setDescription('The value of this object is time interval in seconds between successive ISAKMP keepalive heartbeats issued to the peers to which IKE tunnels have been setup.')
cipsNumIsakmpPolicies = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumIsakmpPolicies.setStatus('current')
if mibBuilder.loadTexts: cipsNumIsakmpPolicies.setDescription('The value of this object is the number of ISAKMP policies that have been configured on the managed entity.')
cipsIsakmpPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5), )
if mibBuilder.loadTexts: cipsIsakmpPolicyTable.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolicyTable.setDescription('The table containing the list of all ISAKMP policy entries configured by the operator.')
cipsIsakmpPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-IPSEC-MIB", "cipsIsakmpPolPriority"))
if mibBuilder.loadTexts: cipsIsakmpPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolicyEntry.setDescription('Each entry contains the attributes associated with a single ISAKMP Policy entry.')
cipsIsakmpPolPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: cipsIsakmpPolPriority.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolPriority.setDescription('The priotity of this ISAKMP Policy entry. This is also the index of this table.')
cipsIsakmpPolEncr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 2), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpPolEncr.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolEncr.setDescription('The encryption transform specified by this ISAKMP policy specification. The Internet Key Exchange (IKE) tunnels setup using this policy item would use the specified encryption transform to protect the ISAKMP PDUs.')
cipsIsakmpPolHash = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 3), IkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpPolHash.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolHash.setDescription('The hash transform specified by this ISAKMP policy specification. The IKE tunnels setup using this policy item would use the specified hash transform to protect the ISAKMP PDUs.')
cipsIsakmpPolAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 4), IkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpPolAuth.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolAuth.setDescription('The peer authentication mthod specified by this ISAKMP policy specification. If this policy entity is selected for negotiation with a peer, the local entity would authenticate the peer using the method specified by this object.')
cipsIsakmpPolGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 5), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpPolGroup.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolGroup.setDescription('This object specifies the Oakley group used for Diffie Hellman exchange in the Main Mode. If this policy item is selected to negotiate Main Mode with an IKE peer, the local entity chooses the group specified by this object to perform Diffie Hellman exchange with the peer.')
cipsIsakmpPolLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsIsakmpPolLifetime.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolLifetime.setDescription('This object specifies the lifetime in seconds of the IKE tunnels generated using this policy specification.')
cipsSALifetime = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 1), CIPsecLifetime()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsSALifetime.setStatus('current')
if mibBuilder.loadTexts: cipsSALifetime.setDescription('The default lifetime (in seconds) assigned to an SA as a global policy (maybe overridden in specific cryptomap definitions).')
cipsSALifesize = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 2), CIPsecLifesize()).setUnits('KBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsSALifesize.setStatus('current')
if mibBuilder.loadTexts: cipsSALifesize.setDescription('The default lifesize in KBytes assigned to an SA as a global policy (unless overridden in cryptomap definition)')
cipsNumStaticCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 3), CIPsecNumCryptoMaps()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumStaticCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumStaticCryptomapSets.setDescription('The number of Cryptomap Sets that are are fully configured. Statically defined cryptomap sets are ones where the operator has fully specified all the parameters required set up IPSec Virtual Private Networks (VPNs).')
cipsNumCETCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 4), CIPsecNumCryptoMaps()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumCETCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumCETCryptomapSets.setDescription('The number of static Cryptomap Sets that have at least one CET cryptomap element as a member of the set.')
cipsNumDynamicCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 5), CIPsecNumCryptoMaps()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumDynamicCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumDynamicCryptomapSets.setDescription("The number of dynamic IPSec Policy templates (called 'dynamic cryptomap templates') configured on the managed entity.")
cipsNumTEDCryptomapSets = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 1, 6), CIPsecNumCryptoMaps()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumTEDCryptomapSets.setStatus('current')
if mibBuilder.loadTexts: cipsNumTEDCryptomapSets.setDescription('The number of static Cryptomap Sets that have at least one dynamic cryptomap template bound to them which has the Tunnel Endpoint Discovery (TED) enabled.')
cipsNumTEDProbesReceived = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 2, 1), Counter32()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumTEDProbesReceived.setStatus('current')
if mibBuilder.loadTexts: cipsNumTEDProbesReceived.setDescription('The number of TED probes that were received by this managed entity since bootup. Not affected by any CLI operation.')
cipsNumTEDProbesSent = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 2, 2), Counter32()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumTEDProbesSent.setStatus('current')
if mibBuilder.loadTexts: cipsNumTEDProbesSent.setDescription('The number of TED probes that were dispatched by all the dynamic cryptomaps in this managed entity since bootup. Not affected by any CLI operation.')
cipsNumTEDFailures = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 2, 3), Counter32()).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsNumTEDFailures.setStatus('current')
if mibBuilder.loadTexts: cipsNumTEDFailures.setDescription('The number of TED probes that were dispatched by the local entity and that failed to locate crypto endpoint. Not affected by any CLI operation.')
cipsMaxSAs = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('Integral Units').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsMaxSAs.setStatus('current')
if mibBuilder.loadTexts: cipsMaxSAs.setDescription('The maximum number of IPsec Security Associations that can be established on this managed entity. If no theoretical limit exists, this returns value 0. Not affected by any CLI operation.')
cips3DesCapable = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 3, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cips3DesCapable.setStatus('current')
if mibBuilder.loadTexts: cips3DesCapable.setDescription('The value of this object is TRUE if the managed entity has the hardware nad software features to support 3DES encryption algorithm. Not affected by any CLI operation.')
cipsStaticCryptomapSetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1), )
if mibBuilder.loadTexts: cipsStaticCryptomapSetTable.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetTable.setDescription('The table containing the list of all cryptomap sets that are fully specified and are not wild-carded. The operator may include different types of cryptomaps in such a set - manual, CET, ISAKMP or dynamic.')
cipsStaticCryptomapSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1), ).setIndexNames((0, "CISCO-IPSEC-MIB", "cipsStaticCryptomapSetName"))
if mibBuilder.loadTexts: cipsStaticCryptomapSetEntry.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetEntry.setDescription('Each entry contains the attributes associated with a single static cryptomap set.')
cipsStaticCryptomapSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 1), DisplayString())
if mibBuilder.loadTexts: cipsStaticCryptomapSetName.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetName.setDescription('The index of the static cryptomap table. The value of the string is the name string assigned by the operator in defining the cryptomap set.')
cipsStaticCryptomapSetSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetSize.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetSize.setDescription('The total number of cryptomap entries contained in this cryptomap set. ')
cipsStaticCryptomapSetNumIsakmp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumIsakmp.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumIsakmp.setDescription('The number of cryptomaps associated with this cryptomap set that use ISAKMP protocol to do key exchange.')
cipsStaticCryptomapSetNumManual = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumManual.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumManual.setDescription('The number of cryptomaps associated with this cryptomap set that require the operator to manually setup the keys and SPIs.')
cipsStaticCryptomapSetNumCET = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumCET.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumCET.setDescription("The number of cryptomaps of type 'ipsec-cisco' associated with this cryptomap set. Such cryptomap elements implement Cisco Encryption Technology based Virtual Private Networks.")
cipsStaticCryptomapSetNumDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDynamic.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDynamic.setDescription('The number of dynamic cryptomap templates linked to this cryptomap set.')
cipsStaticCryptomapSetNumDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDisc.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumDisc.setDescription('The number of dynamic cryptomap templates linked to this cryptomap set that have Tunnel Endpoint Discovery (TED) enabled.')
cipsStaticCryptomapSetNumSAs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumSAs.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapSetNumSAs.setDescription('The number of and IPsec Security Associations that are active and were setup using this cryptomap. ')
cipsDynamicCryptomapSetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 2), )
if mibBuilder.loadTexts: cipsDynamicCryptomapSetTable.setStatus('current')
if mibBuilder.loadTexts: cipsDynamicCryptomapSetTable.setDescription('The table containing the list of all dynamic cryptomaps that use IKE, defined on the managed entity.')
cipsDynamicCryptomapSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 2, 1), ).setIndexNames((0, "CISCO-IPSEC-MIB", "cipsDynamicCryptomapSetName"))
if mibBuilder.loadTexts: cipsDynamicCryptomapSetEntry.setStatus('current')
if mibBuilder.loadTexts: cipsDynamicCryptomapSetEntry.setDescription('Each entry contains the attributes associated with a single dynamic cryptomap template.')
cipsDynamicCryptomapSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 2, 1, 1), DisplayString())
if mibBuilder.loadTexts: cipsDynamicCryptomapSetName.setStatus('current')
if mibBuilder.loadTexts: cipsDynamicCryptomapSetName.setDescription('The index of the dynamic cryptomap table. The value of the string is the one assigned by the operator in defining the cryptomap set.')
cipsDynamicCryptomapSetSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsDynamicCryptomapSetSize.setStatus('current')
if mibBuilder.loadTexts: cipsDynamicCryptomapSetSize.setDescription('The number of cryptomap entries in this cryptomap.')
cipsDynamicCryptomapSetNumAssoc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsDynamicCryptomapSetNumAssoc.setStatus('current')
if mibBuilder.loadTexts: cipsDynamicCryptomapSetNumAssoc.setDescription('The number of static cryptomap sets with which this dynamic cryptomap is associated. ')
cipsStaticCryptomapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3), )
if mibBuilder.loadTexts: cipsStaticCryptomapTable.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapTable.setDescription('The table ilisting the member cryptomaps of the cryptomap sets that are configured on the managed entity.')
cipsStaticCryptomapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1), ).setIndexNames((0, "CISCO-IPSEC-MIB", "cipsStaticCryptomapSetName"), (0, "CISCO-IPSEC-MIB", "cipsStaticCryptomapPriority"))
if mibBuilder.loadTexts: cipsStaticCryptomapEntry.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapEntry.setDescription('Each entry contains the attributes associated with a single static (fully specified) cryptomap entry. This table does not include the members of dynamic cryptomap sets that may be linked with the parent static cryptomap set.')
cipsStaticCryptomapPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: cipsStaticCryptomapPriority.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapPriority.setDescription('The priority of the cryptomap entry in the cryptomap set. This is the second index component of this table.')
cipsStaticCryptomapType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 2), CryptomapType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapType.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapType.setDescription('The type of the cryptomap entry. This can be an ISAKMP cryptomap, CET or manual. Dynamic cryptomaps are not counted in this table.')
cipsStaticCryptomapDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapDescr.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapDescr.setDescription('The description string entered by the operatoir while creating this cryptomap. The string generally identifies a description and the purpose of this policy.')
cipsStaticCryptomapPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapPeer.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapPeer.setDescription('The IP address of the current peer associated with this IPSec policy item. Traffic that is protected by this cryptomap is protected by a tunnel that terminates at the device whose IP address is specified by this object.')
cipsStaticCryptomapNumPeers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapNumPeers.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapNumPeers.setDescription("The number of peers associated with this cryptomap entry. The peers other than the one identified by 'cipsStaticCryptomapPeer' are backup peers. Manual cryptomaps may have only one peer.")
cipsStaticCryptomapPfs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 6), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapPfs.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapPfs.setDescription('This object identifies if the tunnels instantiated due to this policy item should use Perfect Forward Secrecy (PFS) and if so, what group of Oakley they should use.')
cipsStaticCryptomapLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(120, 86400), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapLifetime.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLifetime.setDescription('This object identifies the lifetime of the IPSec Security Associations (SA) created using this IPSec policy entry. If this value is zero, the lifetime assumes the value specified by the global lifetime parameter.')
cipsStaticCryptomapLifesize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2560, 536870912), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapLifesize.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLifesize.setDescription('This object identifies the lifesize (maximum traffic in bytes that may be carried) of the IPSec SAs created using this IPSec policy entry. If this value is zero, the lifetime assumes the value specified by the global lifesize parameter.')
cipsStaticCryptomapLevelHost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 3, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsStaticCryptomapLevelHost.setStatus('current')
if mibBuilder.loadTexts: cipsStaticCryptomapLevelHost.setDescription('This object identifies the granularity of the IPSec SAs created using this IPSec policy entry. If this value is TRUE, distinct SA bundles are created for distinct hosts at the end of the application traffic.')
cipsCryptomapSetIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 4), )
if mibBuilder.loadTexts: cipsCryptomapSetIfTable.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfTable.setDescription('The table lists the binding of cryptomap sets to the interfaces of the managed entity.')
cipsCryptomapSetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-IPSEC-MIB", "cipsStaticCryptomapSetName"))
if mibBuilder.loadTexts: cipsCryptomapSetIfEntry.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfEntry.setDescription('Each entry contains the record of the association between an interface and a cryptomap set (static) that is defined on the managed entity. Note that the cryptomap set identified in this binding must static. Dynamic cryptomaps cannot be bound to interfaces.')
cipsCryptomapSetIfVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 4, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipsCryptomapSetIfVirtual.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfVirtual.setDescription('The value of this object identifies if the interface to which the cryptomap set is attached is a tunnel (such as a GRE or PPTP tunnel).')
cipsCryptomapSetIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 2, 3, 4, 1, 2), CryptomapSetBindStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCryptomapSetIfStatus.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetIfStatus.setDescription("This object identifies the status of the binding of the specified cryptomap set with the specified interface. The value when queried is always 'attached'. When set to 'detached', the cryptomap set if detached from the specified interface. The effect of this is same as the CLI command config-if# no crypto map cryptomapSetName Setting the value to 'attached' will result in SNMP General Error.")
cipsCntlIsakmpPolicyAdded = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 1), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlIsakmpPolicyAdded.setStatus('current')
if mibBuilder.loadTexts: cipsCntlIsakmpPolicyAdded.setDescription('This object defines the administrative state of sending the IOS IPsec ISAKMP Policy Add trap.')
cipsCntlIsakmpPolicyDeleted = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 2), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlIsakmpPolicyDeleted.setStatus('current')
if mibBuilder.loadTexts: cipsCntlIsakmpPolicyDeleted.setDescription('This object defines the administrative state of sending the IOS IPsec ISAKMP Policy Delete trap.')
cipsCntlCryptomapAdded = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 3), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapAdded.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapAdded.setDescription('This object defines the administrative state of sending the IOS IPsec Cryptomap Add trap.')
cipsCntlCryptomapDeleted = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 4), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapDeleted.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapDeleted.setDescription('This object defines the administrative state of sending the IOS IPsec Cryptomap Delete trap.')
cipsCntlCryptomapSetAttached = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 5), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapSetAttached.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapSetAttached.setDescription('This object defines the administrative state of sending the IOS IPsec trap that is issued when a cryptomap set is attached to an interface.')
cipsCntlCryptomapSetDetached = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 6), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlCryptomapSetDetached.setStatus('current')
if mibBuilder.loadTexts: cipsCntlCryptomapSetDetached.setDescription('This object defines the administrative state of sending the IOS IPsec trap that is issued when a cryptomap set is detached from an interface. to which it was earlier bound.')
cipsCntlTooManySAs = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 62, 1, 4, 7), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipsCntlTooManySAs.setStatus('current')
if mibBuilder.loadTexts: cipsCntlTooManySAs.setDescription('This object defines the administrative state of sending the IOS IPsec trap that is issued when the number of SAs crosses the maximum number of SAs that may be supported on the managed entity.')
cipsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0))
cipsIsakmpPolicyAdded = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 1)).setObjects(("CISCO-IPSEC-MIB", "cipsNumIsakmpPolicies"))
if mibBuilder.loadTexts: cipsIsakmpPolicyAdded.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolicyAdded.setDescription('This trap is generated when a new ISAKMP policy element is defined on the managed entity. The context of the event includes the updated number of ISAKMP policy elements currently available.')
cipsIsakmpPolicyDeleted = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 2)).setObjects(("CISCO-IPSEC-MIB", "cipsNumIsakmpPolicies"))
if mibBuilder.loadTexts: cipsIsakmpPolicyDeleted.setStatus('current')
if mibBuilder.loadTexts: cipsIsakmpPolicyDeleted.setDescription('This trap is generated when an existing ISAKMP policy element is deleted on the managed entity. The context of the event includes the updated number of ISAKMP policy elements currently available.')
cipsCryptomapAdded = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 3)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapType"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: cipsCryptomapAdded.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapAdded.setDescription('This trap is generated when a new cryptomap is added to the specified cryptomap set.')
cipsCryptomapDeleted = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 4)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: cipsCryptomapDeleted.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapDeleted.setDescription('This trap is generated when a cryptomap is removed from the specified cryptomap set.')
cipsCryptomapSetAttached = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 5)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetSize"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumIsakmp"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumDynamic"))
if mibBuilder.loadTexts: cipsCryptomapSetAttached.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetAttached.setDescription('A cryptomap set must be attached to an interface of the device in order for it to be operational. This trap is generated when the cryptomap set attached to an active interface of the managed entity. The context of the notification includes: Size of the attached cryptomap set, Number of ISAKMP cryptomaps in the set and Number of Dynamic cryptomaps in the set.')
cipsCryptomapSetDetached = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 6)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetSize"))
if mibBuilder.loadTexts: cipsCryptomapSetDetached.setStatus('current')
if mibBuilder.loadTexts: cipsCryptomapSetDetached.setDescription('This trap is generated when a cryptomap set is detached from an interafce to which it was bound earlier. The context of the event identifies the size of the cryptomap set.')
cipsTooManySAs = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 62, 2, 0, 7)).setObjects(("CISCO-IPSEC-MIB", "cipsMaxSAs"))
if mibBuilder.loadTexts: cipsTooManySAs.setStatus('current')
if mibBuilder.loadTexts: cipsTooManySAs.setDescription('This trap is generated when a new SA is attempted to be setup while the number of currently active SAs equals the maximum configurable. The variables are: cipsMaxSAs')
cipsMIBConformances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 1))
cipsMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2))
cipsMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 1, 1)).setObjects(("CISCO-IPSEC-MIB", "cipsMIBConfIsakmpGroup"), ("CISCO-IPSEC-MIB", "cipsMIBConfIPSecGlobalsGroup"), ("CISCO-IPSEC-MIB", "cipsMIBConfCapacityGroup"), ("CISCO-IPSEC-MIB", "cipsMIBStaticCryptomapGroup"), ("CISCO-IPSEC-MIB", "cipsMIBMandatoryNotifCntlGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBCompliance = cipsMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cipsMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco IPsec MIB')
cipsMIBConfIsakmpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 1)).setObjects(("CISCO-IPSEC-MIB", "cipsIsakmpEnabled"), ("CISCO-IPSEC-MIB", "cipsIsakmpIdentity"), ("CISCO-IPSEC-MIB", "cipsIsakmpKeepaliveInterval"), ("CISCO-IPSEC-MIB", "cipsNumIsakmpPolicies"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBConfIsakmpGroup = cipsMIBConfIsakmpGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBConfIsakmpGroup.setDescription('A collection of objects providing Global ISAKMP policy monitoring capability to a Cisco IPsec capable VPN router.')
cipsMIBConfIPSecGlobalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 2)).setObjects(("CISCO-IPSEC-MIB", "cipsSALifetime"), ("CISCO-IPSEC-MIB", "cipsSALifesize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBConfIPSecGlobalsGroup = cipsMIBConfIPSecGlobalsGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBConfIPSecGlobalsGroup.setDescription('A collection of objects providing Global IPSec policy monitoring capability to a Cisco IPsec capable VPN router.')
cipsMIBConfCapacityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 3)).setObjects(("CISCO-IPSEC-MIB", "cipsMaxSAs"), ("CISCO-IPSEC-MIB", "cips3DesCapable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBConfCapacityGroup = cipsMIBConfCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBConfCapacityGroup.setDescription('A collection of objects providing IPsec System Capacity monitoring capability to a Cisco IPsec capable VPN router.')
cipsMIBStaticCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 4)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetSize"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumIsakmp"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumCET"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumSAs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBStaticCryptomapGroup = cipsMIBStaticCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBStaticCryptomapGroup.setDescription('A collection of objects instrumenting the properties of the Static (fully specified) Cryptomap Sets on an IPsec-capable IOS router.')
cipsMIBManualCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 5)).setObjects(("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumManual"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBManualCryptomapGroup = cipsMIBManualCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBManualCryptomapGroup.setDescription('A collection of objects instrumenting the properties of the Manual Cryptomap entries on a Cisco IPsec capable IOS router.')
cipsMIBDynamicCryptomapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 6)).setObjects(("CISCO-IPSEC-MIB", "cipsNumTEDProbesReceived"), ("CISCO-IPSEC-MIB", "cipsNumTEDProbesSent"), ("CISCO-IPSEC-MIB", "cipsNumTEDFailures"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumDynamic"), ("CISCO-IPSEC-MIB", "cipsStaticCryptomapSetNumDisc"), ("CISCO-IPSEC-MIB", "cipsNumTEDCryptomapSets"), ("CISCO-IPSEC-MIB", "cipsDynamicCryptomapSetSize"), ("CISCO-IPSEC-MIB", "cipsDynamicCryptomapSetNumAssoc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBDynamicCryptomapGroup = cipsMIBDynamicCryptomapGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBDynamicCryptomapGroup.setDescription('A collection of objects instrumenting the properties of the Dynamic Cryptomap group on a Cisco IPsec capable IOS router.')
cipsMIBMandatoryNotifCntlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 62, 3, 2, 7)).setObjects(("CISCO-IPSEC-MIB", "cipsCntlIsakmpPolicyAdded"), ("CISCO-IPSEC-MIB", "cipsCntlIsakmpPolicyDeleted"), ("CISCO-IPSEC-MIB", "cipsCntlCryptomapAdded"), ("CISCO-IPSEC-MIB", "cipsCntlCryptomapDeleted"), ("CISCO-IPSEC-MIB", "cipsCntlCryptomapSetAttached"), ("CISCO-IPSEC-MIB", "cipsCntlCryptomapSetDetached"), ("CISCO-IPSEC-MIB", "cipsCntlTooManySAs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cipsMIBMandatoryNotifCntlGroup = cipsMIBMandatoryNotifCntlGroup.setStatus('current')
if mibBuilder.loadTexts: cipsMIBMandatoryNotifCntlGroup.setDescription('A collection of objects providing IPsec Notification capability to a IPsec-capable IOS router. It is mandatory to implement this set of objects pertaining to IOS notifications about IPSec activity.')
mibBuilder.exportSymbols("CISCO-IPSEC-MIB", cipsIPsecGlobals=cipsIPsecGlobals, cipsCryptomapSetIfVirtual=cipsCryptomapSetIfVirtual, cipsStaticCryptomapSetNumManual=cipsStaticCryptomapSetNumManual, cipsStaticCryptomapDescr=cipsStaticCryptomapDescr, cipsIsakmpGroup=cipsIsakmpGroup, cipsDynamicCryptomapSetSize=cipsDynamicCryptomapSetSize, cipsCryptomapAdded=cipsCryptomapAdded, cipsTrapCntlGroup=cipsTrapCntlGroup, cipsCryptomapSetIfEntry=cipsCryptomapSetIfEntry, cipsMIBConfIPSecGlobalsGroup=cipsMIBConfIPSecGlobalsGroup, cipsStaticCryptomapSetNumIsakmp=cipsStaticCryptomapSetNumIsakmp, cipsMIBMandatoryNotifCntlGroup=cipsMIBMandatoryNotifCntlGroup, cipsNumTEDFailures=cipsNumTEDFailures, ciscoIPsecMIB=ciscoIPsecMIB, cipsStaticCryptomapPfs=cipsStaticCryptomapPfs, cipsStaticCryptomapSetSize=cipsStaticCryptomapSetSize, CryptomapSetBindStatus=CryptomapSetBindStatus, ciscoIPsecMIBNotificationPrefix=ciscoIPsecMIBNotificationPrefix, cipsNumCETCryptomapSets=cipsNumCETCryptomapSets, cipsNumStaticCryptomapSets=cipsNumStaticCryptomapSets, cipsIsakmpPolPriority=cipsIsakmpPolPriority, IkeHashAlgo=IkeHashAlgo, cipsCryptomapSetAttached=cipsCryptomapSetAttached, cipsMIBDynamicCryptomapGroup=cipsMIBDynamicCryptomapGroup, cips3DesCapable=cips3DesCapable, cipsIsakmpPolicyTable=cipsIsakmpPolicyTable, cipsStaticCryptomapPeer=cipsStaticCryptomapPeer, cipsSysCapacityGroup=cipsSysCapacityGroup, cipsStaticCryptomapLevelHost=cipsStaticCryptomapLevelHost, cipsIsakmpKeepaliveInterval=cipsIsakmpKeepaliveInterval, cipsMIBCompliance=cipsMIBCompliance, cipsNumDynamicCryptomapSets=cipsNumDynamicCryptomapSets, cipsIsakmpPolicyEntry=cipsIsakmpPolicyEntry, cipsStaticCryptomapType=cipsStaticCryptomapType, cipsDynamicCryptomapSetEntry=cipsDynamicCryptomapSetEntry, cipsIsakmpPolEncr=cipsIsakmpPolEncr, ciscoIPsecMIBObjects=ciscoIPsecMIBObjects, cipsMIBStaticCryptomapGroup=cipsMIBStaticCryptomapGroup, cipsStaticCryptomapSetName=cipsStaticCryptomapSetName, cipsNumTEDProbesSent=cipsNumTEDProbesSent, cipsMIBConfCapacityGroup=cipsMIBConfCapacityGroup, cipsCntlTooManySAs=cipsCntlTooManySAs, cipsIsakmpPolAuth=cipsIsakmpPolAuth, IPSIpAddress=IPSIpAddress, ciscoIPsecMIBConformance=ciscoIPsecMIBConformance, cipsMaxSAs=cipsMaxSAs, cipsDynamicCryptomapSetNumAssoc=cipsDynamicCryptomapSetNumAssoc, cipsIsakmpPolHash=cipsIsakmpPolHash, cipsStaticCryptomapTable=cipsStaticCryptomapTable, CryptomapType=CryptomapType, cipsMIBConformances=cipsMIBConformances, cipsStaticCryptomapNumPeers=cipsStaticCryptomapNumPeers, cipsNumTEDProbesReceived=cipsNumTEDProbesReceived, cipsCryptomapDeleted=cipsCryptomapDeleted, cipsStaticCryptomapSetNumSAs=cipsStaticCryptomapSetNumSAs, cipsStaticCryptomapSetNumDynamic=cipsStaticCryptomapSetNumDynamic, cipsStaticCryptomapLifesize=cipsStaticCryptomapLifesize, cipsCntlCryptomapAdded=cipsCntlCryptomapAdded, cipsIsakmpPolicyAdded=cipsIsakmpPolicyAdded, IkeIdentityType=IkeIdentityType, cipsIsakmpIdentity=cipsIsakmpIdentity, cipsCryptomapSetIfTable=cipsCryptomapSetIfTable, cipsDynamicCryptomapSetTable=cipsDynamicCryptomapSetTable, PYSNMP_MODULE_ID=ciscoIPsecMIB, cipsMIBManualCryptomapGroup=cipsMIBManualCryptomapGroup, cipsMIBNotifications=cipsMIBNotifications, cipsIsakmpEnabled=cipsIsakmpEnabled, cipsTooManySAs=cipsTooManySAs, cipsStaticCryptomapSetEntry=cipsStaticCryptomapSetEntry, cipsCntlCryptomapSetAttached=cipsCntlCryptomapSetAttached, cipsMIBConfIsakmpGroup=cipsMIBConfIsakmpGroup, CIPsecLifesize=CIPsecLifesize, cipsDynamicCryptomapSetName=cipsDynamicCryptomapSetName, cipsCryptomapGroup=cipsCryptomapGroup, cipsCntlCryptomapDeleted=cipsCntlCryptomapDeleted, TrapStatus=TrapStatus, cipsNumIsakmpPolicies=cipsNumIsakmpPolicies, cipsIsakmpPolicyDeleted=cipsIsakmpPolicyDeleted, cipsStaticCryptomapLifetime=cipsStaticCryptomapLifetime, cipsCntlCryptomapSetDetached=cipsCntlCryptomapSetDetached, EncryptAlgo=EncryptAlgo, cipsIPsecStatistics=cipsIPsecStatistics, cipsCntlIsakmpPolicyAdded=cipsCntlIsakmpPolicyAdded, IkeAuthMethod=IkeAuthMethod, cipsSALifetime=cipsSALifetime, cipsStaticCryptomapSetNumCET=cipsStaticCryptomapSetNumCET, cipsStaticCryptomapSetTable=cipsStaticCryptomapSetTable, cipsCntlIsakmpPolicyDeleted=cipsCntlIsakmpPolicyDeleted, cipsIsakmpPolLifetime=cipsIsakmpPolLifetime, cipsStaticCryptomapEntry=cipsStaticCryptomapEntry, DiffHellmanGrp=DiffHellmanGrp, cipsCryptomapSetDetached=cipsCryptomapSetDetached, cipsStaticCryptomapSetNumDisc=cipsStaticCryptomapSetNumDisc, CIPsecNumCryptoMaps=CIPsecNumCryptoMaps, cipsNumTEDCryptomapSets=cipsNumTEDCryptomapSets, cipsSALifesize=cipsSALifesize, cipsCryptomapSetIfStatus=cipsCryptomapSetIfStatus, CIPsecLifetime=CIPsecLifetime, cipsStaticCryptomapPriority=cipsStaticCryptomapPriority, cipsIsakmpPolGroup=cipsIsakmpPolGroup, cipsIPsecGroup=cipsIPsecGroup, cipsMIBGroups=cipsMIBGroups)

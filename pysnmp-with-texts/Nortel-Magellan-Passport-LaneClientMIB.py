#
# PySNMP MIB module Nortel-Magellan-Passport-LaneClientMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-LaneClientMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:27:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
InterfaceIndex, DisplayString, StorageType, Integer32, RowPointer, RowStatus, Counter32, Unsigned32, MacAddress = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "InterfaceIndex", "DisplayString", "StorageType", "Integer32", "RowPointer", "RowStatus", "Counter32", "Unsigned32", "MacAddress")
NonReplicated, AsciiString, DashedHexString, Link, HexString = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "NonReplicated", "AsciiString", "DashedHexString", "Link", "HexString")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, IpAddress, MibIdentifier, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, iso, ObjectIdentity, Integer32, Bits, Gauge32, Counter32, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "IpAddress", "MibIdentifier", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "iso", "ObjectIdentity", "Integer32", "Bits", "Gauge32", "Counter32", "Unsigned32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
laneClientMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71))
lec = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124))
lecRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1), )
if mibBuilder.loadTexts: lecRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecRowStatusTable.setDescription('This entry controls the addition and deletion of lec components.')
lecRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecRowStatusEntry.setDescription('A single entry in the table represents a single lec component.')
lecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecRowStatus.setDescription('This variable is used as the basis for SNMP naming of lec components. These components can be added and deleted.')
lecComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lecComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lecStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lecStorageType.setDescription('This variable represents the storage type value for the lec tables.')
lecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: lecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecIndex.setDescription('This variable represents the index for the lec tables.')
lecCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 10), )
if mibBuilder.loadTexts: lecCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lecCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecCidDataEntry.setDescription('An entry in the lecCidDataTable.')
lecCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lecCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lecIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 11), )
if mibBuilder.loadTexts: lecIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lecIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecIfEntryEntry.setDescription('An entry in the lecIfEntryTable.')
lecIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lecIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lecMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 12), )
if mibBuilder.loadTexts: lecMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecMpTable.setDescription('This group contains the base provisioning data for the Media Application component.')
lecMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecMpEntry.setDescription('An entry in the lecMpTable.')
lecLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: lecLinkToProtocolPort.setDescription('This attribute contains a protocol port component name. The attribute associates the application with a protocol port.')
lecProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13), )
if mibBuilder.loadTexts: lecProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecProvTable.setDescription('This group contains the provisionable attributes for the LanEmulationClient component.')
lecProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecProvEntry.setDescription('An entry in the lecProvTable.')
lecLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unspecified", 1), ("ethernet", 2))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecLanType.setStatus('mandatory')
if mibBuilder.loadTexts: lecLanType.setDescription('This attribute specifies the data frame format for this LEC. Auto- configuring LECs use this attribute in their Configure requests. Manually-configured LECs use it in their Join requests. A value of unspecified implies that the data frame format is obtained from the LECS or LES. The value of this attribute may be overridden by the LECS or LES; actualLanType contains the actual value.')
lecMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1516, 1580, 4544, 9234, 18190))).clone(namedValues=NamedValues(("unspecified", 0), ("n1516", 1516), ("n1580", 1580), ("n4544", 4544), ("n9234", 9234), ("n18190", 18190))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: lecMaxFrameSize.setDescription('This attribute specifies the maximum data frame size for this LEC. Auto-configuring LECs use this attribute in their Configure requests. Manually-configured LECs use it in their Join requests. A value of unspecified may only be used for auto-configuring LECs. A value of 1580 may only be specified for a LEC that has the v2Capable attribute set to yes.')
lecLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecLanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecLanName.setDescription('This attribute specifies the ELAN name for this LEC. Auto- configuring LECs use this attribute in their Configure requests. Manually-configured LECs use it in their Join requests. An empty string means unspecified. The value of this attribute may be overridden by the LECS or LES; actualLanName contains the actual value.')
lecV2Capable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecV2Capable.setStatus('mandatory')
if mibBuilder.loadTexts: lecV2Capable.setDescription('This attribute specifies whether this LEC exhibits LANE v2 behavior where it differs in its requirements from LANE v1 behavior.')
lecLecsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 5), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecLecsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecLecsAddress.setDescription('This attribute specifies the ATM address of the LECS. If this attribute is non-null, the LEC attempts to set up a Configuration Direct SVC to this address as the first step in the LECS Connect phase. Otherwise, the well known LECS ATM address is used. Only one of the attributes lecsAddress and lesAddress can be specified at one time.')
lecLesAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 6), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecLesAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecLesAddress.setDescription('This attribute specifies the ATM address of the LES. The LEC uses this address to connect directly to the LES, thus bypassing the LECS. A LEC which did not use the LECS is deemed to be manually-configured. Only one of the attributes lecsAddress and lesAddress can be specified at one time.')
lecMaxDataSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1018)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecMaxDataSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: lecMaxDataSvcs.setDescription('This attribute specifies the maximum number of Data Direct SVCs which this LEC can have active at any one time. When operating at the maximum, an SVC setup request releases the oldest 10% of the Data Direct SVCs of this LEC. A SET alarm is issued when currDataSvcs rises above 95% of this value and is CLEAR-ed when it falls below 85%. Set maxDataSvcs as low as acceptable since a fixed amount of memory is consumed proportional to this value on every LP with this feature present.')
lecMaxArpEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(32, 10240)).clone(5120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecMaxArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecMaxArpEntries.setDescription('This attribute specifies the maximum number of entries which this LEC can have in its LE_ARP table at any one time. When operating at the maximum, if an additional entry must be installed, up to 10% of the oldest entries are removed. A SET alarm is issued when currArpEntries rises above 95% of this value and is CLEAR-ed when it falls below 85%.')
lecIlsForwarder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 13, 1, 9), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecIlsForwarder.setStatus('mandatory')
if mibBuilder.loadTexts: lecIlsForwarder.setDescription('This attribute specifies the IlsForwarder that this LEC is using.')
lecStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 15), )
if mibBuilder.loadTexts: lecStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lecStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecStateEntry.setDescription('An entry in the lecStateTable.')
lecAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lecAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lecOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lecOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lecUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lecUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lecOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 16), )
if mibBuilder.loadTexts: lecOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lecOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecOperStatusEntry.setDescription('An entry in the lecOperStatusTable.')
lecSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lecOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17), )
if mibBuilder.loadTexts: lecOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecOperTable.setDescription('This group contains the operational status attributes of the LanEmulationClient component.')
lecOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecOperEntry.setDescription('An entry in the lecOperTable.')
lecActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unspecified", 1), ("ethernet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLanType.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualLanType.setDescription("This attribute indicates the data frame format of this LEC. This may come from the lanType attribute, LECS or LES. The data frame format is not unspecified for an operational LEC. This attribute represents the 'C2' LEC state parameter in the ATM Forum LANE specification. Token Ring data frame format is not supported. The LEC does not become operational if the LECS or LES specify a LAN type of Token Ring.")
lecActualMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1516, 1580, 4544, 9234, 18190))).clone(namedValues=NamedValues(("unspecified", 0), ("n1516", 1516), ("n1580", 1580), ("n4544", 4544), ("n9234", 9234), ("n18190", 18190)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualMaxFrameSize.setDescription("This attribute indicates the maximum data frame size of this LEC. This may come from the maxFrameSize attribute, LECS or LES. The value is not unspecified for an operational LEC. If the LEC's actualV2Capable attribute is no, the value will be limited to one of 1516, 4544, 9234, 18190. This attribute represents the 'C3' LEC state parameter in the ATM Forum LANE specification.")
lecActualLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualLanName.setDescription("This attribute indicates the name of the ELAN to which this LEC is connected. This may come from the lanName attribute, LECS or LES. It may be null for an operational LEC. This attribute represents the 'C5' LEC state parameter in the ATM Forum LANE specification.")
lecElanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecElanId.setStatus('mandatory')
if mibBuilder.loadTexts: lecElanId.setDescription('This attribute identifies the ELAN to which this LEC is connected. For v2, the value will be set in the configuration phase, otherwise it will be 0.')
lecActualV2Capable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualV2Capable.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualV2Capable.setDescription('This attribute indicates whether this LEC exhibits LANE v2 behavior. The value is set in the Join phase.')
lecConfigurationSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("usedProvisionedLecsAddress", 1), ("gotLecsAddressViaIlmi", 2), ("usedWellKnownLecsAddress", 3), ("usedLecsPvc", 4), ("didNotUseLecs", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigurationSource.setStatus('mandatory')
if mibBuilder.loadTexts: lecConfigurationSource.setDescription('This attribute indicates whether this LEC used the LECS, and if so, the method used to establish the Configuration Direct VCC. The attribute retains this value when the LEC is reset. - usedProvisionedLecsAddress: The ATM address specified in lecsAddress was used to locate the LECS. - gotLecsAddressViaIlmi: The ATM address of the LECS was located via the ILMI protocol. - usedWellKnownLecsAddress: The well-known ATM address 0x47007900000000000000000000-00A03E000001-00 was used to locate the LECS. - usedLecsPvc: The well known PVC of VPI=0, VCI=17 was used to locate the LECS. - didNotUseLecs: The LECS was bypassed and the ATM address specified in lesAddress was used to locate the LES.')
lecActualLecsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 7), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLecsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualLecsAddress.setDescription('This attribute indicates the ATM address of the LECS used to configure this LEC. The address is null if the LECS was not used.')
lecActualLesAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 8), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLesAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecActualLesAddress.setDescription("This attribute indicates the ATM address of the LES which is currently serving this LEC. The address is not null for an operational LEC. This attribute represents the 'C9' LEC state parameter in the ATM Forum LANE specification.")
lecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 9), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecAtmAddress.setDescription("This attribute indicates the ATM address of this LEC. This attribute represents the 'C1' LEC state parameter in the ATM Forum LANE specification.")
lecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 10), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecMacAddress.setDescription("This attribute indicates the MAC address of this LEC. This attribute represents the 'C6' LEC state parameter in the ATM Forum LANE specification.")
lecLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lecLecId.setDescription("This attribute indicates the LANE Client Identifier (LECID) assigned to this LEC by the LES during the Join phase. The LECID uniquely identifies a LEC on a particular ELAN. This attribute represents the 'C14' LEC state parameter in the ATM Forum LANE specification.")
lecInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: lecInterfaceState.setDescription('This attribute indicates the current state of the LEC. Note that ifOperStatus is up only when interfaceState is operational. - initialState: Some parameters (such as addresses and ELAN name) are known to the LEC. - lecsConnect: LEC establishes Configuration Direct VCC to LECS. Manually-configured LECs skip this state. - configure: LEC discovers LES. - join: LEC establishes control connections to LES. LEC is assigned unique LECID and knows all ELAN parameters. - initialRegistration: LEC may register additional MAC addresses with LES. This is in addition to the single MAC address registered during Join phase. - busConnect: LEC issues LE_ARP to locate the BUS and sets up the connection. The BUS then establishes the Multicast Forward VCC to the LEC. - operational: LEC is operational and can forward data traffic.')
lecLastFailureResponseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("undefinedError", 3), ("versionNotSupported", 4), ("invalidRequestParameters", 5), ("duplicateLanDestination", 6), ("duplicateAtmAddress", 7), ("insufficientResources", 8), ("accessDenied", 9), ("invalidRequesterId", 10), ("invalidLanDestination", 11), ("invalidAtmAddress", 12), ("noConfiguration", 13), ("leConfigureError", 14), ("insufficientInformation", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLastFailureResponseCode.setStatus('mandatory')
if mibBuilder.loadTexts: lecLastFailureResponseCode.setDescription("The attribute indicates the status code from the last failed Configure or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a time-out period. If none of the LEC's requests have failed, this attribute has the value none.")
lecLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 17, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLastFailureState.setStatus('mandatory')
if mibBuilder.loadTexts: lecLastFailureState.setDescription('This attribute indicates the state that the LEC was in when it updated the lastFailureResponseCode. If lastFailureResponseCode is none, this attribute has the value initialState. See the interfaceState attribute for a description of each state.')
lecStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18), )
if mibBuilder.loadTexts: lecStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecStatsTable.setDescription('This group contains the statistical attributes of the LanEmulationClient component.')
lecStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"))
if mibBuilder.loadTexts: lecStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecStatsEntry.setDescription('An entry in the lecStatsTable.')
lecArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: lecArpRequestsOut.setDescription('This attribute counts the LE_ARP_REQUESTS sent by this LEC. This counter wraps to zero when the maximum value is reached.')
lecArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRepliesIn.setStatus('mandatory')
if mibBuilder.loadTexts: lecArpRepliesIn.setDescription('This attribute counts the LE_ARP_RESPONSES received by this LEC. This counter wraps to zero when the maximum value is reached.')
lecArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: lecArpRequestsIn.setDescription('This attribute counts the LE_ARP_REQUESTS received by this LEC. This counter wraps to zero when the maximum value is reached.')
lecArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRepliesOut.setStatus('mandatory')
if mibBuilder.loadTexts: lecArpRepliesOut.setDescription('This attribute counts the LE_ARP_RESPONSES sent by this LEC. This counter wraps to zero when the maximum value is reached.')
lecControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: lecControlFramesOut.setDescription('This attribute counts the control packets sent by this LEC. This counter wraps to zero when the maximum value is reached.')
lecControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: lecControlFramesIn.setDescription('This attribute counts the control packets received by this LEC. This counter wraps to zero when the maximum value is reached.')
lecSvcFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecSvcFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lecSvcFailures.setDescription('This attribute counts the number of SVCs that could not be set up. The reasons for failure are: - outgoing SVCs that this LEC failed to establish; - incoming SVCs that this LEC failed to establish; and - incoming SVCs that this LEC rejected for protocol or security reasons. This counter wraps to zero when the maximum value is reached.')
lecCurrDataSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecCurrDataSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: lecCurrDataSvcs.setDescription('This attribute counts the number of Data Direct SVCs that this LEC has in service.')
lecPeakDataSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecPeakDataSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: lecPeakDataSvcs.setDescription('The attribute is the peak value of currDataSvcs. In other words, this value is the maximum number of Data Direct SVCs that this LEC had in service at any one time.')
lecCurrArpEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecCurrArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecCurrArpEntries.setDescription('This attribute counts the current number of entries that this LEC has in its LE ARP table.')
lecPeakArpEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecPeakArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecPeakArpEntries.setDescription('The attribute is the peak value currArpEntries. In other words, this value is the maximum number of entries that this LEC had in its LE ARP table at any one time.')
lecBadControlFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecBadControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecBadControlFrames.setDescription("This attribute counts the control frames discarded by the LEC due to invalid or illegal frame format, and those frames with a STATUS code other than 'Success'. This counter wraps to zero when the maximum value is reached.")
lecProtocolViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecProtocolViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lecProtocolViolations.setDescription('This attribute counts the number of responses received by the LEC that contained invalid data or non-protocol compliant data. This counter wraps to zero when the maximum value is reached.')
lecUnsupportedTlvs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 18, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecUnsupportedTlvs.setStatus('mandatory')
if mibBuilder.loadTexts: lecUnsupportedTlvs.setDescription('This attribute counts the number of times an unsupported TLV was received by the LEC in either the Configuration or Join response. This counter wraps to zero when the maximum value is reached.')
lecLeArp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2))
lecLeArpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1), )
if mibBuilder.loadTexts: lecLeArpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of lecLeArp components.')
lecLeArpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecLeArpIndex"))
if mibBuilder.loadTexts: lecLeArpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpRowStatusEntry.setDescription('A single entry in the table represents a single lecLeArp component.')
lecLeArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpRowStatus.setDescription('This variable is used as the basis for SNMP naming of lecLeArp components. These components cannot be added nor deleted.')
lecLeArpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lecLeArpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpStorageType.setDescription('This variable represents the storage type value for the lecLeArp tables.')
lecLeArpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: lecLeArpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpIndex.setDescription('This variable represents the index for the lecLeArp tables.')
lecLeArpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 10), )
if mibBuilder.loadTexts: lecLeArpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the LeArpEntry component.')
lecLeArpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecLeArpIndex"))
if mibBuilder.loadTexts: lecLeArpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpOperEntry.setDescription('An entry in the lecLeArpOperTable.')
lecLeArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpAtmAddress.setDescription('This attribute indicates the ATM address of the BUS or LEC associated with the MAC address of this entry. If the MAC address is the all-ones broadcast address, the entry is for the BUS.')
lecLeArpIsRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpIsRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpIsRemoteAddress.setDescription("This attribute indicates whether this entry is for a local or remote MAC address. In this context, 'local' means a MAC address that is local to a LEC, and 'remote' means a MAC address for which the LEC is proxy. If yes, the address is believed to be remote, or its local/remote status is unknown. If no, the address is believed to be local; that is, registered with the LES by the LEC whose ATM address is atmAddress.")
lecLeArpConnectionId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1022))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLeArpConnectionId.setStatus('mandatory')
if mibBuilder.loadTexts: lecLeArpConnectionId.setDescription('This attribute indicates the connection identifier associated with this entry. The connection identifier is the instance of the Connection component.')
lecConn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3))
lecConnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1), )
if mibBuilder.loadTexts: lecConnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of lecConn components.')
lecConnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnIndex"))
if mibBuilder.loadTexts: lecConnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnRowStatusEntry.setDescription('A single entry in the table represents a single lecConn component.')
lecConnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnRowStatus.setDescription('This variable is used as the basis for SNMP naming of lecConn components. These components cannot be added nor deleted.')
lecConnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lecConnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnStorageType.setDescription('This variable represents the storage type value for the lecConn tables.')
lecConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1022)))
if mibBuilder.loadTexts: lecConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnIndex.setDescription('This variable represents the index for the lecConn tables.')
lecConnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 10), )
if mibBuilder.loadTexts: lecConnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational status attributes of the Connection component.')
lecConnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnIndex"))
if mibBuilder.loadTexts: lecConnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnOperEntry.setDescription('An entry in the lecConnOperTable.')
lecConnRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnRemoteAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnRemoteAtmAddress.setDescription('This attribute indicates the ATM address of the far end.')
lecConnAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnAge.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAge.setDescription('This attribute indicates the age of this connection.')
lecConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("configurationDirectVcc", 1), ("controlDirectVcc", 2), ("controlDistributeVcc", 3), ("dataDirectVcc", 4), ("defaultMulticastSendVcc", 5), ("multicastForward", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnType.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnType.setDescription('This attribute indicates the type of this connection.')
lecConnStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 11), )
if mibBuilder.loadTexts: lecConnStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the statistical attributes of the Connection component.')
lecConnStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnIndex"))
if mibBuilder.loadTexts: lecConnStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnStatsEntry.setDescription('An entry in the lecConnStatsTable.')
lecConnOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnOutFrames.setDescription('This attribute counts the frames sent over this connection. This counter wraps to zero when the maximum value is reached.')
lecConnInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnInFrames.setDescription('This attribute counts the frames received over this connection. This counter wraps to zero when the maximum value is reached.')
lecConnAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2))
lecConnAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1), )
if mibBuilder.loadTexts: lecConnAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of lecConnAtmCon components.')
lecConnAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnAtmConIndex"))
if mibBuilder.loadTexts: lecConnAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConRowStatusEntry.setDescription('A single entry in the table represents a single lecConnAtmCon component.')
lecConnAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of lecConnAtmCon components. These components cannot be added nor deleted.')
lecConnAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lecConnAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConStorageType.setDescription('This variable represents the storage type value for the lecConnAtmCon tables.')
lecConnAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lecConnAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConIndex.setDescription('This variable represents the index for the lecConnAtmCon tables.')
lecConnAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 10), )
if mibBuilder.loadTexts: lecConnAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute group contains the operational attributes for the NapAtmConnection component.')
lecConnAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LaneClientMIB", "lecIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnIndex"), (0, "Nortel-Magellan-Passport-LaneClientMIB", "lecConnAtmConIndex"))
if mibBuilder.loadTexts: lecConnAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConOperEntry.setDescription('An entry in the lecConnAtmConOperTable.')
lecConnAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 124, 3, 2, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConnAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: lecConnAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
laneClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 1))
laneClientGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 1, 5))
laneClientGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 1, 5, 1))
laneClientGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 1, 5, 1, 2))
laneClientCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 3))
laneClientCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 3, 5))
laneClientCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 3, 5, 1))
laneClientCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 71, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LaneClientMIB", lecConnOperTable=lecConnOperTable, lecProvEntry=lecProvEntry, lecMpEntry=lecMpEntry, lecConnAtmConRowStatusEntry=lecConnAtmConRowStatusEntry, laneClientMIB=laneClientMIB, laneClientCapabilitiesBE00A=laneClientCapabilitiesBE00A, lecLeArpRowStatusEntry=lecLeArpRowStatusEntry, lecConnAtmCon=lecConnAtmCon, lecConnAtmConNextHop=lecConnAtmConNextHop, lecActualLanType=lecActualLanType, lecConnStatsEntry=lecConnStatsEntry, lecSvcFailures=lecSvcFailures, lecIndex=lecIndex, lecLeArp=lecLeArp, lecLesAddress=lecLesAddress, lecStateEntry=lecStateEntry, lecConnAge=lecConnAge, lecConnRowStatusEntry=lecConnRowStatusEntry, lecActualV2Capable=lecActualV2Capable, lecLinkToProtocolPort=lecLinkToProtocolPort, lecConnRowStatusTable=lecConnRowStatusTable, lecLeArpIndex=lecLeArpIndex, lecRowStatusTable=lecRowStatusTable, lecConnType=lecConnType, lecV2Capable=lecV2Capable, lecAdminState=lecAdminState, lecLeArpStorageType=lecLeArpStorageType, lecConnAtmConOperEntry=lecConnAtmConOperEntry, laneClientGroupBE00=laneClientGroupBE00, lecComponentName=lecComponentName, lecOperStatusEntry=lecOperStatusEntry, lecLastFailureState=lecLastFailureState, lecLeArpRowStatus=lecLeArpRowStatus, lecLeArpOperEntry=lecLeArpOperEntry, lecCidDataEntry=lecCidDataEntry, lecConnInFrames=lecConnInFrames, lecConnOperEntry=lecConnOperEntry, lecConnStatsTable=lecConnStatsTable, lecRowStatus=lecRowStatus, lecMaxArpEntries=lecMaxArpEntries, lecProvTable=lecProvTable, lecActualMaxFrameSize=lecActualMaxFrameSize, lecConnIndex=lecConnIndex, lecIfEntryEntry=lecIfEntryEntry, laneClientCapabilitiesBE00=laneClientCapabilitiesBE00, lecLecsAddress=lecLecsAddress, lecOperStatusTable=lecOperStatusTable, lecIfAdminStatus=lecIfAdminStatus, lecLeArpOperTable=lecLeArpOperTable, lecConnStorageType=lecConnStorageType, lecOperationalState=lecOperationalState, lecInterfaceState=lecInterfaceState, lecControlFramesOut=lecControlFramesOut, lecConnAtmConIndex=lecConnAtmConIndex, lecConnAtmConComponentName=lecConnAtmConComponentName, lecConn=lecConn, lecLanName=lecLanName, lecLeArpConnectionId=lecLeArpConnectionId, lecArpRequestsIn=lecArpRequestsIn, lecMpTable=lecMpTable, laneClientCapabilities=laneClientCapabilities, lecMaxDataSvcs=lecMaxDataSvcs, lecMaxFrameSize=lecMaxFrameSize, laneClientGroup=laneClientGroup, lecAtmAddress=lecAtmAddress, lecConnRowStatus=lecConnRowStatus, lecConnAtmConRowStatusTable=lecConnAtmConRowStatusTable, lecLeArpComponentName=lecLeArpComponentName, lecLastFailureResponseCode=lecLastFailureResponseCode, lecIfIndex=lecIfIndex, lecConnAtmConRowStatus=lecConnAtmConRowStatus, lec=lec, lecIlsForwarder=lecIlsForwarder, lecConnAtmConStorageType=lecConnAtmConStorageType, lecUsageState=lecUsageState, lecConfigurationSource=lecConfigurationSource, lecArpRepliesOut=lecArpRepliesOut, lecCurrArpEntries=lecCurrArpEntries, lecElanId=lecElanId, lecCustomerIdentifier=lecCustomerIdentifier, lecControlFramesIn=lecControlFramesIn, lecLecId=lecLecId, lecLanType=lecLanType, laneClientCapabilitiesBE=laneClientCapabilitiesBE, laneClientGroupBE=laneClientGroupBE, lecRowStatusEntry=lecRowStatusEntry, lecPeakArpEntries=lecPeakArpEntries, lecLeArpIsRemoteAddress=lecLeArpIsRemoteAddress, lecStatsEntry=lecStatsEntry, lecLeArpAtmAddress=lecLeArpAtmAddress, laneClientGroupBE00A=laneClientGroupBE00A, lecArpRequestsOut=lecArpRequestsOut, lecActualLecsAddress=lecActualLecsAddress, lecCurrDataSvcs=lecCurrDataSvcs, lecStateTable=lecStateTable, lecConnComponentName=lecConnComponentName, lecActualLanName=lecActualLanName, lecSnmpOperStatus=lecSnmpOperStatus, lecOperTable=lecOperTable, lecIfEntryTable=lecIfEntryTable, lecActualLesAddress=lecActualLesAddress, lecMacAddress=lecMacAddress, lecConnAtmConOperTable=lecConnAtmConOperTable, lecLeArpRowStatusTable=lecLeArpRowStatusTable, lecBadControlFrames=lecBadControlFrames, lecUnsupportedTlvs=lecUnsupportedTlvs, lecPeakDataSvcs=lecPeakDataSvcs, lecCidDataTable=lecCidDataTable, lecOperEntry=lecOperEntry, lecProtocolViolations=lecProtocolViolations, lecConnOutFrames=lecConnOutFrames, lecConnRemoteAtmAddress=lecConnRemoteAtmAddress, lecStorageType=lecStorageType, lecStatsTable=lecStatsTable, lecArpRepliesIn=lecArpRepliesIn)

#
# PySNMP MIB module IP-ACCESS-LIST-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IP-ACCESS-LIST-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:55:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
cjnMgmt, = mibBuilder.importSymbols("Cajun-ROOT", "cjnMgmt")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Gauge32, iso, Integer32, Unsigned32, Bits, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, TimeTicks, Counter64, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Gauge32", "iso", "Integer32", "Unsigned32", "Bits", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "TimeTicks", "Counter64", "ModuleIdentity", "NotificationType")
TruthValue, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "RowStatus")
cjnIpAListMgmt = ModuleIdentity((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5))
if mibBuilder.loadTexts: cjnIpAListMgmt.setLastUpdated('9902110000Z')
if mibBuilder.loadTexts: cjnIpAListMgmt.setOrganization("Lucent's Concord Technology Center (CTC)")
if mibBuilder.loadTexts: cjnIpAListMgmt.setContactInfo('Tim Lai -- twlai@lucent.com Raj Duggal (Group Leader) -- rduggal@lucent.com Ira Steckler -- isteckler@lucent.com')
if mibBuilder.loadTexts: cjnIpAListMgmt.setDescription('The IP Access List Table for the Cajun Router.')
ipACListCtlTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 1), )
if mibBuilder.loadTexts: ipACListCtlTable.setStatus('current')
if mibBuilder.loadTexts: ipACListCtlTable.setDescription('This table is used to add/delete access list. This table maintain a list of access lists in the system. Each access list is made up of a group of access rule. The access rules are stored in the ipACRuleTable.')
ipACListCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 1, 1), ).setIndexNames((0, "IP-ACCESS-LIST-MIB", "ipACListCtlName"))
if mibBuilder.loadTexts: ipACListCtlEntry.setStatus('current')
if mibBuilder.loadTexts: ipACListCtlEntry.setDescription('The information concerning one of the IP access list.')
ipACListCtlName = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACListCtlName.setStatus('current')
if mibBuilder.loadTexts: ipACListCtlName.setDescription('Entry Name. Access List Name. If this instance is a string that represent a number, the following rules applies: 1 to 99 - ipACListCtlType must set to standard 101 to 199 - ipACListCtlType must set to extended others - cannot be created If this instance is a string that does not represent a number, the ipACListCtlType must be set before ipACListCtlStatus becomes active.')
ipACListCtlType = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACListCtlType.setStatus('current')
if mibBuilder.loadTexts: ipACListCtlType.setDescription('Type of Access List: unset (0) standard (1) extended (2) This instance cannot be changed once ipACListCtlStatus becomes active. The value of this instance must compile with the rule listed in the ipACListCtlName instance.')
ipACListCtlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACListCtlStatus.setStatus('current')
if mibBuilder.loadTexts: ipACListCtlStatus.setDescription('For creation/deletion of IP access control statement. active (1) -- is set when both ipACListCtlName and ipACListCtlType is set. notInService (2) -- is set when ipACListCtlName or ipACListCtlType is not set. notReady (3) createAndGo (4) -- is set on creating new access list. createAndWait (5) destroy (6) -- is set on destroying an existed access list. The management should inspect the ipACRuleTable and delete all the related entries. An entry in the ipACRuleTable is related to this entry if ipACListCtlName equals ipACRuleName.')
ipACRuleTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2), )
if mibBuilder.loadTexts: ipACRuleTable.setStatus('current')
if mibBuilder.loadTexts: ipACRuleTable.setDescription('This table is used to add/delete individual access rule statement in an access list.')
ipACRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1), ).setIndexNames((0, "IP-ACCESS-LIST-MIB", "ipACRuleName"), (0, "IP-ACCESS-LIST-MIB", "ipACRuleSubIndex"))
if mibBuilder.loadTexts: ipACRuleEntry.setStatus('current')
if mibBuilder.loadTexts: ipACRuleEntry.setDescription('The ipAccessRuleEntry control all the conditional fields and its parameters for an access rule.')
ipACRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleName.setStatus('current')
if mibBuilder.loadTexts: ipACRuleName.setDescription('Entry Name. Access List Name. This object identifies which access list this access rule belongs to. This object shall identify the instance of the ipACListCtlEntry object. ')
ipACRuleSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleSubIndex.setStatus('current')
if mibBuilder.loadTexts: ipACRuleSubIndex.setDescription('Entry sub index. Each access list entry may has multiple rules. This sub index identified each rule.')
ipACRuleOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("external", 2))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleOwner.setStatus('current')
if mibBuilder.loadTexts: ipACRuleOwner.setDescription('The string identifies the media which was used to create/modify this access rule. Local indicates creation via web, cli or snmp. external indicates an external client (ie. CajunRules)')
ipACRuleSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ipACRuleSrcAddr.setDescription("The IP address of the source address. A value of 0 in ipACListSrcMask indicates this is a DON'T CARE field.")
ipACRuleSrcAddrWild = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleSrcAddrWild.setStatus('current')
if mibBuilder.loadTexts: ipACRuleSrcAddrWild.setDescription('This field specifies the wildcard of the source IP address.')
ipACRuleSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleSrcMask.setStatus('current')
if mibBuilder.loadTexts: ipACRuleSrcMask.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. The MASK address of the source address. A value of 0 indicates this field and ipACListSrcAddr are DON'T CARE")
ipACRuleSrcMaskWild = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleSrcMaskWild.setStatus('current')
if mibBuilder.loadTexts: ipACRuleSrcMaskWild.setDescription('The instance is not writable if the corresponding ipACListCtlType is standard. This field specifies the wildcard of the source IP mask.')
ipACRuleDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleDstAddr.setStatus('current')
if mibBuilder.loadTexts: ipACRuleDstAddr.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. The IP address of the destination address. A value of 0 in ipAccessListDstMask indicates this is a DON'T CARE field.")
ipACRuleDstAddrWild = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleDstAddrWild.setStatus('current')
if mibBuilder.loadTexts: ipACRuleDstAddrWild.setDescription('The instance is not writable if the corresponding ipACListCtlType is standard. This field specifies the wildcard of the destination IP address.')
ipACRuleDstMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleDstMask.setStatus('current')
if mibBuilder.loadTexts: ipACRuleDstMask.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. The MASK address of the destination address. A value of 0 indicates this field and ipACListDstAddr are DON'T CARE")
ipACRuleDstMaskWild = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleDstMaskWild.setStatus('current')
if mibBuilder.loadTexts: ipACRuleDstMaskWild.setDescription('The instance is not writable if the corresponding ipACListCtlType is standard. This field specifies the wildcard of the destination IP mask.')
ipACRuleOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("filter", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("forwardPriority8", 9), ("forwardNoChange", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleOperation.setStatus('current')
if mibBuilder.loadTexts: ipACRuleOperation.setDescription('How to operate the IP ACCESS CONTROL statement, on the receiving packet.')
ipACRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65537))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: ipACRuleProtocol.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. Over which protocol does the IP ACCESS CONTROL statement activate. A value of 65536 is don't care. A value of 65537 means both TCP and UDP. Note: Cajun P550 does not allow ipACListProtocol equal to TCP or UDP because of hardware limitation. This limitation will be lift in the future.")
ipACRuleL4SrcPortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleL4SrcPortMin.setStatus('current')
if mibBuilder.loadTexts: ipACRuleL4SrcPortMin.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. If ipACRuleProtocol is TCP(6), UDP(17), or TCP & UDP(65536), this field and ipACListL4SrcPortMax specifies a range of source ports. This field specifies the lower bound of the port range for the access rule. A value of 65536 is don't care. This field has no meaning if ipACRuleProtocol is not TCP(6), UDP(17), or TCP & UDP(65536), and it should be 65536. ")
ipACRuleL4SrcPortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleL4SrcPortMax.setStatus('current')
if mibBuilder.loadTexts: ipACRuleL4SrcPortMax.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. If ipACRuleProtocol is TCP(6), UDP(17), or TCP & UDP(65536), this field and ipACListL4SrcPortMin specifies a range of source ports. This field specifies the upper bound of the port range for the access rule. A value of 65536 is don't care. This field has no meaning if ipACRuleProtocol is not TCP(6), UDP(17), or TCP & UDP(65536), and it should be 65536. ")
ipACRuleL4DestPortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleL4DestPortMin.setStatus('current')
if mibBuilder.loadTexts: ipACRuleL4DestPortMin.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. If ipACRuleProtocol is TCP(6), UDP(17), or TCP & UDP(65536), this field and ipACListL4DestPortMax specifies a range of destination ports. This field specifies the lower bound of the port range for the access rule. A value of 65536 is don't care. This field has no meaning if ipACRuleProtocol is not TCP(6), UDP(17), or TCP & UDP(65536), and it should be 65536. ")
ipACRuleL4DestPortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleL4DestPortMax.setStatus('current')
if mibBuilder.loadTexts: ipACRuleL4DestPortMax.setDescription("The instance is not writable if the corresponding ipACListCtlType is standard. If ipACRuleProtocol is TCP(6), UDP(17), or TCP & UDP(65536), this field and ipACListL4DestPortMin specifies a range of destination ports. This field specifies the upper bound of the port range for the access rule. A value of 65536 is don't care. This field has no meaning if ipACRuleProtocol is not TCP(6), UDP(17), or TCP & UDP(65536), and it should be 65536. ")
ipACRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 18), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleStatus.setStatus('current')
if mibBuilder.loadTexts: ipACRuleStatus.setDescription('For create/delete of a IP access rule statement. active (1) notInService (2) notReady (3) createAndGo (4) createAndWait (5) destroy (6) createAndWait and createAndGo is set on creating new access list. destory is set on destroying access rule. active is set when all the required instance is set in the entry.')
ipACRuleEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 19), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleEstablished.setStatus('current')
if mibBuilder.loadTexts: ipACRuleEstablished.setDescription('This field indicates an established TCP connection.')
ipACRuleLog = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 5, 2, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipACRuleLog.setStatus('current')
if mibBuilder.loadTexts: ipACRuleLog.setDescription('This field indicates whether the access-list should log information.')
cjnIpForwardCtlMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 6))
ipForwardCtlEnabled = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardCtlEnabled.setStatus('current')
if mibBuilder.loadTexts: ipForwardCtlEnabled.setDescription('The object control the enable or disable the forwarding control mechanism in the system.')
ipForwardCtlACName = MibScalar((1, 3, 6, 1, 4, 1, 1751, 2, 43, 3, 6, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardCtlACName.setStatus('current')
if mibBuilder.loadTexts: ipForwardCtlACName.setDescription('This object identifies which access list to use for IP forward control. This object shall identify the instance of the ipACListCtlEntry object. ')
mibBuilder.exportSymbols("IP-ACCESS-LIST-MIB", ipACRuleLog=ipACRuleLog, ipACRuleName=ipACRuleName, ipACRuleOwner=ipACRuleOwner, ipACRuleSrcAddrWild=ipACRuleSrcAddrWild, ipForwardCtlACName=ipForwardCtlACName, ipACRuleSrcMaskWild=ipACRuleSrcMaskWild, ipACRuleDstAddr=ipACRuleDstAddr, ipACRuleSrcMask=ipACRuleSrcMask, ipACRuleDstMask=ipACRuleDstMask, ipACRuleL4SrcPortMin=ipACRuleL4SrcPortMin, cjnIpForwardCtlMgt=cjnIpForwardCtlMgt, PYSNMP_MODULE_ID=cjnIpAListMgmt, ipACRuleL4DestPortMax=ipACRuleL4DestPortMax, ipACRuleDstAddrWild=ipACRuleDstAddrWild, ipACListCtlTable=ipACListCtlTable, ipACRuleSrcAddr=ipACRuleSrcAddr, ipACListCtlName=ipACListCtlName, cjnIpAListMgmt=cjnIpAListMgmt, ipACRuleProtocol=ipACRuleProtocol, ipACListCtlEntry=ipACListCtlEntry, ipACRuleEntry=ipACRuleEntry, ipACRuleOperation=ipACRuleOperation, ipACRuleDstMaskWild=ipACRuleDstMaskWild, ipACRuleL4DestPortMin=ipACRuleL4DestPortMin, ipACRuleTable=ipACRuleTable, ipACRuleL4SrcPortMax=ipACRuleL4SrcPortMax, ipACRuleEstablished=ipACRuleEstablished, ipACListCtlStatus=ipACListCtlStatus, ipForwardCtlEnabled=ipForwardCtlEnabled, ipACRuleStatus=ipACRuleStatus, ipACListCtlType=ipACListCtlType, ipACRuleSubIndex=ipACRuleSubIndex)

#
# PySNMP MIB module IPFRR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPFRR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
inetCidrRouteNextHop, inetCidrRoutePfxLen, inetCidrRouteDestType, inetCidrRouteNextHopType, inetCidrRoutePolicy, inetCidrRouteDest = mibBuilder.importSymbols("IP-FORWARD-MIB", "inetCidrRouteNextHop", "inetCidrRoutePfxLen", "inetCidrRouteDestType", "inetCidrRouteNextHopType", "inetCidrRoutePolicy", "inetCidrRouteDest")
ip, = mibBuilder.importSymbols("IP-MIB", "ip")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Bits, Unsigned32, MibIdentifier, ModuleIdentity, Counter64, NotificationType, ObjectIdentity, IpAddress, TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Unsigned32", "MibIdentifier", "ModuleIdentity", "Counter64", "NotificationType", "ObjectIdentity", "IpAddress", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "Counter32")
RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
ipFrrMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 4, 999))
ipFrrMIB.setRevisions(('2005-02-18 12:00', '2005-02-13 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipFrrMIB.setRevisionsDescriptions(('Add Set operations on ipFrrAltTable', 'Initial version.',))
if mibBuilder.loadTexts: ipFrrMIB.setLastUpdated('200502181200Z')
if mibBuilder.loadTexts: ipFrrMIB.setOrganization('draft-ietf-ipfrr-ip-mib-00.txt')
if mibBuilder.loadTexts: ipFrrMIB.setContactInfo(' Bill Anderson Avici Systems, Inc. EMail: wanderson@avici.com Alia Atlas Avici Systems, Inc. Email: aatlas@avici.com Don Fedyk Nortel Networks Email: dwfedyk@nortel.com ')
if mibBuilder.loadTexts: ipFrrMIB.setDescription('IP MIB module for management of IP Fast-Reroute. Copyright (C) The Internet Society (date). This version of this MIB module is part of draft-ietf-rtgwg-ipfrr-ip-mib-00.txt')
ipFrrMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 999, 1))
ipFrrProtectStats = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 999, 1, 1))
ipFrrTotalRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 999, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrTotalRoutes.setStatus('current')
if mibBuilder.loadTexts: ipFrrTotalRoutes.setDescription('The number of valid routes known by this entity.')
ipFrrUnprotectedRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 999, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrUnprotectedRoutes.setStatus('current')
if mibBuilder.loadTexts: ipFrrUnprotectedRoutes.setDescription('The number of valid routes known by this entity which do not have an alternate next-hop associated with any primary next-hop.')
ipFrrProtectedRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 999, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrProtectedRoutes.setStatus('current')
if mibBuilder.loadTexts: ipFrrProtectedRoutes.setDescription('The number of routes known by this entity which have at least one alternate next-hop.')
ipFrrLinkProtectedRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 999, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrLinkProtectedRoutes.setStatus('current')
if mibBuilder.loadTexts: ipFrrLinkProtectedRoutes.setDescription('The number of routes known by this entity for which all alternate next-hops provide link protection for their associated primary next-hops.')
ipFrrNodeProtectedRoutes = MibScalar((1, 3, 6, 1, 2, 1, 4, 999, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrNodeProtectedRoutes.setStatus('current')
if mibBuilder.loadTexts: ipFrrNodeProtectedRoutes.setDescription('The number of routes known by this entity for which all alternate next-hops provide node protection for their associated primary next-hops.')
ipFrrAltTable = MibTable((1, 3, 6, 1, 2, 1, 4, 999, 1, 2), )
if mibBuilder.loadTexts: ipFrrAltTable.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltTable.setDescription("This entity's IP Fast Reroute Alternates table.")
ipFrrAltEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "inetCidrRouteDestType"), (0, "IP-FORWARD-MIB", "inetCidrRouteDest"), (0, "IP-FORWARD-MIB", "inetCidrRoutePfxLen"), (0, "IP-FORWARD-MIB", "inetCidrRoutePolicy"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHopType"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHop"), (0, "IPFRR-MIB", "ipFrrAltNextHopType"), (0, "IPFRR-MIB", "ipFrrAltNextHop"))
if mibBuilder.loadTexts: ipFrrAltEntry.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltEntry.setDescription('An entry containing information on a particular route, one of its particular (primary) next-hops and one of the associated alternate next-hops. Implementers need to be aware that if the total number of elements (octets or sub-identifiers) in inetCidrRouteDest, inetCidrRoutePolicy, inetCidrRouteNextHop, and ipFrrAltNextHop exceeds 107 then OIDs of column instances in this table will have more than 128 sub-identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
ipFrrAltNextHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipFrrAltNextHopType.setReference('RFC 3291')
if mibBuilder.loadTexts: ipFrrAltNextHopType.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltNextHopType.setDescription('The type of the ipFrrNextHop address, as defined in the InetAddress MIB. Only those address types that may appear in an actual routing table are allowed as values of this object.')
ipFrrAltNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipFrrAltNextHop.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltNextHop.setDescription('The address of the next system along the alternate route. The type of this address is determined by the value of the ipFrrAltNextHopType.')
ipFrrAltIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFrrAltIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltIfIndex.setDescription('The ifIndex value which identifies the local interface through which the next hop of this alternate route should be reached.')
ipFrrAltType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("equalCost", 2), ("loopFree", 3), ("uTurn", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFrrAltType.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltType.setDescription('The type of alternate which is provided by the alternate next-hop. The supported types are as follows: equalCost : The alternate next-hop is another primary next-hop. loopFree : The shortest route to the destination IP address from the alternate next-hop does not traverse this system. See draft-ietf-rtgwg-ipfrr-spec-base-04. uTurn : The alternate next system, which is indicated by the alternate next-hop, has itself a primary path that traverses this system but also has an alternate next-hop for this route that does not traverse this system. See draft-atlas-ip-local-protect-uturn-02. other : The mechanism by which the alternate next-hop can be used is not specified.')
ipFrrAltProtectionAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 5), Bits().clone(namedValues=NamedValues(("nodeProtect", 0), ("linkProtect", 1), ("unknownProtection", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFrrAltProtectionAvailable.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltProtectionAvailable.setDescription('This object specifies the scope of protection for which this alternate next-hop can provide failure protection. The alternate next-hop should provide one or more of node-protection and link-protection. If the protection provided by the alternate next-hop is unknown, then only unknownProtection should be specified. Specifying uknownProtection with any other type of protection is not supported. ')
ipFrrAltMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFrrAltMetric1.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltMetric1.setDescription('This is the primary routing metric for this alternate path to the destination IP address. If the alternate path metric is unknown, the value should be set to -1.')
ipFrrAltStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFrrAltStatus.setStatus('current')
if mibBuilder.loadTexts: ipFrrAltStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
ipFrrNoAltTable = MibTable((1, 3, 6, 1, 2, 1, 4, 999, 1, 3), )
if mibBuilder.loadTexts: ipFrrNoAltTable.setStatus('current')
if mibBuilder.loadTexts: ipFrrNoAltTable.setDescription("This entity's IP Fast Reroute Unprotected Routes table.")
ipFrrNoAltEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 999, 1, 3, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "inetCidrRouteDestType"), (0, "IP-FORWARD-MIB", "inetCidrRouteDest"), (0, "IP-FORWARD-MIB", "inetCidrRoutePfxLen"))
if mibBuilder.loadTexts: ipFrrNoAltEntry.setStatus('current')
if mibBuilder.loadTexts: ipFrrNoAltEntry.setDescription('An entry containing the reason why a route does not have an alternate next-hop. The existence of an entry for a route indicates that there is no alternate next-hop.')
ipFrrNoAltCause = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 999, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ipFrrUnavailable", 1), ("localAddress", 2), ("ipFrrDisabled", 3), ("ipFrrUturnDisabled", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFrrNoAltCause.setStatus('current')
if mibBuilder.loadTexts: ipFrrNoAltCause.setDescription('For valid routes without an alternate next-hop, this object enumerates the reason why no protection is available. The possibilities are as follows. ipFrrUnavailable : The supported IP Fast-Reroute mechanisms could not find a safe alternate next-hop. localAddress : The route represents a local address. This system is the destination so no alternate path is possible or necessary. ipFrrDisabled : Finding of alternate next-hops is operationally disabled. ipFrrUturnDisabled : Finding of u-turn alternate next-hops is operationally disabled. No loop-free alternate could be found. See draft-atlas-ip-local-protect-uturn-02 other : The reason is unknown or different from those specifically enumerated possible causes.')
ipFrrMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 999, 2))
ipFrrMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 999, 2, 1))
ipFrrMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 999, 2, 2))
ipFrrMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 999, 2, 1, 1)).setObjects(("IPFRR-MIB", "ipFrrBasicGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipFrrMIBCompliance = ipFrrMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ipFrrMIBCompliance.setDescription('Minimum requirements to state conformity to this MIB. Supporting only IP v4 addresses This is deprecated in favor of ipFrrMIBInetCompliance There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which there are compliance requirements, expressed in OBJECT clause form in this description: OBJECT inetCidrRouteDestType SYNTAX InetAddressType { ipv4(1), ipv4z(3) } MIN-ACCESS read-only DESCRIPTION A (deprecated) complying implementation at this level is required to support IPv4 addresses only. This compliance level is defined so an implementation only needs to support the addresses it actually supports on the device. OBJECT inetCidrRouteNextHopType SYNTAX InetAddressType { ipv4(1), ipv4z(3) } MIN-ACCESS read-only DESCRIPTION A (deprecated) complying implementation at this level is required to support IPv4 addresses only. This compliance level is defined so an implementation only needs to support the addresses it actually supports on the device. OBJECT ipFrrAltNextHopType SYNTAX InetAddressType { ipv4(1), ipv4z(3) } MIN-ACCESS read-only DESCRIPTION A (deprecated) complying implementation at this level is required to support IPv4 addresses only. This compliance level is defined so an implementation only needs to support the addresses it actually supports on the device. ')
ipFrrMIBInetCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 999, 2, 1, 2)).setObjects(("IPFRR-MIB", "ipFrrBasicGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipFrrMIBInetCompliance = ipFrrMIBInetCompliance.setStatus('current')
if mibBuilder.loadTexts: ipFrrMIBInetCompliance.setDescription('Full conformity to this MIB.')
ipFrrReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 999, 2, 1, 3)).setObjects(("IPFRR-MIB", "ipFrrBasicGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipFrrReadOnlyCompliance = ipFrrReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: ipFrrReadOnlyCompliance.setDescription('When this MIB is implemented without support for read-create (i.e. in read-only mode), then that implementation can claim read-only compliance. In that case, ipFrrAlt group can be monitored but cannot be configured with this MIB.')
ipFrrBasicGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 999, 2, 2, 1)).setObjects(("IPFRR-MIB", "ipFrrTotalRoutes"), ("IPFRR-MIB", "ipFrrUnprotectedRoutes"), ("IPFRR-MIB", "ipFrrProtectedRoutes"), ("IPFRR-MIB", "ipFrrLinkProtectedRoutes"), ("IPFRR-MIB", "ipFrrNodeProtectedRoutes"), ("IPFRR-MIB", "ipFrrAltIfIndex"), ("IPFRR-MIB", "ipFrrAltType"), ("IPFRR-MIB", "ipFrrAltProtectionAvailable"), ("IPFRR-MIB", "ipFrrAltMetric1"), ("IPFRR-MIB", "ipFrrAltStatus"), ("IPFRR-MIB", "ipFrrNoAltCause"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipFrrBasicGroup = ipFrrBasicGroup.setStatus('current')
if mibBuilder.loadTexts: ipFrrBasicGroup.setDescription('The entire collection of objects defined in this MIB for management of IP Fast Reroute .')
mibBuilder.exportSymbols("IPFRR-MIB", ipFrrAltMetric1=ipFrrAltMetric1, PYSNMP_MODULE_ID=ipFrrMIB, ipFrrAltProtectionAvailable=ipFrrAltProtectionAvailable, ipFrrUnprotectedRoutes=ipFrrUnprotectedRoutes, ipFrrMIB=ipFrrMIB, ipFrrProtectedRoutes=ipFrrProtectedRoutes, ipFrrAltStatus=ipFrrAltStatus, ipFrrMIBCompliance=ipFrrMIBCompliance, ipFrrBasicGroup=ipFrrBasicGroup, ipFrrNoAltCause=ipFrrNoAltCause, ipFrrAltNextHop=ipFrrAltNextHop, ipFrrAltIfIndex=ipFrrAltIfIndex, ipFrrMIBGroups=ipFrrMIBGroups, ipFrrNodeProtectedRoutes=ipFrrNodeProtectedRoutes, ipFrrMIBConformance=ipFrrMIBConformance, ipFrrMIBInetCompliance=ipFrrMIBInetCompliance, ipFrrTotalRoutes=ipFrrTotalRoutes, ipFrrAltEntry=ipFrrAltEntry, ipFrrNoAltTable=ipFrrNoAltTable, ipFrrMIBObjects=ipFrrMIBObjects, ipFrrAltNextHopType=ipFrrAltNextHopType, ipFrrAltTable=ipFrrAltTable, ipFrrAltType=ipFrrAltType, ipFrrNoAltEntry=ipFrrNoAltEntry, ipFrrMIBCompliances=ipFrrMIBCompliances, ipFrrProtectStats=ipFrrProtectStats, ipFrrLinkProtectedRoutes=ipFrrLinkProtectedRoutes, ipFrrReadOnlyCompliance=ipFrrReadOnlyCompliance)

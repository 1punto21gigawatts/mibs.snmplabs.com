#
# PySNMP MIB module IPV4ARP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPV4ARP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
apIpv4Arp, = mibBuilder.importSymbols("APENT-MIB", "apIpv4Arp")
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, NotificationType, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter64, ObjectIdentity, Unsigned32, MibIdentifier, Bits, Gauge32, Counter32, IpAddress, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter64", "ObjectIdentity", "Unsigned32", "MibIdentifier", "Bits", "Gauge32", "Counter32", "IpAddress", "Integer32")
TextualConvention, RowStatus, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "MacAddress")
ipv4ArpMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 1))
if mibBuilder.loadTexts: ipv4ArpMib.setLastUpdated('9711242000Z')
if mibBuilder.loadTexts: ipv4ArpMib.setOrganization('ArrowPoint Communications Inc.')
if mibBuilder.loadTexts: ipv4ArpMib.setContactInfo('Postal: ArrowPoint Communications Inc. 50 Nagog Park Acton, Massachusetts 01720 Tel: +1 978-206-3000 option 1 E-Mail: support@arrowpoint.com')
if mibBuilder.loadTexts: ipv4ArpMib.setDescription('This MIB module describes the ArrowPoint enterprise MIB support for IPv4 ARP')
apIpv4ArpAddressMax = MibScalar((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIpv4ArpAddressMax.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpAddressMax.setDescription('Maximum number of addresses that can be simultaneously resolved on one board.')
apIpv4ArpResponseWait = MibScalar((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIpv4ArpResponseWait.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpResponseWait.setDescription('Amount of time in seconds to wait for an ARP response')
apIpv4ArpFlushTime = MibScalar((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 86401)).clone(14400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIpv4ArpFlushTime.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpFlushTime.setDescription("Amount of time in seconds a resolved address is held in the ARP cache. Default is 4 hours. 86401 is a special value that means 'no timeout'.")
apIpv4StaticArpTable = MibTable((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5), )
if mibBuilder.loadTexts: apIpv4StaticArpTable.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpTable.setDescription('A Table of static ARP entries')
apIpv4StaticArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5, 1), ).setIndexNames((0, "IPV4ARP-MIB", "apIpv4ArpIpAddress"))
if mibBuilder.loadTexts: apIpv4StaticArpEntry.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpEntry.setDescription(' ')
apIpv4StaticArpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4StaticArpIpAddress.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpIpAddress.setDescription('IP address for static mapping.')
apIpv4StaticArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apIpv4StaticArpMacAddress.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpMacAddress.setDescription('MAC address for static mapping.')
apIpv4StaticArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apIpv4StaticArpStatus.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpStatus.setDescription('(fill in later)')
apIpv4StaticArpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apIpv4StaticArpIfIndex.setStatus('current')
if mibBuilder.loadTexts: apIpv4StaticArpIfIndex.setDescription('The ifIndex on which this ARP address is configured.')
apIpv4ArpTable = MibTable((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6), )
if mibBuilder.loadTexts: apIpv4ArpTable.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpTable.setDescription('A Table of hosts resolved by ARP')
apIpv4ArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1), ).setIndexNames((0, "IPV4ARP-MIB", "apIpv4ArpIpAddress"))
if mibBuilder.loadTexts: apIpv4ArpEntry.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpEntry.setDescription(' ')
apIpv4ArpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4ArpIpAddress.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpIpAddress.setDescription('IP host address.')
apIpv4ArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4ArpMacAddress.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpMacAddress.setDescription('MAC address for host.')
apIpv4ArpResolutionType = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4ArpResolutionType.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpResolutionType.setDescription('Method by which the address was resolved.')
apIpv4ArpSlotLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4ArpSlotLearned.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpSlotLearned.setDescription('Physical slot on which this ARP address was learned.')
apIpv4ArpPortLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 2467, 1, 9, 4, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIpv4ArpPortLearned.setStatus('current')
if mibBuilder.loadTexts: apIpv4ArpPortLearned.setDescription('Physical port on which this ARP address was learned.')
mibBuilder.exportSymbols("IPV4ARP-MIB", apIpv4ArpAddressMax=apIpv4ArpAddressMax, apIpv4ArpTable=apIpv4ArpTable, apIpv4ArpFlushTime=apIpv4ArpFlushTime, apIpv4StaticArpStatus=apIpv4StaticArpStatus, apIpv4ArpResponseWait=apIpv4ArpResponseWait, PYSNMP_MODULE_ID=ipv4ArpMib, ipv4ArpMib=ipv4ArpMib, apIpv4StaticArpIpAddress=apIpv4StaticArpIpAddress, apIpv4ArpPortLearned=apIpv4ArpPortLearned, apIpv4ArpEntry=apIpv4ArpEntry, apIpv4StaticArpMacAddress=apIpv4StaticArpMacAddress, apIpv4StaticArpEntry=apIpv4StaticArpEntry, apIpv4StaticArpTable=apIpv4StaticArpTable, apIpv4ArpSlotLearned=apIpv4ArpSlotLearned, apIpv4ArpMacAddress=apIpv4ArpMacAddress, apIpv4StaticArpIfIndex=apIpv4StaticArpIfIndex, apIpv4ArpIpAddress=apIpv4ArpIpAddress, apIpv4ArpResolutionType=apIpv4ArpResolutionType)

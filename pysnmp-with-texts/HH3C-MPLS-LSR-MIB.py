#
# PySNMP MIB module HH3C-MPLS-LSR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-MPLS-LSR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
hh3cMpls, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cMpls")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressIPv6, InetAddressIPv4, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddressIPv4", "InetAddressType")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Gauge32, NotificationType, Bits, MibIdentifier, Counter32, ModuleIdentity, Unsigned32, TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "NotificationType", "Bits", "MibIdentifier", "Counter32", "ModuleIdentity", "Unsigned32", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "ObjectIdentity", "iso")
RowPointer, TimeStamp, TruthValue, StorageType, TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "TruthValue", "StorageType", "TextualConvention", "RowStatus", "DisplayString")
hh3cMplsLsr = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1))
hh3cMplsLsr.setRevisions(('2000-07-12 12:00', '2000-07-07 12:00', '2000-04-26 12:00', '2000-04-21 12:00', '2000-03-06 12:00', '2000-02-16 12:00', '1999-06-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cMplsLsr.setRevisionsDescriptions(('Seventh draft version. Fix minor compilation errors.', 'Sixth draft version. Made minor typographical corrections noted from WG mailing list during second working group last call.', 'Fifth draft version. Made minor typographical corrections noted from WG mailing list.', 'Fourth draft version. Made corrections from WG Last Call comments.', 'Third draft version.', 'Second draft version.', 'Initial draft version.',))
if mibBuilder.loadTexts: hh3cMplsLsr.setLastUpdated('200007121200Z')
if mibBuilder.loadTexts: hh3cMplsLsr.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cMplsLsr.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cMplsLsr.setDescription('This MIB contains managed object definitions for the Multiprotocol Label Switching (MPLS) Router as defined in: Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, Internet Draft <draft-ietf-mpls-arch-06.txt>, August 1999.')
class Hh3cMplsLSPID(TextualConvention, OctetString):
    description = 'An identifier that is assigned to each LSP and is used to uniquely identify it. This is assigned at the head end of the LSP and can be used by all LSRs to identify this LSP. This value is piggybacked by the signaling protocol when this LSP is signaled within the network. This identifier can then be used at each LSR to identify which labels are being swapped to other labels for this LSP. For IPv4 addresses this results in a 6-octet long cookie.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class Hh3cMplsLabel(TextualConvention, Unsigned32):
    reference = '1. MPLS Label Stack Encoding, Rosen et al, draft- ietf-mpls-label-encaps-07.txt, March 2000. 2. Use of Label Switching on Frame Relay Networks, Conta et al, draft-ietf-mpls-fr-03.txt, Nov. 1998. 3. MPLS using LDP and ATM VC switching, Davie et al, draft-ietf-mpls-atm-02.txt, April 1999.'
    description = 'This value represents an MPLS label. Note that the contents of a label field are interpreted in an interface-type specific fashion. For example, the 20-bit wide label carried in the MPLS shim header is contained in bits 0-19 and bits 20-31 must be zero. The frame relay label can be either 10 or 23 bits wide depending on the size of the DLCI field and bits 10-31, or 23-31 must be zero, respectively. For an ATM interface, bits 0-15 must be interpreted as the VCI, bits 16-23 as the VPI and bits 24-31 must be zero. Note that the permissible label values are also a function of the interface type. For example, the value 3 has special semantics in the control plane for an MPLS shim header label and is not a valid label value in the data path.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class Hh3cMplsBitRate(TextualConvention, Integer32):
    description = "An estimate of bandwidth in units of 1,000 bits per second. If this object reports a value of 'n' then the rate of the object is somewhere in the range of 'n-500' to 'n+499'. For objects which do not vary in bitrate, or for those where no accurate estimation can be made, this object should contain the nominal bitrate."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class Hh3cMplsBurstSize(TextualConvention, Integer32):
    description = 'The number of octets of MPLS data that the stream may send back-to-back without concern for policing.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class Hh3cMplsObjectOwner(TextualConvention, Integer32):
    description = 'The entity which owns the object in question.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("other", 1), ("snmp", 2), ("ldp", 3), ("rsvp", 4), ("crldp", 5), ("policyAgent", 6), ("unknown", 7))

hh3cmplsLsrObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1))
hh3cmplsLsrNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 2))
hh3cmplsLsrNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 2, 0))
hh3cmplsLsrConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3))
hh3cmplsInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1), )
if mibBuilder.loadTexts: hh3cmplsInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceConfTable.setDescription('This table specifies per-interface MPLS capability and associated information.')
hh3cmplsInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceConfIndex"))
if mibBuilder.loadTexts: hh3cmplsInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for every interface capable of supporting MPLS. The entry with index 0 represents the per-platform label space and contains parameters that apply to all interfaces that participate in the per-platform label space. Other entries defined in this table represent additional MPLS interfaces that may participate in either the per-platform or per- interface label spaces, or both. Additional information about label space participation of an interface is provided in the description clause of hh3cmplsInterfaceLabelParticipationType.')
hh3cmplsInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hh3cmplsInterfaceConfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: hh3cmplsInterfaceConfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceConfIndex.setDescription('This is a unique index for an entry in the hh3cmplsInterfaceConfTable. A non-zero index for an entry indicates the ifIndex for the corresponding interface entry in of the MPLS-layer in the ifTable. Note that the per-platform label space may apply to several interfaces, and therefore the configuration of the per-platform label space interface parameters will apply to all of the interfaces that are participating in the per-platform label space.')
hh3cmplsInterfaceLabelMinIn = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 2), Hh3cMplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMinIn.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMinIn.setDescription('This is the minimum value of an MPLS label that this LSR is willing to receive on this interface.')
hh3cmplsInterfaceLabelMaxIn = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 3), Hh3cMplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMaxIn.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMaxIn.setDescription('This is the maximum value of an MPLS label that this LSR is willing to receive on this interface.')
hh3cmplsInterfaceLabelMinOut = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 4), Hh3cMplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMinOut.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMinOut.setDescription('This is the minimum value of an MPLS label that this LSR is willing to send on this interface.')
hh3cmplsInterfaceLabelMaxOut = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 5), Hh3cMplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMaxOut.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelMaxOut.setDescription('This is the maximum value of an MPLS label that this LSR is willing to send on this interface.')
hh3cmplsInterfaceTotalBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 6), Hh3cMplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceTotalBandwidth.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceTotalBandwidth.setDescription('This value indicates the total amount of usable bandwidth on this interface and is specified in kilobits per second (Kbps). This variable is not applicable when applied to the interface with index 0.')
hh3cmplsInterfaceAvailableBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 7), Hh3cMplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceAvailableBandwidth.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceAvailableBandwidth.setDescription('This value indicates the total amount of available bandwidth available on this interface and is specified in kilobits per second (Kbps). This value is calculated as the difference between the amount of bandwidth currently in use and that specified in hh3cmplsInterfaceTotalBandwidth. This variable is not applicable when applied to the interface with index 0.')
hh3cmplsInterfaceLabelParticipationType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 8), Bits().clone(namedValues=NamedValues(("perPlatform", 0), ("perInterface", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelParticipationType.setReference('Multiprotocol Label Switching, Rosen et al, draft-ietf-mpls- arch-06.txt, August 1999.')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelParticipationType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceLabelParticipationType.setDescription('Either the perPlatform(0) or perInterface(1) bit MUST be set. If the value of the hh3cmplsInterfaceConfIndex for this entry is zero, then only the perPlatform(0) bit MUST be set and the perInterface(1) bit is meaningless. If the perInterface(1) bit is set then the value of hh3cmplsInterfaceLabelMinIn, hh3cmplsInterfaceLabelMaxIn, hh3cmplsInterfaceLabelMinOut, and hh3cmplsInterfaceLabelMaxOut for this entry reflect the label ranges for this interface. If only the perPlatform(0) bit is set, then the value of hh3cmplsInterfaceLabelMinIn, hh3cmplsInterfaceLabelMaxIn, hh3cmplsInterfaceLabelMinOut, and hh3cmplsInterfaceLabelMaxOut for this entry must be identical to the instance of these objects with index 0.')
hh3cmplsInterfaceConfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 1, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInterfaceConfStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceConfStorageType.setDescription('The storage type for this entry.')
hh3cmplsInterfacePerfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2), )
if mibBuilder.loadTexts: hh3cmplsInterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfacePerfTable.setDescription('This table provides MPLS performance information on a per-interface basis.')
hh3cmplsInterfacePerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2, 1), )
hh3cmplsInterfaceConfEntry.registerAugmentions(("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfacePerfEntry"))
hh3cmplsInterfacePerfEntry.setIndexNames(*hh3cmplsInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: hh3cmplsInterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfacePerfEntry.setDescription('An entry in this table is created by the LSR for every interface capable of supporting MPLS. Its is an extension to the hh3cmplsInterfaceConfEntry table.')
hh3cmplsInterfaceInLabelsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceInLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceInLabelsUsed.setDescription('This object counts the number of labels that are in use at this point in time on this interface in the incoming direction. If the interface participates in the per-platform label space only, then this instance of this object MUST be identical with the instance with index 0. If the interface participates in the per-interface label space, then this this instance of this object MUST represent the number of of per-interface labels that are in use at this point in time on this interface.')
hh3cmplsInterfaceFailedLabelLookup = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceFailedLabelLookup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceFailedLabelLookup.setDescription('This object counts the number of labeled packets that have been received on this interface and were discarded because there was no matching cross-connect entry. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
hh3cmplsInterfaceOutLabelsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceOutLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceOutLabelsUsed.setDescription('This object counts the number of top-most labels in the outgoing label stacks that are in use at this point in time on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
hh3cmplsInterfaceOutFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInterfaceOutFragments.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceOutFragments.setDescription('This object counts the number of outgoing MPLS packets that required fragmentation before transmission on this interface. This object transmission on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
hh3cmplsInSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3), )
if mibBuilder.loadTexts: hh3cmplsInSegmentTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentTable.setDescription('This table contains a collection of incoming segments to an LSR.')
hh3cmplsInSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentIfIndex"), (0, "HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentLabel"))
if mibBuilder.loadTexts: hh3cmplsInSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentEntry.setDescription('An entry in this table represents one incoming segment. An entry can be created by a network administrator or an SNMP agent, or an MPLS signaling protocol. The creator of the entry is denoted by hh3cmplsInSegmentOwner. An entry in this table is indexed by the ifIndex of the incoming interface and the (top) label.')
hh3cmplsInSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 1), InterfaceIndexOrZero()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cmplsInSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentIfIndex.setDescription('This is a unique index for an entry in the hh3cmplsInSegmentTable. This value represents the interface index for the incoming MPLS interface. A value of zero represents an incoming label from the per-platform label space. In this case, the hh3cmplsInSegmentLabel is interpreted to be an MPLS-type label.')
hh3cmplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 2), Hh3cMplsLabel()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cmplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentLabel.setDescription('The incoming label for this segment.')
hh3cmplsInSegmentNPop = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentNPop.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentNPop.setDescription('The number of labels to pop from the incoming packet. Normally only the top label is popped from the packet and used for all switching decisions for that packet. Note that technologies which do not support label popping should set this value to its default value of 1.')
hh3cmplsInSegmentAddrFamily = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 4), AddressFamilyNumbers().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentAddrFamily.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentAddrFamily.setDescription('The IANA address family [IANAFamily] of the incoming packet. A value of other(0) indicates that the family type is either unknown or undefined.')
hh3cmplsInSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentXCIndex.setDescription('Index into hh3cmplsXCTable which identifies which cross- connect entry this segment is part of. A value of zero indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this in-segment is a part of, this object is automatically updated to reflect the value of hh3cmplsXCIndex of that cross-connect entry.')
hh3cmplsInSegmentOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 6), Hh3cMplsObjectOwner().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentOwner.setDescription('Denotes the entity that created and is responsible for managing this segment.')
hh3cmplsInSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 7), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this in-segment. This value may point at an entry in the hh3cmplsTrafficParamTable to indicate which hh3cmplsTrafficParamEntry is to be assigned to this segment. This value may optionally point at an externally defined traffic parameter specification table. A value of zero-dot-zero indicates best-effort treatment. By having the same value of this object, two or more segments can indicate resource sharing.')
hh3cmplsInSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
hh3cmplsInSegmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 3, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsInSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentStorageType.setDescription('This variable indicates the storage type for this object.')
hh3cmplsInSegmentPerfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4), )
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfTable.setDescription('This table contains statistical information for incoming MPLS segments to an LSR.')
hh3cmplsInSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1), )
hh3cmplsInSegmentEntry.registerAugmentions(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentPerfEntry"))
hh3cmplsInSegmentPerfEntry.setIndexNames(*hh3cmplsInSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one incoming segment which was configured in the hh3cmplsInSegmentTable. The counters in this entry should behave in a manner similar to that of the interface.')
hh3cmplsInSegmentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentOctets.setDescription('This value represents the total number of octets received by this segment.')
hh3cmplsInSegmentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentPackets.setDescription('Total number of packets received by this segment.')
hh3cmplsInSegmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentErrors.setDescription('The number of errored packets received on this segment.')
hh3cmplsInSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentDiscards.setDescription('The number of labeled packets received on this in- segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
hh3cmplsInSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentHCOctets.setDescription('The total number of octets received. This is the 64 bit version of hh3cmplsInSegmentOctets.')
hh3cmplsInSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
hh3cmplsOutSegmentIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentIndexNext.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentIndexNext.setDescription('This object contains the next appropriate value to be used for hh3cmplsOutSegmentIndex when creating entries in the hh3cmplsOutSegmentTable. If the number of unassigned entries is exhausted, this object will take on the value of 0. To obtain the hh3cmplsOutSegmentIndex value for a new entry, the manager must first issue a management protocol retrieval operation to obtain the current value of this object. The agent should modify the value to reflect the next unassigned index after each retrieval operation. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
hh3cmplsOutSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6), )
if mibBuilder.loadTexts: hh3cmplsOutSegmentTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentTable.setDescription('This table contains a representation of the outgoing segments from an LSR.')
hh3cmplsOutSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIndex"))
if mibBuilder.loadTexts: hh3cmplsOutSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentEntry.setDescription('An entry in this table represents one outgoing segment. An entry can be created by a network administrator or an SNMP agent, or an MPLS signaling protocol. The object hh3cmplsOutSegmentOwner indicates the creator of this entry.')
hh3cmplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cmplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentIndex.setDescription('This value contains a unique index for this row. While a value of 0 is not valid as an index for this row it can be supplied as a valid value to index hh3cmplsXCTable to access entries for which no out- segment has been configured.')
hh3cmplsOutSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentIfIndex.setDescription('This value contains the interface index of the outgoing interface.')
hh3cmplsOutSegmentPushTopLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentPushTopLabel.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentPushTopLabel.setDescription("This value indicates whether or not a top label should be pushed onto the outgoing packet's label stack. The value of this variable must be set to true if the outgoing interface does not support pop- and-go (for example an ATM interface) or if it is a tunnel origination. Note that it is considered an error in the case that hh3cmplsOutSegmentPushTopLabel is set to false, but the cross-connect entry which refers to this out-segment has a non-zero hh3cmplsLabelStackIndex. The LSR MUST ensure that this situation does not happen ")
hh3cmplsOutSegmentTopLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 4), Hh3cMplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentTopLabel.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentTopLabel.setDescription("If hh3cmplsOutSegmentPushTopLabel is true then this represents the label that should be pushed onto the top of the outgoing packet's label stack.")
hh3cmplsOutSegmentNextHopIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 5), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpAddrType.setDescription('Indicates whether the next hop address is IPv4 or IPv6. Note that a value of unknown (0) is valid only when the outgoing interface is of type point-to- point.')
hh3cmplsOutSegmentNextHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 6), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpv4Addr.setDescription('IPv4 Address of the next hop. Its value is significant only when hh3cmplsOutSegmentNextHopIpAddrType is ipV4 (1), otherwise it should return a value of 0.')
hh3cmplsOutSegmentNextHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 7), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentNextHopIpv6Addr.setDescription('IPv6 address of the next hop. Its value is significant only when hh3cmplsOutSegmentNextHopIpAddrType is ipV6 (2), otherwise it should return a value of 0.')
hh3cmplsOutSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentXCIndex.setDescription('Index into hh3cmplsXCTable which identifies which cross- connect entry this segment is part of. A value of zero indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this out-segment is a part of, this object is automatically updated to reflect the value of hh3cmplsXCIndex of that cross-connect entry.')
hh3cmplsOutSegmentOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 9), Hh3cMplsObjectOwner().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentOwner.setDescription('Denotes the entity which created and is responsible for managing this segment.')
hh3cmplsOutSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 10), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this out-segment. This value may point at an entry in the hh3cmplsTrafficParamTable to indicate which hh3cmplsTrafficParamEntry is to be assigned to this segment. This value may optionally point at an externally defined traffic parameter specification table. A value of zero-dot-zero indicates best- effort treatment. By having the same value of this object, two or more segments can indicate resource sharing.')
hh3cmplsOutSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentRowStatus.setDescription('For creating, modifying, and deleting this row.')
hh3cmplsOutSegmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 6, 1, 12), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsOutSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentStorageType.setDescription('This variable indicates the storage type for this object.')
hh3cmplsOutSegmentPerfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7), )
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfTable.setDescription('This table contains statistical information about outgoing segments from an LSR. The counters in this entry should behave in a manner similar to that of the interface.')
hh3cmplsOutSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1), )
hh3cmplsOutSegmentEntry.registerAugmentions(("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentPerfEntry"))
hh3cmplsOutSegmentPerfEntry.setIndexNames(*hh3cmplsOutSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one outgoing segment configured in hh3cmplsOutSegmentTable.')
hh3cmplsOutSegmentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentOctets.setDescription('This value contains the total number of octets sent on this segment.')
hh3cmplsOutSegmentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentPackets.setDescription('This value contains the total number of packets sent on this segment.')
hh3cmplsOutSegmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentErrors.setDescription('Number of packets that could not be sent due to errors on this segment.')
hh3cmplsOutSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentDiscards.setDescription('The number of labeled packets received on this out- segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
hh3cmplsOutSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentHCOctets.setDescription('Total number of octets sent. This is the 64 bit version of hh3cmplsOutSegmentOctets.')
hh3cmplsOutSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 7, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
hh3cmplsXCIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsXCIndexNext.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCIndexNext.setDescription('This object contains an appropriate value to be used for hh3cmplsXCIndex when creating entries in the hh3cmplsXCTable. The value 0 indicates that no unassigned entries are available. To obtain the value of hh3cmplsXCIndex for a new entry in the hh3cmplsXCTable, the manager issues a management protocol retrieval operation to obtain the current value of hh3cmplsXCIndex. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
hh3cmplsXCTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9), )
if mibBuilder.loadTexts: hh3cmplsXCTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCTable.setDescription('This table specifies information for switching between LSP segments. It supports point-to-point, point-to-multipoint and multipoint-to-point connections. hh3cmplsLabelStackTable specifies the label stack information for a cross-connect LSR and is referred to from hh3cmplsXCTable.')
hh3cmplsXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsXCIndex"), (0, "HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentIfIndex"), (0, "HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentLabel"), (0, "HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIndex"))
if mibBuilder.loadTexts: hh3cmplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCEntry.setDescription('A row in this table represents one cross-connect entry. The following objects index it: - cross-connect index hh3cmplsXCIndex that uniquely identifies a group of cross-connect entries - interface index of the in-segment, hh3cmplsInSegmentIfIndex - incoming label(s), hh3cmplsInSegmentLabel - out-segment index, hh3cmplsOutSegmentIndex Originating LSPs: These are represented by using the special combination of values hh3cmplsInSegmentIfIndex=0 and hh3cmplsInSegmentLabel=0 as indexes. In this case the hh3cmplsOutSegmentIndex MUST be non-zero. Terminating LSPs: These are represented by using the special value hh3cmplsOutSegmentIndex=0 as index. Special labels: Entries indexed by reserved MPLS label values 0 through 15 imply terminating LSPs and MUST have hh3cmplsOutSegmentIfIndex = 0. Note that situations where LSPs are terminated with incoming label equal to 0, should have hh3cmplsInSegmentIfIndex = 0 as well, but can be distinguished from originating LSPs because the hh3cmplsOutSegmentIfIndex = 0. The hh3cmplsOutSegmentIfIndex MUST only be set to 0 in cases of terminating LSPs. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
hh3cmplsXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cmplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCIndex.setDescription('Primary index for the conceptual row identifying a group of cross-connect segments.')
hh3cmplsXCLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 2), Hh3cMplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCLspId.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCLspId.setDescription('This value identifies the label switched path that this cross-connect entry belongs to.')
hh3cmplsXCLabelStackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCLabelStackIndex.setDescription('Primary index into hh3cmplsLabelStackTable identifying a stack of labels to be pushed beneath the top label. Note that the top label identified by the out- segment ensures that all the components of a multipoint-to-point connection have the same outgoing label. A value of 0 indicates that no labels are to be stacked beneath the top label.')
hh3cmplsXCIsPersistent = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCIsPersistent.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCIsPersistent.setDescription('Denotes whether or not this cross-connect entry and associated in- and out-segments should be restored automatically after failures. This value MUST be set to false in cases where this cross-connect entry was created by a signaling protocol.')
hh3cmplsXCOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 5), Hh3cMplsObjectOwner()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCOwner.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCOwner.setDescription('Denotes the entity that created and is responsible for managing this cross-connect.')
hh3cmplsXCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCRowStatus.setDescription('For creating, modifying, and deleting this row.')
hh3cmplsXCStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 7), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCStorageType.setDescription('Defines the storage type for this object.')
hh3cmplsXCAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsXCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCAdminStatus.setDescription('The desired operational status of this segment.')
hh3cmplsXCOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsXCOperStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCOperStatus.setDescription('The actual operational status of this cross- connect.')
hh3cmplsMaxLabelStackDepth = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsMaxLabelStackDepth.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsMaxLabelStackDepth.setDescription('The maximum stack depth supported by this LSR.')
hh3cmplsLabelStackIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsLabelStackIndexNext.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackIndexNext.setDescription('This object contains an appropriate value to be used for hh3cmplsLabelStackIndex when creating entries in the hh3cmplsLabelStackTable. The value 0 indicates that no unassigned entries are available. To obtain an hh3cmplsLabelStackIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
hh3cmplsLabelStackTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12), )
if mibBuilder.loadTexts: hh3cmplsLabelStackTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackTable.setDescription('This table specifies the label stack to be pushed onto a packet, beneath the top label. Entries into this table are referred to from hh3cmplsXCTable.')
hh3cmplsLabelStackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackIndex"), (0, "HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackLabelIndex"))
if mibBuilder.loadTexts: hh3cmplsLabelStackEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackEntry.setDescription('An entry in this table represents one label which is to be pushed onto an outgoing packet, beneath the top label. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
hh3cmplsLabelStackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cmplsLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackIndex.setDescription('Primary index for this row identifying a stack of labels to be pushed on an outgoing packet, beneath the top label.')
hh3cmplsLabelStackLabelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cmplsLabelStackLabelIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackLabelIndex.setDescription('Secondary index for this row identifying one label of the stack. Note that an entry with a smaller hh3cmplsLabelStackLabelIndex would refer to a label higher up the label stack and would be popped at a downstream LSR before a label represented by a higher hh3cmplsLabelStackLabelIndex at a downstream LSR.')
hh3cmplsLabelStackLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1, 3), Hh3cMplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsLabelStackLabel.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackLabel.setDescription('The label to pushed.')
hh3cmplsLabelStackRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsLabelStackRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackRowStatus.setDescription('For creating, modifying, and deleting this row.')
hh3cmplsLabelStackStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 12, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsLabelStackStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackStorageType.setDescription('Defines the storage type for this object.')
hh3cmplsTrafficParamIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsTrafficParamIndexNext.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamIndexNext.setDescription('This object contains an appropriate value which will be used for hh3cmplsTrafficParamIndex when creating entries in the hh3cmplsTrafficParamTable. The value 0 indicates that no unassigned entries are available. To obtain the hh3cmplsTrafficParamIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
hh3cmplsTrafficParamTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14), )
if mibBuilder.loadTexts: hh3cmplsTrafficParamTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamTable.setDescription('This table specifies the Traffic Parameter objects for in and out-segments.')
hh3cmplsTrafficParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1), ).setIndexNames((0, "HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamIndex"))
if mibBuilder.loadTexts: hh3cmplsTrafficParamEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamEntry.setDescription('An entry in this table represents the TrafficParam objects for one or more in or out segments. A single entry can be pointed to by multiple segments indicating resource sharing.')
hh3cmplsTrafficParamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cmplsTrafficParamIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamIndex.setDescription('Uniquely identifies this row of the table. Note that zero represents an invalid index.')
hh3cmplsTrafficParamMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 2), Hh3cMplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsTrafficParamMaxRate.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamMaxRate.setDescription('Maximum rate in kilobits/second.')
hh3cmplsTrafficParamMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 3), Hh3cMplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsTrafficParamMeanRate.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamMeanRate.setDescription('Mean rate in kilobits/second.')
hh3cmplsTrafficParamMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 4), Hh3cMplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsTrafficParamMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamMaxBurstSize.setDescription('Maximum burst size in bytes.')
hh3cmplsTrafficParamRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsTrafficParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamRowStatus.setDescription('For creating, modifying, and deleting this row.')
hh3cmplsTrafficParamStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 14, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsTrafficParamStorageType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamStorageType.setDescription('The storage type for this object.')
hh3cmplsXCTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cmplsXCTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCTrapEnable.setDescription('If this object is true, then it enables the generation of hh3cmplsXCUp and hh3cmplsXCDown traps, otherwise these traps are not emitted.')
hh3cmplsXCUp = NotificationType((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 2, 0, 1)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentIfIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentLabel"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCAdminStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCOperStatus"))
if mibBuilder.loadTexts: hh3cmplsXCUp.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCUp.setDescription('This notification is generated when a hh3cmplsXCOperStatus object for one of the configured cross-connect entries is about to leave the down state and transition into some other state (but not into the notPresent state). This other state is indicated by the included value of hh3cmplsXCOperStatus.')
hh3cmplsXCDown = NotificationType((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 2, 0, 2)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentIfIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentLabel"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCAdminStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCOperStatus"))
if mibBuilder.loadTexts: hh3cmplsXCDown.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCDown.setDescription('This notification is generated when a hh3cmplsXCOperStatus object for one of the configured cross-connect entries is about to enter the down state from some other state (but not from the notPresent state). This other state is indicated by the included value of hh3cmplsXCOperStatus.')
hh3cmplsLsrGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1))
hh3cmplsLsrCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 2))
hh3cmplsLsrModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 2, 1)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsPerfGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsSegmentDiscontinuityGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsHCInSegmentPerfGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsHCOutSegmentPerfGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIsPersistentGroup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIsNotPersistentGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsLsrModuleCompliance = hh3cmplsLsrModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLsrModuleCompliance.setDescription('Compliance statement for agents that support the MPLS LSR MIB.')
hh3cmplsInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 1)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceLabelMinIn"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceLabelMaxIn"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceLabelMinOut"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceLabelMaxOut"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceTotalBandwidth"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceAvailableBandwidth"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceLabelParticipationType"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceConfStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsInterfaceGroup = hh3cmplsInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInterfaceGroup.setDescription('Collection of objects needed for MPLS interface configuration and performance information.')
hh3cmplsInSegmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 2)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentNPop"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentAddrFamily"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentXCIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentOctets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentDiscards"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentOwner"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentRowStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentStorageType"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsInSegmentGroup = hh3cmplsInSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsInSegmentGroup.setDescription('Collection of objects needed to implement an in- segment.')
hh3cmplsOutSegmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 3)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIndexNext"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentIfIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentPushTopLabel"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentTopLabel"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentNextHopIpAddrType"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentNextHopIpv4Addr"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentNextHopIpv6Addr"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentXCIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentOwner"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentOctets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentDiscards"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentErrors"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentRowStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentStorageType"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsOutSegmentGroup = hh3cmplsOutSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsOutSegmentGroup.setDescription('Collection of objects needed to implement an out- segment.')
hh3cmplsXCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 4)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIndexNext"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCLabelStackIndex"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCOwner"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCAdminStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCOperStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCRowStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCTrapEnable"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsXCGroup = hh3cmplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCGroup.setDescription('Collection of objects needed to implement a cross-connect entry.')
hh3cmplsXCOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 5)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCLspId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsXCOptionalGroup = hh3cmplsXCOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCOptionalGroup.setDescription('Collection of optional objects for implementing a cross-connect entry.')
hh3cmplsPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 6)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentOctets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentPackets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentErrors"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentDiscards"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentOctets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentPackets"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentDiscards"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceInLabelsUsed"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceFailedLabelLookup"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceOutFragments"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsInterfaceOutLabelsUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsPerfGroup = hh3cmplsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsPerfGroup.setDescription('Collection of objects providing performance information about an LSR.')
hh3cmplsHCInSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 7)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsHCInSegmentPerfGroup = hh3cmplsHCInSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsHCInSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object hh3cmplsInterfaceInOctets wraps around too quickly.')
hh3cmplsHCOutSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 8)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsHCOutSegmentPerfGroup = hh3cmplsHCOutSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsHCOutSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object hh3cmplsInterfaceOutOctets wraps around too quickly.')
hh3cmplsTrafficParamGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 9)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamIndexNext"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamMaxRate"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamMeanRate"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamMaxBurstSize"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamRowStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsTrafficParamStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsTrafficParamGroup = hh3cmplsTrafficParamGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsTrafficParamGroup.setDescription('Object(s) required for supporting QoS resource reservation.')
hh3cmplsXCIsPersistentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 10)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsXCIsPersistentGroup = hh3cmplsXCIsPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCIsPersistentGroup.setDescription('Objects needed to support persistent cross- connects.')
hh3cmplsXCIsNotPersistentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 11)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsXCIsNotPersistentGroup = hh3cmplsXCIsNotPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsXCIsNotPersistentGroup.setDescription('Objects needed to support non-persistent cross- connects.')
hh3cmplsLabelStackGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 12)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackLabel"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackRowStatus"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackStorageType"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsMaxLabelStackDepth"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsLabelStackIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsLabelStackGroup = hh3cmplsLabelStackGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLabelStackGroup.setDescription('Objects needed to support label stacking.')
hh3cmplsSegmentDiscontinuityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 13)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsInSegmentPerfDiscontinuityTime"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsOutSegmentPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsSegmentDiscontinuityGroup = hh3cmplsSegmentDiscontinuityGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsSegmentDiscontinuityGroup.setDescription(' A collection of objects providing information specific to segment discontinuities..')
hh3cmplsLsrNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 25506, 8, 12, 1, 3, 1, 14)).setObjects(("HH3C-MPLS-LSR-MIB", "hh3cmplsXCUp"), ("HH3C-MPLS-LSR-MIB", "hh3cmplsXCDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cmplsLsrNotificationGroup = hh3cmplsLsrNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsLsrNotificationGroup.setDescription('Set of notifications implemented in this module. None is mandatory.')
mibBuilder.exportSymbols("HH3C-MPLS-LSR-MIB", hh3cmplsOutSegmentNextHopIpv6Addr=hh3cmplsOutSegmentNextHopIpv6Addr, hh3cmplsOutSegmentTrafficParamPtr=hh3cmplsOutSegmentTrafficParamPtr, hh3cmplsTrafficParamIndexNext=hh3cmplsTrafficParamIndexNext, hh3cmplsInterfaceLabelMaxIn=hh3cmplsInterfaceLabelMaxIn, hh3cmplsTrafficParamMeanRate=hh3cmplsTrafficParamMeanRate, Hh3cMplsLSPID=Hh3cMplsLSPID, hh3cmplsInterfaceConfStorageType=hh3cmplsInterfaceConfStorageType, hh3cmplsInSegmentOwner=hh3cmplsInSegmentOwner, hh3cmplsOutSegmentIndex=hh3cmplsOutSegmentIndex, hh3cmplsOutSegmentRowStatus=hh3cmplsOutSegmentRowStatus, Hh3cMplsObjectOwner=Hh3cMplsObjectOwner, hh3cmplsInterfaceTotalBandwidth=hh3cmplsInterfaceTotalBandwidth, hh3cmplsLabelStackTable=hh3cmplsLabelStackTable, hh3cMplsLsr=hh3cMplsLsr, hh3cmplsXCOptionalGroup=hh3cmplsXCOptionalGroup, hh3cmplsInSegmentGroup=hh3cmplsInSegmentGroup, hh3cmplsOutSegmentNextHopIpv4Addr=hh3cmplsOutSegmentNextHopIpv4Addr, hh3cmplsLsrNotifyPrefix=hh3cmplsLsrNotifyPrefix, hh3cmplsInSegmentPerfDiscontinuityTime=hh3cmplsInSegmentPerfDiscontinuityTime, Hh3cMplsBitRate=Hh3cMplsBitRate, hh3cmplsInSegmentRowStatus=hh3cmplsInSegmentRowStatus, hh3cmplsTrafficParamIndex=hh3cmplsTrafficParamIndex, hh3cmplsInSegmentErrors=hh3cmplsInSegmentErrors, hh3cmplsInterfaceGroup=hh3cmplsInterfaceGroup, hh3cmplsLabelStackStorageType=hh3cmplsLabelStackStorageType, hh3cmplsInterfacePerfTable=hh3cmplsInterfacePerfTable, hh3cmplsTrafficParamGroup=hh3cmplsTrafficParamGroup, hh3cmplsXCIsPersistentGroup=hh3cmplsXCIsPersistentGroup, hh3cmplsTrafficParamEntry=hh3cmplsTrafficParamEntry, hh3cmplsInSegmentNPop=hh3cmplsInSegmentNPop, hh3cmplsXCDown=hh3cmplsXCDown, hh3cmplsInSegmentAddrFamily=hh3cmplsInSegmentAddrFamily, hh3cmplsOutSegmentPerfTable=hh3cmplsOutSegmentPerfTable, hh3cmplsXCUp=hh3cmplsXCUp, PYSNMP_MODULE_ID=hh3cMplsLsr, hh3cmplsInSegmentTable=hh3cmplsInSegmentTable, hh3cmplsInterfaceConfTable=hh3cmplsInterfaceConfTable, hh3cmplsInSegmentPackets=hh3cmplsInSegmentPackets, hh3cmplsLsrModuleCompliance=hh3cmplsLsrModuleCompliance, hh3cmplsLsrNotificationGroup=hh3cmplsLsrNotificationGroup, hh3cmplsInSegmentPerfTable=hh3cmplsInSegmentPerfTable, hh3cmplsOutSegmentTopLabel=hh3cmplsOutSegmentTopLabel, hh3cmplsXCTable=hh3cmplsXCTable, hh3cmplsOutSegmentIfIndex=hh3cmplsOutSegmentIfIndex, hh3cmplsTrafficParamStorageType=hh3cmplsTrafficParamStorageType, hh3cmplsTrafficParamMaxRate=hh3cmplsTrafficParamMaxRate, hh3cmplsInSegmentXCIndex=hh3cmplsInSegmentXCIndex, hh3cmplsLabelStackIndex=hh3cmplsLabelStackIndex, Hh3cMplsBurstSize=Hh3cMplsBurstSize, hh3cmplsOutSegmentPerfDiscontinuityTime=hh3cmplsOutSegmentPerfDiscontinuityTime, hh3cmplsXCLspId=hh3cmplsXCLspId, hh3cmplsHCInSegmentPerfGroup=hh3cmplsHCInSegmentPerfGroup, hh3cmplsInSegmentHCOctets=hh3cmplsInSegmentHCOctets, hh3cmplsInSegmentEntry=hh3cmplsInSegmentEntry, hh3cmplsLsrObjects=hh3cmplsLsrObjects, hh3cmplsOutSegmentPerfEntry=hh3cmplsOutSegmentPerfEntry, hh3cmplsXCEntry=hh3cmplsXCEntry, hh3cmplsInterfaceLabelMaxOut=hh3cmplsInterfaceLabelMaxOut, hh3cmplsXCIndexNext=hh3cmplsXCIndexNext, hh3cmplsLsrGroups=hh3cmplsLsrGroups, hh3cmplsInSegmentLabel=hh3cmplsInSegmentLabel, hh3cmplsXCStorageType=hh3cmplsXCStorageType, hh3cmplsInterfaceLabelParticipationType=hh3cmplsInterfaceLabelParticipationType, hh3cmplsInterfaceLabelMinOut=hh3cmplsInterfaceLabelMinOut, hh3cmplsOutSegmentHCOctets=hh3cmplsOutSegmentHCOctets, hh3cmplsXCIndex=hh3cmplsXCIndex, hh3cmplsOutSegmentIndexNext=hh3cmplsOutSegmentIndexNext, hh3cmplsOutSegmentNextHopIpAddrType=hh3cmplsOutSegmentNextHopIpAddrType, hh3cmplsLabelStackLabel=hh3cmplsLabelStackLabel, hh3cmplsTrafficParamTable=hh3cmplsTrafficParamTable, hh3cmplsLabelStackIndexNext=hh3cmplsLabelStackIndexNext, hh3cmplsInterfaceOutLabelsUsed=hh3cmplsInterfaceOutLabelsUsed, hh3cmplsXCIsPersistent=hh3cmplsXCIsPersistent, hh3cmplsOutSegmentXCIndex=hh3cmplsOutSegmentXCIndex, hh3cmplsInterfaceOutFragments=hh3cmplsInterfaceOutFragments, hh3cmplsInterfaceFailedLabelLookup=hh3cmplsInterfaceFailedLabelLookup, hh3cmplsLabelStackLabelIndex=hh3cmplsLabelStackLabelIndex, hh3cmplsInSegmentTrafficParamPtr=hh3cmplsInSegmentTrafficParamPtr, hh3cmplsTrafficParamMaxBurstSize=hh3cmplsTrafficParamMaxBurstSize, hh3cmplsLsrConformance=hh3cmplsLsrConformance, hh3cmplsXCOperStatus=hh3cmplsXCOperStatus, hh3cmplsLsrCompliances=hh3cmplsLsrCompliances, hh3cmplsOutSegmentOwner=hh3cmplsOutSegmentOwner, hh3cmplsOutSegmentTable=hh3cmplsOutSegmentTable, hh3cmplsHCOutSegmentPerfGroup=hh3cmplsHCOutSegmentPerfGroup, Hh3cMplsLabel=Hh3cMplsLabel, hh3cmplsOutSegmentOctets=hh3cmplsOutSegmentOctets, hh3cmplsOutSegmentStorageType=hh3cmplsOutSegmentStorageType, hh3cmplsTrafficParamRowStatus=hh3cmplsTrafficParamRowStatus, hh3cmplsOutSegmentGroup=hh3cmplsOutSegmentGroup, hh3cmplsLsrNotifications=hh3cmplsLsrNotifications, hh3cmplsPerfGroup=hh3cmplsPerfGroup, hh3cmplsOutSegmentEntry=hh3cmplsOutSegmentEntry, hh3cmplsXCAdminStatus=hh3cmplsXCAdminStatus, hh3cmplsInSegmentStorageType=hh3cmplsInSegmentStorageType, hh3cmplsXCTrapEnable=hh3cmplsXCTrapEnable, hh3cmplsMaxLabelStackDepth=hh3cmplsMaxLabelStackDepth, hh3cmplsInSegmentOctets=hh3cmplsInSegmentOctets, hh3cmplsInSegmentDiscards=hh3cmplsInSegmentDiscards, hh3cmplsXCGroup=hh3cmplsXCGroup, hh3cmplsInterfaceConfIndex=hh3cmplsInterfaceConfIndex, hh3cmplsInterfaceConfEntry=hh3cmplsInterfaceConfEntry, hh3cmplsInterfacePerfEntry=hh3cmplsInterfacePerfEntry, hh3cmplsOutSegmentPackets=hh3cmplsOutSegmentPackets, hh3cmplsXCLabelStackIndex=hh3cmplsXCLabelStackIndex, hh3cmplsSegmentDiscontinuityGroup=hh3cmplsSegmentDiscontinuityGroup, hh3cmplsOutSegmentDiscards=hh3cmplsOutSegmentDiscards, hh3cmplsXCIsNotPersistentGroup=hh3cmplsXCIsNotPersistentGroup, hh3cmplsXCRowStatus=hh3cmplsXCRowStatus, hh3cmplsOutSegmentErrors=hh3cmplsOutSegmentErrors, hh3cmplsInSegmentIfIndex=hh3cmplsInSegmentIfIndex, hh3cmplsOutSegmentPushTopLabel=hh3cmplsOutSegmentPushTopLabel, hh3cmplsInterfaceAvailableBandwidth=hh3cmplsInterfaceAvailableBandwidth, hh3cmplsInSegmentPerfEntry=hh3cmplsInSegmentPerfEntry, hh3cmplsLabelStackRowStatus=hh3cmplsLabelStackRowStatus, hh3cmplsXCOwner=hh3cmplsXCOwner, hh3cmplsInterfaceLabelMinIn=hh3cmplsInterfaceLabelMinIn, hh3cmplsLabelStackEntry=hh3cmplsLabelStackEntry, hh3cmplsLabelStackGroup=hh3cmplsLabelStackGroup, hh3cmplsInterfaceInLabelsUsed=hh3cmplsInterfaceInLabelsUsed)

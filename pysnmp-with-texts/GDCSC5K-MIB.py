#
# PySNMP MIB module GDCSC5K-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCSC5K-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, IpAddress, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, iso, Unsigned32, MibIdentifier, Integer32, TimeTicks, Counter64, Bits, Gauge32, enterprises, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "IpAddress", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "iso", "Unsigned32", "MibIdentifier", "Integer32", "TimeTicks", "Counter64", "Bits", "Gauge32", "enterprises", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
sc = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3))
sc5000 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2))
gdcSc5000Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 1))
gdcSc5000Timing = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 2))
gdcSc5000Shelf = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 3))
gdcSc5000Highways = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 4))
gdcSc5000LTUConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 5))
gdcSc5000Circuit = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 3, 2, 6))
gdcSc5000MIBVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcSc5000MIBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: gdcSc5000MIBVersion.setDescription('The version number of the MIB, to allow products to know which MIB is being supported. The version number will be x.yzT where x is a major revision (1-9), y is a minor revision(0-9), z is a typo revision (0-9) and T indicates the MIB is still a test revision(A-Z). When a release is complete no T should exist.')
gdcSc5000TimingTable = MibTable((1, 3, 6, 1, 4, 1, 498, 3, 2, 2, 1), )
if mibBuilder.loadTexts: gdcSc5000TimingTable.setStatus('obsolete')
if mibBuilder.loadTexts: gdcSc5000TimingTable.setDescription('A table that contains information about the source of shelf timing in the system. ')
gdcSc5000TimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 3, 2, 2, 1, 1), ).setIndexNames((0, "GDCSC5K-MIB", "gdcSc5000TimingIndex"))
if mibBuilder.loadTexts: gdcSc5000TimingEntry.setStatus('obsolete')
if mibBuilder.loadTexts: gdcSc5000TimingEntry.setDescription('A list of information for each node in the system. ')
gdcSc5000TimingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcSc5000TimingIndex.setStatus('obsolete')
if mibBuilder.loadTexts: gdcSc5000TimingIndex.setDescription('The value indicates the node number for which this entry contains management information. The gdcSc5000TimingIndex is based off of the IFindex in MIB-II. The gdcSc5000TimingIndex value is used to indicate the slot, line and drop of the node in the SCM shelf that is being addressed. The index is defined as: ssllddii. where ss is from 1-32, ll is 1,dd is 0 and ii is 0. ')
gdcSc5000SrcShelfTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inhibit", 1), ("fourMegClk", 2), ("eightKiloClk", 3), ("fourMegAnd8kClk", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcSc5000SrcShelfTiming.setStatus('obsolete')
if mibBuilder.loadTexts: gdcSc5000SrcShelfTiming.setDescription('Identifies which unit or units are the source of shelf timing defined as follows: If one unit is defined as fourMegClk(2) then only one other unit may be defined as eightKiloClk(3) and the remaining units must be defined as inhibit(1). If one unit is defined as eightKiloClk(3) then only one other unit may be defined as fourMegClk(2) and the remaining units must be defined as inhibit(1). If one unit is defined as fourMegAnd8kClk(4) then the remaining units must be defined as inhibit(1). ')
sc5000ShelfNodeTypes = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000ShelfNodeTypes.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfNodeTypes.setDescription('Each octet contains the Node Type of the card occupying the slot. Values are as follows: empty 0 vf288 1 sc5001 2 sc5520 3 datx2011 4 sc700G2 6 sc700G3 7 sc616 12 sc702G2 15 sc5034 17 scdualV34 18 sc613 19 sc5553 20 sc611 21 sc710d2 23 sc700grRP 24 sc710d2RP 26 mp7002 29 uas7616 30 scm 31 sc521 32 sc5002 33')
sc5000ShelfAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfAdminStatus.setDescription('Each octet xx contains the Admin Statuses of the Network Elements(NEs) occupying slot xx. Each octet is bitmapped as follows: bit 7:\\ bit 6: Admin Status of NE in slot xx, line 4 bit 5:\\ bit 4: Admin Status of NE in slot xx, line 3 bit 3:\\ bit 2: Admin Status of NE in slot xx, line 2 bit 1:\\ bit 0: Admin Status of NE in slot xx, line 1 Values per pair of bits are: 01 Up 10 Down 00 No NE present')
sc5000ShelfOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000ShelfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfOperStatus.setDescription('Each octet xx contains the Operational Statuses of the Network Elements(NEs) occupying slot xx. Each octet is bitmapped as follows: bit 7:\\ bit 6: Oper Status of NE in slot xx, line 4 bit 5:\\ bit 4: Oper Status of NE in slot xx, line 3 bit 3:\\ bit 2: Oper Status of NE in slot xx, line 2 bit 1:\\ bit 0: Oper Status of NE in slot xx, line 1 Values per pair of bits are: 01 Up 10 Down 00 No NE present')
sc5000ShelfClockProvider = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfClockProvider.setStatus('obsolete')
if mibBuilder.loadTexts: sc5000ShelfClockProvider.setDescription('Octet 1 contains the slot number of the card providing the 4MHz clock. Octet 2 contains the line number of the card providing the 4MHz clock. Octet 3 contains the slot number of the card providing the 8kHz clock. Octet 4 contains the line number of the card providing the 8kHz clock. A value of 0 indicates that no card is providing the clock.')
sc5000ShelfLTUHwayAssgn = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfLTUHwayAssgn.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfLTUHwayAssgn.setDescription('Octet 1 contains the slot number of the LTU responsible for Highway 1. Octet 2 contains the slot number of the LTU responsible for Highway 2. Octet 3 contains the slot number of the LTU responsible for Highway 3. Octet 4 contains the slot number of the LTU responsible for Highway 4. If Highway x does not have an LTU then the value in Octet x is 00.')
sc5000ShelfClockMode = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("fallback", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000ShelfClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfClockMode.setDescription('Indicates which LTU is supplying the clocks, LTU designated as the primary or fallback. none(3) will only occur when the SCM determines that neither of the cards assigned to be the clock provider exists.')
sc5000ShelfClocks = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfClocks.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfClocks.setDescription('Octet 1 contains the slot number of the primary LTU responsible for providing the shelf clock. Octet 2 contains the line number of the primary LTU responsible for providing the shelf clock. Octet 3 contains the primary timing source. Values are internal (1), network (2), external (3), cascade (4), and station (5). Octet 4 contains the slot number of the DSE responsible for providing the external timing source to the primary LTU. Octet 5 contains the line number of the DSE responsible for providing the external timing source to the primary LTU. Octet 6 contains the slot number of the fallback LTU responsible for providing the shelf clock. Octet 7 contains the line number of the fallback LTU responsible for providing the shelf clock. Octet 8 contains the fallback timing source. Values are internal (1), network (2), cascade (4), and station (5).')
sc5000ShelfAutoClockRevert = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfAutoClockRevert.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfAutoClockRevert.setDescription('enable(1) indicates that the SCM will allow the primary LTU to resume providing the system timing.')
sc5000ShelfRevertToPrimaryClk = MibScalar((1, 3, 6, 1, 4, 1, 498, 3, 2, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ShelfRevertToPrimaryClk.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ShelfRevertToPrimaryClk.setDescription('execute(2) forces the primary LTU to resume providing the system timing.')
sc5000HighwayTable = MibTable((1, 3, 6, 1, 4, 1, 498, 3, 2, 4, 1), )
if mibBuilder.loadTexts: sc5000HighwayTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000HighwayTable.setDescription('A table that contains information about Highway and Time Slot allocation.')
sc5000HighwayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 3, 2, 4, 1, 1), ).setIndexNames((0, "GDCSC5K-MIB", "sc5000HighwayNumber"))
if mibBuilder.loadTexts: sc5000HighwayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000HighwayEntry.setDescription('A list of information for each highway.')
sc5000HighwayNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000HighwayNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000HighwayNumber.setDescription('The value indicates the highway to be configured.')
sc5000HighwayAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(96, 96)).setFixedLength(96)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000HighwayAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000HighwayAllocation.setDescription('There are 3 Octets per Time Slot. Octets 1,2,3 are representative of Time Slot 1, Octets 4,5,6 are representative of Time Slot 2, etc. In each grouping, the first octet indicates the shelf slot (1-32) to which the time slot has been assigned. The second octet indicates the line (1-4) to which the time slot has been assigned. The third octet defines the allocation for the time slot. The values are as follows: 1 = available 2 = not available 3 = Private Line (DSE Data) 4 = SN/Restoral (DBU data) If a time slot has not been assigned then the grouping is 00:00:01')
sc5000LTUConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 3, 2, 5, 1), )
if mibBuilder.loadTexts: sc5000LTUConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000LTUConfigTable.setDescription('A table that contains information about the configuration of the LTUs in the shelf.')
sc5000LTUConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 3, 2, 5, 1, 1), ).setIndexNames((0, "GDCSC5K-MIB", "sc5000SlotNumber"))
if mibBuilder.loadTexts: sc5000LTUConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000LTUConfigEntry.setDescription('A list of information for each LTU in the shelf.')
sc5000SlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000SlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000SlotNumber.setDescription('The value indicates shelf slot containing the LTU.')
sc5000DS0Assign = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000DS0Assign.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000DS0Assign.setDescription('One Octet per DS0. Values are as follows: 1 = Highway 2 = Cascade 3 = Busy Out 4 = Not Present')
sc5000ConfigCSUMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("csuMode", 1), ("concentratorMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5000ConfigCSUMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000ConfigCSUMode.setDescription(" 'csuMode' indicates the unit is operating as a T1 channel service unit with the payload from the network interface connected to the payload of the cascade interface. 'concentratorMode' indicates the unit is operating as a T1 channel service unit with the T1 payloads groomed to cross connect within the shelf and the network and cascade interfaces. ")
sc5000CircuitTable = MibTable((1, 3, 6, 1, 4, 1, 498, 3, 2, 6, 1), )
if mibBuilder.loadTexts: sc5000CircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000CircuitTable.setDescription('A table that contains information about sc5000 circuits.')
sc5000CircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 3, 2, 6, 1, 1), ).setIndexNames((0, "GDCSC5K-MIB", "sc5000CircuitIndex"))
if mibBuilder.loadTexts: sc5000CircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000CircuitEntry.setDescription('A list of information for each node in the system.')
sc5000CircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000CircuitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000CircuitIndex.setDescription('Integer value which uniquely identifies the node to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or extension number')
sc5000CircuitType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 3, 2, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("point-to-point", 1), ("multipoint", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5000CircuitType.setStatus('mandatory')
if mibBuilder.loadTexts: sc5000CircuitType.setDescription('This object defines the circuit type.')
mibBuilder.exportSymbols("GDCSC5K-MIB", sc5000CircuitIndex=sc5000CircuitIndex, sc=sc, gdcSc5000Highways=gdcSc5000Highways, gdc=gdc, gdcSc5000TimingIndex=gdcSc5000TimingIndex, sc5000LTUConfigTable=sc5000LTUConfigTable, gdcSc5000LTUConfig=gdcSc5000LTUConfig, sc5000LTUConfigEntry=sc5000LTUConfigEntry, sc5000SlotNumber=sc5000SlotNumber, sc5000HighwayNumber=sc5000HighwayNumber, gdcSc5000TimingTable=gdcSc5000TimingTable, gdcSc5000TimingEntry=gdcSc5000TimingEntry, sc5000ShelfClockMode=sc5000ShelfClockMode, sc5000ShelfAdminStatus=sc5000ShelfAdminStatus, sc5000=sc5000, sc5000ShelfClockProvider=sc5000ShelfClockProvider, sc5000CircuitEntry=sc5000CircuitEntry, gdcSc5000Shelf=gdcSc5000Shelf, gdcSc5000MIBVersion=gdcSc5000MIBVersion, sc5000ShelfClocks=sc5000ShelfClocks, sc5000HighwayAllocation=sc5000HighwayAllocation, gdcSc5000Version=gdcSc5000Version, sc5000CircuitType=sc5000CircuitType, gdcSc5000SrcShelfTiming=gdcSc5000SrcShelfTiming, sc5000HighwayTable=sc5000HighwayTable, gdcSc5000Circuit=gdcSc5000Circuit, sc5000HighwayEntry=sc5000HighwayEntry, sc5000ShelfOperStatus=sc5000ShelfOperStatus, sc5000DS0Assign=sc5000DS0Assign, sc5000ShelfLTUHwayAssgn=sc5000ShelfLTUHwayAssgn, sc5000ShelfNodeTypes=sc5000ShelfNodeTypes, sc5000ShelfRevertToPrimaryClk=sc5000ShelfRevertToPrimaryClk, sc5000CircuitTable=sc5000CircuitTable, sc5000ShelfAutoClockRevert=sc5000ShelfAutoClockRevert, sc5000ConfigCSUMode=sc5000ConfigCSUMode, gdcSc5000Timing=gdcSc5000Timing)

#
# PySNMP MIB module Nortel-Magellan-Passport-PorsTrunksMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-PorsTrunksMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
RowStatus, DisplayString, RowPointer, Unsigned32, Integer32, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "DisplayString", "RowPointer", "Unsigned32", "Integer32", "StorageType")
AsciiString, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "AsciiString", "NonReplicated")
trkIndex, trk = mibBuilder.importSymbols("Nortel-Magellan-Passport-TrunksMIB", "trkIndex", "trk")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Bits, Gauge32, Counter64, Unsigned32, TimeTicks, Counter32, Integer32, ModuleIdentity, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "Gauge32", "Counter64", "Unsigned32", "TimeTicks", "Counter32", "Integer32", "ModuleIdentity", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
porsTrunksMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39))
trkPa = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4))
trkPaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1), )
if mibBuilder.loadTexts: trkPaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRowStatusTable.setDescription('This entry controls the addition and deletion of trkPa components.')
trkPaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"))
if mibBuilder.loadTexts: trkPaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRowStatusEntry.setDescription('A single entry in the table represents a single trkPa component.')
trkPaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkPa components. These components can be added and deleted.')
trkPaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkPaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaStorageType.setDescription('This variable represents the storage type value for the trkPa tables.')
trkPaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: trkPaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaIndex.setDescription('This variable represents the index for the trkPa tables.')
trkPaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10), )
if mibBuilder.loadTexts: trkPaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaProvTable.setDescription('This group contains all provisionable attributes relevant to path oriented traffic on a trunk. These attributes provide the maximum number of Logical Channels that are permitted under a Trunk/n and the maximum total bandwidth they are allowed to occupy as a percentage of the outgoing trunk bandwidth.')
trkPaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"))
if mibBuilder.loadTexts: trkPaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaProvEntry.setDescription('An entry in the trkPaProvTable.')
trkPaMaxLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65435)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaMaxLc.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaMaxLc.setDescription('This attribute indicates the number of Logical Channels (LCh/n) supported on this trunk. This attribute is used to allocate memory on the trunk FP for the PORS forwarding tables.Unless running in mapped mode on ATM hardware, the PathAdmin will add 100 channels to maxLc to reduce the chances of allocation clashes. However, you should never see more than maxLc channels in use for any extended period of time. On ATM hardware in mapped mode the PathAdmin will only add 10 channels to maxLc to permit more efficient use of the available VCC space. The PathAdmin may not be able to honor a request for maxLc channels. This will happen when the neighbor PathAdmin asks for less channels than this PathAdmin. To resolve the conflict the PathAdmin will always pick the minimum of the two maxLc values. This minimum value is called the negotiatedMaxLc and can be viewed as an operational parameter of the PathAdmin. Note that in mapped mode on ATM hardware, the value of this attribute provides an upper bound to the number of VCCs that this Trunk/n PathAdmin can occupy. It is not a guarantee that maxLc VCCs will be available to this PathAdmin because the VCC space is a shared resource on the card or port.')
trkPaMaxReservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaMaxReservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaMaxReservedBwOut.setDescription('This attribute controls the percentage of trunk bandwidth which may be reserved by outgoing path oriented traffic on the trunk. The sum of requiredBandwidth attributes for all paths on this trunk must not exceed this attribute. Setting this attribute to zero (0) prevents paths from being established on this trunk. The limit of reserved bandwidth for incoming path oriented traffic is set using the same attribute on the trunk component on the other end of the trunk.This attribute may be changed without the trunk being restaged. If the value is decreased, calls may be bumped as necessary to free up bandwidth. Increasing the value has no impact on existing calls and new calls are able to use the new bandwidth. If this attribute is set to greater than 100%, connectionless traffic is given a minimum of 1Kbit per second for administrative traffic. A value greater than 100% overbooks the trunk bandwidth. By overbooking bandwidth, more calls are able to be established using the unused bandwidth reserved by idle PLCs.')
trkPaTrunkSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaTrunkSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaTrunkSecurity.setDescription("This attribute indicates the security level of the trunk. Zero(0) represents the most secure trunk and seven(7) represents the least secure. The path's minimum security requirement is indicated by the Plc requiredSecurity attribute, with values identical in range and meaning to this attribute. PORS ensures that the route selected does not contain a trunk whose PathAdmin trunkSecurity attribute is numerically greater than the path's requiredSecurity.")
trkPaSupportedTrafficTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaSupportedTrafficTypes.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaSupportedTrafficTypes.setDescription('This attribute indicates the type of traffic that can be transmitted on the trunk. There are eight(8) possible traffic types, and the trunk can transmit all of them if desired. The voice, data and video traffic types are defined, and five(5) other traffic types can be defined by the network administration. This attribute is used in the route selection process to limit the route to trunks that support the traffic type carried by the path. The requiredTrafficType attribute of the PLC indicates the type of traffic carried on the path. Description of bits: voice(0) data(1) video(2) trafficType1(3) trafficType2(4) trafficType3(5) trafficType4(6) trafficType5(7)')
trkPaTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("terrestrial", 0), ("satellite", 1), ("trunkType1", 2), ("trunkType2", 3), ("trunkType3", 4), ("trunkType4", 5), ("trunkType5", 6), ("trunkType6", 7))).clone('terrestrial')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaTrunkType.setDescription('This attribute lists the type of the trunk. There can be up to eight(8) types of trunks. The terrestrial and satellite trunk types have been defined, leaving six(6) remaining types that can be defined by the network administration. The set of allowed trunk types for a path is indicated in the permittedTrunkType attribute of the PLC. When selecting a route, PORS only chooses trunks whose PathAdmin trunkType are in the permittedTrunkTypes set of the path.')
trkPaCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaCustomerParameter.setDescription('This attribute indicates the customer defined parameter for the trunk. Its value, a number from zero(0) to seven(7), is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary PLC attribute, requiredCustomerParameter, also has a value from zero(0) to seven(7). The Route Selector does not consider trunks whose PathAdmin customerParameter is greater than the requiredCustomerParameter of the path.')
trkPaTrunkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaTrunkCost.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaTrunkCost.setDescription('This attribute is the cost metric for the trunk. This value is assigned by the network administration to represent the network cost of using this trunk. It can be related to distance, speed, dollars, or any other factor that could be taken into consideration. If the trunkAttributeToMinimize is set to trunkCost, PORS finds a route with the smallest sum of the PathAdmin trunkCost attribute over all trunks. The trunk cost can be increased or decreased without disrupting the service to the link. If it is increased and the PORS optimization feature is enabled calls will move off this link to lower cost links when possible. If the cost is decreased new calls will be attracted to this link.')
trkPaOverrideTrunkDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaOverrideTrunkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaOverrideTrunkDelay.setDescription("This attribute specifies the override value of parent trunk's half round trip delay (propagation delay), which is used by the PathAdmin to negotiate the value of negotiatedTrunkDelay. A value of zero indicates that an override value has not been provided, and that the measured propagation delay value is used for negotiation.")
trkPaOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11), )
if mibBuilder.loadTexts: trkPaOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaOperTable.setDescription('This group contains all operational attributes relevant to path oriented and connectionless bandwidth utilization and path activity on a trunk.')
trkPaOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"))
if mibBuilder.loadTexts: trkPaOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaOperEntry.setDescription('An entry in the trkPaOperTable.')
trkPaState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaState.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaState.setDescription('This attribute gives the operational state of the PathAdmin component. The PathAdmin may be up, down, goingDown, staging or downWaitingRestage.')
trkPaUsedLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaUsedLc.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaUsedLc.setDescription('This attribute gives the total number of Logical Channels currently busy on the trunk. When this number reaches maxLc, no more paths are allowed to instantiate through this trunk. Note that it is possible for usedLc to be less than maxLc but for there to be no currently free LogicalChannels. This is because a LogicalChannel can be in one of several intermediate states between free and busy.')
trkPaNegotiatedMaxLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedMaxLc.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedMaxLc.setDescription("This attribute gives the actual value of maxLc that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's maxLc provisionable attributes the smaller of the two is chosen on both sides. This attribute reflects the minimum of these two maxLc's.")
trkPaMaxReservableBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaMaxReservableBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaMaxReservableBwOut.setDescription("This attribute gives the total bandwidth that this PathAdmin is allowed to reserve. This number is computed by multiplying the parent trunk's measuredSpeedToIf attribute by the maxReservedBwOut provisionable attribute of this PathAdmin.")
trkPaOverReservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaOverReservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaOverReservedBwOut.setDescription('When bumping is required to free up enough bandwidth for a new path there exists a short period of time when both the new path and the soon to be bumped path are occupying the same bandwidth. This means that the total amount of reserved bandwidth will exceed maxReservableBwOut. When this happens the unreservedBwOut attribute will be 0 and the overReservedBwOut attribute will be non- zero to indicate by how much we are currently overcommitted. This value should quickly drop back to zero as the bumping starts to clear the lower holdingPriority calls.')
trkPaUnreservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaUnreservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaUnreservedBwOut.setDescription('This attribute gives the total of amount of bandwidth that is still available for reservation by new connections. When this number reaches 0 the PathAdmin will no longer admit new connections to the trunk. This number represents available bandwidth in the outward going direction. To determine the inward available bandwidth you must query the PathAdmin at the other end of this Trunk.')
trkPaClashCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaClashCount.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaClashCount.setDescription('This attribute gives the total number of path setup requests that resulted in an LCh/n or Vcc/x.y clash. A large value for this number is an indicator of poor performance by the PathAdmin in its allocation of LCh/n or Vcc/x.y components. In general the channels will be allocated in opposite orders at each end of the Trunk but this may not always be the case. Note that as the PathAdmin runs out of LCh/n or Vcc/x.y components the number of clashes will increase.')
trkPaNegotiatedSupportedTrafficTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedSupportedTrafficTypes.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedSupportedTrafficTypes.setDescription("This attribute gives the actual value of supportedTrafficTypes that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's supportedTrafficTypes provisionable attributes the union of the two is chosen on both sides. This attribute reflects the union of these two supportedTrafficTypes 's. It is this union that is advertised to all other nodes in the network and which is used for routing decisions. Description of bits: voice(0) data(1) video(2) trafficType1(3) trafficType2(4) trafficType3(5) trafficType4(6) trafficType5(7)")
trkPaNegotiatedTrunkSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedTrunkSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedTrunkSecurity.setDescription("This attribute gives the actual value of the trunkSecurity that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkSecurity provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two trunkSecurity's.")
trkPaNegotiatedCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedCustomerParameter.setDescription("This attribute gives the actual value of customerParameter that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's customerParameter provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two customerParameter's.")
trkPaNegotiatedTrunkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedTrunkCost.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedTrunkCost.setDescription("This attribute gives the actual value of trunkCost that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkCost provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two trunkCost's.")
trkPaNegotiatedAtmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("multiplexing", 0), ("mapping", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedAtmMode.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedAtmMode.setDescription('This attribute gives the actual value of PathAdmin Atm mode that the PathAdmin has decided on after negotiation with the far end PathAdmin. This is only applicable to ATM cards since the mode on non ATM hardware is not specified. The multiplexing mode implies that all voice traffic will be multiplexed onto the Atm atmConnection Vcc and all data will be multiplexed onto the Trunk Atm atmConnection Vcc. The mapping mode implies that each unique logical channel will be allocated its own Vcc. The mode notApplicable implies either this is not ATM hardware or that no Atm subcomponent exists under this or the peer PathAdmin.')
trkPaNegotiatedTrunkDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedTrunkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedTrunkDelay.setDescription("This attribute gives the actual value of parent trunk's half round trip delay (propagation delay) that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmins the larger of the two propagation delays is chosen on both sides. This attribute reflects the maximum of these two propagation delays.")
trkPaNegotiatedTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("terrestrial", 0), ("satellite", 1), ("trunkType1", 2), ("trunkType2", 3), ("trunkType3", 4), ("trunkType4", 5), ("trunkType5", 6), ("trunkType6", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaNegotiatedTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaNegotiatedTrunkType.setDescription("This attribute gives the actual value of trunkType that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkType provisionable attributes the provisioned values are used on both sides. That is, both sides maintain their provisioned value..")
trkPaAdaptationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 11, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaAdaptationLevel.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdaptationLevel.setDescription('This attribute indicates the current PORS adaptation level of the parent trunk. The adaptation mechanism is controlled by Adaptation group, which is used to alleviate the high utilization condition on the parent trunk. 0 - adaptation is not active. 1 - new calls are prevented from being established over the parent trunk. 2 - some connections starting from the lowest holdingPriority attempt to reroute their paths using alternate trunks. 3 - some connections starting from the lowest holdingPriority are bumped away from the parent trunk.')
trkPaAdaptationTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 12), )
if mibBuilder.loadTexts: trkPaAdaptationTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdaptationTable.setDescription('This group of provisionable attributes controls the PORS adaptive routing mechanism. Adaptation is triggered by high trunk utilization, and is used to alleviate the high utilization condition on the parent Trunk/n component. For a Trunk/n with an Unack subcomponent, the link receive utilization (indicated by utilization of Trunk/n) is used for triggering adaptation. For a Trunk/n with an AtmAccess subcomponent, the aggregation of the transmit VCCs utilization (indicated by utilization of Trunk/n), VP utilization, and PORT utilization (normal port or IMA port if Ima is used) is used for triggering adaptation.')
trkPaAdaptationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"))
if mibBuilder.loadTexts: trkPaAdaptationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdaptationEntry.setDescription('An entry in the trkPaAdaptationTable.')
trkPaMaxAdaptationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaMaxAdaptationLevel.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaMaxAdaptationLevel.setDescription('This attribute specifies the maximum adaptation level that the parent trunk can reach. It determines the highest degree of adaptation that can be triggered by high trunk utilization. When the first degree of adaptation is triggered, new calls are prevented from being established over the parent trunk, and the adaptationLevel changes to level one (1). When the second degree of adaptation is triggered, some connections starting from the lowest holdingPriority attempt to reroute their paths using alternate trunks, and the adaptationLevel changes to level two (2). When the third degree of adaptation is triggered, some connections starting from the lowest holdingPriority are bumped away from the parent trunk, and the adaptationLevel changes to level three (3). The configurable values are: 0 - The adapation mechanism is disabled. 1 - Only the first degree of adaptation can be triggered. 2 - Up to two degrees of adaptation can be triggered. 3 - Up to three degrees of adaptation can be triggered. Regardless of its value, the operator command CLEAR -hotSwap or CLEAR (without an option) can always be issued on a particular LCh/n to cause the entire path to be rerouted if possible or bumped.')
trkPaAdaptationBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaAdaptationBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdaptationBandwidth.setDescription('This attribute specifies the amount of bandwidth to be potentially freed up by rerouting connections if possible or freed up by bumping connections on the trunk when the second or third degree of adaptation is triggered. The adaptationBandwidth value is used to determine the number of connections to be rerouted or bumped starting from the lowest holdingPriority, such that the total of the chosen connections reserved outgoing bandwidth requiredTxBandwidth reaches this adaptationBandwidth value. If its value is greater than the maxReservableBwOut of Trunk/n Pa, the maxReservableBwOut amount of bandwidth is used for rerouting or bumping.')
trkPaRbwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 214), )
if mibBuilder.loadTexts: trkPaRbwTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRbwTable.setDescription('This attribute gives the total bandwidth reserved by paths for each of five (5) holding priorities. For example the bandwidth used by holdingPriority 0 paths is shown in the left most value.')
trkPaRbwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 214, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaRbwIndex"))
if mibBuilder.loadTexts: trkPaRbwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRbwEntry.setDescription('An entry in the trkPaRbwTable.')
trkPaRbwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 214, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: trkPaRbwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRbwIndex.setDescription('This variable represents the index for the trkPaRbwTable.')
trkPaRbwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 214, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaRbwValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaRbwValue.setDescription('This variable represents an individual value for the trkPaRbwTable.')
trkPaPacntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 215), )
if mibBuilder.loadTexts: trkPaPacntTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPacntTable.setDescription('This attribute gives the total number of path instantiation attempts this trunk has processed since its creation. This number includes successful and unsuccessful attempts. This attribute provides five (5) values of this count, one for each path holdingPriority.')
trkPaPacntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 215, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaPacntIndex"))
if mibBuilder.loadTexts: trkPaPacntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPacntEntry.setDescription('An entry in the trkPaPacntTable.')
trkPaPacntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 215, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: trkPaPacntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPacntIndex.setDescription('This variable represents the index for the trkPaPacntTable.')
trkPaPacntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 215, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaPacntValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPacntValue.setDescription('This variable represents an individual value for the trkPaPacntTable.')
trkPaPfcntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 216), )
if mibBuilder.loadTexts: trkPaPfcntTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPfcntTable.setDescription('This attribute gives the total number of path instantiation failures that have happened since the creation of this trunk. This attribute provides five (5) values of this count, one for each path holdingPriority.')
trkPaPfcntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 216, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaPfcntIndex"))
if mibBuilder.loadTexts: trkPaPfcntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPfcntEntry.setDescription('An entry in the trkPaPfcntTable.')
trkPaPfcntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 216, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: trkPaPfcntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPfcntIndex.setDescription('This variable represents the index for the trkPaPfcntTable.')
trkPaPfcntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 216, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaPfcntValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPfcntValue.setDescription('This variable represents an individual value for the trkPaPfcntTable.')
trkPaPccntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 217), )
if mibBuilder.loadTexts: trkPaPccntTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPccntTable.setDescription('This attribute gives the total number of path clear requests this trunk has processed since its creation. This attribute provides five (5) values of this count, one for each path holdingPriority.')
trkPaPccntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 217, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaPccntIndex"))
if mibBuilder.loadTexts: trkPaPccntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPccntEntry.setDescription('An entry in the trkPaPccntTable.')
trkPaPccntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 217, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: trkPaPccntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPccntIndex.setDescription('This variable represents the index for the trkPaPccntTable.')
trkPaPccntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 217, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaPccntValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPccntValue.setDescription('This variable represents an individual value for the trkPaPccntTable.')
trkPaPbcntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 218), )
if mibBuilder.loadTexts: trkPaPbcntTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPbcntTable.setDescription('This attribute gives the total number of path bumping requests this trunk has processed since its creation. This attribute provides 5 values of this count, one for each path holdingPriority.')
trkPaPbcntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 218, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaPbcntIndex"))
if mibBuilder.loadTexts: trkPaPbcntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPbcntEntry.setDescription('An entry in the trkPaPbcntTable.')
trkPaPbcntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 218, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: trkPaPbcntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPbcntIndex.setDescription('This variable represents the index for the trkPaPbcntTable.')
trkPaPbcntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 218, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPaPbcntValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaPbcntValue.setDescription('This variable represents an individual value for the trkPaPbcntTable.')
trkPaAdpthTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 653), )
if mibBuilder.loadTexts: trkPaAdpthTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdpthTable.setDescription('This attribute specifies three utilization thresholds used to trigger the three degrees of adaptation. It is a vector indexed by (level1, level2, and level3). While the PORS adaptationLevel is zero (0), - if the trunk utilization has exceeded the level1 value for the period of time specified by the set value of adaptationHoldOffTime, the first degree of adaptation is triggered. Meanwhile, the Trunk/n Pa component generates a SET alarm indicating that the PORS adaptation mechanism is active. The PORS adaptationLevel increases to level one (1). While the PORS adaptationLevel is one (1), - if the trunk utilization has exceeded the level2 value for the period of time specified by the set value of adaptationHoldOffTime, the second degree of adaptation is triggered. The PORS adaptationLevel increases to level two (2). - Otherwise, if the trunk utilization has exceeded the level1 value for an additional period of time specified by the set value of adaptationHoldOffTime, the PORS adaptationLevel remains unchanged. - Otherwise, if the trunk utilization has subsequently fallen back to a level at or below the level1 value for the period of time specified by the clear value of adaptationHoldOffTime, new calls are allowed to be established over the parent trunk. Meanwhile, the Trunk/n Pa component generates a CLEAR alarm indicating that the PORS adaptation mechanism is no longer active. The PORS adaptationLevel decreases to level zero (0). While the PORS adaptationLevel is two (2), - if the trunk utilization has exceeded the level3 value for the period of time specified by the set value of adaptationHoldOffTime, the third degree of adaptation is triggered. The PORS adaptationLevel increases to level three (3). - Otherwise, if the trunk utilization has exceeded the level2 value for an additional period of time specified by the set value of adaptationHoldOffTime, the second degree of adaptation is triggered again, and the PORS adaptationLevel remains unchanged. - Otherwise, if the trunk utilization has subsequently fallen back to a level at or below the level2 value for the period of time specified by the clear value of adaptationHoldOffTime, the PORS adaptationLevel decreases to level one (1). While the PORS adaptationLevel is three (3), - if the trunk utilization has exceeded the level3 value for an additional period of time specified by the set value of adaptationHoldOffTime, the third degree of adaptation is triggered again, and the PORS adaptationLevel remains unchanged. - Otherwise, if the trunk utilization has subsequently fallen back to a level at or below the level3 value for the period of time specified by the clear value of adaptationHoldOffTime, the PORS adaptationLevel decreases to level two (2). For a Trunk/n with an Unack subcomponent, the link receive utilization (indicated by utilization of Trunk/n) is monitored against the thresholds. Since the trunk application solely owns the physical link, the maximum link receive utilization is 100%. The restrictions on the setting of the three thresholds are: - when maxAdaptationLevel is 1, the value of (level1) must be in the range of 0% to 100%. - when maxAdaptationLevel is 2, the values of (level1 and level2) must be the range of 0% to 100%, and the value of level1 must be less than or equal to the value of level2. - when maxAdaptationLevel is 3, the values of (level1, level2, and level3) must be in the range of 0% to 100%, and the value of level1 must be less than or equal to the value of level2, which must be less than or equal to the value of level3. For a Trunk/n with an AtmAccess subcomponent, the aggregation of transmit VCCs utilization (indicated by utilization of Trunk/n), VP utilization, and PORT utilization (normal port or IMA port if Ima is used) is monitored against the thresholds. Since the trunk application shares a physical link with other applications, both the VCCs and VP utilizations can exceed 100%, and the value 200% is chosen as the maximum calculated utilization for VCCs and VP, so all thresholds can take on any value in the range of 0% to 200%. The restrictions on the setting of the three thresholds are: - when maxAdaptationLevel is 2, the value of level1 must be less than or equal to the value of level2. - when maxAdaptationLevel is 3, the value of level1 must be less than or equal to the value of level2, which must be less than or equal to the value of level3.')
trkPaAdpthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 653, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaAdpthIndex"))
if mibBuilder.loadTexts: trkPaAdpthEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdpthEntry.setDescription('An entry in the trkPaAdpthTable.')
trkPaAdpthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 653, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("level1", 0), ("level2", 1), ("level3", 2))))
if mibBuilder.loadTexts: trkPaAdpthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdpthIndex.setDescription('This variable represents the trkPaAdpthTable specific index for the trkPaAdpthTable.')
trkPaAdpthValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 653, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaAdpthValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdpthValue.setDescription('This variable represents an individual value for the trkPaAdpthTable.')
trkPaAdphoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 654), )
if mibBuilder.loadTexts: trkPaAdphoTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdphoTable.setDescription('This attribute specifies two interval times. It is a vector indexed by (set clear). The set value specifies the period of time for which the trunk utilization must be above the utilization threshold specified by adaptationThreshold before the corresponding degree of adaptation is triggered. The clear value specifies the period of time for which the trunk utilization must be at or below the utilization threshold specified by adaptationThreshold before the PORS adaptationLevel is decreased by one (1).')
trkPaAdphoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 654, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkPaAdphoIndex"))
if mibBuilder.loadTexts: trkPaAdphoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdphoEntry.setDescription('An entry in the trkPaAdphoTable.')
trkPaAdphoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 654, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("set", 0), ("clear", 1))))
if mibBuilder.loadTexts: trkPaAdphoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdphoIndex.setDescription('This variable represents the trkPaAdphoTable specific index for the trkPaAdphoTable.')
trkPaAdphoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 4, 654, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkPaAdphoValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPaAdphoValue.setDescription('This variable represents an individual value for the trkPaAdphoTable.')
trkLCh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5))
trkLChRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1), )
if mibBuilder.loadTexts: trkLChRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of trkLCh components.')
trkLChRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkLChIndex"))
if mibBuilder.loadTexts: trkLChRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChRowStatusEntry.setDescription('A single entry in the table represents a single trkLCh component.')
trkLChRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkLCh components. These components cannot be added nor deleted.')
trkLChComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkLChStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChStorageType.setDescription('This variable represents the storage type value for the trkLCh tables.')
trkLChIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: trkLChIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChIndex.setDescription('This variable represents the index for the trkLCh tables.')
trkLChOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10), )
if mibBuilder.loadTexts: trkLChOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all operational attributes pertaining to the Logical Channel component owned by this trunk.')
trkLChOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-PorsTrunksMIB", "trkLChIndex"))
if mibBuilder.loadTexts: trkLChOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChOperEntry.setDescription('An entry in the trkLChOperTable.')
trkLChNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChNextHop.setDescription('The nextHop is the name of the component across the bus which is forwarding packets to us. Inversely the nextHop of our nextHop component is us. More precisely, LCh/n components point to each other across the bus via their nextHop attributes. In the case where the next hop is an application the nextHop attribute will indicate the component name of this application.')
trkLChSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChSetupPriority.setDescription("This attribute gives the priority at which a path is established. Zero (0) is the highest priority and four (4) is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (or numerically less) than the existing path's holdingPriority.")
trkLChHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChHoldingPriority.setDescription("This attribute gives the priority that a path holds once it is established. Zero (0) is the highest priority and four (4) is the lowest. A path's holdingPriority determines its likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (or numerically less) than the existing path's holdingPriority.")
trkLChEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChEmissionPriority.setDescription("This attribute indicates the urgency with which packets on the LCh's path are emitted by this trunk. The emissionPriority translates into the trunk's emission queue. Zero (0) indicates the highest emissionPriority, while three (3) indicates the lowest. Packets with a higher emissionPriority (or numerically less) are put on an emission queue which is serviced before a queue which accepts packets of a lower emissionPriority and hence experience smaller delays traversing congested trunks.")
trkLChDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path. Zero (0) is used for paths carrying the most important traffic, and two (3) is used for paths carrying the least important traffic. In times of congestion, the discardPriority is used by packet forwarding on the trunk to determine which packets are discarded first to reduce the load. Packets with a higher discardPriority (or numerically less) are discarded after packets with a lower discardPriority (or numerically higher).')
trkLChRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChRequiredTxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second units) reserved by this LCh/n for emitting packets on the trunk.')
trkLChRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChRequiredRxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second units) reserved by this LCh/n for receiving packets on the trunk.')
trkLChMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("hdlcFrmMux", 1), ("aal5FrmMux", 2), ("spoFrmMux", 3), ("spoFrmMap", 4), ("aal5FrmMap", 5), ("cellMap", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChMode.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChMode.setDescription('This attribute gives the operational mode of the LogicalChannel component. It indicates what kind of transport is being performed on the packets in the channel. There are 7 possible values of this attribute as follows: unknown - not currently in busy state, type of forwarding not determined yet. hdlcFrmMux - frames are being multiplexed (multiple LCh/n on same port or channel) using HDLC encapsulation. aal5FrmMux - frames are being multiplexed (multiple LCh/n on same ATM VCC) using the AAL5 segmentation and recombination protocol. spoFrmMux - frames are being multiplexed (multiple LCh/n on same ATM VCC) using the Short Path Oriented segmentation and recombination protocol. This is a proprietary protocol which encapsulates voice frames into a single ATM cell unlike AAL5 which would require two cells to transport the 45 byte voice frames. aal5FrmMap - frames are being mapped (a single LCh/n per ATM VCC) using the AAL5 segmentation and recombination protocol. AAL5 mapped frames are forwarded by hardware in both directions and require no CPU intervention. spoFrmMap - frames are being mapped (a single LCh/n per ATM VCC) using the Short Path Oriented segmentation and recombination protocol. SPO mapped frames are forwarded by hardware in both directions and require no CPU intervention in all but one special case. In particular CPU is required only if frames are being forwarded to an LCh/n whose mode is spoFrmMux. cellMap - ATM cells are being relayed directly over the bus with no segmentation and recombination protocol. The segmentation and recombination is only done at transition points between frame based cards and ATM cell based cards so this hop represents a pure tandem cell hop, ATM card to ATM card. No CPU is required to process these cells.')
trkLChMaximumTransmissionUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChMaximumTransmissionUnit.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChMaximumTransmissionUnit.setDescription('This attribute gives the size of the largest frame this service will send. A value of 0 means that the Mtu is unknown. A value of 45 or less (but non zero) means that ATM single cell transport will be used wherever possible. Otherwise ATM AAL5 adaption layer transport will be required to handle all frames.')
trkLChLocalConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 5, 10, 1, 11), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkLChLocalConnection.setStatus('mandatory')
if mibBuilder.loadTexts: trkLChLocalConnection.setDescription('The localConnection attribute specifies the name of the connection on the local interface. On ATM hardware this is in the form AtmIf/n Vcc/x.y. On non ATM hardware this attribute is empty.')
porsTrunksGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 1))
porsTrunksGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 1, 5))
porsTrunksGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 1, 5, 1))
porsTrunksGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 1, 5, 1, 2))
porsTrunksCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 3))
porsTrunksCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 3, 5))
porsTrunksCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 3, 5, 1))
porsTrunksCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 39, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-PorsTrunksMIB", trkLChMode=trkLChMode, trkPaOperEntry=trkPaOperEntry, trkLChIndex=trkLChIndex, trkPaAdaptationTable=trkPaAdaptationTable, porsTrunksCapabilitiesBE=porsTrunksCapabilitiesBE, trkPaRowStatusTable=trkPaRowStatusTable, trkPaRbwTable=trkPaRbwTable, trkPaPccntEntry=trkPaPccntEntry, trkPaPbcntTable=trkPaPbcntTable, trkLChEmissionPriority=trkLChEmissionPriority, trkPaAdphoValue=trkPaAdphoValue, trkPaPacntValue=trkPaPacntValue, trkPaPbcntValue=trkPaPbcntValue, trkLCh=trkLCh, trkLChOperTable=trkLChOperTable, trkPaIndex=trkPaIndex, trkPaMaxReservableBwOut=trkPaMaxReservableBwOut, trkPaNegotiatedAtmMode=trkPaNegotiatedAtmMode, trkPaNegotiatedTrunkType=trkPaNegotiatedTrunkType, trkPaUnreservedBwOut=trkPaUnreservedBwOut, trkLChOperEntry=trkLChOperEntry, trkPaAdpthTable=trkPaAdpthTable, trkLChRowStatusEntry=trkLChRowStatusEntry, trkPaNegotiatedCustomerParameter=trkPaNegotiatedCustomerParameter, porsTrunksGroupBE00A=porsTrunksGroupBE00A, trkPaCustomerParameter=trkPaCustomerParameter, trkPaProvTable=trkPaProvTable, trkLChRequiredTxBandwidth=trkLChRequiredTxBandwidth, porsTrunksMIB=porsTrunksMIB, trkPaAdpthEntry=trkPaAdpthEntry, trkPaAdpthValue=trkPaAdpthValue, trkLChStorageType=trkLChStorageType, trkPaRowStatusEntry=trkPaRowStatusEntry, trkPaOverReservedBwOut=trkPaOverReservedBwOut, trkLChLocalConnection=trkLChLocalConnection, trkLChRowStatusTable=trkLChRowStatusTable, trkPaMaxLc=trkPaMaxLc, trkPaOverrideTrunkDelay=trkPaOverrideTrunkDelay, trkPaRbwValue=trkPaRbwValue, trkPaPbcntEntry=trkPaPbcntEntry, trkPaPfcntValue=trkPaPfcntValue, trkPaOperTable=trkPaOperTable, trkPaComponentName=trkPaComponentName, trkPaRowStatus=trkPaRowStatus, porsTrunksCapabilitiesBE00=porsTrunksCapabilitiesBE00, trkPa=trkPa, porsTrunksCapabilities=porsTrunksCapabilities, trkPaAdaptationLevel=trkPaAdaptationLevel, trkPaAdpthIndex=trkPaAdpthIndex, trkPaPacntEntry=trkPaPacntEntry, trkPaPccntTable=trkPaPccntTable, trkPaAdphoEntry=trkPaAdphoEntry, trkPaPacntTable=trkPaPacntTable, trkPaAdphoTable=trkPaAdphoTable, trkLChRowStatus=trkLChRowStatus, trkLChComponentName=trkLChComponentName, trkPaAdphoIndex=trkPaAdphoIndex, trkPaTrunkType=trkPaTrunkType, trkPaPfcntEntry=trkPaPfcntEntry, trkPaNegotiatedMaxLc=trkPaNegotiatedMaxLc, trkPaUsedLc=trkPaUsedLc, trkPaPccntIndex=trkPaPccntIndex, porsTrunksCapabilitiesBE00A=porsTrunksCapabilitiesBE00A, trkPaNegotiatedTrunkDelay=trkPaNegotiatedTrunkDelay, trkPaPfcntTable=trkPaPfcntTable, trkPaSupportedTrafficTypes=trkPaSupportedTrafficTypes, trkPaProvEntry=trkPaProvEntry, trkPaStorageType=trkPaStorageType, trkPaTrunkCost=trkPaTrunkCost, trkPaRbwIndex=trkPaRbwIndex, trkLChSetupPriority=trkLChSetupPriority, trkPaNegotiatedTrunkSecurity=trkPaNegotiatedTrunkSecurity, trkPaState=trkPaState, trkPaPbcntIndex=trkPaPbcntIndex, porsTrunksGroupBE00=porsTrunksGroupBE00, trkLChRequiredRxBandwidth=trkLChRequiredRxBandwidth, trkLChHoldingPriority=trkLChHoldingPriority, trkPaNegotiatedTrunkCost=trkPaNegotiatedTrunkCost, trkLChMaximumTransmissionUnit=trkLChMaximumTransmissionUnit, trkPaMaxAdaptationLevel=trkPaMaxAdaptationLevel, trkLChDiscardPriority=trkLChDiscardPriority, trkLChNextHop=trkLChNextHop, porsTrunksGroupBE=porsTrunksGroupBE, trkPaAdaptationEntry=trkPaAdaptationEntry, trkPaPacntIndex=trkPaPacntIndex, trkPaRbwEntry=trkPaRbwEntry, trkPaTrunkSecurity=trkPaTrunkSecurity, trkPaAdaptationBandwidth=trkPaAdaptationBandwidth, trkPaMaxReservedBwOut=trkPaMaxReservedBwOut, trkPaPfcntIndex=trkPaPfcntIndex, trkPaPccntValue=trkPaPccntValue, porsTrunksGroup=porsTrunksGroup, trkPaNegotiatedSupportedTrafficTypes=trkPaNegotiatedSupportedTrafficTypes, trkPaClashCount=trkPaClashCount)

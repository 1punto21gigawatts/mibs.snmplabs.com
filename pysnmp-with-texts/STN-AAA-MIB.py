#
# PySNMP MIB module STN-AAA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/STN-AAA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:11:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Gauge32, iso, TimeTicks, Bits, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, Counter64, ObjectIdentity, MibIdentifier, Integer32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "iso", "TimeTicks", "Bits", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "Counter64", "ObjectIdentity", "MibIdentifier", "Integer32", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
stnNotification, stnSystems = mibBuilder.importSymbols("SPRING-TIDE-NETWORKS-SMI", "stnNotification", "stnSystems")
stnEngineIndex, stnEngineSlot, stnEngineCpu = mibBuilder.importSymbols("STN-CHASSIS-MIB", "stnEngineIndex", "stnEngineSlot", "stnEngineCpu")
stnRouterIndex, = mibBuilder.importSymbols("STN-ROUTER-MIB", "stnRouterIndex")
stnAAA = ModuleIdentity((1, 3, 6, 1, 4, 1, 3551, 2, 10))
if mibBuilder.loadTexts: stnAAA.setLastUpdated('0002160000Z')
if mibBuilder.loadTexts: stnAAA.setOrganization('Spring Tide Networks, Inc.')
if mibBuilder.loadTexts: stnAAA.setContactInfo(' Spring Tide Networks, Inc. Customer Service Postal: 3 Clock Tower Place Maynard, MA 01754 Tel: 1 888-786-4357 Email: stncs@springtidenet.com ')
if mibBuilder.loadTexts: stnAAA.setDescription('The MIB module that describes managed objects of Spring Tide Networks Authentication, Authorization and Accounting functionality')
stnAAAObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1))
stnAAAMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 2))
stnAAATrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 3))
stnAAAConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1))
stnAAAStats = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 2))
stnStackingRuleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 1))
stnNetworkAccessGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4))
stnDefaultPppUserGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8))
stnNoAuthPppUserGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 9))
stnStackingRuleProtocol = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("ppp", 2))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnStackingRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: stnStackingRuleProtocol.setDescription('The rule comparison protocol. Users using this protocol will use the TunnelType and TunnelEndpoint fields')
stnStackingRuleTunnelType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("none", 1), ("pptp", 2), ("l2tp", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnStackingRuleTunnelType.setStatus('current')
if mibBuilder.loadTexts: stnStackingRuleTunnelType.setDescription('The tunneling action the connection will take if the rule comparison protocol is matched.')
stnStackingRuleTunnelEndPoint = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnStackingRuleTunnelEndPoint.setStatus('current')
if mibBuilder.loadTexts: stnStackingRuleTunnelEndPoint.setDescription('The name of server endpoint that we will TunnelType to when the rule comparison protocol is matched.')
stnEndPointTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2), )
if mibBuilder.loadTexts: stnEndPointTable.setStatus('current')
if mibBuilder.loadTexts: stnEndPointTable.setDescription('The Endpoint Table.')
stnEndPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnEndPointIndex"))
if mibBuilder.loadTexts: stnEndPointEntry.setStatus('current')
if mibBuilder.loadTexts: stnEndPointEntry.setDescription('An Server Endpoint entry. An entry in this table corresponds to a single PPP or tunnelling endpoint entity')
stnEndPointIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnEndPointIndex.setStatus('current')
if mibBuilder.loadTexts: stnEndPointIndex.setDescription('The configuration instance of this endpoint.')
stnEndPointIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnEndPointIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnEndPointIpAddress.setDescription('IP address of this endpoint.')
stnEndPointName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnEndPointName.setStatus('current')
if mibBuilder.loadTexts: stnEndPointName.setDescription('The name of server endpoint - if no address is configured then this name will be used for a DNS lookup')
stnEndPointPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnEndPointPassword.setStatus('current')
if mibBuilder.loadTexts: stnEndPointPassword.setDescription('The challenge password or shared secret for this endpoint.')
stnAddressPoolTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 3), )
if mibBuilder.loadTexts: stnAddressPoolTable.setStatus('current')
if mibBuilder.loadTexts: stnAddressPoolTable.setDescription('The Address Pool Table.')
stnAddressPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 3, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnAddressPoolIndex"))
if mibBuilder.loadTexts: stnAddressPoolEntry.setStatus('current')
if mibBuilder.loadTexts: stnAddressPoolEntry.setDescription('An Address Pool entry. An entry in this table corresponds to an address range - all of the entries in this table make up a single address pool for the router')
stnAddressPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: stnAddressPoolIndex.setStatus('current')
if mibBuilder.loadTexts: stnAddressPoolIndex.setDescription('The priority of each range')
stnStartIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnStartIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnStartIpAddress.setDescription('The starting IP address of the address range')
stnEndIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnEndIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnEndIpAddress.setDescription('The ending IP address of the address range')
stnNetworkAccessUserAuthenType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 1), Bits().clone(namedValues=NamedValues(("none", 0), ("internal", 1), ("radius", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessUserAuthenType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessUserAuthenType.setDescription('The type of authentication that will be performed for all users using the router - only one user authentication type may be specified at a time')
stnNetworkAccessEndPointAuthenType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 2), Bits().clone(namedValues=NamedValues(("none", 0), ("internal", 1), ("radius", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessEndPointAuthenType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessEndPointAuthenType.setDescription('The type of authentication that will be performed for all endpoints using the router - only one endpoint authentication type may be specified at a time')
stnNetworkAccessUserAccType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 3), Bits().clone(namedValues=NamedValues(("none", 0), ("internal", 1), ("radius", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessUserAccType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessUserAccType.setDescription('The type of accounting that will be performed for all users using the router - more than one user authentication may be specified at a time')
stnNetworkAccessEndPointAccType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 4), Bits().clone(namedValues=NamedValues(("none", 0), ("internal", 1), ("radius", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessEndPointAccType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessEndPointAccType.setDescription('The type of accounting that will be performed for all endpoints using the router - more than one endpoint authentication may be specified at a time')
stnNetworkAccessDomainName = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessDomainName.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessDomainName.setDescription("The domain name configured for the router - this domain name is used primarily for PPPOE when no router can be determined from the connection type - a username parse will occur attempting to match this domain name with a string located after an '@' sign in the user name ex: john@springtidenetworks.com")
stnNetworkAccessServiceNameRadiusAttrType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("servicename", 1), ("filterid", 2), ("class", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessServiceNameRadiusAttrType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessServiceNameRadiusAttrType.setDescription('The type of RADIUS attribute that will be used to carry the service name for a user if applicable')
stnNetworkAccessLdapAuthorizationUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessLdapAuthorizationUpdateTime.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessLdapAuthorizationUpdateTime.setDescription('The amount of time between LDAP updates for this router in seconds')
stnNetworkAccessLdapUpdateNotification = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stnNetworkAccessLdapUpdateNotification.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessLdapUpdateNotification.setDescription('LDAP service update notification from network management apps.')
stnNetworkAccessRealmAttrType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("springTide-ST-Realm-Name", 0), ("cisco-Avpair", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNetworkAccessRealmAttrType.setStatus('current')
if mibBuilder.loadTexts: stnNetworkAccessRealmAttrType.setDescription('The type of RADIUS attribute that will be used to specify the realm name for a user if applicable')
stnRadiusAccServerTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5), )
if mibBuilder.loadTexts: stnRadiusAccServerTable.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerTable.setDescription('The Radius Accounting Server Table.')
stnRadiusAccServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnRadiusAccServerIndex"))
if mibBuilder.loadTexts: stnRadiusAccServerEntry.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerEntry.setDescription('An Radius Accounting Server entry. An entry in this table corresponds to a single radius accounting server entry')
stnRadiusAccServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: stnRadiusAccServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerIndex.setDescription('The priority of this accounting server - higher priority servers will attempt to be contacted before lower priority servers - highest priority is 1 - priority indexes must be contiguous')
stnRadiusAccServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerAddress.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerAddress.setDescription('The IP address of this Radius accounting server.')
stnRadiusAccServerDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerDestPort.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerDestPort.setDescription('The destination accounting port of this Radius accounting server.')
stnRadiusAccServerRetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 4), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerRetrans.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerRetrans.setDescription('The number of times the router will attempt to retransmit to this server if there is no response')
stnRadiusAccServerTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 5), Integer32().clone(60)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerTimeOut.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerTimeOut.setDescription('The time in seconds to determine the last (re)transmission to this server failed.')
stnRadiusAccServerSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnRadiusAccServerSecret.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerSecret.setDescription('The shared secret configured for this Radius accounting server - this secret must also be configured on the RADIUS server itself')
stnRadiusAccServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerName.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerName.setDescription('The name of this Radius accounting server - this name will be used for a DNS lookup if an ip address is not configured')
stnRadiusAccServerConfigInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAccServerConfigInstance.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAccServerConfigInstance.setDescription('The configuration instance of this accounting server')
stnRadiusAuthServerTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6), )
if mibBuilder.loadTexts: stnRadiusAuthServerTable.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerTable.setDescription('The Radius Authentication Server table.')
stnRadiusAuthServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnRadiusAuthServerIndex"))
if mibBuilder.loadTexts: stnRadiusAuthServerEntry.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerEntry.setDescription('An Radius authentication server entry. An entry in this table corresponds to a single radius authentication server entry')
stnRadiusAuthServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: stnRadiusAuthServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerIndex.setDescription('The priority of this Radius authentication server - highest priority is 1 and higher priority servers will be contacted first - the priorities must be contiguous')
stnRadiusAuthServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerAddress.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerAddress.setDescription('The IP address of this Radius authentication server.')
stnRadiusAuthServerDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerDestPort.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerDestPort.setDescription('The destination authenticaton port of this Radius authentication server.')
stnRadiusAuthServerRetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 4), Integer32().clone(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerRetrans.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerRetrans.setDescription('The number of times the router will attempt to retransmit to this radius authentication server')
stnRadiusAuthServerTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 5), Integer32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerTimeOut.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerTimeOut.setDescription('The time (in seconds) to determine the last (re)transmission to this authentication server failed.')
stnRadiusAuthServerSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnRadiusAuthServerSecret.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerSecret.setDescription('The shared secret configured for this Radius authentication server - this same secret must be configured on the RADIUS server itself')
stnRadiusAuthServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerName.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerName.setDescription('The name of this Radius authentication server - this name will be used for a DNS lookup if no ip address is configured')
stnRadiusAuthServerConfigInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRadiusAuthServerConfigInstance.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthServerConfigInstance.setDescription('The configuration instance of this Radius authentication server')
stnUserTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7), )
if mibBuilder.loadTexts: stnUserTable.setStatus('current')
if mibBuilder.loadTexts: stnUserTable.setDescription('The User Table.')
stnUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnUserIndex"))
if mibBuilder.loadTexts: stnUserEntry.setStatus('current')
if mibBuilder.loadTexts: stnUserEntry.setDescription('An User entry. An entry in this table corresponds to a single user entry')
stnUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIndex.setStatus('current')
if mibBuilder.loadTexts: stnUserIndex.setDescription('The configuration instance of this entry.')
stnUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserName.setStatus('current')
if mibBuilder.loadTexts: stnUserName.setDescription('The user name for this user table entry')
stnUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnUserPassword.setStatus('current')
if mibBuilder.loadTexts: stnUserPassword.setDescription('The password of this user.')
stnUserIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnUserIpAddress.setDescription('The IP address for user sessions created for this user - 255.255.255.254 picks an address from the address pool table and 0 or 255.255.255.255 allows the user to pick the address.')
stnUserIpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpNetMask.setStatus('current')
if mibBuilder.loadTexts: stnUserIpNetMask.setDescription('The IP sub-network mask for sessions created for this user.')
stnUserIpRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unset", 0), ("none", 1), ("send", 2), ("listen", 3), ("both", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouting.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouting.setDescription('The routing method for this user session.')
stnUserMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 65532)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserMTU.setStatus('current')
if mibBuilder.loadTexts: stnUserMTU.setDescription('The maximum transmission unit used by the framed protocol that this user is configured for.')
stnUserIpCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("vj", 2))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpCompression.setStatus('current')
if mibBuilder.loadTexts: stnUserIpCompression.setDescription('The compression type for sessions created for this user.')
stnUserTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserTimeOut.setStatus('current')
if mibBuilder.loadTexts: stnUserTimeOut.setDescription('The total amount of time a session should be allowed to stay connected. A value of 0 indicates no timeout')
stnUserIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIdleTime.setStatus('current')
if mibBuilder.loadTexts: stnUserIdleTime.setDescription('The total amount of time a session should be allowed to stay connected when idle. A value of 0 indicates no timeout')
stnUserTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("unset", 0), ("none", 1), ("pptp", 2), ("l2tp", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserTunnelType.setStatus('current')
if mibBuilder.loadTexts: stnUserTunnelType.setDescription('The type of tunnel that should be used for compulsory tunneling - none indicates that this user should be given a strictly PPP session')
stnUserTunnelServerEndPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserTunnelServerEndPoint.setStatus('current')
if mibBuilder.loadTexts: stnUserTunnelServerEndPoint.setDescription('The name of the tunnel server endpoint to be used when a valid tunnel type is configured')
stnUserTunnelClientEndPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserTunnelClientEndPoint.setStatus('current')
if mibBuilder.loadTexts: stnUserTunnelClientEndPoint.setDescription('The name of the tunnel client endpoint to be used when a valid tunnel type is configured')
stnUserAssignedTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserAssignedTunnelName.setStatus('current')
if mibBuilder.loadTexts: stnUserAssignedTunnelName.setDescription('The name of the tunnel initiator to which a session is to be assigned - this variable allows for a grouping mechanism of tunnel sessions')
stnUserTunnelPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnUserTunnelPassword.setStatus('current')
if mibBuilder.loadTexts: stnUserTunnelPassword.setDescription('The shared secret used for this tunnel session when a valid tunnel type is configured')
stnUserServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 101))).clone(namedValues=NamedValues(("unset", 0), ("login", 1), ("framed", 2), ("administrative", 6), ("provisioner", 101))).clone('framed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserServiceType.setStatus('current')
if mibBuilder.loadTexts: stnUserServiceType.setDescription('The permission level of the user - framed indicates a PPP user and possibly a tunnel user, login indicates a telnet or serial user with read-only allowances, provisioner indicates a telnet or serial user with read-only allowances as well as write privileges for the specific router they are configured on, administrative indicates a telent or serial user with read-only allowances as well as write priveleges for all routers')
stnUserIpFilters = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilters.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilters.setDescription('The list of IP filters that this user entry will be using for its sessions - every four bytes of the octet string contain a 32 bit filter configuration instance')
stnUserIpRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRoutes.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRoutes.setDescription('The list of IP routes for this user - every four bytes of the octet string contain a 32 bit route configuration instance')
stnUserPrimaryDNSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserPrimaryDNSServer.setStatus('current')
if mibBuilder.loadTexts: stnUserPrimaryDNSServer.setDescription('The IP address of the primary DNS server')
stnUserSecondaryDNSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 20), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserSecondaryDNSServer.setStatus('current')
if mibBuilder.loadTexts: stnUserSecondaryDNSServer.setDescription('The IP address of the secondary DNS server')
stnUserPrimaryNBNSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 21), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserPrimaryNBNSServer.setStatus('current')
if mibBuilder.loadTexts: stnUserPrimaryNBNSServer.setDescription('The IP address of the primary NBNS server')
stnUserSecondaryNBNSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 22), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserSecondaryNBNSServer.setStatus('current')
if mibBuilder.loadTexts: stnUserSecondaryNBNSServer.setDescription('The IP address of the secondary NBNS server')
stnUserServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserServiceName.setStatus('current')
if mibBuilder.loadTexts: stnUserServiceName.setDescription('The name indicating the service level for this user - the correlating service and policies for the service may be configured either locally or on an LDAP server')
stnUserPhysicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserPhysicalPort.setStatus('current')
if mibBuilder.loadTexts: stnUserPhysicalPort.setDescription('The physical port this user is allowed to connect to')
stnUserPhysicalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserPhysicalSlot.setStatus('current')
if mibBuilder.loadTexts: stnUserPhysicalSlot.setDescription('The physical slot this user is allowed to connect to')
stnUserVirtualPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserVirtualPathId.setStatus('current')
if mibBuilder.loadTexts: stnUserVirtualPathId.setDescription('The virtual path identifier that this user is allowed to use')
stnUserVirtualCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserVirtualCircuitId.setStatus('current')
if mibBuilder.loadTexts: stnUserVirtualCircuitId.setDescription('The virtual circuit identifier that this user is allowed to use')
stnUserRealmInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 7, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserRealmInstance.setStatus('current')
if mibBuilder.loadTexts: stnUserRealmInstance.setDescription('The instance of this users Realm record')
stnDefaultUserIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIpAddress.setDescription('The IP address for the default PPP user session.')
stnDefaultUserIpNetMask = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpNetMask.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIpNetMask.setDescription('The IP sub-network mask that the PPP default user will use.')
stnDefaultUserIpRouting = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("send", 2), ("listen", 3), ("both", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpRouting.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIpRouting.setDescription('The routing method for the PPP default user')
stnDefaultUserMTU = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 65532)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserMTU.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserMTU.setDescription('The maximum transmission unit used by the framed protocol that the PPP default user is configured for.')
stnDefaultUserIpCompression = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("vj", 2))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpCompression.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIpCompression.setDescription('The compression type for the PPP default user')
stnDefaultUserTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserTimeOut.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserTimeOut.setDescription('The total amount of time the default PPP user should be allowed to stay connected. A value of 0 indicates no timeout')
stnDefaultUserIdleTime = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIdleTime.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIdleTime.setDescription('The total amount of time the PPP default user should be allowed to stay connected when idle. A value of 0 indicates no timeout')
stnDefaultUserTunnelType = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("none", 1), ("pptp", 2), ("l2tp", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserTunnelType.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserTunnelType.setDescription('The type of tunnel that should be used for compulsory tunneling for the PPP default user - if none is indicated then PPP termination with no tunneling occurs')
stnDefaultUserTunnelServerEndPoint = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserTunnelServerEndPoint.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserTunnelServerEndPoint.setDescription('The name of the tunnel server endpoint for the PPP default user to be used if a valid tunnel type is configured for the tunnel type')
stnDefaultUserTunnelClientEndPoint = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserTunnelClientEndPoint.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserTunnelClientEndPoint.setDescription('The name of the tunnel client endpoint for the PPP default user to be used if a valid tunnel type is configured for the tunnel type')
stnDefaultUserIpFilters = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpFilters.setStatus('obsolete')
if mibBuilder.loadTexts: stnDefaultUserIpFilters.setDescription('The list of IP filters for the PPP default user - each 32 bits of the octet string specifies a filter file configuration instance')
stnDefaultUserIpRoutes = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserIpRoutes.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserIpRoutes.setDescription('The list of IP routes for the PPP default user - each 32 bits of the octet string specifies a route configuration instance')
stnDefaultUserPrimaryDNSServer = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserPrimaryDNSServer.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserPrimaryDNSServer.setDescription('The IP address of the primary DNS server')
stnDefaultUserSecondaryDNSServer = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserSecondaryDNSServer.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserSecondaryDNSServer.setDescription('The IP address of the secondary DNS server')
stnDefaultUserPrimaryNBNSServer = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserPrimaryNBNSServer.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserPrimaryNBNSServer.setDescription('The IP address of the primary NBNS server')
stnDefaultUserSecondaryNBNSServer = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserSecondaryNBNSServer.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserSecondaryNBNSServer.setDescription('The IP address of the secondary NBNS server')
stnDefaultUserServiceName = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 8, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnDefaultUserServiceName.setStatus('current')
if mibBuilder.loadTexts: stnDefaultUserServiceName.setDescription('The name indicating the service level for this default user - the correlating service and policies for the service may be configured either locally or on an LDAP server')
stnNoAuthPppUserName = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 9, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNoAuthPppUserName.setStatus('current')
if mibBuilder.loadTexts: stnNoAuthPppUserName.setDescription('The name of this no-authentication PPP user.')
stnNoAuthPppUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 9, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnNoAuthPppUserPassword.setStatus('current')
if mibBuilder.loadTexts: stnNoAuthPppUserPassword.setDescription('The password of this no-authentication PPP user.')
stnUserIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 10), )
if mibBuilder.loadTexts: stnUserIpFilterTable.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterTable.setDescription('The IP Filter table.')
stnUserIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 10, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnUserIpFilterIndex"))
if mibBuilder.loadTexts: stnUserIpFilterEntry.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterEntry.setDescription('An User IP filter entry. An entry in this table corresponds to a single filter file')
stnUserIpFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterIndex.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterIndex.setDescription('The configuration instance of this IP filter file')
stnUserIpFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterName.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterName.setDescription('The name of this IP filter file.')
stnUserIpFilterRules = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRules.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRules.setDescription('A list of the IP Filter Rules that this filter file contains - each 32 bits of the octet string contains a filter rule configuration instance')
stnUserIpFilterRuleTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11), )
if mibBuilder.loadTexts: stnUserIpFilterRuleTable.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleTable.setDescription('The User IP filte rule table.')
stnUserIpFilterRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnUserIpFilterRuleIndex"))
if mibBuilder.loadTexts: stnUserIpFilterRuleEntry.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleEntry.setDescription('An User IP filter rule entry. An entry in this table corresponds to a single IP filter rule entry')
stnUserIpFilterRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleIndex.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleIndex.setDescription('The configuration instance of this IP filter rule')
stnUserIpFilterRuleSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcAddress.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcAddress.setDescription('The filter rule comparison source IP address.')
stnUserIpFilterRuleSrcNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcNetMask.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcNetMask.setDescription('The filter rule comparison source IP sub-network mask.')
stnUserIpFilterRuleSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcPort.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleSrcPort.setDescription('The filter rule comparison source port.')
stnUserIpFilterRuleDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleDestAddress.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleDestAddress.setDescription('The filter rule comparison destination IP address.')
stnUserIpFilterRuleDestNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleDestNetMask.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleDestNetMask.setDescription('The filter rule comparison destination IP sub-network mask.')
stnUserIpFilterRuleDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleDestPort.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleDestPort.setDescription('The filter rule comparison destination port.')
stnUserIpFilterRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleProtocol.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleProtocol.setDescription('The filter rule comparison protocol.')
stnUserIpFilterRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleAction.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleAction.setDescription('The action we should take if a match occurs to the specified comparisons above')
stnUserIpFilterRuleEndPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 11, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpFilterRuleEndPoint.setStatus('obsolete')
if mibBuilder.loadTexts: stnUserIpFilterRuleEndPoint.setDescription('The name of endpoint we will use for the action if appropriate')
stnUserIpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12), )
if mibBuilder.loadTexts: stnUserIpRouteTable.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteTable.setDescription('The User IP route table.')
stnUserIpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnUserIpRouteIndex"))
if mibBuilder.loadTexts: stnUserIpRouteEntry.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteEntry.setDescription('An User IP route entry. An entry in this table may correspond to a single IP route')
stnUserIpRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouteIndex.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteIndex.setDescription('The configuration instance of this IP route.')
stnUserIpRouteDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouteDestAddress.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteDestAddress.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route.')
stnUserIpRouteDestNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouteDestNetMask.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteDestNetMask.setDescription('The IP sub-network mask associated with the destination IP address of this entry.')
stnUserIpRouteDestGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouteDestGateway.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteDestGateway.setDescription('The gateway for packets with a matching destination address and netmask.')
stnUserIpRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 12, 1, 5), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnUserIpRouteMetric.setStatus('current')
if mibBuilder.loadTexts: stnUserIpRouteMetric.setDescription('The number of hops to the gateway.')
stnLDAPAuthorServerTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13), )
if mibBuilder.loadTexts: stnLDAPAuthorServerTable.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerTable.setDescription('The (conceptual) table listing the LDAP authorization servers with which the client shares a secret.')
stnLDAPAuthorServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnLDAPAuthorServerIndex"))
if mibBuilder.loadTexts: stnLDAPAuthorServerEntry.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerEntry.setDescription('An entry (conceptual row) representing a LDAP authorization server with which the client shares a secret.')
stnLDAPAuthorServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 1), Integer32())
if mibBuilder.loadTexts: stnLDAPAuthorServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerIndex.setDescription('A number uniquely identifying each LDAP Authorization server with which this client communicates.')
stnLDAPAuthorServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorServerAddress.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerAddress.setDescription('The IP address of the LDAP authorization server referred to in this table entry.')
stnLDAPAuthorClientServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorClientServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorClientServerPortNumber.setDescription('The UDP port the client is using to send requests to this server.')
stnLDAPAuthorServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorServerTimeout.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerTimeout.setDescription('Amount of time in seconds the STN 5000 will wait for a reply before considering the transmission a failure')
stnLDAPAuthorConnectionEstablishTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorConnectionEstablishTimeout.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorConnectionEstablishTimeout.setDescription('Amount of time in seconds the STN 5000 will wait to reestablish a failed connection')
stnLDAPAuthorBindPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorBindPassword.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorBindPassword.setDescription('This is the password used in conjunction with the stnLDAPAuthorBindUserId to authenticate to the server during a bind')
stnLDAPAuthorRootDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorRootDirectory.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorRootDirectory.setDescription('The path from the topmost (root) directory of the LDAP server to the directory that contains the stnLDAPAuthorServiceDirectoryName')
stnLDAPAuthorServiceDirectoryName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorServiceDirectoryName.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServiceDirectoryName.setDescription('The domain name component of a company or organization. This is the directory where the services and policies directories are located')
stnLDAPAuthorBindOrganizationalUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorBindOrganizationalUnit.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorBindOrganizationalUnit.setDescription('Directory where the stnLDAPAuthorBindUserId user entry can be found')
stnLDAPAuthorBindUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorBindUserId.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorBindUserId.setDescription('The user id to be used in conjunction with the stnLDAPAuthorBindPassword to authenticate to the server during bind process')
stnLDAPAuthorServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorServerName.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerName.setDescription('The name of this LDAP authorization server - this name will be used for a DNS lookup if no ip address is configured')
stnLDAPAuthorServerConfigInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 13, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnLDAPAuthorServerConfigInstance.setStatus('current')
if mibBuilder.loadTexts: stnLDAPAuthorServerConfigInstance.setDescription('The configuration instance of this LDAP authorization server')
stnRealmTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14), )
if mibBuilder.loadTexts: stnRealmTable.setStatus('current')
if mibBuilder.loadTexts: stnRealmTable.setDescription('The Realm Table.')
stnRealmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnRealmIndex"))
if mibBuilder.loadTexts: stnRealmEntry.setStatus('current')
if mibBuilder.loadTexts: stnRealmEntry.setDescription('A Realm entry. An entry in this table corresponds to a single realm entry')
stnRealmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmIndex.setStatus('current')
if mibBuilder.loadTexts: stnRealmIndex.setDescription('The configuration instance of this realm entry.')
stnRealmName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmName.setStatus('current')
if mibBuilder.loadTexts: stnRealmName.setDescription('The realm name for this realm table entry')
stnRealmAddrPoolInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmAddrPoolInstance.setStatus('current')
if mibBuilder.loadTexts: stnRealmAddrPoolInstance.setDescription('The address pool instance associated with this realm')
stnRealmForcedNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 14, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmForcedNextHop.setStatus('current')
if mibBuilder.loadTexts: stnRealmForcedNextHop.setDescription('The IP address of the next hop router that all IP traffic received on this interface will be sent to')
stnRealmRADIUSAuthenTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15), )
if mibBuilder.loadTexts: stnRealmRADIUSAuthenTable.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenTable.setDescription('The Realm RADIUS Authen Servers Table.')
stnRealmRADIUSAuthenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnRealmIndex"), (0, "STN-AAA-MIB", "stnRealmRADIUSAuthenServerIndex"))
if mibBuilder.loadTexts: stnRealmRADIUSAuthenEntry.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenEntry.setDescription('A Realm RADIUS Authentication server entry. An entry in this table corresponds to a single Realm authentication server entry')
stnRealmRADIUSAuthenServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerIndex.setDescription('The RADIUS authentication server array index.')
stnRealmRADIUSAuthenServerInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerInstance.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerInstance.setDescription('The instance of a RADIUS authentication server')
stnRealmRADIUSAuthenServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerAddress.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerAddress.setDescription('The IP address of this Radius authentication server.')
stnRealmRADIUSAuthenServerDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerDestPort.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerDestPort.setDescription('The destination authenticaton port of this Radius authentication server.')
stnRealmRADIUSAuthenServerRetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 5), Integer32().clone(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerRetrans.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerRetrans.setDescription('The number of times the router will attempt to retransmit to this radius authentication server')
stnRealmRADIUSAuthenServerTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 6), Integer32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerTimeOut.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerTimeOut.setDescription('The time (in seconds) to determine the last (re)transmission to this authentication server failed.')
stnRealmRADIUSAuthenServerSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerSecret.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerSecret.setDescription('The shared secret configured for this Radius authentication server - this same secret must be configured on the RADIUS server itself')
stnRealmRADIUSAuthenServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 15, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerName.setStatus('current')
if mibBuilder.loadTexts: stnRealmRADIUSAuthenServerName.setDescription('The name of this Radius authentication server - this name will be used for a DNS lookup if no ip address is configured')
stnNamedAddressPoolTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 16), )
if mibBuilder.loadTexts: stnNamedAddressPoolTable.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolTable.setDescription('The Named Address Pool Table.')
stnNamedAddressPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 16, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnNamedAddressPoolIndex"))
if mibBuilder.loadTexts: stnNamedAddressPoolEntry.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolEntry.setDescription('A named address pool entry. An entry in this table corresponds to a single named address pool')
stnNamedAddressPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNamedAddressPoolIndex.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolIndex.setDescription('The configuration instance of this Named Address Pool entry.')
stnNamedAddressPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 16, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNamedAddressPoolName.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolName.setDescription('The name of this named address pool table entry')
stnNamedAddressPoolRangeTable = MibTable((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 17), )
if mibBuilder.loadTexts: stnNamedAddressPoolRangeTable.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolRangeTable.setDescription('The Named Address Pool Address Range Table.')
stnNamedAddressPoolRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 17, 1), ).setIndexNames((0, "STN-AAA-MIB", "stnNamedAddressPoolIndex"), (0, "STN-AAA-MIB", "stnNamedAddressPoolRangeIndex"))
if mibBuilder.loadTexts: stnNamedAddressPoolRangeEntry.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolRangeEntry.setDescription('A named address pool range entry. An entry in this table corresponds to a single address range')
stnNamedAddressPoolRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNamedAddressPoolRangeIndex.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolRangeIndex.setDescription('The index into the array of address ranges')
stnNamedAddressPoolStartIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 17, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNamedAddressPoolStartIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolStartIpAddress.setDescription('The starting IP address of the address range')
stnNamedAddressPoolEndIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3551, 2, 10, 1, 1, 17, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNamedAddressPoolEndIpAddress.setStatus('current')
if mibBuilder.loadTexts: stnNamedAddressPoolEndIpAddress.setDescription('The ending IP address of the address range')
stnNotificationRadiusAuthServerIndex = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNotificationRadiusAuthServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnNotificationRadiusAuthServerIndex.setDescription('The priority of this Radius authentication server - highest priority is 1 and higher priority servers will be contacted first - the priorities must be contiguous')
stnNotificationRadiusAccServerIndex = MibScalar((1, 3, 6, 1, 4, 1, 3551, 2, 10, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stnNotificationRadiusAccServerIndex.setStatus('current')
if mibBuilder.loadTexts: stnNotificationRadiusAccServerIndex.setDescription('The priority of this accounting server - higher priority servers will attempt to be contacted before lower priority servers - highest priority is 1 - priority indexes must be contiguous')
stnMaxUserSessionLimitExceeded = NotificationType((1, 3, 6, 1, 4, 1, 3551, 2, 100, 0, 20)).setObjects(("STN-CHASSIS-MIB", "stnEngineIndex"), ("STN-CHASSIS-MIB", "stnEngineSlot"), ("STN-CHASSIS-MIB", "stnEngineCpu"))
if mibBuilder.loadTexts: stnMaxUserSessionLimitExceeded.setStatus('current')
if mibBuilder.loadTexts: stnMaxUserSessionLimitExceeded.setDescription('A stnMaxUserSessionLimitExceeded trap signifies that the agent entity has detected that the maximum number of sessions has been exceeded on one of its engines. The generation of this trap can be controlled by the AAATraps configuration object.')
stnRadiusAuthenMismatch = NotificationType((1, 3, 6, 1, 4, 1, 3551, 2, 100, 0, 21)).setObjects(("STN-AAA-MIB", "stnNotificationRadiusAuthServerIndex"), ("STN-AAA-MIB", "stnRadiusAuthServerName"), ("STN-AAA-MIB", "stnRadiusAuthServerConfigInstance"), ("STN-ROUTER-MIB", "stnRouterIndex"))
if mibBuilder.loadTexts: stnRadiusAuthenMismatch.setStatus('current')
if mibBuilder.loadTexts: stnRadiusAuthenMismatch.setDescription('A stnRadiusAuthenMismatch trap signifies that the agent entity has detected that the a authentication failure (security breach or retransmission parameter) has been detected on one of its routers. The generation of this trap can be controlled by the AAATraps configuration object.')
stnPrimaryBillingServerFailure = NotificationType((1, 3, 6, 1, 4, 1, 3551, 2, 100, 0, 22)).setObjects(("STN-AAA-MIB", "stnNotificationRadiusAccServerIndex"), ("STN-AAA-MIB", "stnRadiusAccServerName"), ("STN-AAA-MIB", "stnRadiusAccServerConfigInstance"), ("STN-ROUTER-MIB", "stnRouterIndex"))
if mibBuilder.loadTexts: stnPrimaryBillingServerFailure.setStatus('current')
if mibBuilder.loadTexts: stnPrimaryBillingServerFailure.setDescription('A stnPrimaryBillingServerFailure trap signifies that the agent entity has detected that a problem has occurred with the primary billing server and is switching to a secondary billing server. The generation of this trap can be controlled by the AAATraps configuration object.')
stnNoAddressesAvailable = NotificationType((1, 3, 6, 1, 4, 1, 3551, 2, 100, 0, 23)).setObjects(("STN-ROUTER-MIB", "stnRouterIndex"))
if mibBuilder.loadTexts: stnNoAddressesAvailable.setStatus('current')
if mibBuilder.loadTexts: stnNoAddressesAvailable.setDescription('A stnNoAddressesAvailable trap signifies that the agent entity has detected that no addresses are available on the indicated router. The generation of this trap can be controlled by the AAATraps configuration object.')
mibBuilder.exportSymbols("STN-AAA-MIB", stnDefaultUserPrimaryDNSServer=stnDefaultUserPrimaryDNSServer, stnRealmRADIUSAuthenEntry=stnRealmRADIUSAuthenEntry, stnStartIpAddress=stnStartIpAddress, stnRadiusAccServerTimeOut=stnRadiusAccServerTimeOut, stnRadiusAuthServerConfigInstance=stnRadiusAuthServerConfigInstance, stnNetworkAccessGroup=stnNetworkAccessGroup, stnUserIpFilterRuleTable=stnUserIpFilterRuleTable, stnLDAPAuthorServerName=stnLDAPAuthorServerName, stnNamedAddressPoolName=stnNamedAddressPoolName, stnMaxUserSessionLimitExceeded=stnMaxUserSessionLimitExceeded, stnDefaultUserSecondaryDNSServer=stnDefaultUserSecondaryDNSServer, stnUserIpFilterIndex=stnUserIpFilterIndex, stnLDAPAuthorRootDirectory=stnLDAPAuthorRootDirectory, stnEndPointEntry=stnEndPointEntry, stnUserTable=stnUserTable, stnUserServiceName=stnUserServiceName, stnEndPointIpAddress=stnEndPointIpAddress, stnNetworkAccessEndPointAccType=stnNetworkAccessEndPointAccType, stnRadiusAccServerEntry=stnRadiusAccServerEntry, stnDefaultUserIpFilters=stnDefaultUserIpFilters, stnUserIpFilterRuleDestPort=stnUserIpFilterRuleDestPort, stnLDAPAuthorServerTable=stnLDAPAuthorServerTable, stnNamedAddressPoolStartIpAddress=stnNamedAddressPoolStartIpAddress, stnNamedAddressPoolRangeEntry=stnNamedAddressPoolRangeEntry, stnNetworkAccessUserAccType=stnNetworkAccessUserAccType, stnUserIpFilterRuleProtocol=stnUserIpFilterRuleProtocol, stnUserIpFilterEntry=stnUserIpFilterEntry, stnLDAPAuthorServerTimeout=stnLDAPAuthorServerTimeout, stnRadiusAuthServerAddress=stnRadiusAuthServerAddress, stnRealmAddrPoolInstance=stnRealmAddrPoolInstance, stnUserIpFilterRuleEntry=stnUserIpFilterRuleEntry, stnNamedAddressPoolRangeIndex=stnNamedAddressPoolRangeIndex, stnUserName=stnUserName, stnUserPhysicalPort=stnUserPhysicalPort, stnLDAPAuthorClientServerPortNumber=stnLDAPAuthorClientServerPortNumber, stnUserTunnelType=stnUserTunnelType, stnRealmName=stnRealmName, stnAAAStats=stnAAAStats, stnRealmRADIUSAuthenTable=stnRealmRADIUSAuthenTable, stnDefaultUserTunnelType=stnDefaultUserTunnelType, stnDefaultUserIpAddress=stnDefaultUserIpAddress, stnRealmRADIUSAuthenServerRetrans=stnRealmRADIUSAuthenServerRetrans, stnUserTimeOut=stnUserTimeOut, stnRadiusAuthServerName=stnRadiusAuthServerName, stnUserIpFilterRuleIndex=stnUserIpFilterRuleIndex, stnNetworkAccessLdapAuthorizationUpdateTime=stnNetworkAccessLdapAuthorizationUpdateTime, stnDefaultUserIpCompression=stnDefaultUserIpCompression, stnUserPassword=stnUserPassword, stnDefaultUserTimeOut=stnDefaultUserTimeOut, stnNetworkAccessServiceNameRadiusAttrType=stnNetworkAccessServiceNameRadiusAttrType, stnLDAPAuthorServerIndex=stnLDAPAuthorServerIndex, stnRadiusAuthServerDestPort=stnRadiusAuthServerDestPort, stnRadiusAuthServerTimeOut=stnRadiusAuthServerTimeOut, stnEndPointTable=stnEndPointTable, stnEndPointPassword=stnEndPointPassword, stnRealmIndex=stnRealmIndex, stnUserIpNetMask=stnUserIpNetMask, stnDefaultUserIpRouting=stnDefaultUserIpRouting, stnAddressPoolIndex=stnAddressPoolIndex, stnUserIpFilterName=stnUserIpFilterName, stnRealmTable=stnRealmTable, stnLDAPAuthorServiceDirectoryName=stnLDAPAuthorServiceDirectoryName, stnUserIpRoutes=stnUserIpRoutes, stnNamedAddressPoolEntry=stnNamedAddressPoolEntry, stnRadiusAccServerAddress=stnRadiusAccServerAddress, stnRadiusAccServerName=stnRadiusAccServerName, stnRadiusAuthServerIndex=stnRadiusAuthServerIndex, stnAAATrapVars=stnAAATrapVars, stnUserPhysicalSlot=stnUserPhysicalSlot, stnNetworkAccessDomainName=stnNetworkAccessDomainName, stnRadiusAccServerTable=stnRadiusAccServerTable, stnUserServiceType=stnUserServiceType, stnAAAMibConformance=stnAAAMibConformance, stnUserIpFilterRuleEndPoint=stnUserIpFilterRuleEndPoint, stnUserIpFilterTable=stnUserIpFilterTable, stnUserIpRouteTable=stnUserIpRouteTable, stnRealmRADIUSAuthenServerDestPort=stnRealmRADIUSAuthenServerDestPort, stnRadiusAuthenMismatch=stnRadiusAuthenMismatch, stnNoAuthPppUserName=stnNoAuthPppUserName, stnRadiusAuthServerEntry=stnRadiusAuthServerEntry, stnDefaultPppUserGroup=stnDefaultPppUserGroup, stnNoAuthPppUserGroup=stnNoAuthPppUserGroup, stnNetworkAccessRealmAttrType=stnNetworkAccessRealmAttrType, stnUserIpCompression=stnUserIpCompression, stnRadiusAccServerConfigInstance=stnRadiusAccServerConfigInstance, stnNamedAddressPoolTable=stnNamedAddressPoolTable, stnAddressPoolEntry=stnAddressPoolEntry, stnUserTunnelServerEndPoint=stnUserTunnelServerEndPoint, stnEndPointName=stnEndPointName, stnRealmForcedNextHop=stnRealmForcedNextHop, stnUserTunnelClientEndPoint=stnUserTunnelClientEndPoint, stnRealmRADIUSAuthenServerName=stnRealmRADIUSAuthenServerName, stnAddressPoolTable=stnAddressPoolTable, stnEndIpAddress=stnEndIpAddress, stnLDAPAuthorBindOrganizationalUnit=stnLDAPAuthorBindOrganizationalUnit, stnRadiusAccServerDestPort=stnRadiusAccServerDestPort, stnStackingRuleTunnelType=stnStackingRuleTunnelType, stnStackingRuleTunnelEndPoint=stnStackingRuleTunnelEndPoint, stnDefaultUserIpRoutes=stnDefaultUserIpRoutes, stnNoAddressesAvailable=stnNoAddressesAvailable, stnStackingRuleProtocol=stnStackingRuleProtocol, stnLDAPAuthorServerAddress=stnLDAPAuthorServerAddress, stnRadiusAuthServerSecret=stnRadiusAuthServerSecret, stnEndPointIndex=stnEndPointIndex, stnUserIpFilterRules=stnUserIpFilterRules, stnUserIdleTime=stnUserIdleTime, PYSNMP_MODULE_ID=stnAAA, stnAAA=stnAAA, stnLDAPAuthorServerConfigInstance=stnLDAPAuthorServerConfigInstance, stnNetworkAccessEndPointAuthenType=stnNetworkAccessEndPointAuthenType, stnAAAConfig=stnAAAConfig, stnNamedAddressPoolEndIpAddress=stnNamedAddressPoolEndIpAddress, stnRadiusAccServerSecret=stnRadiusAccServerSecret, stnRadiusAccServerIndex=stnRadiusAccServerIndex, stnDefaultUserMTU=stnDefaultUserMTU, stnDefaultUserTunnelClientEndPoint=stnDefaultUserTunnelClientEndPoint, stnNamedAddressPoolIndex=stnNamedAddressPoolIndex, stnRadiusAuthServerRetrans=stnRadiusAuthServerRetrans, stnUserIpFilters=stnUserIpFilters, stnUserPrimaryNBNSServer=stnUserPrimaryNBNSServer, stnDefaultUserIpNetMask=stnDefaultUserIpNetMask, stnStackingRuleGroup=stnStackingRuleGroup, stnUserIpFilterRuleSrcAddress=stnUserIpFilterRuleSrcAddress, stnUserRealmInstance=stnUserRealmInstance, stnUserIpRouting=stnUserIpRouting, stnDefaultUserPrimaryNBNSServer=stnDefaultUserPrimaryNBNSServer, stnNotificationRadiusAccServerIndex=stnNotificationRadiusAccServerIndex, stnUserAssignedTunnelName=stnUserAssignedTunnelName, stnNetworkAccessUserAuthenType=stnNetworkAccessUserAuthenType, stnUserIpAddress=stnUserIpAddress, stnRealmRADIUSAuthenServerInstance=stnRealmRADIUSAuthenServerInstance, stnRadiusAuthServerTable=stnRadiusAuthServerTable, stnDefaultUserTunnelServerEndPoint=stnDefaultUserTunnelServerEndPoint, stnDefaultUserIdleTime=stnDefaultUserIdleTime, stnUserVirtualCircuitId=stnUserVirtualCircuitId, stnRealmEntry=stnRealmEntry, stnUserIpRouteDestAddress=stnUserIpRouteDestAddress, stnUserIpFilterRuleSrcPort=stnUserIpFilterRuleSrcPort, stnUserIpRouteDestGateway=stnUserIpRouteDestGateway, stnUserTunnelPassword=stnUserTunnelPassword, stnUserIpRouteIndex=stnUserIpRouteIndex, stnUserIpRouteDestNetMask=stnUserIpRouteDestNetMask, stnLDAPAuthorBindPassword=stnLDAPAuthorBindPassword, stnUserPrimaryDNSServer=stnUserPrimaryDNSServer, stnLDAPAuthorServerEntry=stnLDAPAuthorServerEntry, stnRealmRADIUSAuthenServerSecret=stnRealmRADIUSAuthenServerSecret, stnNetworkAccessLdapUpdateNotification=stnNetworkAccessLdapUpdateNotification, stnUserMTU=stnUserMTU, stnRadiusAccServerRetrans=stnRadiusAccServerRetrans, stnUserSecondaryNBNSServer=stnUserSecondaryNBNSServer, stnUserSecondaryDNSServer=stnUserSecondaryDNSServer, stnUserIpFilterRuleAction=stnUserIpFilterRuleAction, stnUserIndex=stnUserIndex, stnUserIpRouteEntry=stnUserIpRouteEntry, stnRealmRADIUSAuthenServerTimeOut=stnRealmRADIUSAuthenServerTimeOut, stnNamedAddressPoolRangeTable=stnNamedAddressPoolRangeTable, stnUserIpFilterRuleDestNetMask=stnUserIpFilterRuleDestNetMask, stnAAAObjects=stnAAAObjects, stnPrimaryBillingServerFailure=stnPrimaryBillingServerFailure, stnUserIpRouteMetric=stnUserIpRouteMetric, stnUserEntry=stnUserEntry, stnNotificationRadiusAuthServerIndex=stnNotificationRadiusAuthServerIndex, stnDefaultUserServiceName=stnDefaultUserServiceName, stnLDAPAuthorConnectionEstablishTimeout=stnLDAPAuthorConnectionEstablishTimeout, stnDefaultUserSecondaryNBNSServer=stnDefaultUserSecondaryNBNSServer, stnLDAPAuthorBindUserId=stnLDAPAuthorBindUserId, stnUserVirtualPathId=stnUserVirtualPathId, stnUserIpFilterRuleSrcNetMask=stnUserIpFilterRuleSrcNetMask, stnUserIpFilterRuleDestAddress=stnUserIpFilterRuleDestAddress, stnNoAuthPppUserPassword=stnNoAuthPppUserPassword, stnRealmRADIUSAuthenServerIndex=stnRealmRADIUSAuthenServerIndex, stnRealmRADIUSAuthenServerAddress=stnRealmRADIUSAuthenServerAddress)

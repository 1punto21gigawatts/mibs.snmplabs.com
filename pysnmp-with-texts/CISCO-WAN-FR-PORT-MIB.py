#
# PySNMP MIB module CISCO-WAN-FR-PORT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-FR-PORT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
frPortServiceQueGrp, frPortCnf, frPortCnt, frPort = mibBuilder.importSymbols("BASIS-MIB", "frPortServiceQueGrp", "frPortCnf", "frPortCnt", "frPort")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Integer32, Bits, TimeTicks, IpAddress, ObjectIdentity, ModuleIdentity, MibIdentifier, Counter64, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Integer32", "Bits", "TimeTicks", "IpAddress", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "Counter64", "NotificationType", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ciscoWanFrPortMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 44))
ciscoWanFrPortMIB.setRevisions(('2002-10-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanFrPortMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanFrPortMIB.setLastUpdated('200210170000Z')
if mibBuilder.loadTexts: ciscoWanFrPortMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanFrPortMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanFrPortMIB.setDescription("The MIB module to create/configure frame relay ports/interfaces. This module contains tables related to frame relay port states and statistics. The frame relay logical port is referred to as 'frame relay port' in this mib. Terminologies Used: Channel : Generically refers to the user access channel across which frame relay data travels. This is also referred to use logical port/interface in this MIB. Within a given T1 or E1 physical line, a channel can be one of the following, depending on how the line is configured. Unchannelized : The Entire T1/E1 line is considered a channel, where: * The T1 line operates at the speed of 1.536 Mbps and is single channel consisting of 24 T1 time slots. * The E1 line operates at the speed of 1.984 Mbps and is single channel consisting of 31 T1 time slots. Channelized: The channel is any one of the N time slots within a given line, where: * The T1 line consists of any one or more channels. Each channel is any one of 24 time slots. * The E1 line consists of one or more channels. Each channel is any one of 31 time slots. Fractional: The T1/E1 channel is one of the following groupings of consecutively or nonconsecutively assigned time slots: * N T1 time slots(N*56/64Kbps where N=1-23 T1 Time slots per FT1 channel. * N E1 time slots(N*64Kbps where N=1-30 Time slots per E1: channel. SVC : Switched Virtual Circuits. SVCs allow access through a Frame Relay Network by setting up a path to the destination endpoints only when the need arises and tearing down the path when it is no longer needed. Refer ITU Q.933 and Q.922 FECN : Forward Explicit Congestion Notification A bit set by a frame relay network to notify an interface device(DTE) that congestion avoidance procedures should be initiated by the receiving device. BECN : Backward Explicit Congestion Notification A bit set by a frame relay network to notify an interface device(DTE) that congestion avoidance procedures should be initiated by the sending device. DE : Discard Eligibility A user-bit set indicating that a frame may be discarded in preference to other frames if congestion occurs, to maintain the committed quality of service within the network. Frames with the DE bit set are considered Be(Excess Burst Size)excess data. Unchannelized Service Modules: Following Service Modules does not support channelized interfaces(i.e supports only unchannelized). FRSM-VHS : FRSM-2T3/2E3, FRSM-HS2/HS2B, FRSM-T3B/E3B For following service modules, ifTable is supported: FRSM-12. ")
frPortCnfPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1))
frPortStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3))
frPortCntPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1))
frPortCnfPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1), )
if mibBuilder.loadTexts: frPortCnfPortGrpTable.setStatus('current')
if mibBuilder.loadTexts: frPortCnfPortGrpTable.setDescription('This table is used for creating/configuring Frame Relay Logical(referred to as frame relay port)Ports. Relation with ifTable: The modules in which ifTable is implemented, the creation of frame relay port in this table will cause an entry to be created in ifTable. The possible interfaces that are created in ifTable are identified by ifType = frameRelayService(44) and frForward(158). The deletion of an entry in this table causes the corresponding entry in ifTable to be deleted. ')
frPortCnfPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-PORT-MIB", "portNum"))
if mibBuilder.loadTexts: frPortCnfPortGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frPortCnfPortGrpEntry.setDescription('An entry in the frame relay port table.')
portNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNum.setReference('CISCO-MGX8800-IF-MAPPING-MIB.my to get the ifIndex value of a port even before it appears in ifTable.')
if mibBuilder.loadTexts: portNum.setStatus('current')
if mibBuilder.loadTexts: portNum.setDescription("This is the frame relay(logical) port number. For Service Modules, supporting ifTable, this must be the ifIndex value of the frame relay port. The port number value supported depends upon the following for each Service Module: - type(Channelized, Unchannelized, Fractional etc) of physical line and number of physical lines - Number of physical line supported - Limitations due to Service Module Hardware components. Port Number mapping is as follows: (NOTE: All the Supported Service Module information is not provided here). T1(channelized) : 24 Time Slots * Max #Lines Supported. Example: 8 Port Service Module - 1..192(24*8) E1(channelized) : 31 Time Slots * Max #Lines Supported. Example: 8 Port Service Module - 1..248(31*8) T3 Channelized : Example: 2CT3 Service Module: 1-256(Limited by hardware) Unchannelized VHS : Range is 1-2 (T3/E3/HS2/T3B/E3B/HS2B-HSSI) FRSM-HS2B-12IN1 : Range is 1-8 FRSM-12 : same as ifIndex value. With the above convention, Port Number mapping is as follows: T1 Service Module : Range is 1-192. E1 Service Module : Range is 1-248. 2CT3 Service Module : Range is 1-256 NOTE: For other Service Modules(Where ifTable is supported): This value for this object must be same as the ifIndex value for the frame relay port ifTable. The frame relay ports identified by ifType values frameRelayService(44) and frForward(158) are valid for this object. Since, Frame Relay Port table is used for creating entries in ifTable, it sounds odd to specify ifIndex value for this object, even before creating the ifTable entries!. The reason(s) for this is as follows: - There are tables in other frame relay mibs, which are indexed by auxiliary objects(objects which are both specified in the INDEX clause and columnar objects of the same row) whose value is supposed to be same as 'portNum'. These MIBs have been used earlier by NMS Applications for the other product lines(MGX8250, MGX8220 etc). - The same frame relay tables in used in other products has been decided to use in new products(for example MGX8850 with FRSM-12 Service Module). It is a requirement that ifTable must be supported in New Service Modules. If we use ifIndex value of the frame relay port (after creation) in other tables(FR Port Stats, FR R Resource Partition or FR Connection etc), and if ifIndex value is different than 'portNum', then it will break the NMS applications which have been using this MIB with the assumptions that 'portNum' and INDEXes(For example: frResPartPortNum, lmiCnfPortNum, etc) are same. To avoid this confusion, it is required that 'portNum' value must be same as 'ifIndex' of the frame relay port. ")
portLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLineNum.setStatus('current')
if mibBuilder.loadTexts: portLineNum.setDescription('This object represents the physical line number on which the frame relay port need to be created. For Service Modules, supporting ifTable, this must be the ifIndex value of the physical line or logical interface. The ifIndex entries in ifTable applicable to this category are identified by ifType values of ds3(30), ds1(18).')
portRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRowStatus.setStatus('current')
if mibBuilder.loadTexts: portRowStatus.setDescription('The value of this object is used for creating modifying or deleting frame relay ports. The possible values are : add(1) : Create frame relay port del(2) : Delete frame relay port mod(3) : Modify the frame relay port. This value is required to be set in Some Older Service Modules (FRSM-8T1/E1, FRSM-VHS, FRSM-HS2B etc) to modify the port parameters. In some service modules, when the port is successfully created(add(1)), this object is set internally to mod(3). The reason for this is, one can modify parameters of the port without requiring to go through an explicit mod(3) to modify the parameters.')
portDs0ConfigBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDs0ConfigBitMap.setStatus('current')
if mibBuilder.loadTexts: portDs0ConfigBitMap.setDescription("This respesents bit map of DS0s for a line/interface which are used to form this logical port. The Bit 0 represents DS0-1(First DS0 timeslot). This object is not applicable for unchannelized service modules. In case of unchannelized interfaces, this field carries the value of 'ffffff'h.")
portDs0Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("speed56k", 1), ("speed64k", 2), ("unUsed", 3))).clone('speed64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDs0Speed.setStatus('current')
if mibBuilder.loadTexts: portDs0Speed.setDescription("The value of this object is used for configuring the port speed(or data rate) of Ds0 in frame relay port. speed56k(1) : set to 56k speed64k(2) : set to 64k unUsed(3) : Not applicable. This field is not applicable for unchannelized interfaces/ports. In case of unchannelized interfaces this object is set to 'unUsed' always. This object can be specified only during port creation.")
portFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFlagsBetweenFrames.setStatus('current')
if mibBuilder.loadTexts: portFlagsBetweenFrames.setDescription('Number of flags transmitted between FR frames For FRSM12 card: Only the values 1 to 8 are supported. The mapping is as follows: MIB object value No. of HDLC flags inserted 1 1 2 2 3 4 4 8 5 16 6 32 7 64 8 128 This object can not be modified if there are any frame relay connections that are configured on the port.')
portEqueueServiceRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEqueueServiceRatio.setStatus('current')
if mibBuilder.loadTexts: portEqueueServiceRatio.setDescription('Number of times queue 1 is serviced for every time queue 2 is serviced. The value 0 is supported only by FRSM-VHS. FRSM-VHS supports two different egress queue servicing algorithms depending on the Egress Qos Feature. if EgrQosFeature is ENABLED, Weighted Fair queueing algorithm will be used to select one queue out of 4 data queues and this object will be set to a default value of 0 in this case and this value cannot be modified by user. In case of EgrQosFeature being DISABLED, this object will be set to a default value of 1 and can be configured to user desired value. This value will be used to decide number of times High priority queue has to be serviced for every time low priority queue is serviced. For FRSM12 card: There is only one scheme of egress scheduling of COS queues within ports, which uses only two COS queues for user data. The scheduling scheme uses a pre-defined ratio to schedule these COS queues on a given port. This object will be used to decide number of times High priority queue has to be serviced for every time low priority queue is serviced.')
portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 8), Integer32()).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpeed.setStatus('current')
if mibBuilder.loadTexts: portSpeed.setDescription('The value of this object contains the Configured speed of port.')
portAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("write-Only", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdmin.setStatus('current')
if mibBuilder.loadTexts: portAdmin.setDescription("The value of this object is used for changing the desired state of the port. up(1) : Up the port;Admin up down(2) : Down the port;Admin down For Service Modules, supporting ifTable, this is equivalent to 'ifAdminStatus' object. The write-only is not supported in these cases.")
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frame-relay", 1), ("frFUNI", 2), ("frame-forward", 3))).clone('frame-relay')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portType.setStatus('current')
if mibBuilder.loadTexts: portType.setDescription('The value of this object identifies the network interface for this frame relay port. The Possible values are: frame-relay(1) : Frame Relay Service Port frFUNI (2) : Frame based UNI Port. when a frame arrives from the FUNI interface the 2 byte FUNI header is removed and frame is segmented into ATM Cells by using AAL5. frame-forward(3): Frame Forward Port. In this case 2 byte Q.922 header is not assumed or interpreted. The signaling(LMI) parameters are not applicable for these ports. Relationship with ifTable: The service modules in which ifTable is implemented following side-effects will take place. For value frame-relay(1) an ifTable entry with ifType = frameRelayService(44) will be created. For value frame-forward(3) an ifTable entry with ifType = frForward(158) will be created. This object can not be modified after the port is created.')
portSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSvcStatus.setStatus('current')
if mibBuilder.loadTexts: portSvcStatus.setDescription('The value of this object is used for enabling/disabling the SVC operation on a frame relay port. For FRSM12 card: Not Supported ')
portSvcInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-use", 1), ("in-use", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSvcInUse.setStatus('current')
if mibBuilder.loadTexts: portSvcInUse.setDescription('The value of this object is used for representing whether SVC is in use or not. For FRSM12 card: Not Supported ')
portSvcShareLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port-based", 1), ("card-based", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcShareLcn.setStatus('current')
if mibBuilder.loadTexts: portSvcShareLcn.setDescription('The value of this object identifies the SVC shared LCN type. For FRSM12 card: Not Supported ')
portSvcLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcLcnLow.setStatus('current')
if mibBuilder.loadTexts: portSvcLcnLow.setDescription('The value of this object identifies the low end of the reserved LCN for SVC. For FRSM12 card: Not Supported ')
portSvcLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcLcnHigh.setStatus('current')
if mibBuilder.loadTexts: portSvcLcnHigh.setDescription('The value of this object identifies the high end of reserved LCN for SVC. For FRSM12 card: Not Supported ')
portSvcDlciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcDlciLow.setStatus('current')
if mibBuilder.loadTexts: portSvcDlciLow.setDescription('The value of this object identifies the low end of reserved DLCI for SVC. For FRSM12 card: Not Supported.')
portSvcDlciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcDlciHigh.setStatus('current')
if mibBuilder.loadTexts: portSvcDlciHigh.setDescription('The value of this object identifies the high end of reserved DLCI for SVC. For FRSM12 card: Not Supported.')
portDeleteSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDeleteSvcs.setStatus('current')
if mibBuilder.loadTexts: portDeleteSvcs.setDescription('The value of this object indicates that all the SVC connections on a given frame relay port has to be deleted. For FRSM12 card: Not Supported ')
portIngrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIngrSvcBandW.setStatus('current')
if mibBuilder.loadTexts: portIngrSvcBandW.setDescription('The value of this object identifies the Ingress bandwidth reserved for SVC. For FRSM12 card: Not Supported ')
portEgrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portEgrSvcBandW.setStatus('current')
if mibBuilder.loadTexts: portEgrSvcBandW.setDescription('The value of this object identifies the Egress bandwidth reserved for SVC. For FRSM12 card: Not Supported.')
portBERTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBERTEnable.setStatus('current')
if mibBuilder.loadTexts: portBERTEnable.setDescription('The value of this object enables/disables the Bit Error Rate Testing (BERT) on the frame relay port. For FRSM12 card: Not Supported ')
portEnhancedSIW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEnhancedSIW.setStatus('current')
if mibBuilder.loadTexts: portEnhancedSIW.setDescription('This variable enables/disables enhanced SIW feature. Enabling this permits support for SIW translation of Appletalk. This feature is supported only in the FRSM-VHS card. This object is not required in FRSM12 since Appletalk is supported by default in FRF.8.1 and FRSM12 supports FRF.8.1 ')
portM32EgrQueueThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6000)).clone(6000)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: portM32EgrQueueThresh.setStatus('current')
if mibBuilder.loadTexts: portM32EgrQueueThresh.setDescription('This represents the M32 logical port Egress Queue threshold in bytes. Frames will not be queued until the number of bytes in the queue is less than the threshold. The default value is 6000. Using a very low value could under utilize the logical port. This is supported in FRSM 8t1e1 and FRSM 4t1e1 Service Modules only.')
portHeaderLen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twoOctets", 1), ("fourOctets", 2))).clone('twoOctets')).setUnits('Octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: portHeaderLen.setReference('Q.922 [25]')
if mibBuilder.loadTexts: portHeaderLen.setStatus('current')
if mibBuilder.loadTexts: portHeaderLen.setDescription('The value of this object identifies the Q.922 address field length and DLCI length for this UNI/NNI logical port. This object can not be modified if there are any frame relay connections that are configured on the port. This object is not applicable to MGX Release 1.x. ')
portFrameChkSumType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16", 1), ("crc32", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrameChkSumType.setStatus('current')
if mibBuilder.loadTexts: portFrameChkSumType.setDescription('The value of this object identifies the CRC Length in the HDLC Packet. Applicable for FrameForwarding ports only. This object can not be modified if there are any frame relay connections that are configured on the port. This object is not applicable to MGX Release 1.x. ')
portFileId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFileId.setStatus('current')
if mibBuilder.loadTexts: portFileId.setDescription('The value of this object identifies the Service Class Template(SCT) file ID. The SCT holds the module specific configuration parameters for the frame relay port. This object is not applicable to MGX Release 1.x.')
portOverSubEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOverSubEnable.setStatus('current')
if mibBuilder.loadTexts: portOverSubEnable.setDescription(' The value of this object enables/disables the port to be over subscribed. This object is not applicable to MGX Release 1.x. ')
portsUsedLine1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine1.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine1.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1. This is for line.')
portsUsedLine2 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine2.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine2.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1. This is for line 2.')
portsUsedLine3 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine3.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine3.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 3.')
portsUsedLine4 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine4.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine4.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 4.')
portsUsedLine5 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine5.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine5.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 5.')
portsUsedLine6 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine6.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine6.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 6.')
portsUsedLine7 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine7.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine7.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 7.')
portsUsedLine8 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine8.setStatus('current')
if mibBuilder.loadTexts: portsUsedLine8.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1. The most significant byte is invalid for DS1. This is for line 8.')
portNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNextAvailable.setStatus('current')
if mibBuilder.loadTexts: portNextAvailable.setDescription("This variable contains the next UNUSED logical port number. This number can be used in channel config table, the portNextAvailable gets updated if the number gets used to create a logical port. A '0' indicates that no more ports are available. For FRSM12 Card: Not Supported ")
frPortStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1), )
if mibBuilder.loadTexts: frPortStateGrpTable.setStatus('current')
if mibBuilder.loadTexts: frPortStateGrpTable.setDescription('Table of transmit/receive states of ports. ')
frPortStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-PORT-MIB", "statePortNum"))
if mibBuilder.loadTexts: frPortStateGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frPortStateGrpEntry.setDescription('An entry for logical port. ')
statePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statePortNum.setStatus('current')
if mibBuilder.loadTexts: statePortNum.setDescription("This is the frame relay(logical) port number. The value of this object must match with the value of object 'portNum' in frPortCnfPortGrpTable.")
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("remoteLoopback", 3), ("failedDueToLine", 4), ("failedDueToSignalling", 5), ("inactive", 6), ("inBert", 7), ("farEndRemoteLoopback", 8), ("latchDS0DropFeLoop", 9), ("latchDS0LineFeLoop", 10), ("latchOcuFeLoop", 11), ("latchCsuFeLoop", 12), ("latchDsuFeLoop", 13), ("latchHL96FeLoop", 14), ("v54PolynomialFeLoop", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription('This variable indicates the state of the logical port ')
portSignallingState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSignallingState.setStatus('current')
if mibBuilder.loadTexts: portSignallingState.setDescription('Bit 0 = 0 -> LMI O.K. or not enabled Bit 0 = 1 -> LMI failed Bit 1 = 0 -> CLLM O.K. or not enabled Bit 1 = 1 -> CLLM failed ')
portOversubscribed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOversubscribed.setStatus('current')
if mibBuilder.loadTexts: portOversubscribed.setDescription('This variable indicates the whether the port is over subscribed or not.')
portIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIngrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: portIngrPercentUtil.setDescription('Percentage Utilization of the Port in the Ingress direction.')
portEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portEgrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: portEgrPercentUtil.setDescription('Percentage Utilization of the Port in the Egress direction.')
frPortCntPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: frPortCntPortGrpTable.setStatus('current')
if mibBuilder.loadTexts: frPortCntPortGrpTable.setDescription('The config table is for logical port interface there are upto 248 entries (for 8 E1s) or 192 (for 8 T1s). In FRSM-VHS, there is support for upto 256 entries. ')
frPortCntPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-PORT-MIB", "cntPortNum"))
if mibBuilder.loadTexts: frPortCntPortGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frPortCntPortGrpEntry.setDescription(' An entry for logical port ')
cntPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPortNum.setStatus('current')
if mibBuilder.loadTexts: cntPortNum.setDescription("This is the frame relay(logical) port number. The value of this object must be same as the value of object 'portNum' in frPortCnfPortGrpTable.")
rcvPortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 2), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFrames.setStatus('current')
if mibBuilder.loadTexts: rcvPortFrames.setDescription('The number of frames Received on the ingress.')
rcvPortBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 3), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortBytes.setStatus('current')
if mibBuilder.loadTexts: rcvPortBytes.setDescription('The number of bytes Received on the ingress.')
rcvPortFramesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 4), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesDE.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesDE.setDescription('The number of frames with DE bit set received on the ingress.')
rcvPortFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 5), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesFECN.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesFECN.setDescription('The number of frames with FECN bit set received on the ingress.')
rcvPortFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 6), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesBECN.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesBECN.setDescription('The number of frames with BECN bit set received on the ingress.')
rcvFramesDiscCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 7), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscCRCError.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscCRCError.setDescription('The number of frames discarded on the ingress due to CRC error.')
rcvFramesDiscAlignmentError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 8), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscAlignmentError.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscAlignmentError.setDescription('The number of frames discarded on the ingress due to Alignment error.')
rcvFramesDiscIllegalLen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 9), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscIllegalLen.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscIllegalLen.setDescription('The number of frames discarded on the ingress due to illegal length.')
rcvFramesDiscIllegalHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 10), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscIllegalHeader.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscIllegalHeader.setDescription('The number of frames discarded on the ingress due to illegal header.')
rcvFramesAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 11), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesAbort.setStatus('current')
if mibBuilder.loadTexts: rcvFramesAbort.setDescription('The number of received frames aborted ')
rcvFramesUnknownDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 12), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesUnknownDLCI.setStatus('current')
if mibBuilder.loadTexts: rcvFramesUnknownDLCI.setDescription('The number of frames received with an unknown DLCI.')
rcvLastUnknownDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvLastUnknownDLCI.setStatus('current')
if mibBuilder.loadTexts: rcvLastUnknownDLCI.setDescription('The last unknown DLCI received.')
rcvPortFramesTaggedFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 14), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedFECN.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesTaggedFECN.setDescription('The number of frames received that were tagged with FECN bit.')
rcvPortFramesTaggedBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 15), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedBECN.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesTaggedBECN.setDescription('The number of frames received that were tagged with BECN bit.')
rcvPortFramesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 16), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedDE.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesTaggedDE.setDescription('The number of frames received that were tagged with DE bit.')
rcvPortFramesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 17), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesDiscXceedDEThresh.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesDiscXceedDEThresh.setDescription('The number of frames discarded on the ingress due to exceeded DE Threshold.')
rcvPortKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 18), Integer32()).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortKbpsAIR.setStatus('current')
if mibBuilder.loadTexts: rcvPortKbpsAIR.setDescription('Received Average Information Rate in KBPS.')
rcvBufNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBufNotAvailable.setStatus('current')
if mibBuilder.loadTexts: rcvBufNotAvailable.setDescription('The number of times the receiver is turned off ')
xmtPortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 20), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFrames.setStatus('current')
if mibBuilder.loadTexts: xmtPortFrames.setDescription('The number of frames transmitted.')
xmtPortBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 21), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytes.setStatus('current')
if mibBuilder.loadTexts: xmtPortBytes.setDescription('The number of bytes transmitted.')
xmtPortFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 22), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesFECN.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesFECN.setDescription('The number of frames transmitted with FECN bit already set.')
xmtPortFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 23), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesBECN.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesBECN.setDescription('The number of frames transmitted with BECN bit already set.')
xmtPortFramesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 24), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDiscXceedQDepth.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesDiscXceedQDepth.setDescription('The number of frames discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtPortBytesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 25), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDiscXceedQDepth.setStatus('current')
if mibBuilder.loadTexts: xmtPortBytesDiscXceedQDepth.setDescription('The number of bytes discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtPortFramesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 26), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDuringLMIAlarm.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesDuringLMIAlarm.setDescription('The number of frames transmitted during LMI logical port alarm ')
xmtPortBytesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 27), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDuringLMIAlarm.setStatus('current')
if mibBuilder.loadTexts: xmtPortBytesDuringLMIAlarm.setDescription('The number of bytes transmitted during LMI logical port alarm ')
xmtFramesAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 28), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesAbort.setStatus('current')
if mibBuilder.loadTexts: xmtFramesAbort.setDescription('The number of transmit frames aborted For FRSM12 Card: Not Supported ')
xmtFramesUnderrun = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 29), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesUnderrun.setStatus('current')
if mibBuilder.loadTexts: xmtFramesUnderrun.setDescription('The number of frames discarded due to underrun.')
xmtPortKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 30), Integer32()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortKbpsAIR.setStatus('current')
if mibBuilder.loadTexts: xmtPortKbpsAIR.setDescription('Transmit Average Information Rate in KBPS.')
xmtBufNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBufNotAvailable.setStatus('current')
if mibBuilder.loadTexts: xmtBufNotAvailable.setDescription('The number of times the transmitter is turned off For FRSM12 Card: Not Supported ')
portClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portClrButton.setStatus('current')
if mibBuilder.loadTexts: portClrButton.setDescription('The value of this object is used for clearing all the port related statistics counters. clear(2) : Clears the Counters. noaction(1) : No action taken.')
rcvFramesDiscNoChan = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 33), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscNoChan.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscNoChan.setDescription('The number of frames received when no channel is setup.')
rcvFramesDiscOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 34), Counter32()).setUnits('Frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscOverrun.setStatus('current')
if mibBuilder.loadTexts: rcvFramesDiscOverrun.setDescription(' The number of frames discarded in Ingress direction due to FIFO overrun in HDLC Controller. This object is not applicable to MGX Release 1.x ')
rcvPortFramesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesDiscard.setStatus('current')
if mibBuilder.loadTexts: rcvPortFramesDiscard.setDescription(' Number of framesdiscarded in the ingress direction by the port ')
xmtPortFramesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDE.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesDE.setDescription(' Number of frames transmitted in the egress direction by the port with DE bit set to 1 ')
xmtPortBytesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDE.setStatus('current')
if mibBuilder.loadTexts: xmtPortBytesDE.setDescription(' Number of bytes transmitted in the egress direction by the port with DE bit set to 1 ')
rcvPortBytesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortBytesDE.setStatus('current')
if mibBuilder.loadTexts: rcvPortBytesDE.setDescription(' Number of bytes received in the ingress direction by the port with DE bit set to 1 ')
xmtPortFramesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDiscXceedDEThresh.setStatus('current')
if mibBuilder.loadTexts: xmtPortFramesDiscXceedDEThresh.setDescription(' Number of frames discarded in the egress direction by the port due to exceeded DE Threshold ')
xmtPortBytesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDiscXceedDEThresh.setStatus('current')
if mibBuilder.loadTexts: xmtPortBytesDiscXceedDEThresh.setDescription(' Number of bytes discarded in the egress direction by the port due to exceeded DE Threshold ')
rcvPortBytesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortBytesDiscXceedDEThresh.setStatus('current')
if mibBuilder.loadTexts: rcvPortBytesDiscXceedDEThresh.setDescription(' Number of bytes discarded in the ingress direction by the port due to exceeded DE Threshold ')
frPortsUsedLineGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11), )
if mibBuilder.loadTexts: frPortsUsedLineGrpTable.setStatus('current')
if mibBuilder.loadTexts: frPortsUsedLineGrpTable.setDescription('This table Contains information on the DS0 time slots used in each DS1 interface.')
frPortsUsedLineGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1), ).setIndexNames((0, "CISCO-WAN-FR-PORT-MIB", "frPortsUsedLineIndex"))
if mibBuilder.loadTexts: frPortsUsedLineGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frPortsUsedLineGrpEntry.setDescription('An entry for each DS1 interface.')
frPortsUsedLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 56))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsUsedLineIndex.setStatus('current')
if mibBuilder.loadTexts: frPortsUsedLineIndex.setDescription('This object uniquely identifies the DS1 interface.')
frPortsUsedLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsUsedLine.setStatus('current')
if mibBuilder.loadTexts: frPortsUsedLine.setDescription("The value of this object provides the information on DS0 time slots used by the DS1 identified by 'frPortsUsedLineIndex' object. A bit set represents a DS0 that is used by all the logical ports defined so far for DS1 interface. The most significant byte is invalid for DS1.")
frPortServiceQueGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1), )
if mibBuilder.loadTexts: frPortServiceQueGrpTable.setStatus('current')
if mibBuilder.loadTexts: frPortServiceQueGrpTable.setDescription('The config table is for logical port interface. In FRSM-VHS, there are 256 entries for FRSM-2CT3 card and 2 entries for FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI cards and 8 entries for FRSM-HS2B-12IN1. The table is supported only in FRSM-VHS when the object egrQosFeature in the cardSpecific group is set to egrQosFeatureEnabled. ')
frPortServiceQueGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-PORT-MIB", "frServPortNum"), (0, "CISCO-WAN-FR-PORT-MIB", "portServiceQueueNo"))
if mibBuilder.loadTexts: frPortServiceQueGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frPortServiceQueGrpEntry.setDescription(' An entry for logical port.')
frServPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frServPortNum.setStatus('current')
if mibBuilder.loadTexts: frServPortNum.setDescription("This is the frame relay port number. The value of this object must match with the value of object 'portNum' in frPortCnfPortGrpTable.")
portServiceQueueNo = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("highpriorityQ", 1), ("rtVBRQ", 2), ("nrtVBRandABRQ", 3), ("uBRQ", 4), ("queue5", 5), ("queue6", 6), ("queue7", 7), ("queue8", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portServiceQueueNo.setStatus('current')
if mibBuilder.loadTexts: portServiceQueueNo.setDescription('This identifies the Q depending on the Service Type 1 High Priority Queue 2 rt VBR Queue 3 nrt VBR and ABR Queue 4 UBR Queue queue5(5) to queue8(8) are reserved for future use There are 8 queues but only four are being used as of now. ')
portEgresQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(1048575)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresQDepth.setStatus('current')
if mibBuilder.loadTexts: portEgresQDepth.setDescription('Indicates the peak Egress queue depth for the frame relay port. The total queue depth of all connections mapped to this queue should not exceed this value.')
portEgresECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(104857)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresECNThresh.setStatus('current')
if mibBuilder.loadTexts: portEgresECNThresh.setDescription('ECN threshold for the frame relay port. If the total queue depth of all connections mapped to this port queue exceeds this threshold, then the appropriate ECN bit (FECN in the downstream direction and BECN in the upstream direction) get set.')
portEgresDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(524287)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresDEThresh.setStatus('current')
if mibBuilder.loadTexts: portEgresDEThresh.setDescription('DE threshold for the frame relay port. If the total queue depth of all connections mapped to this port queue exceeds this threshold, and the DE bit is set in the incoming frame, then the frame gets dropped.')
portQBwInc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portQBwInc.setStatus('current')
if mibBuilder.loadTexts: portQBwInc.setDescription('Denotes the bandwidth increment for this port queue. The bandwidth increment is the percentage of the port bandwidth used by all connections mapped to a particular queue scaled by the value 16384.')
portBytesDiscXceedQueFull = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 7), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: portBytesDiscXceedQueFull.setStatus('current')
if mibBuilder.loadTexts: portBytesDiscXceedQueFull.setDescription('Counter maintained for the no of bytes discarded due to port queue depth exceeded.')
portBytesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 8), Counter32()).setUnits('Bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: portBytesDiscXceedDEThresh.setStatus('current')
if mibBuilder.loadTexts: portBytesDiscXceedDEThresh.setDescription('Counter maintained for the no of bytes discarded due to DE threshold exceeded.')
ciscoWanFrPortMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 44, 2))
ciscoWanFrPortMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1))
ciscoWanFrPortMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 2))
ciscoWanFrPortCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 2, 1)).setObjects(("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortConfGroup"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortStateGroup"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortStatsGroup"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortSvcGroup"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortDs0InDs1Group"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortsUsedGroup"), ("CISCO-WAN-FR-PORT-MIB", "ciscoWanFrPortServiceQueueGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortCompliance = ciscoWanFrPortCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortCompliance.setDescription('The compliance statement for objects related to Frame Relay Ports.')
ciscoWanFrPortConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 1)).setObjects(("CISCO-WAN-FR-PORT-MIB", "portNum"), ("CISCO-WAN-FR-PORT-MIB", "portLineNum"), ("CISCO-WAN-FR-PORT-MIB", "portRowStatus"), ("CISCO-WAN-FR-PORT-MIB", "portDs0ConfigBitMap"), ("CISCO-WAN-FR-PORT-MIB", "portDs0Speed"), ("CISCO-WAN-FR-PORT-MIB", "portFlagsBetweenFrames"), ("CISCO-WAN-FR-PORT-MIB", "portEqueueServiceRatio"), ("CISCO-WAN-FR-PORT-MIB", "portSpeed"), ("CISCO-WAN-FR-PORT-MIB", "portAdmin"), ("CISCO-WAN-FR-PORT-MIB", "portType"), ("CISCO-WAN-FR-PORT-MIB", "portBERTEnable"), ("CISCO-WAN-FR-PORT-MIB", "portEnhancedSIW"), ("CISCO-WAN-FR-PORT-MIB", "portM32EgrQueueThresh"), ("CISCO-WAN-FR-PORT-MIB", "portHeaderLen"), ("CISCO-WAN-FR-PORT-MIB", "portFrameChkSumType"), ("CISCO-WAN-FR-PORT-MIB", "portFileId"), ("CISCO-WAN-FR-PORT-MIB", "portOverSubEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortConfGroup = ciscoWanFrPortConfGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortConfGroup.setDescription('The collection of objects which are used to represent Frame Relay Port information.')
ciscoWanFrPortSvcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 2)).setObjects(("CISCO-WAN-FR-PORT-MIB", "portSvcStatus"), ("CISCO-WAN-FR-PORT-MIB", "portSvcInUse"), ("CISCO-WAN-FR-PORT-MIB", "portSvcShareLcn"), ("CISCO-WAN-FR-PORT-MIB", "portSvcLcnLow"), ("CISCO-WAN-FR-PORT-MIB", "portSvcLcnHigh"), ("CISCO-WAN-FR-PORT-MIB", "portSvcDlciLow"), ("CISCO-WAN-FR-PORT-MIB", "portSvcDlciHigh"), ("CISCO-WAN-FR-PORT-MIB", "portDeleteSvcs"), ("CISCO-WAN-FR-PORT-MIB", "portIngrSvcBandW"), ("CISCO-WAN-FR-PORT-MIB", "portEgrSvcBandW"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortSvcGroup = ciscoWanFrPortSvcGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortSvcGroup.setDescription('The collection of objects which are used to represent SVC characteristics of a Frame Relay Port.')
ciscoWanFrPortDs0InDs1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 3)).setObjects(("CISCO-WAN-FR-PORT-MIB", "portsUsedLine1"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine2"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine3"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine4"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine5"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine6"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine7"), ("CISCO-WAN-FR-PORT-MIB", "portsUsedLine8"), ("CISCO-WAN-FR-PORT-MIB", "portNextAvailable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortDs0InDs1Group = ciscoWanFrPortDs0InDs1Group.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortDs0InDs1Group.setDescription('The objects representing the DS0(in DS1) that are used by the frame relay logical ports.')
ciscoWanFrPortStateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 4)).setObjects(("CISCO-WAN-FR-PORT-MIB", "statePortNum"), ("CISCO-WAN-FR-PORT-MIB", "portState"), ("CISCO-WAN-FR-PORT-MIB", "portSignallingState"), ("CISCO-WAN-FR-PORT-MIB", "portOversubscribed"), ("CISCO-WAN-FR-PORT-MIB", "portIngrPercentUtil"), ("CISCO-WAN-FR-PORT-MIB", "portEgrPercentUtil"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortStateGroup = ciscoWanFrPortStateGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortStateGroup.setDescription('The collection of objects related to state information of Frame Relay Ports.')
ciscoWanFrPortStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 5)).setObjects(("CISCO-WAN-FR-PORT-MIB", "cntPortNum"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFrames"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortBytes"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesDE"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesFECN"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesBECN"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscCRCError"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscAlignmentError"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscIllegalLen"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscIllegalHeader"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesAbort"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesUnknownDLCI"), ("CISCO-WAN-FR-PORT-MIB", "rcvLastUnknownDLCI"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesTaggedFECN"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesTaggedBECN"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesTaggedDE"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesDiscXceedDEThresh"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortKbpsAIR"), ("CISCO-WAN-FR-PORT-MIB", "rcvBufNotAvailable"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFrames"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortBytes"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesFECN"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesBECN"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesDiscXceedQDepth"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortBytesDiscXceedQDepth"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesDuringLMIAlarm"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortBytesDuringLMIAlarm"), ("CISCO-WAN-FR-PORT-MIB", "xmtFramesAbort"), ("CISCO-WAN-FR-PORT-MIB", "xmtFramesUnderrun"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortKbpsAIR"), ("CISCO-WAN-FR-PORT-MIB", "xmtBufNotAvailable"), ("CISCO-WAN-FR-PORT-MIB", "portClrButton"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscNoChan"), ("CISCO-WAN-FR-PORT-MIB", "rcvFramesDiscOverrun"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortFramesDiscard"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesDE"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortBytesDE"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortBytesDE"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortFramesDiscXceedDEThresh"), ("CISCO-WAN-FR-PORT-MIB", "xmtPortBytesDiscXceedDEThresh"), ("CISCO-WAN-FR-PORT-MIB", "rcvPortBytesDiscXceedDEThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortStatsGroup = ciscoWanFrPortStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortStatsGroup.setDescription('The collection of objects related to statistics information of frame relay ports.')
ciscoWanFrPortServiceQueueGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 6)).setObjects(("CISCO-WAN-FR-PORT-MIB", "frServPortNum"), ("CISCO-WAN-FR-PORT-MIB", "portServiceQueueNo"), ("CISCO-WAN-FR-PORT-MIB", "portEgresQDepth"), ("CISCO-WAN-FR-PORT-MIB", "portEgresECNThresh"), ("CISCO-WAN-FR-PORT-MIB", "portEgresDEThresh"), ("CISCO-WAN-FR-PORT-MIB", "portQBwInc"), ("CISCO-WAN-FR-PORT-MIB", "portBytesDiscXceedQueFull"), ("CISCO-WAN-FR-PORT-MIB", "portBytesDiscXceedDEThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortServiceQueueGroup = ciscoWanFrPortServiceQueueGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortServiceQueueGroup.setDescription('The collection of objects related to service queue on frame relay ports.')
ciscoWanFrPortsUsedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 44, 2, 1, 7)).setObjects(("CISCO-WAN-FR-PORT-MIB", "frPortsUsedLineIndex"), ("CISCO-WAN-FR-PORT-MIB", "frPortsUsedLine"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrPortsUsedGroup = ciscoWanFrPortsUsedGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrPortsUsedGroup.setDescription('The collection of objects related to information on DS0 time slots used in each DS1 line.')
mibBuilder.exportSymbols("CISCO-WAN-FR-PORT-MIB", xmtPortFramesFECN=xmtPortFramesFECN, portLineNum=portLineNum, portType=portType, portHeaderLen=portHeaderLen, portsUsedLine6=portsUsedLine6, xmtPortFramesBECN=xmtPortFramesBECN, portOversubscribed=portOversubscribed, portIngrSvcBandW=portIngrSvcBandW, xmtPortFramesDiscXceedDEThresh=xmtPortFramesDiscXceedDEThresh, portSvcDlciHigh=portSvcDlciHigh, xmtFramesUnderrun=xmtFramesUnderrun, ciscoWanFrPortStateGroup=ciscoWanFrPortStateGroup, portSvcStatus=portSvcStatus, rcvPortFramesFECN=rcvPortFramesFECN, portEgrSvcBandW=portEgrSvcBandW, portFileId=portFileId, portOverSubEnable=portOverSubEnable, xmtPortFramesDiscXceedQDepth=xmtPortFramesDiscXceedQDepth, rcvLastUnknownDLCI=rcvLastUnknownDLCI, rcvPortFramesBECN=rcvPortFramesBECN, portsUsedLine4=portsUsedLine4, portEgresECNThresh=portEgresECNThresh, portBytesDiscXceedDEThresh=portBytesDiscXceedDEThresh, rcvFramesDiscAlignmentError=rcvFramesDiscAlignmentError, frPortCntPortGrpTable=frPortCntPortGrpTable, rcvFramesDiscCRCError=rcvFramesDiscCRCError, portFlagsBetweenFrames=portFlagsBetweenFrames, portSvcDlciLow=portSvcDlciLow, portEnhancedSIW=portEnhancedSIW, rcvPortBytes=rcvPortBytes, frServPortNum=frServPortNum, xmtPortFrames=xmtPortFrames, portSpeed=portSpeed, rcvBufNotAvailable=rcvBufNotAvailable, portEgresQDepth=portEgresQDepth, portNum=portNum, ciscoWanFrPortsUsedGroup=ciscoWanFrPortsUsedGroup, frPortCntPortGrpEntry=frPortCntPortGrpEntry, rcvFramesDiscNoChan=rcvFramesDiscNoChan, ciscoWanFrPortMIBConformance=ciscoWanFrPortMIBConformance, portAdmin=portAdmin, portBERTEnable=portBERTEnable, portSvcLcnLow=portSvcLcnLow, frPortsUsedLine=frPortsUsedLine, rcvPortKbpsAIR=rcvPortKbpsAIR, cntPortNum=cntPortNum, portServiceQueueNo=portServiceQueueNo, xmtBufNotAvailable=xmtBufNotAvailable, portDeleteSvcs=portDeleteSvcs, xmtPortFramesDuringLMIAlarm=xmtPortFramesDuringLMIAlarm, portsUsedLine2=portsUsedLine2, frPortsUsedLineGrpTable=frPortsUsedLineGrpTable, rcvFramesDiscIllegalLen=rcvFramesDiscIllegalLen, portSignallingState=portSignallingState, frPortStateGrpTable=frPortStateGrpTable, rcvFramesUnknownDLCI=rcvFramesUnknownDLCI, ciscoWanFrPortSvcGroup=ciscoWanFrPortSvcGroup, portsUsedLine3=portsUsedLine3, portEqueueServiceRatio=portEqueueServiceRatio, ciscoWanFrPortDs0InDs1Group=ciscoWanFrPortDs0InDs1Group, rcvPortFrames=rcvPortFrames, portRowStatus=portRowStatus, portM32EgrQueueThresh=portM32EgrQueueThresh, frPortsUsedLineGrpEntry=frPortsUsedLineGrpEntry, rcvPortFramesDiscard=rcvPortFramesDiscard, portBytesDiscXceedQueFull=portBytesDiscXceedQueFull, ciscoWanFrPortMIBCompliances=ciscoWanFrPortMIBCompliances, portEgresDEThresh=portEgresDEThresh, portSvcShareLcn=portSvcShareLcn, portIngrPercentUtil=portIngrPercentUtil, PYSNMP_MODULE_ID=ciscoWanFrPortMIB, rcvPortFramesDiscXceedDEThresh=rcvPortFramesDiscXceedDEThresh, ciscoWanFrPortServiceQueueGroup=ciscoWanFrPortServiceQueueGroup, portsUsedLine7=portsUsedLine7, xmtPortFramesDE=xmtPortFramesDE, portSvcInUse=portSvcInUse, xmtFramesAbort=xmtFramesAbort, portsUsedLine1=portsUsedLine1, statePortNum=statePortNum, portClrButton=portClrButton, rcvPortFramesTaggedDE=rcvPortFramesTaggedDE, portDs0ConfigBitMap=portDs0ConfigBitMap, portQBwInc=portQBwInc, xmtPortBytesDE=xmtPortBytesDE, xmtPortBytesDiscXceedDEThresh=xmtPortBytesDiscXceedDEThresh, frPortServiceQueGrpTable=frPortServiceQueGrpTable, portsUsedLine8=portsUsedLine8, portState=portState, portsUsedLine5=portsUsedLine5, portEgrPercentUtil=portEgrPercentUtil, portNextAvailable=portNextAvailable, frPortsUsedLineIndex=frPortsUsedLineIndex, frPortCnfPortGrp=frPortCnfPortGrp, ciscoWanFrPortMIB=ciscoWanFrPortMIB, frPortCntPortGrp=frPortCntPortGrp, frPortStateGrp=frPortStateGrp, frPortCnfPortGrpEntry=frPortCnfPortGrpEntry, rcvFramesAbort=rcvFramesAbort, rcvPortBytesDiscXceedDEThresh=rcvPortBytesDiscXceedDEThresh, xmtPortKbpsAIR=xmtPortKbpsAIR, rcvPortFramesTaggedFECN=rcvPortFramesTaggedFECN, rcvFramesDiscOverrun=rcvFramesDiscOverrun, rcvPortFramesDE=rcvPortFramesDE, rcvPortBytesDE=rcvPortBytesDE, xmtPortBytes=xmtPortBytes, xmtPortBytesDiscXceedQDepth=xmtPortBytesDiscXceedQDepth, ciscoWanFrPortConfGroup=ciscoWanFrPortConfGroup, ciscoWanFrPortCompliance=ciscoWanFrPortCompliance, ciscoWanFrPortMIBGroups=ciscoWanFrPortMIBGroups, rcvPortFramesTaggedBECN=rcvPortFramesTaggedBECN, frPortStateGrpEntry=frPortStateGrpEntry, ciscoWanFrPortStatsGroup=ciscoWanFrPortStatsGroup, portFrameChkSumType=portFrameChkSumType, portSvcLcnHigh=portSvcLcnHigh, frPortServiceQueGrpEntry=frPortServiceQueGrpEntry, frPortCnfPortGrpTable=frPortCnfPortGrpTable, xmtPortBytesDuringLMIAlarm=xmtPortBytesDuringLMIAlarm, portDs0Speed=portDs0Speed, rcvFramesDiscIllegalHeader=rcvFramesDiscIllegalHeader)

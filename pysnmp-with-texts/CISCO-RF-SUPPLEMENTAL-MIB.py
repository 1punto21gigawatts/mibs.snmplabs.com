#
# PySNMP MIB module CISCO-RF-SUPPLEMENTAL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-RF-SUPPLEMENTAL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:10:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
ConfigCopyState, = mibBuilder.importSymbols("CISCO-CONFIG-COPY-MIB", "ConfigCopyState")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
PhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "PhysicalIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Integer32, iso, Counter32, NotificationType, Counter64, TimeTicks, Unsigned32, ObjectIdentity, IpAddress, MibIdentifier, ModuleIdentity, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "iso", "Counter32", "NotificationType", "Counter64", "TimeTicks", "Unsigned32", "ObjectIdentity", "IpAddress", "MibIdentifier", "ModuleIdentity", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DateAndTime, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DateAndTime", "TruthValue", "DisplayString")
ciscoRfSupMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 198))
ciscoRfSupMIB.setRevisions(('2004-05-27 00:00', '2004-03-04 00:00', '2001-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoRfSupMIB.setRevisionsDescriptions(('Added the following scalar object to the cRfSupSystem subgroup: cRfSupSysIfCounterSync', 'Two notifications ciscoRfSupTimeChangeEvent and ciscoRfSupTimeZoneChangeEvent have been added. cRfSupNotificationsEnabled has been added to control the above objects.', 'The initial release of this MIB.',))
if mibBuilder.loadTexts: ciscoRfSupMIB.setLastUpdated('200405270000Z')
if mibBuilder.loadTexts: ciscoRfSupMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoRfSupMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-rf-mib@cisco.com')
if mibBuilder.loadTexts: ciscoRfSupMIB.setDescription("This MIB was designed to complement the CISCO-RF-MIB by providing additional optional status and configuration control for redundant CPU platforms. However, the MIB should also be applicable to redundant platforms which don't use the RF Redundancy Framework software since it makes no direct references to any CISCO-RF-MIB objects or textual conventions and no direct reference to any RF states, RF events or internal information. Glossary of terms used in this document: Active - A redundant CPU which is actively controlling the system. Running configuration - The runtime configuration of a system which reflects current configured hardware or software settings. Runtime configuration which is not stored in non-volatile memory may be lost if the system loses power. Standby - A redundant CPU which is not currently controlling the system, but which can take over control if the Active CPU fails. Startup configuration - A copy of system configuration stored in non-volatile memory which can be applied following a system powerup. For platforms where all runtime configuration is automatically stored in a non-volatile manner, the running and startup configurations are always identical. Switchover - The transfer of control from one CPU to a redundant CPU. Sync - The mirroring (or synchronizing) of system state, configuration, statistics or other information from the Active CPU to a Standby CPU to allow it to maintain full system control following a switchover.")
class RfSupSyncAdminState(TextualConvention, Integer32):
    description = 'An enumerated value which indicates the administrative state to allow user control of the syncing of database information from an Active unit to the Standby unit(s).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enableAutoSync", 1), ("disableAutoSync", 2))

class RfSupSyncOperState(TextualConvention, Integer32):
    description = 'An enumerated value which indicates the operational state for the syncing of database information from an Active unit to the Standby unit(s).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("inSync", 1), ("lastUpdateFailed", 2), ("commDown", 3), ("syncDisabled", 4), ("noStandbyPresent", 5))

ciscoRfSupMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 0))
ciscoRfSupMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 1))
cRfSupSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1))
cRfSupCpu = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2))
cRfSupAction = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 3))
cRfSupSysAvailableStartTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 1), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysAvailableStartTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysAvailableStartTime.setDescription("The date and time when this system began providing uninterrupted operation. This includes the time while either redundant unit was Active, but may also include brief intervals during switchover where the new Active unit was operational, but not yet reachable for network management purposes. It may also include intervals where no Standby unit was offering protection, as long as the Active unit was still operational. It normally changes only if an unprotected system restart occurs or if a Standby unit was forced to take over before the initial database sync was completed. However, it may also change if the system's Time of Day clock is changed or adjusted. This object will be inaccurate if the system's Time of Day clock has not been set accurately. However, it should be implemented in such a way that when the system's Time of Day clock is adjusted to an accurate setting, cRfSupSysAvailableStartTime will also adjust to show the accurate available start time.")
cRfSupSysSwitchoverTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysSwitchoverTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysSwitchoverTime.setDescription('The date and time when the last CPU switchover took place. This object will remain uninstantiated if no switchovers have taken place since the current Active CPU was initialized.')
cRfSupSysSwitchovers = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysSwitchovers.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysSwitchovers.setDescription('The number of times that switchovers have occurred since cRfSupSysAvailableStartTime. This object will remain uninstantiated if no switchovers have taken place since the current Active CPU was initialized or if a Standby unit was forced to take over before the initial database sync was completed.')
cRfSupSysRunningConfigSyncTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysRunningConfigSyncTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysRunningConfigSyncTime.setDescription("The date and time when the running configuration was last successfully synced from the current Active unit to the Standby unit. This object will remain uninstantiated if no sync has yet taken place since the current Active CPU was initialized or if a Standby unit was forced to take over before the initial database sync was completed. Since automatic running configuration syncs are event driven and can be disabled by configuration, this time doesn't directly indicate whether Standby software reflects the running configuration of the Active unit. Instead, see the cRfSupSysRunningConfigOper object to determine whether Standby running configuration is in sync with the Active CPU.")
cRfSupSysRunningConfigAdmin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 5), RfSupSyncAdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupSysRunningConfigAdmin.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysRunningConfigAdmin.setDescription("Enables/Disables automatic running configuration syncs only. Doesn't affect other types of sync activity. If set to the default value enableAutoSync, the Active unit will send the full current running configuration following any operation that changes the running configuration. Setting disableAutoSync may be useful for some maintenance and debugging operations.")
cRfSupSysRunningConfigOper = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 6), RfSupSyncOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysRunningConfigOper.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysRunningConfigOper.setDescription('The current operational state of running configuration syncs. When the value inSync is returned, it indicates that the Standby running configuration is being kept actively in sync with the Active unit.')
cRfSupSysStartupConfigSyncTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysStartupConfigSyncTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysStartupConfigSyncTime.setDescription("The date and time when the startup configuration was last successfully synced from the current Active unit to the Standby unit(s). This object will remain uninstantiated if no sync has yet taken place since the current Active CPU was initialized or if a Standby unit was forced to take over before the initial database sync was completed. For platforms where running configuration is always stored in a non-volatile manner, this object should be identical to cRfSupSysRunningConfigSyncTime. Since automatic startup configuration syncs are event driven and may be disabled by configuration, this time doesn't directly reflect whether Standby startup configuration is in sync with the Active unit. Instead, see the cRfSupSysStartupConfigOper object to determine whether Standby startup configuration is in sync with the Active unit.")
cRfSupSysStartupConfigAdmin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 8), RfSupSyncAdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupSysStartupConfigAdmin.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysStartupConfigAdmin.setDescription("Enables/Disables automatic startup configuration syncs only. Doesn't affect other types of sync activity. If set to the default value enableAutoSync, the Active unit will send the full current startup configuration to the Standby unit(s) after any operation that changes the startup configuration in non-volatile memory. This object is not applicable to systems where running configuration is always stored in non-volatile memory. Setting disableAutoSync may be useful for some maintenance and debugging operations.")
cRfSupSysStartupConfigOper = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 9), RfSupSyncOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysStartupConfigOper.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysStartupConfigOper.setDescription('The current operational state of startup configuration syncs. When the value inSync is returned, it indicates that the Standby startup configuration is being kept actively in sync with the Active unit.')
cRfSupSysBootImageSyncTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysBootImageSyncTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysBootImageSyncTime.setDescription("The date and time when the boot image memory was last successfully synced from the current Active unit to the Standby unit(s). This object will remain uninstantiated if no sync has yet taken place since the current Active CPU was initialized or if a Standby unit was forced to take over before the initial database sync was completed. Since automatic boot image memory syncs are event driven and may be disabled by configuration, this time doesn't directly reflect whether Standby boot image memory is in sync with the Active unit. Instead, see the cRfSupSysBootImageOper object to determine whether Standby boot image memory is in sync with the Active unit.")
cRfSupSysBootImageAdmin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 11), RfSupSyncAdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupSysBootImageAdmin.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysBootImageAdmin.setDescription("Enables/Disables automatic boot image memory syncs only. Doesn't affect other types of sync activity. If set to the default value enableAutoSync, the Active unit will send the full current boot image memory to the Standby unit(s) after any operation that affects the boot image. This object is not applicable for systems that don't support automatic boot image memory mirroring. Setting disableAutoSync is necessary during software upgrades for the case where the boot image memory space is too small to simultaneously hold both the old and new images.")
cRfSupSysBootImageOper = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 12), RfSupSyncOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupSysBootImageOper.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysBootImageOper.setDescription('The current operational state of boot image memory syncs. When the value inSync is returned, it indicates that Standby boot image memory is being actively mirrored from the Active unit.')
cRfSupSysStandbyBootFile = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupSysStandbyBootFile.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysStandbyBootFile.setDescription('Allow Standby unit(s) to automatically load a boot image which differs from the image specified for the Active unit. The string should be of the form <device>:<filename>. Specifying a null value indicates that Standby unit(s) should not use a different image than the Active unit. This is used during software upgrade/downgrade procedures, for platforms that support automatic syncs for boot image memory.')
cRfSupNotificationsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupNotificationsEnabled.setStatus('current')
if mibBuilder.loadTexts: cRfSupNotificationsEnabled.setDescription("This specifies whether ciscoRfSupTimeChangeEvent, ciscoRfSupTimeZoneChangeEvent notifications shall be sent when the system's clock or time zone is changed causing a change in the values of cRfSupSysAvailableStartTime or cRfSupSysSwitchoverTime objects. Notifications will be sent only if this object is set to 'true'.")
cRfSupSysIfCounterSync = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupSysIfCounterSync.setStatus('current')
if mibBuilder.loadTexts: cRfSupSysIfCounterSync.setDescription("This object configures the synchronization of Interface Statistics information from Active CPU to the Standby CPU. When this object is set to 'true', synchronization is enabled. When this object is set to 'false', synchronization is disabled.")
cRfSupCpuTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2, 1), )
if mibBuilder.loadTexts: cRfSupCpuTable.setStatus('current')
if mibBuilder.loadTexts: cRfSupCpuTable.setDescription('A table containing redundancy-related information for individual CPU cards.')
cRfSupCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupCpuUniqueIndex"))
if mibBuilder.loadTexts: cRfSupCpuEntry.setStatus('current')
if mibBuilder.loadTexts: cRfSupCpuEntry.setDescription('Information which can differ for each of the redundant CPU units in the system.')
cRfSupCpuUniqueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2, 1, 1, 1), PhysicalIndex())
if mibBuilder.loadTexts: cRfSupCpuUniqueIndex.setStatus('current')
if mibBuilder.loadTexts: cRfSupCpuUniqueIndex.setDescription('A table index which always has a unique platform-assigned value for each physical redundant unit within a particular system. This index should refer to a particular physical unit rather than a logically Active or Standby unit.')
cRfSupCpuActiveSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("nonFaulty", 0), ("nonTrafficAffectingFault", 1), ("partialTrafficAffectingFault", 2), ("fullyTrafficAffectingFault", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupCpuActiveSeverity.setStatus('current')
if mibBuilder.loadTexts: cRfSupCpuActiveSeverity.setDescription("The fault severity of a redundant unit, as calculated by software. The value zero represents a good unit with no detected faults. Higher values represent progressively more serious faults. If it's not possible to determine any current or prior severity information about a unit, the value unknown should be returned. Unlike some severity definitions, cRfSupCpuActiveSeverity should not be downgraded when it switches from being Active. The severity for a faulty Standby unit should correspond to the system impact it would have if it were made to be the Active unit, assuming the severity can be determined while Standby. The severity can be affected by either hardware or software faults with the CPU itself. It can also be affected by faults which prevent this CPU from interacting with one or more other system components (such as linecards), even when the actual faulty Field Replaceable Unit (FRU) is not the CPU itself. As a minimum, the nonFaulty and fullyTrafficAffectingFault values should be supported on any platform supporting this object. Support of the other severity values is preferred, but optional.")
cRfSupCpuInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 2, 1, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupCpuInitTime.setStatus('current')
if mibBuilder.loadTexts: cRfSupCpuInitTime.setDescription('The date and time when this redundant unit was last initialized. If the unit started out in the Standby state, this will also include the time while running as Standby.')
cRfSupActionManualSync = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("runningConfig", 2), ("startupConfig", 3), ("bootImage", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRfSupActionManualSync.setStatus('current')
if mibBuilder.loadTexts: cRfSupActionManualSync.setDescription('This variable is set to invoke a one-time manual copy of the specified information type from the Active to one or more Standby units. When read, this object returns the last command written or noAction if no action has been written to the Active unit since it was initialized. The value noAction can not be used in a write request. The result of the last requested action can be determined by reading the value of cRfSupActionLastSyncResult. The value of the cRfSupActionManualSync object can not be changed until the cRfSupActionLastSyncResult transitions to the successful or failed state.')
cRfSupActionLastSyncResult = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 198, 1, 3, 2), ConfigCopyState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRfSupActionLastSyncResult.setStatus('current')
if mibBuilder.loadTexts: cRfSupActionLastSyncResult.setDescription('Contains the result of the last Manual Sync action request. This object is instantiated only after the cRfSupActionManualSync object has been set to a value other than noAction.')
ciscoRfSupTimeChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 198, 0, 1)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysAvailableStartTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysSwitchoverTime"))
if mibBuilder.loadTexts: ciscoRfSupTimeChangeEvent.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupTimeChangeEvent.setDescription("This notification is sent on the event of system clock modification causing a change in the values of cRfSupSysAvailableStartTime or cRfSupSysSwitchoverTime objects, if cRfSupNotificationsEnabled object has value 'true'. If the system clock change is a result of a time zone change event,this notification will not be sent.")
ciscoRfSupTimeZoneChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 198, 0, 2)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysAvailableStartTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysSwitchoverTime"))
if mibBuilder.loadTexts: ciscoRfSupTimeZoneChangeEvent.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupTimeZoneChangeEvent.setDescription("This notification is sent on the event of system time zone modification causing a change in the values of cRfSupSysAvailableStartTime or cRfSupSysSwitchoverTime objects, if cRfSupNotificationsEnabled object has value 'true'.")
ciscoRfSupMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 2))
ciscoRfSupMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 1))
ciscoRfSupMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2))
ciscoRfSupMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 1, 1)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupActionGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupCpuGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupMibCompliance = ciscoRfSupMibCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRfSupMibCompliance.setDescription('The compliance statement for entities which implement the Cisco RF SUPPLEMENTAL MIB. Note: Platforms which implement the Cisco RF MIB are not required to support the RF SUPPLEMENTAL MIB.')
ciscoRfSupMibComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 1, 2)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupActionGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupCpuGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysOptionalGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupMibComplianceRev1 = ciscoRfSupMibComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRfSupMibComplianceRev1.setDescription('The compliance statement for entities which implement the Cisco RF SUPPLEMENTAL MIB. Note: Platforms which implement the Cisco RF MIB are not required to support the RF SUPPLEMENTAL MIB. ')
ciscoRfSupMibComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 1, 3)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupActionGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupCpuGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysOptionalGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupNotifGroup"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupSysOptionalSyncGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupMibComplianceRev2 = ciscoRfSupMibComplianceRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupMibComplianceRev2.setDescription('The compliance statement for entities which implement the Cisco RF SUPPLEMENTAL MIB. Note: Platforms which implement the Cisco RF MIB are not required to support the RF SUPPLEMENTAL MIB. ')
ciscoRfSupSysGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 1)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysAvailableStartTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysSwitchoverTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysSwitchovers"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysRunningConfigSyncTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysRunningConfigAdmin"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysRunningConfigOper"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysStartupConfigSyncTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysStartupConfigAdmin"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysStartupConfigOper"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysBootImageSyncTime"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysBootImageAdmin"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysBootImageOper"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysStandbyBootFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupSysGroup = ciscoRfSupSysGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupSysGroup.setDescription('The collection of RF SUPPLEMENTAL system-wide objects.')
ciscoRfSupCpuGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 2)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupCpuActiveSeverity"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupCpuInitTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupCpuGroup = ciscoRfSupCpuGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupCpuGroup.setDescription('The collection of RF SUPPLEMENTAL per-CPU objects.')
ciscoRfSupActionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 3)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupActionManualSync"), ("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupActionLastSyncResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupActionGroup = ciscoRfSupActionGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupActionGroup.setDescription('The collection of RF SUPPLEMENTAL execution actions.')
ciscoRfSupSysOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 4)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupNotificationsEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupSysOptionalGroup = ciscoRfSupSysOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupSysOptionalGroup.setDescription('The collection of optional RF SUPPLEMENTAL system-wide objects.')
ciscoRfSupNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 5)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupTimeChangeEvent"), ("CISCO-RF-SUPPLEMENTAL-MIB", "ciscoRfSupTimeZoneChangeEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupNotifGroup = ciscoRfSupNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupNotifGroup.setDescription('The collection of optional notifications issued on system time/time zone modifications.')
ciscoRfSupSysOptionalSyncGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 198, 2, 2, 6)).setObjects(("CISCO-RF-SUPPLEMENTAL-MIB", "cRfSupSysIfCounterSync"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRfSupSysOptionalSyncGroup = ciscoRfSupSysOptionalSyncGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRfSupSysOptionalSyncGroup.setDescription('The collection of optional RF SUPPLEMENTAL system wide objects that control and monitor the synchronization of information between the redundant system units.')
mibBuilder.exportSymbols("CISCO-RF-SUPPLEMENTAL-MIB", cRfSupSysSwitchoverTime=cRfSupSysSwitchoverTime, ciscoRfSupSysOptionalGroup=ciscoRfSupSysOptionalGroup, ciscoRfSupTimeChangeEvent=ciscoRfSupTimeChangeEvent, cRfSupSysStartupConfigAdmin=cRfSupSysStartupConfigAdmin, ciscoRfSupMibCompliance=ciscoRfSupMibCompliance, ciscoRfSupMibComplianceRev2=ciscoRfSupMibComplianceRev2, cRfSupSystem=cRfSupSystem, cRfSupActionLastSyncResult=cRfSupActionLastSyncResult, ciscoRfSupNotifGroup=ciscoRfSupNotifGroup, cRfSupSysRunningConfigSyncTime=cRfSupSysRunningConfigSyncTime, cRfSupSysRunningConfigOper=cRfSupSysRunningConfigOper, cRfSupCpuUniqueIndex=cRfSupCpuUniqueIndex, ciscoRfSupSysOptionalSyncGroup=ciscoRfSupSysOptionalSyncGroup, cRfSupAction=cRfSupAction, cRfSupCpuEntry=cRfSupCpuEntry, cRfSupSysAvailableStartTime=cRfSupSysAvailableStartTime, ciscoRfSupMibComplianceRev1=ciscoRfSupMibComplianceRev1, cRfSupSysBootImageSyncTime=cRfSupSysBootImageSyncTime, RfSupSyncAdminState=RfSupSyncAdminState, ciscoRfSupSysGroup=ciscoRfSupSysGroup, ciscoRfSupMibCompliances=ciscoRfSupMibCompliances, ciscoRfSupMIB=ciscoRfSupMIB, ciscoRfSupMIBObjects=ciscoRfSupMIBObjects, cRfSupSysBootImageOper=cRfSupSysBootImageOper, cRfSupCpuInitTime=cRfSupCpuInitTime, ciscoRfSupMibConformance=ciscoRfSupMibConformance, ciscoRfSupMibGroups=ciscoRfSupMibGroups, ciscoRfSupActionGroup=ciscoRfSupActionGroup, PYSNMP_MODULE_ID=ciscoRfSupMIB, cRfSupSysBootImageAdmin=cRfSupSysBootImageAdmin, cRfSupCpuTable=cRfSupCpuTable, ciscoRfSupTimeZoneChangeEvent=ciscoRfSupTimeZoneChangeEvent, RfSupSyncOperState=RfSupSyncOperState, cRfSupSysStartupConfigOper=cRfSupSysStartupConfigOper, cRfSupSysRunningConfigAdmin=cRfSupSysRunningConfigAdmin, cRfSupSysSwitchovers=cRfSupSysSwitchovers, cRfSupCpu=cRfSupCpu, cRfSupSysStandbyBootFile=cRfSupSysStandbyBootFile, ciscoRfSupCpuGroup=ciscoRfSupCpuGroup, cRfSupCpuActiveSeverity=cRfSupCpuActiveSeverity, cRfSupSysIfCounterSync=cRfSupSysIfCounterSync, cRfSupNotificationsEnabled=cRfSupNotificationsEnabled, cRfSupSysStartupConfigSyncTime=cRfSupSysStartupConfigSyncTime, cRfSupActionManualSync=cRfSupActionManualSync, ciscoRfSupMIBNotifs=ciscoRfSupMIBNotifs)

#
# PySNMP MIB module MPLS-LC-ATM-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-LC-ATM-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:14:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
AtmVpIdentifier, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
mplsInterfaceIndex, = mibBuilder.importSymbols("MPLS-LSR-STD-MIB", "mplsInterfaceIndex")
MplsAtmVcIdentifier, mplsStdMIB = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsAtmVcIdentifier", "mplsStdMIB")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ModuleIdentity, MibIdentifier, ObjectIdentity, Unsigned32, Gauge32, Integer32, Counter32, Bits, IpAddress, TimeTicks, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "ObjectIdentity", "Unsigned32", "Gauge32", "Integer32", "Counter32", "Bits", "IpAddress", "TimeTicks", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "NotificationType")
TruthValue, TextualConvention, DisplayString, RowStatus, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString", "RowStatus", "StorageType")
mplsLcAtmStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 9))
mplsLcAtmStdMIB.setRevisions(('2006-01-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLcAtmStdMIB.setRevisionsDescriptions(('Initial revision, published as part of RFC 4368.',))
if mibBuilder.loadTexts: mplsLcAtmStdMIB.setLastUpdated('200601120000Z')
if mibBuilder.loadTexts: mplsLcAtmStdMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsLcAtmStdMIB.setContactInfo(' Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-244-3051 Email: tnadeau@cisco.com Subrahmanya Hegde Postal: Cisco Systems, Inc. 225 East Tazman Drive Tel: +1-408-525-6562 Email: subrah@cisco.com General comments should be sent to mpls@uu.net ')
if mibBuilder.loadTexts: mplsLcAtmStdMIB.setDescription('This MIB module contains managed object definitions for MPLS Label-Controlled ATM interfaces as defined in [RFC3035]. Copyright (C) The Internet Society (2006). This version of this MIB module is part of RFC 4368; see the RFC itself for full legal notices.')
mplsLcAtmStdNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 9, 0))
mplsLcAtmStdObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 9, 1))
mplsLcAtmStdConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 9, 2))
mplsLcAtmStdInterfaceConfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1), )
if mibBuilder.loadTexts: mplsLcAtmStdInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdInterfaceConfTable.setDescription("This table specifies per-interface MPLS LC-ATM capability and associated information. In particular, this table sparsely extends the MPLS-LSR-STD-MIB's mplsInterfaceConfTable.")
mplsLcAtmStdInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsInterfaceIndex"))
if mibBuilder.loadTexts: mplsLcAtmStdInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for every interface capable of supporting MPLS LC-ATM. Each entry in this table will exist only if a corresponding entry in ifTable and mplsInterfaceConfTable exists. If the associated entries in ifTable and mplsInterfaceConfTable are deleted, the corresponding entry in this table must also be deleted shortly thereafter.')
mplsLcAtmStdCtrlVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 1), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdCtrlVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdCtrlVpi.setDescription('This is the VPI value over which this LSR is willing to accept control traffic on this interface.')
mplsLcAtmStdCtrlVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 2), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdCtrlVci.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdCtrlVci.setDescription('This is the VCI value over which this LSR is willing to accept control traffic on this interface.')
mplsLcAtmStdUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdUnlabTrafVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdUnlabTrafVpi.setDescription('This is the VPI value over which this LSR is willing to accept unlabeled traffic on this interface.')
mplsLcAtmStdUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdUnlabTrafVci.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdUnlabTrafVci.setDescription('This is the VCI value over which this LSR is willing to accept unlabeled traffic on this interface.')
mplsLcAtmStdVcMerge = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdVcMerge.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdVcMerge.setDescription('If set to true(1), indicates that this interface is capable of ATM VC merge; otherwise, it MUST be set to false(2).')
mplsLcAtmVcDirectlyConnected = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmVcDirectlyConnected.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmVcDirectlyConnected.setDescription('This value indicates whether an LC-ATM is directly or indirectly (by means of a VP) connected. If set to true(1), indicates that this interface is directly connected LC-ATM; otherwise, it MUST be set to false(2). Note that although it can be intimated from RFC 3057 that multiple VPs may be used, in practice only a single one is used, and therefore the authors of this MIB module have chosen to model it as such.')
mplsLcAtmLcAtmVPI = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 7), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmLcAtmVPI.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmLcAtmVPI.setDescription('This is the VPI value used for indirectly connected LC-ATM interfaces. For these interfaces, the VPI field is not available to MPLS, and the label MUST be encoded entirely within the VCI field (see [RFC3035]). If the interface is directly connected, this value MUST be set to zero.')
mplsLcAtmStdIfConfRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdIfConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdIfConfRowStatus.setDescription('This object is used to create and delete entries in this table. When configuring entries in this table, the corresponding ifEntry and mplsInterfaceConfEntry MUST exist beforehand. If a manager attempts to create an entry for a corresponding mplsInterfaceConfEntry that does not support LC-ATM, the agent MUST return an inconsistentValue error. If this table is implemented read-only, then the agent must set this object to active(1) when this row is made active. If this table is implemented writable, then an agent MUST not allow modification to its objects once this value is set to active(1), except to mplsLcAtmStdIfConfRowStatus and mplsLcAtmStdIfConfStorageType.')
mplsLcAtmStdIfConfStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 9, 1, 1, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLcAtmStdIfConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdIfConfStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent(4)' need not allow write-access to any columnar objects in the row.")
mplsLcAtmStdCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 9, 2, 1))
mplsLcAtmStdGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 9, 2, 2))
mplsLcAtmStdModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 9, 2, 1, 1)).setObjects(("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdIfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLcAtmStdModuleFullCompliance = mplsLcAtmStdModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for MPLS-LC-ATM-STD-MIB. Such devices can be monitored and also be configured using this MIB module.')
mplsLcAtmStdModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 9, 2, 1, 2)).setObjects(("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdIfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLcAtmStdModuleReadOnlyCompliance = mplsLcAtmStdModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide read-only support for MPLS-LC-ATM-STD-MIB. Such devices can be monitored but cannot be configured using this MIB module. ')
mplsLcAtmStdIfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 9, 2, 2, 1)).setObjects(("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdCtrlVpi"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdCtrlVci"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdUnlabTrafVpi"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdUnlabTrafVci"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdVcMerge"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmVcDirectlyConnected"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmLcAtmVPI"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdIfConfRowStatus"), ("MPLS-LC-ATM-STD-MIB", "mplsLcAtmStdIfConfStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLcAtmStdIfGroup = mplsLcAtmStdIfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLcAtmStdIfGroup.setDescription('Collection of objects needed for MPLS LC-ATM interface configuration.')
mibBuilder.exportSymbols("MPLS-LC-ATM-STD-MIB", mplsLcAtmStdUnlabTrafVpi=mplsLcAtmStdUnlabTrafVpi, mplsLcAtmStdConformance=mplsLcAtmStdConformance, mplsLcAtmStdMIB=mplsLcAtmStdMIB, mplsLcAtmStdModuleReadOnlyCompliance=mplsLcAtmStdModuleReadOnlyCompliance, mplsLcAtmStdNotifications=mplsLcAtmStdNotifications, mplsLcAtmStdInterfaceConfEntry=mplsLcAtmStdInterfaceConfEntry, mplsLcAtmStdCtrlVpi=mplsLcAtmStdCtrlVpi, mplsLcAtmStdModuleFullCompliance=mplsLcAtmStdModuleFullCompliance, mplsLcAtmStdCtrlVci=mplsLcAtmStdCtrlVci, mplsLcAtmStdInterfaceConfTable=mplsLcAtmStdInterfaceConfTable, mplsLcAtmStdGroups=mplsLcAtmStdGroups, mplsLcAtmStdIfConfStorageType=mplsLcAtmStdIfConfStorageType, PYSNMP_MODULE_ID=mplsLcAtmStdMIB, mplsLcAtmStdVcMerge=mplsLcAtmStdVcMerge, mplsLcAtmLcAtmVPI=mplsLcAtmLcAtmVPI, mplsLcAtmStdUnlabTrafVci=mplsLcAtmStdUnlabTrafVci, mplsLcAtmStdIfGroup=mplsLcAtmStdIfGroup, mplsLcAtmStdIfConfRowStatus=mplsLcAtmStdIfConfRowStatus, mplsLcAtmStdCompliances=mplsLcAtmStdCompliances, mplsLcAtmVcDirectlyConnected=mplsLcAtmVcDirectlyConnected, mplsLcAtmStdObjects=mplsLcAtmStdObjects)

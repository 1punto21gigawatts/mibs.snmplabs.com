#
# PySNMP MIB module CROSSSTREAM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CROSSSTREAM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:28:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, enterprises, iso, Gauge32, Counter64, ModuleIdentity, Integer32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, MibIdentifier, Bits, NotificationType, ObjectIdentity, Counter32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "enterprises", "iso", "Gauge32", "Counter64", "ModuleIdentity", "Integer32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "MibIdentifier", "Bits", "NotificationType", "ObjectIdentity", "Counter32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
artel = MibIdentifier((1, 3, 6, 1, 4, 1, 4962))
common = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 1))
device = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 1, 1))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2))
crossStream = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1))
cstrmControl = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1))
cstrmInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2))
cstrmEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3))
cstrmDiags = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4))
cstrmStreamGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5))
cstrmStreamPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6))
class ConnectionStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("inactive", 2), ("underCreation", 3), ("createAndGo", 4), ("createAndWait", 5), ("delete", 6))

class StreamDirection(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ingress", 1), ("egress", 2))

class StreamState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("active", 1), ("inactive", 2))

class StreamType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("atm", 1), ("asi", 2), ("ethernet", 3))

class StreamIndex(Integer32):
    pass

class ProgIndex(Integer32):
    pass

class PidIndex(Integer32):
    pass

class ConnectionIndex(Integer32):
    pass

deviceName = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceName.setStatus('mandatory')
if mibBuilder.loadTexts: deviceName.setDescription("Name of the Artel's Product")
deviceSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSerialNum.setDescription('Serial number of the device.')
deviceModelNum = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceModelNum.setStatus('mandatory')
if mibBuilder.loadTexts: deviceModelNum.setDescription('Model Number of the device.')
deviceFwVer = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: deviceFwVer.setDescription('Firmware version of the product in major.minor form')
deviceHwVer = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: deviceHwVer.setDescription('Hardware version of the product in major.minor form')
deviceTime = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceTime.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTime.setDescription('The current time as measured by the device. The time is specified as YYYYMMDDHHMM, where YYYY - four digits of the year MM - month (01 through 12) DD - day of month(01 through 31) HH - hours(00 through 23) MM - minutes(00 through 59)')
deviceUpTime = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: deviceUpTime.setDescription('The time when the device is intialized. The time is specified as YYYYMMDDHHMM, where YYYY - four digits of the year MM - month (01 through 12) DD - day of month(01 through 31) HH - hours(00 through 23) MM - minutes(00 through 59).')
deviceIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceIpAddress.setDescription('This object returns the current IP address of the device when read and modifies the IP address to the new value when set.')
deviceIpNetmask = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceIpNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: deviceIpNetmask.setDescription('This object returns the netmask of the interface when read and modifies the netmask when set.')
deviceGwAddress = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceGwAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceGwAddress.setDescription('This object returns the default gateway address of the device when read and modifies the default gateway when set.')
deviceHostAddress = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceHostAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceHostAddress.setDescription('This object has the host (TFTP) server ip address which is used for software upgrade.')
deviceReset = MibScalar((1, 3, 6, 1, 4, 1, 4962, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceReset.setStatus('mandatory')
if mibBuilder.loadTexts: deviceReset.setDescription("Always returns '0' when read and resets the device when set with a nonzero value")
vsarReset = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsarReset.setStatus('mandatory')
if mibBuilder.loadTexts: vsarReset.setDescription('Setting this object to 1 resets the VSAR chip and initializes the VSAR control structures by reading from NVRAM.')
vsarConfigTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 2), )
if mibBuilder.loadTexts: vsarConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsarConfigTable.setDescription('This table contains a list of configuration entries which can be loaded to VSAR chip or store current configuration to non volatile memory.')
vsarConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 2, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "vsarConfigIndex"))
if mibBuilder.loadTexts: vsarConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsarConfigEntry.setDescription('This entry contains configurationType, action specifying load/ store.')
vsarConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsarConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsarConfigIndex.setDescription('The index which points to the different VSAR configurations.')
vsarConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsarConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: vsarConfigType.setDescription('Configuration type can specify NVRAM configuration, Flash configuration etc.')
vsarConfigAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("load", 1), ("store", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsarConfigAction.setStatus('mandatory')
if mibBuilder.loadTexts: vsarConfigAction.setDescription("This specifies the action to be peformed on the configuration entry. When set is given with 'load' as action the device is loaded with the specified configuration type. If a set is given with 'store' as action, current configuration of the device is stored in the specified configuartion type.")
usedAtmStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedAtmStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: usedAtmStreamsNumber.setDescription('Currently used number of total available Tranport streams. This includes active and inactive streams')
activeAtmStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeAtmStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: activeAtmStreamsNumber.setDescription('Active Number of Transport Streams running in the system')
maxAtmStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxAtmStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxAtmStreamsNumber.setDescription('Max number of available Transport Streams available in the system')
usedAsiStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedAsiStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: usedAsiStreamsNumber.setDescription('Currently used number of total available ASI Tranport streams. This includes active and inactive streams')
activeAsiStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeAsiStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: activeAsiStreamsNumber.setDescription('Active Number of ASI Transport Streams running in the system')
maxAsiStreamsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxAsiStreamsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxAsiStreamsNumber.setDescription('Max number of available ASI Transport Streams available in the system')
usedProgsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedProgsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: usedProgsNumber.setDescription('Currently used number of programs. This includes active and inactive programs')
activeProgsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeProgsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: activeProgsNumber.setDescription('Active number of programs running in the system')
maxProgsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxProgsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxProgsNumber.setDescription('Max number of programs available in the system')
usedPidsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedPidsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: usedPidsNumber.setDescription('Currently used number of total available PIDs. This includes active and inactive PIDs')
activePidsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activePidsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: activePidsNumber.setDescription('Active number of PIDs running in the system')
maxPidsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxPidsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxPidsNumber.setDescription('Max number of available PIDs in the system')
usedConnectionsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedConnectionsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: usedConnectionsNumber.setDescription('Currently used number of total available connection objects.')
maxConnectionsNumber = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxConnectionsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: maxConnectionsNumber.setDescription('Max number of available connection objects.')
cstrmATMPhyTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 1), Integer32())
if mibBuilder.loadTexts: cstrmATMPhyTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmATMPhyTrapID.setDescription('')
cstrmATMPhyTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: cstrmATMPhyTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmATMPhyTrapStatus.setDescription('')
cstrmOAMVCTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 2), Integer32())
if mibBuilder.loadTexts: cstrmOAMVCTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmOAMVCTrapID.setDescription('')
cstrmOAMVCTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 2, 1), Integer32())
if mibBuilder.loadTexts: cstrmOAMVCTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmOAMVCTrapStatus.setDescription('')
cstrmOAMVPTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 3), Integer32())
if mibBuilder.loadTexts: cstrmOAMVPTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmOAMVPTrapID.setDescription('')
cstrmOAMVPTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 3, 1), Integer32())
if mibBuilder.loadTexts: cstrmOAMVPTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmOAMVPTrapStatus.setDescription('')
cstrmSONETTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 4), Integer32())
if mibBuilder.loadTexts: cstrmSONETTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmSONETTrapID.setDescription('')
cstrmSONETTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 4, 1), Integer32())
if mibBuilder.loadTexts: cstrmSONETTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmSONETTrapStatus.setDescription('')
cstrmActDeActTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 5), Integer32())
if mibBuilder.loadTexts: cstrmActDeActTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmActDeActTrapID.setDescription('')
cstrmActDeActTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 5, 1), Integer32())
if mibBuilder.loadTexts: cstrmActDeActTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmActDeActTrapStatus.setDescription('')
cstrmIngressPidsChangedTrapID = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 6), Integer32())
if mibBuilder.loadTexts: cstrmIngressPidsChangedTrapID.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmIngressPidsChangedTrapID.setDescription('')
cstrmIngressPidsChangedTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 6, 6, 1), Integer32())
if mibBuilder.loadTexts: cstrmIngressPidsChangedTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmIngressPidsChangedTrapStatus.setDescription('')
cstrmAirTemp = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrmAirTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmAirTemp.setDescription('The ambient temperature in degrees Centigrade at the center of the main logic board.')
cstrmCoreRegTemp = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrmCoreRegTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmCoreRegTemp.setDescription('The case temperature in degrees Centigrade of the Core 5 volt voltage regulator I.C.')
cstrm3VRegTemp = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrm3VRegTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cstrm3VRegTemp.setDescription('The case temperature in degrees Centigrade of the 3.3 volt voltage regulator I.C.')
cstrmHotICTemp = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrmHotICTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmHotICTemp.setDescription('The case temperature in degrees Centigrade of the designated hottest I.C. on the main board.')
cstrm5VCoreVoltage = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrm5VCoreVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cstrm5VCoreVoltage.setDescription('The voltage in 1/100ths of a volt of the 5 volt core regulator.')
cstrm3VCoreVoltage = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrm3VCoreVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cstrm3VCoreVoltage.setDescription('The voltage in 1/100ths of a volt of the 3.3 volt core regulator.')
cstrm3VIOVoltage = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrm3VIOVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cstrm3VIOVoltage.setDescription('The voltage in 1/100ths of a volt of the 3.3 volt I/O regulator.')
streamNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: streamNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: streamNextIndex.setDescription('To create a new entry in streamTable, management station has to first get this object value. The value 0 indicates that no assigned values are available. After each retrieval operation from management stations, agent should modify this to next unassigned index.')
streamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2), )
if mibBuilder.loadTexts: streamTable.setStatus('mandatory')
if mibBuilder.loadTexts: streamTable.setDescription("A list of stream entries. An entry specifies the stream type, name and direction. It doesn't included stream specific parameters.")
streamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: streamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: streamEntry.setDescription('An entry in the stream table. This entry is used to specify the stream type, stream direction and stream status.')
streamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: streamIndex.setStatus('mandatory')
if mibBuilder.loadTexts: streamIndex.setDescription('A unique integer handle that identifies a stream.')
ingressState = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 2), StreamState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressState.setStatus('mandatory')
if mibBuilder.loadTexts: ingressState.setDescription("This object specifies the status of the stream in ingress direction. The ingressState can be set to only 'inactive' by the management station. It is automatically set to 'active' by the agent when a valid connection is established.")
egressState = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 3), StreamState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressState.setStatus('mandatory')
if mibBuilder.loadTexts: egressState.setDescription('This object specifies the status of the stream in egress direction.')
streamType = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 4), StreamType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: streamType.setStatus('mandatory')
if mibBuilder.loadTexts: streamType.setDescription('This object specifies the type of the stream.')
streamName = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: streamName.setStatus('mandatory')
if mibBuilder.loadTexts: streamName.setDescription('This object specifies the name of the stream.')
streamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 2, 1, 6), ConnectionStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: streamStatus.setStatus('mandatory')
if mibBuilder.loadTexts: streamStatus.setDescription('This object specifies the status of stream entry.')
ingressStreamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 3), )
if mibBuilder.loadTexts: ingressStreamTable.setStatus('mandatory')
if mibBuilder.loadTexts: ingressStreamTable.setDescription('This table contains ingress stream configuration parameters, one entry per streamTable for which streamDirection is ingress.')
ingressStreamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 3, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: ingressStreamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ingressStreamEntry.setDescription('An ingress entry specifies the cell rate of the stream.')
ingressStreamCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 3, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressStreamCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: ingressStreamCellRate.setDescription(' Specifies the cellrate of the ingress stream.')
egressStreamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4), )
if mibBuilder.loadTexts: egressStreamTable.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamTable.setDescription('This table contains egress stream configuration parameters, one entry per streamTable for which streamDirection is egress.')
egressStreamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: egressStreamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamEntry.setDescription('An egress entry specifies the transport stream rate, buffer control parameters, elasticity table parameters, divisor for center rate of elasticity window.')
egressStreamTsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamTsRate.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamTsRate.setDescription('Transport rate for this egress stream.')
egressStreamNumBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamNumBufs.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamNumBufs.setDescription("Number of buffers to be allocated for this egress stream. Setting this '0' to will deallocate the memory. Modify this value to change the number of buffers from current value.")
egressStreamBufThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamBufThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamBufThreshold.setDescription('Specifies the uniform dealy threshold for this egress stream.')
egressStreamBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamBufSize.setDescription('Size of each buffer allocated in egress pool.')
egressStreamJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamJitter.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamJitter.setDescription('Enable/disable Jitter Attenuation for this egress stream.')
atmStreamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 5), )
if mibBuilder.loadTexts: atmStreamTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmStreamTable.setDescription('This table contains ATM stream configuration parameters, one entry per streamTable for which streamType is ATM.')
atmStreamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 5, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: atmStreamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmStreamEntry.setDescription('An ATM Transport Stream entry contains vpi and vci')
atmStreamVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmStreamVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmStreamVpi.setDescription(' VPI associated with the ATM Stream')
atmStreamVci = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmStreamVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmStreamVci.setDescription('VCI associated with the VCB.')
asiStreamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 6), )
if mibBuilder.loadTexts: asiStreamTable.setStatus('mandatory')
if mibBuilder.loadTexts: asiStreamTable.setDescription('This table contians ASI stream configuration parameters, one entry per streamTable for which streamType is ASI.')
asiStreamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 6, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: asiStreamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asiStreamEntry.setDescription('An ASI Transport stream entry specifies the port number.')
asiStreamPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiStreamPort.setStatus('mandatory')
if mibBuilder.loadTexts: asiStreamPort.setDescription('Physical port number of the ASI stream.')
asiStreamChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiStreamChannel.setStatus('mandatory')
if mibBuilder.loadTexts: asiStreamChannel.setDescription('Channel associated with this ASI stream.')
progNextTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 7), )
if mibBuilder.loadTexts: progNextTable.setStatus('mandatory')
if mibBuilder.loadTexts: progNextTable.setDescription('To create a new entry in progTable, management station has to first get next program index.')
progNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 7, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"))
if mibBuilder.loadTexts: progNextEntry.setStatus('mandatory')
if mibBuilder.loadTexts: progNextEntry.setDescription('This entry contains next program index that can by used by the management stations to add a program in a stream.')
progNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: progNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: progNextIndex.setDescription("Returns an index that can be associated with the given stream. The value '0' indicates that no assigned values are available. After each retrieval operation from management station, agent should modify this to next unassigned index.")
progTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8), )
if mibBuilder.loadTexts: progTable.setStatus('mandatory')
if mibBuilder.loadTexts: progTable.setDescription('A list of programs linked to one VCB. The number of entries is given by numProgs.')
progEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"), (0, "CROSSSTREAM-MIB", "progIndex"))
if mibBuilder.loadTexts: progEntry.setStatus('mandatory')
if mibBuilder.loadTexts: progEntry.setDescription('progEntry contains program number, program name, TS rate, TS len.')
progIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: progIndex.setStatus('mandatory')
if mibBuilder.loadTexts: progIndex.setDescription('A unique handle which identies a program.')
progNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: progNumber.setStatus('mandatory')
if mibBuilder.loadTexts: progNumber.setDescription('Program number which identifies a program in a VCB.')
progName = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: progName.setStatus('mandatory')
if mibBuilder.loadTexts: progName.setDescription('Human readable program name corresponding to the program number of this entry.')
progTsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: progTsRate.setStatus('mandatory')
if mibBuilder.loadTexts: progTsRate.setDescription('Aggregate tranport rate of the program.')
progTsLen = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: progTsLen.setStatus('mandatory')
if mibBuilder.loadTexts: progTsLen.setDescription('Length of the transport stream packet.')
progStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 8, 1, 6), ConnectionStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: progStatus.setStatus('mandatory')
if mibBuilder.loadTexts: progStatus.setDescription('Status of this program associated with the VCB.')
pidNextTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 9), )
if mibBuilder.loadTexts: pidNextTable.setStatus('mandatory')
if mibBuilder.loadTexts: pidNextTable.setDescription('To create a new entry pidTable, management stations has to first retrieve a next available pid index.')
pidNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 9, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"), (0, "CROSSSTREAM-MIB", "progIndex"))
if mibBuilder.loadTexts: pidNextEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pidNextEntry.setDescription('This entry contains next pid index that can by used by the mangement stations to add a pid to the given stream and program.')
pidNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pidNextIndex.setDescription("Returns an index that can be associated with the given stream and program. The value '0' indicates taht no assigned values are available. After each retrieval operation from management station, agent should modify this to next unassigned index.")
pidTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10), )
if mibBuilder.loadTexts: pidTable.setStatus('mandatory')
if mibBuilder.loadTexts: pidTable.setDescription('List of pids linked to one program. The number of entries is given by numPIDs.')
pidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "streamIndex"), (0, "CROSSSTREAM-MIB", "progIndex"), (0, "CROSSSTREAM-MIB", "pidIndex"))
if mibBuilder.loadTexts: pidEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pidEntry.setDescription('pidEntry contains pid number, remap pid number, table identifier, pid transport rate.')
pidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pidIndex.setDescription('A unique integer pid Handle identifying a PID.')
pidNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pidNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pidNumber.setDescription('pid number which uniquely identifies a PID in a program.')
pidTableID = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pidTableID.setStatus('mandatory')
if mibBuilder.loadTexts: pidTableID.setDescription('table type identifier of this PID. This is 0 - Program Association Table 1 - Program MAP Table 2 - PCR PID >2 - Check the manual.')
pidRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pidRate.setStatus('mandatory')
if mibBuilder.loadTexts: pidRate.setDescription('Tranport rate of a specific PID.')
pidStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 10, 1, 5), ConnectionStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pidStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pidStatus.setDescription('The status of this PID.')
cstrmConnNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrmConnNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmConnNextIndex.setDescription('Returns the next free Index in the connection table.')
cstrmConnTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12), )
if mibBuilder.loadTexts: cstrmConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmConnTable.setDescription(' A list of Dipersal Entries..')
cstrmConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "cstrmConnIndex"))
if mibBuilder.loadTexts: cstrmConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmConnEntry.setDescription('An cstrmConnEntry contains source program, source pid, dest program dest pid and asiStreamIndex values. This is the entry through which management station connect source programs to destination programs.')
cstrmConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cstrmConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmConnIndex.setDescription('Index to identify a Connection Table.')
ingressStreamIndexVal = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressStreamIndexVal.setStatus('mandatory')
if mibBuilder.loadTexts: ingressStreamIndexVal.setDescription('Index of the ingress stream.')
egressStreamIndexVal = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressStreamIndexVal.setStatus('mandatory')
if mibBuilder.loadTexts: egressStreamIndexVal.setDescription('Index of the egress stream')
ingressProgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressProgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ingressProgIndex.setDescription("Source program number associated with the connection table. Source program number is linked to an ingress stream. A value of 'zero' indicates that all programs in the parent stream are connected to the egress stream.")
ingressPidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressPidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ingressPidIndex.setDescription("Source PID number associated with the connection table. Source PID number is linked to an ingress stream. A value of 'zero' indicates that all pids in the parent program are connected to the egress stream.")
egressProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressProgNum.setStatus('mandatory')
if mibBuilder.loadTexts: egressProgNum.setDescription('Destination program number associated with the connection table. Destination program number is linked to an egress stream.')
egressPidNum = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressPidNum.setStatus('mandatory')
if mibBuilder.loadTexts: egressPidNum.setDescription('Destination PID number associated with the connection table. Destination PID number is linked to an egress stream.')
pcrAdjust = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcrAdjust.setStatus('mandatory')
if mibBuilder.loadTexts: pcrAdjust.setDescription('Enable/Disable PCR Time Stamp Adjustment for this connection.')
cstrmConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 12, 1, 9), ConnectionStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cstrmConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cstrmConnStatus.setDescription('Status of the this connection table.')
connectionStreamTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 13), )
if mibBuilder.loadTexts: connectionStreamTable.setStatus('mandatory')
if mibBuilder.loadTexts: connectionStreamTable.setDescription('Connection Stream table is used to traverse the stream connections.')
connectionStreamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 13, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "StreamDirection"), (0, "CROSSSTREAM-MIB", "StreamIndex"), (0, "CROSSSTREAM-MIB", "ConnectionIndex"))
if mibBuilder.loadTexts: connectionStreamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connectionStreamEntry.setDescription('This entry has the connection index for the associated stream. If the ConnectionIndex is zero, connectionStreamIndex will return first connection object for this association.')
connectionStreamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionStreamIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connectionStreamIndex.setDescription('Returns an active connection object index connected to/from the given stream index.')
connectionProgTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 14), )
if mibBuilder.loadTexts: connectionProgTable.setStatus('mandatory')
if mibBuilder.loadTexts: connectionProgTable.setDescription('Connection Prog table is used to traverse the program connections.')
connectionProgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 14, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "StreamDirection"), (0, "CROSSSTREAM-MIB", "StreamIndex"), (0, "CROSSSTREAM-MIB", "ProgIndex"), (0, "CROSSSTREAM-MIB", "ConnectionIndex"))
if mibBuilder.loadTexts: connectionProgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connectionProgEntry.setDescription('This entry has the connection index for the given program in the specified stream object. If the ConnectionIndex is zero, connectionProgIndex will return first conneciton object for this association.')
connectionProgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionProgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connectionProgIndex.setDescription('Returns an active connection object index connected to/from the given program index.')
connectionPidTable = MibTable((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 15), )
if mibBuilder.loadTexts: connectionPidTable.setStatus('mandatory')
if mibBuilder.loadTexts: connectionPidTable.setDescription('Connection pid table is used to traverse the pid connections.')
connectionPidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 15, 1), ).setIndexNames((0, "CROSSSTREAM-MIB", "StreamDirection"), (0, "CROSSSTREAM-MIB", "StreamIndex"), (0, "CROSSSTREAM-MIB", "ProgIndex"), (0, "CROSSSTREAM-MIB", "PidIndex"), (0, "CROSSSTREAM-MIB", "ConnectionIndex"))
if mibBuilder.loadTexts: connectionPidEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connectionPidEntry.setDescription('This entry has the connection index for the given pid in the specified program & stream object. If the ConnectionIndex is zero, connectionPidIndex will return first connection object for this association.')
connectionPidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4962, 2, 1, 5, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionPidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connectionPidIndex.setDescription('Returns an active connection object index connected to/from the given pid index.')
cstrmOverTemp = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,1)).setObjects(("CROSSSTREAM-MIB", "cstrmAirTemp"), ("CROSSSTREAM-MIB", "cstrmCoreRegTemp"), ("CROSSSTREAM-MIB", "cstrm3VRegTemp"), ("CROSSSTREAM-MIB", "cstrmHotICTemp"))
if mibBuilder.loadTexts: cstrmOverTemp.setDescription('A cstrmOverTemp trap signifies that one or more of the temperature sensors has exceeded its high threshhold level. The values of the 4 temperature sensors are sent in Degrees Celsius with the trap.')
cstrmCoolFail = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,2))
if mibBuilder.loadTexts: cstrmCoolFail.setDescription('A cstrmCoolFail trap signifies that a cooling system failure has occured.')
cstrmPowerMonitor = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,3)).setObjects(("CROSSSTREAM-MIB", "cstrm5VCoreVoltage"), ("CROSSSTREAM-MIB", "cstrm3VCoreVoltage"), ("CROSSSTREAM-MIB", "cstrm3VIOVoltage"))
if mibBuilder.loadTexts: cstrmPowerMonitor.setDescription('A cstrmPowerMonitor trap signifies that one or more of the voltage sensors is out of acceptable range. The values of the 3 voltage sensors are sent in 100ths of milivolts.')
cstrmATMPhyTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,4)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmATMPhyTrapID"), ("CROSSSTREAM-MIB", "cstrmATMPhyTrapStatus"))
if mibBuilder.loadTexts: cstrmATMPhyTrap.setDescription('')
cstrmOAMVPTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,5)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmOAMVPTrapID"), ("CROSSSTREAM-MIB", "atmStreamVpi"), ("CROSSSTREAM-MIB", "cstrmOAMVPTrapStatus"))
if mibBuilder.loadTexts: cstrmOAMVPTrap.setDescription('')
cstrmOAMVCTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,6)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmOAMVCTrapID"), ("CROSSSTREAM-MIB", "atmStreamVpi"), ("CROSSSTREAM-MIB", "atmStreamVci"), ("CROSSSTREAM-MIB", "cstrmOAMVCTrapStatus"))
if mibBuilder.loadTexts: cstrmOAMVCTrap.setDescription('')
cstrmSONETTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,7)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmSONETTrapID"), ("CROSSSTREAM-MIB", "cstrmSONETTrapStatus"))
if mibBuilder.loadTexts: cstrmSONETTrap.setDescription('')
cstrmActDeActTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,8)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmActDeActTrapID"), ("CROSSSTREAM-MIB", "cstrmActDeActTrapStatus"))
if mibBuilder.loadTexts: cstrmActDeActTrap.setDescription('This Trap is generated for each of Activate and Deactivate event Alarm.')
cstrmIngressPidsChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 4962, 2, 1, 3) + (0,9)).setObjects(("IF-MIB", "ifIndex"), ("CROSSSTREAM-MIB", "cstrmIngressPidsChangedTrapID"), ("CROSSSTREAM-MIB", "cstrmIngressPidsChangedTrapStatus"))
if mibBuilder.loadTexts: cstrmIngressPidsChangedTrap.setDescription('This Trap is generated for each of Activate and Deactivate event Alarm.')
mibBuilder.exportSymbols("CROSSSTREAM-MIB", asiStreamChannel=asiStreamChannel, vsarReset=vsarReset, usedProgsNumber=usedProgsNumber, connectionPidTable=connectionPidTable, maxAsiStreamsNumber=maxAsiStreamsNumber, ingressStreamEntry=ingressStreamEntry, cstrm3VIOVoltage=cstrm3VIOVoltage, pidNextEntry=pidNextEntry, ConnectionStatus=ConnectionStatus, crossStream=crossStream, streamStatus=streamStatus, activeAsiStreamsNumber=activeAsiStreamsNumber, connectionStreamEntry=connectionStreamEntry, activeProgsNumber=activeProgsNumber, ingressState=ingressState, cstrm3VCoreVoltage=cstrm3VCoreVoltage, cstrmEvents=cstrmEvents, cstrmOAMVPTrapStatus=cstrmOAMVPTrapStatus, pcrAdjust=pcrAdjust, maxConnectionsNumber=maxConnectionsNumber, cstrmActDeActTrapID=cstrmActDeActTrapID, connectionProgIndex=connectionProgIndex, cstrmStreamGroup=cstrmStreamGroup, progNextIndex=progNextIndex, cstrm3VRegTemp=cstrm3VRegTemp, deviceIpNetmask=deviceIpNetmask, connectionProgTable=connectionProgTable, StreamIndex=StreamIndex, cstrmConnIndex=cstrmConnIndex, cstrmStreamPrivate=cstrmStreamPrivate, deviceSerialNum=deviceSerialNum, progNextTable=progNextTable, deviceUpTime=deviceUpTime, cstrmOAMVCTrap=cstrmOAMVCTrap, ingressStreamCellRate=ingressStreamCellRate, maxProgsNumber=maxProgsNumber, usedAtmStreamsNumber=usedAtmStreamsNumber, device=device, pidIndex=pidIndex, ingressPidIndex=ingressPidIndex, cstrmSONETTrapID=cstrmSONETTrapID, cstrmOAMVCTrapID=cstrmOAMVCTrapID, usedAsiStreamsNumber=usedAsiStreamsNumber, atmStreamVpi=atmStreamVpi, egressStreamNumBufs=egressStreamNumBufs, cstrmOverTemp=cstrmOverTemp, activePidsNumber=activePidsNumber, cstrmSONETTrap=cstrmSONETTrap, pidNextIndex=pidNextIndex, pidStatus=pidStatus, vsarConfigType=vsarConfigType, cstrmActDeActTrapStatus=cstrmActDeActTrapStatus, deviceHostAddress=deviceHostAddress, atmStreamEntry=atmStreamEntry, asiStreamEntry=asiStreamEntry, usedConnectionsNumber=usedConnectionsNumber, atmStreamVci=atmStreamVci, egressStreamTable=egressStreamTable, streamName=streamName, deviceIpAddress=deviceIpAddress, cstrmATMPhyTrapID=cstrmATMPhyTrapID, activeAtmStreamsNumber=activeAtmStreamsNumber, egressStreamBufSize=egressStreamBufSize, streamTable=streamTable, egressStreamTsRate=egressStreamTsRate, products=products, cstrmAirTemp=cstrmAirTemp, egressStreamEntry=egressStreamEntry, cstrmOAMVCTrapStatus=cstrmOAMVCTrapStatus, ConnectionIndex=ConnectionIndex, pidTable=pidTable, progTable=progTable, egressStreamIndexVal=egressStreamIndexVal, maxPidsNumber=maxPidsNumber, artel=artel, progNextEntry=progNextEntry, cstrmConnStatus=cstrmConnStatus, cstrmIngressPidsChangedTrapStatus=cstrmIngressPidsChangedTrapStatus, progIndex=progIndex, pidNumber=pidNumber, streamType=streamType, connectionStreamIndex=connectionStreamIndex, cstrmSONETTrapStatus=cstrmSONETTrapStatus, vsarConfigTable=vsarConfigTable, cstrmInfo=cstrmInfo, progTsLen=progTsLen, pidTableID=pidTableID, cstrmATMPhyTrapStatus=cstrmATMPhyTrapStatus, cstrmConnEntry=cstrmConnEntry, streamEntry=streamEntry, cstrmControl=cstrmControl, progTsRate=progTsRate, StreamDirection=StreamDirection, cstrmActDeActTrap=cstrmActDeActTrap, progStatus=progStatus, maxAtmStreamsNumber=maxAtmStreamsNumber, cstrmPowerMonitor=cstrmPowerMonitor, deviceName=deviceName, streamIndex=streamIndex, StreamType=StreamType, progName=progName, deviceHwVer=deviceHwVer, egressStreamJitter=egressStreamJitter, pidRate=pidRate, pidEntry=pidEntry, progNumber=progNumber, cstrmCoreRegTemp=cstrmCoreRegTemp, cstrmIngressPidsChangedTrapID=cstrmIngressPidsChangedTrapID, vsarConfigIndex=vsarConfigIndex, deviceTime=deviceTime, pidNextTable=pidNextTable, connectionStreamTable=connectionStreamTable, atmStreamTable=atmStreamTable, cstrmATMPhyTrap=cstrmATMPhyTrap, StreamState=StreamState, PidIndex=PidIndex, cstrmConnNextIndex=cstrmConnNextIndex, cstrmHotICTemp=cstrmHotICTemp, usedPidsNumber=usedPidsNumber, common=common, ingressStreamTable=ingressStreamTable, cstrmConnTable=cstrmConnTable, egressPidNum=egressPidNum, ProgIndex=ProgIndex, deviceReset=deviceReset, deviceFwVer=deviceFwVer, cstrmCoolFail=cstrmCoolFail, connectionPidEntry=connectionPidEntry, cstrmOAMVPTrap=cstrmOAMVPTrap, asiStreamTable=asiStreamTable, connectionPidIndex=connectionPidIndex, progEntry=progEntry, cstrm5VCoreVoltage=cstrm5VCoreVoltage, ingressProgIndex=ingressProgIndex, cstrmIngressPidsChangedTrap=cstrmIngressPidsChangedTrap, egressProgNum=egressProgNum, connectionProgEntry=connectionProgEntry, ingressStreamIndexVal=ingressStreamIndexVal, deviceGwAddress=deviceGwAddress, egressStreamBufThreshold=egressStreamBufThreshold, cstrmDiags=cstrmDiags, deviceModelNum=deviceModelNum, streamNextIndex=streamNextIndex, vsarConfigEntry=vsarConfigEntry, asiStreamPort=asiStreamPort, egressState=egressState, cstrmOAMVPTrapID=cstrmOAMVPTrapID, vsarConfigAction=vsarConfigAction)

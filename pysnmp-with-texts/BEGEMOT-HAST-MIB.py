#
# PySNMP MIB module BEGEMOT-HAST-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BEGEMOT-HAST-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
begemot, = mibBuilder.importSymbols("BEGEMOT-MIB", "begemot")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, MibIdentifier, Counter64, Gauge32, ObjectIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, ModuleIdentity, Bits, TimeTicks, Unsigned32, IpAddress, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibIdentifier", "Counter64", "Gauge32", "ObjectIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "ModuleIdentity", "Bits", "TimeTicks", "Unsigned32", "IpAddress", "Counter32")
DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "RowStatus")
begemotHast = ModuleIdentity((1, 3, 6, 1, 4, 1, 12325, 1, 220))
begemotHast.setRevisions(('2013-04-13 00:00', '2013-07-01 00:00', '2013-12-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: begemotHast.setRevisionsDescriptions(('Initial revision.', 'Added hastResourceWorkerPid.', 'Added hastResourceLocalQueue, hastResourceSendQueue, hastResourceRecvQueue, hastResourceDoneQueue, hastResourceIdleQueue.',))
if mibBuilder.loadTexts: begemotHast.setLastUpdated('201304130000Z')
if mibBuilder.loadTexts: begemotHast.setOrganization('FreeBSD')
if mibBuilder.loadTexts: begemotHast.setContactInfo(' Mikolaj Golub Postal: Bluhera 27v 11 61146 Kharkiv Ukraine Fax: N/A E-Mail: trociny@FreeBSD.org')
if mibBuilder.loadTexts: begemotHast.setDescription('The Begemot MIB for managing HAST.')
begemotHastObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1))
hastConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 1))
hastConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastConfigFile.setStatus('current')
if mibBuilder.loadTexts: hastConfigFile.setDescription('HAST configuration file location.')
hastResourceTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2), )
if mibBuilder.loadTexts: hastResourceTable.setStatus('current')
if mibBuilder.loadTexts: hastResourceTable.setDescription('A table containing information about all HAST resources.')
hastResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1), ).setIndexNames((0, "BEGEMOT-HAST-MIB", "hastResourceIndex"))
if mibBuilder.loadTexts: hastResourceEntry.setStatus('current')
if mibBuilder.loadTexts: hastResourceEntry.setDescription('Table entry that describes one HAST resource.')
hastResourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceIndex.setStatus('current')
if mibBuilder.loadTexts: hastResourceIndex.setDescription('Resource index.')
hastResourceName = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceName.setStatus('current')
if mibBuilder.loadTexts: hastResourceName.setDescription('Resource name.')
hastResourceRole = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("undef", 0), ("init", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hastResourceRole.setStatus('current')
if mibBuilder.loadTexts: hastResourceRole.setDescription('Resource role.')
hastResourceProvName = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceProvName.setStatus('current')
if mibBuilder.loadTexts: hastResourceProvName.setDescription('Resource GEOM provider name that appears as /dev/hast/<name>.')
hastResourceLocalPath = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceLocalPath.setStatus('current')
if mibBuilder.loadTexts: hastResourceLocalPath.setDescription('Path to the local component which is used as a backend provider for the resource.')
hastResourceExtentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceExtentSize.setStatus('current')
if mibBuilder.loadTexts: hastResourceExtentSize.setDescription('Size of an extent. Extent is a block which is used for synchronization. hastd(8) maintains a map of dirty extents and extent is the smallest region that can be marked as dirty. If any part of an extent is modified, entire extent will be synchronized when nodes connect.')
hastResourceKeepDirty = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceKeepDirty.setStatus('current')
if mibBuilder.loadTexts: hastResourceKeepDirty.setDescription('Maximum number of dirty extents to keep dirty all the time. Most recently used extents are kept dirty to reduce number of metadata updates.')
hastResourceRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: hastResourceRemoteAddr.setDescription('Address of the remote hastd(8) daemon for the resource.')
hastResourceSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceSourceAddr.setStatus('current')
if mibBuilder.loadTexts: hastResourceSourceAddr.setDescription('Local address the resource is bound to.')
hastResourceReplication = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fullsync", 0), ("memsync", 1), ("async", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceReplication.setStatus('current')
if mibBuilder.loadTexts: hastResourceReplication.setDescription('Resource replication mode.')
hastResourceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("complete", 0), ("degraded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceStatus.setStatus('current')
if mibBuilder.loadTexts: hastResourceStatus.setDescription('Resource replication status.')
hastResourceDirty = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceDirty.setStatus('current')
if mibBuilder.loadTexts: hastResourceDirty.setDescription('Current number of dirty extents for the resource.')
hastResourceReads = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceReads.setStatus('current')
if mibBuilder.loadTexts: hastResourceReads.setDescription('Count of resource local read operations.')
hastResourceWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceWrites.setStatus('current')
if mibBuilder.loadTexts: hastResourceWrites.setDescription('Count of resource local write operations.')
hastResourceDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceDeletes.setStatus('current')
if mibBuilder.loadTexts: hastResourceDeletes.setDescription('Count of resource local delete operations.')
hastResourceFlushes = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceFlushes.setStatus('current')
if mibBuilder.loadTexts: hastResourceFlushes.setDescription('Count of resource local flush operations.')
hastResourceActivemapUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceActivemapUpdates.setStatus('current')
if mibBuilder.loadTexts: hastResourceActivemapUpdates.setDescription('Count of resource local activemap updates.')
hastResourceReadErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceReadErrors.setStatus('current')
if mibBuilder.loadTexts: hastResourceReadErrors.setDescription('Count of resource local read operations that failed.')
hastResourceWriteErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceWriteErrors.setStatus('current')
if mibBuilder.loadTexts: hastResourceWriteErrors.setDescription('Count of resource local write operations that failed.')
hastResourceDeleteErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceDeleteErrors.setStatus('current')
if mibBuilder.loadTexts: hastResourceDeleteErrors.setDescription('Count of resource local delete operations that failed.')
hastResourceFlushErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceFlushErrors.setStatus('current')
if mibBuilder.loadTexts: hastResourceFlushErrors.setDescription('Count of resource local flush operations that failed.')
hastResourceWorkerPid = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceWorkerPid.setStatus('current')
if mibBuilder.loadTexts: hastResourceWorkerPid.setDescription('Worker process ID.')
hastResourceLocalQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceLocalQueue.setStatus('current')
if mibBuilder.loadTexts: hastResourceLocalQueue.setDescription('Number of outstanding I/O requests to the local component.')
hastResourceSendQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceSendQueue.setStatus('current')
if mibBuilder.loadTexts: hastResourceSendQueue.setDescription('Number of outstanding I/O requests to send to the remote component.')
hastResourceRecvQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceRecvQueue.setStatus('current')
if mibBuilder.loadTexts: hastResourceRecvQueue.setDescription('Number of outstanding I/O requests waiting for response from the remote component.')
hastResourceDoneQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceDoneQueue.setStatus('current')
if mibBuilder.loadTexts: hastResourceDoneQueue.setDescription('Number of processed I/O requests to return to the kernel.')
hastResourceIdleQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 220, 1, 2, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hastResourceIdleQueue.setStatus('current')
if mibBuilder.loadTexts: hastResourceIdleQueue.setDescription('Number of request objects in the free bucket.')
mibBuilder.exportSymbols("BEGEMOT-HAST-MIB", hastResourceLocalPath=hastResourceLocalPath, hastConfig=hastConfig, hastResourceLocalQueue=hastResourceLocalQueue, hastResourceFlushErrors=hastResourceFlushErrors, hastResourceDeleteErrors=hastResourceDeleteErrors, hastResourceName=hastResourceName, hastResourceActivemapUpdates=hastResourceActivemapUpdates, hastResourceKeepDirty=hastResourceKeepDirty, hastResourceWriteErrors=hastResourceWriteErrors, hastResourceDoneQueue=hastResourceDoneQueue, hastResourceRole=hastResourceRole, hastResourceDirty=hastResourceDirty, hastResourceRemoteAddr=hastResourceRemoteAddr, hastResourceIndex=hastResourceIndex, hastResourceWorkerPid=hastResourceWorkerPid, hastResourceSendQueue=hastResourceSendQueue, hastConfigFile=hastConfigFile, hastResourceProvName=hastResourceProvName, hastResourceStatus=hastResourceStatus, hastResourceReplication=hastResourceReplication, hastResourceDeletes=hastResourceDeletes, hastResourceReadErrors=hastResourceReadErrors, hastResourceWrites=hastResourceWrites, hastResourceTable=hastResourceTable, hastResourceRecvQueue=hastResourceRecvQueue, hastResourceFlushes=hastResourceFlushes, begemotHastObjects=begemotHastObjects, hastResourceEntry=hastResourceEntry, hastResourceSourceAddr=hastResourceSourceAddr, begemotHast=begemotHast, hastResourceIdleQueue=hastResourceIdleQueue, hastResourceReads=hastResourceReads, PYSNMP_MODULE_ID=begemotHast, hastResourceExtentSize=hastResourceExtentSize)

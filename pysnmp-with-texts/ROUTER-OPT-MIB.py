#
# PySNMP MIB module ROUTER-OPT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ROUTER-OPT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:58:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, MibIdentifier, NotificationType, ModuleIdentity, enterprises, Gauge32, Unsigned32, Integer32, Counter64, iso, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibIdentifier", "NotificationType", "ModuleIdentity", "enterprises", "Gauge32", "Unsigned32", "Integer32", "Counter64", "iso", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
codex = MibIdentifier((1, 3, 6, 1, 4, 1, 449))
cdxProductSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2))
cdx6500 = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1))
cdx6500Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2))
cdx6500CfgProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1))
cdx6500PCTRouterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5))
cdx6500Statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3))
cdx6500StatProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1))
cdx6500PSTRouterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4))
cdx6500Controls = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 4))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class DisplayString(OctetString):
    pass

cdx6500PCTRarpCacheTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1), )
if mibBuilder.loadTexts: cdx6500PCTRarpCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheTable.setDescription('ARP Cache Configuration Table.')
cdx6500PCTRarpCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRarpCacheIndex"))
if mibBuilder.loadTexts: cdx6500PCTRarpCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheEntry.setDescription('A row of IP configurables')
cdx6500PCTRarpCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRarpCacheIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheIndex.setDescription('Table Index.')
cdx6500PCTRarpCacheIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 36))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpCacheIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheIfNum.setDescription('Interface Number. This must be a router Interface Number as assigned in the Interface Configuration Table (cdx6500PCTRifConfTable) entry.')
cdx6500PCTRarpCacheProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 7, 22, 50))).clone(namedValues=NamedValues(("ip", 0), ("ipx", 7), ("appleTalk", 22), ("newvalIp", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpCacheProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheProtocol.setDescription("Protocol Type. This identifies one of the routing protocols supported by the router. newvalIp : same functionality as 'ip', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRarpCacheProtocolAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpCacheProtocolAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheProtocolAd.setDescription('IP Address. The IP address of a particular host on the attached network identified by the Interface Number.')
cdx6500PCTRarpCacheMacAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpCacheMacAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpCacheMacAd.setDescription('MAC Address.The hardware MAC address of the host with the IP Address of this entry.')
cdx6500PCTRarpParamAutoRef = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamAutoRef.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamAutoRef.setDescription("Auto-Refresh. Enables/Disables the routers capacity to send an ARP request based on the entry in the translation cache before the refresh timer expires. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRarpParamRefTime = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamRefTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamRefTime.setDescription('Refresh Timeout. Changes the timeout value (in minutes) for the refresh timer. A setting of 0 turns off (disables) the refresh timer.')
cdx6500PCTRarpParamUseTime = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamUseTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamUseTime.setDescription('Usage Timeout. Changes the timeout value (in minutes) for the usage timer. A setting of 0 turns off (disables) the usage timer.')
cdx6500PCTRarpParamProxy = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamProxy.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamProxy.setDescription("Proxy ARP. Enables the router to respond as proxy for hosts on different nets reachable from the router. Normal ARP operation calls for hosts to send an ARP request only for destinations that are on the same IP network (or subnetwork) as the requester. Some IP hosts, however, ARP even for off-network IP destination hosts. This parameter enables the router to respond as a proxy for such off-network hosts, causing the source to properly send off-network packets to the router. The router will respond only if the destination network/subnetwork is in its IP Routing Table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRarpParamProxySub = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamProxySub.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamProxySub.setDescription("Proxy ARP Subnets Only. Enables the router to respond as a proxy for hosts on different subnets of the same top-level IP net as the ARP requester. This is a subset of the operation controlled with the Proxy ARP parameter. The router will respond only for a reachable destination subnet,i.e. one which is in its IP Routing Table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRaccControlTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7), )
if mibBuilder.loadTexts: cdx6500PCTRaccControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlTable.setDescription('IP Access Control Table.')
cdx6500PCTRaccControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRaccControlIndex"))
if mibBuilder.loadTexts: cdx6500PCTRaccControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlEntry.setDescription('A row of IP configurables.')
cdx6500PCTRaccControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlIndex.setDescription('Table Index.')
cdx6500PCTRaccControlType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("excluded", 0), ("included", 1), ("newvalExcluded", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlType.setDescription("Access Type. Each received IP packet is compared with all Access Control list entries in order of Entry number. If the first matching Access Control Entry is include, the packet is forwarded. If the entry is exclude, the packet is dropped. If no matching entry is found, the packet is dropped. An entry matches a packet when the source IP address, destination IP address, IP Protocol number range and TCP/UDP port number range all match the packet. newvalExcluded : same functionality as 'excluded', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRaccControlSrcAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcAd.setDescription("Source Address. IP source address to compare against a packet. An IP packet's source IP address field matches an Access Control entry when the result of logically AND-ing it with the Source Mask field equals the Source Address field. A Source Address field of 0.0.0.0 with a Source Mask field of 0.0.0.0 matches any source IP address in the packet.")
cdx6500PCTRaccControlSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcMask.setDescription('Address Mask. Address mask to be applied to a received source IP address. An address is logically AND-ed with the mask and compared with the Source Address. For example, a mask of 255.0.0.0 with a result of 129.0.0.0 will match any address with 129 in the first byte. A mask of 255.255.255.255 with a result of 129.122.3.26 matches only the IP host 129.122.3.26. A mask of 0.0.0.0 with a result of 0.0.0.0 is a wild card, and matches any IP address.')
cdx6500PCTRaccControlDstAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstAd.setDescription("Destination Address. IP destination address in dotted notation. An IP packet's destination IP address field matches an Access Control entry when the result of logically AND-ing it with the Destination Mask field equals the Destination Address field. A Destination Address field of 0.0.0.0 with a Destination Mask field of 0.0.0.0 matches any destination IP address in the packet.")
cdx6500PCTRaccControlDstMask = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstMask.setDescription("Address Mask. Address mask in dotted notation to be applied to an IP packet's destination address. The packet destination IP address is logically AND-ed with the Destination Mask field and compared with the Destination Address field. For example, a mask of 255.0.0.0 with a result of 129.0.0.0 will match any address with 129 in the first byte. A mask of 255.255.255.255 with a result of 126.122.3.26 matches only the IP host 129.122.3.26. A mask of 0.0.0.0 with a result of 0.0.0.0 is a wild card, and matches any IP address.")
cdx6500PCTRaccControlFstProt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlFstProt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlFstProt.setDescription('First Protocol. This decimal number corresponds to the protocol byte in the IP header. A packet with an IP protocol byte between the First Protocol value and Last Protocol value, inclusive, will match the entry. The First Protocol value must be less than or equal to the Last Protocol field value. A First Protocol of 0 and a Last Protocol of 255 will match all IP packets. Commonly used IP protocol numbers are 1 for ICMP, 6 for TCP, 8 for EGP, 17 for UDP and 89 for OSPF.')
cdx6500PCTRaccControlLstProt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlLstProt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlLstProt.setDescription('Last Protocol. This decimal number corresponds to the protocol byte in the IP header.A packet with a protocol value in the specified range will match. This parameter defines the upper value of this range, and must be greater than or equal to the First Protocol field value. A Protocol range of 0 to 255 will match all IP packets. Commonly used protocol numbers are 1 for ICMP, 6 for TCP, 8 for EGP, 17 for UDP and 89 for OSPF.')
cdx6500PCTRaccControlFstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlFstPort.setStatus('deprecated')
if mibBuilder.loadTexts: cdx6500PCTRaccControlFstPort.setDescription("First Port. This decimal number corresponds to a UDP or TCP port number.A UDP or TCP packet will match an Access Control Entry when its UDP/TCP port number is at or above the entry's First Port value, and at or below the Last Port value. An entry with a First Port value of 0 and a Last Port value of 65535 will match all packets. Commonly used port numbers are 21 for FTP, 23 for Telnet, 25 for SMTP, 513 for rlogin, 520 for RIP, and 600 for X.")
cdx6500PCTRaccControlLstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRaccControlLstPort.setStatus('deprecated')
if mibBuilder.loadTexts: cdx6500PCTRaccControlLstPort.setDescription("Last Port. This decimal number corresponds to a UDP or TCP port number. A UDP or TCP packet will match an Access Control Entry when its UDP/TCP port number is at or above the entry's First Port value, and at or below the Last Port value. An entry with a First Port value of 0 and a Last Port value of 65535 will match all packets. Commonly used port numbers are 21 for FTP, 23 for Telnet, 25 for SMTP, 513 for rlogin, 520 for RIP, and 600 for X.")
cdx6500PCTRaccControlSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlSrcPort.setDescription("Source Port Range. This specifies the range (or set of ranges) of port numbers to which the packet's source socket number is compared. A range of 0-65535 will match all packets.A maximum of 8 ranges are permitted to be configured in this list.")
cdx6500PCTRaccControlDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlDstPort.setDescription("Destination Port Range. This specifies the range (or set of ranges) of port numbers to which the packet's destination socket number is compared. A range of 0-65535 will match all packets.A maximum of 8 ranges are permitted to be configured in this list.")
cdx6500PCTRaccControlInIniface = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlInIniface.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlInIniface.setDescription('Inbound Interface List. This parameter specifies a list of interfaces. The filter is applied to packets received on these interfaces. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same flow definitions. Ex: 1,5,7-10,20-25,31 ALL : This option is a wildcard used to match all interfaces. NONE : This indicates that the filter action will not be applied on any interface. INT : This option is a wild card entry used to match internally generated traffic such as Ping, Telnet, SNMP, SOTCP. ALL-PLUS-INT : This option is a wild card entry used to match all interfaces and internally generated traffic.')
cdx6500PCTRaccControlOutIniface = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlOutIniface.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlOutIniface.setDescription('Outbound Interface List. This parameter specifies a list of interfaces. The filter is applied to packets sent on these interfaces. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same flow definitions. Ex: 1,5,7-10,20-25,31 ALL : This option is a wildcard used to match all interfaces. NONE : This indicates that the filter action will not be applied on any interface.')
cdx6500PCTRaccControlInLcon = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlInLcon.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlInLcon.setDescription('Inbound LCON List. This parameter specifies a list of LCONS. The filter is applied to packets received on these LCONs. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same flow definitions. Ex: 1,5,7-10,20-25,31 ALL : This option is a wildcard used to match all LCONs. NONE : This indicates that the filter action will not be applied on any LCON.')
cdx6500PCTRaccControlOutLcon = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 7, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRaccControlOutLcon.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRaccControlOutLcon.setDescription('Outbound LCON List. This parameter specifies a list of LCONS. The filter is applied to packets sent on these LCONs. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same flow definitions. Ex: 1,5,7-10,20-25,31 ALL : This option is a wildcard used to match all LCONs. NONE : This indicates that the filter action will not be applied on any LCON.')
cdx6500PCTRAcceptRIPRouteTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 8), )
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteTable.setStatus('obsolete')
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteTable.setDescription('IP Accept RIP Route Table. This table is now called Rip Route Control Table. Access RIP Route Control Table to get these values')
cdx6500PCTRAcceptRIPRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 8, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRAcceptRIPRouteIndex"))
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteEntry.setStatus('obsolete')
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteEntry.setDescription('IP Accept RIP Route Table. This table is now called Rip Route Control Table. Access RIP Route Control Table to get these values')
cdx6500PCTRAcceptRIPRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteIndex.setStatus('obsolete')
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteIndex.setDescription('Table Index.')
cdx6500PCTRAcceptRIPRouteIpNet = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 8, 1, 2), IpAddress())
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteIpNet.setStatus('obsolete')
if mibBuilder.loadTexts: cdx6500PCTRAcceptRIPRouteIpNet.setDescription('This parameter is now the part of Rip route control Table. IP Network/subnet. IP address which identifies a destination network or subnetwork for which RIP route information is accepted. The route is accepted from any received RIP packet, and overrides any disabled Learn Net Route or Learn Subnet Route setting.')
cdx6500PCTRifConfTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9), )
if mibBuilder.loadTexts: cdx6500PCTRifConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfTable.setDescription('IP Interface Table.')
cdx6500PCTRifConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRifConfIndex"))
if mibBuilder.loadTexts: cdx6500PCTRifConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfEntry.setDescription('A row of IP configurables.')
cdx6500PCTRifConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfIndex.setDescription('Table Index.')
cdx6500PCTRifConfIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfIfNum.setDescription('Interface Number. Each interface must be assigned an Interface Number. Interface Numbers 1 through 4 are for the LAN ports. Interface numbers 5 through 36 are reserved for Lan Connections, which are virtual circuit links over WAN networks such as X.25 or Frame Relay to other routers.')
cdx6500PCTRifConfIpAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfIpAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfIpAd.setDescription('IP Address. This parameter defines the 32-bit IP host address of the router on the associated interface. IP Addresses are considered to consist of a network part, a subnetwork part, and a host number. All IP routers and hosts on a LAN must be assigned the same network/subnetwork part for their IP address. The serial links (LAN connections) between routers must also be assigned an IP network/subnetwork number, and the IP Address assigned on both sides of a serial link must have the same network (and subnetwork) part.')
cdx6500PCTRifConfAdMask = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfAdMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfAdMask.setDescription('Address Mask. This parameter is entered in dotted notation and configures the 32-bit IP Subnetwork Address Mask associated with network to which the interfaces attaches. The subnetwork address mask has 1 bit for the bits which form the network and subnetwork portions of the IP address. For example, if the interface is on a class B network such as 128.185.0.0, and the third byte is used to select a subnet (e.g. 128.185.100.0), the mask should be set to 255.255.255.0. All IP devices on a subnetted network must be configured with the same subnetwork address mask.')
cdx6500PCTRifConfOvrDefRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfOvrDefRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfOvrDefRoute.setDescription("Override Default Route.Enables the router to override the configured Default Gateway when it receives a RIP update from another router advertising the default route of 0.0.0.0 with a cheaper metric than the configured Default Gateway Metric. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfOvrStatRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfOvrStatRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfOvrStatRoute.setDescription("Override Static Route. Enables/Disables the receipt of RIP information on this interface to override the router's statically configured routing information, providing the cost of the RIP information is cheaper. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfSndgDefRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgDefRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgDefRoute.setDescription("Advertise Default Route. Enables/Disables this router advertising the default route of 0.0.0.0 on this interface. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfSndgNetRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgNetRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgNetRoute.setDescription("Advertise Network Routes. Enables/Disables advertisement of directly-attached networks and learned IP network routes on RIP updates transmitted on this interface. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfSndgSubRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgSubRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgSubRoute.setDescription("Advertise Subnet Routes. Enables/Disables the inclusion of all subnet routes within RIP updates sent on this interface. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfSndgStatRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgStatRoute.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSndgStatRoute.setDescription("Advertise Static/Direct Routes. Enables/Disables the inclusion of all statically configured and directly connected routes within RIP updates sent on this interface. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfRcvgRipPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgRipPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgRipPkts.setDescription("Accept RIP. Enables/Disables the processing of RIP updates received on this interface. This is normally enabled whenever RIP is enabled. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfRcvgDynNets = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgDynNets.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgDynNets.setDescription("Learn Network Routes. Enables/Disables the learning of new network-level routes received from neighboring routers on this interface's network. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfRcvgDynSubs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgDynSubs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfRcvgDynSubs.setDescription("Learn Subnet Routes. Enables/Disables the learning of new subnet-level routes received from neighboring routers on this interface's network. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfTagAsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfTagAsNum.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfTagAsNum.setDescription("AS Number. Specifies a tag to be associated with RIP information received on this interface. Tags are used to group routes together for later readvertisement via EGP, where the tag is treated as if it were a route's source Autonomous System. Tags are also propagated by the OSPF routing protocol.")
cdx6500PCTRifConfBcastStyle = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("network", 0), ("local", 1), ("newvalNetwork", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfBcastStyle.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfBcastStyle.setDescription("Broadcast Style. Specifies the convention for addressing IP broadcasts to all other hosts on the attached network. LOCAL broadcast style means that the Broadcast Fill Pattern (1s or 0s) fills all 32 bits of the IP broadcast address. NET broadcast style means that the Network and subnetwork portion of the IP broadcast address is set to the interface's network number, and the Broadcast Fill pattern fills only the host portion. Examples: LOCAL 1-fill: 255.255.255.255 LOCAL 0-fill: 0.0.0.0 NET 1-fill: 128.185.255.255 NET 0-fill: 128.185.0.0 All IP devices on a network must be configured with the same IP broadcast address convention. newvalNetwork : same functionality as 'network', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfBcastFill = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfBcastFill.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfBcastFill.setDescription('Broadcast Fill Pattern. Specifies the IP broadcast fill pattern the router will use when broadcasting on this interface. See Broadcast Style, cdx6500PCTRifConfBcastStyle.')
cdx6500PCTRifMaxIpMTUSize = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(576, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifMaxIpMTUSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifMaxIpMTUSize.setDescription('Specifies the Maximum Transmission Unit to be used.')
cdx6500PCTRifConfSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSplitHorizon.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSplitHorizon.setDescription("This parameter enables/disables the IP RIP split horizon. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifConfSr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifConfSr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifConfSr.setDescription("This parameter enables/disables the IP use of a RIF field in Token Ring networks for ARPs and RIPs. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifRipMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifRipMetric.setDescription('The cost,in number of hops to receive a packet through this interface. This is the cost of direct route in this interface.')
cdx6500PCTRifSendRipVer = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifSendRipVer.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifSendRipVer.setDescription('Send RIP Version. VER1 - send RIP Version 1 updates, VER2-B - send RIP Version 2 updates as broadcast, VER2-M - send RIP Version 2 updates as multicast.')
cdx6500PCTRifSendAggRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifSendAggRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifSendAggRoutes.setDescription('When disabled, this parameter indicates that when sending routes to this interface, aggregated routing information is converted into non aggregated routing information.')
cdx6500PCTRifAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifAuthType.setDescription('This defines the type of authenticaton to be used for RIPv2 Packets.')
cdx6500PCTRifAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifAuthKey.setDescription('This is the Authentication key sent in the RIP packet.')
cdx6500PCTRifOnDemandRip = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifOnDemandRip.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifOnDemandRip.setDescription('Enable : Enables on demand RIP for the interface Disable : Disables on demand RIP for the interface.')
cdx6500PCTRifTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("change", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifTrigUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifTrigUpdate.setDescription('None : No triggered updates will be sent Changes : Triggered updates will be sent with only the changed routing table entries. Full : Triggered updates will be sent with all the entries in the routing table.')
cdx6500PCTRifSecPrdBcastIntv = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 65529))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifSecPrdBcastIntv.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifSecPrdBcastIntv.setDescription('Full RIP updates will be sent periodically with the time interval configured in seconds.')
cdx6500PCTRifRoutInvldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65530))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifRoutInvldTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifRoutInvldTime.setDescription('Specifies time in sec after which the route will be marked unreachable.The time interval should be a multiple of 10.')
cdx6500PCTRifRoutFlushTime = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65530))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifRoutFlushTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifRoutFlushTime.setDescription('Specifies time in sec after which the route will be deleted from the routing table.The time interval should be a multiple of 10.')
cdx6500PCTRifRdpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifRdpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifRdpEnable.setDescription("Enables/Disables the advertising of this interface's address for Router Discovery (RFC 1256).")
cdx6500PCTRifRdpLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 9, 1, 31), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRifRdpLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifRdpLevel.setDescription("Specifies the preferability of this interface's address as the default router address on the interface's subnet. Range : 0 - 0xffffffff.")
cdx6500PCTRbootpServTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 10), )
if mibBuilder.loadTexts: cdx6500PCTRbootpServTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRbootpServTable.setDescription('IP BOOTP Server Table.')
cdx6500PCTRbootpServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 10, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRbootpServIndex"))
if mibBuilder.loadTexts: cdx6500PCTRbootpServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRbootpServEntry.setDescription('A row of IP configurables.')
cdx6500PCTRbootpServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRbootpServIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRbootpServIndex.setDescription('Table Index.')
cdx6500PCTRbootpServAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRbootpServAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRbootpServAd.setDescription('BOOTP Server Address. Adds a BootP server IP address (in dotted notation) to the routers configuration (the router will forward BootP requests to the specified BootP server). This must be used in conjunction with the BootP Forwarding command under the IP Parameters menu. There are no defaults for this command and valid address must be entered.')
cdx6500PCTRegpAsTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11), )
if mibBuilder.loadTexts: cdx6500PCTRegpAsTable.setStatus('optional')
if mibBuilder.loadTexts: cdx6500PCTRegpAsTable.setDescription('IP EGP AS Information Table.')
cdx6500PCTRegpAsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRegpAsIndex"))
if mibBuilder.loadTexts: cdx6500PCTRegpAsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsEntry.setDescription('A row of IP configurables.')
cdx6500PCTRegpAsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRegpAsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsIndex.setDescription('Table Index.')
cdx6500PCTRegpAsNeighAs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpAsNeighAs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsNeighAs.setDescription('Neighboring AS. The number of the Autonomous System to which routing information wil be exchanged. For a value of 0, the default EGP exchange is defined.')
cdx6500PCTRegpAsInterchFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpAsInterchFlag.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsInterchFlag.setDescription("Interchange Flag. Defines the permissible exchange of EGP route information. IN causes all routes received from the neighboring AS to be readvertised via OSPF and RIP. OUT causes all internal known routes to be advertised to EGP. OFF indicates the particular IP networks to be re-advertised are controlled with the Output-Interchange and Input-Interchange configurations. OFF is the recommended configuration. newvalOff : same functionality as 'off', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRegpAsUseEgMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpAsUseEgMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsUseEgMetric.setDescription("Use EGP Metric. This parameter is ON or OFF. When ON, the re-advertised cost is the same as the originally learned cost. For IN interchanges, the EGP cost metric is reported as the RIP/OSPF cost. For OUT interchanges, the RIP/OSPF cost metric is reported as the EGP cost. If this parameter is OFF, the Default Metric parameter of this record is always reported as the cost. newvalOff : same functionality as 'off', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRegpAsDefMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpAsDefMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpAsDefMetric.setDescription('Default Metric. The default cost used for readvertisements. This is usually interpreted as a number of hops. For IN interchanges, this means all routes will be readvertised by OSPF and RIP with the Default Metric cost. In the OUT direction, this means all routes in the RIP/OSPF routing table will be advertised to EGP with the given cost.')
cdx6500PCTRegpNeighTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 12), )
if mibBuilder.loadTexts: cdx6500PCTRegpNeighTable.setStatus('optional')
if mibBuilder.loadTexts: cdx6500PCTRegpNeighTable.setDescription('IP EGP Neighbor Table.')
cdx6500PCTRegpNeighEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 12, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRegpNeighIndex"))
if mibBuilder.loadTexts: cdx6500PCTRegpNeighEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpNeighEntry.setDescription('A row of IP configurables.')
cdx6500PCTRegpNeighIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRegpNeighIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpNeighIndex.setDescription('Table Index.')
cdx6500PCTRegpNeighIdAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 12, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpNeighIdAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpNeighIdAd.setDescription('Neighbor IP Address. IP address of an EGP neighbor in dotted notation.')
cdx6500PCTRegpNeighAs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 12, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRegpNeighAs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRegpNeighAs.setDescription('Neighboring AS. Autonomous System number of the EGP neighbor.')
cdx6500PCTRipParamBootpFwdg = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpFwdg.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpFwdg.setDescription("BOOTP Forwarding. Enables/Disables the forwarding of BootP requests. BOOTP (Boot Parameters) is a protocol that allows workstations to obtain their startup operating system software and other parameters from a BOOTP Server host on the IP network. If enabled, the location of the BOOTP servers must be configured in the cdx6500PCTRbootpServTable MIB table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRipParamBootpMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpMaxHops.setDescription('BOOTP Max Allowed Metric. The maximum cost metric (hop count) a BootP request is allowed to attain before being discarded. This is NOT the maximum number of IP hops to the BootP server.')
cdx6500PCTRipParamBootpSbf = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpSbf.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamBootpSbf.setDescription('BOOTP Seconds Before Forward. The number of seconds the router will wait for a BOOT request to be repeated before forwarding the request to BOOTP Server.')
cdx6500PCTRipParamEgpSysNum = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamEgpSysNum.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamEgpSysNum.setDescription("EGP System Number. Configures the router's Autonomous System Number, as assigned by the Internet Network Information Center. The Exterior Gateway Protocol (EGP) is used to communicate with the Internet backbone. Usually, all of the routers for one company are considered in a single Autonomous System (AS), and all must have the same EGP Autonomous system number. EGP is used by the one (or two, for backup) of a company's gateway routers that connect to an administered Internet backbone such as Milnet or NSFnet.")
cdx6500PCTRipParamEgpReadvert = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamEgpReadvert.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamEgpReadvert.setDescription("EGP Readvertise. Globally Enables/Disables the readvertisement of EGP routes which were originally learned from EGP. When Enabled, the learned routes are advertised locally with RIP or OSPF. The particular EGP neighbors from which routes are learned are specified with the cdx6500PCTRegpAsTable table. The particular networks which are learned can be specified with the cdx6500PCTRinInterchTable table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRipParamRip = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamRip.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamRip.setDescription("RIP Enable. Globally Enables/Disables RIP protocol processing for the router. The Routing Information Protocol (RIP) was the original internal gateway routing protocol used for IP networks, and is suitable for moderate size organization networks. An organization may operate both RIP and OSPF simultaneously. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRipParamRipOrigDef = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamRipOrigDef.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamRipOrigDef.setDescription("Originate Default Route. Enables origination and RIP advertisement of the default IP route 0.0.0.0. Default route advertisements must also be explicitly enabled for each interface. The router will originate the default route only when it has EGP-derived or external OSPF routes in its routing table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRipParamAdvDefMetCost = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamAdvDefMetCost.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamAdvDefMetCost.setDescription('Advertised Default Metric Cost. Sets the cost metric (usually the number of hops) that RIP will advertise for the default route of 0.0.0.0. A metric of 16 advertises that the default route is unreachable.')
cdx6500PCTRipParamNextHopDefGway = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamNextHopDefGway.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamNextHopDefGway.setDescription("Default Gateway. The IP address of the default gateway -this- router will use when a packet's destination route is otherwise unknown. The next hop must be to a router on a directly attached network.")
cdx6500PCTRipParamDistDefGway = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamDistDefGway.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamDistDefGway.setDescription("Default Gateway Metric. The cost metric for a transmission to this router's default gateway, usually given as the number of network hops.")
cdx6500PCTRipParamRoutTableSize = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamRoutTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamRoutTableSize.setDescription('Routing Table Size. The maximum number of routes that may be stored in the IP routing table.')
cdx6500PCTRipParamDirBcast = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamDirBcast.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamDirBcast.setDescription("Directed Broadcast. Enables/Disables the forwarding of IP packets whose destination is a non-local (remote LAN) broadcast address. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRipParamInternalNetMask = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamInternalNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamInternalNetMask.setDescription('This parameter is entered in dotted notation and configures the 32-bit IP Subnetwork Address Mask associated with the Internal interface created when the Internal Address is added to the router configuration parameters. The Internal Network address is derived from the configured Internal address and Internal Network Mask parameter.')
cdx6500PCTRipParamInternalIpAd = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 26), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamInternalIpAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamInternalIpAd.setDescription('This is an IP Address that becomes the Default IP Address for the router. The Default IP Address is used as the IP source address of PING and ICMP frames originated from the router to unnumbered interfaces and it is the reported IP Address in SNMP Trap frames. A Internal Network is added to the router routing table with the network address derived from the configured Internal address and Internal Network Mask parameter. If Internal IP Address is left undefined or the network part of this address matches network address of the configured router interfaces, Default IP Address becomes the IP address of the lowest numbered operational interface of the router.')
cdx6500PCTRipParamCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamCacheSize.setDescription('IP Route Cache Size. The maximum number of entries that may be stored in the IP Route cache. The IP Route Cache holds the destination addresses of recently received packets and for each entry maintains a count of packets forwarded to that destination.')
cdx6500PCTRipParamReasmBuffSize = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2048, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamReasmBuffSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamReasmBuffSize.setDescription("Reassembly Buffer Size. Sets the size (in bytes) of the IP fragment reassembly buffers. It must be set greater than the size of the largest IP packet to be transmitted on the organization's network.")
cdx6500PCTRipParamAccessCntrl = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipParamAccessCntrl.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipParamAccessCntrl.setDescription("Access Control. Globally enables or disables operation of the IP Access Control table. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRdefSubGwayTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30), )
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayTable.setDescription('IP Default Subnet Gateway Table.')
cdx6500PCTRdefSubGwayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRdefSubGwayIndex"))
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayEntry.setDescription('A row of IP configurables.')
cdx6500PCTRdefSubGwayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayIndex.setDescription('Table Index.')
cdx6500PCTRdefSubGwaySubnetAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwaySubnetAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwaySubnetAd.setDescription('Top-Level IP Address. The top-level IP network number must be a class A, B, or C IP address. If this router receives a packet destined to an unknown subnet of that top level net, it will forward the packet to the default subnet router for that net.')
cdx6500PCTRdefSubGwayNextHopAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayNextHopAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayNextHopAd.setDescription('Next Hop to Subnet Gateway. The IP address of the next hop towards a router performing subnet routing for the top-level net of this record. This next hop must be to an IP address on a network directly connected to this router.')
cdx6500PCTRdefSubGwayDistToGway = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 30, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayDistToGway.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRdefSubGwayDistToGway.setDescription('Metric to Subnet Gateway. The cost metric for a transmission to the default subnet gateway, usually the number of network hops to reach that other router.')
cdx6500PCTRStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31), )
if mibBuilder.loadTexts: cdx6500PCTRStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRStaticRouteTable.setDescription('IP Route Table.')
cdx6500PCTRStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRipRouteIndex"))
if mibBuilder.loadTexts: cdx6500PCTRStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRStaticRouteEntry.setDescription('A row of IP configurables.')
cdx6500PCTRipRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRipRouteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipRouteIndex.setDescription('Table Index.')
cdx6500PCTRipRouteIpNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipRouteIpNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipRouteIpNetwork.setDescription('IP Network/Subnet. The IP address of a destination network or subnetwork Host addresses are not included in the route table.')
cdx6500PCTRipRouteIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipRouteIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipRouteIpMask.setDescription('IP Address Mask. The mask associated with the IP Network/Subnet address. For example: if the destination is a subnet of a class B network and the third byte of the IP address is used as the subnet portion, the address mask would be set to 255.255.255.0.')
cdx6500PCTRipRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipRouteNextHop.setDescription('Next Hop. The IP address of the next hop to the destination. The next hop itself must be on an IP network directly connected to the router.')
cdx6500PCTRipRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 31, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRipRouteCost.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRipRouteCost.setDescription('Cost. The distance or cost metric to the destination. It is interpreted as a number of hops.')
cdx6500PCTRoutInterchTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32), )
if mibBuilder.loadTexts: cdx6500PCTRoutInterchTable.setStatus('optional')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchTable.setDescription('IP Output Interchange Table.')
cdx6500PCTRoutInterchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRoutInterchIndex"))
if mibBuilder.loadTexts: cdx6500PCTRoutInterchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchEntry.setDescription('A row of IP configurables.')
cdx6500PCTRoutInterchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchIndex.setDescription('Table Index.')
cdx6500PCTRoutInterchInterchNeighAs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchInterchNeighAs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchInterchNeighAs.setDescription('Neighboring AS. The AS number assigned to an EGP neighbor. If nonzero, the value must match a Neighboring AS number entered in a IP EGP AS Information Table, cdx6500PCTRegpAsTable, entry. A value of 0 adds the route to the default Output Exchange Table, which is reported to all new EGP neighbors learned and not otherwise entered in the IP EGP AS Information table.')
cdx6500PCTRoutInterchSourceAs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchSourceAs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchSourceAs.setDescription('Source AS. A value of 0 indicates the route should be advertised regardless of the Autonomous System it was received from. A value other than 0 indicates the route should only be advertised if the route was received from the specified AS.')
cdx6500PCTRoutInterchIpNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchIpNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchIpNetwork.setDescription('IP Network. The address of the local IP network for which routing information will be advertised.')
cdx6500PCTRoutInterchUseIgpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchUseIgpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchUseIgpMetric.setDescription("Use IGP Metric. This parameter and the following Metric parameter, cdx6500PCTRoutInterchMetric, determine the cost reported to EGP of accessing the internal IP network. The two possible Interior Gateway Protocols (IGPs) are RIP or OSPF. If Use IGP metric is ON, the cost advertised to EGP will be identical to the locally reported routing table cost (from RIP or OSPF). If Use IGP metric OFF, the Metric parameter of this entry is reported. newvalOff : same functionality as 'off', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRoutInterchMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 32, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRoutInterchMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRoutInterchMetric.setDescription('Metric. A configured cost of the route to the interior network, interpreted as a hop count. This cost is reported to EGP if the the Use IGP metric parameter, cdx6500PCTRoutInterchUseIgpMetric, is OFF.')
cdx6500PCTRinInterchTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33), )
if mibBuilder.loadTexts: cdx6500PCTRinInterchTable.setStatus('optional')
if mibBuilder.loadTexts: cdx6500PCTRinInterchTable.setDescription('IP Input Interchange Table.')
cdx6500PCTRinInterchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRinInterchIndex"))
if mibBuilder.loadTexts: cdx6500PCTRinInterchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchEntry.setDescription('A row of IP configurables.')
cdx6500PCTRinInterchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRinInterchIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchIndex.setDescription('Table Index.')
cdx6500PCTRinInterchNeighAs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRinInterchNeighAs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchNeighAs.setDescription('Neighboring AS. A neighboring Autonomous System to which route information will be readvertised via OSPF and RIP. A value of 0 adds the route to the default Input Exchange Table.')
cdx6500PCTRinInterchIpNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRinInterchIpNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchIpNetwork.setDescription('IP Network. The IP address of a network for which EGP received routing information.')
cdx6500PCTRinInterchUseEgpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRinInterchUseEgpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchUseEgpMetric.setDescription("Use EGP Metric. Defines the source of the internally readvertised costs of reaching the external IP network for this entry. If ON, the readvertised cost will be identical to the cost received by the EGP protocol. If OFF, the Metric parameter of this entry is reported. newvalOff : same functionality as 'off', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRinInterchMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 33, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRinInterchMetric.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRinInterchMetric.setDescription('Metric. A configured cost of the route.')
cdx6500PCTRfilterTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 34), )
if mibBuilder.loadTexts: cdx6500PCTRfilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRfilterTable.setDescription('IP Filter Table.')
cdx6500PCTRfilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 34, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRfilterIndex"))
if mibBuilder.loadTexts: cdx6500PCTRfilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRfilterEntry.setDescription('A row of IP configurables.')
cdx6500PCTRfilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 34, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRfilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRfilterIndex.setDescription('Table Index.')
cdx6500PCTRfilterDstIpAd = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 34, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRfilterDstIpAd.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRfilterDstIpAd.setDescription('Destination IP Address. IP address of a network/subnet to filter. All packets destined for a filtered network are discarded, and no route to the filtered network is advertised.')
cdx6500PCTRfilterAdMask = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 34, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRfilterAdMask.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRfilterAdMask.setDescription('Address Mask. Network (or Subnetwork) Address mask associated with the network/subnet address to filter.')
cdx6500PCTRifState1 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState1.setStatus('optional')
if mibBuilder.loadTexts: cdx6500PCTRifState1.setDescription("Interface #1 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState2 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState2.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState2.setDescription("Interface #2 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState3 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState3.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState3.setDescription("Interface #3 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState4 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState4.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState4.setDescription("Interface #4 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState5 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState5.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState5.setDescription("Interface #5 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState6 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState6.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState6.setDescription("Interface #6 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState7 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState7.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState7.setDescription("Interface #7 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState8 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState8.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState8.setDescription("Interface #8 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState9 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState9.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState9.setDescription("Interface #9 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState10 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState10.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState10.setDescription("Interface #10 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState11 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState11.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState11.setDescription("Interface #11 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState12 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState12.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState12.setDescription("Interface #12 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState13 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState13.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState13.setDescription("Interface #13 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState14 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState14.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState14.setDescription("Interface #14 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState15 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState15.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState15.setDescription("Interface #15 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState16 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState16.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState16.setDescription("Interface #16 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState17 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState17.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState17.setDescription("Interface #17 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState18 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState18.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState18.setDescription("Interface #18 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState19 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState19.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState19.setDescription("Interface #19 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState20 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState20.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState20.setDescription("Interface #20 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState21 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState21.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState21.setDescription("Interface #21 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState22 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState22.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState22.setDescription("Interface #22 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState23 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState23.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState23.setDescription("Interface #23 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState24 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState24.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState24.setDescription("Interface #24 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState25 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState25.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState25.setDescription("Interface #25 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState26 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState26.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState26.setDescription("Interface #26 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState27 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState27.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState27.setDescription("Interface #27 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState28 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState28.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState28.setDescription("Interface #28 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState29 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState29.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState29.setDescription("Interface #29 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState30 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState30.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState30.setDescription("Interface #30 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState31 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState31.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState31.setDescription("Interface #31 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState32 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState32.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState32.setDescription("Interface #32 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState33 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState33.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState33.setDescription("Interface #33 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState34 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState34.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState34.setDescription("Interface #34 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState35 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState35.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState35.setDescription("Interface #35 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRifState36 = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifState36.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifState36.setDescription("Interface #36 State. Enable/Disable all routing operations on the interface associated with this interface number. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTReventsTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71), )
if mibBuilder.loadTexts: cdx6500PCTReventsTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsTable.setDescription('IP Events Table.')
cdx6500PCTReventsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTReventsIndex"))
if mibBuilder.loadTexts: cdx6500PCTReventsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsEntry.setDescription('A row of IP configurables.')
cdx6500PCTReventsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTReventsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsIndex.setDescription('Table Index.')
cdx6500PCTReventsSubsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 50))).clone(namedValues=NamedValues(("arp", 0), ("ip", 1), ("icmp", 2), ("udp", 3), ("rip", 4), ("egp", 5), ("ospf", 6), ("ipx", 7), ("tkr", 8), ("eth", 9), ("newvalArp", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTReventsSubsystem.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsSubsystem.setDescription("Protocol. This field selects one of the protocols supported by the router. The event messages are controlled on a per-protocol basis. newvalArp : same functionality as 'arp', new enumeration added for RFC1155 compatibility.")
cdx6500PCTReventsPerPktTrace = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTReventsPerPktTrace.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsPerPktTrace.setDescription("Per Packet Trace. If enabled, reports an event for every packet processed by the subsytem. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTReventsUnusualOper = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTReventsUnusualOper.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsUnusualOper.setDescription("Unusual Operation. Enables/Disables reporting of unusual conditions such as detected packet format errors. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTReventsCommonOper = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 71, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("newvalDisabled", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTReventsCommonOper.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTReventsCommonOper.setDescription("Common Operation. Enables/Disables reporting of commonly occurring events, such as receiving a RIP or OSPF update packet. newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRpriorityIpTraffic = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("low", 0), ("medium", 1), ("high", 2), ("newvalLow", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRpriorityIpTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRpriorityIpTraffic.setDescription("IP Traffic Priority. Defines the priority for IP traffic relative to the rest of the traffic transmitted over WAN virtual circuits. If not configured, a default priority of HIGH is used. newvalLow : same functionality as 'low', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRpriorityIpxTraffic = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("low", 0), ("medium", 1), ("high", 2), ("newvalLow", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRpriorityIpxTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRpriorityIpxTraffic.setDescription("IPX Traffic Priority. Defines the priority for IPX traffic relative to the rest of the traffic transmitted over WAN virtual circuits. If not configured, a default priority of HIGH is used. newvalLow : same functionality as 'low', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRMaxIpInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRMaxIpInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRMaxIpInterfaces.setDescription('Specifies the maximum number of IP Interfaces that may be configured')
cdx6500PCTRAllSubnetBrcast = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRAllSubnetBrcast.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRAllSubnetBrcast.setDescription('Enables/Disables the duplication and forwarding of IP packets which are destined for all hosts on all subnetworks of an IP network.')
cdx6500PCTRIpFwdEnable = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRIpFwdEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRIpFwdEnable.setDescription('Enables/Disables the IP Broadcast Forwarding Feature.')
cdx6500PCTRUdpFwdEnable = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRUdpFwdEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRUdpFwdEnable.setDescription('Enables/Disables the UDP Broadcast Forwarding Feature.')
cdx6500PCTRpriorityAp2Traffic = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRpriorityAp2Traffic.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRpriorityAp2Traffic.setDescription("AppleTalk Traffic Priority. Defines the priority for AppleTalk traffic relative to the rest of the traffic transmitted over WAN virtual circuits. If not configured, a default priority of HIGH is used. newvalLow : same functionality as 'low', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRarpParamMaxQueue = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 79), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamMaxQueue.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamMaxQueue.setDescription('Specifies the maximum Protocol packets which can be queued awaiting address resolution.')
cdx6500PCTRarpParamTimeRetx = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 80), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdx6500PCTRarpParamTimeRetx.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRarpParamTimeRetx.setDescription('Time(in seconds) to resend an ARP Request for a protocol address awaiting resolution.')
cdx6500PCTRRIPRouteControlTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81), )
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlTable.setDescription('IP RIP Route Control Table.')
cdx6500PCTRifStateConfTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 83), )
if mibBuilder.loadTexts: cdx6500PCTRifStateConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifStateConfTable.setDescription('IP Interfaces States Table.')
cdx6500PCTRifStateConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 83, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRifStateConfIndex"))
if mibBuilder.loadTexts: cdx6500PCTRifStateConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifStateConfEntry.setDescription('A row of IP Interfaces States configurables.')
cdx6500PCTRifStateConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 83, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifStateConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifStateConfIndex.setDescription('Table Index (Corresponds to Interface Number Configured). Note: If Index N is not shown, it means Interface Number N State record is not present in the cmem.')
cdx6500PCTRifStateConfState = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 83, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("unconfigured", 2), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRifStateConfState.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRifStateConfState.setDescription("Interfaces State. Enable/Disable all routing operations on the interface associated with this interface number. (The interface number is the cdx6500PCTRifStateConfIndex) newvalDisabled : same functionality as 'disabled', new enumeration added for RFC1155 compatibility.")
cdx6500PCTRRIPRouteControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRRIPRouteControlIndex"))
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlEntry.setDescription('IP RIP Route Control Table.')
cdx6500PCTRRIPRouteControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIndex.setDescription('Table Index.')
cdx6500PCTRRIPRouteControlIpNet = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIpNet.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIpNet.setDescription('IP Network/subnet. IP address which identifies a destination network or subnetwork for which RIP route information is accepted. The route is accepted from any received RIP packet, and overrides any disabled Learn Net Route or Learn Subnet Route setting.')
cdx6500PCTRRIPRouteControlIpMsk = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIpMsk.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRIPRouteControlIpMsk.setDescription("IP Address Mask. Adress mask to be applied to the IP network/subnetwork address. The incoming route's IP address is logically 'AND-ed' with it's mask and the result is comparedwith the result of the logical 'ANDing' of the configured IP address and mask. For example, a mask of 255.0.0.0 with a result of 129.0.0.0 will match any route with 129 in the first byte. A mask of 0.0.0.0 indicates that this parameter will not be used. This parameter will only be used for RIPv2 routes.")
cdx6500PCTRRRCInIniface = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRRRCInIniface.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRRCInIniface.setDescription('Inbound interface list. This parameter specifies a list of interfaces on which the RIP route information is accepted. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same IP network/subnet address. Ex: 1, 5, 7-10, 20-25,31 ALL : This option is a wildcard used to match all interfaces. NONE : This indicates that no inbound RIP route control is required for this IP network/subnetwork address.')
cdx6500PCTRRRCOutIniface = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 81, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRRRCOutIniface.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRRRCOutIniface.setDescription('Outbound interface list. This parameter specifies a list of interfaces on which the RIP route information is advertised. A maximum of 8 ranges are permitted to be configured in this list : the list may be extended by configuring new entries with the same IP network/subnet address. Ex: 1, 5, 7-10, 20-25,31 ALL : This option is a wildcard used to match all interfaces. NONE : This indicates that no inbound RIP route control is required for this IP network/subnetwork address.')
proProtoIpDefGwAddress = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proProtoIpDefGwAddress.setStatus('optional')
if mibBuilder.loadTexts: proProtoIpDefGwAddress.setDescription('The Internet address of the default gateway for the router.')
proProtoIpDefGwCost = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proProtoIpDefGwCost.setStatus('optional')
if mibBuilder.loadTexts: proProtoIpDefGwCost.setDescription('The cost of the default gateway for the router.')
proProtoIpDefGwAge = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proProtoIpDefGwAge.setStatus('optional')
if mibBuilder.loadTexts: proProtoIpDefGwAge.setDescription('The age of the default gateway for the router.')
cdx6500PCTRtunnelTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82), )
if mibBuilder.loadTexts: cdx6500PCTRtunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelTable.setDescription('Tunnel Table')
cdx6500PCTRtunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PCTRtunnelIndex"))
if mibBuilder.loadTexts: cdx6500PCTRtunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelEntry.setDescription('Tunnel configurables.')
cdx6500PCTRtunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelIndex.setDescription('Table Index.')
cdx6500PCTRtunnelDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelDstAddr.setDescription('Destination Address.This is the destination address of the tunnel. This address is put into the destination field of the tunnel packet. This field cannot be 0.0.0.0 or un-numbered address.')
cdx6500PCTRtunnelSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelSrcAddr.setDescription('Source Address. This is the source address of the tunnel. This address is put into the source field of the tunnel packet.')
cdx6500PCTRtunnelLconNo = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelLconNo.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelLconNo.setDescription("This parameter specifies the LCON which will be used to forward the tunneled packet. If the value got is '0', then it means that this is a LAN TUNNEL with cdx6500PCTRtunnelLANnxthopAddr specifing Nexthop IP address corresponding to a LAN interface. Non-Zero value indicates this as a WAN TUNNEL. 1-MAX-LCON => For tunnels going on WAN link. 0 => For tunnels going on LAN link. ")
cdx6500PCTRtunnelIfNo = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelIfNo.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelIfNo.setDescription("This parameter specifies the router interface number used by this tunnel. If the value got is '0', it means that the value has not been prompted in the Tunnel Table.")
cdx6500PCTRtunnelEncrProf = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelEncrProf.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelEncrProf.setDescription('This parameter specifies the profile name of the encryption profile table.')
cdx6500PCTRtunnelProt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gre", 1), ("l2tp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelProt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelProt.setDescription('This parameter specifies the protocol used for tunneling. This defaults to GRE (Generic Routing Encapsulation)')
cdx6500PCTRtunnelGreCksSqn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelGreCksSqn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelGreCksSqn.setDescription(' This parameter enables or disables the GRE configuration. CKS enables end-to-end checksum, SQN enables sequence number. A combination of these can also be specified. Example : CKS+SQN')
cdx6500PCTRtunnelPayProt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelPayProt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelPayProt.setDescription("This parameter specifies the accepted protocol types of the payload data. A combination of these can also be specified (for instance:IP+IPX). If the packet protocol type doesn't match the configured protocol type ,the packet is dropped.")
cdx6500PCTRtunnelDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelDebug.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelDebug.setDescription('This parameter enables reports for diagnostic purposes in the data passing state.')
cdx6500PCTRtunnelLANnxthopAddr = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelLANnxthopAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelLANnxthopAddr.setDescription(' LAN Next Hop IP address. This parameter specifies the LAN Next hop IP address corresponding to a LAN interface which will be used to forward the tunneled packets for LAN tunnel.')
cdx6500PCTRtunnelRtpHdrComProf = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelRtpHdrComProf.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelRtpHdrComProf.setDescription(' This parameter specifies the profile name in the RTP/UDP/IP compression profile table.')
cdx6500PCTRtunnelGreResyncCntr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelGreResyncCntr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelGreResyncCntr.setDescription(" This parameter specifies the Resynchronisation Counter that is used by the receiver. If the value got is '0', it means that the value has not been prompted in the Tunnel Table")
cdx6500PCTRtunnelBrdgLnkNo = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 5, 82, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PCTRtunnelBrdgLnkNo.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PCTRtunnelBrdgLnkNo.setDescription(" This parameter specifies the bridge link used by this tunnel. If the value got is '0', it means that the value has not been prompted in the Tunnel Table.")
cdx6500PSTRtunnelTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4), )
if mibBuilder.loadTexts: cdx6500PSTRtunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelTable.setDescription('Tunnel Statistics Table')
cdx6500PSTRtunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1), ).setIndexNames((0, "ROUTER-OPT-MIB", "cdx6500PSTRtunnelIndex"))
if mibBuilder.loadTexts: cdx6500PSTRtunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelEntry.setDescription('Tunnel Statistics.')
cdx6500PSTRtunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIndex.setDescription('Table Index')
cdx6500PSTRtunnelIpPktIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktIn.setDescription('This parameter specifies the number of IP packets that have been received by the tunnel.')
cdx6500PSTRtunnelIpPktOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktOut.setDescription('This parameter specifies the number of IP packets that have been sent out by the tunnel.')
cdx6500PSTRtunnelIpPktDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpPktDisc.setDescription('This parameter specifies the number of IP packets that have been discarded by the tunnel.')
cdx6500PSTRtunnelIpxPktIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktIn.setDescription('This parameter specifies the number of IPX packets that have been received by the tunnel.')
cdx6500PSTRtunnelIpxPktOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktOut.setDescription('This parameter specifies the number of IPX packets that have been sent out by the tunnel.')
cdx6500PSTRtunnelIpxPktDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelIpxPktDisc.setDescription('This parameter specifies the number of IPX packets that have been discarded by the tunnel.')
cdx6500PSTRtunnelSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelSrcAddr.setDescription('Source Address. This is the source address of the tunnel. This address is put into the source field of the tunnel packet.')
cdx6500PSTRtunnelDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelDstAddr.setDescription('Destination Address.This is the destination address of the tunnel. This address is put into the destination field of the tunnel packet. This field cannot be 0.0.0.0 or un-numbered address.')
cdx6500PSTRtunnelPayProt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 3, 5, 6, 7))).clone(namedValues=NamedValues(("ip", 1), ("ipx", 2), ("brg", 4), ("ip-ipx", 3), ("ip-brg", 5), ("ipx-brg", 6), ("ip-ipx-brg", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelPayProt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelPayProt.setDescription("This parameter specifies the accepted protocol types of the payload data. A combination of thse can also be specified (for instance:IP+IPX+BRG). If the packet protocol type doesn't match the configured protocol type ,the packet is dropped.")
cdx6500PSTRtunnelEncrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelEncrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelEncrStatus.setDescription(' This parameter gives the status of the ENCRYPTION Channel ')
cdx6500PSTRtunnelRuihcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ena", 1), ("dis", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelRuihcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelRuihcStatus.setDescription(' This parameter gives the status of the RTP/UDP/IP Header Compression of the given tunnel')
cdx6500PSTRtunnelBrdgPktIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktIn.setDescription('This parameter specifies the number of BRIDGE packets that have been received by the tunnel.')
cdx6500PSTRtunnelBrdgPktOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktOut.setDescription('This parameter specifies the number of BRIDGE packets that have been sent out by the tunnel.')
cdx6500PSTRtunnelBrdgPktDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 4, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PSTRtunnelBrdgPktDisc.setDescription('This parameter specifies the number of BRIDGE packets that have been discarded by the tunnel.')
mibBuilder.exportSymbols("ROUTER-OPT-MIB", cdx6500PCTRaccControlTable=cdx6500PCTRaccControlTable, cdx6500PCTRifConfRcvgRipPkts=cdx6500PCTRifConfRcvgRipPkts, cdx6500PCTRipRouteNextHop=cdx6500PCTRipRouteNextHop, cdx6500PCTRAcceptRIPRouteTable=cdx6500PCTRAcceptRIPRouteTable, cdx6500PCTReventsTable=cdx6500PCTReventsTable, cdx6500PCTRipParamBootpFwdg=cdx6500PCTRipParamBootpFwdg, cdx6500PCTRbootpServIndex=cdx6500PCTRbootpServIndex, cdx6500PCTRipParamCacheSize=cdx6500PCTRipParamCacheSize, cdx6500PCTRipParamReasmBuffSize=cdx6500PCTRipParamReasmBuffSize, cdx6500PCTRoutInterchMetric=cdx6500PCTRoutInterchMetric, cdx6500PCTRarpCacheTable=cdx6500PCTRarpCacheTable, cdx6500PCTRipParamEgpSysNum=cdx6500PCTRipParamEgpSysNum, cdx6500PCTRaccControlType=cdx6500PCTRaccControlType, cdx6500PCTRifState34=cdx6500PCTRifState34, proProtoIpDefGwCost=proProtoIpDefGwCost, cdx6500PSTRtunnelEncrStatus=cdx6500PSTRtunnelEncrStatus, cdx6500PCTRifState19=cdx6500PCTRifState19, cdx6500PSTRtunnelIpxPktDisc=cdx6500PSTRtunnelIpxPktDisc, cdx6500PCTRtunnelEncrProf=cdx6500PCTRtunnelEncrProf, cdx6500PCTRAcceptRIPRouteEntry=cdx6500PCTRAcceptRIPRouteEntry, cdx6500PCTRpriorityIpxTraffic=cdx6500PCTRpriorityIpxTraffic, cdx6500PCTRifRoutInvldTime=cdx6500PCTRifRoutInvldTime, cdx6500PCTRifMaxIpMTUSize=cdx6500PCTRifMaxIpMTUSize, cdx6500PCTRifConfIpAd=cdx6500PCTRifConfIpAd, cdx6500PCTRipParamInternalIpAd=cdx6500PCTRipParamInternalIpAd, cdx6500PCTRifConfRcvgDynSubs=cdx6500PCTRifConfRcvgDynSubs, cdx6500Statistics=cdx6500Statistics, cdx6500PCTRifConfSndgSubRoute=cdx6500PCTRifConfSndgSubRoute, cdx6500PCTRStaticRouteTable=cdx6500PCTRStaticRouteTable, cdx6500PCTRinInterchEntry=cdx6500PCTRinInterchEntry, cdx6500PCTRtunnelGreCksSqn=cdx6500PCTRtunnelGreCksSqn, cdx6500PCTRbootpServAd=cdx6500PCTRbootpServAd, cdx6500PCTRifState27=cdx6500PCTRifState27, cdx6500PCTRpriorityIpTraffic=cdx6500PCTRpriorityIpTraffic, cdx6500PSTRtunnelTable=cdx6500PSTRtunnelTable, cdx6500PCTRtunnelRtpHdrComProf=cdx6500PCTRtunnelRtpHdrComProf, cdx6500PCTRifConfRcvgDynNets=cdx6500PCTRifConfRcvgDynNets, cdx6500PCTRifSendAggRoutes=cdx6500PCTRifSendAggRoutes, cdx6500PCTRipParamRipOrigDef=cdx6500PCTRipParamRipOrigDef, cdx6500PCTRdefSubGwayEntry=cdx6500PCTRdefSubGwayEntry, cdx6500PCTRarpCacheIfNum=cdx6500PCTRarpCacheIfNum, cdx6500PCTRaccControlSrcPort=cdx6500PCTRaccControlSrcPort, cdx6500PCTRifRipMetric=cdx6500PCTRifRipMetric, cdx6500PCTRoutInterchUseIgpMetric=cdx6500PCTRoutInterchUseIgpMetric, cdx6500PCTRifState17=cdx6500PCTRifState17, cdx6500PCTRifState20=cdx6500PCTRifState20, cdx6500StatProtocolGroup=cdx6500StatProtocolGroup, cdx6500PCTRarpParamUseTime=cdx6500PCTRarpParamUseTime, cdx6500PSTRtunnelIpPktIn=cdx6500PSTRtunnelIpPktIn, cdx6500PCTRarpCacheProtocol=cdx6500PCTRarpCacheProtocol, cdx6500PCTRifState24=cdx6500PCTRifState24, cdx6500PCTRipParamRoutTableSize=cdx6500PCTRipParamRoutTableSize, cdx6500PCTReventsPerPktTrace=cdx6500PCTReventsPerPktTrace, cdx6500PCTRoutInterchTable=cdx6500PCTRoutInterchTable, cdx6500PCTRarpCacheMacAd=cdx6500PCTRarpCacheMacAd, cdx6500PCTRipParamAdvDefMetCost=cdx6500PCTRipParamAdvDefMetCost, cdx6500PCTRifState29=cdx6500PCTRifState29, cdx6500PCTRegpAsIndex=cdx6500PCTRegpAsIndex, cdx6500PCTRifState8=cdx6500PCTRifState8, cdx6500PCTRtunnelIfNo=cdx6500PCTRtunnelIfNo, cdx6500PCTRegpAsUseEgMetric=cdx6500PCTRegpAsUseEgMetric, cdx6500PCTRarpParamMaxQueue=cdx6500PCTRarpParamMaxQueue, cdx6500PCTRegpAsEntry=cdx6500PCTRegpAsEntry, cdx6500PCTRifConfAdMask=cdx6500PCTRifConfAdMask, cdx6500PCTRegpAsNeighAs=cdx6500PCTRegpAsNeighAs, cdx6500PCTRarpCacheProtocolAd=cdx6500PCTRarpCacheProtocolAd, cdx6500PCTReventsEntry=cdx6500PCTReventsEntry, cdx6500PCTRdefSubGwayDistToGway=cdx6500PCTRdefSubGwayDistToGway, cdx6500PCTRRIPRouteControlIndex=cdx6500PCTRRIPRouteControlIndex, cdx6500PCTRtunnelSrcAddr=cdx6500PCTRtunnelSrcAddr, cdx6500PCTRifTrigUpdate=cdx6500PCTRifTrigUpdate, cdx6500PCTRifState9=cdx6500PCTRifState9, cdx6500PCTRtunnelGreResyncCntr=cdx6500PCTRtunnelGreResyncCntr, cdx6500PSTRtunnelIpxPktIn=cdx6500PSTRtunnelIpxPktIn, cdx6500PCTRegpNeighEntry=cdx6500PCTRegpNeighEntry, cdx6500PCTRfilterEntry=cdx6500PCTRfilterEntry, cdx6500PCTRaccControlFstPort=cdx6500PCTRaccControlFstPort, cdx6500PCTRifState2=cdx6500PCTRifState2, cdx6500PCTRifState12=cdx6500PCTRifState12, cdx6500PCTReventsIndex=cdx6500PCTReventsIndex, cdx6500PCTRegpNeighIndex=cdx6500PCTRegpNeighIndex, cdx6500PCTRRIPRouteControlIpMsk=cdx6500PCTRRIPRouteControlIpMsk, cdx6500PCTRifConfSndgDefRoute=cdx6500PCTRifConfSndgDefRoute, cdx6500PCTRifRoutFlushTime=cdx6500PCTRifRoutFlushTime, cdx6500PCTRAcceptRIPRouteIpNet=cdx6500PCTRAcceptRIPRouteIpNet, cdx6500PCTRaccControlDstPort=cdx6500PCTRaccControlDstPort, cdx6500PCTRinInterchMetric=cdx6500PCTRinInterchMetric, cdx6500PCTRaccControlLstPort=cdx6500PCTRaccControlLstPort, cdx6500PCTRifConfSndgStatRoute=cdx6500PCTRifConfSndgStatRoute, cdx6500PCTRtunnelLANnxthopAddr=cdx6500PCTRtunnelLANnxthopAddr, cdx6500PCTRifRdpEnable=cdx6500PCTRifRdpEnable, cdx6500PCTRfilterAdMask=cdx6500PCTRfilterAdMask, cdx6500PCTRoutInterchInterchNeighAs=cdx6500PCTRoutInterchInterchNeighAs, cdx6500PCTRifConfTagAsNum=cdx6500PCTRifConfTagAsNum, cdx6500PSTRtunnelRuihcStatus=cdx6500PSTRtunnelRuihcStatus, cdx6500PCTRarpParamProxySub=cdx6500PCTRarpParamProxySub, cdx6500Controls=cdx6500Controls, cdx6500PCTRifConfSndgNetRoute=cdx6500PCTRifConfSndgNetRoute, cdx6500PCTRifConfSr=cdx6500PCTRifConfSr, cdx6500PCTRdefSubGwayTable=cdx6500PCTRdefSubGwayTable, proProtoIpDefGwAge=proProtoIpDefGwAge, cdx6500PCTReventsSubsystem=cdx6500PCTReventsSubsystem, cdx6500PCTRifStateConfIndex=cdx6500PCTRifStateConfIndex, cdx6500PCTRarpParamAutoRef=cdx6500PCTRarpParamAutoRef, cdx6500PCTRifState1=cdx6500PCTRifState1, cdx6500PSTRtunnelIpxPktOut=cdx6500PSTRtunnelIpxPktOut, cdx6500PSTRtunnelBrdgPktOut=cdx6500PSTRtunnelBrdgPktOut, cdx6500PSTRtunnelIpPktOut=cdx6500PSTRtunnelIpPktOut, cdx6500PCTRifRdpLevel=cdx6500PCTRifRdpLevel, cdx6500PCTRegpNeighIdAd=cdx6500PCTRegpNeighIdAd, cdx6500PCTRoutInterchEntry=cdx6500PCTRoutInterchEntry, cdx6500PCTRifStateConfTable=cdx6500PCTRifStateConfTable, cdx6500PCTRifState28=cdx6500PCTRifState28, cdx6500PCTRegpNeighAs=cdx6500PCTRegpNeighAs, cdx6500PCTRRRCInIniface=cdx6500PCTRRRCInIniface, cdx6500PCTRtunnelTable=cdx6500PCTRtunnelTable, MacAddress=MacAddress, cdx6500PCTRifOnDemandRip=cdx6500PCTRifOnDemandRip, cdx6500PCTRifStateConfEntry=cdx6500PCTRifStateConfEntry, cdx6500PCTRRIPRouteControlTable=cdx6500PCTRRIPRouteControlTable, cdx6500PCTRegpAsInterchFlag=cdx6500PCTRegpAsInterchFlag, cdx6500PCTReventsCommonOper=cdx6500PCTReventsCommonOper, cdx6500PCTRfilterIndex=cdx6500PCTRfilterIndex, cdx6500PCTRipParamInternalNetMask=cdx6500PCTRipParamInternalNetMask, cdx6500PCTRifState5=cdx6500PCTRifState5, cdx6500PCTRipRouteIpMask=cdx6500PCTRipRouteIpMask, cdx6500PSTRtunnelDstAddr=cdx6500PSTRtunnelDstAddr, cdx6500PCTRifConfIfNum=cdx6500PCTRifConfIfNum, cdx6500PCTRinInterchIpNetwork=cdx6500PCTRinInterchIpNetwork, cdx6500PCTRdefSubGwaySubnetAd=cdx6500PCTRdefSubGwaySubnetAd, cdx6500PCTRifConfIndex=cdx6500PCTRifConfIndex, cdx6500=cdx6500, cdx6500PCTRipParamDistDefGway=cdx6500PCTRipParamDistDefGway, cdx6500CfgProtocolGroup=cdx6500CfgProtocolGroup, cdx6500PCTRtunnelPayProt=cdx6500PCTRtunnelPayProt, cdx6500PCTRipParamNextHopDefGway=cdx6500PCTRipParamNextHopDefGway, codex=codex, cdx6500PSTRtunnelPayProt=cdx6500PSTRtunnelPayProt, cdx6500PCTRipParamAccessCntrl=cdx6500PCTRipParamAccessCntrl, cdx6500PCTRarpParamTimeRetx=cdx6500PCTRarpParamTimeRetx, cdx6500PCTRoutInterchSourceAs=cdx6500PCTRoutInterchSourceAs, cdx6500PCTRaccControlFstProt=cdx6500PCTRaccControlFstProt, cdx6500PCTRifState14=cdx6500PCTRifState14, cdx6500PCTRifState23=cdx6500PCTRifState23, cdx6500PCTRifState7=cdx6500PCTRifState7, cdx6500PCTRifStateConfState=cdx6500PCTRifStateConfState, cdx6500PCTRarpCacheIndex=cdx6500PCTRarpCacheIndex, cdx6500PSTRtunnelIpPktDisc=cdx6500PSTRtunnelIpPktDisc, cdx6500PCTRaccControlEntry=cdx6500PCTRaccControlEntry, cdx6500PCTRifConfEntry=cdx6500PCTRifConfEntry, cdx6500PCTRipParamDirBcast=cdx6500PCTRipParamDirBcast, cdx6500PCTRouterGroup=cdx6500PCTRouterGroup, cdx6500PCTRifConfTable=cdx6500PCTRifConfTable, cdx6500PCTRifSendRipVer=cdx6500PCTRifSendRipVer, cdx6500PCTRifAuthType=cdx6500PCTRifAuthType, cdx6500PCTRipRouteIpNetwork=cdx6500PCTRipRouteIpNetwork, cdx6500PSTRtunnelBrdgPktDisc=cdx6500PSTRtunnelBrdgPktDisc, cdx6500PCTRifConfOvrDefRoute=cdx6500PCTRifConfOvrDefRoute, proProtoIpDefGwAddress=proProtoIpDefGwAddress, cdx6500PCTRinInterchNeighAs=cdx6500PCTRinInterchNeighAs, cdx6500PCTRifState30=cdx6500PCTRifState30, cdx6500Configuration=cdx6500Configuration, cdx6500PCTRifSecPrdBcastIntv=cdx6500PCTRifSecPrdBcastIntv, cdx6500PCTRpriorityAp2Traffic=cdx6500PCTRpriorityAp2Traffic, cdx6500PCTRtunnelIndex=cdx6500PCTRtunnelIndex, cdx6500PCTRifState33=cdx6500PCTRifState33, cdx6500PCTRbootpServTable=cdx6500PCTRbootpServTable, cdx6500PCTReventsUnusualOper=cdx6500PCTReventsUnusualOper, cdx6500PCTRRRCOutIniface=cdx6500PCTRRRCOutIniface, cdx6500PCTRfilterDstIpAd=cdx6500PCTRfilterDstIpAd, cdx6500PCTRaccControlInLcon=cdx6500PCTRaccControlInLcon, cdx6500PCTRipParamBootpMaxHops=cdx6500PCTRipParamBootpMaxHops, cdx6500PCTRifState25=cdx6500PCTRifState25, cdx6500PCTRifConfSplitHorizon=cdx6500PCTRifConfSplitHorizon, cdx6500PCTRbootpServEntry=cdx6500PCTRbootpServEntry, cdx6500PCTRtunnelDstAddr=cdx6500PCTRtunnelDstAddr, cdx6500PCTRtunnelDebug=cdx6500PCTRtunnelDebug, cdx6500PSTRouterGroup=cdx6500PSTRouterGroup, cdx6500PCTRifState31=cdx6500PCTRifState31, cdx6500PSTRtunnelBrdgPktIn=cdx6500PSTRtunnelBrdgPktIn, cdx6500PCTRifState13=cdx6500PCTRifState13, cdx6500PCTRarpCacheEntry=cdx6500PCTRarpCacheEntry, cdx6500PCTRtunnelBrdgLnkNo=cdx6500PCTRtunnelBrdgLnkNo, cdx6500PCTRaccControlDstMask=cdx6500PCTRaccControlDstMask, cdx6500PCTRifState16=cdx6500PCTRifState16, cdx6500PCTRaccControlIndex=cdx6500PCTRaccControlIndex, cdx6500PCTRifState10=cdx6500PCTRifState10, cdx6500PCTRtunnelLconNo=cdx6500PCTRtunnelLconNo, cdx6500PCTRaccControlLstProt=cdx6500PCTRaccControlLstProt, cdx6500PCTRifAuthKey=cdx6500PCTRifAuthKey, DisplayString=DisplayString, cdx6500PCTRifConfBcastFill=cdx6500PCTRifConfBcastFill, cdx6500PCTRinInterchTable=cdx6500PCTRinInterchTable, cdx6500PCTRifState32=cdx6500PCTRifState32, cdx6500PCTRaccControlSrcAd=cdx6500PCTRaccControlSrcAd, cdx6500PCTRaccControlOutIniface=cdx6500PCTRaccControlOutIniface, cdx6500PCTRipRouteIndex=cdx6500PCTRipRouteIndex, cdx6500PCTRtunnelProt=cdx6500PCTRtunnelProt, cdx6500PCTRaccControlOutLcon=cdx6500PCTRaccControlOutLcon, cdx6500PCTRinInterchUseEgpMetric=cdx6500PCTRinInterchUseEgpMetric, cdx6500PCTRifState3=cdx6500PCTRifState3, cdx6500PCTRarpParamRefTime=cdx6500PCTRarpParamRefTime, cdx6500PCTRaccControlDstAd=cdx6500PCTRaccControlDstAd, cdx6500PCTRipParamRip=cdx6500PCTRipParamRip, cdx6500PSTRtunnelSrcAddr=cdx6500PSTRtunnelSrcAddr, cdx6500PSTRtunnelIndex=cdx6500PSTRtunnelIndex, cdx6500PCTRMaxIpInterfaces=cdx6500PCTRMaxIpInterfaces, cdx6500PCTRarpParamProxy=cdx6500PCTRarpParamProxy, cdx6500PSTRtunnelEntry=cdx6500PSTRtunnelEntry, cdx6500PCTRegpAsDefMetric=cdx6500PCTRegpAsDefMetric, cdx6500PCTRStaticRouteEntry=cdx6500PCTRStaticRouteEntry, cdx6500PCTRinInterchIndex=cdx6500PCTRinInterchIndex, cdxProductSpecific=cdxProductSpecific, cdx6500PCTRIpFwdEnable=cdx6500PCTRIpFwdEnable, cdx6500PCTRegpAsTable=cdx6500PCTRegpAsTable, cdx6500PCTRipParamEgpReadvert=cdx6500PCTRipParamEgpReadvert, cdx6500PCTRtunnelEntry=cdx6500PCTRtunnelEntry, cdx6500PCTRRIPRouteControlEntry=cdx6500PCTRRIPRouteControlEntry, cdx6500PCTRifConfBcastStyle=cdx6500PCTRifConfBcastStyle, cdx6500PCTRAcceptRIPRouteIndex=cdx6500PCTRAcceptRIPRouteIndex, cdx6500PCTRipRouteCost=cdx6500PCTRipRouteCost, cdx6500PCTRifState21=cdx6500PCTRifState21, cdx6500PCTRifState36=cdx6500PCTRifState36, cdx6500PCTRfilterTable=cdx6500PCTRfilterTable, cdx6500PCTRoutInterchIpNetwork=cdx6500PCTRoutInterchIpNetwork, cdx6500PCTRifState11=cdx6500PCTRifState11, cdx6500PCTRUdpFwdEnable=cdx6500PCTRUdpFwdEnable, cdx6500PCTRoutInterchIndex=cdx6500PCTRoutInterchIndex, cdx6500PCTRifConfOvrStatRoute=cdx6500PCTRifConfOvrStatRoute, cdx6500PCTRipParamBootpSbf=cdx6500PCTRipParamBootpSbf, cdx6500PCTRifState22=cdx6500PCTRifState22, cdx6500PCTRifState6=cdx6500PCTRifState6, cdx6500PCTRdefSubGwayIndex=cdx6500PCTRdefSubGwayIndex, cdx6500PCTRaccControlInIniface=cdx6500PCTRaccControlInIniface, cdx6500PCTRifState26=cdx6500PCTRifState26, cdx6500PCTRRIPRouteControlIpNet=cdx6500PCTRRIPRouteControlIpNet, cdx6500PCTRAllSubnetBrcast=cdx6500PCTRAllSubnetBrcast, cdx6500PCTRifState35=cdx6500PCTRifState35, cdx6500PCTRifState18=cdx6500PCTRifState18, cdx6500PCTRdefSubGwayNextHopAd=cdx6500PCTRdefSubGwayNextHopAd, cdx6500PCTRifState4=cdx6500PCTRifState4, cdx6500PCTRaccControlSrcMask=cdx6500PCTRaccControlSrcMask, cdx6500PCTRegpNeighTable=cdx6500PCTRegpNeighTable, cdx6500PCTRifState15=cdx6500PCTRifState15)

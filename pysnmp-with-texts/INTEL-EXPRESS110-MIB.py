#
# PySNMP MIB module INTEL-EXPRESS110-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INTEL-EXPRESS110-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:54:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
hub_products, = mibBuilder.importSymbols("Intel-Common-MIB", "hub-products")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, ObjectIdentity, iso, Integer32, Bits, Counter64, Counter32, Gauge32, NotificationType, NotificationType, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "iso", "Integer32", "Bits", "Counter64", "Counter32", "Gauge32", "NotificationType", "NotificationType", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
express110 = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1))
hubNumberofStackedChassis = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubNumberofStackedChassis.setStatus('mandatory')
if mibBuilder.loadTexts: hubNumberofStackedChassis.setDescription('Displays the total number of chassis in the stack. ')
hubDescriptionString = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 33))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubDescriptionString.setStatus('mandatory')
if mibBuilder.loadTexts: hubDescriptionString.setDescription('Bitfield used by SNMP application. ')
hubStackReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubStackReset.setStatus('mandatory')
if mibBuilder.loadTexts: hubStackReset.setDescription('Resets all modules in all of the chassis in the stack. ')
hubLCDModeVariable = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("sysName", 1), ("sysLocation", 2), ("sysContact", 3), ("traps", 4), ("utilization", 5), ("ipaddress", 6), ("lcdSleepText", 7), ("notSupported", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubLCDModeVariable.setStatus('mandatory')
if mibBuilder.loadTexts: hubLCDModeVariable.setDescription("Sets the type of information displayed on the Management Module's LCD when in Sleep Mode. sysContact, sysLocation, and sysName are user-definable. Traps shows the most current SNMP trap message generated. Utilization shows the percentage of bandwidth used in each segment in the stack. Ipaddress shows the currently assigned Management Module IP address. Sleep text shows user-definable text set with the hubLCDSleepText object. ")
hubLCDSleepText = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubLCDSleepText.setStatus('mandatory')
if mibBuilder.loadTexts: hubLCDSleepText.setDescription('Sets user-defined text to be displayed by the LCD when in Sleep Mode. For example, you may want the name and phone number of a contact person to display on the LCD panel. This object is only applicable to 200 series stackable hubs.')
hubLCDSleepTime = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubLCDSleepTime.setStatus('mandatory')
if mibBuilder.loadTexts: hubLCDSleepTime.setDescription("Sets the number of minutes before the LCD goes into Sleep Mode. If an LCD button isn't pressed for the time specified, the LCD goes into Sleep Mode and displays the information set by hubLCDModeVariable. To disable this feature, set the time to 0. This object is only applicable to 200 series stackable hubs.")
hubRFC1516Segment = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2), ("allsegments", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubRFC1516Segment.setStatus('mandatory')
if mibBuilder.loadTexts: hubRFC1516Segment.setDescription("Sets which segment the standard repeater MIB (RFC1516) returns counters for. The standard repeater MIB doesn't support two segments at the same time.")
chassisConfigTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8), )
if mibBuilder.loadTexts: chassisConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: chassisConfigTable.setDescription('Configuration information at the chassis level.')
chassisConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "chassisConfigTableIndex"))
if mibBuilder.loadTexts: chassisConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chassisConfigEntry.setDescription('A table entry, containing configuration information about a single chassis.')
chassisConfigTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisConfigTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chassisConfigTableIndex.setDescription('Chassis number in the stack. This object refers to the number in the example below. Example: chassisConfigTableIndex.1 This example refers to chassis 1 of the stack. The chassis at the top of the stack is number 1. ')
chassisSegmentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2), ("auto", 3), ("mixed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisSegmentMode.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSegmentMode.setDescription("Sets/reports the repeater segment the chassis ports participate in. For chassis which do not support port speed autosensing, only 'segment1' or 'segment2' can be set. For stacks with both segments set to the same speed, setting a chassis to 'auto' causes linked ports to participate in segment2. The 'mixed' value is read-only and indicates that ports within the chassis do not share the same segment mode. Setting chassis ports via this object does not prevent ports from being set independently.")
chassisReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisReset.setStatus('mandatory')
if mibBuilder.loadTexts: chassisReset.setDescription('Resets all modules in the selected chassis. ')
chassisRPSState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notPresent", 1), ("standby", 2), ("active", 3), ("notSupported", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisRPSState.setStatus('mandatory')
if mibBuilder.loadTexts: chassisRPSState.setDescription('The state of the optional Redundant Power Supply connected to the chassis. standby means the RPS is actively backing up the chassis. active means the chassis power supply has failed and the RPS is powering the chassis. ')
chassisIsolate = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isolate", 1), ("unisolate", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisIsolate.setStatus('mandatory')
if mibBuilder.loadTexts: chassisIsolate.setDescription('The isolated or unisolates the hub from the backplane channel.')
moduleConfigStatusTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9), )
if mibBuilder.loadTexts: moduleConfigStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: moduleConfigStatusTable.setDescription('Configuration and status information at the module level.')
moduleConfigStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "moduleChassisIndex"), (0, "INTEL-EXPRESS110-MIB", "moduleIndex"))
if mibBuilder.loadTexts: moduleConfigStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: moduleConfigStatusEntry.setDescription('A table entry, containing configuration and status information about a single module.')
moduleChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: moduleChassisIndex.setDescription('Chassis number in the stack. This object refers to the first number in the example below. Example: moduleChassisIndex.1.1 The first number is the chassis (hub) and the second number is the module in the chassis. This example refers to module 1 in hub 1 (which is the hub at the top of the stack). Base ports on the hub are always module 1. The left expansion slot (when facing the hub) is module 2 and the right expansion slot is module 3. ')
moduleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: moduleIndex.setDescription('Module number in the chassis. This object refers to the second number in the example below. Example: moduleChassisIndex.1.1 The first number is the chassis (hub) and the second number is the module in the chassis. This example refers to module 1 in hub 1 (which is the hub at the top of the stack). Base ports on the hub are always module 1. The left expansion slot (when facing the hub) is module 2 and the right expansion slot is module 3. ')
moduleType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("none", 1), ("hubTXports12", 2), ("hubTXports24", 3), ("reserved4", 4), ("management", 5), ("bridge", 6), ("managementWithRMON", 7), ("reserved8", 8), ("hubcrTXports12", 9), ("hubcrTXports24", 10), ("hubppTXports12", 11), ("hubppTXports24", 12), ("express330TXports16", 13), ("express330TXports24", 14), ("fxUplink", 15), ("txUplink", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleType.setStatus('mandatory')
if mibBuilder.loadTexts: moduleType.setDescription('The module type. The base ports of a 12- or 24-port hub are considered modules. For example, hubTXports12 are ports 1-12 on a 12-port hub. bridge is an externally inserted bridge and refers to the Ethernet Module or the Fiber Module. management is the Management Module (also called the SNMP agent). None means no module is installed. ')
moduleUserAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleUserAssignedType.setStatus('mandatory')
if mibBuilder.loadTexts: moduleUserAssignedType.setDescription('User-definable information about the type of the module. Manufacturer assigns a default value. ')
moduleUserAssignedNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleUserAssignedNumber.setStatus('mandatory')
if mibBuilder.loadTexts: moduleUserAssignedNumber.setDescription('User-definable information about the module. Blank by default. ')
moduleUserAssignedName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleUserAssignedName.setStatus('mandatory')
if mibBuilder.loadTexts: moduleUserAssignedName.setDescription('User-definable information about the module. Blank by default. ')
moduleSizeofROM = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSizeofROM.setStatus('mandatory')
if mibBuilder.loadTexts: moduleSizeofROM.setDescription("Displays the module's ROM size. ")
moduleSizeofRAM = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSizeofRAM.setStatus('mandatory')
if mibBuilder.loadTexts: moduleSizeofRAM.setDescription("Displays the module's RAM size. ")
moduleHWDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHWDescription.setStatus('mandatory')
if mibBuilder.loadTexts: moduleHWDescription.setDescription('Displays the CPU type and flash capacity. ')
moduleAgentSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAgentSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAgentSWVersion.setDescription("Displays the module's agent software version. Each module has software which contributes to the SNMP agent's functionality. The Management Module version is the SNMP agent's version.")
moduleBootSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleBootSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: moduleBootSWVersion.setDescription("Displays the module's boot software version. ")
moduleManufacturingInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(24, 24)).setFixedLength(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleManufacturingInfo.setStatus('mandatory')
if mibBuilder.loadTexts: moduleManufacturingInfo.setDescription('Displays the manufacturer-assigned hardware description. ')
moduleTotalPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTotalPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: moduleTotalPortCount.setDescription('Displays the total number of ports in the module. This can be: 14 = a 12-port hub (12 base ports plus 2 expansion modules) 16 = a 12-port hub with an internal bridge (14, as described for a 12-port hub, plus 2 internal bridge ports) 24 = a 24-port hub 26 = a 24-port hub with an internal bridge 1 or 2 for an expansion module (module dependent). ')
moduleExternalPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleExternalPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: moduleExternalPortCount.setDescription('Number of external ports in the module. ')
moduleSegmentLockout = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("yButtonyMgmt", 1), ("nButtonyMgmt", 2), ("yButtonnMgmt", 3), ("nButtonnMgmt", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleSegmentLockout.setStatus('mandatory')
if mibBuilder.loadTexts: moduleSegmentLockout.setDescription('Prevents the hub speed from being changed by either a management station and/or the Change speed button on the front of a hub. Only nButtonnMgmt is valid for expansion modules. Only nButtonnMgmt or nButtonyMgmt is valid for hubs which do not have speed change buttons.')
moduleLEDInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleLEDInfo.setStatus('mandatory')
if mibBuilder.loadTexts: moduleLEDInfo.setDescription('Bitfield used by SNMP application. ')
moduleLastErrorID = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleLastErrorID.setStatus('mandatory')
if mibBuilder.loadTexts: moduleLastErrorID.setDescription('Bitfield used by SNMP application. ')
moduleMediaDevicesReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleMediaDevicesReset.setStatus('mandatory')
if mibBuilder.loadTexts: moduleMediaDevicesReset.setDescription('Performs a physical layer reset of the module. Use this reset if ports lock-up on an individual hub. ')
moduleImageFileSource = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleImageFileSource.setStatus('mandatory')
if mibBuilder.loadTexts: moduleImageFileSource.setDescription('Sets the IP address of the device that transfers the image file to the module. The image filename is specified by the moduleImageFileName object. The moduleImageDownloadControl object starts and stops the download process. ')
moduleImageFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleImageFileName.setStatus('mandatory')
if mibBuilder.loadTexts: moduleImageFileName.setDescription('Sets the image filename contained on the device specified by the moduleImageFileSource object. The moduleImageDownloadControl object starts and stops the download process to the module. e300agentImageUpdateCtrl must be set to enabled before starting the download process.')
moduleImageDownloadControl = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("start", 1), ("stop", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleImageDownloadControl.setStatus('mandatory')
if mibBuilder.loadTexts: moduleImageDownloadControl.setDescription('Starts and stops the image file download process to the module. Use the moduleImageFileSource to set the IP address of the device that contains image file. Use the moduleImageFileName object to set the image filename. ')
moduleImageDownloadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("started", 1), ("stopping", 2), ("completed", 3), ("error", 4), ("notSupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleImageDownloadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: moduleImageDownloadStatus.setDescription("Displays the Management Module's image file download status. If error appears, use the moduleImageFileSource, moduleImageFileName, and moduleImageDownloadControl objects to configure and download the image file to the module. Do not reset the module until the status has changed to completed. ")
moduleOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notoperational", 2), ("notpresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleOperationalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: moduleOperationalStatus.setDescription('Current operational state of the module. ')
moduleUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleUptime.setStatus('mandatory')
if mibBuilder.loadTexts: moduleUptime.setDescription('Time since the module was last reset. ')
moduleReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleReset.setStatus('mandatory')
if mibBuilder.loadTexts: moduleReset.setDescription('Resets the module. ')
moduleAllPortLEDInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortLEDInfo.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortLEDInfo.setDescription('Bitfield used by SNMP application. ')
moduleAllPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 27), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleAllPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortAdminStatus.setDescription('Bitfield used by SNMP application. ')
moduleAllPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortOperStatus.setDescription('Bitfield used by SNMP application. ')
moduleAllPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 29), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortSpeed.setDescription('Bitfield used by SNMP application. ')
moduleAllPortSpeedInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortSpeedInfo.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortSpeedInfo.setDescription('Bitfield used by SNMP application. ')
moduleSegmentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2), ("auto", 3), ("mixed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleSegmentMode.setStatus('mandatory')
if mibBuilder.loadTexts: moduleSegmentMode.setDescription("Sets/reports the repeater segment the module ports participate in. For modules which do not support automatic port speed selection, only 'segment1' or 'segment2' may be set. The 'mixed' value is read-only and indicates that ports within the module do not share the same segment mode. Setting module ports via this object does not prevent ports from being set independently.")
moduleAllPortLinkPartnerInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 32), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortLinkPartnerInfo.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortLinkPartnerInfo.setDescription('Bitfield used by SNMP application. ')
moduleAllPortCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleAllPortCounterReset.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortCounterReset.setDescription('Resets all the port counters in the module to zero. This includes all traffic statistics (packet count, etc.) and error counts. ')
moduleAllPortTimeSinceLinkChange = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 34), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAllPortTimeSinceLinkChange.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAllPortTimeSinceLinkChange.setDescription('Bitfield used by SNMP application. ')
modulePersistentMemoryReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 9, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modulePersistentMemoryReset.setStatus('mandatory')
if mibBuilder.loadTexts: modulePersistentMemoryReset.setDescription('Reset contents of persistent memory objects to factory defaults. Persistent memory object are settings that are saved even after the module is reset or power-cycled. ')
portConfigTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10), )
if mibBuilder.loadTexts: portConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: portConfigTable.setDescription('Configuration information at the Port level.')
portConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "portChassisIndex"), (0, "INTEL-EXPRESS110-MIB", "portModuleIndex"), (0, "INTEL-EXPRESS110-MIB", "portIndex"))
if mibBuilder.loadTexts: portConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portConfigEntry.setDescription('A table entry, containing configuration information about a single port.')
portChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portChassisIndex.setDescription('Chassis number in stack. This object refers to the first number in the example below. Example: portChassisIndex.1.1.9 The first number is the chassis. The second number is the module in the chassis. The third number is the port in the module. This example refers to port 9 in module 1 in hub 1 (which is the hub at the top of the stack). Base ports on the hub are always module 1. The left expansion slot (when facing the hub) is module 2 and the right expansion slot is module 3. ')
portModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portModuleIndex.setDescription('Module number in the chassis. This object refers to the second number in the example below. Example: portModuleIndex.1.1.9 The first number is the chassis. The second number is the module in the chassis. The third number is the port in the module. This example refers to port 9 in module 1 in hub 1 (which is the hub at the top of the stack). Base ports on the hub are always module 1. The left expansion slot (when facing the hub) is module 2 and the right expansion slot is module 3. ')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('Port number in the module. This object refers to the third number in the example below. Example: portChassisIndex 1.1.9 The first number is the chassis. The second number is the module in the chassis. The third number is the port in the module. This example refers to port 9 in module 1 in hub 1 (which is the hub at the top of the stack). Base ports on the hub are always module 1. The left expansion slot (when facing the hub) is module 2 and the right expansion slot is module 3. ')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("twistedPairHalfDuplex", 1), ("twistedPairFullDuplex", 2), ("fiberMultimode", 3), ("fiberSinglemode", 4), ("internalHalfDuplex", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('mandatory')
if mibBuilder.loadTexts: portType.setDescription("Displays the selected port's capabilities. internalHalfDuplex is the expansion module's internal connection to a port in the hub.")
portAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portAdminStatus.setDescription('Enables or disables the selected port. Disabled ports will not be able to establish a link to a device. Disabled ports remain disabled until re-enabled.')
portOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("notoperational", 2), ("notpresent", 3), ("violated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portOperStatus.setDescription('Displays the current link status of the port. Operational means a port has established a link to a device. Notoperational means the port does not have a link established. It does not mean there is a problem with the port. Notpresent may mean that an Intel Cascade Cable was removed from a hub or that the cable is faulty. Violated means that this port was disabled by a security violation. Port security is enabled/disabled with the portSecureAdminMode object. A violated port can be re-enabled with the portAdminStatus object.')
portJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("failure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portJabber.setStatus('mandatory')
if mibBuilder.loadTexts: portJabber.setDescription("Jabber state of the port. Failure means the device attached to the port caused the hub's jabber lock-up protection to turn on. Check the device attached to the port. ")
portLinkPartnerInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkPartnerInfo.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkPartnerInfo.setDescription('Bitfield used by SNMP application. ')
portLEDInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLEDInfo.setStatus('mandatory')
if mibBuilder.loadTexts: portLEDInfo.setDescription('Bitfield used by SNMP application. ')
portTimeSinceLastLinkChange = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTimeSinceLastLinkChange.setStatus('mandatory')
if mibBuilder.loadTexts: portTimeSinceLastLinkChange.setDescription('Time since the last link status change. ')
portAllCountersReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAllCountersReset.setStatus('mandatory')
if mibBuilder.loadTexts: portAllCountersReset.setDescription('Resets all counters for ports to zero. This includes all traffic statistics (packet count, etc.) and error counts. ')
portReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portReset.setStatus('mandatory')
if mibBuilder.loadTexts: portReset.setDescription('Reset the port at the media level. ')
portLastErrorID = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noError", 1), ("badPhy", 2), ("polarity", 3), ("wrongSpeedLP", 4), ("jabberSeen", 5), ("partition", 6), ("reserved1", 7), ("reserved2", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLastErrorID.setStatus('mandatory')
if mibBuilder.loadTexts: portLastErrorID.setDescription("Type of last error that occurred on the port since the last link status change. badPhy is a hardware problem with the hub port. polarity means there's a cabling problem between the hub and the attached device. wrongSpeedLP means the device attached to the port is operating at the wrong speed. jabberSeen means you may have a faulty device attached to the port. partition means the port was automatically partitioned at least once. ")
portSegmentAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSegmentAdminMode.setStatus('mandatory')
if mibBuilder.loadTexts: portSegmentAdminMode.setDescription("For ports that have the ability to be set independent of the hub or module they reside in, this object allows setting the port to 'segment1', 'segment2', or 'auto'.")
portSegmentOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSegmentOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portSegmentOperStatus.setDescription("Reports the port's segment assignment. 'none' indicates the port has a portSegmentAdminMode of 'auto' and has not negotiated a link speed setting with a device.")
portLinkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("mb10", 2), ("mb100", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkSpeed.setDescription("The operational speed of this port when linked. Ports which do not have a link report 'none'.")
portSecureAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("portSecurityOff", 1), ("portSecurityOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecureAdminMode.setStatus('mandatory')
if mibBuilder.loadTexts: portSecureAdminMode.setDescription('Causes a port to be administratively disabled if an un-authorized MAC address is detected as having transmitted a frame into this hub port. A trap is also generated when an unauthorized source MAC address is detected. An unauthorized source MAC addresss is defined as follows: If a portSecureMAC is specified, any frame received from this port which does not originate from the specified portSecureMAC is unauthorized. If no portSecureMAC is specified, the first source MAC address detected on this port is the authorized MAC. Any frame originating on this port with a different MAC address from the first MAC address detected is unauthorized. Older Management modules (those which do not support RMON) will not allow enabling of port security due to hardware limitations.')
portSecureMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecureMAC.setStatus('mandatory')
if mibBuilder.loadTexts: portSecureMAC.setDescription('Specifies the authorized MAC address for this port if portSecureAdminMode is set to portSecurityOn.')
portLinkTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLinkTestState.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkTestState.setDescription('The current setting of link test function for the port. When disable, a port will no longer be disconnected due to link fail. When enable, the port will only remain connected to the network so long as link pulses are being received.')
portLinkTestStatusTrapCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLinkTestStatusTrapCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkTestStatusTrapCtrl.setDescription('This object indicates whether a trap should be generated when the link state changes.')
portSpeedStatusTrapCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSpeedStatusTrapCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: portSpeedStatusTrapCtrl.setDescription('This object indicates whether a trap should be generated when the speed status changes.')
portPolarityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("reversed", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPolarityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portPolarityStatus.setDescription('The current polarity status of this port.')
rptrSegmentConfigTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11), )
if mibBuilder.loadTexts: rptrSegmentConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentConfigTable.setDescription('Repeater configuration information at the segment level. ')
rptrSegmentConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "rptrSegmentConfigIndex"))
if mibBuilder.loadTexts: rptrSegmentConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentConfigEntry.setDescription('A table entry, containing repeater configuration information about a single segment. ')
rptrSegmentConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentConfigIndex.setDescription('Index into this table is rptrSegmentConfigIndex. Any configuration changes apply to all repeater ports participating in the segment. If a stack does not have any ports at the selected speed, the OperationalStatus of this segment will be NotPresent.')
rptrSegmentOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6), ("holdInReset", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentOperationalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentOperationalStatus.setDescription('Displays the operational status of the segment. ')
rptrSegmentZeroCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentZeroCounters.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentZeroCounters.setDescription('Resets all repeater per-port counters of the repeater modules in the segment. The read value is always notreset. ')
rptrSegmentReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentReset.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentReset.setDescription('Performs a cold-reset of all repeater modules in the segment. (RFC2108 rptrInfoReset) ')
rptrSegmentResetMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentResetMedia.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentResetMedia.setDescription('Performs a media layer reset of all repeater modules in the segment. ')
rptrSegmentPartitionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("collisions64", 1), ("collisions128", 2), ("collisions32", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentPartitionThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentPartitionThreshold.setDescription('The number of consecutive collisions that will cause a port to autopartition. Note that this sets the value for all repeaters in the segment. ')
rptrSegmentNonDisruptTest = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentNonDisruptTest.setDescription('Performs a self-test of all repeater modules in the segment. ')
rptrSegmentUtilizationTrapThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentUtilizationTrapThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentUtilizationTrapThreshold.setDescription('If the utilization rate exceeds this value, a trap is sent. Use 0 to disable. This trap is based on the utilization rate over the last rptrSegmentUtilizationTrapPeriod. ')
rptrSegmentCollisionTrapThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 9), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentCollisionTrapThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentCollisionTrapThreshold.setDescription('If the number of collisions exceeds this value, a trap is sent. Use 0 to disable. This trap is based on the number of collision in the last rptrSegmentCollisionTrapPeriod. ')
rptrSegmentUtilizationTrapPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentUtilizationTrapPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentUtilizationTrapPeriod.setDescription('Time period (in minutes) that segment utilization must exceed the trap threshold value to generate a trap.')
rptrSegmentCollisionTrapPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrSegmentCollisionTrapPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentCollisionTrapPeriod.setDescription('Time period (in minutes) that segment collisions must exceed the trap threshold value to generate a trap.')
rptrSegmentSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mb10", 1), ("mb100", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentSpeed.setDescription('The speed of the ports within the segment.')
rptrSegmentStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12), )
if mibBuilder.loadTexts: rptrSegmentStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentStatTable.setDescription('Repeater status information at the segment level. ')
rptrSegmentStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "rptrSegmentStatIndex"))
if mibBuilder.loadTexts: rptrSegmentStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentStatEntry.setDescription('A table entry, containing repeater status information about a single repeater. ')
rptrSegmentStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("segment1", 1), ("segment2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentStatIndex.setDescription('Selects the 10Mbps or 100Mbps segment. ')
rptrSegmentTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentTotalFrames.setDescription('The number of frames detected without errors. Includes unicast, broadcast, and multicast frames. Does not include frames received with frames too long, runt, FCS, or alignment errors. (RFC2108 rptrMonitorGroupTotalFrames for all groups in this segment.) ')
rptrSegmentTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentTotalOctets.setDescription('The number of octets (bytes) contained in frames received that had no errors. This includes octets in unicast, broadcast, and multicast frames. It also includes octets after the start frame delimiter up to FCS but not including FCS octets. (RFC2108 rptrMonitorGroupTotalOctets for all groups in this segment.)')
rptrSegmentTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentTotalErrors.setDescription('The total number of errors detected. Total errors include FCS errors, alignment errors, frame too long, short events, late events, very long event, and rate mismatch errors. (RFC2108 rptrMonitorGroupTotalErrors for all groups in this segment.)')
rptrSegmentTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentTotalCollisions.setDescription('Sum of all collisions in this segment. (RFC2108 rptrMonTxCollisions) ')
rptrSegmentPartitionedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentPartitionedPorts.setDescription('Total number of present and enabled, but autopartitioned ports. (RFC2108 rptrInfoPartitionedPorts) ')
rptrSegmentHealthText = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentHealthText.setDescription('Description of current health of all repeaters in the segment. (RFC2108 rptrHealthText) ')
rptrSegmentUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 12, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrSegmentUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rptrSegmentUtilization.setDescription('The utilization rate over the last one second.')
rptrModuleStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13), )
if mibBuilder.loadTexts: rptrModuleStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleStatTable.setDescription('***** Deprecated and replaced by rptrChassisSegmentStatTable ***** Repeater status information at the Module level. ')
rptrModuleStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "rptrModuleIndex"))
if mibBuilder.loadTexts: rptrModuleStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleStatEntry.setDescription('***** Deprecated and replaced by rptrChassisSegmentStatEntry ***** A table entry, containing repeater status information about a single module. ')
rptrModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleIndex.setDescription('***** Deprecated and replaced by rptrChassisSegmentIndex ***** This index is the chassis number in the stack. The chassis at the top of the stack is number 1. ')
rptrModuleTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleTotalFrames.setDescription('***** Deprecated and replaced by rptrChassisSegmentTotalFrames ***** The number of frames detected without errors. Includes unicast, broadcast, and multicast frames. Does not include frames received with frames too long, runt, FCS, or alignment errors. This is the sum of all valid received frames for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalFrames) ')
rptrModuleTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleTotalOctets.setDescription('***** Deprecated and replaced by rptrChassisSegmentTotalOctets ***** The number of octets (bytes) contained in frames received that had no errors. This includes octets in unicast, broadcast, and multicast frames. It also includes octets after the start frame delimiter up to FCS but not including FCS octets. This is the sum of all valid received octets for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalOctets) ')
rptrModuleTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleTotalErrors.setDescription('***** Deprecated and replaced by rptrChassisSegmentTotalErrors ***** The total number of errors detected. Total errors include FCS errors, alignment errors, frame too long, short events, late events, very long event, and rate mismatch errors. This is the sum of all errors for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalErrors) ')
rptrModuleFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleFCSErrors.setDescription('***** Deprecated and replaced by rptrChassisSegmentFCSErrors ***** The number of frames detected that are free of partial octets and do not pass the FCS check. Usually caused by adapter underrun (when the adapter cant get enough bus bandwidth). FCS errors do not necessarily indicate that data has been lost. ')
rptrModuleAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleAlignmentErrors.setDescription('***** Deprecated and replaced by rptrChassisSegmentAlignmentErrors ***** The number of frames detected that contain partial octets and do not pass the FCS check. ')
rptrModuleFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleFrameTooLongs.setDescription('***** Deprecated and replaced by rptrChassisSegmentFrameTooLongs ***** The number of frames detected that exceed the maximum permitted frame size. ')
rptrModuleShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleShortEvents.setDescription('***** Deprecated and replaced by rptrChassisSegmentShortEvents ***** The number of fragments detected with ActivityDuration less than ShortEventMaxTime (greater than 74 bit times and less than 82 bit times). Usually indicates a network topology problem. ')
rptrModuleRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleRunts.setDescription('***** Deprecated and replaced by rptrChassisSegmentRunts ***** The number of frames detected that are less than the minimum permitted frame size of 64 octets but have a good FCS. Runts usually indicate collision fragments, a normal network event. ')
rptrModuleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleCollisions.setDescription('***** Deprecated and replaced by rptrChassisSegmentCollisions ***** Sum of all collisions for all ports in this repeater module. ')
rptrModuleLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleLateEvents.setDescription('***** Deprecated and replaced by rptrChassisSegmentLateEvents ***** The number of collisions detected after the allowable detection period. Usually indicates a network topology problem, such as daisy-chaining class I 100Mbps hubs with UTP cable or a network diameter that is too wide. ')
rptrModuleVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleVeryLongEvents.setDescription('***** Deprecated and replaced by rptrChassisSegmentVeryLongEvents ***** The number of times MAU jabber lockup protection (MJLP) was detected due to transmission of data that exceeded 5 msec in duration (octet count greater than maxFrameSize). Can indicate a faulty device or port. ')
rptrModuleDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleDataRateMismatches.setDescription('***** Deprecated and replaced by rptrChassisSegmentDataRateMismatches ***** A count of the occurrences of out-of-specification bit rates. This indicates the number of times the FIFO buffer overruns or underruns due to transmission rate errors. This could indicate an incorrect FIFO setting on a network adapter or a faulty adapter. ')
rptrModuleAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrModuleAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrModuleAutoPartitions.setDescription('***** Deprecated and replaced by rptrChassisSegmentAutoPartitions ***** The number of times this port was automatically partitioned. This condition occurs when too many consecutive collisions are detected on the port. These collisions are due to excessive traffic on the segment, a malfunctioning port, or a malfunctioning adapter that is jabbering. ')
rptrPortStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14), )
if mibBuilder.loadTexts: rptrPortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortStatTable.setDescription('Repeater status information at the port level.')
rptrPortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "rptrPortChassisIndex"), (0, "INTEL-EXPRESS110-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortStatEntry.setDescription('A table entry, containing repeater status information about a single port.')
rptrPortChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortChassisIndex.setDescription('Chassis number in stack. The chassis at the top is number 1. ')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIndex.setDescription('Port number in the module. ')
rptrPortPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoPartition", 1), ("notAutoPartition", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortPartitionState.setDescription("Indicates a port's current autopartitioned state. (RFC2108 rptrPortAutoPartitionState) ")
rptrPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortReadableFrames.setDescription('The number of frames detected without errors. Includes unicast, broadcast, and multicast frames. Does not include frames received with frames too long, runt, FCS, or alignment errors. (RFC2108 rptrMonitorPortReadableFrames) ')
rptrPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortReadableOctets.setDescription('The number of octets (bytes) contained in frames received that had no errors. This includes octets in unicast, broadcast, and multicast frames. It also includes octets after the start frame delimiter up to FCS but not including FCS octets. (RFC2108 rptrMonitorPortReadableOctets) ')
rptrPortFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortFcsErrors.setDescription("The number of frames detected that are free of partial octets and do not pass the FCS check. Usually caused by adapter underrun (when the adapter can't get enough bus bandwidth). FCS errors do not necessarily indicate that data has been lost. (RFC2108 rptrMonitorPortFCSErrors) ")
rptrPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAlignmentErrors.setDescription('The number of frames detected that contain partial octets and do not pass the FCS check. (RFC2108 rptrMonitorPortAlignmentErrors) ')
rptrPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortFrameTooLongs.setDescription('The number of frames detected that exceed the maximum permitted frame size of 1518 octets. (RFC2108 rptrMonitorPortFrameTooLongs) ')
rptrPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortShortEvents.setDescription('The number of fragments detected with ActivityDuration less than ShortEventMaxTime (greater than 74 bit times and less than 82 bit times). Usually indicates a network topology problem. (RFC2108 rptrMonitorPortShortEvents) ')
rptrPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortRunts.setDescription('The number of frames detected that are less than the minimum permitted frame size of 64 octets but have a good FCS. Runts usually indicate collision fragments, a normal network event. (RFC2108 rptrMonitorPortRunts) ')
rptrPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortCollisions.setDescription('The number of collisions detected on a port. (RFC2108 rptrMonitorPortCollisions) ')
rptrPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortLateEvents.setDescription('The number of collisions detected after the allowable detection period. Usually indicates a network topology problem, such as daisy-chaining Class I 100Mbps hubs with UTP cable or a network diameter that is too wide. (RFC2108 rptrMonitorPortLateEvents) ')
rptrPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortVeryLongEvents.setDescription('The number of times MAU jabber lockup protection (MJLP) was detected due to transmission of data that exceeded 5 msec in duration (octet count greater than maxFramSize). Can indicate a faulty device or port. (RFC2108 rptrMonitorPortVeryLongEvents) ')
rptrPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortDataRateMismatches.setDescription('A count of the occurrences of out-of-specification bit rates. This indicates the number of times the FIFO buffer overruns or underruns due to transmission rate errors. This could indicate an incorrect FIFO setting on a network adapter or a faulty adapter. (RFC2108 rptrMonitorPortDataRateMismatches) ')
rptrPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAutoPartitions.setDescription('The number of times this port was automatically partitioned. This condition occurs when 64 consecutive collisions are detected on the port. These collisions are due to excessive traffic on the segment, a malfunctioning port, or a malfunctioning adapter that is jabbering. (RFC2108 rptrMonitorPortAutoPartitions) ')
rptrPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortTotalErrors.setDescription('The total number of errors detected. Total errors include FCS errors, alignment errors, frame too long, short events, late events, very long event, rate mismatch, and symbol errors. (RFC2108 rptrMonitorPortTotalErrors) ')
rptrPortLastMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortLastMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortLastMACAddress.setDescription('The source address of the last readable frame received by this port. If no frames have been received on this port, the length of the returned DisplayString is zero. (RFC2108 rptrAddrTrackNewLastSrcAddress) ')
rptrPortNumberofMACAddressChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortNumberofMACAddressChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortNumberofMACAddressChanges.setDescription('The number of times that the value of rptrPortLastMACAddress has changed. The typical value for this port is 1, meaning the value of rptrPortLastMACAddress changed from all zeros to a MAC address. A high number of changes indicates a port connected to a switch or bridge. (RFC2108 rptrAddrTrackSourceAddrChanges) ')
rptrPortSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 14, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortSymbolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortSymbolErrors.setDescription('This counter is incremented by one each time a valid length packet was received at the port and there was at least one occurrence of an invalid data symbol. This can increment only once per valid carrier event. A collision presence at any port of the repeater containing port N will not cause this attribute to increment. ')
rptrChassisSegmentStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15), )
if mibBuilder.loadTexts: rptrChassisSegmentStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentStatTable.setDescription('Repeater status information by segment at the chassis level. ')
rptrChassisSegmentStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "rptrChassisIndex"), (0, "INTEL-EXPRESS110-MIB", "rptrChassisSegmentIndex"))
if mibBuilder.loadTexts: rptrChassisSegmentStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentStatEntry.setDescription('A table entry, containing repeater status information about a single chassis and segment. ')
rptrChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisIndex.setDescription('This index is the chassis number in the stack. The chassis at the top of the stack is number 1. ')
rptrChassisSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentIndex.setDescription('This index is the segment number in the stack.')
rptrChassisSegmentTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentTotalFrames.setDescription('The number of frames detected without errors. Includes unicast, broadcast, and multicast frames. Does not include frames received with frames too long, runt, FCS, or alignment errors. This is the sum of all valid received frames for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalFrames) ')
rptrChassisSegmentTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentTotalOctets.setDescription('The number of octets (bytes) contained in frames received that had no errors. This includes octets in unicast, broadcast, and multicast frames. It also includes octets after the start frame delimiter up to FCS but not including FCS octets. This is the sum of all valid received octets for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalOctets) ')
rptrChassisSegmentTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentTotalErrors.setDescription('The total number of errors detected. Total errors include FCS errors, alignment errors, frame too long, short events, late events, very long event, and rate mismatch errors. This is the sum of all errors for all ports in this repeater module. (RFC2108 rptrMonitorGroupTotalErrors) ')
rptrChassisSegmentFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentFCSErrors.setDescription("The number of frames detected that are free of partial octets and do not pass the FCS check. Usually caused by adapter underrun (when the adapter can't get enough bus bandwidth). FCS errors do not necessarily indicate that data has been lost. ")
rptrChassisSegmentAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentAlignmentErrors.setDescription('The number of frames detected that contain partial octets and do not pass the FCS check. ')
rptrChassisSegmentFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentFrameTooLongs.setDescription('The number of frames detected that exceed the maximum permitted frame size. ')
rptrChassisSegmentShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentShortEvents.setDescription('The number of fragments detected with ActivityDuration less than ShortEventMaxTime (greater than 74 bit times and less than 82 bit times). Usually indicates a network topology problem. ')
rptrChassisSegmentRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentRunts.setDescription('The number of frames detected that are less than the minimum permitted frame size of 64 octets but have a good FCS. Runts usually indicate collision fragments, a normal network event. ')
rptrChassisSegmentCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentCollisions.setDescription('Sum of all collisions for all ports in this repeater module. ')
rptrChassisSegmentLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentLateEvents.setDescription('The number of collisions detected after the allowable detection period. Usually indicates a network topology problem, such as daisy-chaining class I 100Mbps hubs with UTP cable or a network diameter that is too wide. ')
rptrChassisSegmentVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentVeryLongEvents.setDescription('The number of times MAU jabber lockup protection (MJLP) was detected due to transmission of data that exceeded 5 msec in duration (octet count greater than maxFrameSize). Can indicate a faulty device or port. ')
rptrChassisSegmentDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentDataRateMismatches.setDescription('A count of the occurrences of out-of-specification bit rates. This indicates the number of times the FIFO buffer overruns or underruns due to transmission rate errors. This could indicate an incorrect FIFO setting on a network adapter or a faulty adapter. ')
rptrChassisSegmentAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentAutoPartitions.setDescription('The number of times this port was automatically partitioned. This condition occurs when too many consecutive collisions are detected on the port. These collisions are due to excessive traffic on the segment, a malfunctioning port, or a malfunctioning adapter that is jabbering. ')
rptrChassisSegmentSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 15, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrChassisSegmentSymbolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrChassisSegmentSymbolErrors.setDescription('This counter is incremented by one when a valid length packet was received at the port and there was at least one occurrence of an invalid data symbol. This can increment only once per valid carrier event. A collision presence at any port of the repeater containing port N will not cause this attribute to increment. ')
tBrdgAdminTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16), )
if mibBuilder.loadTexts: tBrdgAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgAdminTable.setDescription('Embedded transparent bridge administration.')
tBrdgAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "tBrdgAdminSpanIndex"))
if mibBuilder.loadTexts: tBrdgAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgAdminEntry.setDescription('A table entry, containing administration information for a single embedded transparent bridge span.')
tBrdgAdminSpanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgAdminSpanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgAdminSpanIndex.setDescription('Embedded transparent bridge span number. A bridge span consists of one or more embedded transparent bridges forwarding packets between two segments.')
tBrdgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tBrdgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgAdminState.setDescription('The state of the embedded transparent bridging span. enable - Allows packets to be forwarded by embedded bridging to the peer segment. disable - Prevents packets from being forwarded by embedded bridging to the peer segment.')
tBrdgReset = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reset", 1), ("resetCounters", 2), ("notreset", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tBrdgReset.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgReset.setDescription("'reset' resets all enabled transparent bridges in the span. 'resetCounters' clears all transparent bridge statistics.")
tBrdgThrshld = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tBrdgThrshld.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgThrshld.setDescription('If the number of times the transparent bridge indicates buffer full exceeds this value, a trap is generated. Use 0 to disable. This trap is based on the number of tBrdgBufferFullCount in the last tBrdgPeriod. ')
tBrdgPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tBrdgPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgPeriod.setDescription('Time period (in minutes) that the transparent bridge buffer full count must exceed the trap threshold value in order to generate a trap.')
tBrdgLockout = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("yButtonyMgmt", 1), ("nButtonyMgmt", 2), ("yButtonnMgmt", 3), ("nButtonnMgmt", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tBrdgLockout.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgLockout.setDescription('Prevents embedded transparent bridging from being enabled or disabled via a button on the front of a hub or by the local management console interface.')
tBrdgHubId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgHubId.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgHubId.setDescription('chassisConfigTableIndex of the chassis containing the primary internal bridge for the span. All internal bridge statistics are reported as ports 101 and 102 within this hub chassis.')
tBrdgSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 16, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgSegments.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgSegments.setDescription('Embedded transparent bridge span segments. This is a list of segments (1 per byte) in this bridge span.')
tBrdgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17), )
if mibBuilder.loadTexts: tBrdgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgStatsTable.setDescription('Embedded transparent bridge statistics.')
tBrdgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "tBrdgStatsSpan"), (0, "INTEL-EXPRESS110-MIB", "tBrdgStatsSegment"))
if mibBuilder.loadTexts: tBrdgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgStatsEntry.setDescription('A table entry, containing statistics for a single embedded transparent bridge span domain.')
tBrdgStatsSpan = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgStatsSpan.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgStatsSpan.setDescription('Embedded transparent bridge span number. A bridge span consists of one or more embedded transparent bridges forwarding packets between two segments.')
tBrdgStatsSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgStatsSegment.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgStatsSegment.setDescription('Embedded transparent bridge statistics segment. This index specifies which segment is associated with the transparent bridge statistics.')
tBrdgUtilIn = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgUtilIn.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgUtilIn.setDescription("The percentage of this segment's traffic that was bridged from the peer segment during the previous second.")
tBrdgUtilOut = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgUtilOut.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgUtilOut.setDescription("The percentage of this segment's traffic which was bridged to the peer segment during the previous second.")
tBrdgBufferFullCount = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 17, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBrdgBufferFullCount.setStatus('mandatory')
if mibBuilder.loadTexts: tBrdgBufferFullCount.setDescription('The number of times internal buffer capacity was exceeded while bridging frames out of this segment.')
stackConfigExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 18))
stackClearPortSecurity = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: stackClearPortSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: stackClearPortSecurity.setDescription('Clears all active and persistent port security settings.')
express_snmp_agents = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19)).setLabel("express-snmp-agents")
e300agentConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1))
e300agentVendorName = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentVendorName.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentVendorName.setDescription("Displays the SNMP agent's manufacturer name. ")
e300agentProductName = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentProductName.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentProductName.setDescription('Displays the product name that contains the SNMP agent. ')
e300agentChassisIndex = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentChassisIndex.setDescription("Displays which chassis contains the SNMP agent's module. ")
e300agentModuleIndex = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentModuleIndex.setDescription("Displays which module in the chassis is the SNMP agent's module. The chassis number is in the object agentChassisIndex. ")
e300mibversion = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300mibversion.setStatus('mandatory')
if mibBuilder.loadTexts: e300mibversion.setDescription('Displays the version of the MIB supported by the SNMP agent. ')
e300resetAgent = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("notreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300resetAgent.setStatus('mandatory')
if mibBuilder.loadTexts: e300resetAgent.setDescription('Performs a cold reset of the SNMP agent. If a new IP configuration was set, it will be used after the reset. ')
e300agentRole = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("primaryAgent", 2), ("backupAgent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentRole.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentRole.setDescription('The current role of this agent within this hub stack.')
e300agentIpBootServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentIpBootServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentIpBootServerAddr.setDescription('The IP Address of Boot Server.')
e300agentIpUnauthAddr = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentIpUnauthAddr.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentIpUnauthAddr.setDescription('The IP address of an unauthorized SNMP packet.')
e300agentIpUnauthComm = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentIpUnauthComm.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentIpUnauthComm.setDescription('The community string of an unauthorized SNMP packet.')
e300agentIpLastBootServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentIpLastBootServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentIpLastBootServerAddr.setDescription('The last IP address used as Boot server IP address.')
e300agentIpLastIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300agentIpLastIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentIpLastIpAddr.setDescription('The last IP address used as the agent system IP address.')
e300ipConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2))
e300ipAddressMethodInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("bootp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300ipAddressMethodInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300ipAddressMethodInUse.setDescription('Displays how the IP address in use was determined. For example, fixed means the IP address was assigned by the user and stored within the Management Module. BOOTP means the SNMP agent used a BOOTP server to get its IP configuration. ')
e300ipAddressInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300ipAddressInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300ipAddressInUse.setDescription('Displays the IP address currently in use. ')
e300gatewayorRouterAddrInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300gatewayorRouterAddrInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300gatewayorRouterAddrInUse.setDescription('Displays the default gateway address currently in use. This is the device that routes to a different network. Usually a router or a routing server. ')
e300networkMaskInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300networkMaskInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300networkMaskInUse.setDescription('Displays the network (subnet) mask currently in use. This must match the masks of other devices on the same network. ')
e300broadcastAddressInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300broadcastAddressInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300broadcastAddressInUse.setDescription('Displays the broadcast address currently in use. ')
e300ipAddressMethodNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("bootp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300ipAddressMethodNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300ipAddressMethodNextReset.setDescription('Displays how the IP address will be determined after the SNMP agent is reset. For example, fixed means the IP address will be determined locally. BOOTP means the SNMP agent will search for a BOOTP server to get its IP configuration. ')
e300ipAddressNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300ipAddressNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300ipAddressNextReset.setDescription('Displays the IP address the SNMP agent will use the next time it is reset. ')
e300gatewayorRouterAddrNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300gatewayorRouterAddrNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300gatewayorRouterAddrNextReset.setDescription('Displays the default gateway the SNMP agent will use the next time it is reset. ')
e300networkMaskNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 2, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300networkMaskNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300networkMaskNextReset.setDescription('Displays the netmask (subnet mask) the SNMP agent will use the next time it is reset. ')
e300snmpConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3))
e300snmpReadCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: e300snmpReadCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpReadCommunityString.setDescription("Sets the password for reads from the SNMP agent's MIB. ")
e300snmpWriteCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: e300snmpWriteCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpWriteCommunityString.setDescription("Sets the password for writes to the SNMP agent's MIB. ")
e300snmpTrapReceiverMAX = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300snmpTrapReceiverMAX.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpTrapReceiverMAX.setDescription('Displays the maximum number of trap receiving stations. ')
e300snmpTrapReceiverNumber = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300snmpTrapReceiverNumber.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpTrapReceiverNumber.setDescription('Displays the current number of trap receiving stations. ')
e300snmpTrapAddressTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5), )
if mibBuilder.loadTexts: e300snmpTrapAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpTrapAddressTable.setDescription('Contains information on individual trap receiving stations. ')
e300snmpTrapAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "e300trapAddrIndex"))
if mibBuilder.loadTexts: e300snmpTrapAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: e300snmpTrapAddressEntry.setDescription('An entry in the table, containing information on an individual trap receiving station. ')
e300trapAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300trapAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: e300trapAddrIndex.setDescription('Displays the index number of the trap receiving station. ')
e300trapIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300trapIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: e300trapIPAddr.setDescription('Sets the IP address for a trap receiving station. ')
e300trapCommunityString = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300trapCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: e300trapCommunityString.setDescription('Sets the password for sending traps from the SNMP agent to the SNMP application on the trap receiving station. ')
e300trapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300trapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: e300trapStatus.setDescription('Displays whether traps should be sent to this station (active) or whether traps should not be sent to this station (ignore). ')
e300agentExtConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4))
e300agentSwUpdateMode = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("network-load", 2), ("out-of-band-load", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentSwUpdateMode.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentSwUpdateMode.setDescription('The download media used by the system to download the runtime firmware.')
e300agentConfigUpdateCtrl = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentConfigUpdateCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentConfigUpdateCtrl.setDescription('Current status of configuration file download control. The setting is effective the next time you reset or power on the hub.')
e300agentConfigFilename = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentConfigFilename.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentConfigFilename.setDescription('The name of the configuration file to be downloaded from the BootP or TFTP server when agentConfigUpdateCtrl is enabled.')
e300agentImageUpdateCtrl = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentImageUpdateCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentImageUpdateCtrl.setDescription('Current status of firmware image download control. The setting is effective the next time you reset or power on the hub.')
e300agentImageFilename = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentImageFilename.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentImageFilename.setDescription('The name of the image file to be downloaded from the TFTP server when agentImageUpdateCtrl is enabled.')
e300agentRs232PortConfig = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("console", 2), ("out-of-band", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentRs232PortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentRs232PortConfig.setDescription('The current setting of RS-232C port. The RS-232C port can be configured as the console port or used for out-of-band connection.')
e300agentOutOfBandBaudRateConfig = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("baudRate-1200", 2), ("baudRate-2400", 3), ("baudRate-9600", 4), ("baudRate-19200", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300agentOutOfBandBaudRateConfig.setStatus('mandatory')
if mibBuilder.loadTexts: e300agentOutOfBandBaudRateConfig.setDescription('The baud rate setting for out of band connection. The baud rate for the console interface is always 9600.')
e300slipConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5))
e300slipAddressInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300slipAddressInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipAddressInUse.setDescription('Displays the IP address currently in use. ')
e300slipGatewayorRouterAddrInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300slipGatewayorRouterAddrInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipGatewayorRouterAddrInUse.setDescription('Displays the default gateway address currently in use. This is the device that routes to a different network. Usually a router or a routing server. ')
e300slipNetworkMaskInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300slipNetworkMaskInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipNetworkMaskInUse.setDescription('Displays the network (subnet) mask currently in use. This must match the masks of other devices on the same network. ')
e300slipBroadcastAddressInUse = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300slipBroadcastAddressInUse.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipBroadcastAddressInUse.setDescription('Displays the broadcast address currently in use. ')
e300slipAddressNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300slipAddressNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipAddressNextReset.setDescription('Displays the IP address the SNMP agent will use the next time it is reset. ')
e300slipGatewayorRouterAddrNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300slipGatewayorRouterAddrNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipGatewayorRouterAddrNextReset.setDescription('Displays the default gateway the SNMP agent will use the next time it is reset. ')
e300slipNetworkMaskNextReset = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 5, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e300slipNetworkMaskNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: e300slipNetworkMaskNextReset.setDescription('Displays the netmask (subnet mask) the SNMP agent will use the next time it is reset. ')
e300mgmtBasicInfoTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6), )
if mibBuilder.loadTexts: e300mgmtBasicInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtBasicInfoTable.setDescription('A list of SNMP agent basic information.')
e300mgmtBasicInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6, 1), ).setIndexNames((0, "INTEL-EXPRESS110-MIB", "e300mgmtChassisIndex"))
if mibBuilder.loadTexts: e300mgmtBasicInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtBasicInfoEntry.setDescription('A table entry, containing SNMP agent basic information.')
e300mgmtChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300mgmtChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtChassisIndex.setDescription('Chassis number in the stack which SNMP agent located.')
e300mgmtIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300mgmtIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtIPAddress.setDescription('IP address of the SNMP agent.')
e300mgmtPhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300mgmtPhysicalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtPhysicalAddress.setDescription('Physical address of the SNMP agent.')
e300mgmtRole = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 2, 1, 19, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("primaryAgent", 2), ("backupAgent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e300mgmtRole.setStatus('mandatory')
if mibBuilder.loadTexts: e300mgmtRole.setDescription('The current role of the SNMP agent within this hub stack.')
utilizationThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,0)).setObjects(("INTEL-EXPRESS110-MIB", "rptrSegmentStatIndex"))
if mibBuilder.loadTexts: utilizationThresholdExceeded.setDescription('Utilization rate in last rptrSegmentUtilizationTrapPeriod exceeded rptrSegmentUtilizationTrapThreshold. ')
collisionThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,1)).setObjects(("INTEL-EXPRESS110-MIB", "rptrSegmentStatIndex"))
if mibBuilder.loadTexts: collisionThresholdExceeded.setDescription('Collisions in last rptrSegmentCollisionTrapPeriod exceeded rptrSegmentCollisionTrapThreshold. ')
configurationChange = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,2)).setObjects(("INTEL-EXPRESS110-MIB", "hubDescriptionString"))
if mibBuilder.loadTexts: configurationChange.setDescription('A chassis was added to the stack or removed, a chassis lost power, a module was reset or powered on, or, a repeater module changed speeds. ')
tBrdgBufferFull = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,3))
if mibBuilder.loadTexts: tBrdgBufferFull.setDescription('Buffer full rate in last tBrdgPeriod exceeded tBrdgThrshld.')
chassisRPSActive = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,4)).setObjects(("INTEL-EXPRESS110-MIB", "chassisConfigTableIndex"))
if mibBuilder.loadTexts: chassisRPSActive.setDescription('The power supply has failed and the optional Redundant Power Supply for this chassis has activated.')
portSecurityViolation = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,5)).setObjects(("INTEL-EXPRESS110-MIB", "chassisConfigTableIndex"), ("INTEL-EXPRESS110-MIB", "portIndex"))
if mibBuilder.loadTexts: portSecurityViolation.setDescription('An ethernet frame with an unauthorized source MAC address was detected on this port and the port has been disabled.')
mgmtSwitchedToBackupMgmt = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,6)).setObjects(("INTEL-EXPRESS110-MIB", "chassisConfigTableIndex"))
if mibBuilder.loadTexts: mgmtSwitchedToBackupMgmt.setDescription('Primary management module failed and switched to backup module. The value associated is the hub number of the active management module.')
bridgeConfigChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,7)).setObjects(("INTEL-EXPRESS110-MIB", "tBrdgHubId"))
if mibBuilder.loadTexts: bridgeConfigChangeEvent.setDescription("The trap is sent whenever a stack's bridge configuration is changed. The value associated is the hub number of the active bridge.")
bridgeConfigNoBridgeEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,8))
if mibBuilder.loadTexts: bridgeConfigNoBridgeEvent.setDescription('The trap is sent whenever a stack without a bridge warning')
portlinkChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,9)).setObjects(("INTEL-EXPRESS110-MIB", "portChassisIndex"), ("INTEL-EXPRESS110-MIB", "portModuleIndex"), ("INTEL-EXPRESS110-MIB", "portIndex"), ("INTEL-EXPRESS110-MIB", "portType"), ("INTEL-EXPRESS110-MIB", "portOperStatus"), ("INTEL-EXPRESS110-MIB", "portLinkTestStatusTrapCtrl"))
if mibBuilder.loadTexts: portlinkChangeEvent.setDescription('The trap is sent whenever the link state of a port changes from link up to link down or from link down to link up')
portSpeedChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 2, 2, 1) + (0,10)).setObjects(("INTEL-EXPRESS110-MIB", "portChassisIndex"), ("INTEL-EXPRESS110-MIB", "portModuleIndex"), ("INTEL-EXPRESS110-MIB", "portIndex"), ("INTEL-EXPRESS110-MIB", "portType"), ("INTEL-EXPRESS110-MIB", "portLinkSpeed"), ("INTEL-EXPRESS110-MIB", "portSpeedStatusTrapCtrl"))
if mibBuilder.loadTexts: portSpeedChangeEvent.setDescription('The trap is sent whenever the speed status of a port changes from link up to link down or from link down to link up')
mibBuilder.exportSymbols("INTEL-EXPRESS110-MIB", moduleUserAssignedName=moduleUserAssignedName, rptrChassisSegmentAutoPartitions=rptrChassisSegmentAutoPartitions, rptrSegmentStatIndex=rptrSegmentStatIndex, moduleReset=moduleReset, tBrdgAdminEntry=tBrdgAdminEntry, portLinkSpeed=portLinkSpeed, rptrSegmentConfigTable=rptrSegmentConfigTable, moduleBootSWVersion=moduleBootSWVersion, rptrPortTotalErrors=rptrPortTotalErrors, portLinkTestStatusTrapCtrl=portLinkTestStatusTrapCtrl, moduleAllPortLinkPartnerInfo=moduleAllPortLinkPartnerInfo, e300agentExtConfiguration=e300agentExtConfiguration, rptrChassisSegmentRunts=rptrChassisSegmentRunts, rptrSegmentTotalCollisions=rptrSegmentTotalCollisions, rptrPortFcsErrors=rptrPortFcsErrors, rptrChassisSegmentTotalErrors=rptrChassisSegmentTotalErrors, e300trapCommunityString=e300trapCommunityString, rptrChassisSegmentIndex=rptrChassisSegmentIndex, stackClearPortSecurity=stackClearPortSecurity, e300agentIpBootServerAddr=e300agentIpBootServerAddr, rptrSegmentUtilization=rptrSegmentUtilization, moduleSegmentMode=moduleSegmentMode, e300snmpWriteCommunityString=e300snmpWriteCommunityString, e300mgmtBasicInfoEntry=e300mgmtBasicInfoEntry, chassisSegmentMode=chassisSegmentMode, e300slipNetworkMaskNextReset=e300slipNetworkMaskNextReset, hubRFC1516Segment=hubRFC1516Segment, moduleImageFileSource=moduleImageFileSource, moduleAllPortCounterReset=moduleAllPortCounterReset, e300agentRole=e300agentRole, rptrPortAlignmentErrors=rptrPortAlignmentErrors, rptrChassisSegmentSymbolErrors=rptrChassisSegmentSymbolErrors, moduleUserAssignedType=moduleUserAssignedType, moduleLEDInfo=moduleLEDInfo, rptrPortFrameTooLongs=rptrPortFrameTooLongs, e300mgmtChassisIndex=e300mgmtChassisIndex, rptrSegmentUtilizationTrapThreshold=rptrSegmentUtilizationTrapThreshold, rptrModuleShortEvents=rptrModuleShortEvents, e300agentIpLastBootServerAddr=e300agentIpLastBootServerAddr, portSecureAdminMode=portSecureAdminMode, e300snmpTrapReceiverNumber=e300snmpTrapReceiverNumber, rptrModuleStatTable=rptrModuleStatTable, portReset=portReset, rptrSegmentPartitionedPorts=rptrSegmentPartitionedPorts, rptrSegmentUtilizationTrapPeriod=rptrSegmentUtilizationTrapPeriod, rptrSegmentSpeed=rptrSegmentSpeed, portAllCountersReset=portAllCountersReset, e300agentConfigFilename=e300agentConfigFilename, moduleSizeofRAM=moduleSizeofRAM, portChassisIndex=portChassisIndex, portConfigEntry=portConfigEntry, moduleTotalPortCount=moduleTotalPortCount, rptrModuleTotalOctets=rptrModuleTotalOctets, e300agentConfiguration=e300agentConfiguration, moduleUserAssignedNumber=moduleUserAssignedNumber, tBrdgStatsSegment=tBrdgStatsSegment, e300agentProductName=e300agentProductName, rptrPortVeryLongEvents=rptrPortVeryLongEvents, e300agentIpUnauthAddr=e300agentIpUnauthAddr, e300networkMaskNextReset=e300networkMaskNextReset, portlinkChangeEvent=portlinkChangeEvent, rptrPortLateEvents=rptrPortLateEvents, bridgeConfigNoBridgeEvent=bridgeConfigNoBridgeEvent, tBrdgSegments=tBrdgSegments, tBrdgPeriod=tBrdgPeriod, e300mibversion=e300mibversion, hubDescriptionString=hubDescriptionString, modulePersistentMemoryReset=modulePersistentMemoryReset, e300gatewayorRouterAddrNextReset=e300gatewayorRouterAddrNextReset, moduleOperationalStatus=moduleOperationalStatus, rptrPortRunts=rptrPortRunts, e300ipConfiguration=e300ipConfiguration, e300networkMaskInUse=e300networkMaskInUse, e300mgmtRole=e300mgmtRole, rptrModuleAlignmentErrors=rptrModuleAlignmentErrors, rptrChassisSegmentShortEvents=rptrChassisSegmentShortEvents, e300snmpTrapAddressTable=e300snmpTrapAddressTable, tBrdgReset=tBrdgReset, hubLCDSleepText=hubLCDSleepText, bridgeConfigChangeEvent=bridgeConfigChangeEvent, rptrSegmentPartitionThreshold=rptrSegmentPartitionThreshold, rptrChassisSegmentLateEvents=rptrChassisSegmentLateEvents, express_snmp_agents=express_snmp_agents, e300agentIpUnauthComm=e300agentIpUnauthComm, e300mgmtBasicInfoTable=e300mgmtBasicInfoTable, e300slipBroadcastAddressInUse=e300slipBroadcastAddressInUse, rptrSegmentZeroCounters=rptrSegmentZeroCounters, e300agentOutOfBandBaudRateConfig=e300agentOutOfBandBaudRateConfig, utilizationThresholdExceeded=utilizationThresholdExceeded, portSpeedChangeEvent=portSpeedChangeEvent, rptrChassisSegmentDataRateMismatches=rptrChassisSegmentDataRateMismatches, rptrPortDataRateMismatches=rptrPortDataRateMismatches, rptrModuleVeryLongEvents=rptrModuleVeryLongEvents, e300agentSwUpdateMode=e300agentSwUpdateMode, rptrSegmentCollisionTrapThreshold=rptrSegmentCollisionTrapThreshold, configurationChange=configurationChange, e300slipNetworkMaskInUse=e300slipNetworkMaskInUse, moduleAllPortLEDInfo=moduleAllPortLEDInfo, rptrPortNumberofMACAddressChanges=rptrPortNumberofMACAddressChanges, rptrChassisSegmentStatEntry=rptrChassisSegmentStatEntry, e300ipAddressMethodInUse=e300ipAddressMethodInUse, rptrChassisSegmentStatTable=rptrChassisSegmentStatTable, portConfigTable=portConfigTable, moduleType=moduleType, portLEDInfo=portLEDInfo, rptrChassisSegmentTotalFrames=rptrChassisSegmentTotalFrames, e300agentIpLastIpAddr=e300agentIpLastIpAddr, rptrModuleIndex=rptrModuleIndex, chassisRPSState=chassisRPSState, rptrChassisSegmentAlignmentErrors=rptrChassisSegmentAlignmentErrors, moduleConfigStatusEntry=moduleConfigStatusEntry, rptrChassisIndex=rptrChassisIndex, tBrdgAdminSpanIndex=tBrdgAdminSpanIndex, chassisConfigEntry=chassisConfigEntry, hubStackReset=hubStackReset, portLinkPartnerInfo=portLinkPartnerInfo, portPolarityStatus=portPolarityStatus, express110=express110, rptrChassisSegmentCollisions=rptrChassisSegmentCollisions, rptrModuleDataRateMismatches=rptrModuleDataRateMismatches, moduleLastErrorID=moduleLastErrorID, moduleAllPortOperStatus=moduleAllPortOperStatus, rptrSegmentReset=rptrSegmentReset, hubLCDSleepTime=hubLCDSleepTime, moduleAllPortSpeed=moduleAllPortSpeed, rptrPortShortEvents=rptrPortShortEvents, rptrPortCollisions=rptrPortCollisions, portType=portType, e300snmpReadCommunityString=e300snmpReadCommunityString, e300snmpConfiguration=e300snmpConfiguration, e300agentChassisIndex=e300agentChassisIndex, rptrPortLastMACAddress=rptrPortLastMACAddress, rptrSegmentTotalOctets=rptrSegmentTotalOctets, rptrSegmentConfigEntry=rptrSegmentConfigEntry, rptrSegmentConfigIndex=rptrSegmentConfigIndex, rptrChassisSegmentTotalOctets=rptrChassisSegmentTotalOctets, rptrChassisSegmentVeryLongEvents=rptrChassisSegmentVeryLongEvents, tBrdgUtilOut=tBrdgUtilOut, e300agentRs232PortConfig=e300agentRs232PortConfig, rptrSegmentCollisionTrapPeriod=rptrSegmentCollisionTrapPeriod, chassisConfigTableIndex=chassisConfigTableIndex, moduleMediaDevicesReset=moduleMediaDevicesReset, e300ipAddressNextReset=e300ipAddressNextReset, moduleConfigStatusTable=moduleConfigStatusTable, rptrPortChassisIndex=rptrPortChassisIndex, e300slipAddressInUse=e300slipAddressInUse, e300slipGatewayorRouterAddrNextReset=e300slipGatewayorRouterAddrNextReset, rptrChassisSegmentFCSErrors=rptrChassisSegmentFCSErrors, tBrdgStatsEntry=tBrdgStatsEntry, e300snmpTrapAddressEntry=e300snmpTrapAddressEntry, portLastErrorID=portLastErrorID, rptrModuleTotalErrors=rptrModuleTotalErrors, tBrdgBufferFullCount=tBrdgBufferFullCount, e300slipConfiguration=e300slipConfiguration, e300gatewayorRouterAddrInUse=e300gatewayorRouterAddrInUse, chassisConfigTable=chassisConfigTable, moduleImageFileName=moduleImageFileName, moduleImageDownloadControl=moduleImageDownloadControl, portJabber=portJabber, moduleSizeofROM=moduleSizeofROM, rptrPortStatEntry=rptrPortStatEntry, tBrdgHubId=tBrdgHubId, portIndex=portIndex, portOperStatus=portOperStatus, hubNumberofStackedChassis=hubNumberofStackedChassis, chassisIsolate=chassisIsolate, moduleAllPortAdminStatus=moduleAllPortAdminStatus, moduleAgentSWVersion=moduleAgentSWVersion, portSegmentAdminMode=portSegmentAdminMode, rptrSegmentResetMedia=rptrSegmentResetMedia, rptrSegmentTotalErrors=rptrSegmentTotalErrors, rptrSegmentOperationalStatus=rptrSegmentOperationalStatus, rptrSegmentStatTable=rptrSegmentStatTable, rptrSegmentHealthText=rptrSegmentHealthText, e300trapAddrIndex=e300trapAddrIndex, hubLCDModeVariable=hubLCDModeVariable, portSpeedStatusTrapCtrl=portSpeedStatusTrapCtrl, portAdminStatus=portAdminStatus, moduleAllPortSpeedInfo=moduleAllPortSpeedInfo, e300mgmtPhysicalAddress=e300mgmtPhysicalAddress, stackConfigExtensions=stackConfigExtensions, moduleIndex=moduleIndex, rptrPortReadableFrames=rptrPortReadableFrames, rptrPortStatTable=rptrPortStatTable, moduleHWDescription=moduleHWDescription, e300ipAddressInUse=e300ipAddressInUse, portTimeSinceLastLinkChange=portTimeSinceLastLinkChange, rptrPortAutoPartitions=rptrPortAutoPartitions, e300agentVendorName=e300agentVendorName, rptrSegmentNonDisruptTest=rptrSegmentNonDisruptTest, tBrdgUtilIn=tBrdgUtilIn, moduleChassisIndex=moduleChassisIndex, moduleSegmentLockout=moduleSegmentLockout, e300agentConfigUpdateCtrl=e300agentConfigUpdateCtrl, e300slipGatewayorRouterAddrInUse=e300slipGatewayorRouterAddrInUse, tBrdgThrshld=tBrdgThrshld, mgmtSwitchedToBackupMgmt=mgmtSwitchedToBackupMgmt, e300agentImageUpdateCtrl=e300agentImageUpdateCtrl, tBrdgAdminState=tBrdgAdminState, portModuleIndex=portModuleIndex, rptrModuleFCSErrors=rptrModuleFCSErrors, tBrdgBufferFull=tBrdgBufferFull, e300agentModuleIndex=e300agentModuleIndex, e300trapIPAddr=e300trapIPAddr, rptrModuleTotalFrames=rptrModuleTotalFrames, e300agentImageFilename=e300agentImageFilename, rptrModuleCollisions=rptrModuleCollisions, portSecurityViolation=portSecurityViolation, rptrModuleAutoPartitions=rptrModuleAutoPartitions, e300snmpTrapReceiverMAX=e300snmpTrapReceiverMAX, moduleExternalPortCount=moduleExternalPortCount, e300trapStatus=e300trapStatus, rptrPortPartitionState=rptrPortPartitionState, rptrPortReadableOctets=rptrPortReadableOctets, rptrPortSymbolErrors=rptrPortSymbolErrors, tBrdgStatsSpan=tBrdgStatsSpan, e300slipAddressNextReset=e300slipAddressNextReset, chassisReset=chassisReset, tBrdgStatsTable=tBrdgStatsTable, moduleManufacturingInfo=moduleManufacturingInfo, moduleUptime=moduleUptime, rptrModuleRunts=rptrModuleRunts, rptrSegmentTotalFrames=rptrSegmentTotalFrames, e300resetAgent=e300resetAgent, rptrSegmentStatEntry=rptrSegmentStatEntry, tBrdgAdminTable=tBrdgAdminTable, tBrdgLockout=tBrdgLockout, rptrModuleStatEntry=rptrModuleStatEntry, e300mgmtIPAddress=e300mgmtIPAddress, portLinkTestState=portLinkTestState, e300broadcastAddressInUse=e300broadcastAddressInUse, rptrPortIndex=rptrPortIndex, moduleImageDownloadStatus=moduleImageDownloadStatus, portSecureMAC=portSecureMAC, chassisRPSActive=chassisRPSActive, moduleAllPortTimeSinceLinkChange=moduleAllPortTimeSinceLinkChange, portSegmentOperStatus=portSegmentOperStatus, rptrModuleLateEvents=rptrModuleLateEvents, e300ipAddressMethodNextReset=e300ipAddressMethodNextReset, collisionThresholdExceeded=collisionThresholdExceeded, rptrChassisSegmentFrameTooLongs=rptrChassisSegmentFrameTooLongs, rptrModuleFrameTooLongs=rptrModuleFrameTooLongs)

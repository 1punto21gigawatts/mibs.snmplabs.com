#
# PySNMP MIB module VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/VPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:35:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, iso, TimeTicks, ObjectIdentity, ModuleIdentity, Bits, Counter32, enterprises, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, mgmt, NotificationType, Counter64, IpAddress, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "iso", "TimeTicks", "ObjectIdentity", "ModuleIdentity", "Bits", "Counter32", "enterprises", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "mgmt", "NotificationType", "Counter64", "IpAddress", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
vpnet = MibIdentifier((1, 3, 6, 1, 4, 1, 1866))
vpnmib = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7))
waninterface = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7, 1))
vpns = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7, 2))
log = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7, 3))
vsuSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7, 4))
activeSessions = MibIdentifier((1, 3, 6, 1, 4, 1, 1866, 7, 5))
wanIfTable = MibTable((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1), )
if mibBuilder.loadTexts: wanIfTable.setStatus('mandatory')
wanIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1), ).setIndexNames((0, "VPN-MIB", "wanIfIndex"))
if mibBuilder.loadTexts: wanIfEntry.setStatus('mandatory')
wanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfIndex.setDescription('A unique value for each interface. 1 - Private port 2 - Public port')
wanIfFramesRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfFramesRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfFramesRcvd.setDescription('Total frames received on this interface.')
wanIfFramesXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfFramesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfFramesXmit.setDescription('Total frames transmitted on this interface.')
wanIfFramesDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfFramesDisc.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfFramesDisc.setDescription('Total frames discarded on this interface.')
wanIfRcvOvrn = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvOvrn.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvOvrn.setDescription('Total frames received on this interface with data overrun errors.')
wanIfRcvAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvAbort.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvAbort.setDescription('Total frames received on this interface aborted by the sender.')
wanIfRcvAlignErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvAlignErr.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvAlignErr.setDescription('Total frames received on this interface with alignment errors.')
wanIfRcvCRCErr = MibScalar((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvCRCErr.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvCRCErr.setDescription('Total frames received on this interface with CRC errors.')
wanIfRcvFrameLong = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvFrameLong.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvFrameLong.setDescription('Total frames received on this interface with length errors.')
wanIfRcvNoBuff = MibScalar((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvNoBuff.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvNoBuff.setDescription('Total frames for which there were no receive buffers available.')
wanIfXmitUnderrun = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfXmitUnderrun.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfXmitUnderrun.setDescription('Total frames with transmit underrun errors.')
wanIfXmitTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfXmitTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfXmitTimeout.setDescription("Total times we've timed out trying to transmit a frame.")
wanIfXmitNoBuff = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfXmitNoBuff.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfXmitNoBuff.setDescription('Total times there were no transmit buffers available when trying to transmit a frame.')
wanIfRcvByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfRcvByteRate.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfRcvByteRate.setDescription('last 16 second average KB per second of data received.')
wanIfXmitByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIfXmitByteRate.setStatus('mandatory')
if mibBuilder.loadTexts: wanIfXmitByteRate.setDescription('last 16 second average KB per second of data sent.')
vpnTable = MibTable((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1), )
if mibBuilder.loadTexts: vpnTable.setStatus('mandatory')
vpnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1), ).setIndexNames((0, "VPN-MIB", "vpnIndex"))
if mibBuilder.loadTexts: vpnEntry.setStatus('mandatory')
vpnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vpnIndex.setDescription("A unique value for each VPN. Ranges from 1 to (number of VPNs configured + number of clients configured). So, this table will not map 1-to-1 with the VPNs configured via VPNmanager when VPNRemote clients are configured as part of a VPN. Each client has it's own physical VPN on a VSU.")
vpnDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vpnDescr.setDescription('Textual description of this interface. Currently (1/9/98) just shows the VPN decimal id.')
vpnSkipInPktDecap = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipInPktDecap.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipInPktDecap.setDescription('Total incoming SKIP-decapsulated packets for this VPN.')
vpnSkipOutPktEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipOutPktEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipOutPktEncap.setDescription('Total outgoing SKIP-encapsulated packets for this VPN.')
vpnSkipInPktParseErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipInPktParseErr.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipInPktParseErr.setDescription('Total incoming packets for this VPN with IPSec header errors.')
vpnSkipInKPUpdt = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipInKPUpdt.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipInKPUpdt.setDescription('Number of Kp (key material) updates for incoming traffic this VPN. Not currently supported.')
vpnSkipOutKPUpdt = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipOutKPUpdt.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipOutKPUpdt.setDescription('Number of Kp (key material) updates for outgoing traffic this VPN. Not currently supported.')
vpnOutFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnOutFrag.setStatus('mandatory')
if mibBuilder.loadTexts: vpnOutFrag.setDescription('Total outgoing packets for this VPN that had to be fragmented.')
vpnOctetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnOctetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: vpnOctetsIn.setDescription('Total bytes received for this VPN.')
vpnOctetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnOctetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: vpnOctetsOut.setDescription('Total bytes sent for this VPN.')
vpnNOutOfOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnNOutOfOrder.setStatus('mandatory')
if mibBuilder.loadTexts: vpnNOutOfOrder.setDescription('Counter N out-of-order errors for this VPN. Not currently supported.')
vpnSkipAlgMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnSkipAlgMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: vpnSkipAlgMismatch.setDescription("Total number of packets belonging to this VPN with SKIP Algorithm mismatches. That is, the parameters of the VPN that this packet belongs to does not match the VPN parameters in the packet's SKIP header.")
vpnAuthInPktInvdSig = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnAuthInPktInvdSig.setStatus('mandatory')
if mibBuilder.loadTexts: vpnAuthInPktInvdSig.setDescription('Total number of packets belonging to this VPN with SKIP Authentication errors. That is, the authentication key in the offending packet was not correct. This type of attack results in an authFailure trap which shows up on the VPNmanager as Invalid Authentication Signature.')
vpnAuthInPktParseErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnAuthInPktParseErr.setStatus('mandatory')
if mibBuilder.loadTexts: vpnAuthInPktParseErr.setDescription('Not currently supported.')
vpnEncryptImpEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnEncryptImpEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vpnEncryptImpEncap.setDescription('Total outgoing packets encrypted for this VPN.')
vpnEncryptInPktParseErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 2, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpnEncryptInPktParseErr.setStatus('mandatory')
if mibBuilder.loadTexts: vpnEncryptInPktParseErr.setDescription('Total packets belonging to this VPN that had parse errors. For example, encrypted data was not on a 8-byte boundary or the ESP trailer was not of the appropriate size.')
logTable = MibTable((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1), )
if mibBuilder.loadTexts: logTable.setStatus('mandatory')
logEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1, 1), ).setIndexNames((0, "VPN-MIB", "logIndex"))
if mibBuilder.loadTexts: logEntry.setStatus('mandatory')
logIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logIndex.setStatus('mandatory')
logTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logTime.setStatus('mandatory')
logAttackType = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logAttackType.setStatus('mandatory')
if mibBuilder.loadTexts: logAttackType.setDescription("The type of packet error that caused us to perceive this as an attack. 1 - SKIP header error. e.g. this packet was not IPSec AH or IPSec ESP. 2 - SKIP Counter N error. Not currently (1/9/98) supported. 3 - SKIP Algorithm mismatch. The parameters of the VPN that this packet belongs to does not match the VPN parameters in the SKIP header. 4 - SKIP Authentication error. The authentication key in the offending packet was not correct. This type of attack results in an authFailure trap which shows up on the VPNmanager as Invalid Authentication Signature. 5 - SKIP Authentication Header error. Not supported. 6 - SKIP Encryption Header error. The packet's ESP trailer wasn't correct.")
logDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 65))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logDescription.setStatus('mandatory')
cpuUtilization = MibScalar((1, 3, 6, 1, 4, 1, 1866, 7, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilization.setStatus('mandatory')
activeSessionTable = MibTable((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1), )
if mibBuilder.loadTexts: activeSessionTable.setStatus('mandatory')
activeSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1), ).setIndexNames((0, "VPN-MIB", "asName"))
if mibBuilder.loadTexts: activeSessionEntry.setStatus('mandatory')
asName = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asName.setStatus('mandatory')
if mibBuilder.loadTexts: asName.setDescription('A VPNremote client name or a VSU name as defined in VPNmanager.')
asLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asLength.setStatus('mandatory')
if mibBuilder.loadTexts: asLength.setDescription('Length of this session in seconds.')
asOrgIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asOrgIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: asOrgIPAddress.setDescription("VPNremote client's originating IP address or remote VSU IP address.")
asXlateIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asXlateIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: asXlateIPAddress.setDescription("VPNremote client's assigned address from the Client IP Address pool if configured. If the Client IP Address pool is not configured or this session is from a VSU then this attribute is empty.")
asDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asDescr.setStatus('mandatory')
if mibBuilder.loadTexts: asDescr.setDescription('Textual description of this VPN indicating what key management is being used and what encryption, authentication and compression algorithms are being used. For example: IKE, 3DES, MD5, Compression.')
asPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: asPktsIn.setDescription('Number of packets sent to this VSU from the VPNremote Client or remote VSU indicated by asName during this session.')
asPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: asPktsOut.setDescription('Number of packets sent from this VSU to the VPNremote Client or remote VSU indicated by asName during this session.')
asBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asBytesIn.setStatus('mandatory')
if mibBuilder.loadTexts: asBytesIn.setDescription('Number of bytes sent to this VSU from the VPNremote Client or remote VSU indicated by asName during this session.')
asBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 1866, 7, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asBytesOut.setStatus('mandatory')
if mibBuilder.loadTexts: asBytesOut.setDescription('Number of bytes sent from this VSU to the VPNremote Client or remote VSU indicated by asName during this session.')
skipHdrErr = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,1))
if mibBuilder.loadTexts: skipHdrErr.setDescription('SKIP header error. e.g. this packet was not IPSec AH or IPSec ESP.')
skipNCounterErr = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,2))
if mibBuilder.loadTexts: skipNCounterErr.setDescription('SKIP Count N error. Not used.')
skipAlgMismatch = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,3))
if mibBuilder.loadTexts: skipAlgMismatch.setDescription('SKIP Algorithm mismatch. The parameters of the VPN that a packet belonged to did not match the VPN parameters in the SKIP header.')
authFailure = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,4))
if mibBuilder.loadTexts: authFailure.setDescription('SKIP Authentication error. The authentication key in the offending packet was not correct. This trap shows up on the VPNmanager as Invalid Authentication Signature.')
authHdrErr = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,5))
if mibBuilder.loadTexts: authHdrErr.setDescription('SKIP Authentication Header error. Not used.')
encryptHdrErr = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,6))
if mibBuilder.loadTexts: encryptHdrErr.setDescription("SKIP Encryption Header error. The packet's ESP trailer wasn't correct.")
authFailureLimitErr = NotificationType((1, 3, 6, 1, 4, 1, 1866) + (0,7))
if mibBuilder.loadTexts: authFailureLimitErr.setDescription('Client Configuration Download failure limit reached.')
mibBuilder.exportSymbols("VPN-MIB", wanIfXmitByteRate=wanIfXmitByteRate, activeSessions=activeSessions, wanIfXmitNoBuff=wanIfXmitNoBuff, wanIfXmitUnderrun=wanIfXmitUnderrun, vpns=vpns, vpnTable=vpnTable, asPktsOut=asPktsOut, wanIfFramesDisc=wanIfFramesDisc, vpnEncryptInPktParseErr=vpnEncryptInPktParseErr, logIndex=logIndex, authFailure=authFailure, wanIfRcvFrameLong=wanIfRcvFrameLong, vpnmib=vpnmib, activeSessionEntry=activeSessionEntry, asPktsIn=asPktsIn, vpnOutFrag=vpnOutFrag, wanIfRcvAbort=wanIfRcvAbort, asDescr=asDescr, wanIfRcvByteRate=wanIfRcvByteRate, vpnEncryptImpEncap=vpnEncryptImpEncap, vpnSkipInPktParseErr=vpnSkipInPktParseErr, activeSessionTable=activeSessionTable, asLength=asLength, skipNCounterErr=skipNCounterErr, wanIfRcvOvrn=wanIfRcvOvrn, wanIfRcvAlignErr=wanIfRcvAlignErr, wanIfIndex=wanIfIndex, vpnSkipAlgMismatch=vpnSkipAlgMismatch, skipAlgMismatch=skipAlgMismatch, asXlateIPAddress=asXlateIPAddress, wanIfFramesRcvd=wanIfFramesRcvd, log=log, vpnSkipOutPktEncap=vpnSkipOutPktEncap, vpnSkipInPktDecap=vpnSkipInPktDecap, wanIfEntry=wanIfEntry, asName=asName, wanIfFramesXmit=wanIfFramesXmit, vsuSystem=vsuSystem, logDescription=logDescription, vpnOctetsIn=vpnOctetsIn, skipHdrErr=skipHdrErr, cpuUtilization=cpuUtilization, vpnSkipOutKPUpdt=vpnSkipOutKPUpdt, vpnAuthInPktInvdSig=vpnAuthInPktInvdSig, vpnSkipInKPUpdt=vpnSkipInKPUpdt, logTable=logTable, authFailureLimitErr=authFailureLimitErr, wanIfRcvCRCErr=wanIfRcvCRCErr, vpnOctetsOut=vpnOctetsOut, authHdrErr=authHdrErr, logTime=logTime, vpnIndex=vpnIndex, wanIfXmitTimeout=wanIfXmitTimeout, vpnet=vpnet, logEntry=logEntry, vpnEntry=vpnEntry, wanIfRcvNoBuff=wanIfRcvNoBuff, vpnAuthInPktParseErr=vpnAuthInPktParseErr, asBytesIn=asBytesIn, logAttackType=logAttackType, asBytesOut=asBytesOut, vpnNOutOfOrder=vpnNOutOfOrder, encryptHdrErr=encryptHdrErr, wanIfTable=wanIfTable, asOrgIPAddress=asOrgIPAddress, waninterface=waninterface, vpnDescr=vpnDescr)

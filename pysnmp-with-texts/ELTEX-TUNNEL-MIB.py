#
# PySNMP MIB module ELTEX-TUNNEL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ELTEX-TUNNEL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:02:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
eltexLtd, = mibBuilder.importSymbols("ELTEX-SMI-ACTUAL", "eltexLtd")
IANAtunnelType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAtunnelType")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, Gauge32, Counter64, Integer32, TimeTicks, Counter32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Unsigned32, NotificationType, iso, transmission, IpAddress, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Gauge32", "Counter64", "Integer32", "TimeTicks", "Counter32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Unsigned32", "NotificationType", "iso", "transmission", "IpAddress", "MibIdentifier")
TruthValue, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "DisplayString", "TextualConvention")
eltexTunnelMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 35265, 21))
eltexTunnelMIB.setRevisions(('2015-12-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: eltexTunnelMIB.setRevisionsDescriptions(('First revision of ELTEX-TUNNEL-MIB',))
if mibBuilder.loadTexts: eltexTunnelMIB.setLastUpdated('201512290000Z')
if mibBuilder.loadTexts: eltexTunnelMIB.setOrganization('Eltex')
if mibBuilder.loadTexts: eltexTunnelMIB.setContactInfo('EMail: eltex@eltex.nsk.ru')
if mibBuilder.loadTexts: eltexTunnelMIB.setDescription('The MIB module for management of WiFi Tunnels, independent of the specific encapsulation scheme in use.')
tunnelWiFiConfigTable = MibTable((1, 3, 6, 1, 4, 1, 35265, 21, 1), )
if mibBuilder.loadTexts: tunnelWiFiConfigTable.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigTable.setDescription('The (conceptual) table containing information on configured Wi-Fi tunnels. This table can be used to map a set of WiFi tunnel endpoints to the associated ifIndex value. It can also be used for row creation. Note that every row in the tunnelIfTable with a fixed IPv4 destination address should have a corresponding row in the tunnelWiFiConfigTable, regardless of whether it was created via SNMP. This table does not support IPv6.')
tunnelWiFiConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1), ).setIndexNames((0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigLocalAddressType"), (0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigLocalAddress"), (0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigRemoteAddressType"), (0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigRemoteAddress"), (0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigEncapsMethod"), (0, "ELTEX-TUNNEL-MIB", "tunnelWiFiConfigID"))
if mibBuilder.loadTexts: tunnelWiFiConfigEntry.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigEntry.setDescription('An entry (conceptual row) containing the information on a particular configured tunnel.')
tunnelWiFiConfigLocalAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 1), InetAddressType())
if mibBuilder.loadTexts: tunnelWiFiConfigLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigLocalAddressType.setDescription('The type of address in the corresponding tunnelWiFiConfigLocalAddress.')
tunnelWiFiConfigLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 2), InetAddress())
if mibBuilder.loadTexts: tunnelWiFiConfigLocalAddress.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigLocalAddress.setDescription('The address of the local endpoint of the Wi-Fi tunnel, or 0.0.0.0 if the device is free to choose any of its addresses at Wi-Fi tunnel establishment time.')
tunnelWiFiConfigRemoteAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 3), InetAddressType())
if mibBuilder.loadTexts: tunnelWiFiConfigRemoteAddressType.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigRemoteAddressType.setDescription('The type of address in the corresponding tunnelWiFiConfigRemoteAddress.')
tunnelWiFiConfigRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 4), InetAddress())
if mibBuilder.loadTexts: tunnelWiFiConfigRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigRemoteAddress.setDescription('The address of the remote endpoint of the Wi-Fi tunnel.')
tunnelWiFiConfigEncapsMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 5), IANAtunnelType())
if mibBuilder.loadTexts: tunnelWiFiConfigEncapsMethod.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigEncapsMethod.setDescription('The encapsulation method used by the Wi-Fi tunnel.')
tunnelWiFiConfigID = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: tunnelWiFiConfigID.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigID.setDescription('An identifier used to distinguish between multiple Wi-Fi tunnels of the same encapsulation method, with the same endpoints. If the encapsulation protocol only allows one tunnel per set of endpoint addresses (such as for GRE or IP-in-IP), the value of this object is 1. For encapsulation methods (such as L2F) which allow multiple parallel tunnels, the manager is responsible for choosing any ID which does not conflict with an existing row, such as choosing a random number.')
tunnelWiFiConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelWiFiConfigIfIndex.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigIfIndex.setDescription('If the value of tunnelWiFiConfigStatus for this row is active, then this object contains the value of ifIndex corresponding to the Wi-Fi tunnel interface. A value of 0 is not legal in the active state, and means that the interface index has not yet been assigned.')
tunnelWiFiConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tunnelWiFiConfigStatus.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigStatus.setDescription('The status of this row, by which new entries may be created, or old entries deleted from this table. The agent need not support setting this object to createAndWait or notInService since there are no other writable objects in this table, and writable objects in rows of corresponding tables such as the tunnelIfTable may be modified while this row is active. To create a row in this table for an encapsulation method which does not support multiple parallel tunnels with the same endpoints, the management station should simply use a tunnelWiFiConfigID of 1, and set tunnelWiFiConfigStatus to createAndGo. For encapsulation methods such as L2F which allow multiple parallel tunnels, the management station may select a pseudo-random number to use as the tunnelConfigID and set tunnelConfigStatus to createAndGo. In the event that this ID is already in use and an inconsistentValue is returned in response to the set operation, the management station should simply select a new pseudo-random number and retry the operation. Creating a row in this table will cause an interface index to be assigned by the agent in an implementation-dependent manner, and corresponding rows will be instantiated in the ifTable and the tunnelIfTable. The status of this row will become active as soon as the agent assigns the interface index, regardless of whether the interface is operationally up. Deleting a row in this table will likewise delete the corresponding row in the ifTable and in the tunnelIfTable.')
tunnelWiFiConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notConfigured", 0), ("management", 1), ("data", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelWiFiConfigMode.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigMode.setDescription('Type of Wi-Fi tunnel: notConfigured(0), management(1), data(2).')
tunnelWiFiConfigDefaultProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 35265, 21, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelWiFiConfigDefaultProfile.setStatus('current')
if mibBuilder.loadTexts: tunnelWiFiConfigDefaultProfile.setDescription('If an instance of this object has the value true, this tunnel is a template for create other tunnels and has ip address 0.0.0.0')
mibBuilder.exportSymbols("ELTEX-TUNNEL-MIB", tunnelWiFiConfigStatus=tunnelWiFiConfigStatus, tunnelWiFiConfigLocalAddress=tunnelWiFiConfigLocalAddress, tunnelWiFiConfigEntry=tunnelWiFiConfigEntry, tunnelWiFiConfigLocalAddressType=tunnelWiFiConfigLocalAddressType, tunnelWiFiConfigRemoteAddress=tunnelWiFiConfigRemoteAddress, tunnelWiFiConfigDefaultProfile=tunnelWiFiConfigDefaultProfile, tunnelWiFiConfigRemoteAddressType=tunnelWiFiConfigRemoteAddressType, tunnelWiFiConfigID=tunnelWiFiConfigID, tunnelWiFiConfigIfIndex=tunnelWiFiConfigIfIndex, tunnelWiFiConfigEncapsMethod=tunnelWiFiConfigEncapsMethod, PYSNMP_MODULE_ID=eltexTunnelMIB, tunnelWiFiConfigTable=tunnelWiFiConfigTable, eltexTunnelMIB=eltexTunnelMIB, tunnelWiFiConfigMode=tunnelWiFiConfigMode)

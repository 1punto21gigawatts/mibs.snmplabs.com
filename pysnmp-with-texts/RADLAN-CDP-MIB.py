#
# PySNMP MIB module RADLAN-CDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-CDP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:45:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
cdpCacheEntry, cdpCacheDeviceIndex, cdpCacheIfIndex = mibBuilder.importSymbols("CISCO-CDP-MIB", "cdpCacheEntry", "cdpCacheDeviceIndex", "cdpCacheIfIndex")
CiscoNetworkAddress, CiscoNetworkProtocol = mibBuilder.importSymbols("CISCO-TC", "CiscoNetworkAddress", "CiscoNetworkProtocol")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
PortList, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList", "VlanId")
rndErrorSeverity, rndErrorDesc = mibBuilder.importSymbols("RADLAN-DEVICEPARAMS-MIB", "rndErrorSeverity", "rndErrorDesc")
rnd, rndNotifications = mibBuilder.importSymbols("RADLAN-MIB", "rnd", "rndNotifications")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, ObjectIdentity, Gauge32, NotificationType, iso, Unsigned32, MibIdentifier, Integer32, Counter64, Bits, TimeTicks, Counter32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ObjectIdentity", "Gauge32", "NotificationType", "iso", "Unsigned32", "MibIdentifier", "Integer32", "Counter64", "Bits", "TimeTicks", "Counter32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
MacAddress, DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "TruthValue", "TextualConvention")
rlCdp = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 137))
rlCdp.setRevisions(('2008-09-14 00:00', '2010-08-11 00:00', '2010-10-25 00:00', '2010-11-10 00:00', '2010-11-14 00:00', '2011-01-09 00:00', '2011-02-15 00:00', '2012-02-14 00:00', '2015-03-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlCdp.setRevisionsDescriptions(('Initial revision.', 'Added rlCdpLogMismatchVoiceVlanEnable, rlCdpLogMismatchNativeVlanEnable', 'Added rlCdpSecondaryCacheTable. Added maxNeighborsExceededInSecondaryCache. Renamed maxNeighborsExceeded to maxNeighborsExceededInMainCache.', 'Added rlCdpGlobalLogMismatchDuplexEnable. Added rlCdpGlobalLogMismatchVoiceVlanEnable. Added rlCdpGlobalLogMismatchNativeVlanEnable.', 'Added rlCdpTlvTable. Added rlCdpAdvertiseApplianceTlv.', 'Added rlCdpValidateMandatoryTlvs.', 'Added rlCdpLogMismatchDuplexTrap. Added rlCdpLogMismatchVoiceVlanTrap. Added rlCdpLogMismatchNativeVlanTrap.', 'Added rlCdpTlvSysName to rlCdpTlvTable.', 'Added rlCdpTlvPowerRequestTable. Added rlCdpSecondaryCacheAddressTable. Added rlCdpSecondaryCacheRequestedPowerTable. Added rlCdpTlvPowerConsumption, rlCdpTlvPowerRequestedRequestId, rlCdpTlvPowerRequestedPowerManagementId, rlCdpTlvSparePairPoECapabilities to rlCdpTlvEntry. Added rlCdpSecondaryCachePowerAvailable, rlCdpSecondaryCachePowerConsumption, rlCdpSecondaryCacheSparePairPoECapabilities, rlCdpSecondaryCacheDeviceId, rlCdpSecondaryCachePortId to rlCdpSecondaryCacheEntry.',))
if mibBuilder.loadTexts: rlCdp.setLastUpdated('201503040000Z')
if mibBuilder.loadTexts: rlCdp.setOrganization('Marvell Technology Group Ltd.')
if mibBuilder.loadTexts: rlCdp.setContactInfo('marvell.com')
if mibBuilder.loadTexts: rlCdp.setDescription('The private MIB module definition for CDP protocol.')
class RlCdpVersionTypes(TextualConvention, Integer32):
    description = 'version-v1 - cdp version 1 version-v2 - cdp version 2 '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("version-v1", 1), ("version-v2", 2))

class RlCdpCounterTypes(TextualConvention, Integer32):
    description = ' v1OutputPackets counter specifies the number of sent CDP packets with version 1 v2OutputPackets counter specifies the number of sent CDP packets with version 2 v1InputPackets counter specifies the number of received CDP packets with version 1 v2InputPackets counter specifies the number of received CDP packets with version 2 totalInputPackets counter specifies the total number of received CDP packets totalOutputPackets counter specifies the total number of sent CDP packets illegalChksum counter specifies the number of received CDP packets with illegal checksum. errorPackets counter specifies the number of received CDP packets with other error (duplicated TLVs, illegal TLVs, etc.) maxNeighborsExceededInMainCache counter specifies the number of times a CDP neighbor could not be stored in the main cache. maxNeighborsExceededInSecondaryCache specifies counter the number of times a CDP neighbor could not be stored in the secondary cache. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("totalInputPackets", 1), ("v1InputPackets", 2), ("v2InputPackets", 3), ("totalOutputPackets", 4), ("v1OutputPackets", 5), ("v2OutputPackets", 6), ("illegalChksum", 7), ("errorPackets", 8), ("maxNeighborsExceededInMainCache", 9), ("maxNeighborsExceededInSecondaryCache", 10))

class RlCdpPduActionTypes(TextualConvention, Integer32):
    description = 'filtering - CDP packets would filtered (dropped). bridging - CDP packets bridged as regular data packets '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("filtering", 1), ("bridging", 2), ("flooding", 3))

rlCdpVersionAdvertised = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 1), RlCdpVersionTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpVersionAdvertised.setStatus('current')
if mibBuilder.loadTexts: rlCdpVersionAdvertised.setDescription('Specifies the verison of sent CDP packets')
rlCdpSourceInterface = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 2), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpSourceInterface.setStatus('current')
if mibBuilder.loadTexts: rlCdpSourceInterface.setDescription('Specifices the CDP source-interface, which the IP address advertised into TLV is accoding to this source-interface instead of the outgoing interface. value of 0 indicates no source interface. value must belong to an ethernet port/lag ')
rlCdpLogMismatchDuplexEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpLogMismatchDuplexEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchDuplexEnable.setDescription('Enable logging messages when detecting mishmatch between advertised and received duplex mode. To enable loging on specific interface set the corresponing bit.')
rlCdpCountersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 4), )
if mibBuilder.loadTexts: rlCdpCountersTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpCountersTable.setDescription('This table contains all cdp counter values, indexed by conter name')
rlCdpCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 4, 1), ).setIndexNames((0, "RADLAN-CDP-MIB", "rlCdpCountersName"))
if mibBuilder.loadTexts: rlCdpCountersEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpCountersEntry.setDescription('The row definition for this table.')
rlCdpCountersName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 4, 1, 1), RlCdpCounterTypes())
if mibBuilder.loadTexts: rlCdpCountersName.setStatus('current')
if mibBuilder.loadTexts: rlCdpCountersName.setDescription('counter name used as key for counters table ')
rlCdpCountersValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpCountersValue.setStatus('current')
if mibBuilder.loadTexts: rlCdpCountersValue.setDescription('the value of the counter name specisifed by rlCdpCountersName, unsuppo will have no entry in the tab.')
rlCdpCountersClear = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpCountersClear.setStatus('current')
if mibBuilder.loadTexts: rlCdpCountersClear.setDescription('By setting the MIB to True, all error and traffic counters are set to zero.')
rlCdpCacheClear = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpCacheClear.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheClear.setDescription('By setting the MIB to True, all entries from the cdp cache table is deleted.')
rlCdpVoiceVlanId = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpVoiceVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: rlCdpVoiceVlanId.setDescription('voice vlan Id, used as the Appliance Vlan-Id TLV')
rlCdpCacheTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 8), )
if mibBuilder.loadTexts: rlCdpCacheTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheTable.setDescription('The (conceptual) table contains externtion for the cdpCache table. indexed by cdpCacheEntry.')
rlCdpCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 8, 1), )
cdpCacheEntry.registerAugmentions(("RADLAN-CDP-MIB", "rlCdpCacheEntry"))
rlCdpCacheEntry.setIndexNames(*cdpCacheEntry.getIndexNames())
if mibBuilder.loadTexts: rlCdpCacheEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheEntry.setDescription('The row definition for this table.')
rlCdpCacheVersionExt = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 8, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpCacheVersionExt.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheVersionExt.setDescription('This field contains the extention of the cdpCacheVersion field in the cdpCache table. In case the neighbour advertised the SW TLV as a string with length larger than 160, this field contains the chacters from place 160 and on. Zero-length strings indicates no Version field (TLV) was reported in the most recent CDP message, or it was smaller than 160 chars ')
rlCdpCacheTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpCacheTimeToLive.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheTimeToLive.setDescription('This field indicates the time remains in seconds till the entry should be expried. ')
rlCdpCacheCdpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 8, 1, 3), RlCdpVersionTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpCacheCdpVersion.setStatus('current')
if mibBuilder.loadTexts: rlCdpCacheCdpVersion.setDescription('This field indicates the cdp version that was reported in the most recent CDP message.')
rlCdpPduAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 9), RlCdpPduActionTypes().clone('bridging')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpPduAction.setStatus('current')
if mibBuilder.loadTexts: rlCdpPduAction.setDescription('Defines CDP packets handling when CDP is globally disabled.')
rlCdpLogMismatchVoiceVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 10), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpLogMismatchVoiceVlanEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchVoiceVlanEnable.setDescription('Enable logging messages when detecting mishmatch between advertised and received voice VLAN. To enable logging on specific interface set the corresponing bit.')
rlCdpLogMismatchNativeVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 11), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpLogMismatchNativeVlanEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchNativeVlanEnable.setDescription('Enable logging messages when detecting mishmatch between advertised and received native VLAN. To enable loging on specific interface set the corresponing bit.')
rlCdpSecondaryCacheTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 12), )
if mibBuilder.loadTexts: rlCdpSecondaryCacheTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheTable.setDescription('The (conceptual) table contains partial information from cdpCache table. indexed by rlCdpSecondaryCacheEntry.')
rlCdpSecondaryCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 12, 1), ).setIndexNames((0, "CISCO-CDP-MIB", "cdpCacheIfIndex"), (0, "CISCO-CDP-MIB", "cdpCacheDeviceIndex"))
if mibBuilder.loadTexts: rlCdpSecondaryCacheEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheEntry.setDescription('An entry (conceptual row) in the rlCdpSecondaryCacheTable, containing partial information received via CDP on one interface from one device. Entries appear when a CDP advertisement is received from a neighbor device. Entries disappear when CDP is disabled on the interface, globally or when the secondary cache is cleared')
rlCdpSecondaryCacheMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheMacAddress.setDescription('The MAC address of the neighbor.')
rlCdpSecondaryCachePlatform = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCachePlatform.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCachePlatform.setDescription("The Device's Hardware Platform prefix, as reported in the most recent CDP message. The zero-length string indicates that no Platform field (TLV) was reported in the most recent CDP message.")
rlCdpSecondaryCacheCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheCapabilities.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheCapabilities.setDescription("The Device's Functional Capabilities as reported in the most recent CDP message.")
rlCdpSecondaryCacheVoiceVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheVoiceVlanID.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheVoiceVlanID.setDescription("The remote device's VoIP VLAN ID, as reported in the most recent CDP message. This object is not instantiated if no Appliance VLAN-ID field (TLV) was reported in the most recently received CDP message.")
rlCdpSecondaryCacheTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheTimeToLive.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheTimeToLive.setDescription('This field indicates the number of seconds till the entry is expried. ')
rlCdpSecondaryCachePowerAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCachePowerAvailable.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCachePowerAvailable.setDescription("The remote device's available power, as reported in the most recent CDP message. A value of 0xFFFFFFFF indicates that no Power Available TLV was reported in the most recently received CDP message.")
rlCdpSecondaryCachePowerConsumption = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCachePowerConsumption.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCachePowerConsumption.setDescription("The remote device's consumed power, as reported in the most recent CDP message. A value of 0xFFFFFFFF indicates that no Power Consumption TLV was reported in the most recently received CDP message.")
rlCdpSecondaryCacheSparePairPoECapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 10), Bits().clone(namedValues=NamedValues(("supported", 0), ("detectionClassificationRequired", 1), ("desiredState", 2), ("operationalState", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheSparePairPoECapabilities.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheSparePairPoECapabilities.setDescription("The remote device's Spare-Pair (4-wire) Power-Over-Ethernet negotiation capabilities. The bit 'supported(0)' indicates that the device supports Spare Pair POE. The bit 'detectionClassificationRequired(1)' indicates that the device requires detection/classification on the spare-pair. The bit 'desiredState(2)' indicates whether the PD device desires power on the spare pair. The bit 'operationalState(3)' indicates whether the PSE device supplies power on the spare pair.")
rlCdpSecondaryCacheDeviceId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheDeviceId.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheDeviceId.setDescription("The remote device's Device-ID prefix, as reported in the most recent CDP message. The zero-length string indicates that no Device-ID TLV was reported in the most recent CDP message.")
rlCdpSecondaryCachePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 12, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCachePortId.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCachePortId.setDescription("The remote device's Port-ID prefix, as reported in the most recent CDP message. The zero-length string indicates that no Port-ID TLV was reported in the most recent CDP message.")
rlCdpGlobalLogMismatchDuplexEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchDuplexEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchDuplexEnable.setDescription('Globally enable/disable logging messages when detecting mishmatch between advertised and received duplex mode.')
rlCdpGlobalLogMismatchVoiceVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 14), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchVoiceVlanEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchVoiceVlanEnable.setDescription('Globally enable/disable logging messages when detecting mishmatch between advertised and received voice VLAN.')
rlCdpGlobalLogMismatchNativeVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 15), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchNativeVlanEnable.setStatus('current')
if mibBuilder.loadTexts: rlCdpGlobalLogMismatchNativeVlanEnable.setDescription('Globally enable/disable logging messages when detecting mishmatch between advertised and received native VLAN.')
rlCdpTlvTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 16), )
if mibBuilder.loadTexts: rlCdpTlvTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvTable.setDescription('The (conceptual) table contains the local advertised information. indexed by rlCdpTlvEntry.')
rlCdpTlvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 16, 1), ).setIndexNames((0, "RADLAN-CDP-MIB", "rlCdpTlvIfIndex"))
if mibBuilder.loadTexts: rlCdpTlvEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvEntry.setDescription('An entry (conceptual row) in the rlCdpTlvTable, containing local information advertised by CDP on one interface. Entries are available only when CDP is globally enabled, for interfaces on which CDP is enabled and the interface state is UP.')
rlCdpTlvIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rlCdpTlvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvIfIndex.setDescription('The ifIndex value of the local interface. A value of zero is used to access TLVs which do not changed between interfaces.')
rlCdpTlvDeviceIdFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("serialNumber", 1), ("macAddress", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvDeviceIdFormat.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvDeviceIdFormat.setDescription('An indication of the format of Device-Id contained in the corresponding instance of rlCdpTlvDeviceId. serialNumber(1) indicates that the value of rlCdpTlvDeviceId object is in the form of an ASCII string contain the device serial number. macAddress(2) indicates that the value of rlCdpTlvDeviceId object is in the form of Layer 2 MAC address. other(3) indicates that the value of rlCdpTlvDeviceId object is in the form of a platform specific ASCII string contain info that identifies the device. For example: ASCII string contains serialNumber appended/prepened with system name.')
rlCdpTlvDeviceId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvDeviceId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvDeviceId.setDescription('The Device-ID string as will be advertised in subsequent CDP messages.')
rlCdpTlvAddress1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress1Type.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress1Type.setDescription('The Inet address type of rlCdpTlvAddress1')
rlCdpTlvAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress1.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress1.setDescription("The (first) network-layer address of the device as will be advertised in the Address TLV of subsequent CDP messages. For example, if the corresponding instance of rlCdpTlvAddress1Type had the value 'ipv4(1)', then this object would be an IPv4-address.")
rlCdpTlvAddress2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress2Type.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress2Type.setDescription('The Inet address type of rlCdpTlvAddress2')
rlCdpTlvAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress2.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress2.setDescription("The (first) network-layer address of the device as will be advertised in the Address TLV of subsequent CDP messages. For example, if the corresponding instance of rlCdpTlvAddress2Type had the value 'ipv6(2)', then this object would be an IPv6-address.")
rlCdpTlvAddress3Type = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress3Type.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress3Type.setDescription('The Inet address type of rlCdpTlvAddress3')
rlCdpTlvAddress3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvAddress3.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvAddress3.setDescription("The (first) network-layer address of the device as will be advertised in the Address TLV of subsequent CDP messages. For example, if the corresponding instance of rlCdpTlvAddress3Type had the value 'ipv6(2)', then this object would be an IPv6-address.")
rlCdpTlvPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPortId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPortId.setDescription("The Port-ID string as will be advertised in subsequent CDP messages from this interface. This will typically be the value of the ifName object (e.g., 'Ethernet0').")
rlCdpTlvCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvCapabilities.setReference('Cisco Discovery Protocol Specification, 10/19/94.')
if mibBuilder.loadTexts: rlCdpTlvCapabilities.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvCapabilities.setDescription("The Device's Functional Capabilities as will be advertised in subsequent CDP messages. For latest set of specific values, see the latest version of the CDP specification.")
rlCdpTlvVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvVersion.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvVersion.setDescription('The Version string as will be advertised in subsequent CDP messages.')
rlCdpTlvPlatform = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPlatform.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPlatform.setDescription("The Device's Hardware Platform as will be advertised in subsequent CDP messages.")
rlCdpTlvNativeVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvNativeVLAN.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvNativeVLAN.setDescription("The local device's interface's native VLAN, as will be advertised in subsequent CDP messages.")
rlCdpTlvDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("halfduplex", 2), ("fullduplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvDuplex.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvDuplex.setDescription("The local device's interface's duplex mode, as will be advertised in subsequent CDP messages.")
rlCdpTlvApplianceID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvApplianceID.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvApplianceID.setDescription("The local device's Appliance ID, as will be advertised in subsequent CDP messages. A value of zero denotes no Appliance VLAN-ID TLV will be advertised in subsequent CDP messages.")
rlCdpTlvApplianceVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvApplianceVlanID.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvApplianceVlanID.setDescription("The local device's VoIP VLAN ID, as will be advertised in subsequent CDP messages. A value of zero denotes no Appliance VLAN-ID TLV will be advertised in subsequent CDP messages.")
rlCdpTlvExtendedTrust = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("untrusted", 0), ("trusted", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvExtendedTrust.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvExtendedTrust.setDescription("The local device's interface's extended trust mode, as will be advertised in subsequent CDP messages. A value of zero indicates the absence of extended trust.")
rlCdpTlvCosForUntrustedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvCosForUntrustedPorts.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvCosForUntrustedPorts.setDescription('The COS value with which all packets received on an untrusted port should be marked by a simple switching device which cannot itself classify individual packets. This TLV only has any meaning if corresponding instance of rlCdpTlvExtendedTrust indicates the absence of extended trust.')
rlCdpTlvPowerAvailableRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerAvailableRequestId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerAvailableRequestId.setDescription('The Power Available TLV Request-ID field echoes the Request-ID field last received in a Power Requested TLV. It is 0 if no Power Requested TLV has been received since the interface last transitioned to ifOperState == Up.')
rlCdpTlvPowerAvailablePowerManagementId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerAvailablePowerManagementId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerAvailablePowerManagementId.setDescription('The Power Available TLV Power-Management-ID field.')
rlCdpTlvPowerAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerAvailable.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerAvailable.setDescription('The Power Available TLV Available-Power field indicates the number of milliwatts of power available to powered devices at the time this object is instatiated. A value of 0xFFFFFFFF indicates that the Power Available TLV is not advertised.')
rlCdpTlvPowerAvailableManagementPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerAvailableManagementPowerLevel.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerAvailableManagementPowerLevel.setDescription("The Power Available TLV Management-Power-Level field indicates the number of milliwatts representing the supplier's request to the powered device for its Power Consumption TLV. A value of 0xFFFFFFFF indicates the local device has no preference.")
rlCdpTlvSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 24), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvSysName.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvSysName.setDescription('The sysName MIB as will be advertised in subsequent CDP messages.')
rlCdpTlvPowerConsumption = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerConsumption.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerConsumption.setDescription('The value of Power Consumption TLV indicates the maximum amount of power, in milliwatts, expected to be obtained and consumed from the interface over which the CDP packet is sent. A value of 0xFFFFFFFF indicates the TLV is not advertised.')
rlCdpTlvPowerRequestedRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerRequestedRequestId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestedRequestId.setDescription('The Power Requested TLV Request-ID field. A value of zero indicates that the Power Requested TLV is not advertised.')
rlCdpTlvPowerRequestedPowerManagementId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerRequestedPowerManagementId.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestedPowerManagementId.setDescription('The Power Requested TLV Power-Management-ID field echoes the Management- Power-ID field in the last received Power Available TLV, or to 0, if no Power Available TLV has been received.')
rlCdpTlvSparePairPoECapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 16, 1, 28), Bits().clone(namedValues=NamedValues(("supported", 0), ("detectionClassificationRequired", 1), ("desiredState", 2), ("operationalState", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvSparePairPoECapabilities.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvSparePairPoECapabilities.setDescription("The capabilities advertised in the Spare-Pair POE TLV. The bit 'supported(0)' indicates that the device supports Spare Pair POE. The bit 'detectionClassificationRequired(1)' indicates that the device requires detection/classification on the spare-pair. The bit 'desiredState(2)' indicates whether the PD device desires power on the spare pair. The bit 'operationalState(3)' indicates whether the PSE device supplies power on the spare pair.")
rlCdpTlvPowerRequestTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 21), )
if mibBuilder.loadTexts: rlCdpTlvPowerRequestTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestTable.setDescription('The (conceptual) table contains the local advertised requested power levels in Power Requested TLV. indexed by rlCdpTlvPowerRequestEntry.')
rlCdpTlvPowerRequestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 21, 1), ).setIndexNames((0, "RADLAN-CDP-MIB", "rlCdpTlvIfIndex"), (0, "RADLAN-CDP-MIB", "rlCdpTlvPowerRequestPowerLevelIndex"))
if mibBuilder.loadTexts: rlCdpTlvPowerRequestEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestEntry.setDescription('An entry (conceptual row) in the rlCdpTlvPowerRequestTable, containing locally requested power levels advertised by CDP on one interface. Entries are available only when CDP is globally enabled, for interfaces on which CDP is enabled and the interface state is UP.')
rlCdpTlvPowerRequestPowerLevelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 21, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rlCdpTlvPowerRequestPowerLevelIndex.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestPowerLevelIndex.setDescription('An index to the list of Requested-Power-Level in Power Requested TLV.')
rlCdpTlvPowerRequestPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 21, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpTlvPowerRequestPowerLevel.setStatus('current')
if mibBuilder.loadTexts: rlCdpTlvPowerRequestPowerLevel.setDescription('A possible value of the Power Consumption TLV, in milliwatts')
rlCdpSecondaryCacheAddressTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 22), )
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressTable.setDescription('The (conceptual) table containing the list of network-layer addresses of a neighbor interface, as reported in the Address TLV of the most recently received CDP message and stored in the secondary cache.')
rlCdpSecondaryCacheAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 22, 1), ).setIndexNames((0, "CISCO-CDP-MIB", "cdpCacheIfIndex"), (0, "CISCO-CDP-MIB", "cdpCacheDeviceIndex"), (0, "RADLAN-CDP-MIB", "rlCdpSecondaryCacheAddressIndex"))
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressEntry.setDescription('An entry (conceptual row) in the rlCdpSecondaryCacheAddressTable, containing the list of network-layer addresses of a neighbor interface, as reported in the Address TLV of the most recently received CDP message and stored in the secondary cache. Entries are available only when CDP is globally enabled, for interfaces on which CDP is enabled and the interface state is UP.')
rlCdpSecondaryCacheAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 22, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressIndex.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressIndex.setDescription('The index of the address entry for a given cdpCacheIfIndex,cdpCacheDeviceIndex pair.')
rlCdpSecondaryCacheAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 22, 1, 4), CiscoNetworkProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressType.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddressType.setDescription('An indication of the type of address contained in the corresponding instance of rlCdpSecondaryCacheAddress')
rlCdpSecondaryCacheAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 22, 1, 5), CiscoNetworkAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddress.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheAddress.setDescription("A network-layer address of the device as reported in the most recent CDP message's Address TLV. For example, if the the corresponding instance of rlCdpSecondaryCacheAddressType had the value 'ip(1)', then this object would be an IPv4-address.")
rlCdpSecondaryCacheRequestedPowerTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 23), )
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerTable.setDescription('The (conceptual) table containing the list of requested power levels by a remote device, as reported in the Power Requested TLV of the most recently received CDP message and stored in the secondary cache.')
rlCdpSecondaryCacheRequestedPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 23, 1), ).setIndexNames((0, "CISCO-CDP-MIB", "cdpCacheIfIndex"), (0, "CISCO-CDP-MIB", "cdpCacheDeviceIndex"), (0, "RADLAN-CDP-MIB", "rlCdpSecondaryCacheRequestedPowerIndex"))
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerEntry.setDescription('An entry (conceptual row) in the rlCdpSecondaryCacheRequestedPowerTable, containing the list of requested power levels by a remote device, as reported in the Power Requested TLV of the most recently received CDP message and stored in the secondary cache. Entries are available only when CDP is globally enabled, for interfaces on which CDP is enabled and the interface state is UP.')
rlCdpSecondaryCacheRequestedPowerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 23, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerIndex.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerIndex.setDescription('The index of the requested power level entry for a given cdpCacheIfIndex,cdpCacheDeviceIndex pair.')
rlCdpSecondaryCacheRequestedPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 23, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerLevel.setStatus('current')
if mibBuilder.loadTexts: rlCdpSecondaryCacheRequestedPowerLevel.setDescription('A requested power level in the Power Requested TLV, in milliwatts.')
rlCdpAdvertiseApplianceTlv = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 17), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpAdvertiseApplianceTlv.setStatus('current')
if mibBuilder.loadTexts: rlCdpAdvertiseApplianceTlv.setDescription('By setting the MIB to True Appliance VLAN-ID TLV may be advertised. A value of False will prevent this TLV from being advertised.')
rlCdpValidateMandatoryTlvs = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 18), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpValidateMandatoryTlvs.setStatus('current')
if mibBuilder.loadTexts: rlCdpValidateMandatoryTlvs.setDescription('By setting the MIB to true all mandatory TLVs 0x0001-0x0006 will be validated. Incoming CDP frames without any of the TLVs will be dropped. A value of false indicates that only the Device ID TLV (0x0001) is mandatory. Frames containing Device ID TLV will be processed, regardless of whether other TLVs are present or not.')
rlCdpInterfaceCountersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 137, 19), )
if mibBuilder.loadTexts: rlCdpInterfaceCountersTable.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceCountersTable.setDescription('This table contains all CDP counter values, indexed by interface id.')
rlCdpInterfaceCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 137, 19, 1), ).setIndexNames((0, "RADLAN-CDP-MIB", "rlCdpInterfaceId"))
if mibBuilder.loadTexts: rlCdpInterfaceCountersEntry.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceCountersEntry.setDescription('The row definition for this table.')
rlCdpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlCdpInterfaceId.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceId.setDescription('Interface id, used as index for interface counters table.')
rlCdpInterfaceTotalInputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceTotalInputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceTotalInputPackets.setDescription('Num of received packets on rlCdpInterfaceId')
rlCdpInterfaceV1InputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceV1InputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceV1InputPackets.setDescription('Num of v1 received packets on rlCdpInterfaceId')
rlCdpInterfaceV2InputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceV2InputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceV2InputPackets.setDescription('Num of v2 received packets on rlCdpInterfaceId')
rlCdpInterfaceTotalOutputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceTotalOutputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceTotalOutputPackets.setDescription('Num of sent packets from rlCdpInterfaceId')
rlCdpInterfaceV1OutputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceV1OutputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceV1OutputPackets.setDescription('Num of v1 sent packets from rlCdpInterfaceId')
rlCdpInterfaceV2OutputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceV2OutputPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceV2OutputPackets.setDescription('Num of v2 sent packets from rlCdpInterfaceId')
rlCdpInterfaceIllegalChksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceIllegalChksum.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceIllegalChksum.setDescription('Num of received packets with illegal CDP checksum.')
rlCdpInterfaceErrorPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceErrorPackets.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceErrorPackets.setDescription('specifies the number of received CDP packets with other error (duplicated TLVs, illegal TLVs, etc.) ')
rlCdpInterfaceMaxNeighborsExceededInMainCache = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceMaxNeighborsExceededInMainCache.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceMaxNeighborsExceededInMainCache.setDescription('specifies the number of times a CDP neighbor could not be stored in the main cache. ')
rlCdpInterfaceMaxNeighborsExceededInSecondaryCache = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 137, 19, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCdpInterfaceMaxNeighborsExceededInSecondaryCache.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceMaxNeighborsExceededInSecondaryCache.setDescription(' specifies the number of times a CDP neighbor could not be stored in the secondary cache.')
rlCdpInterfaceCountersClear = MibScalar((1, 3, 6, 1, 4, 1, 89, 137, 20), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCdpInterfaceCountersClear.setStatus('current')
if mibBuilder.loadTexts: rlCdpInterfaceCountersClear.setDescription('By setting the scalar to a interface id , all error and traffic counters of this interface are set to zero. To clear the counters for ALL interfaces set the scalar to 0x0FFFFFFF')
rlCdpLogMismatchDuplexTrap = NotificationType((1, 3, 6, 1, 4, 1, 89, 0, 224)).setObjects(("RADLAN-DEVICEPARAMS-MIB", "rndErrorDesc"), ("RADLAN-DEVICEPARAMS-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlCdpLogMismatchDuplexTrap.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchDuplexTrap.setDescription('Warning trap indicating that duplex mismatch has been detected by CDP')
rlCdpLogMismatchVoiceVlanTrap = NotificationType((1, 3, 6, 1, 4, 1, 89, 0, 225)).setObjects(("RADLAN-DEVICEPARAMS-MIB", "rndErrorDesc"), ("RADLAN-DEVICEPARAMS-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlCdpLogMismatchVoiceVlanTrap.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchVoiceVlanTrap.setDescription('Warning trap indicating that voice vlan mismatch has been detected by CDP')
rlCdpLogMismatchNativeVlanTrap = NotificationType((1, 3, 6, 1, 4, 1, 89, 0, 226)).setObjects(("RADLAN-DEVICEPARAMS-MIB", "rndErrorDesc"), ("RADLAN-DEVICEPARAMS-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlCdpLogMismatchNativeVlanTrap.setStatus('current')
if mibBuilder.loadTexts: rlCdpLogMismatchNativeVlanTrap.setDescription('Warning trap indicating that native vlan mismatch has been detected by CDP')
mibBuilder.exportSymbols("RADLAN-CDP-MIB", rlCdpCountersTable=rlCdpCountersTable, rlCdpLogMismatchDuplexEnable=rlCdpLogMismatchDuplexEnable, rlCdpTlvSysName=rlCdpTlvSysName, rlCdpTlvTable=rlCdpTlvTable, rlCdpCountersValue=rlCdpCountersValue, rlCdpTlvDeviceIdFormat=rlCdpTlvDeviceIdFormat, rlCdpInterfaceCountersEntry=rlCdpInterfaceCountersEntry, rlCdpTlvPowerRequestPowerLevel=rlCdpTlvPowerRequestPowerLevel, rlCdpTlvCapabilities=rlCdpTlvCapabilities, rlCdpTlvAddress3=rlCdpTlvAddress3, rlCdpInterfaceV1InputPackets=rlCdpInterfaceV1InputPackets, rlCdpCountersEntry=rlCdpCountersEntry, rlCdpSecondaryCacheRequestedPowerLevel=rlCdpSecondaryCacheRequestedPowerLevel, rlCdpInterfaceV2OutputPackets=rlCdpInterfaceV2OutputPackets, rlCdpTlvPowerRequestTable=rlCdpTlvPowerRequestTable, rlCdpTlvAddress2=rlCdpTlvAddress2, rlCdpInterfaceCountersTable=rlCdpInterfaceCountersTable, rlCdpTlvPowerConsumption=rlCdpTlvPowerConsumption, rlCdpSecondaryCacheAddressIndex=rlCdpSecondaryCacheAddressIndex, RlCdpVersionTypes=RlCdpVersionTypes, rlCdpVoiceVlanId=rlCdpVoiceVlanId, rlCdpTlvPowerRequestPowerLevelIndex=rlCdpTlvPowerRequestPowerLevelIndex, rlCdpSecondaryCacheVoiceVlanID=rlCdpSecondaryCacheVoiceVlanID, rlCdpInterfaceMaxNeighborsExceededInSecondaryCache=rlCdpInterfaceMaxNeighborsExceededInSecondaryCache, rlCdpSecondaryCacheTable=rlCdpSecondaryCacheTable, rlCdpCountersName=rlCdpCountersName, PYSNMP_MODULE_ID=rlCdp, rlCdpInterfaceCountersClear=rlCdpInterfaceCountersClear, rlCdpTlvExtendedTrust=rlCdpTlvExtendedTrust, rlCdpSecondaryCachePortId=rlCdpSecondaryCachePortId, rlCdpTlvSparePairPoECapabilities=rlCdpTlvSparePairPoECapabilities, rlCdpInterfaceTotalInputPackets=rlCdpInterfaceTotalInputPackets, rlCdpSecondaryCacheAddressEntry=rlCdpSecondaryCacheAddressEntry, rlCdpTlvPowerAvailableManagementPowerLevel=rlCdpTlvPowerAvailableManagementPowerLevel, rlCdpTlvAddress1=rlCdpTlvAddress1, rlCdpTlvApplianceID=rlCdpTlvApplianceID, rlCdpSecondaryCachePowerConsumption=rlCdpSecondaryCachePowerConsumption, rlCdpTlvCosForUntrustedPorts=rlCdpTlvCosForUntrustedPorts, rlCdpTlvNativeVLAN=rlCdpTlvNativeVLAN, rlCdpCacheClear=rlCdpCacheClear, rlCdpSecondaryCacheAddressType=rlCdpSecondaryCacheAddressType, rlCdpTlvVersion=rlCdpTlvVersion, rlCdpAdvertiseApplianceTlv=rlCdpAdvertiseApplianceTlv, RlCdpPduActionTypes=RlCdpPduActionTypes, rlCdpLogMismatchNativeVlanEnable=rlCdpLogMismatchNativeVlanEnable, rlCdpTlvIfIndex=rlCdpTlvIfIndex, rlCdpLogMismatchVoiceVlanTrap=rlCdpLogMismatchVoiceVlanTrap, rlCdpTlvEntry=rlCdpTlvEntry, rlCdpVersionAdvertised=rlCdpVersionAdvertised, rlCdpInterfaceV2InputPackets=rlCdpInterfaceV2InputPackets, rlCdpCacheCdpVersion=rlCdpCacheCdpVersion, rlCdpTlvPowerAvailablePowerManagementId=rlCdpTlvPowerAvailablePowerManagementId, rlCdpGlobalLogMismatchVoiceVlanEnable=rlCdpGlobalLogMismatchVoiceVlanEnable, rlCdpTlvDeviceId=rlCdpTlvDeviceId, rlCdpTlvPowerRequestedRequestId=rlCdpTlvPowerRequestedRequestId, rlCdpSecondaryCachePowerAvailable=rlCdpSecondaryCachePowerAvailable, rlCdpSecondaryCacheRequestedPowerEntry=rlCdpSecondaryCacheRequestedPowerEntry, rlCdpSecondaryCacheSparePairPoECapabilities=rlCdpSecondaryCacheSparePairPoECapabilities, rlCdpLogMismatchVoiceVlanEnable=rlCdpLogMismatchVoiceVlanEnable, rlCdpCacheVersionExt=rlCdpCacheVersionExt, rlCdpCacheTable=rlCdpCacheTable, rlCdpSecondaryCacheEntry=rlCdpSecondaryCacheEntry, rlCdpGlobalLogMismatchNativeVlanEnable=rlCdpGlobalLogMismatchNativeVlanEnable, rlCdpTlvDuplex=rlCdpTlvDuplex, RlCdpCounterTypes=RlCdpCounterTypes, rlCdpInterfaceMaxNeighborsExceededInMainCache=rlCdpInterfaceMaxNeighborsExceededInMainCache, rlCdpTlvApplianceVlanID=rlCdpTlvApplianceVlanID, rlCdpSecondaryCacheRequestedPowerIndex=rlCdpSecondaryCacheRequestedPowerIndex, rlCdpTlvPowerAvailable=rlCdpTlvPowerAvailable, rlCdpTlvPlatform=rlCdpTlvPlatform, rlCdpInterfaceV1OutputPackets=rlCdpInterfaceV1OutputPackets, rlCdpSecondaryCacheCapabilities=rlCdpSecondaryCacheCapabilities, rlCdpSecondaryCachePlatform=rlCdpSecondaryCachePlatform, rlCdpSecondaryCacheMacAddress=rlCdpSecondaryCacheMacAddress, rlCdpValidateMandatoryTlvs=rlCdpValidateMandatoryTlvs, rlCdpTlvPowerRequestedPowerManagementId=rlCdpTlvPowerRequestedPowerManagementId, rlCdpSecondaryCacheTimeToLive=rlCdpSecondaryCacheTimeToLive, rlCdpTlvPowerRequestEntry=rlCdpTlvPowerRequestEntry, rlCdpCacheTimeToLive=rlCdpCacheTimeToLive, rlCdpInterfaceIllegalChksum=rlCdpInterfaceIllegalChksum, rlCdpLogMismatchDuplexTrap=rlCdpLogMismatchDuplexTrap, rlCdpGlobalLogMismatchDuplexEnable=rlCdpGlobalLogMismatchDuplexEnable, rlCdp=rlCdp, rlCdpTlvAddress2Type=rlCdpTlvAddress2Type, rlCdpSourceInterface=rlCdpSourceInterface, rlCdpTlvPortId=rlCdpTlvPortId, rlCdpInterfaceId=rlCdpInterfaceId, rlCdpInterfaceErrorPackets=rlCdpInterfaceErrorPackets, rlCdpSecondaryCacheAddress=rlCdpSecondaryCacheAddress, rlCdpInterfaceTotalOutputPackets=rlCdpInterfaceTotalOutputPackets, rlCdpTlvAddress1Type=rlCdpTlvAddress1Type, rlCdpCountersClear=rlCdpCountersClear, rlCdpSecondaryCacheDeviceId=rlCdpSecondaryCacheDeviceId, rlCdpTlvPowerAvailableRequestId=rlCdpTlvPowerAvailableRequestId, rlCdpPduAction=rlCdpPduAction, rlCdpSecondaryCacheAddressTable=rlCdpSecondaryCacheAddressTable, rlCdpSecondaryCacheRequestedPowerTable=rlCdpSecondaryCacheRequestedPowerTable, rlCdpCacheEntry=rlCdpCacheEntry, rlCdpLogMismatchNativeVlanTrap=rlCdpLogMismatchNativeVlanTrap, rlCdpTlvAddress3Type=rlCdpTlvAddress3Type)

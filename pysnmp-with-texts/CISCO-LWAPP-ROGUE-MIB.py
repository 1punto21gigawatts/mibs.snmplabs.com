#
# PySNMP MIB module CISCO-LWAPP-ROGUE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LWAPP-ROGUE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:06:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
cLApName, = mibBuilder.importSymbols("CISCO-LWAPP-AP-MIB", "cLApName")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter64, ObjectIdentity, TimeTicks, MibIdentifier, IpAddress, Counter32, NotificationType, Gauge32, iso, Integer32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter64", "ObjectIdentity", "TimeTicks", "MibIdentifier", "IpAddress", "Counter32", "NotificationType", "Gauge32", "iso", "Integer32", "Unsigned32")
StorageType, TextualConvention, TruthValue, RowStatus, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "TruthValue", "RowStatus", "DisplayString", "MacAddress")
ciscoLwappRogueMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 610))
ciscoLwappRogueMIB.setRevisions(('2014-07-14 00:00', '2011-09-07 00:00', '2011-03-11 00:00', '2010-07-17 00:00', '2007-02-06 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoLwappRogueMIB.setRevisionsDescriptions(('Added new object group - ciscoLwappRogueConfigSup4Group Added new compliance - ciscoLwappRogueMIBComplianceRev4.', 'Added following objects: cLRogueReportInterval cLRogueMinimumRssi cLRogueTransientInterval. Deprecated ciscoLwappRogueMIBComplianceRev2 and added ciscoLwappRogueMIBComplianceRev3.', 'Added following objects: cLRldpAutoContainLevel cLRldpAutoContainOnlyforMonitorModeAps. Deprecated ciscoLwappRogueMIBComplianceRev1 and added ciscoLwappRogueMIBComplianceRev2.', 'Added following tables: cLRogueIgnoreListTable cLRuleConfigTable cLConditionConfigTable cLConditionSsidConfigTable Added following objects: cLRldpAutoContainFeatureOnWiredNetwork cLRldpAutoContainRoguesAdvertisingSsid cLRldpAutoContainAdhocNetworks cLRldpAutoContainTrustedClientsOnRogueAps Deprecated ciscoLwappRogueMIBCompliance and added ciscoLwappRogueMIBComplianceRev1.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoLwappRogueMIB.setLastUpdated('201407140000Z')
if mibBuilder.loadTexts: ciscoLwappRogueMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoLwappRogueMIB.setContactInfo('Cisco Systems, Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS Email: cs-wnbu-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoLwappRogueMIB.setDescription('This MIB is intended to be implemented on all those devices operating as Central Controllers, that terminate the Light Weight Access Point Protocol tunnel from Cisco Light-weight LWAPP Access Points. This MIB provides information about the Rogue APs and Clients that are detected by the controller. The relationship between CC and the LWAPP APs can be depicted as follows: +......+ +......+ +......+ + + + + + + + CC + + CC + + CC + + + + + + + +......+ +......+ +......+ .. . . .. . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ + + + + + + + + + AP + + AP + + AP + + AP + + + + + + + + + +......+ +......+ +......+ +......+ . . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ + + + + + + + + + MN + + MN + + MN + + MN + + + + + + + + + +......+ +......+ +......+ +......+ The LWAPP tunnel exists between the controller and the APs. The MNs communicate with the APs through the protocol defined by the 802.11 standard. LWAPP APs, upon bootup, discover and join one of the controllers and the controller pushes the configuration, that includes the WLAN parameters, to the LWAPP APs. The APs then encapsulate all the 802.11 frames from wireless clients inside LWAPP frames and forward the LWAPP frames to the controller. GLOSSARY Access Point ( AP ) An entity that contains an 802.11 medium access control ( MAC ) and physical layer ( PHY ) interface and provides access to the distribution services via the wireless medium for associated clients. LWAPP APs encapsulate all the 802.11 frames in LWAPP frames and sends them to the controller to which it is logically connected. Light Weight Access Point Protocol ( LWAPP ) This is a generic protocol that defines the communication between the Access Points and the Central Controller. Mobile Node ( MN ) A roaming 802.11 wireless device in a wireless network associated with an access point. Mobile Node and client are used interchangeably. Rogue Any 802.11 device which is not part of the RF network is a Rogue device. Ad-hoc Network A set of mobile devices within direct communication range establishing a network among themselves for transmitting data, without the use of a Access point is called a ad-hoc network. Rogue Ad-hoc Client Any 802.11 client which is part of that ad-hoc network, but not in the trusted list. Service Set Identifier ( SSID ) SSID is a unique identifier that APs and clients use to identify with each other. SSID is a simple means of access control and is not for security. The SSID can be any alphanumeric entry up to 32 characters. RSSI Received Signal Strength Indication (RSSI), the IEEE 802.11 standard defines a mechanism by which RF energy is to be measured by the circuitry on a wireless NIC. Its value is measured in dBm and ranges from -128 to 0. Rogue Location Detection Protocol (RLDP) RLDP is a protocol to detect and automatically contain rogue devices. When the controller discovers a rogue access point, it uses the Rogue Location Discovery Protocol (RLDP) to determine if the rogue is attached to your network. RLDP can be enabled/disabled per controller level. LRAD (LWAPP RADIO) Light Weight Access Point Protocol Radio basically ones own AP. REFERENCE [1] Wireless LAN Medium Access Control ( MAC ) and Physical Layer ( PHY ) Specifications. [2] Draft-obara-capwap-lwapp-00.txt, IETF Light Weight Access Point Protocol.')
ciscoLwappRogueMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 0))
ciscoLwappRogueMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1))
ciscoLwappRogueMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 2))
cLRogueConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1))
cLRoguePolicyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1))
cLRogueRuleConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3))
cLRogueIgnoreListConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4))
cLRldpAutoContainConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5))
cLRogueApConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6))
class CLAutoContainActions(TextualConvention, Integer32):
    description = 'This textual convention represents the action that should be taken with respect to auto containment feature when any of the following are detected by the switch: rogue adhoc network rogues APs that are advertising our SSID trusted clients that are associated to rogue APs alarmOnly(1) - only an alarm will be generated contain(2) - contain automatically'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("alarmOnly", 1), ("contain", 2))

cLRogueAdhocRogueReportEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueAdhocRogueReportEnable.setStatus('current')
if mibBuilder.loadTexts: cLRogueAdhocRogueReportEnable.setDescription("This object is used to turn on and off ad-hoc rogue reporting. Setting this object to 'true' will enable ad-hoc rogue reporting. Setting to 'false' will disable ad-hoc rogue reporting.")
cLRogueReportInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 300))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueReportInterval.setStatus('current')
if mibBuilder.loadTexts: cLRogueReportInterval.setDescription('This object specifies the rogue report interval, which is the interval that monitor mode APs send rogue detection details to the controller.')
cLRogueMinimumRssi = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, -70))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueMinimumRssi.setStatus('current')
if mibBuilder.loadTexts: cLRogueMinimumRssi.setDescription('This object specifies the minimum value of RSSI considered for detection of rogues.')
cLRogueTransientInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(120, 1800), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueTransientInterval.setStatus('current')
if mibBuilder.loadTexts: cLRogueTransientInterval.setDescription("This object specifies the rogue transient interval. A value of '0' specifies that an AP sends rogue detection details to the controller as soon as it detects a rogue. A non-zero value specifies that an AP sends rogue detection details to the controller if it hears the rogue more than once in the specified interval.")
cLRogueClientNumThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueClientNumThreshold.setStatus('current')
if mibBuilder.loadTexts: cLRogueClientNumThreshold.setDescription('This object specifies the number of clients the Rogue AP can have. A value of zero indicates no limitation on the number of clients the Rogue AP can have.')
cLRogueDetectionSecurityLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("high", 2), ("critical", 3), ("custom", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueDetectionSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: cLRogueDetectionSecurityLevel.setDescription("This object specifies the rogue detection security level. When the object has value of 'low', 'high' or 'critical', controller uses pre-defined rogue detection parameters for the specified security level. When the object has value of 'custom', controller uses the user configured rogue detection parameters. low - security level is low high - security level is high critical - security level is critical custom - customized security level")
cLRogueValidateRogueClientsAgainstMse = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueValidateRogueClientsAgainstMse.setStatus('current')
if mibBuilder.loadTexts: cLRogueValidateRogueClientsAgainstMse.setDescription("The object specifies whether the controller validates 'valid' clients which are associating with rogue AP, against MSE. A value of 'enable' indicates that the controller does validates 'valid'clients which are associating with rogue AP, against MSE. A value of 'disable' indicates that the controller does not validates 'valid' clients which are associating with rogue AP, against MSE.")
cLRogueAdhocRogueNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRogueAdhocRogueNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cLRogueAdhocRogueNotifEnabled.setDescription("The object to control the generation of cLRogueAdhocDetected notification. A value of 'true' indicates that the agent generates cLRogueAdhocDetected notification. A value of 'false' indicates that the agent doesn't generate cLRogueAdhocDetected notification.")
cLRogueAdhocRogueDetected = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 610, 0, 1)).setObjects(("CISCO-LWAPP-AP-MIB", "cLApName"))
if mibBuilder.loadTexts: cLRogueAdhocRogueDetected.setStatus('current')
if mibBuilder.loadTexts: cLRogueAdhocRogueDetected.setDescription('This notification is generated by the controller when a a rogue is detected. The name of the AP that detected this rogue is sent in the notification.')
cLRuleConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1), )
if mibBuilder.loadTexts: cLRuleConfigTable.setStatus('current')
if mibBuilder.loadTexts: cLRuleConfigTable.setDescription('This table provides the configuration needed by the controller for classifying rogue APs. The user defines the custom rules which are used to classify the APs under different classification types. When a new rule is created priority will be assigned automatically by controller, highest priority given to rule which are created first. Also if user is changing the priority of a rule manually, the new priority should not be used by any other existing rule.')
cLRuleConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-LWAPP-ROGUE-MIB", "cLRuleName"))
if mibBuilder.loadTexts: cLRuleConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cLRuleConfigEntry.setDescription('Each entry represents a conceptual row (as identified by a rule name)in cLRuleConfigTable.')
cLRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: cLRuleName.setStatus('current')
if mibBuilder.loadTexts: cLRuleName.setDescription('This object represents the rule name to identify this entry.')
cLRuleRogueType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("friendly", 1), ("malicious", 2), ("unclassified", 3), ("custom", 4))).clone('custom')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRuleRogueType.setStatus('current')
if mibBuilder.loadTexts: cLRuleRogueType.setDescription('This object determines the classification applied to the rogue AP that matches this rule. friendly - known and acknowledged rogue AP. malicious - unknown AP that matches user defined malicious rules. unclassified - an unknown AP that did not match malicious or friendly rules. custom - user can configure rogue detection parameters.')
cLRuleConditionsMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("all", 1), ("any", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRuleConditionsMatch.setStatus('current')
if mibBuilder.loadTexts: cLRuleConditionsMatch.setDescription('This object represents how the conditions defined by corresponding instances of cLConditionType, are matched under each rule. all - all the conditions defined per rule should be matched any - any conditions defined per rule can be matched.')
cLRulePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRulePriority.setStatus('current')
if mibBuilder.loadTexts: cLRulePriority.setDescription('This object is used to define the order in which the rules will be applied. The rules will be applied from lowest to highest and gaps are allowed. Each rule must have and unique value for this object.')
cLRuleEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRuleEnable.setStatus('current')
if mibBuilder.loadTexts: cLRuleEnable.setDescription("This object specifies whether this rule is enabled or not. A value of 'true' specifies this rule is enabled. A value of 'false' specifies this rule is disabled.")
cLRuleStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRuleStorageType.setStatus('current')
if mibBuilder.loadTexts: cLRuleStorageType.setDescription('This object represents the storage type for this conceptual row.')
cLRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: cLRuleRowStatus.setDescription('This object represents the status column for a conceptual row in this table. All writable objects in this row may be modified when the row is active.')
cLConditionConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2), )
if mibBuilder.loadTexts: cLConditionConfigTable.setStatus('current')
if mibBuilder.loadTexts: cLConditionConfigTable.setDescription('This table represents the configuration of conditions that can be applied to a rule.')
cLConditionConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-LWAPP-ROGUE-MIB", "cLRuleName"), (0, "CISCO-LWAPP-ROGUE-MIB", "cLConditionName"))
if mibBuilder.loadTexts: cLConditionConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cLConditionConfigEntry.setDescription('Each entry represents a conceptual row in cLConditionConfigTable, as identified by a specific condition name to be applied on a specific rule name.')
cLConditionName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cLConditionName.setStatus('current')
if mibBuilder.loadTexts: cLConditionName.setDescription('This object represents the condition name.')
cLConditionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("managedSsid", 1), ("rssi", 2), ("duration", 3), ("clientCount", 4), ("noEncryption", 5), ("userConfigSsid", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionType.setStatus('current')
if mibBuilder.loadTexts: cLConditionType.setDescription('This object represents the condition type for this condition associated with a rule. managedSsid - matches managed SSID rssi - required minimum RSSI duration - limited to this time duration clientCount - number of associated clients noEncryption - no encryption rule userConfigSsid - matches user configured SSID')
cLConditionValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionValue.setStatus('current')
if mibBuilder.loadTexts: cLConditionValue.setDescription("This object represents the value associated with the condition type as specified by the corresponding cLConditionType instance. If cLConditionType is 'userConfigSsid', then corresponding 'cLConditionValue' can only take on the value of zero.")
cLConditionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionEnable.setStatus('current')
if mibBuilder.loadTexts: cLConditionEnable.setDescription("This object indicates whether matching against this condition is enabled or not. A value of 'true' indicates matching against this condition is enabled. A value of 'false' indicates matching against this condition is disabled.")
cLConditionStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionStorageType.setStatus('current')
if mibBuilder.loadTexts: cLConditionStorageType.setDescription('This object represents the storage type for this conceptual row.')
cLConditionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionRowStatus.setStatus('current')
if mibBuilder.loadTexts: cLConditionRowStatus.setDescription('This object represents the status column for a conceptual row in this table. All writable objects except cLConditionType in this row may be modified when the row is active.')
cLConditionRssi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionRssi.setStatus('current')
if mibBuilder.loadTexts: cLConditionRssi.setDescription("This object specifies the minimum value of RSSI that a rogue AP must have in order to match cLConditionType of 'rssi'.")
cLConditionClientCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionClientCount.setStatus('current')
if mibBuilder.loadTexts: cLConditionClientCount.setDescription("This object specifies the minimum value of client count that a rogue AP must have in order to match cLConditionType of 'clientCount'.")
cLConditionNoEncryptionEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 9), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionNoEncryptionEnabled.setStatus('current')
if mibBuilder.loadTexts: cLConditionNoEncryptionEnabled.setDescription("This object specifies whether or not encryption is enabled. A value of 'true' indicates that encryption is not enabled. A value of 'false' indicates that encryption is enabled for this condition.")
cLConditionManagedSsidEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 10), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionManagedSsidEnabled.setStatus('current')
if mibBuilder.loadTexts: cLConditionManagedSsidEnabled.setDescription("This object specifies whether or not managed SSID is enabled. A value of 'true' indicates managed SSID is enabled. A value of 'false' indicates managed SSID is not enabled for this condition.")
cLConditionDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 2, 1, 11), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionDuration.setStatus('current')
if mibBuilder.loadTexts: cLConditionDuration.setDescription("This object specifies the minimum value of duration, in seconds, a rogue AP must be present in order to match cLConditionType of 'duration'.")
cLConditionSsidConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 3), )
if mibBuilder.loadTexts: cLConditionSsidConfigTable.setStatus('current')
if mibBuilder.loadTexts: cLConditionSsidConfigTable.setDescription("This table represents the configuration of SSID for a rule. This is applicable to conditions within a rule which has the corresponding cLConditionType taking on the value of 'userConfigSsid'.")
cLConditionSsidConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 3, 1), ).setIndexNames((0, "CISCO-LWAPP-ROGUE-MIB", "cLRuleName"), (0, "CISCO-LWAPP-ROGUE-MIB", "cLConditionName"), (0, "CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidValue"))
if mibBuilder.loadTexts: cLConditionSsidConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cLConditionSsidConfigEntry.setDescription('Each entry represents a conceptual row in cLConditionSsidConfigTable.')
cLConditionSsidValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: cLConditionSsidValue.setStatus('current')
if mibBuilder.loadTexts: cLConditionSsidValue.setDescription('This object represents the SSID value for this condition associated with a rule.')
cLConditionSsidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 3, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionSsidStorageType.setStatus('current')
if mibBuilder.loadTexts: cLConditionSsidStorageType.setDescription('This object represents the storage type for this conceptual row.')
cLConditionSsidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 3, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLConditionSsidRowStatus.setStatus('current')
if mibBuilder.loadTexts: cLConditionSsidRowStatus.setDescription('This object represents the status column for a conceptual row in this table. All writable objects in this row may not be modified when the row is active.')
cLRogueIgnoreListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4, 1), )
if mibBuilder.loadTexts: cLRogueIgnoreListTable.setStatus('current')
if mibBuilder.loadTexts: cLRogueIgnoreListTable.setDescription("The table lists the APs, as identified by the AP's mac address, which should not be treated as rogue by the controller. These APs are the autonomous access points that have been manually added to WCS.")
cLRogueIgnoreListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListMACAddress"))
if mibBuilder.loadTexts: cLRogueIgnoreListEntry.setStatus('current')
if mibBuilder.loadTexts: cLRogueIgnoreListEntry.setDescription('Each entry represents a conceptual row in this table. There will be a row for each entry of the autonomous APs which are manually added to WCS. When the autonomous AP is no longer managed by WCS, the corresponding row entry will be removed.')
cLRogueIgnoreListMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: cLRogueIgnoreListMACAddress.setStatus('current')
if mibBuilder.loadTexts: cLRogueIgnoreListMACAddress.setDescription('This is the MAC Address of the AP to be put in the rogue ignore list.')
cLRogueIgnoreListStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4, 1, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueIgnoreListStorageType.setStatus('current')
if mibBuilder.loadTexts: cLRogueIgnoreListStorageType.setDescription('This object represents the storage type for this conceptual row.')
cLRogueIgnoreListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 4, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueIgnoreListRowStatus.setStatus('current')
if mibBuilder.loadTexts: cLRogueIgnoreListRowStatus.setDescription('This is the status of the conceptual row. All writable objects in this row may not be modified when the row is active.')
cLRldpAutoContainFeatureOnWiredNetwork = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainFeatureOnWiredNetwork.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainFeatureOnWiredNetwork.setDescription('This object represents the RLDP Auto contain feature status. disable - automatic containment of rogues on wired network is disabled enable - automatic containment of rogues on wired network is enabled NOTE: Using this feature may have legal consequences!!!')
cLRldpAutoContainRoguesAdvertisingSsid = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 2), CLAutoContainActions().clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainRoguesAdvertisingSsid.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainRoguesAdvertisingSsid.setDescription('This is the action with respect to auto containment feature, that should be taken when switch detects rogues that are advertising our SSID. NOTE: Using this feature may have legal consequences!!!')
cLRldpAutoContainAdhocNetworks = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 3), CLAutoContainActions().clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainAdhocNetworks.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainAdhocNetworks.setDescription('This is the action with respect to auto containment feature, that should be taken when adhoc networks are detected by the switch. NOTE: Using this feature may have legal consequences!!!')
cLRldpAutoContainTrustedClientsOnRogueAps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 4), CLAutoContainActions().clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainTrustedClientsOnRogueAps.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainTrustedClientsOnRogueAps.setDescription('This is the action with respect to auto containment feature, that should be taken when trusted clients that are associated to rogue APs are detected by the switch. NOTE: Using this feature may have legal consequences!!!')
cLRldpAutoContainLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainLevel.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainLevel.setDescription('This object is used to specify the level of auto containment. The level actually denotes the number of APs that should be used by the controller for auto containment.')
cLRldpAutoContainOnlyforMonitorModeAps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cLRldpAutoContainOnlyforMonitorModeAps.setStatus('current')
if mibBuilder.loadTexts: cLRldpAutoContainOnlyforMonitorModeAps.setDescription('This object is used to specify if auto containment should be done only using monitor mode APs or not. disable - auto containment will be done using all APs irrespective of the mode enable - auto containment will be done only using monitor mode APs.')
cLRogueApTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1), )
if mibBuilder.loadTexts: cLRogueApTable.setStatus('current')
if mibBuilder.loadTexts: cLRogueApTable.setDescription('The table lists the configured rogue APs in the system.')
cLRogueApEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-LWAPP-ROGUE-MIB", "cLRogueApMACAddress"))
if mibBuilder.loadTexts: cLRogueApEntry.setStatus('current')
if mibBuilder.loadTexts: cLRogueApEntry.setDescription('An entry containing contains management information of a particular rogue AP. An entry can be created, or deleted by using cLRogueApRowStatus.')
cLRogueApMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: cLRogueApMACAddress.setStatus('current')
if mibBuilder.loadTexts: cLRogueApMACAddress.setDescription('MAC Address of a rogue AP.')
cLRogueApClassType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("friendly", 1), ("malicious", 2), ("unclassified", 3), ("custom", 4))).clone('custom')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueApClassType.setStatus('current')
if mibBuilder.loadTexts: cLRogueApClassType.setDescription('This object specifies the type of a rogue AP. friendly - existing known, Acknowledge, and Trust missing rogue states are classified as Friendly. malicious - unknown AP that could be a threat. unclassified - an unknown AP or rogue AP is identified but it does not belong to Friendly or Malicious rogue types. custom - AP that matches user defined custom rules.')
cLRogueApState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("pending", 1), ("alert", 2), ("detectedLrad", 3), ("known", 4), ("acknowledge", 5), ("contained", 6), ("threat", 7), ("containedPending", 8), ("knownContained", 9), ("trustedMissing", 10), ("initializing", 11))).clone('alert')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueApState.setStatus('current')
if mibBuilder.loadTexts: cLRogueApState.setDescription("This objects specifies the state in which the rogue AP is. pending - a read-only value indicates that rogue AP can not be state to any of the following type. alert - rogue AP can be a potential threat. Trap will be sent out to trap recipients. detectedLrad - a read-only value indicates that a LRAD that got detected as rogue. known - a read-only value indicates that an internal AP which is not on the same switch. acknowledge - a read-only value indicates that an external AP whose existence is acceptable and not a threat(probably from vendor other than cisco). contained - containment is initiated and ongoing. threat - rogue AP is found on wired network. containedPending - a read-only value indicates that no AP resources available for containment. knownContained - a read-only value indicates that no longer used. trustedMissing - rogue AP is friendly but there is no slot for friendly AP. initializing - a read-only value indicates that rogue AP is being initialized. For a friendly rogue AP, only two states are valid: 'known' and 'acknowledge'. 'known', 'knownContained' and 'trustedMissing' can appear in known rogue list. Known rogues can be pre-provisioned and known rogues state can be changed to 'alert'.")
cLRogueApStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueApStorageType.setStatus('current')
if mibBuilder.loadTexts: cLRogueApStorageType.setDescription('This object represents the storage type for this conceptual row.')
cLRogueApRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 610, 1, 1, 6, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cLRogueApRowStatus.setStatus('current')
if mibBuilder.loadTexts: cLRogueApRowStatus.setDescription('The status of the conceptual row. All writable objects in this row may be modified when the row is active.')
ciscoLwappRogueMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1))
ciscoLwappRogueMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2))
ciscoLwappRogueMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1, 1)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueNotifsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueMIBCompliance = ciscoLwappRogueMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueMIBCompliance.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRogueMIB module.')
ciscoLwappRogueMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1, 2)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueNotifsGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigSup1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueMIBComplianceRev1 = ciscoLwappRogueMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueMIBComplianceRev1.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRogueMIB module.')
ciscoLwappRogueMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1, 3)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueNotifsGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigSup2Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueMIBComplianceRev2 = ciscoLwappRogueMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueMIBComplianceRev2.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRogueMIB module.')
ciscoLwappRogueMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1, 4)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueNotifsGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigSup3Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueMIBComplianceRev3 = ciscoLwappRogueMIBComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueMIBComplianceRev3.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRogueMIB module.')
ciscoLwappRogueMIBComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 1, 5)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueNotifsGroup"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigSup3Group"), ("CISCO-LWAPP-ROGUE-MIB", "ciscoLwappRogueConfigSup4Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueMIBComplianceRev4 = ciscoLwappRogueMIBComplianceRev4.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRogueMIBComplianceRev4.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRogueMIB module.')
ciscoLwappRogueConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 1)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueAdhocRogueReportEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueAdhocRogueNotifEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueConfigGroup = ciscoLwappRogueConfigGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRogueConfigGroup.setDescription('This collection of objects represent the rogue configuration on the controller.')
ciscoLwappRogueNotifsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 2)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueAdhocRogueDetected"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueNotifsGroup = ciscoLwappRogueNotifsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRogueNotifsGroup.setDescription('This collection of objects specifies the notifications for rogue detection.')
ciscoLwappRogueConfigSup1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 3)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRogueType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleConditionsMatch"), ("CISCO-LWAPP-ROGUE-MIB", "cLRulePriority"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionValue"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainFeatureOnWiredNetwork"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainRoguesAdvertisingSsid"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainAdhocNetworks"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainTrustedClientsOnRogueAps"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueConfigSup1Group = ciscoLwappRogueConfigSup1Group.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueConfigSup1Group.setDescription('This collection of objects represent the rogue configuration on the controller. ciscoLwappRogueConfigSup1Group object is superseded by ciscoLwappRogueConfigSup2Group.')
ciscoLwappRogueConfigSup2Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 4)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRogueType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleConditionsMatch"), ("CISCO-LWAPP-ROGUE-MIB", "cLRulePriority"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionValue"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainFeatureOnWiredNetwork"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainRoguesAdvertisingSsid"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainAdhocNetworks"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainTrustedClientsOnRogueAps"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainLevel"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainOnlyforMonitorModeAps"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueConfigSup2Group = ciscoLwappRogueConfigSup2Group.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRogueConfigSup2Group.setDescription('This collection of objects represent the rogue configuration on the controller. ciscoLwappRogueConfigSup2Group object is superseded by ciscoLwappRogueConfigSup3Group.')
ciscoLwappRogueConfigSup3Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 5)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueIgnoreListRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRogueType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleConditionsMatch"), ("CISCO-LWAPP-ROGUE-MIB", "cLRulePriority"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRuleRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionValue"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionEnable"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionSsidRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainFeatureOnWiredNetwork"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainRoguesAdvertisingSsid"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainAdhocNetworks"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainTrustedClientsOnRogueAps"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainLevel"), ("CISCO-LWAPP-ROGUE-MIB", "cLRldpAutoContainOnlyforMonitorModeAps"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueReportInterval"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueMinimumRssi"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueTransientInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueConfigSup3Group = ciscoLwappRogueConfigSup3Group.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRogueConfigSup3Group.setDescription('This collection of objects represent the rogue configuration on the controller.')
ciscoLwappRogueConfigSup4Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 610, 2, 2, 6)).setObjects(("CISCO-LWAPP-ROGUE-MIB", "cLRogueApClassType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueApState"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueApStorageType"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueApRowStatus"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueClientNumThreshold"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueDetectionSecurityLevel"), ("CISCO-LWAPP-ROGUE-MIB", "cLRogueValidateRogueClientsAgainstMse"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionRssi"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionClientCount"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionNoEncryptionEnabled"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionManagedSsidEnabled"), ("CISCO-LWAPP-ROGUE-MIB", "cLConditionDuration"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRogueConfigSup4Group = ciscoLwappRogueConfigSup4Group.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRogueConfigSup4Group.setDescription('This collection of objects represent the rogue configuration on the controller.')
mibBuilder.exportSymbols("CISCO-LWAPP-ROGUE-MIB", cLRuleConfigEntry=cLRuleConfigEntry, cLConditionSsidRowStatus=cLConditionSsidRowStatus, cLConditionStorageType=cLConditionStorageType, cLConditionSsidStorageType=cLConditionSsidStorageType, cLRldpAutoContainFeatureOnWiredNetwork=cLRldpAutoContainFeatureOnWiredNetwork, cLRldpAutoContainOnlyforMonitorModeAps=cLRldpAutoContainOnlyforMonitorModeAps, cLConditionConfigTable=cLConditionConfigTable, ciscoLwappRogueConfigSup4Group=ciscoLwappRogueConfigSup4Group, ciscoLwappRogueNotifsGroup=ciscoLwappRogueNotifsGroup, ciscoLwappRogueMIBCompliances=ciscoLwappRogueMIBCompliances, cLRulePriority=cLRulePriority, cLRogueApMACAddress=cLRogueApMACAddress, cLRogueConfig=cLRogueConfig, cLConditionDuration=cLConditionDuration, cLConditionEnable=cLConditionEnable, cLRldpAutoContainRoguesAdvertisingSsid=cLRldpAutoContainRoguesAdvertisingSsid, cLRogueIgnoreListEntry=cLRogueIgnoreListEntry, cLRogueClientNumThreshold=cLRogueClientNumThreshold, cLRogueReportInterval=cLRogueReportInterval, cLRogueIgnoreListRowStatus=cLRogueIgnoreListRowStatus, cLConditionRowStatus=cLConditionRowStatus, CLAutoContainActions=CLAutoContainActions, cLRldpAutoContainLevel=cLRldpAutoContainLevel, ciscoLwappRogueMIBComplianceRev1=ciscoLwappRogueMIBComplianceRev1, cLRogueIgnoreListMACAddress=cLRogueIgnoreListMACAddress, cLConditionClientCount=cLConditionClientCount, ciscoLwappRogueConfigSup3Group=ciscoLwappRogueConfigSup3Group, cLRogueApStorageType=cLRogueApStorageType, cLRuleRogueType=cLRuleRogueType, cLRogueDetectionSecurityLevel=cLRogueDetectionSecurityLevel, cLConditionConfigEntry=cLConditionConfigEntry, ciscoLwappRogueMIBComplianceRev4=ciscoLwappRogueMIBComplianceRev4, cLConditionSsidConfigEntry=cLConditionSsidConfigEntry, cLRuleStorageType=cLRuleStorageType, ciscoLwappRogueMIB=ciscoLwappRogueMIB, ciscoLwappRogueMIBObjects=ciscoLwappRogueMIBObjects, ciscoLwappRogueMIBComplianceRev2=ciscoLwappRogueMIBComplianceRev2, cLConditionRssi=cLConditionRssi, ciscoLwappRogueConfigGroup=ciscoLwappRogueConfigGroup, cLRuleName=cLRuleName, cLRogueIgnoreListTable=cLRogueIgnoreListTable, cLConditionSsidValue=cLConditionSsidValue, cLConditionType=cLConditionType, cLRoguePolicyConfig=cLRoguePolicyConfig, cLRogueIgnoreListStorageType=cLRogueIgnoreListStorageType, cLConditionSsidConfigTable=cLConditionSsidConfigTable, cLRogueApTable=cLRogueApTable, cLRuleRowStatus=cLRuleRowStatus, cLRuleConfigTable=cLRuleConfigTable, cLRldpAutoContainAdhocNetworks=cLRldpAutoContainAdhocNetworks, ciscoLwappRogueMIBCompliance=ciscoLwappRogueMIBCompliance, cLRogueApClassType=cLRogueApClassType, cLRogueApEntry=cLRogueApEntry, cLRogueTransientInterval=cLRogueTransientInterval, cLConditionNoEncryptionEnabled=cLConditionNoEncryptionEnabled, cLRogueMinimumRssi=cLRogueMinimumRssi, cLRogueApState=cLRogueApState, cLRuleEnable=cLRuleEnable, cLConditionManagedSsidEnabled=cLConditionManagedSsidEnabled, cLConditionValue=cLConditionValue, cLConditionName=cLConditionName, cLRogueRuleConfig=cLRogueRuleConfig, cLRogueValidateRogueClientsAgainstMse=cLRogueValidateRogueClientsAgainstMse, ciscoLwappRogueMIBConform=ciscoLwappRogueMIBConform, cLRogueAdhocRogueReportEnable=cLRogueAdhocRogueReportEnable, cLRldpAutoContainTrustedClientsOnRogueAps=cLRldpAutoContainTrustedClientsOnRogueAps, cLRogueAdhocRogueNotifEnabled=cLRogueAdhocRogueNotifEnabled, cLRogueAdhocRogueDetected=cLRogueAdhocRogueDetected, cLRogueIgnoreListConfig=cLRogueIgnoreListConfig, ciscoLwappRogueConfigSup2Group=ciscoLwappRogueConfigSup2Group, cLRldpAutoContainConfig=cLRldpAutoContainConfig, PYSNMP_MODULE_ID=ciscoLwappRogueMIB, cLRogueApConfig=cLRogueApConfig, ciscoLwappRogueMIBComplianceRev3=ciscoLwappRogueMIBComplianceRev3, ciscoLwappRogueMIBNotifs=ciscoLwappRogueMIBNotifs, cLRuleConditionsMatch=cLRuleConditionsMatch, ciscoLwappRogueConfigSup1Group=ciscoLwappRogueConfigSup1Group, cLRogueApRowStatus=cLRogueApRowStatus, ciscoLwappRogueMIBGroups=ciscoLwappRogueMIBGroups)

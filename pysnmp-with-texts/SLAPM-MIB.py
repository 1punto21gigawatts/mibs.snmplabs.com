#
# PySNMP MIB module SLAPM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SLAPM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:06:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
TimeTicks, MibIdentifier, Unsigned32, IpAddress, Gauge32, experimental, iso, NotificationType, Counter32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ObjectIdentity, Integer32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibIdentifier", "Unsigned32", "IpAddress", "Gauge32", "experimental", "iso", "NotificationType", "Counter32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ObjectIdentity", "Integer32", "ModuleIdentity")
TextualConvention, TestAndIncr, DateAndTime, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TestAndIncr", "DateAndTime", "DisplayString", "RowStatus")
slapmMIB = ModuleIdentity((1, 3, 6, 1, 3, 88))
slapmMIB.setRevisions(('2000-01-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: slapmMIB.setRevisionsDescriptions(('This version published as RFC 2758.',))
if mibBuilder.loadTexts: slapmMIB.setLastUpdated('200001240000Z')
if mibBuilder.loadTexts: slapmMIB.setOrganization('International Business Machines Corp.')
if mibBuilder.loadTexts: slapmMIB.setContactInfo('Kenneth White International Business Machines Corporation Network Computing Software Division Research Triangle Park, NC, USA E-mail: wkenneth@us.ibm.com')
if mibBuilder.loadTexts: slapmMIB.setDescription('The Service Level Agreement Performance Monitoring MIB (SLAPM-MIB) provides data collection and monitoring capabilities for Service Level Agreements (SLAs) policy definitions.')
class SlapmNameType(SnmpAdminString):
    description = 'The textual convention for naming entities within this MIB. The actual contents of an object defined using this textual convention should consist of the distinguished name portion of an name. This is usually the right-most portion of the name. This convention is necessary, since names within this MIB can be used as index items and an instance identifier is limited to 128 subidentifiers. This textual convention has been deprecated. All of the tables defined within this MIB that use this textual convention have been deprecated as well since the method of using a portion of the name (either of a policy definition or of a traffic profile) has been replaced by using an Unsigned32 index. The new slapmPolicyNameTable would then map the Unsigned32 index to a real name.'
    status = 'deprecated'
    subtypeSpec = SnmpAdminString.subtypeSpec + ValueSizeConstraint(0, 32)

class SlapmStatus(TextualConvention, Bits):
    description = 'The textual convention for defining the various slapmPRMonTable (or old slapmPolicyMonitorTable) and the slapmSubcomponentTable states for actual policy rule traffic monitoring.'
    status = 'current'
    namedValues = NamedValues(("slaMinInRateNotAchieved", 0), ("slaMaxInRateExceeded", 1), ("slaMaxDelayExceeded", 2), ("slaMinOutRateNotAchieved", 3), ("slaMaxOutRateExceeded", 4), ("monitorMinInRateNotAchieved", 5), ("monitorMaxInRateExceeded", 6), ("monitorMaxDelayExceeded", 7), ("monitorMinOutRateNotAchieved", 8), ("monitorMaxOutRateExceeded", 9))

class SlapmPolicyRuleName(TextualConvention, OctetString):
    description = 'To facilitate internationalization, this TC represents information taken from the ISO/IEC IS 10646-1 character set, encoded as an octet string using the UTF-8 character encoding scheme described in RFC 2044. For strings in 7-bit US-ASCII, there is no impact since the UTF-8 representation is identical to the US-ASCII encoding.'
    status = 'current'
    displayHint = '1024t'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 1024)

slapmNotifications = MibIdentifier((1, 3, 6, 1, 3, 88, 0))
slapmObjects = MibIdentifier((1, 3, 6, 1, 3, 88, 1))
slapmConformance = MibIdentifier((1, 3, 6, 1, 3, 88, 2))
slapmBaseObjects = MibIdentifier((1, 3, 6, 1, 3, 88, 1, 1))
slapmSpinLock = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slapmSpinLock.setStatus('current')
if mibBuilder.loadTexts: slapmSpinLock.setDescription('An advisory lock used to allow cooperating applications to coordinate their use of the contents of this MIB. This typically occurs when an application seeks to create an new entry or alter an existing entry in slapmPRMonTable (or old slapmPolicyMonitorTable). A management implementation MAY utilize the slapmSpinLock to serialize its changes or additions. This usage is not required. However, slapmSpinLock MUST be supported by agent implementations.')
slapmPolicyCountQueries = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyCountQueries.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyCountQueries.setDescription('The total number of times that a policy lookup occurred with respect to a policy agent. This is the number of times that a reference was made to a policy definition at a system and includes the number of times that a policy repository was accessed, slapmPolicyCountAccesses. The object slapmPolicyCountAccesses should be less than slapmPolicyCountQueries when policy definitions are cached at a system.')
slapmPolicyCountAccesses = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyCountAccesses.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyCountAccesses.setDescription('Total number of times that a policy repository was accessed with respect to a policy agent. The value of this object should be less than slapmPolicyCountQueries, since typically policy entries are cached to minimize repository accesses.')
slapmPolicyCountSuccessAccesses = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyCountSuccessAccesses.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyCountSuccessAccesses.setDescription('Total number of successful policy repository accesses with respect to a policy agent.')
slapmPolicyCountNotFounds = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyCountNotFounds.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyCountNotFounds.setDescription('Total number of policy repository accesses, with respect to a policy agent, that resulted in an entry not being located.')
slapmPolicyPurgeTime = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(900)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: slapmPolicyPurgeTime.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyPurgeTime.setDescription('The purpose of this object is to define the amount of time (in seconds) to wait before removing an slapmPolicyRuleStatsEntry (or old slapmPolicyStatsEntry) when a system detects that the associated policy definition has been deleted. This gives any polling management applications time to complete their last poll before an entry is removed. An slapmPolicyRuleStatsEntry (or old slapmPolicyStatsEntry) enters the deleteNeeded(3) state via slapmPolicyRuleStatsOperStatus (or old slapmPolicyStatsOperStatus) when a system first detects that the entry needs to be removed. Once slapmPolicyPurgeTime has expired for an entry in deleteNeeded(3) state it is removed a long with any dependent slapmPRMonTable (or slapmPolicyMonitorTable) entries. A value of 0 for this option disables this function and results in the automatic purging of slapmPRMonTable (or slapmPolicyTable) entries upon transition into deleteNeeded(3) state. A slapmPolicyRuleDeleted (or slapmPolicyProfileDeleted) notification is sent when an slapmPolicyRuleStatsEntry (or slapmPolicyStatsEntry) is removed. Dependent slapmPRMonTable (or slapmPolicyMonitorTable) deletion results in a slapmPolicyRuleMonDeleted (or slapmPolicyMonitorDeleted) notification being sent. These notifications are suppressed if the value of slapmPolicyTrapEnable is disabled(2).')
slapmPolicyTrapEnable = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slapmPolicyTrapEnable.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyTrapEnable.setDescription('Indicates whether slapmPolicyRuleDeleted and slapmPolicyRuleMonDeleted (or slapmPolicyProfileDeleted and slapmPolicyMonitorDeleted) notifications should be generated by this system.')
slapmPolicyTrapFilter = MibScalar((1, 3, 6, 1, 3, 88, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(3)).setUnits('intervals').setMaxAccess("readwrite")
if mibBuilder.loadTexts: slapmPolicyTrapFilter.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyTrapFilter.setDescription('The purpose of this object is to suppress unnecessary slapmSubcMonitorNotOkay (or slapmSubcomponentMonitoredEventNotAchieved), for example, notifications. Basically, a monitored event has to not meet its SLA requirement for the number of consecutive intervals indicated by the value of this object.')
slapmTableObjects = MibIdentifier((1, 3, 6, 1, 3, 88, 1, 2))
slapmPolicyStatsTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 1), )
if mibBuilder.loadTexts: slapmPolicyStatsTable.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsTable.setDescription('Provides statistics on all policies known at a system. This table has been deprecated and replaced with the slapmPolicyRuleStatsTable. Older implementations of this MIB are expected to continue their support of this table.')
slapmPolicyStatsEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 1, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmPolicyStatsSystemAddress"), (0, "SLAPM-MIB", "slapmPolicyStatsPolicyName"), (0, "SLAPM-MIB", "slapmPolicyStatsTrafficProfileName"))
if mibBuilder.loadTexts: slapmPolicyStatsEntry.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsEntry.setDescription('Defines an entry in the slapmPolicyStatsTable. This table defines a set of statistics that is kept on a per system, policy and traffic profile basis. A policy can be defined to contain multiple traffic profiles that map to a single action. Entries in this table are not created or deleted via SNMP but reflect the set of policy definitions known at a system.')
slapmPolicyStatsSystemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmPolicyStatsSystemAddress.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsSystemAddress.setDescription('Address of a system that an Policy definition relates to. A zero length octet string must be used to indicate that only a single system is being represented. Otherwise, the length of the octet string must be 4 for an ipv4 address or 16 for an ipv6 address.')
slapmPolicyStatsPolicyName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 2), SlapmNameType())
if mibBuilder.loadTexts: slapmPolicyStatsPolicyName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsPolicyName.setDescription('Policy name that this entry relates to.')
slapmPolicyStatsTrafficProfileName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 3), SlapmNameType())
if mibBuilder.loadTexts: slapmPolicyStatsTrafficProfileName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsTrafficProfileName.setDescription('The name of a traffic profile that is associated with a policy.')
slapmPolicyStatsOperStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("deleteNeeded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsOperStatus.setDescription('The state of a policy entry: inactive(1) - An policy entry was either defined by local system definition or discovered via a directory search but has not been activated (not currently being used). active(2) - Policy entry is being used to affect traffic flows. deleteNeeded(3) - Either though local implementation dependent methods or by discovering that the directory entry corresponding to this table entry no longer exists and slapmPolicyPurgeTime needs to expire before attempting to remove the corresponding slapmPolicyStatsEntry and any dependent slapmPolicyMonitor table entries. Note: a policy traffic profile in a state other than active(1) is not being used to affect traffic flows.')
slapmPolicyStatsActiveConns = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsActiveConns.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsActiveConns.setDescription('The number of active TCP connections that are affected by the corresponding policy entry.')
slapmPolicyStatsTotalConns = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsTotalConns.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsTotalConns.setDescription('The number of total TCP connections that are affected by the corresponding policy entry.')
slapmPolicyStatsFirstActivated = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 7), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsFirstActivated.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsFirstActivated.setDescription('The timestamp for when the corresponding policy entry is activated. The value of this object serves as the discontinuity event indicator when polling entries in this table. The value of this object is updated on transition of slapmPolicyStatsOperStatus into the active(2) state.')
slapmPolicyStatsLastMapping = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 8), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsLastMapping.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsLastMapping.setDescription('The timestamp for when the last time that the associated policy entry was used.')
slapmPolicyStatsInOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsInOctets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsInOctets.setDescription('The number of octets that was received by IP for an entity that map to this entry.')
slapmPolicyStatsOutOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsOutOctets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsOutOctets.setDescription('The number of octets that was transmitted by IP for an entity that map to this entry.')
slapmPolicyStatsConnectionLimit = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsConnectionLimit.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsConnectionLimit.setDescription('The limit for the number of active TCP connections that are allowed for this policy definition. A value of zero for this object implies that a connection limit has not been specified.')
slapmPolicyStatsCountAccepts = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsCountAccepts.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsCountAccepts.setDescription("This counter is incremented when a policy action's Permission value is set to Accept and a session (TCP connection) is accepted.")
slapmPolicyStatsCountDenies = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsCountDenies.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsCountDenies.setDescription("This counter is incremented when a policy action's Permission value is set to Deny and a session is denied, or when a session (TCP connection) is rejected due to a policy's connection limit (slapmPolicyStatsConnectLimit) being reached.")
slapmPolicyStatsInDiscards = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsInDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsInDiscards.setDescription('This counter counts the number of in octets discarded. This occurs when an error is detected. Examples of this are buffer overflow, checksum error, or bad packet format.')
slapmPolicyStatsOutDiscards = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsOutDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsOutDiscards.setDescription('This counter counts the number of out octets discarded. Examples of this are buffer overflow, checksum error, or bad packet format.')
slapmPolicyStatsInPackets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsInPackets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsInPackets.setDescription('This counter counts the number of in packets received that relate to this policy entry from IP.')
slapmPolicyStatsOutPackets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsOutPackets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsOutPackets.setDescription('This counter counts the number of out packets sent by IP that relate to this policy entry.')
slapmPolicyStatsInProfileOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsInProfileOctets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsInProfileOctets.setDescription('This counter counts the number of in octets that are determined to be within profile.')
slapmPolicyStatsOutProfileOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsOutProfileOctets.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsOutProfileOctets.setDescription('This counter counts the number of out octets that are determined to be within profile.')
slapmPolicyStatsMinRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 20), Integer32()).setUnits('Kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsMinRate.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsMinRate.setDescription('The minimum transfer rate defined for this entry.')
slapmPolicyStatsMaxRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 21), Integer32()).setUnits('Kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsMaxRate.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsMaxRate.setDescription('The maximum transfer rate defined for this entry.')
slapmPolicyStatsMaxDelay = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 1, 1, 22), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyStatsMaxDelay.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyStatsMaxDelay.setDescription('The maximum delay defined for this entry.')
slapmPolicyMonitorTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 2), )
if mibBuilder.loadTexts: slapmPolicyMonitorTable.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorTable.setDescription('Provides a method of monitoring policies and their effect at a system. This table has been deprecated and replaced with the slapmPRMonTable. Older implementations of this MIB are expected to continue their support of this table.')
slapmPolicyMonitorEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 2, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmPolicyMonitorOwnerIndex"), (0, "SLAPM-MIB", "slapmPolicyMonitorSystemAddress"), (0, "SLAPM-MIB", "slapmPolicyMonitorPolicyName"), (0, "SLAPM-MIB", "slapmPolicyMonitorTrafficProfileName"))
if mibBuilder.loadTexts: slapmPolicyMonitorEntry.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorEntry.setDescription('Defines an entry in the slapmPolicyMonitorTable. This table defines which policies should be monitored on a per policy traffic profile basis.')
slapmPolicyMonitorOwnerIndex = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: slapmPolicyMonitorOwnerIndex.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorOwnerIndex.setDescription("To facilitate the provisioning of access control by a security administrator using the View-Based Access Control Model (RFC 2575, VACM) for tables in which multiple users may need to independently create or modify entries, the initial index is used as an 'owner index'. Such an initial index has a syntax of SnmpAdminString, and can thus be trivially mapped to a securityName or groupName as defined in VACM, in accordance with a security policy. All entries in that table belonging to a particular user will have the same value for this initial index. For a given user's entries in a particular table, the object identifiers for the information in these entries will have the same subidentifiers (except for the 'column' subidentifier) up to the end of the encoded owner index. To configure VACM to permit access to this portion of the table, one would create vacmViewTreeFamilyTable entries with the value of vacmViewTreeFamilySubtree including the owner index portion, and vacmViewTreeFamilyMask 'wildcarding' the column subidentifier. More elaborate configurations are possible.")
slapmPolicyMonitorSystemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmPolicyMonitorSystemAddress.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorSystemAddress.setDescription('Address of a system that an Policy definition relates to. A zero length octet string can be used to indicate that only a single system is being represented. Otherwise, the length of the octet string should be 4 for an ipv4 address and 16 for an ipv6 address.')
slapmPolicyMonitorPolicyName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 3), SlapmNameType())
if mibBuilder.loadTexts: slapmPolicyMonitorPolicyName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorPolicyName.setDescription('Policy name that this entry relates to.')
slapmPolicyMonitorTrafficProfileName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 4), SlapmNameType())
if mibBuilder.loadTexts: slapmPolicyMonitorTrafficProfileName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorTrafficProfileName.setDescription('The corresponding Traffic Profile name.')
slapmPolicyMonitorControl = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 5), Bits().clone(namedValues=NamedValues(("monitorMinRate", 0), ("monitorMaxRate", 1), ("monitorMaxDelay", 2), ("enableAggregateTraps", 3), ("enableSubcomponentTraps", 4), ("monitorSubcomponents", 5))).clone(namedValues=NamedValues(("monitorMinRate", 0), ("monitorMaxRate", 1), ("monitorMaxDelay", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorControl.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorControl.setDescription("The value of this object determines the type and level of monitoring that is applied to a policy/profile. The value of this object can't be changed once the table entry that it is a part of is activated via a slapmPolicyMonitorRowStatus transition to active state. monitorMinRate(0) - Monitor minimum transfer rate. monitorMaxRate(1) - Monitor maximum transfer rate. monitorMaxDelay(2) - Monitor maximum delay. enableAggregateTraps(3) - The enableAggregateTraps(3) BITS setting enables notification generation when monitoring a policy traffic profile as an aggregate using the values in the corresponding slapmPolicyStatsEntry. By default this function is not enabled. enableSubcomponentTraps(4) - This BITS setting enables notification generation when monitoring all subcomponents that are mapped to an corresponding slapmPolicyStatsEntry. By default this function is not enabled. monitorSubcomponents(5) - This BITS setting enables monitoring of each subcomponent (typically a TCP connection or UDP listener) individually.")
slapmPolicyMonitorStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 6), SlapmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorStatus.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorStatus.setDescription("The value of this object indicates when a monitored value has not meet a threshold or isn't meeting the defined service level. The SlapmStatus TEXTUAL-CONVENTION defines two levels of not meeting a threshold. The first set: slaMinInRateNotAchieved(0), slaMaxInRateExceeded(1), slaMaxDelayExceeded(2), slaMinOutRateNotAchieved(3), slaMaxOutRateExceeded(4) are used to indicate when the SLA as an aggregate is not meeting a threshold while the second set: monitorMinInRateNotAchieved(5), monitorMaxInRateExceeded(6), monitorMaxDelayExceeded(7), monitorMinOutRateNotAchieved(8), monitorMaxOutRateExceeded(9) indicate that at least one subcomponent is not meeting a threshold.")
slapmPolicyMonitorInterval = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400)).clone(20)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorInterval.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorInterval.setDescription('The number of seconds that defines the sample period.')
slapmPolicyMonitorIntTime = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 8), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorIntTime.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorIntTime.setDescription('The timestamp for when the last interval ended.')
slapmPolicyMonitorCurrentInRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 9), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentInRate.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentInRate.setDescription('Using the value of the corresponding slapmPolicyMonitorInterval, slapmPolicyStatsInOctets is sampled and then divided by slapmPolicyMonitorInterval to determine the current in transfer rate.')
slapmPolicyMonitorCurrentOutRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 10), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentOutRate.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentOutRate.setDescription('Using the value of the corresponding slapmPolicyMonitorInterval, slapmPolicyStatsOutOctets is sampled and then divided by slapmPolicyMonitorInterval to determine the current out transfer rate.')
slapmPolicyMonitorMinRateLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 11), Integer32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMinRateLow.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMinRateLow.setDescription("The threshold for generating a slapmMonitoredEventNotAchieved notification, signalling that a monitored minimum transfer rate has not been meet. A slapmMonitoredEventNotAchieved notification is not generated again for an slapmPolicyMonitorEntry until the minimum transfer rate exceeds slapmPolicyMonitorMinRateHigh (a slapmMonitoredEventOkay notification is then transmitted) and then fails below slapmPolicyMonitorMinRateLow. This behavior reduces the slapmMonitoredEventNotAchieved notifications that are transmitted. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMinRate(0) is not enabled. When enabled the default value for this object is the min rate value specified in the associated action definition minus 10%. If the action definition doesn't have a min rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMinRate(0) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMinRateHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 12), Integer32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMinRateHigh.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMinRateHigh.setDescription("The threshold for generating a slapmMonitoredEventOkay notification, signalling that a monitored minimum transfer rate has increased to an acceptable level. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMinRate(0) is not enabled. When enabled the default value for this object is the min rate value specified in the associated action definition plus 10%. If the action definition doesn't have a min rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMinRate(0) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMaxRateHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 13), Integer32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxRateHigh.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxRateHigh.setDescription("The threshold for generating a slapmMonitoredEventNotAchieved notification, signalling that a monitored maximum transfer rate has been exceeded. A slapmMonitoredEventNotAchieved notification is not generated again for an slapmPolicyMonitorEntry until the maximum transfer rate fails below slapmPolicyMonitorMaxRateLow (a slapmMonitoredEventOkay notification is then transmitted) and then raises above slapmPolicyMonitorMaxRateHigh. This behavior reduces the slapmMonitoredEventNotAchieved notifications that are transmitted. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMaxRate(1) is not enabled. When enabled the default value for this object is the max rate value specified in the associated action definition plus 10%. If the action definition doesn't have a max rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxRate(1) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMaxRateLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 14), Integer32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxRateLow.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxRateLow.setDescription("The threshold for generating a slapmMonitoredEventOkay notification, signalling that a monitored maximum transfer rate has fallen to an acceptable level. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMaxRate(1) is not enabled. When enabled the default value for this object is the max rate value specified in the associated action definition minus 10%. If the action definition doesn't have a max rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxRate(1) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMaxDelayHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 15), Integer32()).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayHigh.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayHigh.setDescription("The threshold for generating a slapmMonitoredEventNotAchieved notification, signalling that a monitored maximum delay rate has been exceeded. A slapmMonitoredEventNotAchieved notification is not generated again for an slapmPolicyMonitorEntry until the maximum delay rate falls below slapmPolicyMonitorMaxDelayLow (a slapmMonitoredEventOkay notification is then transmitted) and raises above slapmPolicyMonitorMaxDelayHigh. This behavior reduces the slapmMonitoredEventNotAchieved notifications that are transmitted. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMaxDelay(4) is not enabled. When enabled the default value for this object is the max delay value specified in the associated action definition plus 10%. If the action definition doesn't have a max delay defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxDelay(4) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMaxDelayLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 16), Integer32()).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayLow.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayLow.setDescription("The threshold for generating a slapmMonitoredEventOkay notification, signalling that a monitored maximum delay rate has fallen to an acceptable level. A value of zero for this object is returned when the slapmPolicyMonitorControl monitorMaxDelay(4) is not enabled. When enabled the default value for this object is the max delay value specified in the associated action definition minus 10%. If the action definition doesn't have a max delay defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxDelay(4) is selected. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPolicyMonitorMinInRateNotAchieves = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorMinInRateNotAchieves.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMinInRateNotAchieves.setDescription('The number of times that a minimum transfer in rate was not achieved.')
slapmPolicyMonitorMaxInRateExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxInRateExceeds.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxInRateExceeds.setDescription('The number of times that a maximum transfer in rate was exceeded.')
slapmPolicyMonitorMaxDelayExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayExceeds.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxDelayExceeds.setDescription('The number of times that a maximum delay in rate was exceeded.')
slapmPolicyMonitorMinOutRateNotAchieves = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorMinOutRateNotAchieves.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMinOutRateNotAchieves.setDescription('The number of times that a minimum transfer out rate was not achieved.')
slapmPolicyMonitorMaxOutRateExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorMaxOutRateExceeds.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorMaxOutRateExceeds.setDescription('The number of times that a maximum transfer out rate was exceeded.')
slapmPolicyMonitorCurrentDelayRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 22), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentDelayRate.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorCurrentDelayRate.setDescription('The current delay rate for this entry. This is calculated by taking the average of the TCP round trip times for all associating slapmSubcomponentTable entries within a interval.')
slapmPolicyMonitorRowStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 2, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPolicyMonitorRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorRowStatus.setDescription('This object allows entries to be created and deleted in the slapmPolicyMonitorTable. An entry in this table is deleted by setting this object to destroy(6). Removal of a corresponding (same policy and traffic profile names) slapmPolicyStatsEntry has the side effect of the automatic deletion an entry in this table.')
slapmSubcomponentTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 3), )
if mibBuilder.loadTexts: slapmSubcomponentTable.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTable.setDescription('Defines a table to provide information on the individually components that are mapped to a policy rule (or old traffic profile). The indexing for this table is designed to support the use of an SNMP GET-NEXT operation using only the remote address and remote port as a way for a management station to retrieve the table entries relating to a particular client.')
slapmSubcomponentEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 3, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmSubcomponentRemAddress"), (0, "SLAPM-MIB", "slapmSubcomponentRemPort"), (0, "SLAPM-MIB", "slapmSubcomponentLocalAddress"), (0, "SLAPM-MIB", "slapmSubcomponentLocalPort"))
if mibBuilder.loadTexts: slapmSubcomponentEntry.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentEntry.setDescription("Describes a particular subcomponent entry. This table does not have an OwnerIndex as part of its indexing since this table's contents is intended to span multiple users.")
slapmSubcomponentRemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmSubcomponentRemAddress.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentRemAddress.setDescription('Indicate the remote address of a subcomponent. A remote address can be either an ipv4 address in which case 4 octets are required or as an ipv6 address that requires 16 octets. The value of this subidentifier is a zero length octet string when this entry relates to a UDP listener.')
slapmSubcomponentRemPort = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: slapmSubcomponentRemPort.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentRemPort.setDescription('Indicate the remote port of a subcomponent. The value of this subidentifier is 0 when this entry relates to a UDP listener.')
slapmSubcomponentLocalAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 3), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmSubcomponentLocalAddress.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentLocalAddress.setDescription('Indicate the local address of a subcomponent. A local address can be either an ipv4 address in which case 4 octets are required or as an ipv6 address that requires 16 octets.')
slapmSubcomponentLocalPort = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: slapmSubcomponentLocalPort.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentLocalPort.setDescription('Indicate the local port of a subcomponent.')
slapmSubcomponentProtocol = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("udpListener", 1), ("tcpConnection", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentProtocol.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentProtocol.setDescription('Indicate the protocol in use that identifies the type of subcomponent.')
slapmSubcomponentSystemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 6), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentSystemAddress.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentSystemAddress.setDescription('Address of a system that an Policy definition relates to. A zero length octet string can be used to indicate that only a single system is being represented. Otherwise, the length of the octet string should be 4 for an ipv4 address and 16 for an ipv6 address.')
slapmSubcomponentPolicyName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 7), SlapmNameType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentPolicyName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmSubcomponentPolicyName.setDescription('Policy name that this entry relates to. This object, along with slapmSubcomponentTrafficProfileName, have been replaced with the use of an unsigned integer index that is mapped to an slapmPolicyNameEntry to actually identify policy naming.')
slapmSubcomponentTrafficProfileName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 8), SlapmNameType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTrafficProfileName.setStatus('deprecated')
if mibBuilder.loadTexts: slapmSubcomponentTrafficProfileName.setDescription('The corresponding traffic profile name. This object, along with slapmSubcomponentProfileName, have been replaced with the use of an unsigned integer index that is mapped to an slapmPolicyNameEntry to actually identify policy naming.')
slapmSubcomponentLastActivity = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 9), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentLastActivity.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentLastActivity.setDescription('The date and timestamp of when this entry was last used.')
slapmSubcomponentInOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentInOctets.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentInOctets.setDescription('The number of octets received from IP for this connection.')
slapmSubcomponentOutOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentOutOctets.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentOutOctets.setDescription('The number of octets sent to IP for this connection.')
slapmSubcomponentTcpOutBufferedOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTcpOutBufferedOctets.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTcpOutBufferedOctets.setDescription('Number of outgoing octets buffered. The value of this object is zero when the entry is not for a TCP connection.')
slapmSubcomponentTcpInBufferedOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTcpInBufferedOctets.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTcpInBufferedOctets.setDescription('Number of incoming octets buffered. The value of this object is zero when the entry is not for a TCP connection.')
slapmSubcomponentTcpReXmts = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTcpReXmts.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTcpReXmts.setDescription('Number of retransmissions. The value of this object is zero when the entry is not for a TCP connection.')
slapmSubcomponentTcpRoundTripTime = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 15), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTcpRoundTripTime.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTcpRoundTripTime.setDescription('The amount of time that has elapsed, measured in milliseconds, from when the last TCP segment was transmitted by the TCP Stack until the ACK was received. The value of this object is zero when the entry is not for a TCP connection.')
slapmSubcomponentTcpRoundTripVariance = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentTcpRoundTripVariance.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentTcpRoundTripVariance.setDescription('Round trip time variance. The value of this object is zero when the entry is not for a TCP connection.')
slapmSubcomponentInPdus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentInPdus.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentInPdus.setDescription('The number of protocol related data units transferred inbound: slapmSubcomponentProtocol PDU Type udpListener(1) UDP datagrams tcpConnection(2) TCP segments')
slapmSubcomponentOutPdus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentOutPdus.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentOutPdus.setDescription('The number of protocol related data units transferred outbound: slapmSubcomponentProtocol PDU Type udpListener(1) UDP datagrams tcpConnection(2) TCP segments')
slapmSubcomponentApplName = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 19), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentApplName.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentApplName.setDescription('The application name associated with this entry if known, otherwise a zero-length octet string is returned as the value of this object.')
slapmSubcomponentMonitorStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 20), SlapmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentMonitorStatus.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentMonitorStatus.setDescription("The value of this object indicates when a monitored value has exceeded a threshold or isn't meeting the defined service level. Only the following SlapmStatus BITS setting can be reported here: monitorMinInRateNotAchieved(5), monitorMaxInRateExceeded(6), monitorMaxDelayExceeded(7), monitorMinOutRateNotAchieved(8), monitorMaxOutRateExceeded(9) This object only has meaning when an corresponding slapmPolicyMonitorEntry exists with the slapmPolicyMonitorControl BITS setting monitorSubcomponents(5) enabled.")
slapmSubcomponentMonitorIntTime = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 21), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentMonitorIntTime.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentMonitorIntTime.setDescription('The timestamp for when the last interval ended. This object only has meaning when an corresponding slapmPRMonEntry (or old slapmPolicyMonitorEntry) exists with the slapmPRMonControl (or slapmPolicyMonitorControl) BITS setting monitorSubcomponents(5) enabled. All of the octets returned when monitoring is not in effect must be zero.')
slapmSubcomponentMonitorCurrentInRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 22), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentMonitorCurrentInRate.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentMonitorCurrentInRate.setDescription('Using the value of the corresponding slapmPRMonInterval (or slapmPolicyMonitorInterval), slapmSubcomponentStatsInOctets is divided by slapmSubcomponentMonitorInterval to determine the current in transfer rate. This object only has meaning when an corresponding slapmPRMonEntry (or slapmPolicyMonitorEntry) exists with the slapmPRMonControl (or slapmPolicyMonitorControl) BITS setting monitorSubcomponents(5) enabled. The value of this object is zero when monitoring is not in effect.')
slapmSubcomponentMonitorCurrentOutRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 23), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentMonitorCurrentOutRate.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentMonitorCurrentOutRate.setDescription('Using the value of the corresponding slapmPRMonInterval (or slapmPolicyMonitorInterva)l, slapmSubcomponentStatsOutOctets is divided by slapmPRMonInterval (or slapmPolicyMonitorInterval) to determine the current out transfer rate. This object only has meaning when an corresponding slapmPRMonEntry (or slapmPolicyMonitorEntry) exists with the slapmPRMonControl (or slapmPolicyMonitorControl) BITS setting monitorSubcomponents(5) enabled. The value of this object is zero when monitoring is not in effect.')
slapmSubcomponentPolicyRuleIndex = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 3, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmSubcomponentPolicyRuleIndex.setStatus('current')
if mibBuilder.loadTexts: slapmSubcomponentPolicyRuleIndex.setDescription('Points to an slapmPolicyNameEntry when combined with slapmSubcomponentSystemAddress to indicate the policy naming that relates to this entry. A value of 0 for this object MUST be returned when the corresponding slapmSubcomponentEntry has no policy rule associated with it.')
slapmPolicyNameTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 4), )
if mibBuilder.loadTexts: slapmPolicyNameTable.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyNameTable.setDescription('Provides the mapping between a policy index as a unsigned 32 bit integer and the unique name associated with a policy rule.')
slapmPolicyNameEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 4, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmPolicyNameSystemAddress"), (0, "SLAPM-MIB", "slapmPolicyNameIndex"))
if mibBuilder.loadTexts: slapmPolicyNameEntry.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyNameEntry.setDescription('Defines an entry in the slapmPolicyNameTable.')
slapmPolicyNameSystemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmPolicyNameSystemAddress.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyNameSystemAddress.setDescription('Address of a system that an Policy rule definition relates to. A zero length octet string must be used to indicate that only a single system is being represented. Otherwise, the length of the octet string must be 4 for an ipv4 address or 16 for an ipv6 address.')
slapmPolicyNameIndex = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: slapmPolicyNameIndex.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyNameIndex.setDescription('A locally arbitrary, but unique identifier associated with this table entry. This value is not expected to remain constant across reIPLs.')
slapmPolicyNameOfRule = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 4, 1, 3), SlapmPolicyRuleName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyNameOfRule.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyNameOfRule.setDescription('The unique name that identifies a policy rule definition.')
slapmPolicyRuleStatsTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 5), )
if mibBuilder.loadTexts: slapmPolicyRuleStatsTable.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsTable.setDescription('Provides statistics on a per system and a per policy rule basis.')
slapmPolicyRuleStatsEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 5, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmPolicyNameSystemAddress"), (0, "SLAPM-MIB", "slapmPolicyNameIndex"))
if mibBuilder.loadTexts: slapmPolicyRuleStatsEntry.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsEntry.setDescription('Defines an entry in the slapmPolicyRuleStatsTable. This table defines a set of statistics that is kept on a per system and per policy rule basis. Entries in this table are not created or deleted via SNMP but reflect the set of policy rule definitions known at a system.')
slapmPolicyRuleStatsOperStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("deleteNeeded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsOperStatus.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsOperStatus.setDescription('The state of a policy entry: inactive(1) - An policy entry was either defined by local system definition or discovered via a directory search but has not been activated (not currently being used). active(2) - Policy entry is being used to affect traffic flows. deleteNeeded(3) - Either though local implementation dependent methods or by discovering that the directory entry corresponding to this table entry no longer exists and slapmPolicyPurgeTime needs to expire before attempting to remove the corresponding slapmPolicyStatsEntry and any dependent slapmPolicyMonitor table entries. Note: a policy rule in a state other than active(2) is not being used to affect traffic flows.')
slapmPolicyRuleStatsActiveConns = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsActiveConns.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsActiveConns.setDescription('The number of active TCP connections that are affected by the corresponding policy entry.')
slapmPolicyRuleStatsTotalConns = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsTotalConns.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsTotalConns.setDescription('The number of total TCP connections that are affected by the corresponding policy entry.')
slapmPolicyRuleStatsLActivated = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 4), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsLActivated.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsLActivated.setDescription('The timestamp for when the corresponding policy entry was last activated. The value of this object serves as the discontinuity event indicator when polling entries in this table. The value of this object is updated on transition of slapmPolicyRuleStatsOperStatus into the active(2) state.')
slapmPolicyRuleStatsLastMapping = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 5), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsLastMapping.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsLastMapping.setDescription('The timestamp for when the last time that the associated policy entry was used.')
slapmPolicyRuleStatsInOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsInOctets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsInOctets.setDescription('The number of octets that was received by IP for an entity that map to this entry.')
slapmPolicyRuleStatsOutOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutOctets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutOctets.setDescription('The number of octets that was transmitted by IP for an entity that map to this entry.')
slapmPolicyRuleStatsConnLimit = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsConnLimit.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsConnLimit.setDescription('The limit for the number of active TCP connections that are allowed for this policy definition. A value of zero for this object implies that a connection limit has not been specified.')
slapmPolicyRuleStatsCountAccepts = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsCountAccepts.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsCountAccepts.setDescription("This counter is incremented when a policy action's Permission value is set to Accept and a session (TCP connection) is accepted.")
slapmPolicyRuleStatsCountDenies = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsCountDenies.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsCountDenies.setDescription("This counter is incremented when a policy action's Permission value is set to Deny and a session is denied, or when a session (TCP connection) is rejected due to a policy's connection limit (slapmPolicyRuleStatsConnectLimit) being reached.")
slapmPolicyRuleStatsInDiscards = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsInDiscards.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsInDiscards.setDescription('This counter counts the number of in octets discarded. This occurs when an error is detected. Examples of this are buffer overflow, checksum error, or bad packet format.')
slapmPolicyRuleStatsOutDiscards = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutDiscards.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutDiscards.setDescription('This counter counts the number of out octets discarded. Examples of this are buffer overflow, checksum error, or bad packet format.')
slapmPolicyRuleStatsInPackets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsInPackets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsInPackets.setDescription('This counter counts the number of in packets received that relate to this policy entry from IP.')
slapmPolicyRuleStatsOutPackets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutPackets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutPackets.setDescription('This counter counts the number of out packets sent by IP that relate to this policy entry.')
slapmPolicyRuleStatsInProOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsInProOctets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsInProOctets.setDescription('This counter counts the number of in octets that are determined to be within profile.')
slapmPolicyRuleStatsOutProOctets = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutProOctets.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsOutProOctets.setDescription('This counter counts the number of out octets that are determined to be within profile.')
slapmPolicyRuleStatsMinRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 17), Unsigned32()).setUnits('Kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsMinRate.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsMinRate.setDescription('The minimum transfer rate defined for this entry.')
slapmPolicyRuleStatsMaxRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 18), Unsigned32()).setUnits('Kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsMaxRate.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsMaxRate.setDescription('The maximum transfer rate defined for this entry.')
slapmPolicyRuleStatsMaxDelay = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 19), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsMaxDelay.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsMaxDelay.setDescription('The maximum delay defined for this entry.')
slapmPolicyRuleStatsTotalRsvpFlows = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsTotalRsvpFlows.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsTotalRsvpFlows.setDescription('Total number of RSVP flows that have be activated.')
slapmPolicyRuleStatsActRsvpFlows = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 5, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPolicyRuleStatsActRsvpFlows.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleStatsActRsvpFlows.setDescription('Current number of active RSVP flows.')
slapmPRMonTable = MibTable((1, 3, 6, 1, 3, 88, 1, 2, 6), )
if mibBuilder.loadTexts: slapmPRMonTable.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonTable.setDescription('Provides a method of monitoring policies and their effect at a system.')
slapmPRMonEntry = MibTableRow((1, 3, 6, 1, 3, 88, 1, 2, 6, 1), ).setIndexNames((0, "SLAPM-MIB", "slapmPRMonOwnerIndex"), (0, "SLAPM-MIB", "slapmPRMonSystemAddress"), (0, "SLAPM-MIB", "slapmPRMonIndex"))
if mibBuilder.loadTexts: slapmPRMonEntry.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonEntry.setDescription('Defines an entry in the slapmPRMonTable. This table defines which policies should be monitored on a per policy rule basis. An attempt to set any read-create object defined within an slapmPRMonEntry while the value of slapmPRMonRowStatus is active(1) will result in an inconsistentValue error.')
slapmPRMonOwnerIndex = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: slapmPRMonOwnerIndex.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonOwnerIndex.setDescription("To facilitate the provisioning of access control by a security administrator using the View-Based Access Control Model (RFC 2575, VACM) for tables in which multiple users may need to independently create or modify entries, the initial index is used as an 'owner index'. Such an initial index has a syntax of SnmpAdminString, and can thus be trivially mapped to a securityName or groupName as defined in VACM, in accordance with a security policy. All entries in that table belonging to a particular user will have the same value for this initial index. For a given user's entries in a particular table, the object identifiers for the information in these entries will have the same subidentifiers (except for the 'column' subidentifier) up to the end of the encoded owner index. To configure VACM to permit access to this portion of the table, one would create vacmViewTreeFamilyTable entries with the value of vacmViewTreeFamilySubtree including the owner index portion, and vacmViewTreeFamilyMask 'wildcarding' the column subidentifier. More elaborate configurations are possible.")
slapmPRMonSystemAddress = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: slapmPRMonSystemAddress.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonSystemAddress.setDescription('Address of a system that an Policy definition relates to. A zero length octet string can be used to indicate that only a single system is being represented. Otherwise, the length of the octet string should be 4 for an ipv4 address and 16 for an ipv6 address.')
slapmPRMonIndex = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 3), Unsigned32())
if mibBuilder.loadTexts: slapmPRMonIndex.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonIndex.setDescription('An slapmPolicyNameTable index, slapmPolicyNameIndex, that points to the unique name associated with a policy rule definition.')
slapmPRMonControl = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 4), Bits().clone(namedValues=NamedValues(("monitorMinRate", 0), ("monitorMaxRate", 1), ("monitorMaxDelay", 2), ("enableAggregateTraps", 3), ("enableSubcomponentTraps", 4), ("monitorSubcomponents", 5))).clone(namedValues=NamedValues(("monitorMinRate", 0), ("monitorMaxRate", 1), ("monitorMaxDelay", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonControl.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonControl.setDescription("The value of this object determines the type and level of monitoring that is applied to a policy rule. The value of this object can't be changed once the table entry that it is a part of is activated via a slapmPRMonRowStatus transition to active state. monitorMinRate(0) - Monitor minimum transfer rate. monitorMaxRate(1) - Monitor maximum transfer rate. monitorMaxDelay(2) - Monitor maximum delay. enableAggregateTraps(3) - The enableAggregateTraps(3) BITS setting enables notification generation when monitoring a policy rule as an aggregate using the values in the corresponding slapmPRMonStatsEntry. By default this function is not enabled. enableSubcomponentTraps(4) - This BITS setting enables notification generation when monitoring all subcomponents that are mapped to an corresponding slapmPRMonStatsEntry. By default this function is not enabled. monitorSubcomponents(5) - This BITS setting enables monitoring of each subcomponent (typically a TCP connection or UDP listener) individually.")
slapmPRMonStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 5), SlapmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonStatus.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonStatus.setDescription("The value of this object indicates when a monitored value has not meet a threshold or isn't meeting the defined service level. The SlapmStatus TEXTUAL-CONVENTION defines two levels of not meeting a threshold. The first set: slaMinInRateNotAchieved(0), slaMaxInRateExceeded(1), slaMaxDelayExceeded(2), slaMinOutRateNotAchieved(3), slaMaxOutRateExceeded(4) are used to indicate when the SLA as an aggregate is not meeting a threshold while the second set: monitorMinInRateNotAchieved(5), monitorMaxInRateExceeded(6), monitorMaxDelayExceeded(7), monitorMinOutRateNotAchieved(8), monitorMaxOutRateExceeded(9) indicate that at least one subcomponent is not meeting a threshold.")
slapmPRMonInterval = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400)).clone(20)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonInterval.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonInterval.setDescription('The number of seconds that defines the sample period.')
slapmPRMonIntTime = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 7), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonIntTime.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonIntTime.setDescription('The timestamp for when the last interval ended.')
slapmPRMonCurrentInRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 8), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonCurrentInRate.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonCurrentInRate.setDescription('Using the value of the corresponding slapmPRMonInterval, slapmPolicyRuleStatsInOctets is sampled and then divided by slapmPRMonInterval to determine the current in transfer rate.')
slapmPRMonCurrentOutRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 9), Gauge32()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonCurrentOutRate.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonCurrentOutRate.setDescription('Using the value of the corresponding slapmPolicyMonInterval, slapmPolicyRuleStatsOutOctets is sampled and then divided by slapmPRMonInterval to determine the current out transfer rate.')
slapmPRMonMinRateLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 10), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMinRateLow.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMinRateLow.setDescription("The threshold for generating a slapmPolicyRuleMonNotOkay notification, signalling that a monitored minimum transfer rate has not been meet. A slapmPolicyRuleMonNotOkay notification is not generated again for an slapmPRMonEntry until the minimum transfer rate exceeds slapmPRMonMinRateHigh (a slapmPolicyRuleMonOkay notification is then transmitted) and then fails below slapmPRMonMinRateLow. This behavior reduces the slapmPolicyRuleMonNotOkay notifications that are transmitted. A value of zero for this object is returned when the slapmPRMonControl monitorMinRate(0) is not enabled. When enabled the default value for this object is the min rate value specified in the associated action definition minus 10%. If the action definition doesn't have a min rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMinRate(0) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMinRateHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 11), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMinRateHigh.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMinRateHigh.setDescription("The threshold for generating a slapmPolicyRuleMonOkay notification, signalling that a monitored minimum transfer rate has increased to an acceptable level. A value of zero for this object is returned when the slapmPRMonControl monitorMinRate(0) is not enabled. When enabled the default value for this object is the min rate value specified in the associated action definition plus 10%. If the action definition doesn't have a min rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMinRate(0) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMaxRateHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 12), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMaxRateHigh.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxRateHigh.setDescription("The threshold for generating a slapmPolicyRuleMonNotOkay notification, signalling that a monitored maximum transfer rate has been exceeded. A slapmPolicyRuleNotOkay notification is not generated again for an slapmPRMonEntry until the maximum transfer rate fails below slapmPRMonMaxRateLow (a slapmPolicyRuleMonOkay notification is then transmitted) and then raises above slapmPRMonMaxRateHigh. This behavior reduces the slapmPolicyRuleMonNotOkay notifications that are transmitted. A value of zero for this object is returned when the slapmPRMonControl monitorMaxRate(1) is not enabled. When enabled the default value for this object is the max rate value specified in the associated action definition plus 10%. If the action definition doesn't have a max rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxRate(1) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMaxRateLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 13), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMaxRateLow.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxRateLow.setDescription("The threshold for generating a slapmPolicyRuleMonOkay notification, signalling that a monitored maximum transfer rate has fallen to an acceptable level. A value of zero for this object is returned when the slapmPRMonControl monitorMaxRate(1) is not enabled. When enabled the default value for this object is the max rate value specified in the associated action definition minus 10%. If the action definition doesn't have a max rate defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxRate(1) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMaxDelayHigh = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 14), Unsigned32()).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMaxDelayHigh.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxDelayHigh.setDescription("The threshold for generating a slapmPolicyRuleMonNotOkay notification, signalling that a monitored maximum delay rate has been exceeded. A slapmPolicyRuleMonNotOkay notification is not generated again for an slapmPRMonEntry until the maximum delay rate falls below slapmPRMonMaxDelayLow (a slapmPolicyRuleMonOkay notification is then transmitted) and raises above slapmPRMonMaxDelayHigh. This behavior reduces the slapmPolicyRuleMonNotOkay notifications that are transmitted. A value of zero for this object is returned when the slapmPRMonControl monitorMaxDelay(4) is not enabled. When enabled the default value for this object is the max delay value specified in the associated action definition plus 10%. If the action definition doesn't have a max delay defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxDelay(4) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMaxDelayLow = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 15), Unsigned32()).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonMaxDelayLow.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxDelayLow.setDescription("The threshold for generating a slapmPolicyRuleMonOkay notification, signalling that a monitored maximum delay rate has fallen to an acceptable level. A value of zero for this object is returned when the slapmPRMonControl monitorMaxDelay(4) is not enabled. When enabled the default value for this object is the max delay value specified in the associated action definition minus 10%. If the action definition doesn't have a max delay defined then there is no default for this object and a value MUST be specified prior to activating this entry when monitorMaxDelay(4) is selected. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for any notification relating to this entry to potentially be generated.")
slapmPRMonMinInRateNotAchieves = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonMinInRateNotAchieves.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMinInRateNotAchieves.setDescription('The number of times that a minimum transfer in rate was not achieved.')
slapmPRMonMaxInRateExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonMaxInRateExceeds.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxInRateExceeds.setDescription('The number of times that a maximum transfer in rate was exceeded.')
slapmPRMonMaxDelayExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonMaxDelayExceeds.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxDelayExceeds.setDescription('The number of times that a maximum delay in rate was exceeded.')
slapmPRMonMinOutRateNotAchieves = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonMinOutRateNotAchieves.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMinOutRateNotAchieves.setDescription('The number of times that a minimum transfer out rate was not achieved.')
slapmPRMonMaxOutRateExceeds = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonMaxOutRateExceeds.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonMaxOutRateExceeds.setDescription('The number of times that a maximum transfer out rate was exceeded.')
slapmPRMonCurrentDelayRate = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 21), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slapmPRMonCurrentDelayRate.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonCurrentDelayRate.setDescription('The current delay rate for this entry. This is calculated by taking the average of the TCP round trip times for all associating slapmSubcomponentTable entries within a interval.')
slapmPRMonRowStatus = MibTableColumn((1, 3, 6, 1, 3, 88, 1, 2, 6, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: slapmPRMonRowStatus.setStatus('current')
if mibBuilder.loadTexts: slapmPRMonRowStatus.setDescription('This object allows entries to be created and deleted in the slapmPRMonTable. An entry in this table is deleted by setting this object to destroy(6). Removal of an corresponding (same policy index) slapmPolicyRuleStatsEntry has the side effect of the automatic deletion an entry in this table. Note that an attempt to set any read-create object defined within an slapmPRMonEntry while the value of slapmPRMonRowStatus is active(1) will result in an inconsistentValue error.')
slapmMonitoredEventNotAchieved = NotificationType((1, 3, 6, 1, 3, 88, 0, 1)).setObjects(("SLAPM-MIB", "slapmPolicyMonitorIntTime"), ("SLAPM-MIB", "slapmPolicyMonitorControl"), ("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentInRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentDelayRate"))
if mibBuilder.loadTexts: slapmMonitoredEventNotAchieved.setStatus('deprecated')
if mibBuilder.loadTexts: slapmMonitoredEventNotAchieved.setDescription('This notification is generated when an monitored event is not achieved with respect to threshold. This applies only towards monitoring a policy traffic profile as an aggregate via an associating slapmPolicyStatsEntry. The value of slapmPolicyMonitorControl can be examined to determine what is being monitored. The first slapmPolicyMonitorStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmMonitoredEventOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 2)).setObjects(("SLAPM-MIB", "slapmPolicyMonitorIntTime"), ("SLAPM-MIB", "slapmPolicyMonitorControl"), ("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentInRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentDelayRate"))
if mibBuilder.loadTexts: slapmMonitoredEventOkay.setStatus('deprecated')
if mibBuilder.loadTexts: slapmMonitoredEventOkay.setDescription('This notification is generated when a monitored event has improved to an acceptable level. This applies only towards monitoring a policy traffic profile as an aggregate via an associating slapmPolicyStatsEntry. The value of slapmPolicyMonitorControl can be examined to determine what is being monitored. The first slapmPolicyMonitorStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableAggregateTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmPolicyProfileDeleted = NotificationType((1, 3, 6, 1, 3, 88, 0, 3)).setObjects(("SLAPM-MIB", "slapmPolicyStatsActiveConns"), ("SLAPM-MIB", "slapmPolicyStatsTotalConns"), ("SLAPM-MIB", "slapmPolicyStatsFirstActivated"), ("SLAPM-MIB", "slapmPolicyStatsLastMapping"), ("SLAPM-MIB", "slapmPolicyStatsInOctets"), ("SLAPM-MIB", "slapmPolicyStatsOutOctets"), ("SLAPM-MIB", "slapmPolicyStatsConnectionLimit"), ("SLAPM-MIB", "slapmPolicyStatsCountAccepts"), ("SLAPM-MIB", "slapmPolicyStatsCountDenies"), ("SLAPM-MIB", "slapmPolicyStatsInDiscards"), ("SLAPM-MIB", "slapmPolicyStatsOutDiscards"), ("SLAPM-MIB", "slapmPolicyStatsInPackets"), ("SLAPM-MIB", "slapmPolicyStatsOutPackets"), ("SLAPM-MIB", "slapmPolicyStatsInProfileOctets"), ("SLAPM-MIB", "slapmPolicyStatsOutProfileOctets"), ("SLAPM-MIB", "slapmPolicyStatsMinRate"), ("SLAPM-MIB", "slapmPolicyStatsMaxRate"), ("SLAPM-MIB", "slapmPolicyStatsMaxDelay"))
if mibBuilder.loadTexts: slapmPolicyProfileDeleted.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyProfileDeleted.setDescription('A slapmPolicyDeleted notification is sent when a slapmPolicyStatsEntry is deleted if the value of slapmPolicyTrapEnable is enabled(1).')
slapmPolicyMonitorDeleted = NotificationType((1, 3, 6, 1, 3, 88, 0, 4)).setObjects(("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorInterval"), ("SLAPM-MIB", "slapmPolicyMonitorIntTime"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentInRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentDelayRate"), ("SLAPM-MIB", "slapmPolicyMonitorMinRateLow"), ("SLAPM-MIB", "slapmPolicyMonitorMinRateHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxRateHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxRateLow"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayLow"), ("SLAPM-MIB", "slapmPolicyMonitorMinInRateNotAchieves"), ("SLAPM-MIB", "slapmPolicyMonitorMaxInRateExceeds"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayExceeds"), ("SLAPM-MIB", "slapmPolicyMonitorMinOutRateNotAchieves"), ("SLAPM-MIB", "slapmPolicyMonitorMaxOutRateExceeds"))
if mibBuilder.loadTexts: slapmPolicyMonitorDeleted.setStatus('deprecated')
if mibBuilder.loadTexts: slapmPolicyMonitorDeleted.setDescription('A slapmPolicyMonitorDeleted notification is sent when a slapmPolicyMonitorEntry is deleted if the value of slapmPolicyTrapEnable is enabled(1).')
slapmSubcomponentMonitoredEventNotAchieved = NotificationType((1, 3, 6, 1, 3, 88, 0, 5)).setObjects(("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentPolicyName"), ("SLAPM-MIB", "slapmSubcomponentTrafficProfileName"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"))
if mibBuilder.loadTexts: slapmSubcomponentMonitoredEventNotAchieved.setStatus('deprecated')
if mibBuilder.loadTexts: slapmSubcomponentMonitoredEventNotAchieved.setDescription('This notification is generated when a monitored value does not achieved a threshold specification. This applies only towards monitoring the individual components of a policy traffic profile. The value of the corresponding slapmPolicyMonitorControl can be examined to determine what is being monitored. The first slapmSubcomponentMonitorStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableSubcomponentTraps(4), MUST be selected in order for this notification to potentially be generated.')
slapmSubcomponentMonitoredEventOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 6)).setObjects(("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentPolicyName"), ("SLAPM-MIB", "slapmSubcomponentTrafficProfileName"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"))
if mibBuilder.loadTexts: slapmSubcomponentMonitoredEventOkay.setStatus('deprecated')
if mibBuilder.loadTexts: slapmSubcomponentMonitoredEventOkay.setDescription('This notification is generated when a monitored value has reached an acceptable level. Note: The corresponding slapmPolicyMonitorControl BITS setting, enableSubcomponentTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmPolicyRuleMonNotOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 7)).setObjects(("SLAPM-MIB", "slapmPRMonIntTime"), ("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonCurrentInRate"), ("SLAPM-MIB", "slapmPRMonCurrentOutRate"), ("SLAPM-MIB", "slapmPRMonCurrentDelayRate"))
if mibBuilder.loadTexts: slapmPolicyRuleMonNotOkay.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleMonNotOkay.setDescription('This notification is generated when an monitored event is not achieved with respect to a threshold. This applies only towards monitoring a policy rule as an aggregate via an associating slapmPolicyRuleStatsEntry. The value of slapmPRMonControl can be examined to determine what is being monitored. The first slapmPRMonStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmPolicyRuleMonOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 8)).setObjects(("SLAPM-MIB", "slapmPRMonIntTime"), ("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonCurrentInRate"), ("SLAPM-MIB", "slapmPRMonCurrentOutRate"), ("SLAPM-MIB", "slapmPRMonCurrentDelayRate"))
if mibBuilder.loadTexts: slapmPolicyRuleMonOkay.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleMonOkay.setDescription('This notification is generated when a monitored event has improved to an acceptable level. This applies only towards monitoring a policy rule as an aggregate via an associating slapmPolicyRuleStatsEntry. The value of slapmPRMonControl can be examined to determine what is being monitored. The first slapmPRMonStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPRMonControl BITS setting, enableAggregateTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmPolicyRuleDeleted = NotificationType((1, 3, 6, 1, 3, 88, 0, 9)).setObjects(("SLAPM-MIB", "slapmPolicyRuleStatsActiveConns"), ("SLAPM-MIB", "slapmPolicyRuleStatsTotalConns"), ("SLAPM-MIB", "slapmPolicyRuleStatsLActivated"), ("SLAPM-MIB", "slapmPolicyRuleStatsLastMapping"), ("SLAPM-MIB", "slapmPolicyRuleStatsInOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsConnLimit"), ("SLAPM-MIB", "slapmPolicyRuleStatsCountAccepts"), ("SLAPM-MIB", "slapmPolicyRuleStatsCountDenies"), ("SLAPM-MIB", "slapmPolicyRuleStatsInDiscards"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutDiscards"), ("SLAPM-MIB", "slapmPolicyRuleStatsInPackets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutPackets"), ("SLAPM-MIB", "slapmPolicyRuleStatsInProOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutProOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsMinRate"), ("SLAPM-MIB", "slapmPolicyRuleStatsMaxRate"), ("SLAPM-MIB", "slapmPolicyRuleStatsMaxDelay"), ("SLAPM-MIB", "slapmPolicyRuleStatsTotalRsvpFlows"), ("SLAPM-MIB", "slapmPolicyRuleStatsActRsvpFlows"))
if mibBuilder.loadTexts: slapmPolicyRuleDeleted.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleDeleted.setDescription('A slapmPolicyRuleDeleted notification is sent when a slapmPolicyRuleStatsEntry is deleted if the value of slapmPolicyTrapEnable is enabled(1).')
slapmPolicyRuleMonDeleted = NotificationType((1, 3, 6, 1, 3, 88, 0, 10)).setObjects(("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonInterval"), ("SLAPM-MIB", "slapmPRMonIntTime"), ("SLAPM-MIB", "slapmPRMonCurrentInRate"), ("SLAPM-MIB", "slapmPRMonCurrentOutRate"), ("SLAPM-MIB", "slapmPRMonCurrentDelayRate"), ("SLAPM-MIB", "slapmPRMonMinRateLow"), ("SLAPM-MIB", "slapmPRMonMinRateHigh"), ("SLAPM-MIB", "slapmPRMonMaxRateHigh"), ("SLAPM-MIB", "slapmPRMonMaxRateLow"), ("SLAPM-MIB", "slapmPRMonMaxDelayHigh"), ("SLAPM-MIB", "slapmPRMonMaxDelayLow"), ("SLAPM-MIB", "slapmPRMonMinInRateNotAchieves"), ("SLAPM-MIB", "slapmPRMonMaxInRateExceeds"), ("SLAPM-MIB", "slapmPRMonMaxDelayExceeds"), ("SLAPM-MIB", "slapmPRMonMinOutRateNotAchieves"), ("SLAPM-MIB", "slapmPRMonMaxOutRateExceeds"))
if mibBuilder.loadTexts: slapmPolicyRuleMonDeleted.setStatus('current')
if mibBuilder.loadTexts: slapmPolicyRuleMonDeleted.setDescription('A slapmPolicyRuleMonDeleted notification is sent when a slapmPRMonEntry is deleted if the value of slapmPolicyTrapEnable is enabled(1).')
slapmSubcMonitorNotOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 11)).setObjects(("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentPolicyRuleIndex"), ("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"))
if mibBuilder.loadTexts: slapmSubcMonitorNotOkay.setStatus('current')
if mibBuilder.loadTexts: slapmSubcMonitorNotOkay.setDescription('This notification is generated when a monitored value does not achieved a threshold specification. This applies only towards monitoring the individual components of a policy rule. The value of the corresponding slapmPRMonControl can be examined to determine what is being monitored. The first slapmSubcomponentMonitorStatus value supplies the current monitor status while the 2nd value supplies the previous status. Note: The corresponding slapmPRMonControl BITS setting, enableSubcomponentTraps(4), MUST be selected in order for this notification to potentially be generated.')
slapmSubcMonitorOkay = NotificationType((1, 3, 6, 1, 3, 88, 0, 12)).setObjects(("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentPolicyRuleIndex"), ("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"))
if mibBuilder.loadTexts: slapmSubcMonitorOkay.setStatus('current')
if mibBuilder.loadTexts: slapmSubcMonitorOkay.setDescription('This notification is generated when a monitored value has reached an acceptable level. Note: The corresponding slapmPRMonControl BITS setting, enableSubcomponentTraps(3), MUST be selected in order for this notification to potentially be generated.')
slapmCompliances = MibIdentifier((1, 3, 6, 1, 3, 88, 2, 1))
slapmGroups = MibIdentifier((1, 3, 6, 1, 3, 88, 2, 2))
slapmCompliance = ModuleCompliance((1, 3, 6, 1, 3, 88, 2, 1, 1)).setObjects(("SLAPM-MIB", "slapmBaseGroup2"), ("SLAPM-MIB", "slapmNotGroup2"), ("SLAPM-MIB", "slapmEndSystemGroup2"), ("SLAPM-MIB", "slapmEndSystemNotGroup2"), ("SLAPM-MIB", "slapmBaseGroup"), ("SLAPM-MIB", "slapmNotGroup"), ("SLAPM-MIB", "slapmOptionalGroup"), ("SLAPM-MIB", "slapmEndSystemGroup"), ("SLAPM-MIB", "slapmEndSystemNotGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmCompliance = slapmCompliance.setStatus('current')
if mibBuilder.loadTexts: slapmCompliance.setDescription('The compliance statement for the SLAPM-MIB.')
slapmBaseGroup = ObjectGroup((1, 3, 6, 1, 3, 88, 2, 2, 1)).setObjects(("SLAPM-MIB", "slapmSpinLock"), ("SLAPM-MIB", "slapmPolicyCountQueries"), ("SLAPM-MIB", "slapmPolicyCountAccesses"), ("SLAPM-MIB", "slapmPolicyCountSuccessAccesses"), ("SLAPM-MIB", "slapmPolicyCountNotFounds"), ("SLAPM-MIB", "slapmPolicyPurgeTime"), ("SLAPM-MIB", "slapmPolicyTrapEnable"), ("SLAPM-MIB", "slapmPolicyStatsOperStatus"), ("SLAPM-MIB", "slapmPolicyStatsActiveConns"), ("SLAPM-MIB", "slapmPolicyStatsFirstActivated"), ("SLAPM-MIB", "slapmPolicyStatsLastMapping"), ("SLAPM-MIB", "slapmPolicyStatsInOctets"), ("SLAPM-MIB", "slapmPolicyStatsOutOctets"), ("SLAPM-MIB", "slapmPolicyStatsConnectionLimit"), ("SLAPM-MIB", "slapmPolicyStatsTotalConns"), ("SLAPM-MIB", "slapmPolicyStatsCountAccepts"), ("SLAPM-MIB", "slapmPolicyStatsCountDenies"), ("SLAPM-MIB", "slapmPolicyStatsInDiscards"), ("SLAPM-MIB", "slapmPolicyStatsOutDiscards"), ("SLAPM-MIB", "slapmPolicyStatsInPackets"), ("SLAPM-MIB", "slapmPolicyStatsOutPackets"), ("SLAPM-MIB", "slapmPolicyStatsMinRate"), ("SLAPM-MIB", "slapmPolicyStatsMaxRate"), ("SLAPM-MIB", "slapmPolicyStatsMaxDelay"), ("SLAPM-MIB", "slapmPolicyMonitorControl"), ("SLAPM-MIB", "slapmPolicyMonitorStatus"), ("SLAPM-MIB", "slapmPolicyMonitorInterval"), ("SLAPM-MIB", "slapmPolicyMonitorIntTime"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentInRate"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmPolicyMonitorMinRateLow"), ("SLAPM-MIB", "slapmPolicyMonitorMinRateHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxRateHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxRateLow"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayHigh"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayLow"), ("SLAPM-MIB", "slapmPolicyMonitorMinInRateNotAchieves"), ("SLAPM-MIB", "slapmPolicyMonitorMaxInRateExceeds"), ("SLAPM-MIB", "slapmPolicyMonitorMaxDelayExceeds"), ("SLAPM-MIB", "slapmPolicyMonitorMinOutRateNotAchieves"), ("SLAPM-MIB", "slapmPolicyMonitorMaxOutRateExceeds"), ("SLAPM-MIB", "slapmPolicyMonitorCurrentDelayRate"), ("SLAPM-MIB", "slapmPolicyMonitorRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmBaseGroup = slapmBaseGroup.setStatus('deprecated')
if mibBuilder.loadTexts: slapmBaseGroup.setDescription('The group of objects defined by this MIB that are required for all implementations to be compliant.')
slapmOptionalGroup = ObjectGroup((1, 3, 6, 1, 3, 88, 2, 2, 2)).setObjects(("SLAPM-MIB", "slapmPolicyStatsInProfileOctets"), ("SLAPM-MIB", "slapmPolicyStatsOutProfileOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmOptionalGroup = slapmOptionalGroup.setStatus('deprecated')
if mibBuilder.loadTexts: slapmOptionalGroup.setDescription('The group of objects defined by this MIB that are optional.')
slapmEndSystemGroup = ObjectGroup((1, 3, 6, 1, 3, 88, 2, 2, 3)).setObjects(("SLAPM-MIB", "slapmPolicyTrapFilter"), ("SLAPM-MIB", "slapmSubcomponentProtocol"), ("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentPolicyName"), ("SLAPM-MIB", "slapmSubcomponentTrafficProfileName"), ("SLAPM-MIB", "slapmSubcomponentLastActivity"), ("SLAPM-MIB", "slapmSubcomponentInOctets"), ("SLAPM-MIB", "slapmSubcomponentOutOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpOutBufferedOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpInBufferedOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpReXmts"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripVariance"), ("SLAPM-MIB", "slapmSubcomponentInPdus"), ("SLAPM-MIB", "slapmSubcomponentOutPdus"), ("SLAPM-MIB", "slapmSubcomponentApplName"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmEndSystemGroup = slapmEndSystemGroup.setStatus('deprecated')
if mibBuilder.loadTexts: slapmEndSystemGroup.setDescription('The group of objects defined by this MIB that are required for end system implementations.')
slapmNotGroup = NotificationGroup((1, 3, 6, 1, 3, 88, 2, 2, 4)).setObjects(("SLAPM-MIB", "slapmMonitoredEventNotAchieved"), ("SLAPM-MIB", "slapmMonitoredEventOkay"), ("SLAPM-MIB", "slapmPolicyProfileDeleted"), ("SLAPM-MIB", "slapmPolicyMonitorDeleted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmNotGroup = slapmNotGroup.setStatus('deprecated')
if mibBuilder.loadTexts: slapmNotGroup.setDescription('The group of notifications defined by this MIB that MUST be implemented.')
slapmEndSystemNotGroup = NotificationGroup((1, 3, 6, 1, 3, 88, 2, 2, 5)).setObjects(("SLAPM-MIB", "slapmSubcomponentMonitoredEventNotAchieved"), ("SLAPM-MIB", "slapmSubcomponentMonitoredEventOkay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmEndSystemNotGroup = slapmEndSystemNotGroup.setStatus('deprecated')
if mibBuilder.loadTexts: slapmEndSystemNotGroup.setDescription('The group of objects defined by this MIB that are required for end system implementations.')
slapmBaseGroup2 = ObjectGroup((1, 3, 6, 1, 3, 88, 2, 2, 6)).setObjects(("SLAPM-MIB", "slapmSpinLock"), ("SLAPM-MIB", "slapmPolicyCountQueries"), ("SLAPM-MIB", "slapmPolicyCountAccesses"), ("SLAPM-MIB", "slapmPolicyCountSuccessAccesses"), ("SLAPM-MIB", "slapmPolicyCountNotFounds"), ("SLAPM-MIB", "slapmPolicyPurgeTime"), ("SLAPM-MIB", "slapmPolicyTrapEnable"), ("SLAPM-MIB", "slapmPolicyNameOfRule"), ("SLAPM-MIB", "slapmPolicyRuleStatsOperStatus"), ("SLAPM-MIB", "slapmPolicyRuleStatsActiveConns"), ("SLAPM-MIB", "slapmPolicyRuleStatsTotalConns"), ("SLAPM-MIB", "slapmPolicyRuleStatsLActivated"), ("SLAPM-MIB", "slapmPolicyRuleStatsLastMapping"), ("SLAPM-MIB", "slapmPolicyRuleStatsInOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsConnLimit"), ("SLAPM-MIB", "slapmPolicyRuleStatsCountAccepts"), ("SLAPM-MIB", "slapmPolicyRuleStatsCountDenies"), ("SLAPM-MIB", "slapmPolicyRuleStatsInDiscards"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutDiscards"), ("SLAPM-MIB", "slapmPolicyRuleStatsInPackets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutPackets"), ("SLAPM-MIB", "slapmPolicyRuleStatsInProOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsOutProOctets"), ("SLAPM-MIB", "slapmPolicyRuleStatsMinRate"), ("SLAPM-MIB", "slapmPolicyRuleStatsMaxRate"), ("SLAPM-MIB", "slapmPolicyRuleStatsMaxDelay"), ("SLAPM-MIB", "slapmPolicyRuleStatsTotalRsvpFlows"), ("SLAPM-MIB", "slapmPolicyRuleStatsActRsvpFlows"), ("SLAPM-MIB", "slapmPRMonControl"), ("SLAPM-MIB", "slapmPRMonStatus"), ("SLAPM-MIB", "slapmPRMonInterval"), ("SLAPM-MIB", "slapmPRMonIntTime"), ("SLAPM-MIB", "slapmPRMonCurrentInRate"), ("SLAPM-MIB", "slapmPRMonCurrentOutRate"), ("SLAPM-MIB", "slapmPRMonMinRateLow"), ("SLAPM-MIB", "slapmPRMonMinRateHigh"), ("SLAPM-MIB", "slapmPRMonMaxRateHigh"), ("SLAPM-MIB", "slapmPRMonMaxRateLow"), ("SLAPM-MIB", "slapmPRMonMaxDelayHigh"), ("SLAPM-MIB", "slapmPRMonMaxDelayLow"), ("SLAPM-MIB", "slapmPRMonMinInRateNotAchieves"), ("SLAPM-MIB", "slapmPRMonMaxInRateExceeds"), ("SLAPM-MIB", "slapmPRMonMaxDelayExceeds"), ("SLAPM-MIB", "slapmPRMonMinOutRateNotAchieves"), ("SLAPM-MIB", "slapmPRMonMaxOutRateExceeds"), ("SLAPM-MIB", "slapmPRMonCurrentDelayRate"), ("SLAPM-MIB", "slapmPRMonRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmBaseGroup2 = slapmBaseGroup2.setStatus('current')
if mibBuilder.loadTexts: slapmBaseGroup2.setDescription('The group of objects defined by this MIB that are required for all implementations to be compliant.')
slapmEndSystemGroup2 = ObjectGroup((1, 3, 6, 1, 3, 88, 2, 2, 7)).setObjects(("SLAPM-MIB", "slapmPolicyTrapFilter"), ("SLAPM-MIB", "slapmSubcomponentProtocol"), ("SLAPM-MIB", "slapmSubcomponentSystemAddress"), ("SLAPM-MIB", "slapmSubcomponentLastActivity"), ("SLAPM-MIB", "slapmSubcomponentInOctets"), ("SLAPM-MIB", "slapmSubcomponentOutOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpOutBufferedOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpInBufferedOctets"), ("SLAPM-MIB", "slapmSubcomponentTcpReXmts"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripTime"), ("SLAPM-MIB", "slapmSubcomponentTcpRoundTripVariance"), ("SLAPM-MIB", "slapmSubcomponentInPdus"), ("SLAPM-MIB", "slapmSubcomponentOutPdus"), ("SLAPM-MIB", "slapmSubcomponentApplName"), ("SLAPM-MIB", "slapmSubcomponentMonitorStatus"), ("SLAPM-MIB", "slapmSubcomponentMonitorIntTime"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentOutRate"), ("SLAPM-MIB", "slapmSubcomponentMonitorCurrentInRate"), ("SLAPM-MIB", "slapmSubcomponentPolicyRuleIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmEndSystemGroup2 = slapmEndSystemGroup2.setStatus('current')
if mibBuilder.loadTexts: slapmEndSystemGroup2.setDescription('The group of objects defined by this MIB that are required for end system implementations.')
slapmNotGroup2 = NotificationGroup((1, 3, 6, 1, 3, 88, 2, 2, 8)).setObjects(("SLAPM-MIB", "slapmPolicyRuleMonNotOkay"), ("SLAPM-MIB", "slapmPolicyRuleMonOkay"), ("SLAPM-MIB", "slapmPolicyRuleDeleted"), ("SLAPM-MIB", "slapmPolicyRuleMonDeleted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmNotGroup2 = slapmNotGroup2.setStatus('current')
if mibBuilder.loadTexts: slapmNotGroup2.setDescription('The group of notifications defined by this MIB that MUST be implemented.')
slapmEndSystemNotGroup2 = NotificationGroup((1, 3, 6, 1, 3, 88, 2, 2, 9)).setObjects(("SLAPM-MIB", "slapmSubcMonitorNotOkay"), ("SLAPM-MIB", "slapmSubcMonitorOkay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    slapmEndSystemNotGroup2 = slapmEndSystemNotGroup2.setStatus('current')
if mibBuilder.loadTexts: slapmEndSystemNotGroup2.setDescription('The group of objects defined by this MIB that are required for end system implementations.')
mibBuilder.exportSymbols("SLAPM-MIB", slapmPRMonCurrentOutRate=slapmPRMonCurrentOutRate, slapmPRMonMaxRateLow=slapmPRMonMaxRateLow, slapmPolicyRuleDeleted=slapmPolicyRuleDeleted, slapmPolicyStatsLastMapping=slapmPolicyStatsLastMapping, slapmPolicyMonitorMaxDelayExceeds=slapmPolicyMonitorMaxDelayExceeds, slapmPolicyStatsOutOctets=slapmPolicyStatsOutOctets, slapmPolicyMonitorIntTime=slapmPolicyMonitorIntTime, slapmPolicyRuleStatsCountDenies=slapmPolicyRuleStatsCountDenies, slapmSubcomponentTrafficProfileName=slapmSubcomponentTrafficProfileName, slapmPolicyRuleStatsTotalRsvpFlows=slapmPolicyRuleStatsTotalRsvpFlows, slapmPolicyRuleStatsInPackets=slapmPolicyRuleStatsInPackets, slapmPolicyMonitorMinRateLow=slapmPolicyMonitorMinRateLow, slapmPolicyMonitorCurrentDelayRate=slapmPolicyMonitorCurrentDelayRate, slapmSubcomponentInPdus=slapmSubcomponentInPdus, slapmSubcomponentOutOctets=slapmSubcomponentOutOctets, slapmPolicyStatsInOctets=slapmPolicyStatsInOctets, slapmPolicyMonitorMaxInRateExceeds=slapmPolicyMonitorMaxInRateExceeds, slapmPolicyCountAccesses=slapmPolicyCountAccesses, slapmPolicyStatsPolicyName=slapmPolicyStatsPolicyName, slapmSubcomponentRemPort=slapmSubcomponentRemPort, slapmPolicyMonitorTrafficProfileName=slapmPolicyMonitorTrafficProfileName, slapmPolicyMonitorMaxRateHigh=slapmPolicyMonitorMaxRateHigh, slapmMonitoredEventOkay=slapmMonitoredEventOkay, slapmOptionalGroup=slapmOptionalGroup, slapmPolicyRuleStatsCountAccepts=slapmPolicyRuleStatsCountAccepts, slapmPRMonTable=slapmPRMonTable, slapmPolicyStatsInDiscards=slapmPolicyStatsInDiscards, slapmSubcomponentPolicyName=slapmSubcomponentPolicyName, slapmPRMonMinOutRateNotAchieves=slapmPRMonMinOutRateNotAchieves, slapmSubcomponentOutPdus=slapmSubcomponentOutPdus, slapmPolicyMonitorControl=slapmPolicyMonitorControl, slapmSubcomponentMonitorCurrentInRate=slapmSubcomponentMonitorCurrentInRate, slapmPolicyRuleStatsTable=slapmPolicyRuleStatsTable, slapmPolicyRuleStatsOperStatus=slapmPolicyRuleStatsOperStatus, slapmSubcomponentTcpRoundTripVariance=slapmSubcomponentTcpRoundTripVariance, slapmMIB=slapmMIB, slapmPolicyRuleMonNotOkay=slapmPolicyRuleMonNotOkay, slapmPolicyStatsTrafficProfileName=slapmPolicyStatsTrafficProfileName, slapmPolicyRuleStatsInDiscards=slapmPolicyRuleStatsInDiscards, slapmPolicyStatsTable=slapmPolicyStatsTable, slapmSubcomponentMonitoredEventOkay=slapmSubcomponentMonitoredEventOkay, slapmPolicyNameTable=slapmPolicyNameTable, slapmPolicyStatsCountAccepts=slapmPolicyStatsCountAccepts, slapmPolicyStatsOutDiscards=slapmPolicyStatsOutDiscards, slapmBaseGroup2=slapmBaseGroup2, slapmObjects=slapmObjects, slapmPolicyMonitorCurrentInRate=slapmPolicyMonitorCurrentInRate, slapmPRMonMaxDelayLow=slapmPRMonMaxDelayLow, slapmPolicyStatsFirstActivated=slapmPolicyStatsFirstActivated, slapmPRMonIntTime=slapmPRMonIntTime, slapmPolicyRuleStatsTotalConns=slapmPolicyRuleStatsTotalConns, slapmPRMonRowStatus=slapmPRMonRowStatus, slapmPolicyStatsActiveConns=slapmPolicyStatsActiveConns, slapmPolicyMonitorMinInRateNotAchieves=slapmPolicyMonitorMinInRateNotAchieves, slapmSubcomponentApplName=slapmSubcomponentApplName, slapmEndSystemGroup2=slapmEndSystemGroup2, slapmEndSystemNotGroup2=slapmEndSystemNotGroup2, slapmSubcomponentLocalPort=slapmSubcomponentLocalPort, slapmPolicyStatsOutProfileOctets=slapmPolicyStatsOutProfileOctets, slapmPRMonCurrentInRate=slapmPRMonCurrentInRate, slapmPolicyRuleStatsActiveConns=slapmPolicyRuleStatsActiveConns, slapmEndSystemNotGroup=slapmEndSystemNotGroup, slapmPolicyMonitorMaxOutRateExceeds=slapmPolicyMonitorMaxOutRateExceeds, slapmPolicyRuleStatsOutProOctets=slapmPolicyRuleStatsOutProOctets, slapmPolicyStatsOutPackets=slapmPolicyStatsOutPackets, slapmPolicyStatsMinRate=slapmPolicyStatsMinRate, slapmPolicyMonitorMaxRateLow=slapmPolicyMonitorMaxRateLow, slapmSubcomponentTcpInBufferedOctets=slapmSubcomponentTcpInBufferedOctets, slapmPolicyStatsOperStatus=slapmPolicyStatsOperStatus, slapmPRMonMaxOutRateExceeds=slapmPRMonMaxOutRateExceeds, slapmPRMonMinRateLow=slapmPRMonMinRateLow, slapmSubcomponentRemAddress=slapmSubcomponentRemAddress, slapmBaseObjects=slapmBaseObjects, slapmPolicyMonitorMaxDelayHigh=slapmPolicyMonitorMaxDelayHigh, slapmSubcomponentLocalAddress=slapmSubcomponentLocalAddress, slapmPRMonIndex=slapmPRMonIndex, slapmBaseGroup=slapmBaseGroup, slapmPolicyCountQueries=slapmPolicyCountQueries, slapmPolicyRuleStatsConnLimit=slapmPolicyRuleStatsConnLimit, slapmCompliance=slapmCompliance, slapmPolicyMonitorRowStatus=slapmPolicyMonitorRowStatus, slapmConformance=slapmConformance, slapmPolicyRuleStatsActRsvpFlows=slapmPolicyRuleStatsActRsvpFlows, slapmPolicyRuleMonDeleted=slapmPolicyRuleMonDeleted, slapmPolicyMonitorPolicyName=slapmPolicyMonitorPolicyName, slapmPolicyMonitorTable=slapmPolicyMonitorTable, slapmPRMonMinRateHigh=slapmPRMonMinRateHigh, slapmCompliances=slapmCompliances, slapmPolicyMonitorMinRateHigh=slapmPolicyMonitorMinRateHigh, slapmPolicyPurgeTime=slapmPolicyPurgeTime, slapmPRMonMaxRateHigh=slapmPRMonMaxRateHigh, slapmPRMonMaxDelayExceeds=slapmPRMonMaxDelayExceeds, slapmPolicyNameIndex=slapmPolicyNameIndex, slapmPolicyRuleStatsMinRate=slapmPolicyRuleStatsMinRate, slapmEndSystemGroup=slapmEndSystemGroup, slapmPRMonMaxDelayHigh=slapmPRMonMaxDelayHigh, slapmNotifications=slapmNotifications, slapmPolicyStatsCountDenies=slapmPolicyStatsCountDenies, slapmPolicyRuleStatsLActivated=slapmPolicyRuleStatsLActivated, slapmSubcMonitorNotOkay=slapmSubcMonitorNotOkay, slapmPolicyRuleStatsLastMapping=slapmPolicyRuleStatsLastMapping, slapmPRMonMinInRateNotAchieves=slapmPRMonMinInRateNotAchieves, slapmPolicyTrapFilter=slapmPolicyTrapFilter, slapmSubcomponentMonitorStatus=slapmSubcomponentMonitorStatus, slapmPolicyCountNotFounds=slapmPolicyCountNotFounds, slapmSubcomponentLastActivity=slapmSubcomponentLastActivity, slapmPolicyRuleStatsInOctets=slapmPolicyRuleStatsInOctets, slapmPolicyMonitorOwnerIndex=slapmPolicyMonitorOwnerIndex, slapmPRMonCurrentDelayRate=slapmPRMonCurrentDelayRate, slapmSubcomponentMonitorIntTime=slapmSubcomponentMonitorIntTime, slapmSubcomponentSystemAddress=slapmSubcomponentSystemAddress, slapmPolicyMonitorEntry=slapmPolicyMonitorEntry, slapmPolicyRuleMonOkay=slapmPolicyRuleMonOkay, slapmPolicyRuleStatsMaxDelay=slapmPolicyRuleStatsMaxDelay, slapmSubcomponentTable=slapmSubcomponentTable, slapmPRMonInterval=slapmPRMonInterval, SlapmStatus=SlapmStatus, PYSNMP_MODULE_ID=slapmMIB, slapmPolicyMonitorStatus=slapmPolicyMonitorStatus, slapmSubcomponentProtocol=slapmSubcomponentProtocol, slapmSubcomponentTcpOutBufferedOctets=slapmSubcomponentTcpOutBufferedOctets, slapmPRMonOwnerIndex=slapmPRMonOwnerIndex, slapmSubcomponentInOctets=slapmSubcomponentInOctets, slapmSpinLock=slapmSpinLock, slapmPolicyMonitorMinOutRateNotAchieves=slapmPolicyMonitorMinOutRateNotAchieves, slapmPolicyStatsSystemAddress=slapmPolicyStatsSystemAddress, slapmPolicyMonitorDeleted=slapmPolicyMonitorDeleted, slapmPolicyStatsInPackets=slapmPolicyStatsInPackets, slapmPolicyStatsInProfileOctets=slapmPolicyStatsInProfileOctets, slapmSubcomponentTcpRoundTripTime=slapmSubcomponentTcpRoundTripTime, slapmNotGroup=slapmNotGroup, slapmPolicyRuleStatsOutOctets=slapmPolicyRuleStatsOutOctets, slapmSubcomponentPolicyRuleIndex=slapmSubcomponentPolicyRuleIndex, slapmPRMonControl=slapmPRMonControl, slapmPolicyNameEntry=slapmPolicyNameEntry, slapmPRMonSystemAddress=slapmPRMonSystemAddress, slapmPolicyStatsEntry=slapmPolicyStatsEntry, SlapmNameType=SlapmNameType, slapmPolicyMonitorCurrentOutRate=slapmPolicyMonitorCurrentOutRate, slapmPolicyStatsTotalConns=slapmPolicyStatsTotalConns, slapmPolicyTrapEnable=slapmPolicyTrapEnable, SlapmPolicyRuleName=SlapmPolicyRuleName, slapmSubcomponentTcpReXmts=slapmSubcomponentTcpReXmts, slapmPolicyRuleStatsEntry=slapmPolicyRuleStatsEntry, slapmPolicyStatsConnectionLimit=slapmPolicyStatsConnectionLimit, slapmPRMonStatus=slapmPRMonStatus, slapmPolicyNameOfRule=slapmPolicyNameOfRule, slapmPolicyMonitorSystemAddress=slapmPolicyMonitorSystemAddress, slapmTableObjects=slapmTableObjects, slapmGroups=slapmGroups, slapmPolicyStatsMaxRate=slapmPolicyStatsMaxRate, slapmPolicyRuleStatsOutPackets=slapmPolicyRuleStatsOutPackets, slapmMonitoredEventNotAchieved=slapmMonitoredEventNotAchieved, slapmPolicyNameSystemAddress=slapmPolicyNameSystemAddress, slapmSubcMonitorOkay=slapmSubcMonitorOkay, slapmPolicyRuleStatsInProOctets=slapmPolicyRuleStatsInProOctets, slapmPolicyMonitorInterval=slapmPolicyMonitorInterval, slapmPolicyProfileDeleted=slapmPolicyProfileDeleted, slapmSubcomponentMonitoredEventNotAchieved=slapmSubcomponentMonitoredEventNotAchieved, slapmSubcomponentEntry=slapmSubcomponentEntry, slapmPolicyRuleStatsMaxRate=slapmPolicyRuleStatsMaxRate, slapmPolicyCountSuccessAccesses=slapmPolicyCountSuccessAccesses, slapmPRMonEntry=slapmPRMonEntry, slapmPolicyStatsMaxDelay=slapmPolicyStatsMaxDelay, slapmSubcomponentMonitorCurrentOutRate=slapmSubcomponentMonitorCurrentOutRate, slapmPRMonMaxInRateExceeds=slapmPRMonMaxInRateExceeds, slapmPolicyRuleStatsOutDiscards=slapmPolicyRuleStatsOutDiscards, slapmPolicyMonitorMaxDelayLow=slapmPolicyMonitorMaxDelayLow, slapmNotGroup2=slapmNotGroup2)

#
# PySNMP MIB module ENDRUNTECHNOLOGIES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ENDRUNTECHNOLOGIES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:02:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, ObjectIdentity, TimeTicks, IpAddress, ModuleIdentity, iso, Counter32, Unsigned32, MibIdentifier, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, enterprises, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "TimeTicks", "IpAddress", "ModuleIdentity", "iso", "Counter32", "Unsigned32", "MibIdentifier", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "enterprises", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
endRunTechnologiesMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 13827))
endRunTechnologies = ModuleIdentity((1, 3, 6, 1, 4, 1, 13827, 0))
if mibBuilder.loadTexts: endRunTechnologies.setLastUpdated('0208190000Z')
if mibBuilder.loadTexts: endRunTechnologies.setOrganization('EndRun Technologies LLC')
if mibBuilder.loadTexts: endRunTechnologies.setContactInfo('Technical Support 1-877-749-3878 snmpsupport@endruntechnologies.com')
if mibBuilder.loadTexts: endRunTechnologies.setDescription('EndRun Technologies Enterprise MIB')
praecisCntp = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 1))
cntp = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 1, 0))
cntptrap = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 1, 0, 0))
cdma = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 1, 1))
cdmatrap = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 1, 1, 0))
cntpTrapLeapIndBitsChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 1, 0, 0, 1)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "cntpLeapIndBits"))
if mibBuilder.loadTexts: cntpTrapLeapIndBitsChange.setStatus('current')
if mibBuilder.loadTexts: cntpTrapLeapIndBitsChange.setDescription('A cntpTrapNTPLeapIndBitsChange trap signifies that the value of the leap indicator bits contained in the NTP reply packets sent by the time server has changed. The current value of these bits is contained in the included cntpLeapIndBits. The decimal value of these bits ranges from 0 to 3: 0 is the no fault, no leap warning condition 1 is the no fault, leap second insertion warning condition 2 is the no fault, leap second deletion warning condition 3 is the unsynchronized, alarm condition')
cntpTrapStratumChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 1, 0, 0, 2)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "cntpStratum"))
if mibBuilder.loadTexts: cntpTrapStratumChange.setStatus('current')
if mibBuilder.loadTexts: cntpTrapStratumChange.setDescription('A cntpTrapStratumChange trap signifies that the value of the stratum field contained in the NTP reply packets sent by the time server has changed. The current value is contained in the included variable, cntpStratum. The decimal value of this field ranges from 1 to 16: 1 is the synchronized, actively locked to the reference UTC source stratum 11 is the synchronized, but flywheeling on the local real time clock stratum 16 is the unsynchronized stratum level')
cntpRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpRxPkts.setStatus('current')
if mibBuilder.loadTexts: cntpRxPkts.setDescription('Total number of NTP request packets received by the NTP daemon.')
cntpTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpTxPkts.setStatus('current')
if mibBuilder.loadTexts: cntpTxPkts.setDescription('Total number of NTP reply packets transmitted by the NTP daemon.')
cntpIgnoredPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpIgnoredPkts.setStatus('current')
if mibBuilder.loadTexts: cntpIgnoredPkts.setDescription('Total number of NTP request packets ignored by the NTP daemon.')
cntpDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpDroppedPkts.setStatus('current')
if mibBuilder.loadTexts: cntpDroppedPkts.setDescription('Total number of NTP request packets dropped by the NTP daemon.')
cntpAuthFail = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpAuthFail.setStatus('current')
if mibBuilder.loadTexts: cntpAuthFail.setDescription('Total number of authentication failures detected by the NTP daemon.')
cntpTimeFigureOfMerit = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 7, 8, 9))).clone(namedValues=NamedValues(("lessthan100us", 6), ("lessthan1ms", 7), ("lessthan10ms", 8), ("greaterthan10ms", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpTimeFigureOfMerit.setStatus('current')
if mibBuilder.loadTexts: cntpTimeFigureOfMerit.setDescription('The Time Figure of Merit (TFOM) value ranges from 4 to 9 and indicates the current estimate of the worst case time error. It is a logarithmic scale, with each increment indicating a tenfold increase in the worst case time error boundaries. The scale is referenced to a worst case time error of 100 picoseconds, equivalent to a TFOM of zero. During normal locked operation with CDMA the TFOM is 6 and implies a worst case time error of 100 microseconds. During periods of signal loss, the CDMA sub-system will compute an extrapolated worst case time error. One hour after the worst case time error has reached the value equivalent to a TFOM of 9, the NTP server will cease to send stratum 1 reply packets and an Alarm LED will be energized.')
cntpLeapIndBits = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noFaultorLeap", 0), ("leapInsWarning", 1), ("leapDelWarning", 2), ("unSynchronized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpLeapIndBits.setStatus('current')
if mibBuilder.loadTexts: cntpLeapIndBits.setDescription('This is a status code indicating: normal operation, a leap second to be inserted in the last minute of the current day, a leap second to be deleted in the last second of the day or an alarm condition indicating loss of timing synchronization. The leap indicator field of NTP reply packets sent from this server is set to cntpLeapIndBits.')
cntpSyncSource = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpSyncSource.setStatus('current')
if mibBuilder.loadTexts: cntpSyncSource.setDescription('This is an ASCII string identifying the synchronization source for this NTP server. It is one of CDMA, CPU or NONE. If it is NONE, then the server is not synchronized, has its Leap Indicator Bits in the Alarm state and is running at Stratum 16. If it is CPU, then the server is free running on its NTP disciplined CPU clock at Stratum 11. Check the Stratum, Leap Indicator Bits and Time Figure of Merit for further information. NTP reply packets from this server will have the reference identifier field set to cntpSyncSource if it is CDMA. Otherwise it will be set to either 127.127.1.0 (CPU) or 0.0.0.0 (NONE).')
cntpOffsetToCDMAReference = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpOffsetToCDMAReference.setStatus('current')
if mibBuilder.loadTexts: cntpOffsetToCDMAReference.setDescription('This is an ASCII string containing the floating value of the current offset in units of seconds of the NTP server CPU clock to the CDMA reference time. Positive values imply that the NTP server clock is ahead of the CDMA reference time.')
cntpStratum = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 11, 16))).clone(namedValues=NamedValues(("cntpStratumOne", 1), ("cntpStratumFlywheeling", 11), ("cntpStratumUnsync", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpStratum.setStatus('current')
if mibBuilder.loadTexts: cntpStratum.setDescription('This is an integer showing the current stratum level being reported by the NTP daemon in its reply packets to clients. If it is 1, then the server is fully synchronized and delivering Stratum 1 accuracy. If it is 16, then the server is unambiguously unsynchronized. If it is 11, and the previous stratum value was 1, then the server is flywheeling on the local CPU clock. However, if the previous stratum value was 16, then the server has synchronized to its CPU Real Time Clock. NTP clients on the network should be configured to not use the time from this server if the stratum is not 1.')
cntpVersion = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 0, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntpVersion.setStatus('current')
if mibBuilder.loadTexts: cntpVersion.setDescription('This is an ASCII string showing the NTP server firmware version.')
cdmaTrapFaultStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 1, 1, 0, 1)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "cdmaFaultStatus"))
if mibBuilder.loadTexts: cdmaTrapFaultStatusChange.setStatus('current')
if mibBuilder.loadTexts: cdmaTrapFaultStatusChange.setDescription('A cdmaTrapFaultStatusChange trap signifies that the value of the fault status word reported by the CDMA sub-system has changed. The current value is contained in the included cdmaFaultStatus.')
cdmaFaultStatus = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 1), Bits().clone(namedValues=NamedValues(("cdmaNotUsed", 0), ("cdmaNTPNotPolling", 1), ("cdmaLOFailure", 2), ("cdmaLOPLLFlt", 3), ("cdmaFLASHWriteFlt", 4), ("cdmaFPGACfgFlt", 5), ("cdmaNoSignalTimeout", 6), ("cdmaDACNearLimit", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaFaultStatus.setStatus('current')
if mibBuilder.loadTexts: cdmaFaultStatus.setDescription("This is a bit string contained in one character representing the least significant two nibbles of the CDMA fault status word. Unfortunately, SNMP numbers the bits in the reverse order, so that the enumerated values are backwards from the description contained in the User's Manual for the fault status field returned by the cdmastat command. Each bit indicates a fault when set. Currently defined fault states encoded in this value: Bit 7: DAC controlling the TCXO is near the high or low limit. Bit 6: Time Figure of Merit has been 9 (unsynchronized) for 1 hour. Bit 5: Field Programmable Gate Array (FPGA) did not configure properly. Bit 4: FLASH memory had a write fault. Bit 3: Local Oscillator PLL fault. Bit 2: Local Oscillator PLL failed. Bit 1: NTP daemon is not polling the CDMA reference clock. Bit 0: Not Used.")
cdmaTimeFigureOfMerit = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 7, 8, 9))).clone(namedValues=NamedValues(("lessthan100us", 6), ("lessthan1ms", 7), ("lessthan10ms", 8), ("greaterthan10ms", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaTimeFigureOfMerit.setStatus('current')
if mibBuilder.loadTexts: cdmaTimeFigureOfMerit.setDescription('The Time Figure of Merit (TFOM) value ranges from 6 to 9 and indicates the current estimate of the worst case time error. It is a logarithmic scale, with each increment indicating a tenfold increase in the worst case time error boundaries. The scale is referenced to a worst case time error of 100 picoseconds, equivalent to a TFOM of zero. During normal locked operation the TFOM is 6 and implies a worst case time error of 100 microseconds. During periods of signal loss, the CDMA sub-system will compute an extrapolated worst case time error. One hour after the worst case time error has reached the value equivalent to a TFOM of 9, the NTP server will cease to send stratum 1 reply packets and an Alarm LED will be energized.')
cdmaSigProcState = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 8))).clone(namedValues=NamedValues(("cdmaAcquiring", 0), ("cdmaDetected", 1), ("cdmaCodeLocking", 2), ("cdmaCarrierLocking", 4), ("cdmaLocked", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaSigProcState.setStatus('current')
if mibBuilder.loadTexts: cdmaSigProcState.setDescription('Current CDMA signal processor state. One of 0, 1, 2, 4 or 8, with 0 indicating the acquisition state and 8 the fully locked on state.')
cdmaChannel = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("priAbandclass0subclass0", 0), ("priBbandclass0subclass0", 1), ("secAbandclass0subclass0", 2), ("secBbandclass0subclass0", 3), ("priAbandclass0subclass1", 4), ("priBbandclass0subclass1", 5), ("secAbandclass0subclass1", 6), ("secBbandclass0subclass1", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaChannel.setStatus('current')
if mibBuilder.loadTexts: cdmaChannel.setDescription('Current CDMA frequency band and channel being used. Channels 0-3 are the North American cellular channels. Channels 4-7 are the South Korean cellular channels.')
cdmaPNO = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaPNO.setStatus('current')
if mibBuilder.loadTexts: cdmaPNO.setDescription('Current Pseudo Noise Offset of the base station being tracked. The value ranges from 0 to 511 and is in units of 64 Pseudo Noise Code chips. This offset serves as a base station identifier that is analogous to the Pseudo Random Noise (PRN) codes used by the individual satellites in the GPS system.')
cdmaAGC = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaAGC.setStatus('current')
if mibBuilder.loadTexts: cdmaAGC.setDescription('Current 8 bit, Automatic Gain Control (AGC) DAC value. Typical values are around 200, but proximity to the base station, type of building construction and orientation within the building have a strong influence on this value. More positive values have the effect of increasing the RF gain.')
cdmaVCDAC = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaVCDAC.setStatus('current')
if mibBuilder.loadTexts: cdmaVCDAC.setDescription('Current 16 bit, Voltage Controlled TCXO DAC value. Typical range is 20000 to 40000, where more positive numbers have the effect of raising the TCXO frequency.')
cdmaCarrierToNoiseRatio = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaCarrierToNoiseRatio.setStatus('current')
if mibBuilder.loadTexts: cdmaCarrierToNoiseRatio.setDescription('ASCII string representing the current received CDMA signal carrier-to-noise ratio, a unitless quantity. Numbers less than 2.5 indicate a very weak signal condition.')
cdmaFrameErrorRate = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaFrameErrorRate.setStatus('current')
if mibBuilder.loadTexts: cdmaFrameErrorRate.setDescription('ASCII string representing the current sync channel message error rate, a number ranging from 0.000 to 1.000. It indicates the proportion of messages received that fail the Cyclical Redundancy Check.')
cdmaLeapMode = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaLeapMode.setStatus('current')
if mibBuilder.loadTexts: cdmaLeapMode.setDescription('ASCII string showing the current leap second mode of operation for the CDMA sub-system. It is either AUTO or USER. If the mode is USER, then the current and future values of the UTC to GPS leap second offset is also included.')
cdmaCurrentLeapSeconds = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaCurrentLeapSeconds.setStatus('current')
if mibBuilder.loadTexts: cdmaCurrentLeapSeconds.setDescription('This value is the current difference in seconds between GPS time and UTC time. GPS time is ahead of UTC time by this amount.')
cdmaFutureLeapSeconds = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaFutureLeapSeconds.setStatus('current')
if mibBuilder.loadTexts: cdmaFutureLeapSeconds.setDescription('This value is the future difference in seconds between GPS time and UTC time. Leap seconds may be inserted or deleted from the UTC timescale twice during the year: Dec 31 and June 30 at UTC midnight. If this value is the same as cdmaCurrentLeapSeconds, then no leap second insertion or deletion will occur at the next possible time. If it is different, then the change will take affect at the next possible time. GPS time will be ahead of UTC time by this amount.')
cdmaVersion = MibScalar((1, 3, 6, 1, 4, 1, 13827, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdmaVersion.setStatus('current')
if mibBuilder.loadTexts: cdmaVersion.setDescription('ASCII string showing the CDMA sub-system firmware and FPGA versions.')
praecisGntp = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 2))
gntp = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 2, 0))
gntptrap = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 2, 0, 0))
gps = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 2, 1))
gpstrap = MibIdentifier((1, 3, 6, 1, 4, 1, 13827, 2, 1, 0))
gntpTrapLeapIndBitsChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 2, 0, 0, 1)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "gntpLeapIndBits"))
if mibBuilder.loadTexts: gntpTrapLeapIndBitsChange.setStatus('current')
if mibBuilder.loadTexts: gntpTrapLeapIndBitsChange.setDescription('A gntpTrapNTPLeapIndBitsChange trap signifies that the value of the leap indicator bits contained in the NTP reply packets sent by the time server has changed. The current value of these bits is contained in the included gntpLeapIndBits. The decimal value of these bits ranges from 0 to 3: 0 is the no fault, no leap warning condition 1 is the no fault, leap second insertion warning condition 2 is the no fault, leap second deletion warning condition 3 is the unsynchronized, alarm condition')
gntpTrapStratumChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 2, 0, 0, 2)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "gntpStratum"))
if mibBuilder.loadTexts: gntpTrapStratumChange.setStatus('current')
if mibBuilder.loadTexts: gntpTrapStratumChange.setDescription('A gntpTrapStratumChange trap signifies that the value of the stratum field contained in the NTP reply packets sent by the time server has changed. The current value is contained in the included variable, gntpStratum. The decimal value of this field ranges from 1 to 16: 1 is the synchronized, actively locked to the reference UTC source stratum 11 is the synchronized, but flywheeling on the local real time clock stratum 16 is the unsynchronized stratum level')
gntpRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpRxPkts.setStatus('current')
if mibBuilder.loadTexts: gntpRxPkts.setDescription('Total number of NTP request packets received by the NTP daemon.')
gntpTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpTxPkts.setStatus('current')
if mibBuilder.loadTexts: gntpTxPkts.setDescription('Total number of NTP reply packets transmitted by the NTP daemon.')
gntpIgnoredPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpIgnoredPkts.setStatus('current')
if mibBuilder.loadTexts: gntpIgnoredPkts.setDescription('Total number of NTP request packets ignored by the NTP daemon.')
gntpDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpDroppedPkts.setStatus('current')
if mibBuilder.loadTexts: gntpDroppedPkts.setDescription('Total number of NTP request packets dropped by the NTP daemon.')
gntpAuthFail = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpAuthFail.setStatus('current')
if mibBuilder.loadTexts: gntpAuthFail.setDescription('Total number of authentication failures detected by the NTP daemon.')
gntpTimeFigureOfMerit = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("lessthan1us", 4), ("lessthan10us", 5), ("lessthan100us", 6), ("lessthan1ms", 7), ("lessthan10ms", 8), ("greaterthan10ms", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpTimeFigureOfMerit.setStatus('current')
if mibBuilder.loadTexts: gntpTimeFigureOfMerit.setDescription('The Time Figure of Merit (TFOM) value ranges from 4 to 9 and indicates the current estimate of the worst case time error. It is a logarithmic scale, with each increment indicating a tenfold increase in the worst case time error boundaries. The scale is referenced to a worst case time error of 100 picoseconds, equivalent to a TFOM of zero. During normal locked operation with GPS the TFOM is 4 and implies a worst case time error of 1 microsecond. During periods of signal loss, the GPS sub-system will compute an extrapolated worst case time error. One hour after the worst case time error has reached the value equivalent to a TFOM of 9, the NTP server will cease to send stratum 1 reply packets and an Alarm LED will be energized.')
gntpLeapIndBits = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noFaultorLeap", 0), ("leapInsWarning", 1), ("leapDelWarning", 2), ("unSynchronized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpLeapIndBits.setStatus('current')
if mibBuilder.loadTexts: gntpLeapIndBits.setDescription('This is a status code indicating: normal operation, a leap second to be inserted in the last minute of the current day, a leap second to be deleted in the last second of the day or an alarm condition indicating loss of timing synchronization. The leap indicator field of NTP reply packets sent from this server is set to gntpLeapIndBits.')
gntpSyncSource = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpSyncSource.setStatus('current')
if mibBuilder.loadTexts: gntpSyncSource.setDescription('This is an ASCII string identifying the synchronization source for this NTP server. It is one of GPS, CPU or NONE. If it is NONE, then the server is not synchronized, has its Leap Indicator Bits in the Alarm state and is running at Stratum 16. If it is CPU, then the server is running on its NTP disciplined CPU clock at Stratum 11. Check the Stratum, Leap Indicator Bits and Time Figure of Merit for further information. NTP reply packets from this server will have the reference identifier field set to gntpSyncSource if it is GPS. Otherwise it will be set to either 127.127.1.0 (CPU) or 0.0.0.0 (NONE).')
gntpOffsetToGPSReference = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpOffsetToGPSReference.setStatus('current')
if mibBuilder.loadTexts: gntpOffsetToGPSReference.setDescription('This is an ASCII string containing the floating value of the current offset in units of seconds of the NTP server CPU clock to the GPS reference time. Positive values imply that the NTP server clock is ahead of the GPS reference time.')
gntpStratum = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 11, 16))).clone(namedValues=NamedValues(("gntpStratumOne", 1), ("gntpStratumFlywheeling", 11), ("gntpStratumUnsync", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpStratum.setStatus('current')
if mibBuilder.loadTexts: gntpStratum.setDescription('This is an integer showing the current stratum level being reported by the NTP daemon in its reply packets to clients. If it is 1, then the server is fully synchronized and delivering Stratum 1 accuracy. If it is 16, then the server is unambiguously unsynchronized. If it is 11, and the previous stratum value was 1, then the server is flywheeling on the local CPU clock. However, if the previous stratum value was 16, then the server has synchronized to its CPU Real Time Clock. NTP clients on the network should be configured to not use the time from this server if the stratum is not 1.')
gntpVersion = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 0, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gntpVersion.setStatus('current')
if mibBuilder.loadTexts: gntpVersion.setDescription('This is an ASCII string showing the NTP server firmware version.')
gpsTrapFaultStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 13827, 2, 1, 0, 1)).setObjects(("ENDRUNTECHNOLOGIES-MIB", "gpsFaultStatus"))
if mibBuilder.loadTexts: gpsTrapFaultStatusChange.setStatus('current')
if mibBuilder.loadTexts: gpsTrapFaultStatusChange.setDescription('A gpsTrapFaultStatusChange trap signifies that the value of the fault status word reported by the GPS sub-system has changed. The current value is contained in the included gpsFaultStatus.')
gpsFaultStatus = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 1), Bits().clone(namedValues=NamedValues(("gpsAntennaFlt", 0), ("gpsNTPNotPolling", 1), ("gpsnotused0", 2), ("gpsnotused1", 3), ("gpsFLASHWriteFlt", 4), ("gpsFPGACfgFlt", 5), ("gpsNoSignalTimeout", 6), ("gpsDACNearLimit", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsFaultStatus.setStatus('current')
if mibBuilder.loadTexts: gpsFaultStatus.setDescription("This is a bit string contained in one character representing the least significant two nibbles of the GPS fault status word. Unfortunately, SNMP numbers the bits in the reverse order, so that the enumerated values are backwards from the description contained in the User's Manual for the fault status field returned by the gpsstat command. Each bit indicates a fault when set. Currently defined fault states encoded in this value: Bit 7: DAC controlling the TCXO is near the high or low limit. Bit 6: Time Figure of Merit has been 9 (unsynchronized) for 1 hour. Bit 5: Field Programmable Gate Array (FPGA) did not configure properly. Bit 4: FLASH memory had a write fault. Bit 3: Not Used. Bit 2: Not Used. Bit 1: NTP daemon is not polling the GPS reference clock. Bit 0: GPS antenna or feedline is shorted or open.")
gpsTimeFigureOfMerit = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("lessthan1us", 4), ("lessthan10us", 5), ("lessthan100us", 6), ("lessthan1ms", 7), ("lessthan10ms", 8), ("greaterthan10ms", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsTimeFigureOfMerit.setStatus('current')
if mibBuilder.loadTexts: gpsTimeFigureOfMerit.setDescription('The Time Figure of Merit (TFOM) value ranges from 4 to 9 and indicates the current estimate of the worst case time error. It is a logarithmic scale, with each increment indicating a tenfold increase in the worst case time error boundaries. The scale is referenced to a worst case time error of 100 picoseconds, equivalent to a TFOM of zero. During normal locked operation the TFOM is 4 and implies a worst case time error of 1 microsecond. During periods of signal loss, the GPS sub-system will compute an extrapolated worst case time error. One hour after the worst case time error has reached the value equivalent to a TFOM of 9, the NTP server will cease to send stratum 1 reply packets and an Alarm LED will be energized.')
gpsSigProcState = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("gpsAcquiring", 0), ("gpsLocking", 1), ("gpsLocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsSigProcState.setStatus('current')
if mibBuilder.loadTexts: gpsSigProcState.setDescription('Current GPS signal processor state. One of 0, 1 or 2, with 0 being the acquisition state and 2 the fully locked on state.')
gpsNumTrackSats = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsNumTrackSats.setStatus('current')
if mibBuilder.loadTexts: gpsNumTrackSats.setDescription('Current number of GPS satellites being tracked.')
gpsVCDAC = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsVCDAC.setStatus('current')
if mibBuilder.loadTexts: gpsVCDAC.setDescription('Current 16 bit, Voltage Controlled TCXO DAC value. Typical range is 20000 to 40000, where more positive numbers have the effect of raising the TCXO frequency.')
gpsAvgCarrierToNoiseRatiodB = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsAvgCarrierToNoiseRatiodB.setStatus('current')
if mibBuilder.loadTexts: gpsAvgCarrierToNoiseRatiodB.setDescription('ASCII string representing the current average carrier to noise ratio of all tracked satellites, in units of dB. Values less than 35 indicate weak signal conditions.')
gpsReferencePosition = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsReferencePosition.setStatus('current')
if mibBuilder.loadTexts: gpsReferencePosition.setDescription('WGS-84 latitude, longitude and height above the reference ellipsoid of the GPS antenna. Ellipsoid height may deviate from local Mean Sea Level by as much as 100 meters.')
gpsRefPosSource = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsRefPosSource.setStatus('current')
if mibBuilder.loadTexts: gpsRefPosSource.setDescription('ASCII string indicating the source of the GPS antenna reference position. It is one of: USR (user supplied), AVG (automatically determined by averaging thousands of 3-D position fixes, UNK (unknown).')
gpsCurrentLeapSeconds = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsCurrentLeapSeconds.setStatus('current')
if mibBuilder.loadTexts: gpsCurrentLeapSeconds.setDescription('This value is the current difference in seconds between GPS time and UTC time. GPS time is ahead of UTC time by this amount.')
gpsFutureLeapSeconds = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsFutureLeapSeconds.setStatus('current')
if mibBuilder.loadTexts: gpsFutureLeapSeconds.setDescription('This value is the future difference in seconds between GPS time and UTC time. Leap seconds may be inserted or deleted from the UTC timescale twice during the year: Dec 31 and June 30 at UTC midnight. If this value is the same as cdmaCurrentLeapSeconds, then no leap second insertion or deletion will occur at the next possible time. If it is different, then the change will take affect at the next possible time. GPS time will be ahead of UTC time by this amount.')
gpsVersion = MibScalar((1, 3, 6, 1, 4, 1, 13827, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsVersion.setStatus('current')
if mibBuilder.loadTexts: gpsVersion.setDescription('ASCII string showing the GPS sub-system firmware and FPGA versions.')
mibBuilder.exportSymbols("ENDRUNTECHNOLOGIES-MIB", cntptrap=cntptrap, cntpDroppedPkts=cntpDroppedPkts, cdmaSigProcState=cdmaSigProcState, cdmaAGC=cdmaAGC, cdmaFutureLeapSeconds=cdmaFutureLeapSeconds, cntpAuthFail=cntpAuthFail, cdmaCurrentLeapSeconds=cdmaCurrentLeapSeconds, gntpIgnoredPkts=gntpIgnoredPkts, cdmaFaultStatus=cdmaFaultStatus, gpsAvgCarrierToNoiseRatiodB=gpsAvgCarrierToNoiseRatiodB, cdmaTimeFigureOfMerit=cdmaTimeFigureOfMerit, gntpVersion=gntpVersion, cdmaTrapFaultStatusChange=cdmaTrapFaultStatusChange, gpsReferencePosition=gpsReferencePosition, gpsFaultStatus=gpsFaultStatus, cdmatrap=cdmatrap, gntp=gntp, cntpTimeFigureOfMerit=cntpTimeFigureOfMerit, cdmaCarrierToNoiseRatio=cdmaCarrierToNoiseRatio, cdmaFrameErrorRate=cdmaFrameErrorRate, gntpTrapStratumChange=gntpTrapStratumChange, praecisGntp=praecisGntp, gntpLeapIndBits=gntpLeapIndBits, gntpRxPkts=gntpRxPkts, gntpTxPkts=gntpTxPkts, cdmaVCDAC=cdmaVCDAC, gntpOffsetToGPSReference=gntpOffsetToGPSReference, cntpIgnoredPkts=cntpIgnoredPkts, gntpTrapLeapIndBitsChange=gntpTrapLeapIndBitsChange, gntpDroppedPkts=gntpDroppedPkts, cntpStratum=cntpStratum, gntpStratum=gntpStratum, cntpOffsetToCDMAReference=cntpOffsetToCDMAReference, gpsSigProcState=gpsSigProcState, cdmaLeapMode=cdmaLeapMode, gpsRefPosSource=gpsRefPosSource, gntpSyncSource=gntpSyncSource, gpsVCDAC=gpsVCDAC, gpsNumTrackSats=gpsNumTrackSats, cntpTrapLeapIndBitsChange=cntpTrapLeapIndBitsChange, endRunTechnologiesMIB=endRunTechnologiesMIB, cdmaPNO=cdmaPNO, endRunTechnologies=endRunTechnologies, gntpAuthFail=gntpAuthFail, cntpSyncSource=cntpSyncSource, gpsCurrentLeapSeconds=gpsCurrentLeapSeconds, praecisCntp=praecisCntp, cntp=cntp, cntpRxPkts=cntpRxPkts, gntptrap=gntptrap, gpstrap=gpstrap, cdma=cdma, cntpVersion=cntpVersion, cntpTxPkts=cntpTxPkts, cntpLeapIndBits=cntpLeapIndBits, cdmaChannel=cdmaChannel, cdmaVersion=cdmaVersion, gpsTrapFaultStatusChange=gpsTrapFaultStatusChange, gpsFutureLeapSeconds=gpsFutureLeapSeconds, gntpTimeFigureOfMerit=gntpTimeFigureOfMerit, cntpTrapStratumChange=cntpTrapStratumChange, PYSNMP_MODULE_ID=endRunTechnologies, gps=gps, gpsVersion=gpsVersion, gpsTimeFigureOfMerit=gpsTimeFigureOfMerit)

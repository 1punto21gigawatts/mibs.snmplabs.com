#
# PySNMP MIB module AT-GS950-16-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AT-GS950-16-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:30:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressPrefixLength, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddressType", "InetAddress")
lldpXdot1RemProtoVlanSupported, lldpXdot1RemProtocolId, lldpXdot1RemPortVlanId, lldpXdot1RemVlanName = mibBuilder.importSymbols("LLDP-EXT-DOT1-MIB", "lldpXdot1RemProtoVlanSupported", "lldpXdot1RemProtocolId", "lldpXdot1RemPortVlanId", "lldpXdot1RemVlanName")
lldpXdot3RemPortOperMauType, lldpXdot3RemPowerClass, lldpXdot3RemLinkAggStatus, lldpXdot3RemMaxFrameSize = mibBuilder.importSymbols("LLDP-EXT-DOT3-MIB", "lldpXdot3RemPortOperMauType", "lldpXdot3RemPowerClass", "lldpXdot3RemLinkAggStatus", "lldpXdot3RemMaxFrameSize")
lldpStatsRemTablesAgeouts, lldpRemManAddr, lldpLocPortNum, lldpLocPortId, lldpRemPortId, lldpRemSysName, lldpStatsRemTablesDrops, lldpStatsRemTablesInserts, lldpRemChassisId, lldpStatsRemTablesDeletes = mibBuilder.importSymbols("LLDP-MIB", "lldpStatsRemTablesAgeouts", "lldpRemManAddr", "lldpLocPortNum", "lldpLocPortId", "lldpRemPortId", "lldpRemSysName", "lldpStatsRemTablesDrops", "lldpStatsRemTablesInserts", "lldpRemChassisId", "lldpStatsRemTablesDeletes")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
ZeroBasedCounter32, TimeFilter = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32", "TimeFilter")
SnmpEngineID, SnmpSecurityLevel, SnmpSecurityModel, SnmpAdminString = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpEngineID", "SnmpSecurityLevel", "SnmpSecurityModel", "SnmpAdminString")
snmpTargetParamsName, SnmpTagValue = mibBuilder.importSymbols("SNMP-TARGET-MIB", "snmpTargetParamsName", "SnmpTagValue")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
enterprises, ModuleIdentity, Integer32, iso, Gauge32, ObjectIdentity, NotificationType, Bits, Unsigned32, Counter32, TimeTicks, MibIdentifier, Counter64, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "ModuleIdentity", "Integer32", "iso", "Gauge32", "ObjectIdentity", "NotificationType", "Bits", "Unsigned32", "Counter32", "TimeTicks", "MibIdentifier", "Counter64", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress")
TimeStamp, TruthValue, RowStatus, DisplayString, MacAddress, TextualConvention, PhysAddress, AutonomousType, TAddress, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TruthValue", "RowStatus", "DisplayString", "MacAddress", "TextualConvention", "PhysAddress", "AutonomousType", "TAddress", "TimeInterval")
at_GS95016v3 = ModuleIdentity((1, 3, 6, 1, 4, 1, 207, 1, 4, 166)).setLabel("at-GS95016v3")
at_GS95016v3.setRevisions(('2012-02-06 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: at_GS95016v3.setRevisionsDescriptions(('No Description',))
if mibBuilder.loadTexts: at_GS95016v3.setLastUpdated('201202060000Z')
if mibBuilder.loadTexts: at_GS95016v3.setOrganization('Allied Telesis Inc.')
if mibBuilder.loadTexts: at_GS95016v3.setContactInfo('Allied Telesis Inc. Customer Service Postal: 19800 North Creek Parkway, Suite 100 Bothell, WA 98011 USA Email: support@alliedtelesis.com')
if mibBuilder.loadTexts: at_GS95016v3.setDescription('Private MIB for AT-GS950 Series Switches')
l2Snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1))
l2Radius = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25))
l2Cfa = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27))
l2Rmon = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44))
l2La = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63))
l2Pnac = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64))
l2System = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81))
l2Dfs = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83))
l2Syslog = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89))
l2Security = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95))
l2Ssl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96))
l2Ssh = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97))
l2Sntp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99))
l2Dscp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100))
l2Snoop = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105))
l2Bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116))
l2Mst = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118))
l2Rst = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119))
l2Vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120))
fslldp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158))
l2VoiceVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163))
trafficSeg = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 165))
atiAclMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166))
l2DhcpSnoop = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181))
dot1dPBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6))
dot1qQBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7))
class L2snmpLevel(TextualConvention, Integer32):
    description = ''
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("v1", 1), ("v2c", 2), ("noAuthNoPriv", 3), ("authNoPriv", 4), ("authPriv", 5))

sysSnmpUser = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1))
sysSnmpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2))
sysSnmpGroupAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3))
sysSnmpViewTree = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4))
sysSnmpCommunity = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5))
sysSnmpTrapManager = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6))
sysSnmpEngineID = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 7), SnmpEngineID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnmpEngineID.setStatus('current')
if mibBuilder.loadTexts: sysSnmpEngineID.setDescription("An SNMP engine's administratively-unique identifier. In a simple agent, this value is always that agent's own snmpEngineID value. The value can also take the value of the snmpEngineID of a remote SNMP engine with which this user can communicate.")
snmpGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGlobalState.setStatus('current')
if mibBuilder.loadTexts: snmpGlobalState.setDescription('This object is for enabling or disabling SNMP Community function.')
sysSnmpUserTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1), )
if mibBuilder.loadTexts: sysSnmpUserTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserTable.setDescription('')
sysSnmpUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpUserName"))
if mibBuilder.loadTexts: sysSnmpUserEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserEntry.setDescription('')
sysSnmpUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpUserName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserName.setDescription('A human readable string rsysresenting the name of the user. This is the (User-based Security) Model dependent security ID.')
sysSnmpUserAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1, 1, 2), AutonomousType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpUserAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserAuthProtocol.setDescription("An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be authenticated, and if so, the type of authentication protocol which is used. An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same concsystual row). If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned. The value will be overwritten/set when a set operation is performed on the corresponding instance of UserCloneFrom. Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the NoAuthProtocol. If a set operation tries to change the value of an existing instance of this object to any value other than NoAuthProtocol, then an 'inconsistentValue' error must be returned. If a set operation tries to set the value to the NoAuthProtocol while the UserPrivProtocol value in the same row is not equal to NoPrivProtocol, then an 'inconsistentValue' error must be returned. That means that an SNMP command generator application must first ensure that the UserPrivProtocol is set to the NoPrivProtocol value before it can set the UserAuthProtocol value to NoAuthProtocol.")
sysSnmpUserPrivProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1, 1, 3), AutonomousType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpUserPrivProtocol.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserPrivProtocol.setDescription("An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be protected from disclosure, and if so, the type of privacy protocol which is used. An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same concsystual row). If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned. The value will be overwritten/set when a set operation is performed on the corresponding instance of usmUserCloneFrom. Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the NoPrivProtocol. If a set operation tries to change the value of an existing instance of this object to any value other than NoPrivProtocol, then an 'inconsistentValue' error must be returned. Note that if any privacy protocol is used, then you must also use an authentication protocol. In other words, if usmUserPrivProtocol is set to anything else than NoPrivProtocol, then the corresponding instance of usmUserAuthProtocol cannot have a value of usmNoAuthProtocol. If it does, then an 'inconsistentValue' error must be returned.")
sysSnmpUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 1, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpUserStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpUserStatus.setDescription("The status of this concsystual row. Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the usmUserStatus column is 'notReady'. In particular, a newly created row for a user who employs authentication, cannot be made active until the corresponding usmUserCloneFrom and usmUserAuthKeyChange have been set. Further, a newly created row for a user who also employs privacy, cannot be made active until the usmUserPrivKeyChange has been set. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this concsystual row can be modified, excsyst for usmUserOwnAuthKeyChange and usmUserOwnPrivKeyChange. For these 2 objects, the value of usmUserStatus MUST be active.")
sysSnmpGroupTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1), )
if mibBuilder.loadTexts: sysSnmpGroupTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupTable.setDescription('')
sysSnmpGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpSecurityModel"), (0, "AT-GS950-16-MIB", "sysSnmpSecurityName"))
if mibBuilder.loadTexts: sysSnmpGroupEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupEntry.setDescription('')
sysSnmpSecurityModel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1, 1, 1), SnmpSecurityModel())
if mibBuilder.loadTexts: sysSnmpSecurityModel.setStatus('current')
if mibBuilder.loadTexts: sysSnmpSecurityModel.setDescription('A human readable string rsysresenting the name of the user. This is the (User-based Security) Model dsysendent security ID.')
sysSnmpSecurityName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpSecurityName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpSecurityName.setDescription('A human readable string rsysresenting the name of the user. This is the (User-based Security) Model dsysendent security ID.')
sysSnmpGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpGroupName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupName.setDescription('The name of the group to which this entry (e.g., the combination of securityModel and securityName) belongs. This groupName is used as index into the vacmAccessTable to select an access control policy. However, a value in this table does not imply that an instance with the value exists in table vacmAccesTable.')
sysSnmpGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 2, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpGroupStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupStatus.setDescription("The status of this concsystual row. Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the usmUserStatus column is 'notReady'. In particular, a newly created row for a user who employs authentication, cannot be made active until the corresponding usmUserCloneFrom and usmUserAuthKeyChange have been set. Further, a newly created row for a user who also employs privacy, cannot be made active until the usmUserPrivKeyChange has been set. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this concsystual row can be modified, excsyst for usmUserOwnAuthKeyChange and usmUserOwnPrivKeyChange. For these 2 objects, the value of usmUserStatus MUST be active.")
sysSnmpGroupAccessTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1), )
if mibBuilder.loadTexts: sysSnmpGroupAccessTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupAccessTable.setDescription('')
sysSnmpGroupAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpaccessGroupIndex"), (0, "AT-GS950-16-MIB", "sysSnmpaccessSecurityModel"), (0, "AT-GS950-16-MIB", "sysSnmpaccessSecurityLevel"))
if mibBuilder.loadTexts: sysSnmpGroupAccessEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpGroupAccessEntry.setDescription('')
sysSnmpaccessGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpaccessGroupIndex.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessGroupIndex.setDescription('The name of the group to which this entry (e.g., the combination of securityModel and securityName) belongs. This groupName is used as index into the vacmAccessTable to select an access control policy. However, a value in this table does not imply that an instance with the value exists in table vacmAccesTable.')
sysSnmpaccessSecurityModel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 2), SnmpSecurityModel())
if mibBuilder.loadTexts: sysSnmpaccessSecurityModel.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessSecurityModel.setDescription('In order to gain the access rights allowed by this concsystual row, this securityModel must be in use.')
sysSnmpaccessSecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 3), SnmpSecurityLevel())
if mibBuilder.loadTexts: sysSnmpaccessSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessSecurityLevel.setDescription('The minimum level of security required in order to gain the access rights allowed by this concsystual row. A securityLevel of noAuthNoPriv is less than authNoPriv which in turn is less than authPriv. If multiple entries are equally indexed excsyst for this vacmAccessSecurityLevel index, then the entry which has the highest value for vacmAccessSecurityLevel is selected.')
sysSnmpaccessReadViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpaccessReadViewName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessReadViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this concsystual row authorizes read access. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted.')
sysSnmpaccessWriteViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpaccessWriteViewName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessWriteViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this concsystual row authorizes write access. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted.')
sysSnmpaccessNotifyViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpaccessNotifyViewName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessNotifyViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this concsystual row authorizes access for notifications. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted.')
sysSnmpaccessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 3, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpaccessStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpaccessStatus.setDescription('The status of this concsystual row. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this concsystual row can be modified.')
sysSnmpViewTreeTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1), )
if mibBuilder.loadTexts: sysSnmpViewTreeTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpViewTreeTable.setDescription('')
sysSnmpViewTreeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpviewTreeName"), (0, "AT-GS950-16-MIB", "sysSnmpviewTreeSubtree"))
if mibBuilder.loadTexts: sysSnmpViewTreeEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpViewTreeEntry.setDescription('')
sysSnmpviewTreeName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpviewTreeName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpviewTreeName.setDescription('The human readable name for a family of view subtrees.')
sysSnmpviewTreeSubtree = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1, 2), ObjectIdentifier())
if mibBuilder.loadTexts: sysSnmpviewTreeSubtree.setStatus('current')
if mibBuilder.loadTexts: sysSnmpviewTreeSubtree.setDescription('The MIB subtree which when combined with the corresponding instance of vacmViewTreeFamilyMask defines a family of view subtrees.')
sysSnmpviewTreeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpviewTreeMask.setStatus('current')
if mibBuilder.loadTexts: sysSnmpviewTreeMask.setDescription("The bit mask which, in combination with the corresponding instance of vacmViewTreeFamilySubtree, defines a family of view subtrees. Each bit of this bit mask corresponds to a sub-identifier of vacmViewTreeFamilySubtree, with the most significant bit of the i-th octet of this octet string value (extended if necessary, see below) corresponding to the (8*i - 7)-th sub-identifier, and the least significant bit of the i-th octet of this octet string corresponding to the (8*i)-th sub-identifier, where i is in the range 1 through 16. Each bit of this bit mask specifies whether or not the corresponding sub-identifiers must match when determining if an OBJECT IDENTIFIER is in this family of view subtrees; a '1' indicates that an exact match must occur; a '0' indicates 'wild card', i.e., any sub-identifier value matches. Thus, the OBJECT IDENTIFIER X of an object instance is contained in a family of view subtrees if, for each sub-identifier of the value of vacmViewTreeFamilySubtree, either: the i-th bit of vacmViewTreeFamilyMask is 0, or the i-th sub-identifier of X is equal to the i-th sub-identifier of the value of vacmViewTreeFamilySubtree. If the value of this bit mask is M bits long and there are more than M sub-identifiers in the corresponding instance of vacmViewTreeFamilySubtree, then the bit mask is extended with 1's to be the required length. Note that when the value of this object is the zero-length string, this extension rule results in a mask of all-1's being used (i.e., no 'wild card'), and the family of view subtrees is the one view subtree uniquely identified by the corresponding instance of vacmViewTreeFamilySubtree. Note that masks of length greater than zero length do not need to be supported. In this case this object is made read-only.")
sysSnmpviewTreeType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpviewTreeType.setStatus('current')
if mibBuilder.loadTexts: sysSnmpviewTreeType.setDescription('Indicates whether the corresponding instances of vacmViewTreeFamilySubtree and vacmViewTreeFamilyMask define a family of view subtrees which is included in or excluded from the MIB view.')
sysSnmpviewTreeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 4, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpviewTreeStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpviewTreeStatus.setDescription('The status of this concsystual row. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this concsystual row can be modified.')
sysSnmpCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1), )
if mibBuilder.loadTexts: sysSnmpCommunityTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpCommunityTable.setDescription('')
sysSnmpCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpsnmpCommunityIndex"))
if mibBuilder.loadTexts: sysSnmpCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpCommunityEntry.setDescription('')
sysSnmpsnmpCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpsnmpCommunityIndex.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpCommunityIndex.setDescription('The unique index value of a row in this table.')
sysSnmpsnmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpCommunityName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpCommunityName.setDescription('The unique index value of a row in this table.')
sysSnmpsnmpCommunityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpCommunityPolicy.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpCommunityPolicy.setDescription('A human readable string rsysresenting the corresponding value of snmpCommunityName in a Security Model indsysendent format.')
sysSnmpsnmpCommunityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 5, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpCommunityStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpCommunityStatus.setDescription('The status of this concsystual row in the snmpCommunityTable. An entry in this table is not qualified for activation until instances of all corresponding columns have been initialized, either through default values, or through Set operations. The snmpCommunityName and snmpCommunitySecurityName objects must be explicitly set. There is no restriction on setting columns in this table when the value of snmpCommunityStatus is active(1).')
sysSnmpTrapManagerTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1), )
if mibBuilder.loadTexts: sysSnmpTrapManagerTable.setStatus('current')
if mibBuilder.loadTexts: sysSnmpTrapManagerTable.setDescription('')
sysSnmpTrapManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnmpsnmpTrapManagerName"))
if mibBuilder.loadTexts: sysSnmpTrapManagerEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnmpTrapManagerEntry.setDescription('')
sysSnmpsnmpTrapManagerName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerName.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerName.setDescription('The locally arbitrary, but unique identifier associated with this snmpNotifyEntry.')
sysSnmpsnmpTrapManagerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1, 1, 2), TAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerAddress.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerAddress.setDescription('This object contains a transport address. The format of this address dsysends on the value of the snmpTargetAddrTDomain object.')
sysSnmpsnmpTrapManagerSecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1, 1, 3), L2snmpLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerSecurityLevel.setDescription('The Level of Security to be used when generating SNMP messages using this entry.')
sysSnmpsnmpTrapManagerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 1, 6, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnmpsnmpTrapManagerStatus.setDescription('The status of this concsystual row in the SnmpTrapManagerTable. An entry in this table is not qualified for activation until instances of all corresponding columns have been initialized, either through default values, or through Set operations. The snmpTrapManagerName, snmpTrapManagerAddress and snmpTrapManagerSecurityLevel objects must be explicitly set. There is no restriction on setting columns in this table when the value of snmpTrapManagerStatus is active(1).')
sysRadiusExtClient = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1))
sysRadiusExtServerTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3), )
if mibBuilder.loadTexts: sysRadiusExtServerTable.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerTable.setDescription('The (concsystual) table listing the RADIUS servers with which the client shares a secret.')
sysRadiusExtServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysRadiusExtServerIndex"))
if mibBuilder.loadTexts: sysRadiusExtServerEntry.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerEntry.setDescription('An entry (concsystual row) rsysresenting a RADIUS server with which the client shares a secret.')
sysRadiusExtServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysRadiusExtServerIndex.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerIndex.setDescription('The RADIUS server with whom the client interacts.')
sysRadiusExtServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerAddress.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerAddress.setDescription('The IP address of the RADIUS server referred to in this table entry.')
sysRadiusExtServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerSharedSecret.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerSharedSecret.setDescription('The secret string which is shared between Server and Client')
sysRadiusExtServerResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerResponseTime.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerResponseTime.setDescription('The maximum time within which the server has to respond for a request from the client')
sysRadiusExtServerMaximumRetransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerMaximumRetransmission.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerMaximumRetransmission.setDescription('The allowed maximum no. of trials to be tried by a client to get response from the server for a request')
sysRadiusExtServerAuthPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerAuthPortNum.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerAuthPortNum.setDescription('The UDP port the client is using to send authentication requests to this server.')
sysRadiusExtServerEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysRadiusExtServerEntryStatus.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerEntryStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
sysRadiusExtServerAccPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 25, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRadiusExtServerAccPort.setStatus('current')
if mibBuilder.loadTexts: sysRadiusExtServerAccPort.setDescription('The UDP port the client is using to send accounting requests to this server.')
pysmi_if = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1)).setLabel("if")
traps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 4))
ifMaxInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMaxInterfaces.setStatus('deprecated')
if mibBuilder.loadTexts: ifMaxInterfaces.setDescription('Specifies the maximum number of interfaces that can be present in the system.')
ifMaxPhysInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 2), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMaxPhysInterfaces.setStatus('deprecated')
if mibBuilder.loadTexts: ifMaxPhysInterfaces.setDescription('Specifies the maximum number of physical interfaces that can be present in the system.')
ifAvailableIndex = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifAvailableIndex.setStatus('current')
if mibBuilder.loadTexts: ifAvailableIndex.setDescription('Shows an ifIndex which is available for creation of any new virtual (non-physical) interface in the system. This ifIndex value can be used for creation of interfaces in the ifMainTable or any media-specif MIB. For creation of physical interfaces, any free ifIndex between 1 and ifMaxPhysInterfaces can be used.')
ifMainTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4), )
if mibBuilder.loadTexts: ifMainTable.setStatus('current')
if mibBuilder.loadTexts: ifMainTable.setDescription('A list of all the interface entries in the system. This table contains objects which are applicable to all types of interfaces in the system. This table is a proprietary extension to the standard ifTable and ifXTable. The index to this table has the semantics of the MIB-2 ifIndex.')
ifMainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "ifMainIndex"))
if mibBuilder.loadTexts: ifMainEntry.setStatus('current')
if mibBuilder.loadTexts: ifMainEntry.setDescription('An entry containing management information applicable to a particular interface.')
ifMainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ifMainIndex.setStatus('current')
if mibBuilder.loadTexts: ifMainIndex.setDescription('A unique value, greater than zero, for each interface. This object is identical to the ifIndex of the standard MIB-2 ifTable.')
ifMainType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 9, 23, 24, 32, 38, 49, 84, 92, 108, 114, 118, 131, 134, 135, 136, 150, 161, 166))).clone(namedValues=NamedValues(("rfc877x25", 5), ("ethernetCsmacd", 6), ("iso88025TokenRing", 9), ("ppp", 23), ("softwareLoopback", 24), ("frameRelay", 32), ("miox25", 38), ("aal5", 49), ("async", 84), ("frameRelayMPI", 92), ("pppMultilinkBundle", 108), ("ipOverAtm", 114), ("hdlc", 118), ("tunnel", 131), ("atmSubInterface", 134), ("l2macvlan", 135), ("l3ipvlan", 136), ("mplsTunnel", 150), ("ieee8023ad", 161), ("mpls", 166)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifMainType.setStatus('current')
if mibBuilder.loadTexts: ifMainType.setDescription('The type/protocol of interface. Specification of the object is mandatory for all interfaces. This value should be specified after the row creation in the ifMainTable and before setting any other object in this table. Once the type is specified, it cannot be changed - the interface should be deleted for changing the type of the interface. The ethernetCsmacd(6), iso88025TokenRing(9), aal5(49), async(84) and hdlc(118) are physical interfaces while all other types are virtual or logical interfaces. For creation of physical interface types, it is mandatory to specify the handle to the device driver using the ifAlias object of the standard ifXTable before specifying the type. This handle could be something like eth1 or /dev/abcd.')
ifMainMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifMainMtu.setStatus('current')
if mibBuilder.loadTexts: ifMainMtu.setDescription('The MTU for the interface as shown to the higher interface sub-layer (this value should not include the encapsulation or header added by the interface). If IP is operating over the interface, then this value indicates the IP MTU over this interface. For changing the MTU of any interface, the interface must be brought down first - changing MTU while the interface is administratively up is not permitted. If not specified during interface creation, a default value is assigned based on the ifMainType given to the particular interface. While configuring for logical VLAN interfaces, care should be taken to, configure this value as the lowest of the MTU values of the member ports.')
ifMainAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifMainAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ifMainAdminStatus.setDescription("The desired state of the interface. This object can be set only when the ifMainRowStatus of the interface is active. This object has the semantics of the ifAdminStatus of the standard ifTable. The testing(3) state indicates that no operational packets can be passed - this state is not currently supported. When a managed system initializes, all interfaces start with ifMainAdminStatus in the down(2) state, it's a default state also. As a result of either explicit management action or per configuration information retained by the managed system, ifMainAdminStatus is then changed to the up (1) state (or remains in the down(2) state).")
ifMainOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMainOperStatus.setStatus('current')
if mibBuilder.loadTexts: ifMainOperStatus.setDescription('The current operational state of the interface. The testing (3) state indicates that no operational packets can be passed - this state is not supported currently. If ifMainAdminStatus is down (2) then ifMainOperStatus would be down (2). If ifMainAdminStatus is changed to up (1) then ifMainOperStatus should change to up (1) if the interface is ready to transmit and receive work traffic; it should change to dormant (5) the interface is waiting for external actions (such as a serial line waiting for an incoming connection); it should change to lowerLayerDown(7) state if it cannot be made up as the interface sub-layer below it is down; it should remain in the down (2) state if and only if there is a fault that prevents it from going to the up (1) state; it should remain in the notPresent (6) state if the interface has missing (typically, hardware) components. The status unknown(4) is shown when it is not possible to determine the exact status of the interface - e.g. the interface sub-layer is performing negotiations - during this period the interface is not up but at the same time, it is not a fault condition and hence it cannot be shown as down - in such periods the status is shown as unknown. This object has the semantics of the ifOperStatus of the standard ifTable.')
ifMainEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("nlpid", 2), ("nlpidSnap", 3), ("cudNlpid", 4), ("cudNlpidSnap", 5), ("llcSnap", 6), ("vcMultiplexed", 7), ("ethernetV2", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMainEncapType.setStatus('current')
if mibBuilder.loadTexts: ifMainEncapType.setDescription('The encapsulation type to be used over the interface. For Ethernet interfaces, the default encapsulation type is ethernetV2(8). The other possible encapsulation is llcSnap(6). If other(1) is specified then an automatic encapsulation type learning method is used in ARP for determining the encapsulation for unicast destinations while the multicast and broadcast destinations use ethernetV2(8). For PPP and MLPPP interfaces, the encapsulation type can only be other(1) and this is the default value. For FR VCs, the value can be nlpid(2) (for carrying protocols which have NLPID) or nlpidSnap(3) (for other protocols). The default is nlpid(2) and the types of protocols supported are inferred from the stack-layering implemented over the interface. For X.25 VCs, the value can be nlpid(2) or nlpidSnap(3) (where the VC can carry multiplexed protocol traffic with each data packet containing the NLPID or SNAP header) or cudNlpid(4) or cudNlpidSnap(5) (where the CUD specifies the NLPID of the protocol or SNAP and the data packets do not contain these headers - for dedicated VCs). The default is cudNlpid(4). For ATM VCs, the default is llcSnap(6) but the vcMultiplexed(7) encapsulation is also supported. This object is not applicable to other interfaces.')
ifMainBrgPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("providerNetworkPort", 1), ("customerNetworkPortPortBased", 2), ("customerNetworkPortStagged", 3), ("customerEdgePort", 4), ("propCustomerEdgePort", 5), ("propCustomerNetworkPort", 6), ("propProviderNetworkPort", 7), ("customerBridgePort", 8))).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMainBrgPortType.setStatus('current')
if mibBuilder.loadTexts: ifMainBrgPortType.setDescription('The Bridge port type of this specified externally accessible port. Bridge Port type can be specified only for switch ports and not for router ports. providerNetworkPort - Port Connected to a single Provider. SVLAN Classification is based on only the PVID configured for the port for untagged packets. customerNetworkPortPortBased - Port in the S-VLAN component that can transmit or received frames for single customer. All packets received on this port, are mapped to one single service instance identified by the PVID of that Port. Accsystable Port Type will be always Admit only Untagged or Priority Tagged Frames on this port. customerNetworkPortStagged - Port in the S-VLAN component that can transmit or received frames for single customer. VLAN classification on this interface will be based on the S-tag received or on the PVID of the port. Ingress Filtering will be always enabled on this port. customerEdgePort - Port in a Provider Edge Bridge connected to a single customer. Multiple services can be provide on this port. The Packets received on this interface will be first classified to a CVLAN. CVLAN classification can be based on the Vid in the C-Tag present in the packet (if it C-tagged packet) or from the pvid of the port. Service instance selection (S-VLAN selection) for a frame is done based on the entry present in the C-VID registration table for the pair (C-VID, recsystion Port). CustomerEdgePort configuration is allowed only in Provider Edge Bridges. propCustomerEdgePort - Port connected to a single customer, where multiple services can be provided based on only Proprietary SVLAN classification tables. S-VLAN classification will not happen based on C-VID registration table on this port. propCustomerEdgePort configuration is allowed only in Provider Edge Bridges. propCustomerNetworkPort - Port connected to a single customer, where multiple service can be provided based on CVLANs by assigning one of the Proprietary SVLAN classification tables to this port. The services can also be assigned using other proprietary SVLAN classification tables where CVLAN is not the index of the table. propProviderNetworkPort - Port connected to a Q-in-Q Bridge located inside Provider Network. This port is part of S-VLAN component. If packets to be tagged and sent out of this port will have 0x8100 as the ether type. Similarly pakcets with standard Q tag (ether type as 0x8100) received will be considered as S-Tagged packets. customerBridgePort - Type of the port to be used in customer bridges as well in Provider(Q-in-Q) bridges. This type is not valid in Provider Core bridges as well as Provider Edge bridge. In Customer bridges and in Provider Bridges only customerPort option is allowed. Bridge Port Type cannot be set for a port-channel port, if some physical ports are aggregated in it. Also Bridge Port type cannot be set for a port, if part of a port-channel. Whenever the Bridge port type changes, the previous configuration associated with the port will be flushed. For example. whenever CNP(STagged) and PNP port types are changed to any other port type, - The unicast entries learnt on this port and - The VID translation table entries associated with the port will be flushed. Whenever CEP port type is changed to any other port type, - The unicast entries learnt on this port - The C-VID registration table entries associated with the port - The PEP configuration table entries - The service priority regeneration table entries will be flushed. Even the vlan membership of the port will be removed when the Pbport type is changed.')
ifMainRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 4, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifMainRowStatus.setStatus('current')
if mibBuilder.loadTexts: ifMainRowStatus.setDescription('A RowStatus variable for addition, deletion and in-activation of the interfaces. Specification of the object is mandatory for all interfaces. When the status is active, the interface is created and ready to use in the respective protocol modules. When the status is notInService, the interface has not been registered with the respective protocol modules and as such those modules are not aware of the existence of the interface - creation is hence, incomplete. Setting an active interface to notInService results in de-registration/deletion of the interface from the respective protocol modules and all the configurations associated with that interface in those modules may be lost. Deletion of an interface, may affect the status of other interfaces which are layered above or below it in the Interface Stack (ifStackTable) and may result in other interfaces being made notReady or notInService.')
ifIpTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5), )
if mibBuilder.loadTexts: ifIpTable.setStatus('current')
if mibBuilder.loadTexts: ifIpTable.setDescription("A list of all the interface entries in the system which are registered with IP. This table contains objects which are applicable for the management of IP over the network interfaces in the system. This table is a extension to the ifMainTable. The index to this table has the semantics of the ifMainIndex of the ifMainTable. Entries are created automatically in this table for any interface sub-layer which is layer below IP using the ifStackTable. Similarly, entries are deleted from this table when the interface's layering below IP is removed.")
ifIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "ifMainIndex"))
if mibBuilder.loadTexts: ifIpEntry.setStatus('current')
if mibBuilder.loadTexts: ifIpEntry.setDescription('An entry containing management information applicable to a particular interface over which IP is operating.')
ifIpAddrAllocMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 1), ("negotiation", 2), ("dynamic", 3), ("none", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpAddrAllocMethod.setStatus('current')
if mibBuilder.loadTexts: ifIpAddrAllocMethod.setDescription('The mechanism to be used for allocation of IP address for this interface. The value negotiation can be used only for PPP and MLPPP interfaces which support obtaining of IP addresses through negotiation. The dynamic(3) option takes an IP address dynamically from the available server (dhcp/bootp/rarp) according to the protocol specified in ifIpAddrAllocProtocol. If the method specified is manual and the IP address is not provided (then the interface would be treated as a un-numbered interface.')
ifIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpAddr.setStatus('current')
if mibBuilder.loadTexts: ifIpAddr.setDescription('Specifies the IP address given to this interface. The specification of this object is mandatory for all network interfaces (Ethernet, FR VC, IPoA interface, PPP link - not under MP, MP interface and X.25 VC). If the interface is not a network interface then the default value of 0.0.0.0 is assigned and the interface is treated as a un-numbered interface by IP.')
ifIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ifIpSubnetMask.setDescription('Specifies the IP Subnet Mask for this interface. The value should be specified only for network interfaces and any valid VLSM is accsysted. If not specified, this object takes the default subnet mask value based on the class of the IP address configured for the interface.')
ifIpBroadcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpBroadcastAddr.setStatus('current')
if mibBuilder.loadTexts: ifIpBroadcastAddr.setDescription('Specifies the IP broadcast address for this interface. The value should be specified only for network interfaces and any valid broadcast address based on a valid VLSM is accsysted. If not specified, this object takes the default value based on the class of the IP address configured for the interface.')
ifIpForwardingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpForwardingEnable.setStatus('current')
if mibBuilder.loadTexts: ifIpForwardingEnable.setDescription('Specifies whether IP forwarding is enable on this interface. Disabling IP forwarding on an interface will result in packets which are to be forwarded on that interface being dropped and ICMP error messages being generated for the packets.')
ifIpAddrAllocProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("rarp", 1), ("dhcp", 2), ("bootp", 3))).clone('dhcp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIpAddrAllocProtocol.setStatus('current')
if mibBuilder.loadTexts: ifIpAddrAllocProtocol.setDescription('Specifies the protocol to be used to obtain IP address for this interface. This object is valid only when ifIpAddrAllocMethod is set to dynamic (3). Currently rarp (1) option is not supported. The assigned value will be effective only when the interface admin status changes')
ifIvrTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 8), )
if mibBuilder.loadTexts: ifIvrTable.setStatus('current')
if mibBuilder.loadTexts: ifIvrTable.setDescription('A list of all the interfaces in the system with IVR related configurations. This table is an extension to the ifMainTable. The index to this table has the semantics of the ifMainIndex of the ifMainTable.')
ifIvrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 8, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "ifMainIndex"))
if mibBuilder.loadTexts: ifIvrEntry.setStatus('current')
if mibBuilder.loadTexts: ifIvrEntry.setDescription('An entry containing IVR-related information applicable to a interface.')
ifIvrBridgedIface = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 8, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifIvrBridgedIface.setStatus('current')
if mibBuilder.loadTexts: ifIvrBridgedIface.setDescription("Indicates if this interface is a Bridged interface or not. A value of 'TRUE' indicates that this interface is a Bridged interface and is capable of performing bridging of packets through this interface. A value of 'FALSE' indicates that this interface is a Routed interface and is capable of performing routing of packets through this interface.")
ifSetMgmtVlanList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifSetMgmtVlanList.setStatus('current')
if mibBuilder.loadTexts: ifSetMgmtVlanList.setDescription('A string of octets containing one bit per VLAN. The first octet corresponds to VLANs with VlanId values 1 through 8; the second octet to VLANs 9 through 16 etc. The most significant bit of each octet corresponds to the lowest VlanId value in that octet. This is the set of vlans configured by management to associate with the management interface.')
ifResetMgmtVlanList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifResetMgmtVlanList.setStatus('current')
if mibBuilder.loadTexts: ifResetMgmtVlanList.setDescription('A string of octets containing one bit per VLAN. The first octet corresponds to VLANs with VlanId values 1 through 8; the second octet to VLANs 9 through 16 etc. The most significant bit of each octet corresponds to the lowest VlanId value in that octet. This is the set of vlans configured by management to dis-associate from the management interface. Get operation is not allowed for this object.')
ifSecondaryIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11), )
if mibBuilder.loadTexts: ifSecondaryIpAddressTable.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpAddressTable.setDescription('A list of secondary IP addresses configured over the interfaces registered with IP. This table is a extension to the ifMainTable. The index to this table has the semantics of the ifMainIndex of the ifMainTable. Secondary IpAddress configuration should not override the primary ip address configured for any of the interface Updation of entries in this table are not allowd when RowStatus is active')
ifSecondaryIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "ifMainIndex"), (0, "AT-GS950-16-MIB", "ifSecondaryIpAddress"))
if mibBuilder.loadTexts: ifSecondaryIpAddressEntry.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpAddressEntry.setDescription('An entry contains the information associated with the secondary(additional) ip address configured to a particular interface.')
ifSecondaryIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11, 1, 1), IpAddress())
if mibBuilder.loadTexts: ifSecondaryIpAddress.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpAddress.setDescription('Specifies the Secondary IP address associated with the interface')
ifSecondaryIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifSecondaryIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpSubnetMask.setDescription('Specifies the IP Subnet Mask associted with the secondary ip address configuration. The value should be specified only for network interfaces and any valid VLSM is accsysted. If not specified, this object takes the default subnet mask value based on the class of the IP address configured for the interface.')
ifSecondaryIpBroadcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifSecondaryIpBroadcastAddr.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpBroadcastAddr.setDescription('Specifies the IP broadcast address associated with the configured secondary IP address. The value should be specified only for network interfaces and any valid broadcast address based on a valid VLSM is accsysted. If not specified, this object takes the default value based on the class of the IP address configured for the interface.')
ifSecondaryIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 27, 1, 11, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifSecondaryIpRowStatus.setStatus('current')
if mibBuilder.loadTexts: ifSecondaryIpRowStatus.setDescription('This object is used to manage creation and deletion of rows in this table.')
sysRmonEnableStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysRmonenabled", 1), ("sysRmondisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRmonEnableStatus.setStatus('current')
if mibBuilder.loadTexts: sysRmonEnableStatus.setDescription('This object defines the sysRmonenable flag for sysRmon')
sysRmonHwStatsSupp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notsupported", 0), ("supported", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRmonHwStatsSupp.setStatus('current')
if mibBuilder.loadTexts: sysRmonHwStatsSupp.setDescription('This object defines the flag for whether HW supports Etherstatistics or not ')
sysRmonHwHistorySupp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notsupported", 0), ("supported", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRmonHwHistorySupp.setStatus('current')
if mibBuilder.loadTexts: sysRmonHwHistorySupp.setDescription('This object defines the enabled HWhistorysupp flag for sysRmon')
sysRmonHwAlarmSupp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notsupported", 0), ("supported", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRmonHwAlarmSupp.setStatus('current')
if mibBuilder.loadTexts: sysRmonHwAlarmSupp.setDescription('This object defines the enabled HWAlarmsupp flag for sysRmon')
sysRmonHwEventSupp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 44, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notsupported", 0), ("supported", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRmonHwEventSupp.setStatus('current')
if mibBuilder.loadTexts: sysRmonHwEventSupp.setDescription('This object defines the enabled HWEvent flag for sysRmon')
class PortLaMode(TextualConvention, Integer32):
    description = 'Defines how a Port Channel does channeling. lacp(1) - place the port into passive negotiation state, in which the port waits for its peer to initiate negotiation. manual(2) - force the port to enable channeling. disable(3) - channeling is disabled.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("lacp", 1), ("manual", 2), ("disable", 3))

class LacpKey(TextualConvention, Integer32):
    description = 'The Actor or Partner Key value.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class LacpState(TextualConvention, Bits):
    description = 'The Actor and Partner State values from the LACPDU.'
    status = 'current'
    namedValues = NamedValues(("lacpActivity", 0), ("lacpTimeout", 1), ("aggregation", 2), ("synchronization", 3), ("collecting", 4), ("distributing", 5), ("defaulted", 6), ("expired", 7))

sysLaSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1))
sysLaPortChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2))
sysLaPort = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3))
sysLaSystemControl = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaSystemControl.setStatus('current')
if mibBuilder.loadTexts: sysLaSystemControl.setDescription("Start or shutdown Link Aggregation Module in the system When set as 'start',resources required by Link aggregation module are allocated & Link aggregation module starts running. When shutdown, all resources used by Link aggregation module will be released to the system ")
sysLaStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaStatus.setStatus('current')
if mibBuilder.loadTexts: sysLaStatus.setDescription("Sets the Link Aggregation Module administrative status as enabled or disabled. The module can be enabled only when this object is set to 'enabled'.")
sysLaTraceOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaTraceOption.setStatus('current')
if mibBuilder.loadTexts: sysLaTraceOption.setDescription('This object is used to enable Trace Statements in Link Aggregation Module. A FOUR BYTE integer is used for enabling the level of tracing. Each BIT in the four byte integer, rsysresents a particular level of Trace. The mapping between the bit positions & the level of trace is as follows: 0 - Init and Shutdown Traces 1 - Management Traces 2 - Data Path Traces 3 - Control Plane Traces 4 - Packet Dump Traces 5 - Traces related to All Resources excsyst Buffers 6 - All Failure Traces 7 - Buffer Traces The remaining bits are unused. Combination of levels are also allowed. For example if the bits 0 and 1 are set, then the Trace statements related to Init-Shutdown and management will be printed. The user has to enter the corresponding INTEGER VALUE for the bits set. For example if bits 0 and 1 are set then user has to set the value 3.')
sysLaMaxPortsPerPortChannel = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaMaxPortsPerPortChannel.setStatus('current')
if mibBuilder.loadTexts: sysLaMaxPortsPerPortChannel.setDescription('This Object specifies the maximun number of ports that can attach to a port-channel')
sysLaMaxPortChannels = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaMaxPortChannels.setStatus('current')
if mibBuilder.loadTexts: sysLaMaxPortChannels.setDescription('This Object specifies the maximum number of Port-channels Present in the system')
sysLaOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaOperStatus.setStatus('current')
if mibBuilder.loadTexts: sysLaOperStatus.setDescription('This read only objects gives actual status of the Link Aggregation Module (Operational status of module). When Module is enabled Link Aggregation protocol starts functioning. When the module is disabled all the dynamically allocated memory will be freed and Link Aggregation protocol stops functioning.')
sysLaActorSystemID = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 1, 7), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaActorSystemID.setStatus('current')
if mibBuilder.loadTexts: sysLaActorSystemID.setDescription('A 6-octet read-write MAC address value used as a unique identifier for the System.')
sysLaPortChannelTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1), )
if mibBuilder.loadTexts: sysLaPortChannelTable.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelTable.setDescription('A Port-channel is created through ifMain table. After the creation of the port-channel, corresponding logical interface will be created in the ifMain table. This Port-channel table is indexed through Key values and allows to configure link selection policy and the Mac address for the port-channel. All other objects in this table displays the details of the port-channel')
sysLaPortChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysLaPortChannelIfIndex"))
if mibBuilder.loadTexts: sysLaPortChannelEntry.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelEntry.setDescription('There is one entry in this table for each created port-channel port')
sysLaPortChannelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: sysLaPortChannelIfIndex.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelIfIndex.setDescription("The ifIndex of the port-channel(Aggregator's interface index). ")
sysLaPortChannelGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 2), LacpKey()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortChannelGroup.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelGroup.setDescription('An index that uniquely identifies an entry in this table. ')
sysLaPortChannelAdminMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortChannelAdminMacAddress.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelAdminMacAddress.setDescription('This object is used for configuring MacAddress that is to be used by the port-channel when sysLaPortChannelMacSelection is force. WARNING:The value configured should not conflict with the MAC address of system ports that are not configured to select this port-channel.')
sysLaPortChannelMacSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("force", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortChannelMacSelection.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelMacSelection.setDescription('Indicates the MAC address selection method for for the port-channel. Dynamic - Port-channel MAC address is chosen as MAC address of an active port in the PortChannel. Force - Port-channel MAC address configured through sysLaPortChannelAdminMacAddress is used. The value can be changed to Force only after configuring a valid MAC address in sysLaPortChannelAdminMacAddress.')
sysLaPortChannelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 5), PortLaMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortChannelMode.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelMode.setDescription('Current Operating Channel Mode of the port Lacp(1) - forcing the port to negotiate with the partner. manual(2) - force the port to enable channeling (Manual). disable(3) - channeling is disabled.')
sysLaPortChannelPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortChannelPortCount.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelPortCount.setDescription('The number of ports actually configured to the port-channel')
sysLaPortChannelActivePortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortChannelActivePortCount.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelActivePortCount.setDescription('This object will give the number of ports that are attached to the port-channel and actively carrying data traffic on the link.')
sysLaPortChannelSelectionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("macSrc", 1), ("macDst", 2), ("macSrcDst", 3), ("ipSrc", 4), ("ipDst", 5), ("ipSrcDst", 6), ("vlanId", 7))).clone('macSrcDst')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortChannelSelectionPolicy.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelSelectionPolicy.setDescription('Link selection policy to be used by the port-channel. The selection policies based on the IP address can be set if and only if hardware is present and supported.')
sysLaPortChannelDefaultPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 2, 1, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortChannelDefaultPortIndex.setStatus('current')
if mibBuilder.loadTexts: sysLaPortChannelDefaultPortIndex.setDescription('The ifIndex of the default port that gets attached to the aggregator. A value of 0 means there is no default port for this port-channel. If this object is set to 0, it will remove the current default port from the aggregator. To change the default port of an aggregator, first reset the object to 0 and then set the new ifIndex as default port.')
sysLaPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1), )
if mibBuilder.loadTexts: sysLaPortTable.setStatus('current')
if mibBuilder.loadTexts: sysLaPortTable.setDescription('A table that contains objects to set the port lacp mode of dot3adAggPortTable.')
sysLaPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysLaPortIndex"))
if mibBuilder.loadTexts: sysLaPortEntry.setStatus('current')
if mibBuilder.loadTexts: sysLaPortEntry.setDescription('Each entry in this table is for each physical port that participates in Link Aggregation which can be either aggregatable or individual. This table is indexed by the PortIndex.')
sysLaPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: sysLaPortIndex.setStatus('current')
if mibBuilder.loadTexts: sysLaPortIndex.setDescription('The ifIndex of the port')
sysLaPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 2), PortLaMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortMode.setStatus('current')
if mibBuilder.loadTexts: sysLaPortMode.setDescription('This object is used to enable LACP, disable LACP or manually aggregate a port')
sysLaPortBundleState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("upInBndl", 0), ("standby", 1), ("down", 2), ("upIndividual", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortBundleState.setStatus('current')
if mibBuilder.loadTexts: sysLaPortBundleState.setDescription('This read-only object is used to display the port state in aggregation upInBndl(0) - The port is operationally up and actively takes part in aggregation. standby(1) - The port is capable of joining in aggregation group, when any of the ports in aggregation group goes down. down(2) - The port is operationally down in lower layers. or the port is operational in lower layers but temporarily not able to participate in aggregation because of different partner information in the same group. upIndividual(3) - The port is operating individually and is not taking part in aggregation.')
sysLaPortActorResetAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 4), LacpState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortActorResetAdminState.setStatus('current')
if mibBuilder.loadTexts: sysLaPortActorResetAdminState.setDescription('A string of 8 bits,corresponding to the administrative values of Actor_State as transmitted by the Actor in LACPDUs. The first bit corresponds to bit 0 of Actor_State (LACP_Activity), the second bit corresponds to bit 1 (LACP_Timeout),the third bit corresponds to bit 2 (Aggregation),the fourth bit corresponds to bit 3 (Synchronization),the fifth bit corresponds to bit 4 (Collecting),the sixth bit corresponds to bit 5 (Distributing), the seventh bit corresponds to bit 6 (Defaulted),and the eighth bit corresponds to bit 7 (Expired). This object allows the RESET of the values of Actor LACP_Activity, LACP_Timeout and Aggregation. Get operation on this object returns the current Port State of the Actor')
sysLaPortAggregateWaitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 5), TimeTicks().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortAggregateWaitTime.setStatus('current')
if mibBuilder.loadTexts: sysLaPortAggregateWaitTime.setDescription('Duration of the port to attach to the PortChannel.')
sysLaPortPartnerResetAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 6), LacpState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortPartnerResetAdminState.setStatus('current')
if mibBuilder.loadTexts: sysLaPortPartnerResetAdminState.setDescription('A string of 8 bits,corresponding to the administrative values of Partner_State.The first bit corresponds to bit 0 of Partner_State (LACP_Activity),the second bit corresponds to bit 1 (LACP_Timeout), the third bit corresponds to bit 2 (Aggregation),the fourth bit corresponds to bit 3 (Synchronization),the fifth bit corresponds to bit 4 (Collecting),the sixth bit corresponds to bit 5 (Distributing), the seventh bit corresponds to bit 6 (Defaulted),and the eighth bit corresponds to bit 7 (Expired). This object allows the RESET of the values of Partner LACP_Activity, LACP_Timeout and Aggregation. Get operation on this object returns zeros for the Partner administrative values')
sysLaPortActorAdminPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortActorAdminPort.setStatus('current')
if mibBuilder.loadTexts: sysLaPortActorAdminPort.setDescription('The port number used as dot3adAggPortActorPort and is communicated in LACPDUs as the Actor_Port.')
sysLaPortRestoreMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLaPortRestoreMtu.setStatus('current')
if mibBuilder.loadTexts: sysLaPortRestoreMtu.setDescription('The Restore mtu stores the original MTU of the port before getting aggregated to port channel. A SET on the MIB object is not allowed for SNMP users. This operation is allowed only during config-save-restore operation , during system initialization.')
sysLaPortSelectAggregator = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 63, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dynamic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLaPortSelectAggregator.setStatus('current')
if mibBuilder.loadTexts: sysLaPortSelectAggregator.setDescription("This read-only object is used to display whether the port participates in dynamic aggregator selection. The default will be static aggregation selection. static(0) - The port is involved only in static aggregation. i.e. the port can be a member of only the aggregation to which it is configured. dynamic(1) - The port participates in dynamic aggregation selection. i.e. the port will be a part of best aggregation selected based on System id and Admin key. This object is set to 'dynamic' once the port is configured as a default port of a port channel.")
class PaeControlledPortStatus(TextualConvention, Integer32):
    description = 'The status values of the Authenticator PAE controlled session.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("authorized", 1), ("unauthorized", 2))

class AuthenticMethod(TextualConvention, Integer32):
    description = 'The Authentication method is using Remote Authentication Server or Local Authentication Server.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("remoteServer", 1), ("localServer", 2))

class PermissionType(TextualConvention, Integer32):
    description = 'The permission values.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("allow", 1), ("deny", 2))

sysPnacPaeSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1))
sysPnacAuthServer = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3))
sysGuestVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 4))
sysPnacSystemControl = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacSystemControl.setStatus('current')
if mibBuilder.loadTexts: sysPnacSystemControl.setDescription("Starts or shutdowns PNAC Module in the system. When set as 'start',resources required by PNAC module are allocated & PNAC module starts running. When shutdown, all resources used by PNAC module will be released to the system.")
sysPnacAuthenticServer = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 3), AuthenticMethod()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacAuthenticServer.setStatus('current')
if mibBuilder.loadTexts: sysPnacAuthenticServer.setDescription('This object is used to configure for the choice of local or remote Authentication Server to be used by the Authenticator for its authentication services.')
sysPnacNasId = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacNasId.setStatus('current')
if mibBuilder.loadTexts: sysPnacNasId.setDescription('This object is the Network Access Server Identifier to be presented before the remote Authentication Server.')
sysPnacPaePortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5), )
if mibBuilder.loadTexts: sysPnacPaePortTable.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePortTable.setDescription('A table of system level information for each port supported by the EnterprisePNAC. An entry appears in this table for each port of this system. This table is an extension of dot1xPaePortTable of IEEE 802.1x MIB.')
sysPnacPaePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysPnacPaePortNumber"))
if mibBuilder.loadTexts: sysPnacPaePortEntry.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePortEntry.setDescription('Configuration as port based or MAC based authentication and Supplicant count on a port. Index to this table is same as that of the dot1xPaePortTable, which is the InterfaceIndex.')
sysPnacPaePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: sysPnacPaePortNumber.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePortNumber.setDescription('The port number associated with this port.')
sysPnacPaePortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 6), PaeControlledPortStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPnacPaePortStatus.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePortStatus.setDescription('The value of the combined Port status.')
sysPnacPaeMultiAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacPaeMultiAuthEnable.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaeMultiAuthEnable.setDescription('This object indicates dot1x multi hsot is enabled or disabled.')
sysPnacPaeProtocolMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacPaeProtocolMode.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaeProtocolMode.setDescription('This object indicates mode is 802.1x or mac based.')
sysPnacPaePiggybackMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacPaePiggybackMode.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePiggybackMode.setDescription('This object indicates piggyback mode is enabled or disabled.')
sysPnacPaeVlanAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacPaeVlanAssignment.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaeVlanAssignment.setDescription('This object indicates vlan assignment is enabled or disabled.')
sysPnacPaeSecureVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacPaeSecureVlan.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaeSecureVlan.setDescription('This object indicates Secure vlan is enabled or disabled.')
sysPnacModuleOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPnacModuleOperStatus.setStatus('current')
if mibBuilder.loadTexts: sysPnacModuleOperStatus.setDescription('This read only objects gives actual status of the PNAC Module (Operational status of module). When Module is enabled PNAC protocol starts functioning. When the module is disabled all the dynamically allocated memory will be freed and PNAC protocol stops functioning.')
sysPnacASUserConfigTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1), )
if mibBuilder.loadTexts: sysPnacASUserConfigTable.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigTable.setDescription('This table contains authentication related User configuration information maintained by PNAC local Authentication Server.')
sysPnacASUserConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysPnacASUserConfigUserName"))
if mibBuilder.loadTexts: sysPnacASUserConfigEntry.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigEntry.setDescription('Each entry contains User name, Password, Authentication protocol used, Authenticated session timeout and Access ports list of the User seeking authentication.')
sysPnacASUserConfigUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 115)))
if mibBuilder.loadTexts: sysPnacASUserConfigUserName.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigUserName.setDescription('Identity of the User seeking authentication. A string of not more than 20 printable characters.')
sysPnacASUserConfigPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacASUserConfigPassword.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigPassword.setDescription('The secret Password of the User. A string of not more than 20 printable characters. When read, this always returns a String of length zero.')
sysPnacASUserConfigAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPnacASUserConfigAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigAuthProtocol.setDescription('The Authentication protocol supported for the User.')
sysPnacASUserConfigAuthTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacASUserConfigAuthTimeout.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigAuthTimeout.setDescription('The time in seconds after which the Authentication offerred to the User ceases. Maximum value of the object can be 7200 seconds. When the object value is 0, the ReAuthPeriod of the Authenticator port is used by Authenticator.')
sysPnacASUserConfigPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 5), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacASUserConfigPortList.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigPortList.setDescription("The complete set of ports of Authenticator to which the User is allowed or denied access, on the basis of setting of 'sysPnacASUserConfigPermission' object.")
sysPnacASUserConfigPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 6), PermissionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacASUserConfigPermission.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigPermission.setDescription("For the set of ports indicated by 'sysPnacASUserConfigPortList' object, the User is allowed access when this object is set 'allow' and is denied access when this object is set 'deny'.")
sysPnacASUserConfigDynamicVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacASUserConfigDynamicVlanID.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigDynamicVlanID.setDescription('Dynamic Vlan ID is assigned by Switch in local mode')
sysPnacASUserConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 3, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysPnacASUserConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysPnacASUserConfigRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
sysPnacGuestVlanTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 4, 1), )
if mibBuilder.loadTexts: sysPnacGuestVlanTable.setStatus('current')
if mibBuilder.loadTexts: sysPnacGuestVlanTable.setDescription('This table contains authentication session information associated with each Guest vlan while Authenticator operates in port based authentication mode.')
sysPnacGuestVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysPnacPaePortNo"))
if mibBuilder.loadTexts: sysPnacGuestVlanEntry.setStatus('current')
if mibBuilder.loadTexts: sysPnacGuestVlanEntry.setDescription('Guest Vlan ID assign with each port.')
sysPnacPaePortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPnacPaePortNo.setStatus('current')
if mibBuilder.loadTexts: sysPnacPaePortNo.setDescription('The port number associated with this port.')
sysPnacGuestVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 64, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPnacGuestVlanId.setStatus('current')
if mibBuilder.loadTexts: sysPnacGuestVlanId.setDescription('specify the guest vlan tag.0 for non exiting')
sysSystemInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1))
sysConfigControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2))
sysMirror = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3))
sysIpAuthMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7))
sysLBDdetect = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22))
sysSwitchName = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)).clone('SysName')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSwitchName.setStatus('current')
if mibBuilder.loadTexts: sysSwitchName.setDescription('System name used for identification of the device. The following characters are allowed to input. 0 ~ 9 / a ~ z / A ~ Z Special character: ( ) A!V + _ = .')
sysHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysHardwareVersion.setDescription('Version number of the Hardware.')
sysFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysFirmwareVersion.setDescription('Version number of the Firmware.')
sysDefaultIpAddrCfgMode = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("dynamic", 2))).clone('manual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultIpAddrCfgMode.setStatus('current')
if mibBuilder.loadTexts: sysDefaultIpAddrCfgMode.setDescription("Specifies the means by which the default interface in the device gets the IP address. If 'manual' mode is selected, the default interface takes the 'sysDefaultIpAddr' configured in the system. If 'dynamic' mode is selected, the default interface gets the IP address through dynamic IP address configuration protocols such as RARP client, BootP client, DHCP Client, etc. If the system fails to get the IP address dynamically through all the above protocols, the default interface uses the 'sysDefaultIpAddr' configured in the system.")
sysDefaultIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultIpAddr.setStatus('current')
if mibBuilder.loadTexts: sysDefaultIpAddr.setDescription('Default IP Address of the system. This IP address, if modified, will take effect only when the configuration is stored & restored.')
sysDefaultIpSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: sysDefaultIpSubnetMask.setDescription('IP subnet mask for the default IP address. This subnet mask, if modified, will take effect only when the configuration is stored & restored.')
sysRestart = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRestart.setStatus('current')
if mibBuilder.loadTexts: sysRestart.setDescription("This object allows the user to restart the Switch (i.e)the entire switch will operationally go down and start again. Setting a value of 'true' causes the switch to be restarted. When the switch operationally goes down, configuration save operation is initiated based on the configuration save option chosen. When the switch operationally come up, the saved configurations are restored based on the restore option chosen. Once the switch is restarted, the value of this object reverts to 'false'.")
sysConfigSaveOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noSave", 1), ("flashSave", 2), ("remoteSave", 3), ("startupConfig", 4))).clone('startupConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigSaveOption.setStatus('current')
if mibBuilder.loadTexts: sysConfigSaveOption.setDescription("Specifies whether the configurations of the switch has to be saved or not. The value 'noSave' specifies that the configurations need not be saved. The value 'flashSave' specifies that the configurations need to be saved in flash in the specified file name sysConfigSaveFileName. The value 'remoteSave' specifies that the configurations need to be saved in specified remote system. The value 'startupConfig' specifies that the configurations need to be saved in flash in the 'Startup Configuration File'.")
sysConfigSaveIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigSaveIpAddr.setStatus('current')
if mibBuilder.loadTexts: sysConfigSaveIpAddr.setDescription("IP Address of the remote system to which the switch configurations have to be saved. This object is valid only if 'sysConfigSaveOption' is chosen to be 'remoteSave'.")
sysConfigSaveFileName = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('iss.conf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigSaveFileName.setStatus('current')
if mibBuilder.loadTexts: sysConfigSaveFileName.setDescription("Name of the file in which the switch configurations are to be saved. This object is valid only if 'sysConfigSaveOption' is chosen to be 'flashSave' or 'remoteSave'.")
sysInitiateConfigSave = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysInitiateConfigSave.setStatus('current')
if mibBuilder.loadTexts: sysInitiateConfigSave.setDescription("When set as 'true' switch configurations save operation is initiated. As soon as the configuration save operation is completed, the value of this object reverts back to 'false'. All the configurations made via the three interfaces viz. -> commandline interface -> Web Interface -> SNMP interface are saved either in 'Startup Configuration File' in the flash or in the specified 'sysConfigSaveFileName' in the flash or in the chosen remote system, dsysending upon 'ConfigSaveOption'.")
sysConfigSaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("saveInProgress", 1), ("saveSuccessful", 2), ("saveFailed", 3), ("notInitiated", 4))).clone('notInitiated')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysConfigSaveStatus.setStatus('current')
if mibBuilder.loadTexts: sysConfigSaveStatus.setDescription('Status of configuration save operation.')
sysConfigRestoreOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noRestore", 1), ("restore", 2))).clone('noRestore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigRestoreOption.setStatus('current')
if mibBuilder.loadTexts: sysConfigRestoreOption.setDescription("Specifies whether the switch configurations have to be restored or not. The value 'noRestore' specifies that the switch configurations need not be restored when the system is restarted. The value 'restore' specifies that the configurations need to be restored from the 'Startup Configuration File' in the flash when the system is restarted.")
sysRemoteConfigRestoreIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRemoteConfigRestoreIpAddr.setStatus('current')
if mibBuilder.loadTexts: sysRemoteConfigRestoreIpAddr.setDescription("IP Address of the remote system from where the switch configurations have to be downloaded to the 'Startup Configuration File' in the flash.")
sysConfigRestoreFileName = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('iss.conf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigRestoreFileName.setStatus('current')
if mibBuilder.loadTexts: sysConfigRestoreFileName.setDescription("The configuration file name in the remote system which has to be downloaded to the 'Startup Configuration File' and set this name to 'Startup Configuration Restire File Name' in the flash.")
sysInitiateRemoteConfigRestore = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 18), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysInitiateRemoteConfigRestore.setStatus('current')
if mibBuilder.loadTexts: sysInitiateRemoteConfigRestore.setDescription("When set as 'true', the switch configurations will be downloaded from the specified remote system to the 'Startup Configuration File' in the flash. As soon as the configuration download operation is completed, the value of this object reverts back to 'false'.")
sysConfigRestoreStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("restoreInprogress", 1), ("restoreSuccessful", 2), ("restoreFailed", 3), ("notInitiated", 4))).clone('notInitiated')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysConfigRestoreStatus.setStatus('current')
if mibBuilder.loadTexts: sysConfigRestoreStatus.setDescription('The status of the switch configuration restore operation.')
sysDlFirmwareFromIp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDlFirmwareFromIp.setStatus('current')
if mibBuilder.loadTexts: sysDlFirmwareFromIp.setDescription('The Ip Address of machine from where the firmware has to be downloaded.')
sysDlFirmwareName = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('firmware.hex')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDlFirmwareName.setStatus('current')
if mibBuilder.loadTexts: sysDlFirmwareName.setDescription('The firmware name which is to be downloaded to the switch.')
sysInitiateDlFirmware = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysInitiateDlFirmware.setStatus('current')
if mibBuilder.loadTexts: sysInitiateDlFirmware.setDescription('Initiates the firmware Download operation.')
sysLoggingOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("console", 1), ("file", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLoggingOption.setStatus('current')
if mibBuilder.loadTexts: sysLoggingOption.setDescription('The option specifies whether the debug logging messages is to be sent to console or to a file(system buffer) in the system.')
sysUploadLogFileToIp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysUploadLogFileToIp.setStatus('current')
if mibBuilder.loadTexts: sysUploadLogFileToIp.setDescription('The Ip address of TFTP server to which the log file is to be uploaded.')
sysLogFileName = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('iss.log')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogFileName.setStatus('current')
if mibBuilder.loadTexts: sysLogFileName.setDescription('The file name to be used for uploading the logs to the remote system.')
sysInitiateUlLogFile = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 26), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysInitiateUlLogFile.setStatus('current')
if mibBuilder.loadTexts: sysInitiateUlLogFile.setDescription("Initiates uploading of log file to the specified IP address in 'sysUploadLogFileToIp'. The logs will be uploaded and saved in a file using the file name which was specified in 'sysLogFileName'.")
sysSysContact = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSysContact.setStatus('current')
if mibBuilder.loadTexts: sysSysContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person. If no contact information is known, the value is the zero-length string.')
sysSysLocation = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSysLocation.setStatus('current')
if mibBuilder.loadTexts: sysSysLocation.setDescription("The physical location of this node (e.g., `telsyshone closet, 3rd floor'). If the location is unknown, the value is the zero-length string.")
sysLoginAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local", 1), ("remoteRadius", 2), ("remoteTacacs", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLoginAuthentication.setStatus('current')
if mibBuilder.loadTexts: sysLoginAuthentication.setDescription('The mechanism by which the user login to access the GUI for configuration has to be authenticated. Authentication is done either locally or in the remote side through a RADIUS Server.')
sysSwitchBaseMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 32), MacAddress().clone(hexValue="000102030405")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSwitchBaseMacAddress.setStatus('current')
if mibBuilder.loadTexts: sysSwitchBaseMacAddress.setDescription('Ethernet address (base address) of the Switch. This base Mac Address, if modified, will take effect only when the Switch is restarted.')
sysSwitchDate = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSwitchDate.setStatus('current')
if mibBuilder.loadTexts: sysSwitchDate.setDescription(' The date is display in the switch in the format, Hours:Minutes:Seconds Day Month Year e.g 19:10:31 11 08 2005 01-12 Month - beginning from January to December The railway time 00 to 24 hours can be displayed. The Display of the date is in the format , WeekDay Month Day Hours:Minutes:Seconds Year e.g 04 09 21 18:11:30 2005 01-07 WeekDay - beginning from Sunday to Saturday 01-12 Month - beginning from January to December ')
sysHttpPort = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHttpPort.setStatus('current')
if mibBuilder.loadTexts: sysHttpPort.setDescription('The port to be used by the hosts/PC to configure ISS using the Web Interface The HTTP server must be disabled before this configuration is done')
sysHttpStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHttpStatus.setStatus('current')
if mibBuilder.loadTexts: sysHttpStatus.setDescription('This object is for enabling or disabling HTTP in the system.')
sysDefaultVlanId = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: sysDefaultVlanId.setDescription('The Default VLAN Identifier to be used at system startup. The VLAN Module creates this vlan as the default vlan. The Default VLAN Identifier, if modified, will take effect only when the switch is restarted')
sysWebAutoTimeoutInterval = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(180, 3600)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysWebAutoTimeoutInterval.setStatus('current')
if mibBuilder.loadTexts: sysWebAutoTimeoutInterval.setDescription('This time interval to be used at counting time seconds to logout web interface automatically.')
sysCliAutoTimeoutInterval = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18000)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCliAutoTimeoutInterval.setStatus('current')
if mibBuilder.loadTexts: sysCliAutoTimeoutInterval.setDescription('This time interval to be used at counting time seconds to logout command interface automatically.')
sysCpuPolicerStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCpuPolicerStatus.setStatus('current')
if mibBuilder.loadTexts: sysCpuPolicerStatus.setDescription('This object is for enabling or disabling cpu policer in the system.')
sysLedEcoModeStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLedEcoModeStatus.setStatus('current')
if mibBuilder.loadTexts: sysLedEcoModeStatus.setDescription('This object is for enabling or disabling LED ECO mode in the system.')
sysPowerSavingEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPowerSavingEnable.setStatus('current')
if mibBuilder.loadTexts: sysPowerSavingEnable.setDescription('This object is for enabling or disabling powersaving in the system.')
sysDhcpAutoConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDhcpAutoConfiguration.setStatus('current')
if mibBuilder.loadTexts: sysDhcpAutoConfiguration.setDescription('This object is for enabling or disabling DHCP auto configuration in the system.')
sysAsyVLANEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAsyVLANEnable.setStatus('current')
if mibBuilder.loadTexts: sysAsyVLANEnable.setDescription('This object is for set asyvlan to ivl or svl in the system.')
issCosEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: issCosEnable.setStatus('current')
if mibBuilder.loadTexts: issCosEnable.setDescription('This object is for enabling or disabling COS in the system.')
sysTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapEnable.setStatus('current')
if mibBuilder.loadTexts: sysTrapEnable.setDescription('This object is for enabling or disabling Trap in the system.')
sysFDResetStateEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysFDResetStateEnable.setStatus('current')
if mibBuilder.loadTexts: sysFDResetStateEnable.setDescription('Enable/Disable Factory Default Reset function. The Factory Default Reset function is used to enable or disable the push button and reset function on the device. When the user wants to disable reset function that must be configure a password to lock it. Once want to recovery the reset function, the password was needed to verify authorize.')
sysFDRInputPw = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 1, 68), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysFDRInputPw.setStatus('current')
if mibBuilder.loadTexts: sysFDRInputPw.setDescription('Input a password first and then the sysFDResetStateEnable can work correctly.')
sysConfigCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1), )
if mibBuilder.loadTexts: sysConfigCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlTable.setDescription('A table to control device features like egress traffic control, stats collection, etc. either for the entire switch or for each interface in the switch.')
sysConfigCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysConfigCtrlIndex"))
if mibBuilder.loadTexts: sysConfigCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlEntry.setDescription("An entry appears in this table for each interface in the system. In addition to that an entry with index '0' is created in this table by default. If 'sysConfigCtrlStatus' of the entry '0' is made 'valid', then global control is chosen and the values against entry '0' is applicable for all the interfaces of the switch. If 'sysConfigCtrlStatus' of the entry '0' is made 'invalid', then interface-wise control is chosen & the values against each interface index is applicable for that interface. At a particular point of time, either global control will be applicable or interface-wise control is applicable. Both will not be considered together. Index to the table is the interface index of the port.")
sysConfigCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: sysConfigCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlIndex.setDescription("Interface index of the port for which the configuration in this entry applies. If any configuration is made in this table for the index '0', that configuration will be considered as global configuration and is applicable for all the interfaces of the switch.")
sysConfigCtrlEgressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigCtrlEgressStatus.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlEgressStatus.setDescription("Controls the transmission of egress traffic over this interface. This value for entry '0' controls the egress traffic over all interfaces.")
sysConfigCtrlStatsCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigCtrlStatsCollection.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlStatsCollection.setDescription("Enables or disables statistics collection for this interface. This value for entry '0' controls the stats collection for all interfaces.")
sysConfigCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: sysConfigCtrlStatus.setDescription("Speficies the validity of the entry. If the 'Config Control Status' for entry '0' is made 'valid', then global control is chosen in the system. It signifies that the values against entry '0' is applicable for all the interfaces of the switch. If the 'Config Control Status' for entry '0' is made 'invalid', then interface-wise control is chosen. Then the values against each interface index is applicable for that interface. By default, 'sysConfigCtrlStatus' will be 'invalid' for entry '0' and 'valid' for all other entries. (ie) by default, interface-wise configuration is enabled in the system. The status of entries other than the zeroth(0th) entry can not be made 'invalid'.")
sysPortCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2), )
if mibBuilder.loadTexts: sysPortCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlTable.setDescription('A table to control the port specific parameters of the device like speed, duplex mode, etc.')
sysPortCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysPortCtrlIndex"))
if mibBuilder.loadTexts: sysPortCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlEntry.setDescription('An entry appears in this table for each interface in the system. Index to the table is the interface index of the port.')
sysPortCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sysPortCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlIndex.setDescription('Interface index of the port for which the configuration in this entry applies.')
sysPortCtrlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("noNegotiation", 2))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlMode.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlMode.setDescription("Speficies the mode in which the speed, duplex modes and flow control of the interface is determined. If set as 'auto', the hardware senses speed and negotiates with the port on the other end of the link for data transfer operation as 'full-duplex' or 'half-duplex' and about flow contol. If set as 'nonegotiation', the configured values for interface speed, duplex mode and flow control will be effective.")
sysPortCtrlDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full", 1), ("half", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlDuplex.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlDuplex.setDescription("Configures interface data transfer mode as full-duplex or half-duplex. This object can be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value from Hardware after negotiating with its peer")
sysPortCtrlSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tenMBPS", 1), ("hundredMBPS", 2), ("oneGB", 3), ("tenGB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlSpeed.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlSpeed.setDescription("Configures interface speed. This object can be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value from Hardware after negotiating with its peer")
sysPortCtrlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlFlowControl.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlFlowControl.setDescription("Enables / disables flow control for the interface. This object be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value from Hardware after negotiating with its peer")
sysPortCtrlMDI = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("mdi", 2), ("mdix", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlMDI.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlMDI.setDescription('Sets the auto/mdi/mdix of the copper interface. Fiber media is not support.')
issJumboFramePerPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: issJumboFramePerPortEnable.setStatus('current')
if mibBuilder.loadTexts: issJumboFramePerPortEnable.setDescription('Gigabit Web Smart Switches support jumbo frames (frames larger than the Ethernet frame size of 1522 bytes) of up to 10,000 bytes (tagged). Default jumbo frame is disabled.')
issJumboFramePerPortMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1522, 10000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: issJumboFramePerPortMtu.setStatus('current')
if mibBuilder.loadTexts: issJumboFramePerPortMtu.setDescription('Gigabit Web Smart Switches support jumbo frames (frames larger than the Ethernet frame size of 1522 bytes) of up to 10,000 bytes (tagged). Default jumbo frame MTU is 10000.')
sysPortCtrlEAPPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlEAPPassThrough.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlEAPPassThrough.setDescription('Enables / disables dot1x EAP packet pass through for the interface. This object be configured only if the dot1x is disabled.')
sysPortCtrlBPDUPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortCtrlBPDUPassThrough.setStatus('current')
if mibBuilder.loadTexts: sysPortCtrlBPDUPassThrough.setDescription('Enables / disables STP BPDU passthrough for the interface. This object be configured only if the RSTP/MSTP is disabled.')
sysMirrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMirrorStatus.setStatus('current')
if mibBuilder.loadTexts: sysMirrorStatus.setDescription('Provides control over the mirroring feature in the switch.')
sysMirrorToPort = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMirrorToPort.setStatus('current')
if mibBuilder.loadTexts: sysMirrorToPort.setDescription('Specifies the port to which the mirrored traffic in the system is to be copied.')
sysMirrorCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3), )
if mibBuilder.loadTexts: sysMirrorCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlTable.setDescription("A table to control mirroring features either for the entire switch or for each interface in the switch. Parameters in this table are valid only when the 'sysMirrorStatus' for the switch is not 'disabled'.")
sysMirrorCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysMirrorCtrlIndex"))
if mibBuilder.loadTexts: sysMirrorCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlEntry.setDescription('An entry appears in this table for each interface in the system.')
sysMirrorCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sysMirrorCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlIndex.setDescription('The interface index of the port for which the configuration in this entry applies.')
sysMirrorCtrlIngressMirroring = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMirrorCtrlIngressMirroring.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlIngressMirroring.setDescription('Provides control to enable or disable mirroring of ingress traffic over this interface to the mirrored-to port.')
sysMirrorCtrlEgressMirroring = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMirrorCtrlEgressMirroring.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlEgressMirroring.setDescription('Provides control to enable or disable mirroring of egress traffic over this interface to the mirrored-to port.')
sysMirrorCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMirrorCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: sysMirrorCtrlStatus.setDescription('Provides control to enable or disable mirroring of egress traffic over this interface to the mirrored-to port.')
sysIpAuthMgrStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpAuthMgrStatus.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrStatus.setDescription('Provides control over the Ip authentication management feature in the switch.')
sysIpAuthMgrTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2), )
if mibBuilder.loadTexts: sysIpAuthMgrTable.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrTable.setDescription('A table to configure IP authorized managers in the system.')
sysIpAuthMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysIpAuthMgrIpAddr"), (0, "AT-GS950-16-MIB", "sysIpAuthMgrIpMask"))
if mibBuilder.loadTexts: sysIpAuthMgrEntry.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrEntry.setDescription('Each entry in this table rsysresents rules for particular IP authorized manager.')
sysIpAuthMgrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: sysIpAuthMgrIpAddr.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrIpAddr.setDescription("Specifies either the Network or Host address from which the switch can be managed. An address 0.0.0.0 indicates 'Any Manager'.")
sysIpAuthMgrIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: sysIpAuthMgrIpMask.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrIpMask.setDescription("Specifies the IP address mask to be applied on sysIpAuthMgrIpAddr. Value 0.0.0.0 indicates mask for 'Any Manager'.")
sysIpAuthMgrPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpAuthMgrPortList.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrPortList.setDescription("Specifies the port numbers through which the authorized manager can access the switch. By default the authorized manager is allowed to access the switch through all the ports. If a set of ports are configured in the 'PortList', the manager can access the switch only through the configured ports.")
sysIpAuthMgrVlanList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpAuthMgrVlanList.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrVlanList.setDescription("Specifies the Vlan's in which the IP authorized manager can reside. By default the manager is allowed to reside in any vlan. If a set of vlans are configured in the 'VlanList', the manager can reside only in the configured vlan set. Access to the switch will be denied from any other vlan.")
sysIpAuthMgrAllowedServices = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 6), Integer32().clone(31)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpAuthMgrAllowedServices.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrAllowedServices.setDescription('Specifies the allowed services through which the authorized manager can access the switch. This object takes bit mask values. The services rsysresented by each bit position is as given below: With bit 0 being the Least Significant Bit, Bit0 --> snmp Bit1 --> telnet Bit2 --> http Bit3 --> https Bit4 --> ssh If the particular bit is set to 1,corresponding service is allowed for the configured manager. By default all services are allowed for the configured manager.')
sysIpAuthMgrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 7, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysIpAuthMgrRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysIpAuthMgrRowStatus.setDescription('This object indicates the status of this entry.')
sysLBDStateEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDStateEnable.setStatus('current')
if mibBuilder.loadTexts: sysLBDStateEnable.setDescription('Enable/Disable Loopback detection function. The Loopback Detection function is used to detect the loop created by a specific port while Spanning Tree Protocol (STP) is not enabled in the network, especially when the down links are hubs or unmanaged switchs.The Switch will automatically shutdown the port and sends a log to the administrator.')
sysLBDInterval = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDInterval.setStatus('current')
if mibBuilder.loadTexts: sysLBDInterval.setDescription('Set a Loop detection Interval between 1 and 32767 seconds. The default is 2 seconds. This time interval to be used at counting time seconds to resend the CTP packet automatically.')
sysLBDRecoverTime = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(60, 1000000), )).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDRecoverTime.setStatus('current')
if mibBuilder.loadTexts: sysLBDRecoverTime.setDescription('This time interval to be used at counting time seconds to recover the disabled port automatically. The Loop Detection Recover Time can be set at 0 seconds, or 60 to 1000000 seconds. Entering 0 will disable the Loop Detection Recover Time. The default is 60 seconds.')
sysLBDCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 4), )
if mibBuilder.loadTexts: sysLBDCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlTable.setDescription('A table to control Loopback detection features either for the entire switch or for each interface in the switch.')
sysLBDCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysLBDCtrlIndex"))
if mibBuilder.loadTexts: sysLBDCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlEntry.setDescription('An entry appears in this table for each interface in the system.')
sysLBDCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlIndex.setDescription('The interface index of the port for which the configuration in this entry applies.')
sysLBDPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDPortStatus.setStatus('current')
if mibBuilder.loadTexts: sysLBDPortStatus.setDescription('Provides control to per port enable or disable the loopback detection function. Default is disabled.')
sysLBDPortLoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 22, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDPortLoopStatus.setStatus('current')
if mibBuilder.loadTexts: sysLBDPortLoopStatus.setDescription('The loop status for this port.')
sysRateControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4))
sysStormControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12))
sysRateCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4, 1), )
if mibBuilder.loadTexts: sysRateCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysRateCtrlTable.setDescription('A table to control the rate limiting parameters either for the entire switch or for each interface in the switch.')
sysRateCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysRateCtrlIndex"))
if mibBuilder.loadTexts: sysRateCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysRateCtrlEntry.setDescription('An entry appears in this table for each physical interface in the switch.')
sysRateCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sysRateCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysRateCtrlIndex.setDescription('The interface index for which the configuration in this entry applies.')
sysRateCtrlEgressLimitValue = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRateCtrlEgressLimitValue.setStatus('current')
if mibBuilder.loadTexts: sysRateCtrlEgressLimitValue.setDescription("Configures interface Rate Limit (Packet that can be transferred on a port at a particular second). This object's value will take effect on the interface speed. Based on the operating speed of the port, the rate limit will be applied. This value can also be affected by the metering. A value of zero(0) disable rate limiting i.e. sets the port to full speed. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000 (Kbits per second) in GE port. (Note: The multiple of 1850 Kbits/sec will be set automatically because the resolution of Giga-port Tx bandwidth control is 1850 Kbits/sec.)")
sysRateCtrlIngressLimitValue = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRateCtrlIngressLimitValue.setStatus('current')
if mibBuilder.loadTexts: sysRateCtrlIngressLimitValue.setDescription('Allows to configure the limiting value for the maximum number of receive packets that can be transmitted per second over this interface. Setting this object to the value zero disables rate limiting for receive packets on this interface. The value that can be set for this object is limited by the underlying hardware. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000(Kbits per second) in GE port.')
sysStormCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1), )
if mibBuilder.loadTexts: sysStormCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysStormCtrlTable.setDescription('A table to control the rate limiting parameters either for the entire switch or for each interface in the switch.')
sysStormCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysStormCtrlIndex"))
if mibBuilder.loadTexts: sysStormCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysStormCtrlEntry.setDescription('An entry appears in this table for each physical interface in the switch.')
sysStormCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sysStormCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysStormCtrlIndex.setDescription('The interface index for which the configuration in this entry applies.')
sysDlfOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDlfOnOff.setStatus('current')
if mibBuilder.loadTexts: sysDlfOnOff.setDescription('This object indicates unknown unicast storm control function is enabled or disabled for device. When you enable unknown unicast storm control function, it will allowed you to limit the number of unknown unicast packets per second going through device.')
sysBroadcastOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBroadcastOnOff.setStatus('current')
if mibBuilder.loadTexts: sysBroadcastOnOff.setDescription('This object indicates broadcast storm control function is enabled or disabled for device. When you enable broadcast storm control function, it will allowed you to limit the number of broadcast packets per second going through device.')
sysMulticastOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMulticastOnOff.setStatus('current')
if mibBuilder.loadTexts: sysMulticastOnOff.setDescription('This object indicates multicast storm control function is enabled or disabled for device. When you enable multicast storm control function, it will allowed you to limit the number of multicast packets per second going through device.')
sysStormCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysStormCtrlThreshold.setStatus('current')
if mibBuilder.loadTexts: sysStormCtrlThreshold.setDescription('Allows to configure the limiting value for the maximum number of packets that can be transmitted per second over this interface. Setting this object to the value zero disables rate limiting on this interface. The value that can be set for this object is limited by the underlying hardware. The limit value must be low, medium, or high. (Notice : if the limit value is 0, it means unlimited.)')
sysStormCtrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 12, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysStormCtrlRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysStormCtrlRowStatus.setDescription("*This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
sysUserAuthMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30))
sysUserAuthMgrTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30, 1), )
if mibBuilder.loadTexts: sysUserAuthMgrTable.setStatus('current')
if mibBuilder.loadTexts: sysUserAuthMgrTable.setDescription('A table to configure user authorized managers in the system.')
sysUserAuthMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysUserAuthMgrId"))
if mibBuilder.loadTexts: sysUserAuthMgrEntry.setStatus('current')
if mibBuilder.loadTexts: sysUserAuthMgrEntry.setDescription('User tabale entry.')
sysUserAuthMgrId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysUserAuthMgrId.setStatus('current')
if mibBuilder.loadTexts: sysUserAuthMgrId.setDescription('User ID used for administration of this device.')
sysUserAuthMgrName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysUserAuthMgrName.setStatus('current')
if mibBuilder.loadTexts: sysUserAuthMgrName.setDescription('User Name used for administration of this device.')
sysUserAuthMgrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 81, 30, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysUserAuthMgrRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysUserAuthMgrRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
class IfDirection(TextualConvention, Integer32):
    description = "IfDirection specifies a direction of data travel on an interface. 'inbound' traffic is operated on during recsystion from the interface, while 'outbound' traffic is operated on prior to transmission on the interface."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("outbound", 1), ("inbound", 2))

class DscpOrAny(TextualConvention, Unsigned32):
    reference = 'RFC 2474, RFC 2780'
    description = 'The IP header Differentiated Services Code-Point that may be used for discriminating among traffic streams. The value -1 is used to indicate a wild card i.e. any value.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 63)

sysDfsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1))
sysDfsMFClassifier = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2))
sysDfsClassifier = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3))
sysDfsInProfileAction = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4))
sysDfsOutProfileAction = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5))
sysDfsMeter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6))
sysDfsEnterpriseCoSqAlgorithm = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 8))
sysDfsMultiFieldClfrTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1), )
if mibBuilder.loadTexts: sysDfsMultiFieldClfrTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrTable.setDescription('This table contains the Multifield Classifier details. (In WEB, it means Class Map)')
sysDfsMultiFieldClfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsMultiFieldClfrId"))
if mibBuilder.loadTexts: sysDfsMultiFieldClfrEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrEntry.setDescription('An IP Multi-field Classifier entry describes a single MF Classifier.')
sysDfsMultiFieldClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: sysDfsMultiFieldClfrId.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrId.setDescription('An index that enumerates the MultiField Classifier filter.')
sysDfsMultiFieldClfrFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsMultiFieldClfrFilterId.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrFilterId.setDescription('This Object specifies the ID of the filter the details of which should be matched against the incoming packet')
sysDfsMultiFieldClfrFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("macfilter", 1), ("ipfilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsMultiFieldClfrFilterType.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrFilterType.setDescription('This Object specifies the type of the filter')
sysDfsMultiFieldClfrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 2, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysDfsMultiFieldClfrStatus.setStatus('current')
if mibBuilder.loadTexts: sysDfsMultiFieldClfrStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active.')
sysDfsClfrTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1), )
if mibBuilder.loadTexts: sysDfsClfrTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrTable.setDescription('This table contains the Multifield filter details. (In WEB, it means Policy Map)')
sysDfsClfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsClfrId"))
if mibBuilder.loadTexts: sysDfsClfrEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrEntry.setDescription("An entry in the classifier table describes a single classifier. All classifier elements belonging to the same classifier use the classifier's sysDfsClfrId as part of their index.")
sysDfsClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: sysDfsClfrId.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrId.setDescription('An index that enumerates the classifier entries.')
sysDfsClfrMFClfrId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsClfrMFClfrId.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrMFClfrId.setDescription('The Object refers to a MultiField Classifier Id which is the index for the MF Classifier table. A Valid value of this object is not mandatory for the creation of an entry in this table. Need to map a Class ID (sysDfsMultiFieldClfrId)')
sysDfsClfrInProActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsClfrInProActionId.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrInProActionId.setDescription('The Object refers to a In Profile Action Id which is the index for the InProfile Action Table. A Valid value of this object is not mandatory for the creation of an entry in this table. Must the same with sysDfsClfrId. ')
sysDfsClfrOutProActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsClfrOutProActionId.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrOutProActionId.setDescription('The Object refers to a Out Profile Action Id which is the index for the OutProfile Action Table. A Valid value of this object is not mandatory for the creation of an entry in this table. Must the same with sysDfsClfrId. ')
sysDfsClfrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 3, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysDfsClfrStatus.setStatus('current')
if mibBuilder.loadTexts: sysDfsClfrStatus.setDescription("The status of this concsystual row. The objects sysDfsClfrInProActionId and sysDfsClfrOutProActionId can be modified at any time. But the other Objects can not be modified when the RowStatus is 'active'for the particular entry. when the Row Status is set to 'destroy'for any of the entries only the entry is removed from the table. As the Object in this table are indexed to various other tables they stand unmodified by setting the RowStatus to 'destroy'.")
sysDfsInProfileActionTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1), )
if mibBuilder.loadTexts: sysDfsInProfileActionTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionTable.setDescription('The Action Table enumerates actions that can be performed to a stream of traffic which is inprofile.For example, traffic exiting from a meter may be counted, marked, and potentially dropped before entering a queue.')
sysDfsInProfileActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsInProfileActionId"))
if mibBuilder.loadTexts: sysDfsInProfileActionEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionEntry.setDescription('Each entry in the action table allows description of one of action to be applied to traffic dsysending upon the treatment selected by sysDfsInProfileActionFlag.')
sysDfsInProfileActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: sysDfsInProfileActionId.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionId.setDescription('An index that enumerates the In Profile Action entries. Must be match the Policy ID. ')
sysDfsInProfileActionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsInProfileActionFlag.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionFlag.setDescription('This Object defines the action to be performed on the packet, when the packets are found to be In profile. Default Priority = 1 (0x0001), TOS = 4 (0x0004), DSCP = 1024 (0x0400)')
sysDfsInProfileActionNewPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsInProfileActionNewPrio.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionNewPrio.setDescription('This Object kesyss the new priority value in case the action selected by sysDfsInProfileActionFlag is to assign a new priority/COS value.')
sysDfsInProfileActionDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1, 6), DscpOrAny()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsInProfileActionDscp.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionDscp.setDescription('This Object kesyss the new DSCP value in case the action selected by sysDfsInProfileActionFlag is to assign a new DSCP value.')
sysDfsInProfileActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 4, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysDfsInProfileActionStatus.setStatus('current')
if mibBuilder.loadTexts: sysDfsInProfileActionStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active.')
sysDfsOutProfileActionTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1), )
if mibBuilder.loadTexts: sysDfsOutProfileActionTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionTable.setDescription('The Action Table enumerates actions that can be performed to a stream of traffic which is out of profile.For example, traffic exiting from a meter may be counted, marked, and potentially dropped before entering a queue.')
sysDfsOutProfileActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsOutProfileActionId"))
if mibBuilder.loadTexts: sysDfsOutProfileActionEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionEntry.setDescription('Each entry in the action table allows description of one of action to be applied to traffic dsysending upon the treatment selected by sysDfsOutProfileActionFlag.')
sysDfsOutProfileActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: sysDfsOutProfileActionId.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionId.setDescription('An index that enumerates the Out Profile Action entries. Must the same with sysDfsClfrId. ')
sysDfsOutProfileActionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsOutProfileActionFlag.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionFlag.setDescription('This Object defines the action to be performed on the packet when the packets are found to be out of profile. Drop = 2 (0x0002) DSCP = 4 (0x0004)')
sysDfsOutProfileActionMID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsOutProfileActionMID.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionMID.setDescription('This Object kesyss the Meter Id to be added to the DataPath to which this particular OutProfileAction is applicable. Must the same with sysDfsClfrId. ')
sysDfsOutProfileActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 5, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysDfsOutProfileActionStatus.setStatus('current')
if mibBuilder.loadTexts: sysDfsOutProfileActionStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active. The row comprises of an Meter Id which is an index to the Meter Table.')
sysDfsMeterTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6, 1), )
if mibBuilder.loadTexts: sysDfsMeterTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsMeterTable.setDescription('The Meter Table has the number of token with it and refreshCount value for associated with the meter.')
sysDfsMeterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsMeterId"))
if mibBuilder.loadTexts: sysDfsMeterEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsMeterEntry.setDescription('An entry in the Meter Table describing a single instance of a Metering Unit.')
sysDfsMeterId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: sysDfsMeterId.setStatus('current')
if mibBuilder.loadTexts: sysDfsMeterId.setDescription('An index that enumerates the Meter entries. Must the same with sysDfsClfrId. ')
sysDfsMeterRefreshCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsMeterRefreshCount.setStatus('current')
if mibBuilder.loadTexts: sysDfsMeterRefreshCount.setDescription('This values specifies the number of tokens to be added to the meter bucket after each 8 usec. (Threshold kbps)')
sysDfsMeterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 6, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysDfsMeterStatus.setStatus('current')
if mibBuilder.loadTexts: sysDfsMeterStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when this rowstatus in not active.')
sysDfsCoSqAlgorithmTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 8, 1), )
if mibBuilder.loadTexts: sysDfsCoSqAlgorithmTable.setStatus('current')
if mibBuilder.loadTexts: sysDfsCoSqAlgorithmTable.setDescription('A table containing the scheduling algorithm applied to a particular port.')
sysDfsCoSqAlgorithmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 8, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysDfsPortId"))
if mibBuilder.loadTexts: sysDfsCoSqAlgorithmEntry.setStatus('current')
if mibBuilder.loadTexts: sysDfsCoSqAlgorithmEntry.setDescription('An entry in this table gives mapping of a Port to user defined scheduled algorithm.')
sysDfsPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)))
if mibBuilder.loadTexts: sysDfsPortId.setStatus('current')
if mibBuilder.loadTexts: sysDfsPortId.setDescription('Port identifier to which scheduling algorightm is set.')
sysDfsCoSqAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 83, 1, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("strictPriority", 1), ("weightedRoundRobin", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDfsCoSqAlgorithm.setStatus('current')
if mibBuilder.loadTexts: sysDfsCoSqAlgorithm.setDescription('Sets the packet scheduling algorithm for the port The default is strictPriority(1).')
class InetAddressIPv4(TextualConvention, OctetString):
    description = 'Represents an IPv4 network address: octets contents encoding 1-4 IP address network-byte order The corresponding InetAddressType value is ipv4(1).'
    status = 'current'
    displayHint = '1d.1d.1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class InetAddressIPv6(TextualConvention, OctetString):
    description = 'Represents an IPv6 network address: octets contents encoding 1-16 IPv6 address network-byte order 17-20 scope identifier network-byte order The corresponding InetAddressType value is ipv6(2). The scope identifier (bytes 17-20) MUST NOT be present for global IPv6 addresses. For non-global IPv6 addresses (e.g. link-local or site-local addresses), the scope identifier MUST always be present. It contains a link identifier for link-local and a site identifier for site-local IPv6 addresses. The scope identifier MUST disambiguate identical address values. For link-local addresses, the scope identifier will typically be the interface index (ifIndex as defined in the IF-MIB, RFC 2233) of the interface on which the address is configured. The scope identifier may contain the special value 0 which refers to the default scope. The default scope may be used in cases where the valid scope identifier is not known (e.g., a management application needs to write a site-local InetAddressIPv6 address without knowing the site identifier value). The default scope SHOULD NOT be used as an easy way out in cases where the scope identifier for a non-global IPv6 is known.'
    status = 'current'
    displayHint = '2x:2x:2x:2x:2x:2x:2x:2x%4d'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )
class InetAddressDNS(TextualConvention, OctetString):
    description = 'Represents a DNS domain name. The name SHOULD be fully qualified whenever possible. The corresponding InetAddressType is dns(16). The DESCRIPTION clause of InetAddress objects that may have InetAddressDNS values must fully describe how (and when) such names are to be resolved to IP addresses.'
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

sysSyslogGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1))
sysSyslogLogs = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 2))
sysSyslogLogging = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogLogging.setStatus('current')
if mibBuilder.loadTexts: sysSyslogLogging.setDescription('This object is for enabling or disabling syslog alert features in the system.')
sysSyslogTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogTimeStamp.setStatus('current')
if mibBuilder.loadTexts: sysSyslogTimeStamp.setDescription('This object is for enabling or disabling timestamp option. When enabled, the messages (log alert messages) will hold the time stamp information. When disabled, the time stamp information will not be carried with the messages sent to the log servers.')
sysSyslogSysBuffers = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogSysBuffers.setStatus('current')
if mibBuilder.loadTexts: sysSyslogSysBuffers.setDescription('Number of log buffers to be allocated in the system')
sysSyslogClearLog = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogClearLog.setStatus('current')
if mibBuilder.loadTexts: sysSyslogClearLog.setDescription("Clears the buffered logs. This object is set to 'false' by default. When set to 'True', the buffered logs will be cleared and the value of this object will become 'false' again.")
sysSyslogConfigTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 6), )
if mibBuilder.loadTexts: sysSyslogConfigTable.setStatus('current')
if mibBuilder.loadTexts: sysSyslogConfigTable.setDescription('A table for configuring module specific log levels.')
sysSyslogConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 6, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSyslogConfigModule"))
if mibBuilder.loadTexts: sysSyslogConfigEntry.setStatus('current')
if mibBuilder.loadTexts: sysSyslogConfigEntry.setDescription('An entry containing logging level options for a particular module.')
sysSyslogConfigModule = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: sysSyslogConfigModule.setStatus('current')
if mibBuilder.loadTexts: sysSyslogConfigModule.setDescription('Specifies the module for which the log level option has to be configured.')
sysSyslogConfigLogLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("emergency", 0), ("alert", 1), ("critical", 2), ("error", 3), ("warning", 4), ("notice", 5), ("info", 6), ("debug", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogConfigLogLevel.setStatus('current')
if mibBuilder.loadTexts: sysSyslogConfigLogLevel.setDescription('Specifies the log level option to be set for a specific module.')
sysSyslogFacility = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(128, 136, 144, 152, 160, 168, 176, 184))).clone(namedValues=NamedValues(("local0", 128), ("local1", 136), ("local2", 144), ("local3", 152), ("local4", 160), ("local5", 168), ("local6", 176), ("local7", 184))).clone('local0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogFacility.setStatus('current')
if mibBuilder.loadTexts: sysSyslogFacility.setDescription('The Syslog standard facilities. The facility to be used when sending Syslog messages to this server.')
sysSyslogLogSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 89, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSyslogLogSrvAddr.setStatus('current')
if mibBuilder.loadTexts: sysSyslogLogSrvAddr.setDescription('Specifies the syslog server IP to be used for remote logging. When configured, a new socket will be opened for this address. When the address is changed, the socket opened for the previous address will be closed and a new socket will be opened for this address.')
sysPortSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1))
sysPortSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1, 1), )
if mibBuilder.loadTexts: sysPortSecurityTable.setStatus('current')
if mibBuilder.loadTexts: sysPortSecurityTable.setDescription('A list of port default priority Entries.')
sysPortSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysPortSecurityIndex"))
if mibBuilder.loadTexts: sysPortSecurityEntry.setStatus('current')
if mibBuilder.loadTexts: sysPortSecurityEntry.setDescription('A list of port default priority priorities.')
sysPortSecurityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: sysPortSecurityIndex.setStatus('current')
if mibBuilder.loadTexts: sysPortSecurityIndex.setDescription('The interface index for which the configuration in this entry applies.')
sysPortSecurityState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortSecurityState.setStatus('current')
if mibBuilder.loadTexts: sysPortSecurityState.setDescription('The security state on specific port.')
sysPortSecurityMLA = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 95, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortSecurityMLA.setStatus('current')
if mibBuilder.loadTexts: sysPortSecurityMLA.setDescription('The max. learning number of MAC entries on specific port')
sysSslGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 1))
sysSslCiphers = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 2))
sysSslSecureHttpStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSslSecureHttpStatus.setStatus('current')
if mibBuilder.loadTexts: sysSslSecureHttpStatus.setDescription('This object is for enabling or disabling secure HTTP in the system.')
sysSslPort = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(443)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSslPort.setStatus('current')
if mibBuilder.loadTexts: sysSslPort.setDescription('This object is to configure the SSL port.')
sysSslTrace = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSslTrace.setStatus('current')
if mibBuilder.loadTexts: sysSslTrace.setDescription('Set the trace level for SSL. BIT 0 - Initialisation and Shutdown Trace. BIT 1 - Management trace. BIT 2 - Data path trace. BIT 3 - Control Plane trace. BIT 4 - Packet Dump. BIT 5 - OS Resource trace. BIT 6 - All Failure trace (All failures including Packet Validation) BIT 7 - Buffer Trace. Note:BIT 0 - Least significant bit BIT 7 - Most significant bit For example,setting the trace level to the value -0001 0101, will enable Init-Shutdown, data path and packet dump trace levels. Setting all the bits will enable all the trace levels and resetting them will disable all the trace levels.')
sysSslCipherList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSslCipherList.setStatus('current')
if mibBuilder.loadTexts: sysSslCipherList.setDescription('This object is to configure the cipher-suites list. This field is a bit mask, setting a bit indicates that the corresponding cipher-list will be involved in the server authentication. BIT 0 - RSA-NULL-MD5 BIT 1 - RSA-NULL-SHA1 BIT 2 - RSA-DES-SHA1 BIT 3 - RSA-3DES-SHA1 BIT 4 - DH-RSA-DES-SHA1 BIT 5 - DH-RSA-3DES-SHA1 BIT 6 - RSA-EXP1024-DES-SHA1 Note:BIT 0 - Least significant bit BIT 6 - Most significant bit For example,setting the cipher list to the value - 001 0101, will include RSA-NULL-MD5, RSA-DES-SHA1 and DH-RSA-DES-SHA1 as cipher-list for authentication.')
sysSslDefaultCipherList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 96, 2, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSslDefaultCipherList.setStatus('current')
if mibBuilder.loadTexts: sysSslDefaultCipherList.setDescription("This object is to set the default cipher-suites list in 'sysSslCipherList'. Setting DefaultCipherList to TRUE would set the following cipher-list for authentication: - RSA_3DES_SHA1 - RSA_DES_SHA1 - RSA_EXP1024_DES_SHA1 The value of this object reverts back to FALSE once the default cipher list is set.")
sysSshGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1))
sysSshVersionCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshVersionCompatibility.setStatus('current')
if mibBuilder.loadTexts: sysSshVersionCompatibility.setDescription('This object is to configure the SSH version compatibility mode. When set to TRUE, both SSH version-1 and SSH Version-2 will be supported. When set to FALSE, SSH version-2 only will be supported. By default SSH version-2 is supported.')
sysSshCipherList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshCipherList.setStatus('current')
if mibBuilder.loadTexts: sysSshCipherList.setDescription('This object is to configure the cipher-suites list. This object takes values as bit mask. Setting a bit indicates that the corresponding cipher-list will be used for Encryption. The value of each bit position is as given below with bit 0 being the least significant bit: BIT 1 - DES-CBC BIT 0 - 3DES-CBC')
sysSshMacList = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshMacList.setStatus('current')
if mibBuilder.loadTexts: sysSshMacList.setDescription('This object is to configure the MAC-list. This object takes values as bit mask. Setting a bit indicates that the corresponding MAC-list will be used for authentication. The value of each bit position is as given below with bit 0 being the least significant bit: BIT 1 - HMAC-MD5 BIT 0 - HMAC-SHA1')
sysSshTrace = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshTrace.setStatus('current')
if mibBuilder.loadTexts: sysSshTrace.setDescription('Set the trace level for SSH. BIT 0 - Initialisation and Shutdown Trace. BIT 1 - Management trace. BIT 2 - Data path trace. BIT 3 - Control Plane trace. BIT 4 - Packet Dump. BIT 5 - OS Resource trace. BIT 6 - All Failure trace (All failures including Packet Validation) BIT 7 - Buffer Trace. Note:BIT 0 - Least significant bit BIT 7 - Most significant bit For example,setting the trace level to the value -0001 0101, will enable Init-Shutdown, data path and packet dump trace levels. Setting all the bits will enable all the trace levels and resetting them will disable all the trace levels.')
sysSshStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 97, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshStatus.setStatus('current')
if mibBuilder.loadTexts: sysSshStatus.setDescription('This object is for enabling or disabling ssh in the system.')
sysSntpGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1))
sysSntpTzGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2))
sysSntpStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpStatus.setStatus('current')
if mibBuilder.loadTexts: sysSntpStatus.setDescription('This object is for enabling or disabling SNTP Client feature in the system.')
sysSntpPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpPollInterval.setStatus('current')
if mibBuilder.loadTexts: sysSntpPollInterval.setDescription('The SNTP server polling interval in seconds.')
sysSntpTimeSeconds = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTimeSeconds.setStatus('current')
if mibBuilder.loadTexts: sysSntpTimeSeconds.setDescription('This object is for setting the system time in seconds from Epoch (00:00:00 UTC, January 1, 1970).')
sysSntpPrimarySrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpPrimarySrvAddr.setStatus('current')
if mibBuilder.loadTexts: sysSntpPrimarySrvAddr.setDescription('Specifies the primary SNTP server IP to be used for network time syncronization. When configured, a new socket will be opened for this address. When the address is changed, the socket opened for the previous address will be closed and a new socket will be opened for this address.')
sysSntpSecondSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpSecondSrvAddr.setStatus('current')
if mibBuilder.loadTexts: sysSntpSecondSrvAddr.setDescription('Specifies the secondary SNTP server IP to be used for network time syncronization. If the primary SNTP server fail, the system will try secondary SNTP server. When configured, a new socket will be opened for this address. When the address is changed, the socket opened for the previous address will be closed and a new socket will be opened for this address.')
sysSntpTimeZoneMappingIndex = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTimeZoneMappingIndex.setStatus('current')
if mibBuilder.loadTexts: sysSntpTimeZoneMappingIndex.setDescription('This object is used for distinguishing areas in the same time zone.')
sysSntpTzDSTStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTStatus.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTStatus.setDescription('This object is for enabling or disabling Time Zone Daylight Saving Time feature in the system.')
sysSntpTzMinutesWest = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzMinutesWest.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzMinutesWest.setDescription('Specifies the Time Zone Offset from GMT in +/- Minutes.')
sysSntpTzDSTStartMon = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTStartMon.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTStartMon.setDescription('The start month of Daylight Saving Time.')
sysSntpTzDSTStartDay = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTStartDay.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTStartDay.setDescription('The start day of Daylight Saving Time.')
sysSntpTzDSTStartHour = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTStartHour.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTStartHour.setDescription('The start hour of Daylight Saving Time.')
sysSntpTzDSTStartMinute = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTStartMinute.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTStartMinute.setDescription('The start minutes of Daylight Saving Time.')
sysSntpTzDSTEndMon = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTEndMon.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTEndMon.setDescription('The end month of Daylight Saving Time.')
sysSntpTzDSTEndDay = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTEndDay.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTEndDay.setDescription('The end day of Daylight Saving Time.')
sysSntpTzDSTEndHour = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTEndHour.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTEndHour.setDescription('The end hour of Daylight Saving Time.')
sysSntpTzDSTEndMinute = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTEndMinute.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTEndMinute.setDescription('The end minutes of Daylight Saving Time.')
sysSntpTzDSTForwardOffset = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 99, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(30, 60))).clone(namedValues=NamedValues(("halfHour", 30), ("oneHour", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSntpTzDSTForwardOffset.setStatus('current')
if mibBuilder.loadTexts: sysSntpTzDSTForwardOffset.setDescription('The adjusted time of Daylight Saving Time.')
sysDscpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1))
sysDscpTypeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2))
sysDscpEnable = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpEnable.setStatus('current')
if mibBuilder.loadTexts: sysDscpEnable.setDescription('Enable / Disable DiffServ function')
sysDscpType01 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType01.setStatus('current')
if mibBuilder.loadTexts: sysDscpType01.setDescription('DiffServ Type 01 : IP ToS value = 0')
sysDscpType02 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType02.setStatus('current')
if mibBuilder.loadTexts: sysDscpType02.setDescription('DiffServ Type 02 : IP ToS value = 4')
sysDscpType03 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType03.setStatus('current')
if mibBuilder.loadTexts: sysDscpType03.setDescription('DiffServ Type 03 : IP ToS value = 8')
sysDscpType04 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType04.setStatus('current')
if mibBuilder.loadTexts: sysDscpType04.setDescription('DiffServ Type 04 : IP ToS value = 12')
sysDscpType05 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType05.setStatus('current')
if mibBuilder.loadTexts: sysDscpType05.setDescription('DiffServ Type 05 : IP ToS value = 16')
sysDscpType06 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType06.setStatus('current')
if mibBuilder.loadTexts: sysDscpType06.setDescription('DiffServ Type 06 : IP ToS value = 20')
sysDscpType07 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType07.setStatus('current')
if mibBuilder.loadTexts: sysDscpType07.setDescription('DiffServ Type 07 : IP ToS value = 24')
sysDscpType08 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType08.setStatus('current')
if mibBuilder.loadTexts: sysDscpType08.setDescription('DiffServ Type 08 : IP ToS value = 28')
sysDscpType09 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType09.setStatus('current')
if mibBuilder.loadTexts: sysDscpType09.setDescription('DiffServ Type 09 : IP ToS value = 32')
sysDscpType10 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType10.setStatus('current')
if mibBuilder.loadTexts: sysDscpType10.setDescription('DiffServ Type 10 : IP ToS value = 36')
sysDscpType11 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType11.setStatus('current')
if mibBuilder.loadTexts: sysDscpType11.setDescription('DiffServ Type 11 : IP ToS value = 40')
sysDscpType12 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType12.setStatus('current')
if mibBuilder.loadTexts: sysDscpType12.setDescription('DiffServ Type 12 : IP ToS value = 44')
sysDscpType13 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType13.setStatus('current')
if mibBuilder.loadTexts: sysDscpType13.setDescription('DiffServ Type 13 : IP ToS value = 48')
sysDscpType14 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType14.setStatus('current')
if mibBuilder.loadTexts: sysDscpType14.setDescription('DiffServ Type 14 : IP ToS value = 52')
sysDscpType15 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType15.setStatus('current')
if mibBuilder.loadTexts: sysDscpType15.setDescription('DiffServ Type 15 : IP ToS value = 56')
sysDscpType16 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType16.setStatus('current')
if mibBuilder.loadTexts: sysDscpType16.setDescription('DiffServ Type 16 : IP ToS value = 60')
sysDscpType17 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType17.setStatus('current')
if mibBuilder.loadTexts: sysDscpType17.setDescription('DiffServ Type 17 : IP ToS value = 64')
sysDscpType18 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType18.setStatus('current')
if mibBuilder.loadTexts: sysDscpType18.setDescription('DiffServ Type 18 : IP ToS value = 68')
sysDscpType19 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType19.setStatus('current')
if mibBuilder.loadTexts: sysDscpType19.setDescription('DiffServ Type 19 : IP ToS value = 72')
sysDscpType20 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType20.setStatus('current')
if mibBuilder.loadTexts: sysDscpType20.setDescription('DiffServ Type 20 : IP ToS value = 76')
sysDscpType21 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType21.setStatus('current')
if mibBuilder.loadTexts: sysDscpType21.setDescription('DiffServ Type 21 : IP ToS value = 80')
sysDscpType22 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType22.setStatus('current')
if mibBuilder.loadTexts: sysDscpType22.setDescription('DiffServ Type 22 : IP ToS value = 84')
sysDscpType23 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType23.setStatus('current')
if mibBuilder.loadTexts: sysDscpType23.setDescription('DiffServ Type 23 : IP ToS value = 88')
sysDscpType24 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType24.setStatus('current')
if mibBuilder.loadTexts: sysDscpType24.setDescription('DiffServ Type 24 : IP ToS value = 92')
sysDscpType25 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType25.setStatus('current')
if mibBuilder.loadTexts: sysDscpType25.setDescription('DiffServ Type 25 : IP ToS value = 96')
sysDscpType26 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType26.setStatus('current')
if mibBuilder.loadTexts: sysDscpType26.setDescription('DiffServ Type 26 : IP ToS value = 100')
sysDscpType27 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType27.setStatus('current')
if mibBuilder.loadTexts: sysDscpType27.setDescription('DiffServ Type 27 : IP ToS value = 104')
sysDscpType28 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType28.setStatus('current')
if mibBuilder.loadTexts: sysDscpType28.setDescription('DiffServ Type 28 : IP ToS value = 108')
sysDscpType29 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType29.setStatus('current')
if mibBuilder.loadTexts: sysDscpType29.setDescription('DiffServ Type 29 : IP ToS value = 112')
sysDscpType30 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType30.setStatus('current')
if mibBuilder.loadTexts: sysDscpType30.setDescription('DiffServ Type 30 : IP ToS value = 116')
sysDscpType31 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType31.setStatus('current')
if mibBuilder.loadTexts: sysDscpType31.setDescription('DiffServ Type 31 : IP ToS value = 120')
sysDscpType32 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType32.setStatus('current')
if mibBuilder.loadTexts: sysDscpType32.setDescription('DiffServ Type 32 : IP ToS value = 124')
sysDscpType33 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType33.setStatus('current')
if mibBuilder.loadTexts: sysDscpType33.setDescription('DiffServ Type 33 : IP ToS value = 128')
sysDscpType34 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType34.setStatus('current')
if mibBuilder.loadTexts: sysDscpType34.setDescription('DiffServ Type 34 : IP ToS value = 132')
sysDscpType35 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType35.setStatus('current')
if mibBuilder.loadTexts: sysDscpType35.setDescription('DiffServ Type 35 : IP ToS value = 136')
sysDscpType36 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType36.setStatus('current')
if mibBuilder.loadTexts: sysDscpType36.setDescription('DiffServ Type 36 : IP ToS value = 140')
sysDscpType37 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType37.setStatus('current')
if mibBuilder.loadTexts: sysDscpType37.setDescription('DiffServ Type 37 : IP ToS value = 144')
sysDscpType38 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType38.setStatus('current')
if mibBuilder.loadTexts: sysDscpType38.setDescription('DiffServ Type 38 : IP ToS value = 148')
sysDscpType39 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType39.setStatus('current')
if mibBuilder.loadTexts: sysDscpType39.setDescription('DiffServ Type 39 : IP ToS value = 152')
sysDscpType40 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType40.setStatus('current')
if mibBuilder.loadTexts: sysDscpType40.setDescription('DiffServ Type 40 : IP ToS value = 156')
sysDscpType41 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType41.setStatus('current')
if mibBuilder.loadTexts: sysDscpType41.setDescription('DiffServ Type 41 : IP ToS value = 160')
sysDscpType42 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType42.setStatus('current')
if mibBuilder.loadTexts: sysDscpType42.setDescription('DiffServ Type 42 : IP ToS value = 164')
sysDscpType43 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType43.setStatus('current')
if mibBuilder.loadTexts: sysDscpType43.setDescription('DiffServ Type 43 : IP ToS value = 168')
sysDscpType44 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType44.setStatus('current')
if mibBuilder.loadTexts: sysDscpType44.setDescription('DiffServ Type 44 : IP ToS value = 172')
sysDscpType45 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType45.setStatus('current')
if mibBuilder.loadTexts: sysDscpType45.setDescription('DiffServ Type 45 : IP ToS value = 176')
sysDscpType46 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType46.setStatus('current')
if mibBuilder.loadTexts: sysDscpType46.setDescription('DiffServ Type 46 : IP ToS value = 180')
sysDscpType47 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType47.setStatus('current')
if mibBuilder.loadTexts: sysDscpType47.setDescription('DiffServ Type 47 : IP ToS value = 184')
sysDscpType48 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType48.setStatus('current')
if mibBuilder.loadTexts: sysDscpType48.setDescription('DiffServ Type 48 : IP ToS value = 188')
sysDscpType49 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType49.setStatus('current')
if mibBuilder.loadTexts: sysDscpType49.setDescription('DiffServ Type 49 : IP ToS value = 192')
sysDscpType50 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType50.setStatus('current')
if mibBuilder.loadTexts: sysDscpType50.setDescription('DiffServ Type 50 : IP ToS value = 196')
sysDscpType51 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType51.setStatus('current')
if mibBuilder.loadTexts: sysDscpType51.setDescription('DiffServ Type 51 : IP ToS value = 200')
sysDscpType52 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType52.setStatus('current')
if mibBuilder.loadTexts: sysDscpType52.setDescription('DiffServ Type 52 : IP ToS value = 204')
sysDscpType53 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType53.setStatus('current')
if mibBuilder.loadTexts: sysDscpType53.setDescription('DiffServ Type 53 : IP ToS value = 208')
sysDscpType54 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType54.setStatus('current')
if mibBuilder.loadTexts: sysDscpType54.setDescription('DiffServ Type 54 : IP ToS value = 212')
sysDscpType55 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType55.setStatus('current')
if mibBuilder.loadTexts: sysDscpType55.setDescription('DiffServ Type 55 : IP ToS value = 216')
sysDscpType56 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType56.setStatus('current')
if mibBuilder.loadTexts: sysDscpType56.setDescription('DiffServ Type 56 : IP ToS value = 220')
sysDscpType57 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType57.setStatus('current')
if mibBuilder.loadTexts: sysDscpType57.setDescription('DiffServ Type 57 : IP ToS value = 224')
sysDscpType58 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType58.setStatus('current')
if mibBuilder.loadTexts: sysDscpType58.setDescription('DiffServ Type 58 : IP ToS value = 228')
sysDscpType59 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType59.setStatus('current')
if mibBuilder.loadTexts: sysDscpType59.setDescription('DiffServ Type 59 : IP ToS value = 232')
sysDscpType60 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType60.setStatus('current')
if mibBuilder.loadTexts: sysDscpType60.setDescription('DiffServ Type 60 : IP ToS value = 236')
sysDscpType61 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType61.setStatus('current')
if mibBuilder.loadTexts: sysDscpType61.setDescription('DiffServ Type 61 : IP ToS value = 240')
sysDscpType62 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType62.setStatus('current')
if mibBuilder.loadTexts: sysDscpType62.setDescription('DiffServ Type 62 : IP ToS value = 244')
sysDscpType63 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType63.setStatus('current')
if mibBuilder.loadTexts: sysDscpType63.setDescription('DiffServ Type 63 : IP ToS value = 248')
sysDscpType64 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 100, 1, 2, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("class0", 0), ("class1", 1), ("class2", 2), ("class3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDscpType64.setStatus('current')
if mibBuilder.loadTexts: sysDscpType64.setDescription('DiffServ Type 64 : IP ToS value = 252')
sysSnoopInst = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2))
sysSnoopVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3))
sysSnoopStats = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4))
sysSnoopInstanceGlobalTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 1), )
if mibBuilder.loadTexts: sysSnoopInstanceGlobalTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceGlobalTable.setDescription('This table contains multicast forwarding mode configuration for each instance running in the snooping switch')
sysSnoopInstanceGlobalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopInstanceGlobalInstId"))
if mibBuilder.loadTexts: sysSnoopInstanceGlobalEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceGlobalEntry.setDescription('This table contains instance number and the multicast forwarding mode configuration for the particular instance')
sysSnoopInstanceGlobalInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopInstanceGlobalInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceGlobalInstId.setDescription('Instance ID pertaining to the global configuration entry.')
sysSnoopInstanceGlobalSystemControl = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopInstanceGlobalSystemControl.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceGlobalSystemControl.setDescription("Snooping module is shutdown or started through this object. When set to 'start', resources required by the Enterprise SNOOP module is allocated and the module starts running. When set to 'shutdown', all the resources are released back to the system and the module stops running.")
sysSnoopInstanceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2), )
if mibBuilder.loadTexts: sysSnoopInstanceConfigTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceConfigTable.setDescription('This table contains global configuration of snooping for each instance running in switch')
sysSnoopInstanceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopInstanceConfigInstId"), (0, "AT-GS950-16-MIB", "sysSnoopInetAddressType"))
if mibBuilder.loadTexts: sysSnoopInstanceConfigEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceConfigEntry.setDescription('This table contains instance number, address type and the list of global configuration for the particular instance and address type')
sysSnoopInstanceConfigInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopInstanceConfigInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInstanceConfigInstId.setDescription('Instance ID pertaining to the global configuration entry. Currently only one instance is supported so it is always 1')
sysSnoopInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 2), InetAddressType())
if mibBuilder.loadTexts: sysSnoopInetAddressType.setStatus('current')
if mibBuilder.loadTexts: sysSnoopInetAddressType.setDescription('Inet Address Type corresponding to the global configuration entry. This indicates whether the row is for IGMP/MLD Snooping')
sysSnoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatus.setDescription("Enables or disables IGMP/MLD snooping in the system. When set to 'enabled', the Enterprise IGS/MLDS module starts protocol operations. When set to 'disabled', the IGS/MLDS module stops performing protocol operations.")
sysSnoopRouterPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopRouterPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopRouterPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt router port entry will be purged. For each router port learnt, this timer runs for 'RouterPortPurgeInterval' seconds.When the timer expires, the learnt router port entry is purged. However if control messages are received from the router before the timer expiry, then the timer is restarted.")
sysSnoopPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(130, 1225)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt port entry will be purged. For each port on which rsysort has been received this timer runs for 'PortPurgeInterval' seconds. This timer will be restarted whenever a rsysort message is received from a host on the specific port. If the timer expires, then , the learnt port entry will be purged from the multicast group.")
sysSnoopReportForwardInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopReportForwardInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopReportForwardInterval.setDescription("This timer is used when proxy-reporting is disabled,the switch then has to suppress multiple IGMPv2/ MLDv1 report messages for the same group from being forwarded to the router. This is the interval (in seconds) within which report messages for the same multicast group will not be forwarded. The 'ReportForwardTimer' is per multicast group. This timer is started as soon as a report message for that group is forwarded out. Within this 'ReportForwardInterval' if another report for the same group arrives, that report will not be forwarded.")
sysSnoopRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopRetryCount.setStatus('current')
if mibBuilder.loadTexts: sysSnoopRetryCount.setDescription("When the switch receives leave message on a port, it sends group specific query to check if there are any other interested receivers for the group. This attribute defines the maximum number of queries sent by the switch before deleting the port from the group membership information in the forwarding database. If the maximum retry count exceeds 'sysSnoopRetryCount', then the port will be deleted from the multicast group membership information in the forwarding database and received leave message will be forwarded onto the router ports if there are no interested receivers for the group.")
sysSnoopGrpQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopGrpQueryInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopGrpQueryInterval.setDescription("The value of this attribute defines the time period with which the switch will send group specific queries on a port to check if there are any intersted receivers. The switch will send 'sysSnoopRetryCount' queries before removing the port from the group membership information in the forwarding database.")
sysSnoopReportFwdOnAllPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allports", 1), ("rtrports", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopReportFwdOnAllPorts.setStatus('current')
if mibBuilder.loadTexts: sysSnoopReportFwdOnAllPorts.setDescription('Snooping module will forward reports only on router ports by default, to enable forwarding on all other ports this object to provide a administrative control to forward the reports on all the member ports of the VLAN')
sysSnoopOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopOperStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnoopOperStatus.setDescription('The operational status of the IGS/MLDS protocol. The value enabled(1) indicates the IGS/MLDS module is currently enabled in the system. The value disable(1) indicates the IGS/MLDS module is currently disabled in the system.')
sysSnoopSendQueryOnTopoChange = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopSendQueryOnTopoChange.setStatus('current')
if mibBuilder.loadTexts: sysSnoopSendQueryOnTopoChange.setDescription("The Snooping Switch can be configured to send IGMP/MLD General queries on all non router ports when spanning tree topology change occurs in a network. If the spanning tree mode is RSTP, IGMP/MLD general queries will be sent on all the non router ports present in the switch.If the spanning tree mode is MSTP, IGMP/MLD general queries will be sent on all the non router ports of the VLAN mapped for the MSTP instance.When this object is set to 'enabled' ,the switch will generate general query messages")
sysSnoopQuerierQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopQuerierQueryInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopQuerierQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier. A switch should be configured as a querier for a VLAN only when there are no queriers in the network.')
sysSnoopVlanMcastMacFwdTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1), )
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdTable.setDescription("This table contains MAC based multicast forwarding information. This information is applicable only if the 'sysSnoopMcastForwardingMode' is set to 'macbased' ")
sysSnoopVlanMcastMacFwdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopVlanMcastMacFwdInstId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanMcastMacFwdVlanId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanMcastMacFwdInetAddressType"), (0, "AT-GS950-16-MIB", "sysSnoopVlanMcastMacFwdGroupAddress"))
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdEntry.setDescription('This table contains VLAN ID, multicast group MAC address and the list of ports onto which the multicast data packets for group should be forwarded.')
sysSnoopVlanMcastMacFwdInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdInstId.setDescription('Instance ID pertaining to the Multicast forwarding entry. Currently only one instance is supported so it is always 1')
sysSnoopVlanMcastMacFwdVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdVlanId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdVlanId.setDescription('VLAN ID pertaining to the Multicast forwarding entry')
sysSnoopVlanMcastMacFwdInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1, 3), InetAddressType())
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdInetAddressType.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdInetAddressType.setDescription('InetAddressType pertaining to the Multicast forwarding entry')
sysSnoopVlanMcastMacFwdGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1, 4), MacAddress())
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdGroupAddress.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdGroupAddress.setDescription('Multicast group MAC address.')
sysSnoopVlanMcastMacFwdPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 1, 1, 5), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdPortList.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanMcastMacFwdPortList.setDescription('List of ports onto which the multicast data packets destined for this group will be forwarded.')
sysSnoopVlanRouterTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3), )
if mibBuilder.loadTexts: sysSnoopVlanRouterTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterTable.setDescription('This table contains the list of ports through which a router, in a particular VLAN is reachable.')
sysSnoopVlanRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopVlanRouterInstId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanRouterVlanId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanRouterInetAddressType"))
if mibBuilder.loadTexts: sysSnoopVlanRouterEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterEntry.setDescription('Contains the VLAN ID and list of ports on which routers are present in the VLAN.')
sysSnoopVlanRouterInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopVlanRouterInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterInstId.setDescription('Instance ID pertaining to the router port entry. Currently only one instance is supported so it is always 1')
sysSnoopVlanRouterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: sysSnoopVlanRouterVlanId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterVlanId.setDescription('VLAN ID of the ports through which router is reachable.')
sysSnoopVlanRouterInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3, 1, 3), InetAddressType())
if mibBuilder.loadTexts: sysSnoopVlanRouterInetAddressType.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterInetAddressType.setDescription('It indicates whether the row belongs to IGMP / MLD snooping.')
sysSnoopVlanRouterPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 3, 1, 4), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopVlanRouterPortList.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRouterPortList.setDescription('List of ports on which routers are present. These router ports are learnt through control messages received from routers, and can also be configured statically.')
sysSnoopVlanFilterTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4), )
if mibBuilder.loadTexts: sysSnoopVlanFilterTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFilterTable.setDescription('This table contains configuration of snooping on specific Vlans. This Table is valid only when VLAN is enabled in the system.')
sysSnoopVlanFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopVlanFilterInstId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanFilterVlanId"), (0, "AT-GS950-16-MIB", "sysSnoopVlanFilterInetAddressType"))
if mibBuilder.loadTexts: sysSnoopVlanFilterEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFilterEntry.setDescription('Contains snooping status , version and fast leave configuration for a specific VLAN.')
sysSnoopVlanFilterInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopVlanFilterInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFilterInstId.setDescription('Instance ID pertaining to VLAN filter table entry. Currently only one instance is supported so it is always 1')
sysSnoopVlanFilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: sysSnoopVlanFilterVlanId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFilterVlanId.setDescription('VLAN ID for which snooping configuration is to be done.')
sysSnoopVlanFilterInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 3), InetAddressType())
if mibBuilder.loadTexts: sysSnoopVlanFilterInetAddressType.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFilterInetAddressType.setDescription('Indicates whether the row belongs to IGS/MLD snooping')
sysSnoopVlanSnoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopVlanSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanSnoopStatus.setDescription('Enables or disables IGS/MLDS on that specific VLAN')
sysSnoopVlanOperatingVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2))).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopVlanOperatingVersion.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanOperatingVersion.setDescription('Indicates the operating version of the IGS/MLDS switch for a specific VLAN. The default operating mode on a specific VLAN is IGMP version 2 i.e, V2(2) or MLD version 1 i.e, V1(1)')
sysSnoopVlanFastLeave = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopVlanFastLeave.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanFastLeave.setDescription("Enables or disables fast leave for the VLAN. When it is 'disabled',on reception of a leave message the switch checks if they are any interested receivers for the group by sending a group specific query before removing the port from the forwarding table. If set to 'enabled', the switch does not send a group specific query and immediately removes the port from the forwarding table.")
sysSnoopVlanQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopVlanQuerier.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanQuerier.setDescription('Indicates whether the switch is configured as a querier in the VLAN')
sysSnoopVlanCfgQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopVlanCfgQuerier.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanCfgQuerier.setDescription("The snooping switch can be configured to send IGMP/MLD queries when IGMP/MLD routers are not present in the VLAN. When set to 'enabled' the switch will generate general query messages.")
sysSnoopVlanQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopVlanQueryInterval.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier for the VLAN. A switch should be configured as a querier for a VLAN only when there are no queriers in the network.')
sysSnoopVlanRtrPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 11), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnoopVlanRtrPortList.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRtrPortList.setDescription('List of ports which are configured statically as router ports')
sysSnoopVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 3, 4, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysSnoopVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysSnoopVlanRowStatus.setDescription("The status of a row in the VLAN filter table. By 'sysSnoopVlanRowStatus' new entries can be created in the VLAN filter table and the existing entries can be removed from the VLAN filter table")
sysSnoopStatsTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1), )
if mibBuilder.loadTexts: sysSnoopStatsTable.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsTable.setDescription('This table contains snooping statistics maintained by the switch. The statistics are maintained on a per VLAN basis.')
sysSnoopStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "sysSnoopStatsInstId"), (0, "AT-GS950-16-MIB", "sysSnoopStatsVlanId"), (0, "AT-GS950-16-MIB", "sysSnoopStatsInetAddressType"))
if mibBuilder.loadTexts: sysSnoopStatsEntry.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsEntry.setDescription('Contains snooping statistics for a particular VLAN.')
sysSnoopStatsInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: sysSnoopStatsInstId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsInstId.setDescription('Instance ID pertaining for the statistics entry. Currently only one instance is supported so it is always 1')
sysSnoopStatsVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: sysSnoopStatsVlanId.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsVlanId.setDescription('VLAN ID for which snooping statistics are displayed')
sysSnoopStatsInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 3), InetAddressType())
if mibBuilder.loadTexts: sysSnoopStatsInetAddressType.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsInetAddressType.setDescription('Indicates whether the statistics are for IGS/MLDS')
sysSnoopStatsRxGenQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsRxGenQueries.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsRxGenQueries.setDescription('Provides the statistics of General Queries received by the snooping switch.')
sysSnoopStatsRxGrpQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsRxGrpQueries.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsRxGrpQueries.setDescription('Provides the statistics of Group Specific Queries received by the snooping switch.')
sysSnoopStatsRxAsmReports = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsRxAsmReports.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsRxAsmReports.setDescription('Provides the statistics of IGMPv1/IGMPv2 Membership reports received by the snooping switch. In case of MLDS, it provides the statistics of MLDv1 membership reports.')
sysSnoopStatsRxAsmLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsRxAsmLeaves.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsRxAsmLeaves.setDescription('Provides the statistics of IGMPv2/MLDv1 Leave messages received by the snooping switch.')
sysSnoopStatsTxGenQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsTxGenQueries.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsTxGenQueries.setDescription('Provides the statistics of General Queries transmitted by the snooping switch when it is act as a querier.')
sysSnoopStatsTxGrpQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsTxGrpQueries.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsTxGrpQueries.setDescription('Provides the statistics of Group Specific Queries transmitted by the snooping switch.')
sysSnoopStatsTxAsmReports = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsTxAsmReports.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsTxAsmReports.setDescription('Provides the statistics of IGMPv1/IGMPv2 Membership reports transmitted by the snooping switch.')
sysSnoopStatsTxAsmLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsTxAsmLeaves.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsTxAsmLeaves.setDescription('Provides the statistics of IGMPv2/MLDv1 Leave messages transmitted by the snooping switch.')
sysSnoopStatsDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 105, 4, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnoopStatsDroppedPkts.setStatus('current')
if mibBuilder.loadTexts: sysSnoopStatsDroppedPkts.setDescription('Provides the number of erroneous IGMP/MLD packets dropped by the snooping switch due to failure in checksum calculation.')
class BridgeId(TextualConvention, OctetString):
    description = "The Bridge-Identifier as used in the Spanning Tree Protocol to uniquely identify a bridge. Its first two octets (in network byte order) contain a priority value and its last 6 octets contain the MAC address used to refer to a bridge in a unique fashion (typically, the numerically smallest MAC address of all ports on the bridge). Several objects in this MIB module represent values of timers used by the Spanning Tree Protocol. In this MIB, these timers have values in units of hundreths of a second (i.e. 1/100 secs). These timers, when stored in a Spanning Tree Protocol's BPDU, are in units of 1/256 seconds. Note, however, that 802.1D-1990 specifies a settable granularity of no more than 1 second for these timers. To avoid ambiguity, a data type is defined here as a textual convention and all representation of these timers in this MIB module are defined using this data type. An algorithm is also defined for converting between the different units, to ensure a timer's value is not distorted by multiple conversions."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class Timeout(TextualConvention, Integer32):
    description = 'A STP timer in units of 1/100 seconds To convert a Timeout value into a value in units of 1/256 seconds, the following algorithm should be used: b = floor( (n * 256) / 100) where: floor = quotient [ignore remainder] n is the value in 1/100 second units b is the value in 1/256 second units To convert the value from 1/256 second units back to 1/100 seconds, the following algorithm should be used: n = ceiling( (b * 100) / 256) where: ceiling = quotient [if remainder is 0], or quotient + 1 [if remainder is non-zero] n is the value in 1/100 second units b is the value in 1/256 second units Note: it is important that the arithmetic operations are done in the order specified (i.e., multiply first, divide second).'
    status = 'current'
    displayHint = 'd4'

dot1dNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 0))
dot1dBase = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1))
l2Dot1dStp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2))
dot1dSr = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 3))
dot1dTp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4))
dot1dStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5))
dot1dBaseTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1), )
if mibBuilder.loadTexts: dot1dBaseTable.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseTable.setDescription('List of per Virtual Bridge Module Parameters.')
dot1dBaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBaseContextId"))
if mibBuilder.loadTexts: dot1dBaseEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseEntry.setDescription('Virtual Bridge Rst Module Parameters.')
dot1dBaseContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1dBaseContextId.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseContextId.setDescription('Virtual Bridge number')
dot1dBaseBridgeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setReference('IEEE 802.1D-1990: Sections 6.4.1.1.3 and 3.12.5')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique. When concatenated with dot1dStpPriority a unique BridgeIdentifier is formed which is used in the Spanning Tree Protocol.')
dot1dBaseNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseNumPorts.setReference('IEEE 802.1D-1990: Section 6.4.1.1.3')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setDescription('The number of ports controlled by this bridging entity.')
dot1dBaseType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparentonly", 2), ("sourcerouteonly", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseType.setStatus('current')
if mibBuilder.loadTexts: dot1dBaseType.setDescription('Indicates what type of bridging this bridge can perform. If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.')
dot1dBasePortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2), )
if mibBuilder.loadTexts: dot1dBasePortTable.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortTable.setDescription('A table that contains generic information about every port that is associated with this bridge. Transparent, source-route, and srt ports are included.')
dot1dBasePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: dot1dBasePortEntry.setReference('IEEE 802.1D-1990: Section 6.4.2, 6.6.1')
if mibBuilder.loadTexts: dot1dBasePortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortEntry.setDescription('A list of information for each port of the bridge.')
dot1dBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1dBasePort.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePort.setDescription('The port number of the port for which this entry contains bridge management information.')
dot1dBasePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in MIB-II, for the interface corresponding to this port.')
dot1dBasePortCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortCircuit.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortCircuit.setDescription('For a port which (potentially) has the same value of dot1dBasePortIfIndex as another port on the same bridge, this object contains the name of an object instance unique to this port. For example, in the case where multiple ports correspond one- to-one with multiple X.25 virtual circuits, this value might identify an (e.g., the first) object instance associated with the X.25 virtual circuit corresponding to this port. For a port which has a unique value of dot1dBasePortIfIndex, this object can have the value { 0 0 }.')
dot1dBasePortDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setDescription('The number of frames discarded by this port due to excessive transit delay through the bridge. It is incremented by both transparent and source route bridges.')
dot1dBasePortMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setDescription('The number of frames discarded by this port due to an excessive size. It is incremented by both transparent and source route bridges.')
dot1dStpTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1), )
if mibBuilder.loadTexts: dot1dStpTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStpTable.setDescription('Table of StpScalars per virtual bridge')
dot1dStpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dStpContextId"))
if mibBuilder.loadTexts: dot1dStpEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStpEntry.setDescription('Per bridge StpScalars')
dot1dStpContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1dStpContextId.setStatus('current')
if mibBuilder.loadTexts: dot1dStpContextId.setDescription('Virtual Bridge number')
dot1dStpProtocolSpecification = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpProtocolSpecification.setStatus('current')
if mibBuilder.loadTexts: dot1dStpProtocolSpecification.setDescription("An indication of what version of the Spanning Tree Protocol is being run. The value 'decLb100(2)' indicates the DEC LANbridge 100 Spanning Tree protocol. IEEE 802.1d implementations will return 'ieee8021d(3)'. If enterprise versions of the IEEE Spanning Tree Protocol are released that are incompatible with the current version a new value will be defined.")
dot1dStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPriority.setReference('IEEE 802.1D-1990: Section 4.5.3.7')
if mibBuilder.loadTexts: dot1dStpPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID. The other (last) 6 octets of the Bridge ID are given by the value of dot1dBaseBridgeAddress.')
dot1dStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
dot1dStpTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpTopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: dot1dStpTopChanges.setStatus('current')
if mibBuilder.loadTexts: dot1dStpTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
dot1dStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.3.1')
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
dot1dStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpRootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: dot1dStpRootCost.setStatus('current')
if mibBuilder.loadTexts: dot1dStpRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
dot1dStpRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpRootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: dot1dStpRootPort.setStatus('current')
if mibBuilder.loadTexts: dot1dStpRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
dot1dStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 9), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.4')
if mibBuilder.loadTexts: dot1dStpMaxAge.setStatus('current')
if mibBuilder.loadTexts: dot1dStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
dot1dStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 10), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.5')
if mibBuilder.loadTexts: dot1dStpHelloTime.setStatus('current')
if mibBuilder.loadTexts: dot1dStpHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
dot1dStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpHoldTime.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: dot1dStpHoldTime.setStatus('current')
if mibBuilder.loadTexts: dot1dStpHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
dot1dStpForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 12), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.6')
if mibBuilder.loadTexts: dot1dStpForwardDelay.setStatus('current')
if mibBuilder.loadTexts: dot1dStpForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in each of the Listening and Learning states, which precede the Forwarding state. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. [Note that this value is the one that this bridge is currently using, in contrast to dot1dStpBridgeForwardDelay which is the value that this bridge and all others would start using if/when this bridge were to become the root.]')
dot1dStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 13), Timeout().subtype(subtypeSpec=ValueRangeConstraint(600, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.8')
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setDescription('The value that all bridges use for MaxAge when this bridge is acting as the root. Note that 802.1D-1990 specifies that the range for this parameter is related to the value of dot1dStpBridgeHelloTime. The granularity of this timer is specified by 802.1D-1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 14), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.9')
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setStatus('current')
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setDescription('The value that all bridges use for HelloTime when this bridge is acting as the root. The granularity of this timer is specified by 802.1D- 1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 1, 1, 15), Timeout().subtype(subtypeSpec=ValueRangeConstraint(400, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.10')
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setStatus('current')
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setDescription('The value that all bridges use for ForwardDelay when this bridge is acting as the root. Note that 802.1D-1990 specifies that the range for this parameter is related to the value of dot1dStpBridgeMaxAge. The granularity of this timer is specified by 802.1D-1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2), )
if mibBuilder.loadTexts: dot1dStpPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortTable.setDescription('A table that contains port-specific information for the Spanning Tree Protocol.')
dot1dStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dStpPort"))
if mibBuilder.loadTexts: dot1dStpPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortEntry.setDescription('A list of information maintained by every port about the Spanning Tree Protocol state for that port.')
dot1dStpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1dStpPort.setReference('IEEE 802.1D-1990: Section 6.8.2.1.2')
if mibBuilder.loadTexts: dot1dStpPort.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPort.setDescription('The port number of the port for which this entry contains Spanning Tree Protocol management information.')
dot1dStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortPriority.setReference('IEEE 802.1D-1990: Section 4.5.5.1')
if mibBuilder.loadTexts: dot1dStpPortPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID. The other octet of the Port ID is given by the value of dot1dStpPort.')
dot1dStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortState.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: dot1dStpPortState.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see dot1dStpPortEnable), this object will have a value of disabled(1).")
dot1dStpPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortEnable.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: dot1dStpPortEnable.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortEnable.setDescription('The enabled/disabled status of the port.')
dot1dStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortPathCost.setReference('IEEE 802.1D-1990: Section 4.5.5.3')
if mibBuilder.loadTexts: dot1dStpPortPathCost.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port. 802.1D-1990 recommends that the default value of this parameter be in inverse proportion to the speed of the attached LAN.')
dot1dStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.5.4')
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
dot1dStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
dot1dStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 8), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setReference('IEEE 802.1D-1990: Section 4.5.5.6')
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
dot1dStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setReference('IEEE 802.1D-1990: Section 4.5.5.7')
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
dot1dStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
dot1dTpTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 1), )
if mibBuilder.loadTexts: dot1dTpTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTpTable.setDescription('Table of Tp per virtual bridge')
dot1dTpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBaseContextId"))
if mibBuilder.loadTexts: dot1dTpEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTpEntry.setDescription('Per bridge TpScalars')
dot1dTpLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setDescription('The total number of Forwarding Database entries, which have been or would have been learned, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
dot1dTpAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTpAgingTime.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpAgingTime.setStatus('current')
if mibBuilder.loadTexts: dot1dTpAgingTime.setDescription('The timeout period in seconds for aging out dynamically learned forwarding information. 802.1D-1990 recommends a default of 300 seconds.')
dot1dTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 2), )
if mibBuilder.loadTexts: dot1dTpFdbTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTpFdbTable.setDescription('A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame. This table maintains context ID as one more index to support Multiple Instances.')
dot1dTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBaseContextId"), (0, "AT-GS950-16-MIB", "dot1dTpFdbAddress"))
if mibBuilder.loadTexts: dot1dTpFdbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the bridge has some forwarding and/or filtering information.')
dot1dTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 2, 1, 1), MacAddress())
if mibBuilder.loadTexts: dot1dTpFdbAddress.setReference('IEEE 802.1D-1990: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: dot1dTpFdbAddress.setStatus('current')
if mibBuilder.loadTexts: dot1dTpFdbAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
dot1dTpFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpFdbPort.setStatus('current')
if mibBuilder.loadTexts: dot1dTpFdbPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance of dot1dTpFdbAddress has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address (e.g. in the dot1dStaticTable). Implementors are encouraged to assign the port value to this object whenever it is learned even for addresses for which the corresponding value of dot1dTpFdbStatus is not learned(3).")
dot1dTpFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpFdbStatus.setStatus('current')
if mibBuilder.loadTexts: dot1dTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) : none of the following. This would include the case where some other MIB object (not the corresponding instance of dot1dTpFdbPort, nor an entry in the dot1dStaticTable) is being used to determine if and how frames addressed to the value of the corresponding instance of dot1dTpFdbAddress are being forwarded. invalid(2) : this entry is not longer valid (e.g., it was learned but has since aged-out), but has not yet been flushed from the table. learned(3) : the value of the corresponding instance of dot1dTpFdbPort was learned, and is being used. self(4) : the value of the corresponding instance of dot1dTpFdbAddress represents one of the bridge's addresses. The corresponding instance of dot1dTpFdbPort indicates which of the bridge's ports has this address. mgmt(5) : the value of the corresponding instance of dot1dTpFdbAddress is also the value of an existing instance of dot1dStaticAddress.")
dot1dTpPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3), )
if mibBuilder.loadTexts: dot1dTpPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
dot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortEntry.setDescription('A list of information for each port of a transparent bridge.')
dot1dTpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1dTpPort.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPort.setDescription('The port number of the port for which this entry contains Transparent bridging management information.')
dot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
dot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
dot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
dot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
dot1dStaticTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1), )
if mibBuilder.loadTexts: dot1dStaticTable.setReference('IEEE 802.1D-1990: Section 6.7.2')
if mibBuilder.loadTexts: dot1dStaticTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticTable.setDescription('A table containing filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific destination addresses are allowed to be forwarded. The value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for unicast and for group/broadcast addresses.This table maintains context ID as one more index to support Multiple Instances.')
dot1dStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBaseContextId"), (0, "AT-GS950-16-MIB", "dot1dStaticAddress"), (0, "AT-GS950-16-MIB", "dot1dStaticReceivePort"))
if mibBuilder.loadTexts: dot1dStaticEntry.setReference('IEEE 802.1D-1990: Section 6.7.2')
if mibBuilder.loadTexts: dot1dStaticEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticEntry.setDescription('Filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from a specific port and containing a specific destination address are allowed to be forwarded.')
dot1dStaticAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: dot1dStaticAddress.setReference('IEEE 802.1D-1990: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: dot1dStaticAddress.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object can take the value of a unicast address, a group address or the broadcast address.")
dot1dStaticReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1dStaticReceivePort.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticReceivePort.setDescription("Either the value '0', or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.")
dot1dStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1dStaticRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticRowStatus.setDescription("This object indicates the status of the AllowedToGoTo PortList to which a frame with a specific unicast address will be flooded in the event that it has not been learned. To fill the AllowedToGoTo portlist, we have to set the rowstatus as 'NOT_IN_SERVICE' and set the appropriate port in the dot1dStaticAllowedToGoTable and set the rowstatus as 'ACTIVE' to make the portlist available.")
dot1dStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStaticStatus.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticStatus.setDescription('This object indicates the status of this entry. The default value is permanent(3). other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
dot1dStaticAllowedToGoTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 2), )
if mibBuilder.loadTexts: dot1dStaticAllowedToGoTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticAllowedToGoTable.setDescription('A table containing the information of AllowedToGoTo ports for each static unicast entry. This table maintains context ID as one more index to support Multiple Instances.')
dot1dStaticAllowedToGoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBaseContextId"), (0, "AT-GS950-16-MIB", "dot1dStaticAddress"), (0, "AT-GS950-16-MIB", "dot1dStaticReceivePort"), (0, "AT-GS950-16-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dStaticAllowedToGoEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticAllowedToGoEntry.setDescription('Information about a port, Whether it is an AllowedToGoTo member or not.')
dot1dStaticAllowedIsMember = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 5, 2, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStaticAllowedIsMember.setStatus('current')
if mibBuilder.loadTexts: dot1dStaticAllowedIsMember.setDescription('Indicates whether the port is an allowedToGoTo member.')
newRoot = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 0, 1))
if mibBuilder.loadTexts: newRoot.setStatus('current')
if mibBuilder.loadTexts: newRoot.setDescription('The newRoot trap indicates that the sending agent has become the new root of the Spanning Tree; the trap is sent by a bridge soon after its election as the new root, e.g., upon expiration of the Topology Change Timer immediately subsequent to its election. Implementation of this trap is optional.')
topologyChange = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 0, 2))
if mibBuilder.loadTexts: topologyChange.setStatus('current')
if mibBuilder.loadTexts: topologyChange.setDescription('A topologyChange trap is sent by a bridge when any of its configured ports transitions from the Learning state to the Forwarding state, or from the Forwarding state to the Blocking state. The trap is not sent if a newRoot trap is sent for the same transition. Implementation of this trap is optional.')
dot1dStpExtTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 3), )
if mibBuilder.loadTexts: dot1dStpExtTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStpExtTable.setDescription('Table of ExtStpScalars per Virtual Context.')
dot1dStpExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 3, 1), )
dot1dStpEntry.registerAugmentions(("AT-GS950-16-MIB", "dot1dStpExtEntry"))
dot1dStpExtEntry.setIndexNames(*dot1dStpEntry.getIndexNames())
if mibBuilder.loadTexts: dot1dStpExtEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStpExtEntry.setDescription('Per Virtual Context Stp Scalars')
dot1dStpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2))).clone('rstp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpVersion.setReference('IEEE 802.1w clause 14.8.1, 17.12, 17.16.1')
if mibBuilder.loadTexts: dot1dStpVersion.setStatus('current')
if mibBuilder.loadTexts: dot1dStpVersion.setDescription("The version of Spanning Tree Protocol the bridge is currently running. The value 'stpCompatible(0)' indicates the Spanning Tree Protocol specified in IEEE 802.1D and 'rstp(2)' indicates the Rapid Spanning Tree Protocol specified in IEEE 802.1w. New value may be defined as future versions of the protocol become available.")
dot1dStpTxHoldCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpTxHoldCount.setReference('IEEE 802.1w clause 17.16.6')
if mibBuilder.loadTexts: dot1dStpTxHoldCount.setStatus('current')
if mibBuilder.loadTexts: dot1dStpTxHoldCount.setDescription('The value used by the Port Transmit state machine to limit the maximum transmission rate.')
dot1dStpPathCostDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stp8021d1998", 1), ("stp8021t2001", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPathCostDefault.setReference('IEEE 802.1D & 802.1t Table 8-5')
if mibBuilder.loadTexts: dot1dStpPathCostDefault.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPathCostDefault.setDescription('The version of the Spanning Tree default Path Costs that are to be used by this Bridge. A value of 8021d1998(1) uses the 16-bit default Path Costs from IEEE Std. 802.1D-1998. A value of stp8021t2001(2) uses the 32-bit default Path Costs from IEEE Std. 802.1t.')
dot1dStpExtPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4), )
if mibBuilder.loadTexts: dot1dStpExtPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1dStpExtPortTable.setDescription('A table that contains port-specific Rapid Spanning Tree information.')
dot1dStpExtPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1), )
dot1dStpPortEntry.registerAugmentions(("AT-GS950-16-MIB", "dot1dStpExtPortEntry"))
dot1dStpExtPortEntry.setIndexNames(*dot1dStpPortEntry.getIndexNames())
if mibBuilder.loadTexts: dot1dStpExtPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dStpExtPortEntry.setDescription('A list of Rapid Spanning Tree information maintained by each port.')
dot1dStpPortProtocolMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortProtocolMigration.setReference('IEEE 802.1w clause 14.8.2.4, 17.18.10, 17.26')
if mibBuilder.loadTexts: dot1dStpPortProtocolMigration.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortProtocolMigration.setDescription('When operating in RSTP (version 2) mode, writing TRUE(1) to this object forces this port to transmit RSTP BPDUs. Any other operation on this object has no effect and it always returns FALSE(2) when read.')
dot1dStpPortAdminEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortAdminEdgePort.setReference('IEEE 802.1t clause 14.8.2, 18.3.3')
if mibBuilder.loadTexts: dot1dStpPortAdminEdgePort.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortAdminEdgePort.setDescription('The administrative value of the Edge Port parameter. A value of TRUE(1) indicates that this port should be assumed as an edge-port and a value of FALSE(2) indicates that this port should be assumed as a non-edge-port.')
dot1dStpPortOperEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortOperEdgePort.setReference('IEEE 802.1t clause 14.8.2, 18.3.4')
if mibBuilder.loadTexts: dot1dStpPortOperEdgePort.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortOperEdgePort.setDescription('The operational value of the Edge Port parameter. The object is initialized to the value of dot1dStpPortAdminEdgePort and is set FALSE on reception of a BPDU.')
dot1dStpPortAdminPointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("forceTrue", 0), ("forceFalse", 1), ("auto", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortAdminPointToPoint.setReference('IEEE 802.1w clause 6.4.3, 6.5, 14.8.2')
if mibBuilder.loadTexts: dot1dStpPortAdminPointToPoint.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortAdminPointToPoint.setDescription('The administrative point-to-point status of the LAN segment attached to this port. A value of forceTrue(0) indicates that this port should always be treated as if it is connected to a point-to-point link. A value of forceFalse(1) indicates that this port should be treated as having a shared media connection. A value of auto(2) indicates that this port is considered to have a point-to-point link if it is an Aggregator and all of its members are aggregatable, or if the MAC entity is configured for full duplex operation, either through auto-negotiation or by management means.')
dot1dStpPortOperPointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 2, 4, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortOperPointToPoint.setReference('IEEE 802.1w clause 6.4.3, 6.5, 14.8.2')
if mibBuilder.loadTexts: dot1dStpPortOperPointToPoint.setStatus('current')
if mibBuilder.loadTexts: dot1dStpPortOperPointToPoint.setDescription('The operational point-to-point status of the LAN segment attached to this port. It indicates whether a port is considered to have a point-to-point connection or not. The value is determined by management or by auto-detection, as described in the dot1dStpPortAdminPointToPoint object.')
class EnabledStatus(TextualConvention, Integer32):
    description = 'A simple status value for the object.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

dot1dMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1))
dot1dExtBase = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1))
dot1dPriority = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2))
dot1dGarp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3))
dot1dConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2))
dot1dGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1))
dot1dCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 2))
dot1dExtBaseTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1), )
if mibBuilder.loadTexts: dot1dExtBaseTable.setStatus('current')
if mibBuilder.loadTexts: dot1dExtBaseTable.setDescription('List of dot1dExtBase group objects that can be configured per virtual context in the system.')
dot1dExtBaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBridgeContextId"))
if mibBuilder.loadTexts: dot1dExtBaseEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dExtBaseEntry.setDescription('dot1dExtBase group objects per virtual context.')
dot1dBridgeContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1dBridgeContextId.setStatus('current')
if mibBuilder.loadTexts: dot1dBridgeContextId.setDescription('Identifies the virtual context.')
dot1dDeviceCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1, 1, 2), Bits().clone(namedValues=NamedValues(("dot1dExtendedFilteringServices", 0), ("dot1dTrafficClasses", 1), ("dot1qStaticEntryIndividualPort", 2), ("dot1qIVLCapable", 3), ("dot1qSVLCapable", 4), ("dot1qHybridCapable", 5), ("dot1qConfigurablePvidTagging", 6), ("dot1dLocalVlanCapable", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dDeviceCapabilities.setReference('ISO/IEC 15802-3 Section 5.2, IEEE 802.1Q/D11 Section 5.2, 12.10.1.1.3/b/2')
if mibBuilder.loadTexts: dot1dDeviceCapabilities.setStatus('current')
if mibBuilder.loadTexts: dot1dDeviceCapabilities.setDescription('Indicates the optional parts of IEEE 802.1D and 802.1Q that are implemented by this device and are manageable through this MIB. Capabilities that are allowed on a per-port basis are indicated in dot1dPortCapabilities.')
dot1dTrafficClassesEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTrafficClassesEnabled.setStatus('current')
if mibBuilder.loadTexts: dot1dTrafficClassesEnabled.setDescription('The value true(1) indicates that Traffic Classes are enabled on this bridge. When false(2), the bridge operates with a single priority level for all traffic.')
dot1dGmrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 1, 1, 4), EnabledStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dGmrpStatus.setStatus('current')
if mibBuilder.loadTexts: dot1dGmrpStatus.setDescription('The administrative status requested by management for GMRP. The value enabled(1) indicates that GMRP should be enabled on this device, in all VLANs, on all ports for which it has not been specifically disabled. When disabled(2), GMRP is disabled, in all VLANs and on all ports, and all GMRP packets will be forwarded transparently. This object affects both Applicant and Registrar state machines. A transition from disabled(2) to enabled(1) will cause a reset of all GMRP state machines on all ports. The value of this object MUST be retained across reinitializations of the management system.')
dot1dPortCapabilitiesTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 2), )
if mibBuilder.loadTexts: dot1dPortCapabilitiesTable.setStatus('current')
if mibBuilder.loadTexts: dot1dPortCapabilitiesTable.setDescription('A table that contains capabilities information about every port that is associated with this bridge.')
dot1dPortCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 2, 1), )
dot1dBasePortEntry.registerAugmentions(("AT-GS950-16-MIB", "dot1dPortCapabilitiesEntry"))
dot1dPortCapabilitiesEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: dot1dPortCapabilitiesEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dPortCapabilitiesEntry.setDescription('A set of capabilities information about this port indexed by dot1dBasePort.')
dot1dPortCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 1, 2, 1, 1), Bits().clone(namedValues=NamedValues(("dot1qDot1qTagging", 0), ("dot1qConfigurableAcceptableFrameTypes", 1), ("dot1qIngressFiltering", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortCapabilities.setReference('ISO/IEC 15802-3 Section 5.2, IEEE 802.1Q/D11 Section 5.2')
if mibBuilder.loadTexts: dot1dPortCapabilities.setStatus('current')
if mibBuilder.loadTexts: dot1dPortCapabilities.setDescription('Indicates the parts of IEEE 802.1D and 802.1Q that are optional on a per-port basis that are implemented by this device and are manageable through this MIB.')
dot1dPortPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 1), )
if mibBuilder.loadTexts: dot1dPortPriorityTable.setStatus('current')
if mibBuilder.loadTexts: dot1dPortPriorityTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
dot1dPortPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 1, 1), )
dot1dBasePortEntry.registerAugmentions(("AT-GS950-16-MIB", "dot1dPortPriorityEntry"))
dot1dPortPriorityEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: dot1dPortPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dPortPriorityEntry.setDescription('A list of Default User Priorities for each port of a transparent bridge. This is indexed by dot1dBasePort.')
dot1dPortDefaultUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortDefaultUserPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dPortDefaultUserPriority.setDescription('The default ingress User Priority for this port. This only has effect on media, such as Ethernet, that do not support native User Priority.')
dot1dPortNumTrafficClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortNumTrafficClasses.setStatus('current')
if mibBuilder.loadTexts: dot1dPortNumTrafficClasses.setDescription('The number of egress traffic classes supported on this port. This object may optionally be read-only. The value of this object MUST be retained across reinitializations of the management system.')
dot1dUserPriorityRegenTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 2), )
if mibBuilder.loadTexts: dot1dUserPriorityRegenTable.setReference('ISO/IEC 15802-3 Section 6.4')
if mibBuilder.loadTexts: dot1dUserPriorityRegenTable.setStatus('current')
if mibBuilder.loadTexts: dot1dUserPriorityRegenTable.setDescription('A list of Regenerated User Priorities for each received User Priority on each port of a bridge. The Regenerated User Priority value may be used to index the Traffic Class Table for each input port. This only has effect on media that support native User Priority. The default values for Regenerated User Priorities are the same as the User Priorities.')
dot1dUserPriorityRegenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBasePort"), (0, "AT-GS950-16-MIB", "dot1dUserPriority"))
if mibBuilder.loadTexts: dot1dUserPriorityRegenEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dUserPriorityRegenEntry.setDescription('A mapping of incoming User Priority to a Regenerated User Priority.')
dot1dUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: dot1dUserPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dUserPriority.setDescription('The User Priority for a frame received on this port.')
dot1dRegenUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dRegenUserPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dRegenUserPriority.setDescription('The Regenerated User Priority that the incoming User Priority is mapped to for this port. The value of this object MUST be retained across reinitializations of the management system.')
dot1dTrafficClassTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 3), )
if mibBuilder.loadTexts: dot1dTrafficClassTable.setReference('ISO/IEC 15802-3 Table 7-2')
if mibBuilder.loadTexts: dot1dTrafficClassTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTrafficClassTable.setDescription('A table mapping evaluated User Priority to Traffic Class, for forwarding by the bridge. Traffic class is a number in the range (0..(dot1dPortNumTrafficClasses-1)).')
dot1dTrafficClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBasePort"), (0, "AT-GS950-16-MIB", "dot1dTrafficClassPriority"))
if mibBuilder.loadTexts: dot1dTrafficClassEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTrafficClassEntry.setDescription('User Priority to Traffic Class mapping.')
dot1dTrafficClassPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: dot1dTrafficClassPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dTrafficClassPriority.setDescription('The Priority value determined for the received frame. This value is equivalent to the priority indicated in the tagged frame received, or one of the evaluated priorities, determined according to the media-type. For untagged frames received from Ethernet media, this value is equal to the dot1dPortDefaultUserPriority value for the ingress port. For untagged frames received from non-Ethernet media, this value is equal to the dot1dRegenUserPriority value for the ingress port and media-specific user priority.')
dot1dTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTrafficClass.setStatus('current')
if mibBuilder.loadTexts: dot1dTrafficClass.setDescription('The Traffic Class the received frame is mapped to.')
dot1dPortOutboundAccessPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 4), )
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityTable.setReference('ISO/IEC 15802-3 Table 7-3')
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityTable.setStatus('current')
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityTable.setDescription('A table mapping Regenerated User Priority to Outbound Access Priority. This is a fixed mapping for all port types, with two options for 802.5 Token Ring.')
dot1dPortOutboundAccessPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBasePort"), (0, "AT-GS950-16-MIB", "dot1dRegenUserPriority"))
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityEntry.setDescription('Regenerated User Priority to Outbound Access Priority mapping.')
dot1dPortOutboundAccessPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriority.setStatus('current')
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriority.setDescription('The Outbound Access Priority the received frame is mapped to.')
dot1dPortGarpTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3, 1), )
if mibBuilder.loadTexts: dot1dPortGarpTable.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpTable.setDescription('A table of GARP control information about every bridge port. This is indexed by dot1dBasePort.')
dot1dPortGarpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3, 1, 1), )
dot1dBasePortEntry.registerAugmentions(("AT-GS950-16-MIB", "dot1dPortGarpEntry"))
dot1dPortGarpEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: dot1dPortGarpEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpEntry.setDescription('GARP control information for a bridge port.')
dot1dPortGarpJoinTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3, 1, 1, 1), TimeInterval().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpJoinTime.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpJoinTime.setDescription('The GARP Join time, in centiseconds.')
dot1dPortGarpLeaveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3, 1, 1, 2), TimeInterval().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpLeaveTime.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpLeaveTime.setDescription('The GARP Leave time, in centiseconds.')
dot1dPortGarpLeaveAllTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 1, 3, 1, 1, 3), TimeInterval().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpLeaveAllTime.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpLeaveAllTime.setDescription('The GARP LeaveAll time, in centiseconds.')
dot1dTpHCPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 5), )
if mibBuilder.loadTexts: dot1dTpHCPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTpHCPortTable.setDescription('A table that contains information about every high capacity port that is associated with this transparent bridge.')
dot1dTpHCPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpHCPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTpHCPortEntry.setDescription('Statistics information for each high capacity port of a transparent bridge.')
dot1dTpHCPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 5, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortInFrames.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpHCPortInFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpHCPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
dot1dTpHCPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortOutFrames.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpHCPortOutFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpHCPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
dot1dTpHCPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 5, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortInDiscards.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpHCPortInDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dTpHCPortInDiscards.setDescription('Count of valid frames that have been received by this port from its segment which were discarded (i.e., filtered) by the Forwarding Process.')
dot1dTpPortOverflowTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 6), )
if mibBuilder.loadTexts: dot1dTpPortOverflowTable.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortOverflowTable.setDescription('A table that contains the most-significant bits of statistics counters for ports that are associated with this transparent bridge that are on high capacity interfaces, as defined in the conformance clauses for this table. This table is provided as a way to read 64-bit counters for agents which support only SNMPv1. Note that the reporting of most-significant and least-significant counter bits separately runs the risk of missing an overflow of the lower bits in the interval between sampling. The manager must be aware of this possibility, even within the same varbindlist, when interpreting the results of a request or asynchronous notification.')
dot1dTpPortOverflowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 6, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpPortOverflowEntry.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortOverflowEntry.setDescription('The most significant bits of statistics counters for a high capacity interface of a transparent bridge. Each object is associated with a corresponding object in dot1dTpPortTable which indicates the least significant bits of the counter.')
dot1dTpPortInOverflowFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInOverflowFrames.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInOverflowFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortInOverflowFrames.setDescription('The number of times the associated dot1dTpPortInFrames counter has overflowed.')
dot1dTpPortOutOverflowFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortOutOverflowFrames.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortOutOverflowFrames.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortOutOverflowFrames.setDescription('The number of times the associated dot1dTpPortOutFrames counter has overflowed.')
dot1dTpPortInOverflowDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInOverflowDiscards.setReference('ISO/IEC 15802-3 Section 14.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInOverflowDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1dTpPortInOverflowDiscards.setDescription('The number of times the associated dot1dTpPortInDiscards counter has overflowed.')
dot1dExtCapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 1)).setObjects(("AT-GS950-16-MIB", "dot1dDeviceCapabilities"), ("AT-GS950-16-MIB", "dot1dPortCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dExtCapGroup = dot1dExtCapGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dExtCapGroup.setDescription('A collection of objects indicating the optional capabilities of the device.')
dot1dDeviceGmrpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 2)).setObjects(("AT-GS950-16-MIB", "dot1dGmrpStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dDeviceGmrpGroup = dot1dDeviceGmrpGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dDeviceGmrpGroup.setDescription('A collection of objects providing device-level control for the Multicast Filtering extended bridge services.')
dot1dDevicePriorityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 3)).setObjects(("AT-GS950-16-MIB", "dot1dTrafficClassesEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dDevicePriorityGroup = dot1dDevicePriorityGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dDevicePriorityGroup.setDescription('A collection of objects providing device-level control for the Priority services.')
dot1dDefaultPriorityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 4)).setObjects(("AT-GS950-16-MIB", "dot1dPortDefaultUserPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dDefaultPriorityGroup = dot1dDefaultPriorityGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dDefaultPriorityGroup.setDescription('A collection of objects defining the User Priority applicable to each port for media which do not support native User Priority.')
dot1dRegenPriorityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 5)).setObjects(("AT-GS950-16-MIB", "dot1dRegenUserPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dRegenPriorityGroup = dot1dRegenPriorityGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dRegenPriorityGroup.setDescription('A collection of objects defining the User Priorities applicable to each port for media which support native User Priority.')
dot1dPriorityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 6)).setObjects(("AT-GS950-16-MIB", "dot1dPortNumTrafficClasses"), ("AT-GS950-16-MIB", "dot1dTrafficClass"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dPriorityGroup = dot1dPriorityGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dPriorityGroup.setDescription('A collection of objects defining the traffic classes within a bridge for each evaluated User Priority.')
dot1dAccessPriorityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 7)).setObjects(("AT-GS950-16-MIB", "dot1dPortOutboundAccessPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dAccessPriorityGroup = dot1dAccessPriorityGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dAccessPriorityGroup.setDescription('A collection of objects defining the media dependent outbound access level for each priority.')
dot1dPortGarpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 8)).setObjects(("AT-GS950-16-MIB", "dot1dPortGarpJoinTime"), ("AT-GS950-16-MIB", "dot1dPortGarpLeaveTime"), ("AT-GS950-16-MIB", "dot1dPortGarpLeaveAllTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dPortGarpGroup = dot1dPortGarpGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dPortGarpGroup.setDescription('A collection of objects providing port level control and status information for GARP operation.')
dot1dHCPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 10)).setObjects(("AT-GS950-16-MIB", "dot1dTpHCPortInFrames"), ("AT-GS950-16-MIB", "dot1dTpHCPortOutFrames"), ("AT-GS950-16-MIB", "dot1dTpHCPortInDiscards"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dHCPortGroup = dot1dHCPortGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dHCPortGroup.setDescription('A collection of objects providing 64-bit statistics counters for high capacity bridge ports.')
dot1dPortOverflowGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 1, 11)).setObjects(("AT-GS950-16-MIB", "dot1dTpPortInOverflowFrames"), ("AT-GS950-16-MIB", "dot1dTpPortOutOverflowFrames"), ("AT-GS950-16-MIB", "dot1dTpPortInOverflowDiscards"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dPortOverflowGroup = dot1dPortOverflowGroup.setStatus('current')
if mibBuilder.loadTexts: dot1dPortOverflowGroup.setDescription('A collection of objects providing overflow statistics counters for high capacity bridge ports.')
dot1dCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 6, 2, 2, 1)).setObjects(("AT-GS950-16-MIB", "dot1dExtCapGroup"), ("AT-GS950-16-MIB", "dot1dDeviceGmrpGroup"), ("AT-GS950-16-MIB", "dot1dDevicePriorityGroup"), ("AT-GS950-16-MIB", "dot1dDefaultPriorityGroup"), ("AT-GS950-16-MIB", "dot1dRegenPriorityGroup"), ("AT-GS950-16-MIB", "dot1dPriorityGroup"), ("AT-GS950-16-MIB", "dot1dAccessPriorityGroup"), ("AT-GS950-16-MIB", "dot1dPortGarpGroup"), ("AT-GS950-16-MIB", "dot1dHCPortGroup"), ("AT-GS950-16-MIB", "dot1dPortOverflowGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1dCompliance = dot1dCompliance.setStatus('current')
if mibBuilder.loadTexts: dot1dCompliance.setDescription('The compliance statement for device support of Priority and Multicast Filtering extended bridging services.')
class VlanIndex(TextualConvention, Unsigned32):
    description = 'A value used to index per-VLAN tables: values of 0 and 4095 are not permitted; if the value is between 1 and 4094 inclusive, it represents an IEEE 802.1Q VLAN-ID with global scope within a given bridged domain (see VlanId textual convention). If the value is greater than 4095 then it represents a VLAN with scope local to the particular agent, i.e. one without a global VLAN-ID assigned to it. Such VLANs are outside the scope of IEEE 802.1Q but it is convenient to be able to manage them in the same way using this MIB.'
    status = 'current'

class VlanId(TextualConvention, Integer32):
    description = 'A 12-bit VLAN ID used in the VLAN Tag header.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4094)

dot1qMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1))
dot1qBase = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1))
dot1qTp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2))
dot1qStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3))
dot1qVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4))
dot1qBaseTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1), )
if mibBuilder.loadTexts: dot1qBaseTable.setStatus('current')
if mibBuilder.loadTexts: dot1qBaseTable.setDescription('List of dot1qBase objects that can be configured per virtual context in the system.')
dot1qBaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"))
if mibBuilder.loadTexts: dot1qBaseEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qBaseEntry.setDescription('Virtual context dot1qBase objects.')
dot1qVlanContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1qVlanContextId.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanContextId.setDescription('Identifies a virtual context.')
dot1qVlanVersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("version1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanVersionNumber.setReference('IEEE 802.1Q/D11 Section 12.10.1.1')
if mibBuilder.loadTexts: dot1qVlanVersionNumber.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanVersionNumber.setDescription('The version number of IEEE 802.1Q that this device supports.')
dot1qMaxVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 3), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qMaxVlanId.setReference('IEEE 802.1Q/D11 Section 9.3.2.3')
if mibBuilder.loadTexts: dot1qMaxVlanId.setStatus('current')
if mibBuilder.loadTexts: dot1qMaxVlanId.setDescription('The maximum IEEE 802.1Q VLAN ID that this device supports.')
dot1qMaxSupportedVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qMaxSupportedVlans.setReference('IEEE 802.1Q/D11 Section 12.10.1.1')
if mibBuilder.loadTexts: dot1qMaxSupportedVlans.setStatus('current')
if mibBuilder.loadTexts: dot1qMaxSupportedVlans.setDescription('The maximum number of IEEE 802.1Q VLANs that this device supports.')
dot1qNumVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qNumVlans.setReference('IEEE 802.1Q/D11 Section 12.7.1.1')
if mibBuilder.loadTexts: dot1qNumVlans.setStatus('current')
if mibBuilder.loadTexts: dot1qNumVlans.setDescription('The current number of IEEE 802.1Q VLANs that are configured in this device.')
dot1qGvrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qGvrpStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qGvrpStatus.setDescription('The administrative status requested by management for GVRP. The value enabled(1) indicates that GVRP should be enabled on this device, on all ports for which it has not been specifically disabled. When disabled(2), GVRP is disabled on all ports and all GVRP packets will be forwarded transparently. This object affects all GVRP Applicant and Registrar state machines. A transition from disabled(2) to enabled(1) will cause a reset of all GVRP state machines on all ports.')
dot1qFdbTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 1), )
if mibBuilder.loadTexts: dot1qFdbTable.setStatus('current')
if mibBuilder.loadTexts: dot1qFdbTable.setDescription('A table that contains configuration and control information for each Filtering Database currently operating on this device. Entries in this table appear automatically when VLANs are assigned FDB IDs in the dot1qVlanCurrentTable. This table maintains context ID as one more index to support Multiple Instances.')
dot1qFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qFdbId"))
if mibBuilder.loadTexts: dot1qFdbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qFdbEntry.setDescription('Information about a specific Filtering Database.')
dot1qFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: dot1qFdbId.setStatus('current')
if mibBuilder.loadTexts: dot1qFdbId.setDescription('The identity of this Filtering Database.')
dot1qFdbDynamicCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qFdbDynamicCount.setReference('IEEE 802.1Q/D11 Section 12.7.1.1.3')
if mibBuilder.loadTexts: dot1qFdbDynamicCount.setStatus('current')
if mibBuilder.loadTexts: dot1qFdbDynamicCount.setDescription('The current number of dynamic entries in this Filtering Database.')
dot1qTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2), )
if mibBuilder.loadTexts: dot1qTpFdbTable.setReference('IEEE 802.1Q/D11 Section 12.7.7')
if mibBuilder.loadTexts: dot1qTpFdbTable.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbTable.setDescription('A table that contains information about unicast entries for which the device has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame. This table maintains context ID as one more index to support Multiple Instances.')
dot1qTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qFdbId"), (0, "AT-GS950-16-MIB", "dot1qTpFdbAddress"))
if mibBuilder.loadTexts: dot1qTpFdbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the device has some forwarding and/or filtering information.')
dot1qTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qTpFdbAddress.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbAddress.setDescription('A unicast MAC address for which the device has forwarding and/or filtering information.')
dot1qTpFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qTpFdbPort.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance of dot1qTpFdbAddress has been seen. A value of '0' indicates that the port number has not been learned but that the device does have some forwarding/filtering information about this address (e.g. in the dot1qStaticUnicastTable). Implementors are encouraged to assign the port value to this object whenever it is learned even for addresses for which the corresponding value of dot1qTpFdbStatus is not learned(3).")
dot1qTpFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qTpFdbStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) - none of the following. This may include the case where some other MIB object (not the corresponding instance of dot1qTpFdbPort, nor an entry in the dot1qStaticUnicastTable) is being used to determine if and how frames addressed to the value of the corresponding instance of dot1qTpFdbAddress are being forwarded. invalid(2) - this entry is no longer valid (e.g., it was learned but has since aged out), but has not yet been flushed from the table. learned(3) - the value of the corresponding instance of dot1qTpFdbPort was learned and is being used. self(4) - the value of the corresponding instance of dot1qTpFdbAddress represents one of the device's addresses. The corresponding instance of dot1qTpFdbPort indicates which of the device's ports has this address. mgmt(5) - the value of the corresponding instance of dot1qTpFdbAddress is also the value of an existing instance of dot1qStaticAddress.")
dot1qTpFdbPw = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qTpFdbPw.setStatus('current')
if mibBuilder.loadTexts: dot1qTpFdbPw.setDescription("Either the value '0', or the pseudowire number on which a frame having a source address equal to the value of the corresponding instance of dot1qTpFdbAddress has been seen. A value of '0' indicates that the entry was learned via the layer2 port. Non-zero value indicates that this value must be used for forwading irrespective of dot1qTpFdbPort")
dot1qStaticUnicastTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1), )
if mibBuilder.loadTexts: dot1qStaticUnicastTable.setReference('IEEE 802.1Q/D11 Section 12.7.7, ISO/IEC 15802-3 Section 7.9.1')
if mibBuilder.loadTexts: dot1qStaticUnicastTable.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastTable.setDescription('A table containing filtering information for Unicast MAC addresses for each Filtering Database, configured into the device by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific unicast destination addresses are allowed to be forwarded. A value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for unicast addresses only. This table maintains context ID as one more index to support Multiple Instances.')
dot1qStaticUnicastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qFdbId"), (0, "AT-GS950-16-MIB", "dot1qStaticUnicastAddress"), (0, "AT-GS950-16-MIB", "dot1qStaticUnicastReceivePort"))
if mibBuilder.loadTexts: dot1qStaticUnicastEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastEntry.setDescription('Filtering information configured into the device by (local or network) management specifying the set of ports to which frames received from a specific port and containing a specific unicast destination address are allowed to be forwarded.')
dot1qStaticUnicastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qStaticUnicastAddress.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object must take the value of a unicast address.")
dot1qStaticUnicastReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qStaticUnicastReceivePort.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastReceivePort.setDescription("Either the value '0', or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the device for which there is no other applicable entry.")
dot1qStaticUnicastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1qStaticUnicastRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastRowStatus.setDescription("This object indicates the status of the AllowedToGoTo PortList to which a frame with a specific unicast address will be flooded in the event that it has not been learned. To fill the AllowedToGoTo portlist, we have to set the rowstatus as 'NOT_IN_SERVICE' and set the appropriate port in the dot1qStaticAllowedToGoTable and set the rowstatus as 'ACTIVE' to make the portlist available.")
dot1qStaticUnicastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qStaticUnicastStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticUnicastStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
dot1qStaticAllowedToGoTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 2), )
if mibBuilder.loadTexts: dot1qStaticAllowedToGoTable.setReference('IEEE 802.1Q/D11 Table 8-5, ISO/IEC 15802-3 Table 7-5')
if mibBuilder.loadTexts: dot1qStaticAllowedToGoTable.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticAllowedToGoTable.setDescription('A table containing the information of AllowedToGoTo ports for each static unicast entry. This table maintains context ID as one more index to support Multiple Instances.')
dot1qStaticAllowedToGoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qFdbId"), (0, "AT-GS950-16-MIB", "dot1qStaticUnicastAddress"), (0, "AT-GS950-16-MIB", "dot1qStaticUnicastReceivePort"), (0, "AT-GS950-16-MIB", "dot1qTpPort"))
if mibBuilder.loadTexts: dot1qStaticAllowedToGoEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticAllowedToGoEntry.setDescription('Information about a port, Whether it is an AllowedToGoTo member or not.')
dot1qStaticAllowedIsMember = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 2, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qStaticAllowedIsMember.setReference('IEEE 802.1Q/D11 Table 8-5, ISO/IEC 15802-3 Table 7-5')
if mibBuilder.loadTexts: dot1qStaticAllowedIsMember.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticAllowedIsMember.setDescription('Indicates whether the port is an allowedToGoTo member.')
dot1qTpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1qTpPort.setReference('IEEE 802.1Q/D11 Table 8-5, ISO/IEC 15802-3 Table 7-5')
if mibBuilder.loadTexts: dot1qTpPort.setStatus('current')
if mibBuilder.loadTexts: dot1qTpPort.setDescription('The port number of the port for which this entry applies.')
dot1qStaticMulticastTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3), )
if mibBuilder.loadTexts: dot1qStaticMulticastTable.setReference('IEEE 802.1Q/D11 Section 12.7.7, ISO/IEC 15802-3 Section 7.9.1')
if mibBuilder.loadTexts: dot1qStaticMulticastTable.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastTable.setDescription('A table containing filtering information for Multicast and Broadcast MAC addresses for each VLAN, configured into the device by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific Multicast and Broadcast destination addresses are allowed to be forwarded. A value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for Multicast and Broadcast addresses only. This table maintains context ID as one more index to support Multiple Instances.')
dot1qStaticMulticastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"), (0, "AT-GS950-16-MIB", "dot1qStaticMulticastAddress"), (0, "AT-GS950-16-MIB", "dot1qStaticMulticastReceivePort"))
if mibBuilder.loadTexts: dot1qStaticMulticastEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastEntry.setDescription('Filtering information configured into the device by (local or network) management specifying the set of ports to which frames received from this specific port for this VLAN and containing this Multicast or Broadcast destination address are allowed to be forwarded.')
dot1qStaticMulticastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qStaticMulticastAddress.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object must take the value of a Multicast or Broadcast address.")
dot1qStaticMulticastReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qStaticMulticastReceivePort.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastReceivePort.setDescription("Either the value '0', or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the device for which there is no other applicable entry.")
dot1qStaticMulticastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1qStaticMulticastRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastRowStatus.setDescription("This object indicates the status of the PortLists (Eggress, Forbidden) used in the static multicast table. To fill the eggress and forbidden portlist, we have to set the rowstatus as 'NOT_IN_SERVICE' and set the appropriate port in the dot1qForwardUnregPortConfigTable and set the rowstatus as 'ACTIVE' to make the portlist available.")
dot1qStaticMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qStaticMulticastStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMulticastStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
dot1qStaticMcastPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 4), )
if mibBuilder.loadTexts: dot1qStaticMcastPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMcastPortTable.setDescription('A table containing egress and forbidden ports for static multicast entry. This table maintains context ID as one more index to support Multiple Instance.')
dot1qStaticMcastPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"), (0, "AT-GS950-16-MIB", "dot1qStaticMulticastAddress"), (0, "AT-GS950-16-MIB", "dot1qStaticMulticastReceivePort"), (0, "AT-GS950-16-MIB", "dot1qTpPort"))
if mibBuilder.loadTexts: dot1qStaticMcastPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMcastPortEntry.setDescription('Information about a port, Whether it is a member or a forbidden member.')
dot1qStaticMcastPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("addMember", 1), ("addForbidden", 2), ("delMember", 3), ("delForbidden", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qStaticMcastPort.setStatus('current')
if mibBuilder.loadTexts: dot1qStaticMcastPort.setDescription("Indicates whether the port is a member or a forbidden member in the static multicast entry. 'addMember' - to add the port in the egress member-list. 'addForbidden' - to add the port in the forbidden member-list. 'delMember' - to remove the port from the egress member-list. 'delForbidden' - to remove the port from the forbidden member-list.")
dot1qVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 3, 4, 1, 2), VlanIndex())
if mibBuilder.loadTexts: dot1qVlanIndex.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanIndex.setDescription('The VLAN-ID or other identifier referring to this VLAN.')
dot1qVlanNumDeletesTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 1), )
if mibBuilder.loadTexts: dot1qVlanNumDeletesTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanNumDeletesTable.setDescription('Table containing number of VLAN deletions in the VLAN current database. This table maintains context ID as index to support Multiple Instances.')
dot1qVlanNumDeletesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"))
if mibBuilder.loadTexts: dot1qVlanNumDeletesEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanNumDeletesEntry.setDescription('Entry for a virtual context.')
dot1qVlanNumDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanNumDeletes.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanNumDeletes.setDescription('The number of times a VLAN entry has been deleted from the dot1qVlanCurrentTable (for any reason). If an entry is deleted, then inserted, and then deleted, this counter will be incremented by 2.')
dot1qVlanCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2), )
if mibBuilder.loadTexts: dot1qVlanCurrentTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanCurrentTable.setDescription('A table containing current configuration information for each VLAN currently configured into the device by (local or network) management, or dynamically created as a result of GVRP requests received. This table maintains context ID as one more index to support Multiple Instances.')
dot1qVlanCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanTimeMark"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: dot1qVlanCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanCurrentEntry.setDescription('Information for a VLAN configured into the device by (local or network) management, or dynamically created as a result of GVRP requests received.')
dot1qVlanTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2, 1, 1), TimeFilter())
if mibBuilder.loadTexts: dot1qVlanTimeMark.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
dot1qVlanFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanFdbId.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanFdbId.setDescription('The Filtering Database used by this VLAN. This is one of the dot1qFdbId values in the dot1qFdbTable. This value is allocated automatically by the device whenever the VLAN is created: either dynamically by GVRP, or by management, in dot1qVlanStaticTable. Allocation of this value follows the learning constraints defined for this VLAN in dot1qLearningConstraintsTable.')
dot1qVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("permanent", 2), ("dynamicGvrp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. permanent(2) - this entry, corresponding to an entry in dot1qVlanStaticTable, is currently in use and will remain so after the next reset of the device. The port lists for this entry include ports from the equivalent dot1qVlanStaticTable entry and ports learnt dynamically. dynamicGvrp(3) - this entry is currently in use and will remain so until removed by GVRP. There is no static entry for this VLAN and it will be removed when the last port leaves the VLAN.')
dot1qVlanCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanCreationTime.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanCreationTime.setDescription('The value of sysUpTime when this VLAN was created.')
dot1qVlanEgressPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 3), )
if mibBuilder.loadTexts: dot1qVlanEgressPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanEgressPortTable.setDescription('A table containing the information of egress ports for each VLAN. This table maintains context ID as one more index to support Multiple Instance.')
dot1qVlanEgressPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanTimeMark"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"), (0, "AT-GS950-16-MIB", "dot1qTpPort"))
if mibBuilder.loadTexts: dot1qVlanEgressPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanEgressPortEntry.setDescription('Information about a port, Whether it is a tagged or an untagged member.')
dot1qVlanCurrentEgressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tagged", 1), ("untagged", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanCurrentEgressPort.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanCurrentEgressPort.setDescription("Indicates whether the port is a tagged or a untagged member in the VLAN. 'tagged' - to add the port in the tagged portlist. 'untagged' - to add the port in the untagged portlist.")
dot1qVlanStaticTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 4), )
if mibBuilder.loadTexts: dot1qVlanStaticTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticTable.setDescription('A table containing static configuration information for each VLAN configured into the device by (local or network) management. All entries are permanent and will be restored after the device is reset. This table maintains context ID as one more index to support Multiple Instance.')
dot1qVlanStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: dot1qVlanStaticEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticEntry.setDescription('Static information for a VLAN configured into the device by (local or network) management.')
dot1qVlanStaticName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1qVlanStaticName.setReference('IEEE 802.1Q/D11 Section 12.10.2.1')
if mibBuilder.loadTexts: dot1qVlanStaticName.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticName.setDescription('An administratively assigned string, which may be used to identify the VLAN.')
dot1qVlanStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1qVlanStaticRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticRowStatus.setDescription('This object indicates the status of this entry.')
dot1qVlanStaticPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 5), )
if mibBuilder.loadTexts: dot1qVlanStaticPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticPortConfigTable.setDescription('A table containing the information of tagged, untagged and forbidden ports for each VLAN. This table maintains context ID as one more index to support Multiple Instance.')
dot1qVlanStaticPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanContextId"), (0, "AT-GS950-16-MIB", "dot1qVlanIndex"), (0, "AT-GS950-16-MIB", "dot1qTpPort"))
if mibBuilder.loadTexts: dot1qVlanStaticPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticPortConfigEntry.setDescription('Forwarding information about a port, Whether it is a member or a forbidden member.')
dot1qVlanStaticPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("addTagged", 1), ("addUntagged", 2), ("addForbidden", 3), ("delTagged", 4), ("delUntagged", 5), ("delForbidden", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanStaticPort.setReference('IEEE 802.1Q/D11 Section 12.10.2.1')
if mibBuilder.loadTexts: dot1qVlanStaticPort.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanStaticPort.setDescription("Indicates whether the port is a member or a forbidden member in the forwarding information for this VLAN. 'addTagged' - to add the port in the tagged portlist. 'addUntagged' - to add the port in the untagged portlist. 'addForbidden' - to add the port in the forbidden portlist. 'delTagged' - to delete the port from the tagged portlist. 'delUntagged' - to delete the port from the untagged portlist. 'delForbidden' - to delete the port from the forbidden portlist.")
dot1qPortVlanTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7), )
if mibBuilder.loadTexts: dot1qPortVlanTable.setStatus('current')
if mibBuilder.loadTexts: dot1qPortVlanTable.setDescription('A table containing per port control and status information for VLAN configuration in the device.')
dot1qPortVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: dot1qPortVlanEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qPortVlanEntry.setDescription('Information controlling VLAN configuration for a port on the device. This is indexed by dot1dBasePort.')
dot1qPvid = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 1), VlanIndex().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPvid.setReference('IEEE 802.1Q/D11 Section 12.10.1.1')
if mibBuilder.loadTexts: dot1qPvid.setStatus('current')
if mibBuilder.loadTexts: dot1qPvid.setDescription('The PVID, the VLAN ID assigned to untagged frames or Priority-Tagged frames received on this port.')
dot1qPortAcceptableFrameTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("admitAll", 1), ("admitOnlyVlanTagged", 2), ("admitOnlyUntaggedAndPriorityTagged", 3))).clone('admitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPortAcceptableFrameTypes.setReference('IEEE 802.1Q/D11 Section 12.10.1.3')
if mibBuilder.loadTexts: dot1qPortAcceptableFrameTypes.setStatus('current')
if mibBuilder.loadTexts: dot1qPortAcceptableFrameTypes.setDescription('When this is admitOnlyVlanTagged(2) the device will discard untagged frames or Priority-Tagged frames received on this port. When admitAll(1), untagged frames or Priority-Tagged frames received on this port will be accepted and assigned to the PVID for this port. When this is admitOnlyUntaggedAndPriorityTagged the device will recieve only untagged and priority tagged frames on this port. This control does not affect VLAN independent BPDU frames, such as GVRP and STP. It does affect VLAN dependent BPDU frames, such as GMRP.')
dot1qPortIngressFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPortIngressFiltering.setReference('IEEE 802.1Q/D11 Section 12.10.1.4')
if mibBuilder.loadTexts: dot1qPortIngressFiltering.setStatus('current')
if mibBuilder.loadTexts: dot1qPortIngressFiltering.setDescription('When this is true(1) the device will discard incoming frames for VLANs which do not include this Port in its Member set. When false(2), the port will accept all incoming frames. This control does not affect VLAN independent BPDU frames, such as GVRP and STP. It does affect VLAN dependent BPDU frames, such as GMRP.')
dot1qPortGvrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 4), EnabledStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPortGvrpStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qPortGvrpStatus.setDescription('The state of GVRP operation on this port. The value enabled(1) indicates that GVRP is enabled on this port, as long as dot1qGvrpStatus is also enabled for this device. When disabled(2) but dot1qGvrpStatus is still enabled for the device, GVRP is disabled on this port: any GVRP packets received will be silently discarded and no GVRP registrations will be propagated from other ports. This object affects all GVRP Applicant and Registrar state machines on this port. A transition from disabled(2) to enabled(1) will cause a reset of all GVRP state machines on this port.')
dot1qPortGvrpFailedRegistrations = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qPortGvrpFailedRegistrations.setStatus('current')
if mibBuilder.loadTexts: dot1qPortGvrpFailedRegistrations.setDescription('The total number of failed GVRP registrations, for any reason, on this port.')
dot1qPortGvrpLastPduOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qPortGvrpLastPduOrigin.setStatus('current')
if mibBuilder.loadTexts: dot1qPortGvrpLastPduOrigin.setDescription('The Source MAC Address of the last GVRP message received on this port.')
dot1qPortRestrictedVlanRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 116, 7, 1, 4, 7, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPortRestrictedVlanRegistration.setReference('IEEE 802.1u clause 11.2.3.2.3, 12.10.1.7.')
if mibBuilder.loadTexts: dot1qPortRestrictedVlanRegistration.setStatus('current')
if mibBuilder.loadTexts: dot1qPortRestrictedVlanRegistration.setDescription('The state of Restricted VLAN Registration on this port. If the value of this control is true(1), then creation of a new dynamic VLAN entry is permitted only if there is a Static VLAN Registration Entry for the VLAN concerned, in which the Registrar Administrative Control value for this port is Normal Registration.')
dot1sMst = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1))
dot1sMstTrapsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2))
dot1sMstTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3))
dot1sMstTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3), )
if mibBuilder.loadTexts: dot1sMstTable.setStatus('current')
if mibBuilder.loadTexts: dot1sMstTable.setDescription('List of per Virtual Context Mst Module Parameters.')
dot1sMstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sMstContextId"))
if mibBuilder.loadTexts: dot1sMstEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sMstEntry.setDescription('Virtual Context Mst Module Parameters.')
dot1sMstContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1sMstContextId.setStatus('current')
if mibBuilder.loadTexts: dot1sMstContextId.setDescription('Identifies the Virtual Context.')
dot1sSystemControl = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sSystemControl.setStatus('current')
if mibBuilder.loadTexts: dot1sSystemControl.setDescription('The administrative shutdown status requested by management for the MST feature. The value start (1) indicates that MST should be active in the device on all ports. The value shutdown (2) indicates that MST should be shutdown in the device on all ports. All memory should be released on all ports.')
dot1sModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 3), EnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sModuleStatus.setStatus('current')
if mibBuilder.loadTexts: dot1sModuleStatus.setDescription('The administrative status requested by management for the MST feature. The value enabled(1) indicates that Mst should be enabled in the device on all ports. The value disabled(2) indicates that Mst should be disabled in the device on all ports. The object can be set to enabled(1) if and only if, dot1sSystemControl set to start.')
dot1sMaxMstInstanceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMaxMstInstanceNumber.setStatus('current')
if mibBuilder.loadTexts: dot1sMaxMstInstanceNumber.setDescription('The Maximun number of spanning trees to be allowed. A User may limit the Number of Spanning Tree instance to be allowed in the Bridge.')
dot1sNoOfMstiSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sNoOfMstiSupported.setStatus('current')
if mibBuilder.loadTexts: dot1sNoOfMstiSupported.setDescription('Indicates Maximum number of spanning tree Instances supported.')
dot1sMaxHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMaxHopCount.setStatus('current')
if mibBuilder.loadTexts: dot1sMaxHopCount.setDescription('Indicates the Maximum Hop Count value. The granularity of this timer is specified to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1sBrgAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sBrgAddress.setStatus('current')
if mibBuilder.loadTexts: dot1sBrgAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique. When concatenated with dot1sCistBridgePriority or dot1sMstiBridgePriority a unique BridgeIdentifier is formed which is used in the Spanning Tree Protocol.')
dot1sCistRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 8), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sCistRoot.setDescription('The bridge identifier of the Root of the common spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the CIST Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
dot1sCistRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistRegionalRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sCistRegionalRoot.setDescription('The bridge identifier of the Root of the Multiple spanning tree region as determined by the Spanning Tree Protocol as executed by this node. This value is used as the CIST Regional Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
dot1sCistRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistRootCost.setStatus('current')
if mibBuilder.loadTexts: dot1sCistRootCost.setDescription('The Cost of the path to the CIST Root as seen from this bridge.')
dot1sCistRegionalRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistRegionalRootCost.setStatus('current')
if mibBuilder.loadTexts: dot1sCistRegionalRootCost.setDescription('The Cost of the path to the CIST Regional Root as seen from this bridge.')
dot1sCistRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistRootPort.setStatus('current')
if mibBuilder.loadTexts: dot1sCistRootPort.setDescription('The Port Number of the Port which offers the lowest path cost from this bridge to the CIST Root Bridge.')
dot1sCistBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistBridgePriority.setStatus('current')
if mibBuilder.loadTexts: dot1sCistBridgePriority.setDescription('The Value of the writable portion of the Bridge Identifier comprising of the first two octets. The values that are set for Bridge Priority must be in steps of 4096.')
dot1sCistBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 14), Timeout().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: dot1sCistBridgeMaxAge.setDescription('The value that all bridges use for MaxAge when this bridge is acting as the root. The granularity of this timer is specified to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1sCistBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 15), Timeout().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistBridgeForwardDelay.setStatus('current')
if mibBuilder.loadTexts: dot1sCistBridgeForwardDelay.setDescription('The value that all bridges use for ForwardDelay when this bridge is acting as the root. Note that 802.1D specifies that the range for this parameter is related to the value of BridgeMaxAge. The granularity of this timer is specified to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1sCistHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistHoldTime.setStatus('current')
if mibBuilder.loadTexts: dot1sCistHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
dot1sCistMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 17), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistMaxAge.setStatus('current')
if mibBuilder.loadTexts: dot1sCistMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
dot1sCistForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 18), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistForwardDelay.setStatus('current')
if mibBuilder.loadTexts: dot1sCistForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in a particular state before moving to the next state.')
dot1sMstpUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstpUpCount.setStatus('current')
if mibBuilder.loadTexts: dot1sMstpUpCount.setDescription('The number of times MSTP Module has been enabled.')
dot1sMstpDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstpDownCount.setStatus('current')
if mibBuilder.loadTexts: dot1sMstpDownCount.setDescription('The number of times MSTP Module has been disabled.')
dot1sPathCostDefaultType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stp8021d1998", 1), ("stp8021t2001", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sPathCostDefaultType.setStatus('current')
if mibBuilder.loadTexts: dot1sPathCostDefaultType.setDescription('The version of the Spanning Tree default Path Costs that are to be used by this Bridge. A value of 8021d1998(1) uses the 16-bit default Path Costs from IEEE Std. 802.1D-1998. A value of stp8021t2001(2) uses the 32-bit default Path Costs from IEEE Std. 802.1t.')
dot1sTrace = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sTrace.setStatus('current')
if mibBuilder.loadTexts: dot1sTrace.setDescription('This object is used to enable Trace Statements in the MSTP Module. A FOUR BYTE integer is used for enabling the level of tracing. Each BIT in the four byte integer, represents a particular level of Trace. The mapping between the bit positions & the level of trace is as follows: 0 - Init and Shutdown Traces 1 - Management Traces 2 - Data Path Traces 3 - Control Plane Traces 4 - Packet Dump Traces 5 - Traces related to All Resources except Buffers 6 - All Failure Traces 7 - Buffer Traces The remaining bits are unused. Combination of trace levels are also allowed. For example if the bits 0 and 1 are set, then the Trace statements related to Init-Shutdown and management will be printed. The user has to enter the corresponding INTEGER VALUE for the bits set. For example if bits 0 and 1 are to be set then user has to give the value for this object as 3. Setting the Trace Option to any value will cause the Debug Option to be set to 0 (i.e.) the Trace Option and Debug Option are mutually exclusive.')
dot1sDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 131071))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sDebug.setStatus('current')
if mibBuilder.loadTexts: dot1sDebug.setDescription('This object is used to enable Debug Statements in the MSTP Module. A FOUR BYTE integer is used for enabling the level of debugging. Each BIT in the four byte integer, represents a particular level of Debug. The mapping between the bit positions & the level of debug is as follows: 0 - Init and Shutdown Debug statements 1 - Management Debug statements 2 - Memory related Debug statements 3 - BPDU related Debug statements 4 - Event Handling Debug statements 5 - Timer Module Debug statements 6 - Port Information SEM Debug statements 7 - Port Receive SEM Debug statements (valid in the case of MSTP alone) 8 - Role Selection SEM Debug statements 9 - Role Transition SEM Debug statements 10 - State Transition SEM Debug statements 11 - Protocol Migration SEM Debug statements 12 - Topology Change SEM Debug statements 13 - Port Transmit SEM Debug statements 14 - Bridge Detection SEM Debug statements 15 - All Failure Debug statements 16 - Redundancy code flow Debug statements The remaining bits are unused. Combination of debug levels are also allowed. For example if the bits 0 and 1 are set, then the Debug statements related to Init-Shutdown and management will be printed. The user has to enter the corresponding INTEGER VALUE for the bits set. For example if bits 0 and 1 are to be set then user has to give the value for this object as 3. Setting the Debug Option to any value will cause the Trace Option to be set to 0 (i.e.) the Trace Option and Debug Option are mutually exclusive.')
dot1sForceProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2), ("mstp", 3))).clone('mstp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sForceProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: dot1sForceProtocolVersion.setDescription("The version of Spanning Tree Protocol the bridge is currently running. The value 'stpCompatible(0)' indicates the Spanning Tree Protocol specified in IEEE 802.1D and 'rstp(2)' indicates the Rapid Spanning Tree Protocol specified in IEEE 802.1w and 'mstp(3)' indicates the Multiple Spanning Tree Protocol Specified in IEEE 802.1s.")
dot1sTxHoldCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sTxHoldCount.setStatus('current')
if mibBuilder.loadTexts: dot1sTxHoldCount.setDescription('The value used by the Port Transmit state machine to limit the maximum transmission rate.')
dot1sMstiConfigIdSel = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiConfigIdSel.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiConfigIdSel.setDescription('The Configuration Identifier Format Selector used by the Bridge. This has a fixed value of 0 to indicate RegionName, RegionVersion are specified as in Standard.')
dot1sMstiRegionName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiRegionName.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiRegionName.setDescription("The Name for the Region's configuration. By Default Region Name will be equal to the Bridge Mac Address.")
dot1sMstiRegionVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiRegionVersion.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiRegionVersion.setDescription('Version of the MST Region.')
dot1sMstiConfigDigest = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiConfigDigest.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiConfigDigest.setDescription('The Configuration Digest value for this Region.')
dot1sBufferOverFlowCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sBufferOverFlowCount.setStatus('current')
if mibBuilder.loadTexts: dot1sBufferOverFlowCount.setDescription('The number of times Buffer overflows/failures have occured. A Trap is generated on the occurence of this event.')
dot1sMemAllocFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMemAllocFailureCount.setStatus('current')
if mibBuilder.loadTexts: dot1sMemAllocFailureCount.setDescription('The number of times memory allocation failures have occured. A Trap is generated on the occurence of this event.')
dot1sRegionConfigChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sRegionConfigChangeCount.setStatus('current')
if mibBuilder.loadTexts: dot1sRegionConfigChangeCount.setDescription('The number of times a Region Configuration Identifier Change was detected. A Trap is generated on the occurence of this event.')
dot1sCistBridgeRoleSelectionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("initbridge", 0), ("roleselection", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistBridgeRoleSelectionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistBridgeRoleSelectionSemState.setDescription('Current state of the Port Role Selection State Machine of this bridge in Common Spanning Tree context')
dot1sCistTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 34), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: dot1sCistTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the TcWhile Timer for any port in this Bridge was non-zero for Common Spanning Tree context.')
dot1sCistTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistTopChanges.setStatus('current')
if mibBuilder.loadTexts: dot1sCistTopChanges.setDescription('The number of times that there have been atleast one non-zero TcWhile Timer on this Bridge for Common Spanning Tree context.')
dot1sCistNewRootBridgeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistNewRootBridgeCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistNewRootBridgeCount.setDescription('The number of times this Bridge has detected a Root Bridge change for Common Spanning Tree context. A Trap is generated on the occurence of this event.')
dot1sCistHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 37), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistHelloTime.setStatus('current')
if mibBuilder.loadTexts: dot1sCistHelloTime.setDescription('This time value, measured in units of hundredths of a second, specifies the amount of time between the transmission of configuration BPDUs by this node on any port when it is the root of the spanning tree or trying to become so.')
dot1sCistBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 38), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistBridgeHelloTime.setStatus('current')
if mibBuilder.loadTexts: dot1sCistBridgeHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node in units of hundredths of a second.')
dot1sCistDynamicPathcostCalculation = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 39), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistDynamicPathcostCalculation.setStatus('current')
if mibBuilder.loadTexts: dot1sCistDynamicPathcostCalculation.setDescription('This object is used to determine whether dynamic pathcost calculation is allowed or not.The value is determined by management. If set to true, pathcost is calculated dynamically from port speed, otherwise the link speed at the time of port creation is used for calculating the path cost. In both cases if the user has configured a pathcost for the port that will be used. By default dynamic pathcost calculation is set to false.')
dot1sContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 3, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sContextName.setStatus('current')
if mibBuilder.loadTexts: dot1sContextName.setDescription('This object is used to identity the context-name.')
dot1sMstiBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4), )
if mibBuilder.loadTexts: dot1sMstiBridgeTable.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiBridgeTable.setDescription('Table containing Bridge Information specific to Spanning Tree Instance. This table maintains context ID as one more index to support Multiple Instances.')
dot1sMstiBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sMstContextId"), (0, "AT-GS950-16-MIB", "dot1sMstiInstanceIndex"))
if mibBuilder.loadTexts: dot1sMstiBridgeEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiBridgeEntry.setDescription('Entry indicating the Bridge Information.')
dot1sMstiInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: dot1sMstiInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiInstanceIndex.setDescription('Spanning Tree Instance to which the information belongs.')
dot1sMstiBridgeRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 2), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiBridgeRegionalRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiBridgeRegionalRoot.setDescription('MSTI Regional Root Identifier value for the Instance. This value is used as the MSTI Regional Root Identifier parameter in all Configuration Bridge PDUs originated by this node')
dot1sMstiBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiBridgePriority.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiBridgePriority.setDescription('The writable portion of the MSTI Bridge Identifier. comprising of the first two octets. The values that are set for Bridge Priority must be in steps of 4096.')
dot1sMstiRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiRootCost.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiRootCost.setDescription('The Cost of the path to the MSTI Regional Root as seen by this bridge.')
dot1sMstiRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiRootPort.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiRootPort.setDescription('The Port Number of the Port which offers the lowest path cost from this bridge to the MSTI Region Root Bridge.')
dot1sMstiTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the TcWhile Timer for any port in this Bridge was non-zero for this spanning tree instance.')
dot1sMstiTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiTopChanges.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiTopChanges.setDescription('The number of times that there have been atleast one non-zero TcWhile Timer on this Bridge for this spanning tree instance.')
dot1sMstiNewRootBridgeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiNewRootBridgeCount.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiNewRootBridgeCount.setDescription('The number of times this Bridge has detected a Root Bridge change for this spanning tree instance. A Trap is generated on the occurence of this event.')
dot1sMstiBridgeRoleSelectionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("initbridge", 0), ("roleselection", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiBridgeRoleSelectionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiBridgeRoleSelectionSemState.setDescription('Current state of the Port Role Selection State Machine for this spanning tree instance for this bridge.')
dot1sInstanceUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceUpCount.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceUpCount.setDescription('The number of times a new spanning tree instance has been created. A Trap is generated on the occurence of this event.')
dot1sInstanceDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceDownCount.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceDownCount.setDescription('The number of times a spanning tree instance has been deleted. A Trap is generated on the occurence of this event.')
dot1sOldDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 4, 1, 12), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sOldDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sOldDesignatedRoot.setDescription('The bridge identifier of the old root of the spanning tree instance as determined by the Spanning Tree Protocol as executed by this node. ')
dot1sVlanInstanceMappingTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5), )
if mibBuilder.loadTexts: dot1sVlanInstanceMappingTable.setStatus('current')
if mibBuilder.loadTexts: dot1sVlanInstanceMappingTable.setDescription('This table contains one entry for each instance of MSTP. This table maintains context ID as one more index to support Multiple Instances.')
dot1sVlanInstanceMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sMstContextId"), (0, "AT-GS950-16-MIB", "dot1sInstanceIndex"))
if mibBuilder.loadTexts: dot1sVlanInstanceMappingEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sVlanInstanceMappingEntry.setDescription('A conceptual row containing the status of the MSTP instance.')
dot1sInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: dot1sInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceIndex.setDescription('An arbitrary integer within the range from 1 to the value of Max Instance Number that uniquely identifies an instance.')
dot1sMapVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 2), VlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMapVlanIndex.setStatus('current')
if mibBuilder.loadTexts: dot1sMapVlanIndex.setDescription('The VlanId will get mapped to the spanning tree instance specified. All the Instance Specific information for the Member ports of the Vlan will be created.This object is used only for SET operation.GET Operation returns null values. If the VlanId to Instance Mapping has to be known then any one of the VlanMapped object should be used.')
dot1sUnMapVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 3), VlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sUnMapVlanIndex.setStatus('current')
if mibBuilder.loadTexts: dot1sUnMapVlanIndex.setDescription('The VlanId will get unmapped from spanning tree instance to which it it mapped. All the Instance Specific information for the Member ports of the Vlan will get released.This object is used only for SET operation.GET Operation returns null values.')
dot1sSetVlanList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sSetVlanList.setStatus('current')
if mibBuilder.loadTexts: dot1sSetVlanList.setDescription('A string of octets containing one bit per VLAN. The first octet corresponds to VLANs with VlanIndex values 1 through 8; the second octet to VLANs 9 through 16 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. The set of vlans configured by management to map for this Instance. If the VlanId to Instance Mapping has to be known then any one of the VlanMapped object should be used.If a vlan is already mapped to this Instance, it may not be mapped again. This object is used only for SET operation. GET Operation returns null values.')
dot1sResetVlanList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sResetVlanList.setStatus('current')
if mibBuilder.loadTexts: dot1sResetVlanList.setDescription('A string of octets containing one bit per VLAN. The first octet corresponds to VLANs with VlanIndex values 1 through 8; the second octet to VLANs 9 through 16 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. The set of vlans configured by management to unmap from this Instance. A vlan may not be unmapped from this instance if it is not already mapped to this Instance. This object is used only for SET operation.GET Operation returns null values.')
dot1sInstanceVlanMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceVlanMapped.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceVlanMapped.setDescription("A string of octets containing one bit per VLAN. The first octet corresponds to VLANs with VlanIndex values 1 through 8; the second octet to VLANs 9 through 16 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. For each VLAN that is mapped to this MSTP instance, the bit corresponding to that VLAN is set to '1'.")
dot1sInstanceVlanMapped2k = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceVlanMapped2k.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceVlanMapped2k.setDescription("A string of octets containing one bit per VLAN for VLANS with VlanIndex values 1024 through 2047. The first octet corresponds to VLANs with VlanIndex values 1024 through 1031; the second octet to VLANs 1032 through 1039 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. For each VLAN that is mapped to this MSTP instance, the bit corresponding to that VLAN is set to '1'. This object is only instantiated on devices with support for VlanIndex values up to 4095.")
dot1sInstanceVlanMapped3k = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceVlanMapped3k.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceVlanMapped3k.setDescription("A string of octets containing one bit per VLAN for VLANS with VlanIndex values 2048 through 3071. The first octet corresponds to VLANs with VlanIndex values of 2048 through 2055; the second octet to VLANs 2056 through 2063 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. For each VLAN that is mapped to this MSTP instance, the bit corresponding to that VLAN is set to '1'. This object is only instantiated on devices with support for VlanIndex values up to 4095.")
dot1sInstanceVlanMapped4k = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 5, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sInstanceVlanMapped4k.setStatus('current')
if mibBuilder.loadTexts: dot1sInstanceVlanMapped4k.setDescription("A string of octets containing one bit per VLAN for VLANS with VlanIndex values 3072 through 4095. The first octet corresponds to VLANs with VlanIndex values 3072 through 3079; the second octet to VLANs 3080 through 3087 etc. The most significant bit of each octet corresponds to the lowest VlanIndex value in that octet. For each VLAN that is mapped to this MSTP instance, the bit corresponding to that VLAN is set to '1'. This object is only instantiated on devices with support for VlanIndex values up to 4095.")
dot1sCistPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6), )
if mibBuilder.loadTexts: dot1sCistPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTable.setDescription('This table contains Common Spanning Tree Port Information.')
dot1sCistPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sCistPort"))
if mibBuilder.loadTexts: dot1sCistPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortEntry.setDescription('A list of information maintained by every port for Common Spanning tree.')
dot1sCistPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1sCistPort.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPort.setDescription('The Port number of the port for which this entry contains spanning tree information.')
dot1sCistPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortPathCost.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the CIST Root which include this port.')
dot1sCistPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortPriority.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortPriority.setDescription('The four most significant bits of the Port Identifier of the Spanning Tree instance can be modified by setting the CistPortPriority value. The values that are set for Port Priority must be in steps of 16.')
dot1sCistPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortDesignatedRoot.setDescription('The unique Bridge Identifier of the bridge recorded as the CIST Root in the configuration BPDUs transmitted.')
dot1sCistPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortDesignatedBridge.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortDesignatedBridge.setDescription("The unique Bridge Identifier of the bridge which this port considers to be the Designated Bridge for the port's segment.")
dot1sCistPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortDesignatedPort.setDescription("The Port identifier of the port on the Designated Bridge for this port's segment.")
dot1sCistPortAdminP2P = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("forceTrue", 0), ("forceFalse", 1), ("auto", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortAdminP2P.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortAdminP2P.setDescription('The administrative point-to-point status of the LAN segment attached to this port. A value of forceTrue(0) indicates that this port should always be treated as if it is connected to a point-to-point link. A value of forceFalse(1) indicates that this port should be treated as having a shared media connection. A value of auto(2) indicates that this port is considered to have a point-to-point link if it is an Aggregator and all of its members are aggregatable, or if the MAC entity is configured for full duplex operation, either through auto-negotiation or by management means.')
dot1sCistPortOperP2P = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortOperP2P.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortOperP2P.setDescription('The operational point-to-point status of the LAN segment attached to this port. It indicates whether a port is considered to have a point-to-point connection or not. The value is determined by management or by auto-detection, as described in the dot1sCistPortAdminP2P object.')
dot1sCistPortAdminEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortAdminEdgeStatus.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortAdminEdgeStatus.setDescription('The administrative value of the Edge Port parameter. A value of TRUE(1) indicates that this port should be assumed as an edge-port and a value of FALSE(2) indicates that this port should be assumed as a non-edge-port.')
dot1sCistPortOperEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortOperEdgeStatus.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortOperEdgeStatus.setDescription('The operational value of the Edge Port parameter. The object is initialized to the value of dot1sCistPortAdminEdgeStatus and is set FALSE on reception of a BPDU.')
dot1sCistPortProtocolMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortProtocolMigration.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortProtocolMigration.setDescription('Indicates the Protocol migration state of this Port. When operating in RSTP/MSTP (version >= 2) mode, writing TRUE(1) to this object forces this port to transmit MSTP BPDUs without instance information. Any other operation on this object has no effect and it always returns FALSE(2) when read.')
dot1sCistPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("discarding", 2), ("learning", 4), ("forwarding", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortState.setDescription('Current state of the Port as defined by the Common spanning tree protocol.')
dot1sCistForcePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistForcePortState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistForcePortState.setDescription("Current state of the Port which can be changed to either Disabled or Enabled for ALL spanning tree instances. Setting this object will override the port's status in any of the MSTI contexts")
dot1sCistPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortForwardTransitions.setDescription('Number of times this port has transitioned to the Forwarding State.')
dot1sCistPortRxMstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRxMstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRxMstBpduCount.setDescription('Number of MST BPDUs received on this port.')
dot1sCistPortRxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRxRstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRxRstBpduCount.setDescription('Number of RST BPDUs received on this port.')
dot1sCistPortRxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRxConfigBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRxConfigBpduCount.setDescription('Number of Configuration BPDUs received on this port.')
dot1sCistPortRxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRxTcnBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRxTcnBpduCount.setDescription('Number of TCN BPDUs received on this port.')
dot1sCistPortTxMstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTxMstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTxMstBpduCount.setDescription('Number of MST BPDUs Transmitted from this port.')
dot1sCistPortTxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTxRstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTxRstBpduCount.setDescription('Number of RST BPDUs Transmitted from this port.')
dot1sCistPortTxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTxConfigBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTxConfigBpduCount.setDescription('Number of Configuration BPDUs Transmitted from this port.')
dot1sCistPortTxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTxTcnBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTxTcnBpduCount.setDescription('Number of TCN BPDUs Transmitted from this port.')
dot1sCistPortInvalidMstBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortInvalidMstBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortInvalidMstBpduRxCount.setDescription('Number of Invalid MST BPDUs Received on this port.')
dot1sCistPortInvalidRstBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortInvalidRstBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortInvalidRstBpduRxCount.setDescription('Number of Invalid RST BPDUs Received on this port.')
dot1sCistPortInvalidConfigBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortInvalidConfigBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortInvalidConfigBpduRxCount.setDescription('Number of Invalid Configuration BPDUs Received on this port.')
dot1sCistPortInvalidTcnBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortInvalidTcnBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortInvalidTcnBpduRxCount.setDescription('Number of Invalid TCN BPDUs Received on this port.')
dot1sCistPortTransmitSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("transmitinit", 0), ("transmitperiodic", 1), ("transmitconfig", 2), ("transmittcn", 3), ("transmitrstp", 4), ("idle", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTransmitSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTransmitSemState.setDescription('Indicates current State of the Port Transmit state machine.')
dot1sCistPortReceiveSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("discard", 0), ("receive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortReceiveSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortReceiveSemState.setDescription('Indicates current State of the Port Receive state machine.')
dot1sCistPortProtMigrationSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("init", 0), ("sendrstp", 1), ("sendingrstp", 2), ("sendstp", 3), ("sendingstp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortProtMigrationSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortProtMigrationSemState.setDescription('Indicates current State of the Port Protocol Migration State machine.')
dot1sCistProtocolMigrationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistProtocolMigrationCount.setStatus('current')
if mibBuilder.loadTexts: dot1sCistProtocolMigrationCount.setDescription('The number of times this Port has migrated from one STP protocol version to another. The relevant protocols are STP-COMPATIBLE and RSTP/MSTP. A Trap is generated on the occurence of this event.')
dot1sCistPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port.')
dot1sCistPortRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 32), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRegionalRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRegionalRoot.setDescription('The unique Bridge Identifier of the bridge recorded as the CIST Regional Root Identifier in the configuration BPDUs transmitted.')
dot1sCistPortRegionalPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRegionalPathCost.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRegionalPathCost.setDescription('The contribution of this port to the path cost of paths towards the CIST Regional Root which include this port.')
dot1sCistSelectedPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistSelectedPortRole.setStatus('current')
if mibBuilder.loadTexts: dot1sCistSelectedPortRole.setDescription('Selected Port Role of the port for this spanning tree instance.')
dot1sCistCurrentPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistCurrentPortRole.setStatus('current')
if mibBuilder.loadTexts: dot1sCistCurrentPortRole.setDescription('Current Port Role of the port for this spanning tree instance.')
dot1sCistPortInfoSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 0), ("aged", 1), ("update", 2), ("superiordesg", 3), ("repeatdesg", 4), ("inferiordesg", 5), ("notdesg", 6), ("current", 7), ("receive", 8), ("other", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortInfoSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortInfoSemState.setDescription('Current state of the Port Information State Machine for this port in this spanning tree context.')
dot1sCistPortRoleTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("init", 0), ("disableport", 1), ("disabledport", 2), ("rootport", 3), ("designatedport", 4), ("alternateport", 5), ("masterport", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortRoleTransitionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRoleTransitionSemState.setDescription('Current state of the Port Role Transition State Machine for this port in this spanning tree context.')
dot1sCistPortStateTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("discarding", 0), ("learning", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortStateTransitionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortStateTransitionSemState.setDescription('Current state of the Port State Transition State Machine for this port in this spanning tree context.')
dot1sCistPortTopologyChangeSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("inactive", 0), ("learning", 1), ("detected", 2), ("active", 3), ("notifiedtcn", 4), ("notifiedtc", 5), ("propagating", 6), ("acknowledged", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortTopologyChangeSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortTopologyChangeSemState.setDescription('Current state of the Topology Change State Machine for this port in this spanning tree context.')
dot1sCistPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 40), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortHelloTime.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on this port in units of hundredths of a second.')
dot1sCistPortOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2), ("mstp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortOperVersion.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortOperVersion.setDescription('This indicates whether the Port is operationally in the Mstp mode, Rstp mode or the Stp-compatible mode i.e., whether the Port is transmitting MST BPDUs, RST BPDUs or Config/TCN BPDUs.')
dot1sCistPortEffectivePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 42), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sCistPortEffectivePortState.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortEffectivePortState.setDescription('The effective operational state of the port for CIST. This will TRUE only when the port is operationally up in the Interface level and Protocol level for CIST. This is will be set to False for all other times.')
dot1sCistPortAutoEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 43), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortAutoEdgeStatus.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortAutoEdgeStatus.setDescription('This parameter when TRUE(1) indicates that detection of a port as Edge Port happens automatically and FALSE(2) indicates that this feature is disabled.')
dot1sCistPortRestrictedRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 44), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortRestrictedRole.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRestrictedRole.setDescription("A Boolean value set by management. If TRUE causes the Port not to be selected as Root Port for the CIST or any MSTI, even it has the best spanning tree priority vector. Such a Port will be selected as an Alternate Port after the Root Port has been selected. This parameter should be FALSE by default. If set it can cause lack of spanning tree connectivity. It is set by a network administrator to prevent bridges external to a core region of the network influencing the spanning tree active topology, possibly because those bridges are not under the full control of the administrator. This administrator configuration is also known as 'Root Guard'.")
dot1sCistPortRestrictedTCN = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 6, 1, 45), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sCistPortRestrictedTCN.setStatus('current')
if mibBuilder.loadTexts: dot1sCistPortRestrictedTCN.setDescription('A Boolean value set by management. If TRUE causes the Port not to propagate received topology change notifications and topology changes to other Ports. This parameter should be FALSE by default. If set it can cause temporary loss of connectivity after changes in a spanning trees active topology as a result of persistent incorrectly learnt station location information. It is set by a network administrator to prevent bridges external to a core region of the network causing address flushing in that region, possibly because those bridges are not under the full control of the administrator or MAC_Operational for the attached LANs transitions frequently.')
dot1sMstiPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7), )
if mibBuilder.loadTexts: dot1sMstiPortTable.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortTable.setDescription('This table contains Spanning Tree Instance Specific Port Information.')
dot1sMstiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sMstiPort"), (0, "AT-GS950-16-MIB", "dot1sInstanceIndex"))
if mibBuilder.loadTexts: dot1sMstiPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortEntry.setDescription('A list of information maintained by every port for each and every spanning tree instance.')
dot1sMstiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dot1sMstiPort.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPort.setDescription('The Port number of the port for which this entry contains spanning tree information.')
dot1sMstiPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiPortPathCost.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the MSTI Root which include this port.')
dot1sMstiPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiPortPriority.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortPriority.setDescription('The four most significant bits of the Port Identifier for a given Spanning Tree instance can be modified independently for each Spanning Tree instance supported by the Bridge. The values that are set for Port Priority must be in steps of 16.')
dot1sMstiPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortDesignatedRoot.setDescription('The unique Bridge Identifier of the bridge recorded as the MSTI Regional Root in the configuration BPDUs transmitted.')
dot1sMstiPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortDesignatedBridge.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortDesignatedBridge.setDescription("The unique Bridge Identifier of the bridge which this port considers to be the Designated Bridge for the port's segment.")
dot1sMstiPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortDesignatedPort.setDescription("The Port identifier of the port on the Designated Bridge for this port's segment.")
dot1sMstiPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("discarding", 2), ("learning", 4), ("forwarding", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortState.setDescription('Current state of the Port as defined by the Multiple spanning tree protocol. Port which is Forwarding state in one instance can be in Discarding (Blocking) state in another instance.')
dot1sMstiForcePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstiForcePortState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiForcePortState.setDescription("Current state of the Port which can be changed to either Disabled or Enabled for the specific spanning tree instance. This object can be set to enabled only if the 'dot1sCistForcePortState' is set to 'enabled' for this port")
dot1sMstiPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortForwardTransitions.setDescription('Number of times this port has transitioned to the Forwarding State for specific instance.')
dot1sMstiPortReceivedBPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortReceivedBPDUs.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortReceivedBPDUs.setDescription('Number of BPDUs received by this port for this spanning tree instance.')
dot1sMstiPortTransmittedBPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortTransmittedBPDUs.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortTransmittedBPDUs.setDescription('Number of BPDUs transmitted on this port for this spanning tree instance.')
dot1sMstiPortInvalidBPDUsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortInvalidBPDUsRcvd.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortInvalidBPDUsRcvd.setDescription('Number of Invalid BPDUs received on this Port for this spanning tree instance.')
dot1sMstiPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port.')
dot1sMstiSelectedPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ("master", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiSelectedPortRole.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiSelectedPortRole.setDescription('Selected Port Role of the port for this spanning tree instance.')
dot1sMstiCurrentPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ("master", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiCurrentPortRole.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiCurrentPortRole.setDescription('Current Port Role of the port for this spanning tree instance.')
dot1sMstiPortInfoSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 0), ("aged", 1), ("update", 2), ("superiordesg", 3), ("repeatdesg", 4), ("inferiordesg", 5), ("notdesg", 6), ("current", 7), ("receive", 8), ("other", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortInfoSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortInfoSemState.setDescription('Current state of the Port Information State Machine for this port in this spanning tree context.')
dot1sMstiPortRoleTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("init", 0), ("disableport", 1), ("disabledport", 2), ("rootport", 3), ("designatedport", 4), ("alternateport", 5), ("masterport", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortRoleTransitionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortRoleTransitionSemState.setDescription('Current state of the Port Role Transition State Machine for this port in this spanning tree context.')
dot1sMstiPortStateTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("discarding", 0), ("learning", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortStateTransitionSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortStateTransitionSemState.setDescription('Current state of the Port State Transition State Machine for this port in this spanning tree context.')
dot1sMstiPortTopologyChangeSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("inactive", 0), ("learning", 1), ("detected", 2), ("active", 3), ("notifiedtcn", 4), ("notifiedtc", 5), ("propagating", 6), ("acknowledged", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortTopologyChangeSemState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortTopologyChangeSemState.setDescription('Current state of the Topology Change State Machine for this port in this spanning tree context.')
dot1sMstiPortEffectivePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 1, 7, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sMstiPortEffectivePortState.setStatus('current')
if mibBuilder.loadTexts: dot1sMstiPortEffectivePortState.setDescription('The effective operational stae of the port for specific instance. This is will be TRUE only when the port is operationally up in the interface level and Protocol level for the specific instance. This is will be set to false at all other times.')
dot1sMstSetGlobalTrapOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sMstSetGlobalTrapOption.setStatus('current')
if mibBuilder.loadTexts: dot1sMstSetGlobalTrapOption.setDescription('This object is used to enable and disable MSTP traps for memory failure or buffer failure irrespective of the context in which the failure occurs. 0 - Traps are not enabled. 1 - Memory and buffer failure traps enabled')
dot1sGlobalErrTrapType = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("memfail", 1), ("bufffail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sGlobalErrTrapType.setStatus('current')
if mibBuilder.loadTexts: dot1sGlobalErrTrapType.setDescription('Used within the Trap Notification PDU. It returns the following values none - none of the below values memfail - memory allocation failure bufffail - buffer allocation failure')
dot1sMstTrapsControlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 3), )
if mibBuilder.loadTexts: dot1sMstTrapsControlTable.setStatus('current')
if mibBuilder.loadTexts: dot1sMstTrapsControlTable.setDescription('List of per virtual bridge Trap Control Info.')
dot1sMstTrapsControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sMstContextId"))
if mibBuilder.loadTexts: dot1sMstTrapsControlEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sMstTrapsControlEntry.setDescription('Virtual bridge TrapsControl information.')
dot1sSetTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1sSetTraps.setStatus('current')
if mibBuilder.loadTexts: dot1sSetTraps.setDescription('This object is used to enable and disable context-specific MSTP traps. Currently the following are defined 0 - Traps are not enabled. 1 - General Traps like protocol up or down 2 - Exception Traps like port protocol migration or invalid packet rcvd in port 3 - All the above Traps ')
dot1sGenTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sGenTrapType.setStatus('current')
if mibBuilder.loadTexts: dot1sGenTrapType.setDescription('Used within the Trap Notification PDU. It denotes general events like none - none of the below values up - protocol UP, down - protocol DOWN')
dot1sPortTrapNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4), )
if mibBuilder.loadTexts: dot1sPortTrapNotificationTable.setStatus('current')
if mibBuilder.loadTexts: dot1sPortTrapNotificationTable.setDescription('This table is used to store the notification information occured in each of the port for protocol migration and invalid packet received. This table is maintained per virtual context in the system.')
dot1sPortTrapNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sPortTrapIndex"))
if mibBuilder.loadTexts: dot1sPortTrapNotificationEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sPortTrapNotificationEntry.setDescription('This entry is used to store the notification information')
dot1sPortTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)))
if mibBuilder.loadTexts: dot1sPortTrapIndex.setStatus('current')
if mibBuilder.loadTexts: dot1sPortTrapIndex.setDescription('A unique value, greater than zero, indicating the Port number.')
dot1sPortMigrationType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("sendstp", 0), ("sendrstp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sPortMigrationType.setStatus('current')
if mibBuilder.loadTexts: dot1sPortMigrationType.setDescription('Port Protocol migration type occured in the port')
dot1sPktErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("protocolIdErr", 0), ("invalidBpdu", 1), ("configLengthErr", 2), ("tcnLengthErr", 3), ("rstpLengthErr", 4), ("maxAgeErr", 5), ("fwdDelayErr", 6), ("helloTimeErr", 7), ("mstpLengthErr", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sPktErrType.setStatus('current')
if mibBuilder.loadTexts: dot1sPktErrType.setDescription('Type of invalid packet received in each of the port ')
dot1sPktErrVal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sPktErrVal.setStatus('current')
if mibBuilder.loadTexts: dot1sPktErrVal.setDescription('Packet error value corresponding to the above type ')
dot1sPortRoleTrapNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 5), )
if mibBuilder.loadTexts: dot1sPortRoleTrapNotificationTable.setStatus('current')
if mibBuilder.loadTexts: dot1sPortRoleTrapNotificationTable.setDescription('This table is used to store the notification information occured in each of the port for its role change. This table is maintained per virtual context in the system.')
dot1sPortRoleTrapNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1sPortTrapIndex"), (0, "AT-GS950-16-MIB", "dot1sMstiInstanceIndex"))
if mibBuilder.loadTexts: dot1sPortRoleTrapNotificationEntry.setStatus('current')
if mibBuilder.loadTexts: dot1sPortRoleTrapNotificationEntry.setDescription('This entry is used to store the notification information')
dot1sPortRoleType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabledPort", 0), ("alternatePort", 1), ("backupPort", 2), ("rootPort", 3), ("designatedPort", 4), ("masterport", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sPortRoleType.setStatus('current')
if mibBuilder.loadTexts: dot1sPortRoleType.setDescription('Particular Role Selected for the Port')
dot1sOldRoleType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabledPort", 0), ("alternatePort", 1), ("backupPort", 2), ("rootPort", 3), ("designatedPort", 4), ("masterport", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1sOldRoleType.setStatus('current')
if mibBuilder.loadTexts: dot1sOldRoleType.setDescription('Particular Role which is existing for the Port')
dot1sTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0))
dot1sGlobalErrTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 1)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sGlobalErrTrapType"))
if mibBuilder.loadTexts: dot1sGlobalErrTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sGlobalErrTrap.setDescription('Generated when any of the error events like memory failure or buffer failure or protocol migration or new root or topology change occurs ')
dot1sGenTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 2)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sGenTrapType"))
if mibBuilder.loadTexts: dot1sGenTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sGenTrap.setDescription('Generated when any of the general events like protocol up or protocol down occurs')
dot1sNewRootTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 3)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sOldDesignatedRoot"), ("AT-GS950-16-MIB", "dot1sMstiBridgeRegionalRoot"))
if mibBuilder.loadTexts: dot1sNewRootTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sNewRootTrap.setDescription('Generated whenever a new root bridge is selected in the topology ')
dot1sTopologyChgTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 4)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sMstiTopChanges"))
if mibBuilder.loadTexts: dot1sTopologyChgTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sTopologyChgTrap.setDescription('Generated when topology change is detected ')
dot1sProtocolMigrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 5)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sForceProtocolVersion"), ("AT-GS950-16-MIB", "dot1sPortMigrationType"))
if mibBuilder.loadTexts: dot1sProtocolMigrationTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sProtocolMigrationTrap.setDescription('Generated when port protocol migration happens in the port ')
dot1sInvalidBpduRxdTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 6)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sPktErrType"), ("AT-GS950-16-MIB", "dot1sPktErrVal"))
if mibBuilder.loadTexts: dot1sInvalidBpduRxdTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sInvalidBpduRxdTrap.setDescription('Generated when the invalid packet is received for bpdu/stp/rstp/maximum age/forward delay/hello time')
dot1sRegionConfigChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 7)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sContextName"), ("AT-GS950-16-MIB", "dot1sMstiConfigIdSel"), ("AT-GS950-16-MIB", "dot1sMstiRegionName"), ("AT-GS950-16-MIB", "dot1sMstiRegionVersion"), ("AT-GS950-16-MIB", "dot1sMstiConfigDigest"))
if mibBuilder.loadTexts: dot1sRegionConfigChangeTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sRegionConfigChangeTrap.setDescription("Generated when the MST region's configuration identifier changes.")
dot1sNewPortRoleTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 118, 3, 0, 8)).setObjects(("AT-GS950-16-MIB", "dot1sBrgAddress"), ("AT-GS950-16-MIB", "dot1sPortRoleType"), ("AT-GS950-16-MIB", "dot1sOldRoleType"))
if mibBuilder.loadTexts: dot1sNewPortRoleTrap.setStatus('current')
if mibBuilder.loadTexts: dot1sNewPortRoleTrap.setDescription('Generated whenever a new role is selected for the port ')
dot1wRst = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1))
dot1wRstTrapsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2))
dot1wRstTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3))
dot1wRstTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3), )
if mibBuilder.loadTexts: dot1wRstTable.setStatus('current')
if mibBuilder.loadTexts: dot1wRstTable.setDescription('List of per virtual context RstModule Parameters')
dot1wRstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1wRstContextId"))
if mibBuilder.loadTexts: dot1wRstEntry.setStatus('current')
if mibBuilder.loadTexts: dot1wRstEntry.setDescription('Virtual Bridge RstModule Parameters.')
dot1wRstContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1wRstContextId.setStatus('current')
if mibBuilder.loadTexts: dot1wRstContextId.setDescription('Identifies the Virtual Bridge Context.')
dot1wSystemControl = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wSystemControl.setStatus('current')
if mibBuilder.loadTexts: dot1wSystemControl.setDescription("The administrative system control status requested by management for the RSTP feature. The value 'start'(1) indicates that all resources required by RSTP should be allocated and RSTP should be supported in the device on all ports. The value shutdown(2) indicates that RSTP should be shutdown in the device on all ports and all allocated memory must be released.")
dot1wModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 3), EnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wModuleStatus.setStatus('current')
if mibBuilder.loadTexts: dot1wModuleStatus.setDescription("The administrative module status requested by management for the RSTP Module. This enables or disables RSTP in the system. A value of 'enabled' (1) indicates that RSTP must be enabled in the device on all the ports. A value of 'disabled'(2) indicates that RSTP must be disabled in the device on all the ports. This object can be set only after the object dot1wSystemControl has been set.")
dot1wTraceOption = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wTraceOption.setStatus('current')
if mibBuilder.loadTexts: dot1wTraceOption.setDescription('This object is used to enable Trace Statements in the RSTP Module. A FOUR BYTE integer is used for enabling the level of tracing. Each BIT in the four byte integer, represents a particular level of Trace. The mapping between the bit positions & the level of trace is as follows: 0 - Init and Shutdown Traces 1 - Management Traces 2 - Data Path Traces 3 - Control Plane Traces 4 - Packet Dump Traces 5 - Traces related to All Resources except Buffers 6 - All Failure Traces 7 - Buffer Traces The remaining bits are unused. Combination of trace levels are also allowed. For example if the bits 0 and 1 are set, then the Trace statements related to Init-Shutdown and management will be printed. The user has to enter the corresponding INTEGER VALUE for the bits set. For example if bits 0 and 1 are to be set then user has to give the value for this object as 3. Setting the Trace Option to any value will cause the Debug Option to be set to 0 (i.e.) the Trace Option and Debug Option are mutually exclusive.')
dot1wDebugOption = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 262143))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wDebugOption.setStatus('current')
if mibBuilder.loadTexts: dot1wDebugOption.setDescription('This object is used to enable Debug Statements in the RSTP Module. A FOUR BYTE integer is used for enabling the level of debugging. Each BIT in the four byte integer, represents a particular level of Debug. The mapping between the bit positions & the level of debug is as follows: 0 - Init and Shutdown Debug statements 1 - Management Debug statements 2 - Memory related Debug statements 3 - BPDU related Debug statements 4 - Event Handling Debug statements 5 - Timer Module Debug statements 6 - Port Information SEM Debug statements 7 - Port Receive SEM Debug statements 8 - Role Selection SEM Debug statements 9 - Role Transition SEM Debug statements 10 - State Transition SEM Debug statements 11 - Protocol Migration SEM Debug statements 12 - Topology Change SEM Debug statements 13 - Port Transmit SEM Debug statements 14 - Bridge Detection SEM Debug statements 15 - All Failure Debug statements 16 - Redundancy code flow Debug statements 17 - State Machine variable changes debug statements The remaining bits are unused. Combination of debug levels are also allowed. For example if the bits 0 and 1 are set, then the Debug statements related to Init-Shutdown and management will be printed. The user has to enter the corresponding INTEGER VALUE for the bits set. For example if bits 0 and 1 are to be set then user has to give the value for this object as 3. Setting the Debug Option to any value will cause the Trace Option to be set to 0 (i.e.) the Trace Option and Debug Option are mutually exclusive.')
dot1wRstpUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wRstpUpCount.setStatus('current')
if mibBuilder.loadTexts: dot1wRstpUpCount.setDescription('The number of times RSTP Module has been enabled.')
dot1wRstpDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wRstpDownCount.setStatus('current')
if mibBuilder.loadTexts: dot1wRstpDownCount.setDescription('The number of times RSTP Module has been disabled.')
dot1wBufferFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wBufferFailureCount.setStatus('current')
if mibBuilder.loadTexts: dot1wBufferFailureCount.setDescription('The number of times buffer overflows/failures have occurred. A Trap is generated on the occurrence of this event.')
dot1wMemAllocFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wMemAllocFailureCount.setStatus('current')
if mibBuilder.loadTexts: dot1wMemAllocFailureCount.setDescription('The number of times memory allocation failures have occurred. A Trap is generated on the occurrence of this event.')
dot1wNewRootIdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wNewRootIdCount.setStatus('current')
if mibBuilder.loadTexts: dot1wNewRootIdCount.setDescription('The number of times this Bridge has detected a new Root in the topology. A Trap is generated on the occurrence of this event.')
dot1wPortRoleSelSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("initbridge", 0), ("roleselection", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRoleSelSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRoleSelSmState.setDescription("This indicates the current state of the Port Role Selection State Machine. This object will hold the value 'initbridge' when the Port Role Selection state machine is in the INIT_BRIDGE state and the value of 'roleselection' when the state machine is in the ROLE_SELECTION state.")
dot1wOldDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 12), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wOldDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: dot1wOldDesignatedRoot.setDescription('The bridge identifier of the old root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. ')
dot1wDynamicPathcostCalculation = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wDynamicPathcostCalculation.setStatus('current')
if mibBuilder.loadTexts: dot1wDynamicPathcostCalculation.setDescription('This object is used to determine whether dynamic pathcost calculation is allowed or not.The value is determined by management. If set to true, pathcost is calculated dynamically from port speed, otherwise the link speed at the time of port creation is used for calculating the path cost. In both cases if the user has configured a pathcost for the port that will be used. By default dynamic pathcost calculation is set to false.')
dot1wContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wContextName.setStatus('current')
if mibBuilder.loadTexts: dot1wContextName.setDescription('This object is used to identity the context-name.')
dot1wPortExtTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4), )
if mibBuilder.loadTexts: dot1wPortExtTable.setStatus('current')
if mibBuilder.loadTexts: dot1wPortExtTable.setDescription('This is a table that is an extension to the dot1dStpExtPortTable. This contains object(s) that are Port-based.')
dot1wPortExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1wPort"))
if mibBuilder.loadTexts: dot1wPortExtEntry.setStatus('current')
if mibBuilder.loadTexts: dot1wPortExtEntry.setDescription('Each entry in this table is for each port present in the system. This table is indexed by the dot1wPort.')
dot1wPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)))
if mibBuilder.loadTexts: dot1wPort.setStatus('current')
if mibBuilder.loadTexts: dot1wPort.setDescription('A unique value, greater than zero, indicating the Port number.')
dot1wPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabledPort", 0), ("alternatePort", 1), ("backupPort", 2), ("rootPort", 3), ("designatedPort", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRole.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRole.setDescription('This indicates the current Port Role assumed by this Port.')
dot1wPortOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortOperVersion.setStatus('current')
if mibBuilder.loadTexts: dot1wPortOperVersion.setDescription('This indicates whether the Port is operationally in the Rstp mode or the Stp-compatible mode i.e., whether the Port is transmitting RST BPDUs or Config/TCN BPDUs.')
dot1wPortInfoSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("disabled", 0), ("aged", 1), ("update", 2), ("superior", 3), ("repeat", 4), ("notdesignated", 5), ("present", 6), ("receive", 7), ("inferiordesignated", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortInfoSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortInfoSmState.setDescription("This indicates the current state of the Port Information state machine. This object will hold the value 'disabled' when the Port Information state machine is in the DISABLED state, the value 'aged' when the state machine is in the AGED state, the value 'update' when the state machine is in the UPDATE state, the value 'superior' when the state machine is in the SUPERIOR state, the value 'repeat' when the state machine is in the REPEAT state, the value 'notdesignated' when the state machine is in the NOT_DESIGNATED state, the value 'present' when the state machine is in the CURRENT state and the value 'receive' when the state machine is in the RECEIVE state and the value 'inferiordesignated' when the state machine is in the INFERIOR_DESIGNATED state.")
dot1wPortMigSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("checkingrstp", 0), ("selectingstp", 1), ("sensing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortMigSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortMigSmState.setDescription("This indicates the current state of the Port Protocol Migration state machine. This object will hold the value 'checkingrstp' when the Protocol Migration state machine is in the CHECKING_RSTP state, the value 'selectingstp' when the state machine is in the SELECTING_STP state, the value 'sensing' when the state machine is in the SENSING state.")
dot1wPortRoleTransSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("init", 0), ("disableport", 1), ("disabledport", 2), ("rootport", 3), ("designatedport", 4), ("backupport", 5), ("rootproposed", 6), ("rootagreed", 7), ("reroot", 8), ("rootforward", 9), ("rootlearn", 10), ("rerooted", 11), ("designatedpropose", 12), ("designatedsynced", 13), ("designatedretired", 14), ("designatedforward", 15), ("designatedlearn", 16), ("designatedlisten", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRoleTransSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRoleTransSmState.setDescription("This indicates the current state of the Port Role Transition state machine. This object will hold the value 'init' when the Port Role Transition state machine is in the INIT state, the value 'disableport' when the state machine is in the DISABLE_PORT state, the value 'disabledport' when the state machine is in the DISABLED_PORT state, the value 'rootport' when the state machine is in the ROOT_PORT state, the value 'desgport' when the state machine is in the DESIGNATED_PORT state, the value 'backupport' when the state machine is in BACKUP_PORT state, the value 'rootproposed' when the state machine is in the ROOT_PROPOSED state, the value 'rootagreed' when the state machine is in the ROOT_AGREED state, the value 'reroot' when the state machine is in the REROOT state, the value 'rootforward' when the state machine is in the ROOT_FORWARD state, the value 'rootlearn' when the state machine is in the ROOT_LEARN state, the value 'rerooted' when the state machine is in the REROOTED state, the value 'designatedpropose' when the state machine is in the DESIGNATED_PROPOSE state, the value 'designatedsynced' when the state machine is in the DESIGNATED_SYNCED state, the value 'designatedretired' when the state machine is in the DESIGNATED_RETIRED state, the value 'designatedforward' when the state machine is in the DESIGNATED_FORWARD state, the value 'designatedlearn' when the state machine is in the DESIGNATED_LEARN state and the value 'designatedlisten' when the state machine is in the DESIGNATED_LISTEN state.")
dot1wPortStateTransSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("discarding", 0), ("learning", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortStateTransSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortStateTransSmState.setDescription("This indicates the current state of the Port State Transition state machine. This object will hold the value 'discarding' when the Port State Transition state machine is in the DISCARDING state, the value 'learning' when the state machine is in the LEARNING state and the value 'forwarding' when the state machine is in the FORWARDING state.")
dot1wPortTopoChSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("inactive", 0), ("learning", 1), ("detected", 2), ("active", 3), ("notifiedtcn", 4), ("notifiedtc", 5), ("propagating", 6), ("acknowledged", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortTopoChSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTopoChSmState.setDescription("This indicates the current state of the Topology Change state machine. This object will hold the value 'inactive' when the Topology Change state machine is in the INACTIVE state, the value 'learning' when the state machine is in the LEARNING state, the value 'active' when the state machine is in the ACTIVE state, the value 'detected' when the state machine is in the DETECTED state, the value 'notifiedtcn' when the state machine is in the NOTIFIED_TCN state, the value 'notifiedtc' when the state machine is in the NOTIFIED_TC state, the value 'propagating' state when the state machine is in the PROPAGATING state and the value 'acknowledged' when the state machine is in the ACKNOWLEDGED state.")
dot1wPortTxSmState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("transmitinit", 0), ("transmitperiodic", 1), ("transmitconfig", 2), ("transmittcn", 3), ("transmitrstp", 4), ("idle", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortTxSmState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTxSmState.setDescription("This indicates the current state of the Port Transmit state machine. This object will hold the value 'transmitinit' when the Port Transmit state machine is in the TRANSMIT_INIT state, the value 'transmitperiodic' when the state machine is in the TRANSMIT_PERIODIC state, the value 'transmitconfig' when the state machine is in the TRANSMIT_CONFIG state, the value 'transmittcn', when the state machine is in the TRANSMIT_TCN state, the value 'transmitrstp', when the state machine is in the TRANSMIT_RSTP state and the value 'idle' when the state machine is in the IDLE state.")
dot1wPortRxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRxRstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRxRstBpduCount.setDescription('The number of RST BPDUs that have been received on this Port.')
dot1wPortRxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRxConfigBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRxConfigBpduCount.setDescription('The number of Config BPDUs that have been received on this Port.')
dot1wPortRxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRxTcnBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRxTcnBpduCount.setDescription('The number of TCN BPDUs that have been received on this Port.')
dot1wPortTxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortTxRstBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTxRstBpduCount.setDescription('The number of RST BPDUs that have been transmitted by this Port.')
dot1wPortTxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortTxConfigBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTxConfigBpduCount.setDescription('The number of Config BPDUs that have been transmitted by this Port.')
dot1wPortTxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortTxTcnBpduCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTxTcnBpduCount.setDescription('The number of TCN BPDUs that have been transmitted by this Port.')
dot1wPortInvalidRstBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortInvalidRstBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortInvalidRstBpduRxCount.setDescription('The number of invalid RSTP BPDUs that have been received on this Port. A Trap is generated on the occurrence of this event.')
dot1wPortInvalidConfigBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortInvalidConfigBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortInvalidConfigBpduRxCount.setDescription('The number of invalid Configuration BPDUs that have been received on this Port. A Trap is generated on the occurrence of this event.')
dot1wPortInvalidTcnBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortInvalidTcnBpduRxCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortInvalidTcnBpduRxCount.setDescription('The number of invalid TCN BPDUs that have been received on this Port. A Trap is generated on the occurrence of this event.')
dot1wPortProtocolMigrationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortProtocolMigrationCount.setStatus('current')
if mibBuilder.loadTexts: dot1wPortProtocolMigrationCount.setDescription('The number of times this Port has migrated from one STP protocol version to another. The relevant protocols are STP-COMPATIBLE and RSTP. A Trap is generated on the occurrence of this event.')
dot1wPortEffectivePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortEffectivePortState.setStatus('current')
if mibBuilder.loadTexts: dot1wPortEffectivePortState.setDescription('The effective Operational state of the port. This object will be set to TRUE only when the port is operationally up in the interface manager and the force Port State for this port and specified port state is enabled. Otherwise this object is set to FALSE.')
dot1wPortAutoEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wPortAutoEdge.setStatus('current')
if mibBuilder.loadTexts: dot1wPortAutoEdge.setDescription('This parameter when TRUE(1) indicates that detection of a port as Edge Port happens automatically and FALSE(2) indicates that this feature is disabled.')
dot1wPortRestrictedRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wPortRestrictedRole.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRestrictedRole.setDescription("A Boolean value set by management. If TRUE causes the Port not to be selected as Root Port for the CIST or any MSTI, even it has the best spanning tree priority vector. Such a Port will be selected as an Alternate Port after the Root Port has been selected. This parameter should be FALSE by default. If set it can cause lack of spanning tree connectivity. It is set by a network administrator to prevent bridges external to a core region of the network influencing the spanning tree active topology, possibly because those bridges are not under the full control of the administrator. This administrator configuration is also known as 'Root Guard'.")
dot1wPortRestrictedTCN = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 1, 4, 1, 23), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wPortRestrictedTCN.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRestrictedTCN.setDescription('A Boolean value set by management. If TRUE causes the Port not to propagate received topology change notifications and topology changes to other Ports. This parameter should be FALSE by default. If set it can cause temporary loss of connectivity after changes in a spanning trees active topology as a result of persistent incorrectly learnt station location information. It is set by a network administrator to prevent bridges external to a core region of the network causing address flushing in that region, possibly because those bridges are not under the full control of the administrator or MAC_Operational for the attached LANs transitions frequently.')
dot1wSetGlobalTraps = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wSetGlobalTraps.setStatus('current')
if mibBuilder.loadTexts: dot1wSetGlobalTraps.setDescription('This object is used to enable and disable RSTP traps for memory failure or buffer failure irrespective of the context in which the failure occurs. 0 - Traps are not enabled. 1 - Memory and buffer failure traps enabled')
dot1wGlobalErrTrapType = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("memfail", 1), ("bufffail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wGlobalErrTrapType.setStatus('current')
if mibBuilder.loadTexts: dot1wGlobalErrTrapType.setDescription('Used within the Trap Notification PDU. It returns the following values none - none of the below values memfail - memory allocation failure bufffail - buffer allocation failure')
dot1wRstTrapsControlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 3), )
if mibBuilder.loadTexts: dot1wRstTrapsControlTable.setStatus('current')
if mibBuilder.loadTexts: dot1wRstTrapsControlTable.setDescription('List of per virtual bridge TrapsControl Info.')
dot1wRstTrapsControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1wRstContextId"))
if mibBuilder.loadTexts: dot1wRstTrapsControlEntry.setStatus('current')
if mibBuilder.loadTexts: dot1wRstTrapsControlEntry.setDescription('Virtual bridge TrapsControl information.')
dot1wSetTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1wSetTraps.setStatus('current')
if mibBuilder.loadTexts: dot1wSetTraps.setDescription('This object is used to enable and disable context-specific RSTP traps. Currently the following are defined 0 - Traps are not enabled. 1 - Protocol up or down traps. 2 - Exception Traps like port protocol migration or invalid packet rcvd in port 3 - All the above Traps ')
dot1wGenTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wGenTrapType.setStatus('current')
if mibBuilder.loadTexts: dot1wGenTrapType.setDescription('Used within the Trap Notification PDU. It denotes general events like none - none of the below values up - protocol UP, down - protocol DOWN')
dot1wPortTrapNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4), )
if mibBuilder.loadTexts: dot1wPortTrapNotificationTable.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTrapNotificationTable.setDescription('This table is used to store the notification information occurred in each of the port for protocol migration and invalid packet received ')
dot1wPortTrapNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1wPortTrapIndex"))
if mibBuilder.loadTexts: dot1wPortTrapNotificationEntry.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTrapNotificationEntry.setDescription('This entry is used to store the notification information')
dot1wPortTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)))
if mibBuilder.loadTexts: dot1wPortTrapIndex.setStatus('current')
if mibBuilder.loadTexts: dot1wPortTrapIndex.setDescription('A unique value, greater than zero, indicating the Port number.')
dot1wPortMigrationType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("sendstp", 0), ("sendrstp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortMigrationType.setStatus('current')
if mibBuilder.loadTexts: dot1wPortMigrationType.setDescription('Port Protocol migration type occurred in the port')
dot1wPktErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("protocolIdErr", 0), ("invalidBpdu", 1), ("configLengthErr", 2), ("tcnLengthErr", 3), ("rstpLengthErr", 4), ("maxAgeErr", 5), ("fwdDelayErr", 6), ("helloTimeErr", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPktErrType.setStatus('current')
if mibBuilder.loadTexts: dot1wPktErrType.setDescription('Type of invalid packet received in each of the port ')
dot1wPktErrVal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPktErrVal.setStatus('current')
if mibBuilder.loadTexts: dot1wPktErrVal.setDescription('Packet error value corresponding to the above type ')
dot1wPortRoleType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabledPort", 0), ("alternatePort", 1), ("backupPort", 2), ("rootPort", 3), ("designatedPort", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wPortRoleType.setStatus('current')
if mibBuilder.loadTexts: dot1wPortRoleType.setDescription('Particular Role Selected for the Port')
dot1wOldRoleType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabledPort", 0), ("alternatePort", 1), ("backupPort", 2), ("rootPort", 3), ("designatedPort", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1wOldRoleType.setStatus('current')
if mibBuilder.loadTexts: dot1wOldRoleType.setDescription('Particular Role which is existing for the Port')
dot1wTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0))
dot1wGlobalErrTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 1)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wGlobalErrTrapType"))
if mibBuilder.loadTexts: dot1wGlobalErrTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wGlobalErrTrap.setDescription('Generated when any of the error events like memory failure or buffer failure or protocol migration or new root or topology change occurrs ')
dot1wGenTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 2)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wContextName"), ("AT-GS950-16-MIB", "dot1wGenTrapType"))
if mibBuilder.loadTexts: dot1wGenTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wGenTrap.setDescription('Generated when any of the general events like protocol up or protocol down occurrs')
dot1wNewRootTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 3)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wContextName"), ("AT-GS950-16-MIB", "dot1wOldDesignatedRoot"), ("AT-GS950-16-MIB", "dot1dStpDesignatedRoot"))
if mibBuilder.loadTexts: dot1wNewRootTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wNewRootTrap.setDescription('Generated whenever a new root bridge is selected in the topology ')
dot1wTopologyChgTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 4)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wContextName"))
if mibBuilder.loadTexts: dot1wTopologyChgTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wTopologyChgTrap.setDescription('Generated when topology change is detected ')
dot1wProtocolMigrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 5)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wContextName"), ("AT-GS950-16-MIB", "dot1dStpVersion"), ("AT-GS950-16-MIB", "dot1wPortMigrationType"))
if mibBuilder.loadTexts: dot1wProtocolMigrationTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wProtocolMigrationTrap.setDescription('Generated when port protocol migration happens in the port ')
dot1wInvalidBpduRxdTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 6)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wContextName"), ("AT-GS950-16-MIB", "dot1wPktErrType"), ("AT-GS950-16-MIB", "dot1wPktErrVal"))
if mibBuilder.loadTexts: dot1wInvalidBpduRxdTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wInvalidBpduRxdTrap.setDescription('Generated when the invalid packet is received for bpdu/stp/rstp/maximum age/forward delay/hello time')
dot1wNewPortRoleTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 119, 3, 0, 7)).setObjects(("AT-GS950-16-MIB", "dot1dBaseBridgeAddress"), ("AT-GS950-16-MIB", "dot1wPortRoleType"), ("AT-GS950-16-MIB", "dot1wOldRoleType"))
if mibBuilder.loadTexts: dot1wNewPortRoleTrap.setStatus('current')
if mibBuilder.loadTexts: dot1wNewPortRoleTrap.setDescription('Generated whenever a new role is selected for the port ')
l2Dot1qVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1))
portBaseVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3))
portBaseStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4))
dot1qVlanGlobalTrace = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanGlobalTrace.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanGlobalTrace.setDescription('Enable/Disable the global trace in VLAN.')
dot1qVlanGlobalsTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2), )
if mibBuilder.loadTexts: dot1qVlanGlobalsTable.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanGlobalsTable.setDescription('List of per virtual context Vlan Module Parameters.')
dot1qVlanGlobalsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dot1qVlanGlobalsContextId"))
if mibBuilder.loadTexts: dot1qVlanGlobalsEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanGlobalsEntry.setDescription('Per virtual context Vlan module parmaters.')
dot1qVlanGlobalsContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: dot1qVlanGlobalsContextId.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanGlobalsContextId.setDescription('Identifies the virtual context in the system.')
dot1qGarpShutdownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qGarpShutdownStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qGarpShutdownStatus.setDescription('The administrative status requested by management for GARP The value true(1) indicates that GARP should be shutdown in the device on all ports. All memory will be released. The value false(2) indicates that GARP should be active in the device on all ports. This object can be set to true only when none of the Garp applications (GVRP, GMRP) are enabled. Whenever Garp is enabled after shutdown, Gvrp and Gmrp must be enabled explicitly.')
dot1qVlanDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 524287))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanDebug.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanDebug.setDescription('Enables the tracing in the selected submodule in VLAN. A 32 bit integer is used to store the Tracing level in the specified module. Different Tracing Levels - BIT 0 - Initialisation and Shutdown Trace. BIT 1 - Management trace. BIT 2 - Data path trace. BIT 3 - Control Plane trace. BIT 4 - Packet Dump. BIT 5 - OS Resource trace. BIT 6 - All Failure trace (All failures including Packet Validation) BIT 7 - Buffer Trace. Different submodule Tracing - BIT 16 - Tracing in VLAN module. BIT 17 - Tracing in VLAN Priority module. BIT 18 - Tracing in VLAN Redundancy module. The remaining bits are reserved. The combination of levels and submodules are allowed i.e. Tracing can be allowed at all failure and data path level in All submodules by setting the BIT appropriately. For Example, setting the debug value to the following bit stream, 00000000000000010000000000000100 will enable data path trace prints in VLAN module. Multiple submodules and multiple levels can be combined by setting the corresponding bits. For Example, setting the debug value to the following bit stream, 00000000000000110000000000001100 will enable data path and control plane trace prints in VLAN and VLAN Priority modules. Note : BIT0 is the least significant bit and BIT31 is the most significant bit.')
dot1qVlanLearningMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ivl", 1), ("svl", 2))).clone('ivl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanLearningMode.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanLearningMode.setDescription('The type of VLAN learning mode.')
dot1qVlanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 10), EnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanOperStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanOperStatus.setDescription('The operational status of the Vlan module. The value enabled(1) indicates that Vlan module is currently enabled in the device. The value disabled(2) indicates that Vlan module is currently disabled in the device.')
dot1qGvrpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 1, 2, 1, 11), EnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qGvrpOperStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qGvrpOperStatus.setDescription('The operational status of the GVRP module. The value enabled(1) indicates that GVRP module is currently enabled in the device. The value disabled(2) indicates that GVRP module is currently disabled in the device.')
portBaseVlanEnablePerPort = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 1), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseVlanEnablePerPort.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanEnablePerPort.setDescription('The set of ports which are in port-based VLAN mode.')
portBaseVlanCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2), )
if mibBuilder.loadTexts: portBaseVlanCurrentTable.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanCurrentTable.setDescription('A table containing current configuration information for each VLAN currently configured into the device by (local or network) management, or dynamically created as a result of GVRP requests received.')
tabPortBaseVlanCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "portBaseVlanIndex"))
if mibBuilder.loadTexts: tabPortBaseVlanCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: tabPortBaseVlanCurrentEntry.setDescription('Information for a VLAN configured into the device by (local or network) management, or dynamically created as a result of GVRP requests received.')
portBaseVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: portBaseVlanIndex.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanIndex.setDescription('The VLAN-ID or other identifier referring to this VLAN.')
portBaseVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseVlanName.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanName.setDescription('The VLAN-Name referring to this VLAN.')
portBaseVlanCurrentEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseVlanCurrentEgressPorts.setReference('IEEE 802.1Q/D11 Section 12.10.2.1')
if mibBuilder.loadTexts: portBaseVlanCurrentEgressPorts.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanCurrentEgressPorts.setDescription('The set of ports which are transmitting traffic for this VLAN as either tagged or untagged frames.')
portBaseVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("permanent", 2), ("dynamicGvrp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseVlanStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. permanent(2) - this entry, corresponding to an entry in portBaseVlanStaticTable, is currently in use and will remain so after the next reset of the device. The port lists for this entry include ports from the equivalent portBaseVlanStaticTable entry and ports learnt dynamically. dynamicGvrp(3) - this entry is currently in use and will remain so until removed by GVRP. There is no static entry for this VLAN and it will be removed when the last port leaves the VLAN.')
portBaseVlanCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseVlanCreationTime.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanCreationTime.setDescription('The value of sysUpTime when this VLAN was created.')
portBaseVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 3, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portBaseVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseVlanRowStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active.')
portBaseStaticUnicastTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1), )
if mibBuilder.loadTexts: portBaseStaticUnicastTable.setReference('IEEE 802.1Q/D11 Section 12.7.7, ISO/IEC 15802-3 Section 7.9.1')
if mibBuilder.loadTexts: portBaseStaticUnicastTable.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastTable.setDescription('A table containing filtering information for Unicast MAC addresses for each Filtering Database, configured into the device by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific unicast destination addresses are allowed to be forwarded. A value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for unicast addresses only.')
tabPortBaseStaticUnicastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "portBaseStaticUnicastIndex"))
if mibBuilder.loadTexts: tabPortBaseStaticUnicastEntry.setStatus('current')
if mibBuilder.loadTexts: tabPortBaseStaticUnicastEntry.setDescription('Filtering information configured into the device by (local or network) management specifying the set of ports to which frames received from a specific port and containing a specific unicast destination address are allowed to be forwarded.')
portBaseStaticUnicastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: portBaseStaticUnicastIndex.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastIndex.setDescription('The index of entries int this table.')
portBaseStaticUnicastVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticUnicastVlanIndex.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastVlanIndex.setDescription('The VLAN-ID or other identifier referring to this VLAN.')
portBaseStaticUnicastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticUnicastAddress.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object must take the value of a unicast address.")
portBaseStaticUnicastAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticUnicastAllowedToGoTo.setReference('IEEE 802.1Q/D11 Table 8-5, ISO/IEC 15802-3 Table 7-5')
if mibBuilder.loadTexts: portBaseStaticUnicastAllowedToGoTo.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastAllowedToGoTo.setDescription("The set of ports for which a frame with a specific unicast address will be flooded in the event that it has not been learned. It also specifies the set of ports a specific unicast address may be dynamically learnt on. The portBaseTpFdbTable will have an equivalent entry with a portBaseTpFdbPort value of '0' until this address has been learnt, when it will be updated with the port the address has been seen on. This only applies to ports that are members of the VLAN, defined by portBaseVlanCurrentEgressPorts. The default value of this object is a string of ones of appropriate length.")
portBaseStaticUnicastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticUnicastStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
portBaseStaticUnicastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portBaseStaticUnicastRowStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticUnicastRowStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active.')
portBaseStaticMulticastTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2), )
if mibBuilder.loadTexts: portBaseStaticMulticastTable.setReference('IEEE 802.1Q/D11 Section 12.7.7, ISO/IEC 15802-3 Section 7.9.1')
if mibBuilder.loadTexts: portBaseStaticMulticastTable.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastTable.setDescription('A table containing filtering information for Multicast and Broadcast MAC addresses for each VLAN, configured into the device by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific Multicast and Broadcast destination addresses are allowed to be forwarded. A value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for Multicast and Broadcast addresses only.')
tabPortBaseStaticMulticastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "portBaseStaticMulticastIndex"))
if mibBuilder.loadTexts: tabPortBaseStaticMulticastEntry.setStatus('current')
if mibBuilder.loadTexts: tabPortBaseStaticMulticastEntry.setDescription('Filtering information configured into the device by (local or network) management specifying the set of ports to which frames received from this specific port for this VLAN and containing this Multicast or Broadcast destination address are allowed to be forwarded.')
portBaseStaticMulticastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: portBaseStaticMulticastIndex.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastIndex.setDescription('The index of entries int this table.')
portBaseStaticMulticastVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticMulticastVlanIndex.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastVlanIndex.setDescription('The VLAN-ID or other identifier referring to this VLAN.')
portBaseStaticMulticastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticMulticastAddress.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object must take the value of a Multicast or Broadcast address.")
portBaseStaticMulticastStaticEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticMulticastStaticEgressPorts.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastStaticEgressPorts.setDescription('The set of ports to which frames received from a specific port and destined for a specific Multicast or Broadcast MAC address must be forwarded, regardless of any dynamic information e.g. from GMRP. A port may not be added in this set if it is already a member of the set of ports in portBaseStaticMulticastForbiddenEgressPorts. The default value of this object is a string of ones of appropriate length.')
portBaseStaticMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBaseStaticMulticastStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so differ from the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
portBaseStaticMulticastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 120, 4, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portBaseStaticMulticastRowStatus.setStatus('current')
if mibBuilder.loadTexts: portBaseStaticMulticastRowStatus.setDescription('The status of this concsystual row. All writable objects in this row may be modified only when the row status is not active.')
fsLldpSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 1))
fsLldpTLV = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2))
fsLldpStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 3))
fsLldpNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4))
fsLldpSystemControl = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("start", 1), ("shutdownInProgress", 2), ("shutdown", 3))).clone('start')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpSystemControl.setStatus('current')
if mibBuilder.loadTexts: fsLldpSystemControl.setDescription("The administrative system control status of LLDP module. The value 'start' (1) indicates that all resources required by LLDP module should be allocated and LLDP should be supported in the device on all ports. The value 'shutdown' (3) indicates that LLDP should be shutdown in the device on all ports and all allocated memory must be released. Here, start and shutdown are configurable values. shutdownInProgress can only be read and cannot be wriiten. When 'shutdown' (3)is configured, the value is changed to 'shutdownInProgress' (2). This is because shutdownInProgress is used to indicate that shutdown process has been initiated by setting the object as shutdown but the process is not comitted. The value should be changed to shutdown once LLDP is shut on all ports and memory is released.")
fsLldpModuleStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpModuleStatus.setStatus('current')
if mibBuilder.loadTexts: fsLldpModuleStatus.setDescription("The administrative module status of LLDP module. This enables or disables LLDP in the system. A value of 'enabled' (1) indicates that LLDP is enabled in the device and can be enabled port-wise. A value of 'disabled' (2) indicates that LLDP is disabled in the device and also disabled on all ports. When LLLDP module status is changed from enabled to disabled, a global timer (instead of port specific timers) is started to ensure the successful transmission of shutdown frame on all ports. Module status change from disabled to enabled is not allowed when the global timer is running (i.e., when disable is in progress).")
fsLldpTraceInput = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 280)).clone('critical')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpTraceInput.setStatus('current')
if mibBuilder.loadTexts: fsLldpTraceInput.setDescription('This object stores the trace option string input given by the user. To enable particular trace the user has to enter the corresponding string(given below) assigned for that. And for enabling more than once traces the user has to enter the corresponding strings with SPACE delimiter between each string. For example, to enable - Init and Shutdown traces - Management traces - Neighbor delete traces - LLDP Port-descr TLV traces and - LLDP Power-via-mdi TLV traces The input string is, enable init-shut mgmt neigh-del port-descr pwr-mdi For example to disable - Init and Shutdown traces - Management traces - Neighbor delete traces - LLDP Port-descr TLV traces and - LLDP Power-via-mdi TLV traces The input string is, disable init-shut mgmt neigh-del port-descr pwr-mdi first value should be either enable or disable. The entered input string is parsed to get the trace options. And the corresponding bits of the trace options are set in fsLldpTraceOption object. enable - Enables the corresponding option. disable - Disables the corresponding option. init-shut - Init and Shutdown traces mgmt - Management traces data - Data Path traces ctrl - Control Plane traces pkt-dump - Packet Dump traces resource - Traces related to all resources except buffers all-fail - All Failure traces buf - Buffer allocation/ release traces neigh-add - Neighbor add traces neigh-del - Neighbor delete traces neigh-updt - Neighbor update traces neigh-drop - Neighbor drop traces neigh-ageout - Neighbor ageout traces critical - LLDP Critical traces all-tlv - LLDP All TLV traces chassis-id - LLDP Chassis-id TLV traces port-id - LLDP Port-id TLV trace ttl - LLDP Ttl TLV trace port-descr - LLDP Port-descr TLV traces sys-name - LLDP Sys-name TLV traces sys-descr - LLDP Sys-descr TLV traces sys-capab - LLDP Sys-capab TLV traces mgmt-addr - LLDP Mgmt-addr TLV traces port-vlan - LLDP Port-vlan TLV traces ppvlan - LLDP Port-proto-vlan TLV traces vlan-name - LLDP Vlan-name TLV traces proto-id - LLDP Proto-id TLV traces mac-phy - LLDP Mac-phy TLV traces pwr-mdi - LLDP Power-via-mdi TLV traces lagg - LLDP Link-agg TLV traces max-frame - LLDP Max-frame-size TLV traces - - Reserved By default critical trace is enabled.')
fsLldpTraceOption = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 1, 4), Integer32().clone(8192)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpTraceOption.setStatus('current')
if mibBuilder.loadTexts: fsLldpTraceOption.setDescription('This object is used to store the trace options that are enabled by the user. The bit positions of the traces is shown below Bit 0 - init-shut Bit 1 - mgmt Bit 2 - data Bit 3 - ctrl Bit 4 - pkt-dump Bit 5 - resource Bit 6 - all-fail Bit 7 - buf Bit 8 - neigh-add Bit 9 - neigh-del Bit 10 - neigh-updt Bit 11 - neigh-drop Bit 12 - neigh-ageout Bit 13 - critical Bit 14 - all-tlv Bit 15 - chassis-id Bit 16 - port-id Bit 17 - ttl Bit 18 - port-descr Bit 19 - sys-name Bit 20 - sys-descr Bit 21 - sys-capab Bit 22 - mgmt-addr Bit 23 - port-vlan Bit 24 - ppvlan Bit 25 - vlan-name Bit 26 - proto-id Bit 27 - mac-phy Bit 28 - pwr-mdi Bit 29 - lagg Bit 30 - max-frame Bit 31 - - By default critical trace(Bit 13) is set.')
fsLldpLocChassisIdSubtype = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("chassiscomp", 1), ("ifalias", 2), ("portcomp", 3), ("macaddr", 4), ("nwaddr", 5), ("ifname", 6), ("local", 7))).clone('macaddr')).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpLocChassisIdSubtype.setReference('IEEE 802.1AB-2005 9.5.2.2')
if mibBuilder.loadTexts: fsLldpLocChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocChassisIdSubtype.setDescription('The type of encoding used to identify the chassis component associated with the local system. When chassis id subtype is configured as chassiscomp/portcomp/local it is mandatory to configure the fsLldpLocChassisId object. If fsLldpLocChassisId object is not configured then current value of fsLldpLocChassisId is advertised. When chassis id subtype is configured as ifalias/macaddr/nwaddr/ ifname it is not required to configure fsLldpLocChassisId object. System specific values are used for setting fsLldpLocChassisId object.')
fsLldpLocChassisId = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpLocChassisId.setReference('IEEE 802.1AB-2005 9.5.2.3')
if mibBuilder.loadTexts: fsLldpLocChassisId.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocChassisId.setDescription('The string value used to identify the chassis component associated with the local system. Write operation to this object is allowed only when the chassis id subtype is configured as chassiscomp/portcomp/local. When chassis id subtype is configured as ifalias/macaddr/nwaddr/ifname system specific values are used and hence write operation to this object is not allowed.')
fsLldpLocPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 3), )
if mibBuilder.loadTexts: fsLldpLocPortTable.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocPortTable.setDescription('This table contains one or more rows per port information associated with the local system known to this agent.')
fsLldpLocPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 3, 1), ).setIndexNames((0, "LLDP-MIB", "lldpLocPortNum"))
if mibBuilder.loadTexts: fsLldpLocPortEntry.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocPortEntry.setDescription('Information about a particular port component. Entries may be created and deleted in this table by the agent.')
fsLldpLocPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ifalias", 1), ("portcomp", 2), ("macaddr", 3), ("nwaddr", 4), ("ifname", 5), ("agentcircuitid", 6), ("local", 7))).clone('ifalias')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpLocPortIdSubtype.setReference('IEEE Std 802.1AB-2005 9.5.3.2')
if mibBuilder.loadTexts: fsLldpLocPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocPortIdSubtype.setDescription('The type of port identifier encoding used to identify the port component associated with the local port. When port id subtype is configured as portcomp/local it is mandatory to configure the fsLldpLocPortId object. If fsLldpLocPortId object is not configured then current value of fsLldpLocPortId is advertised. When chassis id subtype is configured as ifalias/macaddr/nwaddr/ ifname/agentcircuitid it is not required to configure fsLldpLocPortId object. System specific values are used for setting fsLldpLocPortId object.')
fsLldpLocPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpLocPortId.setReference('IEEE Std 802.1AB-2005 9.5.3.3')
if mibBuilder.loadTexts: fsLldpLocPortId.setStatus('current')
if mibBuilder.loadTexts: fsLldpLocPortId.setDescription('TThe string value used to identify the port component associated with the local port. Write operation to this object is allowed only when the chassis id subtype is configured as chassiscomp/portcomp/local. When chassis id subtype is configured as ifalias/macaddr/nwaddr/ifname system specific values are used and hence write operation to this object is not allowed.')
fsLldpPortConfigNotificationType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("remTabChg", 1), ("misCfg", 2), ("remTabChgAndMisCfg", 3))).clone('misCfg')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsLldpPortConfigNotificationType.setStatus('current')
if mibBuilder.loadTexts: fsLldpPortConfigNotificationType.setDescription('This object is used to set the notification type. If the associated fsLldpNotificationType object has a value of remTabChg (1),then LLDP agent sends trap notification to NMS whenever remote table change occurs. If the associated fsLldpNotificationType object has a value of misCfg (1),then LLDP agent sends trap notification to NMS whenever mis-configuration is identified. If the associated fsLldpNotificationType object has a value of remTabChgAndMisCfg(3),then LLDP agent sends trap notification to NMS whenever remote table change occurs or/and whenever mis-configuration is identified. LLDP agent send the trap messages only when MIB Object lldpPortConfigNotificationEnable is true.So fsLldpNotificationType Object is valid when lldpPortConfigNotificationEnable Object is true.')
fsLldpMemAllocFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpMemAllocFailure.setStatus('current')
if mibBuilder.loadTexts: fsLldpMemAllocFailure.setDescription('This object gives the count of total memory allocation failures')
fsLldpInputQOverFlows = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpInputQOverFlows.setStatus('current')
if mibBuilder.loadTexts: fsLldpInputQOverFlows.setDescription('This object gives the count of total input queue overflows')
fsLldpStatsRemTablesUpdates = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 3, 3), ZeroBasedCounter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: fsLldpStatsRemTablesUpdates.setStatus('current')
if mibBuilder.loadTexts: fsLldpStatsRemTablesUpdates.setDescription('The number of times any information advertised by a particular MSAP is updated in tables contained in lldpRemoteSystemsData and lldpExtensions objects.')
fsLldpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0))
fsLldpRemTablesChange = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 1)).setObjects(("LLDP-MIB", "lldpStatsRemTablesInserts"), ("LLDP-MIB", "lldpStatsRemTablesDeletes"), ("LLDP-MIB", "lldpStatsRemTablesDrops"), ("LLDP-MIB", "lldpStatsRemTablesAgeouts"), ("AT-GS950-16-MIB", "fsLldpStatsRemTablesUpdates"))
if mibBuilder.loadTexts: fsLldpRemTablesChange.setStatus('current')
if mibBuilder.loadTexts: fsLldpRemTablesChange.setDescription("A fsLldpRemTablesChange notification is sent when the value of lldpStatsRemTableLastChangeTime changes. It can be utilized by an NMS to trigger LLDP remote systems table maintenance polls. Note that transmission of fsLldpRemTablesChange notifications are throttled by the agent, as specified by the 'lldpNotificationInterval' object. The first four objects are already mentioned in the standard LLDP mib. As the Table Updation notification is also sent in the same notification PDU these objects are moved to proprietary mib.")
fsLldpExceedsMaxFrameSize = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 2)).setObjects(("LLDP-MIB", "lldpLocPortId"))
if mibBuilder.loadTexts: fsLldpExceedsMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: fsLldpExceedsMaxFrameSize.setDescription('A fsLldpExceedsMaxFrameSize notification is sent if the size of LLDP frame to be transmitted exceeds the maximum frame size (1522 bytes). This can occur if many number of TLVs need to be included in a single frame . It notifies the NMS that the information obtained about this system from its neighbor is not complete.')
fsLldpDupChasisId = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 3)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"))
if mibBuilder.loadTexts: fsLldpDupChasisId.setStatus('current')
if mibBuilder.loadTexts: fsLldpDupChasisId.setDescription('A fsLldpDupChasisId notification sent if the configured chasisId and Received chasisId from the neighbor is same. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
fsLldpDupSystemName = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 4)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-MIB", "lldpRemSysName"))
if mibBuilder.loadTexts: fsLldpDupSystemName.setStatus('current')
if mibBuilder.loadTexts: fsLldpDupSystemName.setDescription('A fsLldpDupSystemName notification sent if the configured system name and Received system name from the neighbor is same. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
fsLldpDupManagmentAddress = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 5)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-MIB", "lldpRemManAddr"))
if mibBuilder.loadTexts: fsLldpDupManagmentAddress.setStatus('current')
if mibBuilder.loadTexts: fsLldpDupManagmentAddress.setDescription('A fsLldpDupManagementAddress notification sent if the configured management address and Received management address from the neighbor is same. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
fsLldpMisConfigPortVlanID = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 6)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT1-MIB", "lldpXdot1RemPortVlanId"))
if mibBuilder.loadTexts: fsLldpMisConfigPortVlanID.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigPortVlanID.setDescription('A fsLldpMisConfigPortVlanID notification sent if the Port VlanId of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigPortProtoVlanID = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 7)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT1-MIB", "lldpXdot1RemProtoVlanSupported"))
if mibBuilder.loadTexts: fsLldpMisConfigPortProtoVlanID.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigPortProtoVlanID.setDescription('A fsLldpMisConfigPortProtoVlanID notification sent if the Port and protocol VlanId of two systems connected to the same link is different. lldpRemPortId and lldpRemChassisId information sent to identify the remote system. lldpXdot1RemProtoVlanId is not accesiable since it is the index, so sending the lldpXdot1RemProtoVlanSupported information, to know which Port and Protocol VlanId is MisConfigured. PPVID will be sent along with the OID. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigVlanName = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 8)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT1-MIB", "lldpXdot1RemVlanName"))
if mibBuilder.loadTexts: fsLldpMisConfigVlanName.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigVlanName.setDescription('A fsLldpMisConfigVlanName notification sent if the vlan name of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigProtocolIdentity = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 9)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT1-MIB", "lldpXdot1RemProtocolId"))
if mibBuilder.loadTexts: fsLldpMisConfigProtocolIdentity.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigProtocolIdentity.setDescription('A fsLldpMisConfigProtocolIdentity notification sent if the protocol identity information (example spanning Tree protocol, the Link Aggregation protocol and proprietary protocol) of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigLinkAggStatus = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 10)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT3-MIB", "lldpXdot3RemLinkAggStatus"))
if mibBuilder.loadTexts: fsLldpMisConfigLinkAggStatus.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigLinkAggStatus.setDescription('A fsLldpMisConfigLinkAggStatus notification sent if the Link aggregation configuration of two systems connected to the same link is different. It is possible that if one system formed a link aggregation with a remote port while the other system is unaware of the aggregation. This type of configuration may cause network loops or unpredictable communication. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigPowerMDI = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 11)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT3-MIB", "lldpXdot3RemPowerClass"))
if mibBuilder.loadTexts: fsLldpMisConfigPowerMDI.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigPowerMDI.setDescription('A fsLldpMisConfigPowerMDI notification sent if the power class configuration of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigMaxFrameSize = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 12)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT3-MIB", "lldpXdot3RemMaxFrameSize"))
if mibBuilder.loadTexts: fsLldpMisConfigMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigMaxFrameSize.setDescription('A fsLldpMisConfigMaxFrameSize notification sent if the maximum frame size configuration of two systems connected to the same link is different. Difference in maximum frame size can result in loss of frames if the sending station advertised maximum frame size is larger than the receiveing station. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
fsLldpMisConfigOperMauType = NotificationType((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 158, 4, 0, 13)).setObjects(("LLDP-MIB", "lldpRemChassisId"), ("LLDP-MIB", "lldpRemPortId"), ("LLDP-EXT-DOT3-MIB", "lldpXdot3RemPortOperMauType"))
if mibBuilder.loadTexts: fsLldpMisConfigOperMauType.setStatus('current')
if mibBuilder.loadTexts: fsLldpMisConfigOperMauType.setDescription('A fsLldpMisConfigOperMauType notification sent if the Operational MauType of the two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
voicevlanSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1))
voicevlanOUI = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2))
voiceVlanMode = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceVlanMode.setStatus('current')
if mibBuilder.loadTexts: voiceVlanMode.setDescription('Voice VLAN is a feature that allows you to automatically place the voice traffic from IP phone to an assigned VLAN to enhance the VoIP service. This object is for enabling or disabling Voice Vlan function in the system. If the Vlan mode is in Asymmetric VLAN mode, Voice VLAN can not be enabled.')
voiceVlanId = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceVlanId.setStatus('current')
if mibBuilder.loadTexts: voiceVlanId.setDescription('The ID of VLAN that you want the voice traffic to be in. It must be a exist vlan id.')
voiceVlanTimeout = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceVlanTimeout.setStatus('current')
if mibBuilder.loadTexts: voiceVlanTimeout.setDescription('A period of time in hour to remove a port from voice VLAN if the port is an automatic VLAN member. The Timeout range is 1~120 hours. Default aging time is 1 hour.')
voiceVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("highest", 0), ("high", 1), ("medium", 2), ("low", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceVlanPriority.setStatus('current')
if mibBuilder.loadTexts: voiceVlanPriority.setDescription('The 802.1p priority levels of the traffic in the Voice VLAN.')
voicevlanPortControlTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 6), )
if mibBuilder.loadTexts: voicevlanPortControlTable.setStatus('current')
if mibBuilder.loadTexts: voicevlanPortControlTable.setDescription('A table that contains Voice Vlan Port Control configuration information.')
voicevlanPortControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 6, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "voicevlanPortControlIndex"))
if mibBuilder.loadTexts: voicevlanPortControlEntry.setStatus('current')
if mibBuilder.loadTexts: voicevlanPortControlEntry.setDescription('A list of Voice Vlan Control configuration parameters for each Port on this device.')
voicevlanPortControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 6, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicevlanPortControlIndex.setStatus('current')
if mibBuilder.loadTexts: voicevlanPortControlIndex.setDescription('The voice vlan port index.')
voicevlanPortAutoDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicevlanPortAutoDetection.setStatus('current')
if mibBuilder.loadTexts: voicevlanPortAutoDetection.setDescription('This object is for enabling or disabling Voice Vlan Auto Detection in the port. If the auto detection is enable, switch will add this port to the voice VLAN automatically if it detects the device OUI matches the Telephony OUI. If the port is a static member of voice vlan or a LA member, it can not enable voice vlan auto detection.')
voicevlanPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("dynamic", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicevlanPortState.setStatus('current')
if mibBuilder.loadTexts: voicevlanPortState.setDescription('This object indicates Voice vlan state to this Port. manual - this port is a static member of voice vlan. dynamic - this port is a dynamic member of voice vlan. none - this port is not a member of voice vlan.')
voicevlanOUITable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1), )
if mibBuilder.loadTexts: voicevlanOUITable.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUITable.setDescription('A voice vlan OUI entry containing the description and mac.')
voicevlanOUIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "voicevlanOUITelephonyOUI"))
if mibBuilder.loadTexts: voicevlanOUIEntry.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUIEntry.setDescription('A voice vlan OUI entry containing the description and mac.')
voicevlanOUITelephonyOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicevlanOUITelephonyOUI.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUITelephonyOUI.setDescription("An Organizationally Unique Identifier (OUI) is a 24-bit number that is purchased from the IEEE Registration Authority. This identifier uniquely identifies a vendor, manufacturer, or other organization. This object indicates the voice traffic's OUI that user created.")
voicevlanOUIDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicevlanOUIDescription.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUIDescription.setDescription('The Description for the OUI.')
voicevlanOUIMask = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicevlanOUIMask.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUIMask.setDescription('Voice vlan OUI Mask. Always be FF:FF:FF:00:00:00.')
voicevlanOUIStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 163, 2, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: voicevlanOUIStatus.setStatus('current')
if mibBuilder.loadTexts: voicevlanOUIStatus.setDescription('This object indicates the status of this entry. To create a new entry, you must set the voicevlanOUIStatus to be CreateAndGo, then this entry will turn to be Active.')
trafficSegTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 165, 1), )
if mibBuilder.loadTexts: trafficSegTable.setStatus('current')
if mibBuilder.loadTexts: trafficSegTable.setDescription('A Port-channel is created through ifMain table. After the creation of the port-channel, corresponding logical interface will be created in the ifMain table. This Port-channel table is indexed through Key values and allows to configure link selection policy and the Mac address for the port-channel. All other objects in this table displays the details of the port-channel')
trafficSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 165, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "trafficSegIfIndex"))
if mibBuilder.loadTexts: trafficSegEntry.setStatus('current')
if mibBuilder.loadTexts: trafficSegEntry.setDescription('There is one entry in this table for each created port-channel port')
trafficSegIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 165, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficSegIfIndex.setStatus('current')
if mibBuilder.loadTexts: trafficSegIfIndex.setDescription("The ifIndex of the port-channel(Aggregator's interface index). ")
trafficSegMemberList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 165, 1, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficSegMemberList.setStatus('current')
if mibBuilder.loadTexts: trafficSegMemberList.setDescription('List of the member port of the port-channel.')
atiAcl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1))
atiMacFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2))
atiAclClassifierTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1), )
if mibBuilder.loadTexts: atiAclClassifierTable.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierTable.setDescription('ACL Classifier entry table.')
atiAclClassifierEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclClassifierIndex"))
if mibBuilder.loadTexts: atiAclClassifierEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierEntry.setDescription('Classifier is used to specify a packet type for Policies.')
atiAclClassifierIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclClassifierIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierIndex.setDescription('The index of the Classifier entry.')
atiAclClassifierSrcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierSrcMac.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierSrcMac.setDescription('Source MAC address.')
atiAclClassifierSrcMacMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierSrcMacMaskLen.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierSrcMacMaskLen.setDescription('Source MAC mask length. 1-48: length in bits 0: Ignored')
atiAclClassifierDstMac = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDstMac.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDstMac.setDescription('Destination MAC address.')
atiAclClassifierDstMacMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDstMacMaskLen.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDstMacMaskLen.setDescription('Destination MAC mask length. 1-48: length in bits 0: Ignored')
atiAclClassifierVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierVlanId.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierVlanId.setDescription('802.1Q Vlan Id. 1-4000: Vlan Id -1: Ignored')
atiAclClassifierCos = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierCos.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierCos.setDescription('802.1p priority. 0-7: 802.1p priority value -1: Ignored')
atiAclClassifierEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierEtherType.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierEtherType.setDescription('EtherType. 0-65535: EtherType number -1: Ignored')
atiAclClassifierSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierSrcIp.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierSrcIp.setDescription('Source IP address.')
atiAclClassifierSrcIpMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierSrcIpMaskLen.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierSrcIpMaskLen.setDescription('Source IP mask length. 1-32: length in bits 0: Ignored')
atiAclClassifierDstIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDstIp.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDstIp.setDescription('Destination IP address.')
atiAclClassifierDstIpMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDstIpMaskLen.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDstIpMaskLen.setDescription('Destination IP mask length. 1-32: length in bits 0: Ignored')
atiAclClassifierDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDscp.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDscp.setDescription('Differentiated Services Code Point. 0-63: DSCP value -1: Ignored')
atiAclClassifierProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierProtocol.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierProtocol.setDescription('Layer 4 protocol type. 0-255: Layer 4 protocol number -1: Ignored')
atiAclClassifierSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierSrcPort.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierSrcPort.setDescription('TCP/UDP Source port. 0-65535: port number -1: Ignored')
atiAclClassifierDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclClassifierDstPort.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierDstPort.setDescription('TCP/UDP Destination port. 0-65535: port number -1: Ignored')
atiAclClassifierRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 1, 1, 30), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclClassifierRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclClassifierRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiAclProfileActionTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2), )
if mibBuilder.loadTexts: atiAclProfileActionTable.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionTable.setDescription('ACL Profile Action entry table.')
atiAclProfileActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclProfileActionIndex"))
if mibBuilder.loadTexts: atiAclProfileActionEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionEntry.setDescription('Profile Action is used to manipulate the DSCP or CoS values in a packet.')
atiAclProfileActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 72))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclProfileActionIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionIndex.setDescription('The index of the Action entry.')
atiAclProfileActionCos = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclProfileActionCos.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionCos.setDescription('Policied-Cos. 0-7: 802.1p priority value -1: Ignored')
atiAclProfileActionDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclProfileActionDscp.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionDscp.setDescription('Policied-DSCP. 0-63: DSCP value -1: Ignored')
atiAclProfileActionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclProfileActionRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclProfileActionRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiAclInProfileActionTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3), )
if mibBuilder.loadTexts: atiAclInProfileActionTable.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionTable.setDescription('ACL In-Profile Action entry table.')
atiAclInProfileActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclInProfileActionIndex"))
if mibBuilder.loadTexts: atiAclInProfileActionEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionEntry.setDescription('In-Profile Action is used to assign an action to a policy.')
atiAclInProfileActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclInProfileActionIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionIndex.setDescription('The index of the In-Profile Action entry.')
atiAclInProfileActionPermitDeny = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclInProfileActionPermitDeny.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionPermitDeny.setDescription('Permit/Deny action. 0: Permit 1: Deny')
atiAclInProfileActionActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 72))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclInProfileActionActionId.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionActionId.setDescription('The index of Action entry used by this In-Profile entry. 1-72: Action entry index 0: Ignored')
atiAclInProfileActionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclInProfileActionRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclInProfileActionRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiAclOutProfileActionTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4), )
if mibBuilder.loadTexts: atiAclOutProfileActionTable.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionTable.setDescription('ACL Out-Profile Action entry table.')
atiAclOutProfileActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclOutProfileActionIndex"))
if mibBuilder.loadTexts: atiAclOutProfileActionEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionEntry.setDescription('Out-Profile Action is used to assign a classifier index to a profile action ID as well as a committed rate and a burst size')
atiAclOutProfileActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclOutProfileActionIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionIndex.setDescription('The index of the Out-Profile Action entry.')
atiAclOutProfileActionPermitDeny = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclOutProfileActionPermitDeny.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionPermitDeny.setDescription('Permit/Deny action. 0: Permit 1: Deny')
atiAclOutProfileActionCommittedRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclOutProfileActionCommittedRate.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionCommittedRate.setDescription('Committed rate in Kbps.')
atiAclOutProfileActionBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclOutProfileActionBurstSize.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionBurstSize.setDescription('Max burst size which is the maximum amount of data in KB.')
atiAclOutProfileActionActionId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 72))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclOutProfileActionActionId.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionActionId.setDescription('The index of Action entry used by this Out-Profile entry. 1-72: Action entry index 0: Ignored')
atiAclOutProfileActionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclOutProfileActionRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclOutProfileActionRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiAclPortListTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 5), )
if mibBuilder.loadTexts: atiAclPortListTable.setStatus('current')
if mibBuilder.loadTexts: atiAclPortListTable.setDescription('ACL Port-List entry table.')
atiAclPortListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 5, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclPortListIndex"))
if mibBuilder.loadTexts: atiAclPortListEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclPortListEntry.setDescription('Port-List is used to specify a list of ports.')
atiAclPortListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclPortListIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPortListIndex.setDescription('The index of the Port-List entry.')
atiAclPortListString = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPortListString.setStatus('current')
if mibBuilder.loadTexts: atiAclPortListString.setDescription('Port-list string. e.g. 1,3,5-8')
atiAclPortListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclPortListRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclPortListRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiAclPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6), )
if mibBuilder.loadTexts: atiAclPolicyTable.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyTable.setDescription('ACL Policy entry table.')
atiAclPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiAclPolicyIndex"))
if mibBuilder.loadTexts: atiAclPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyEntry.setDescription('Policy controls the ingress traffic on a port. It defines a category of traffic and the action of the port when it receives packets of the category.')
atiAclPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiAclPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyIndex.setDescription('The index of the Policy entry.')
atiAclPolicyClassifierIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPolicyClassifierIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyClassifierIndex.setDescription('The index of Classifier entry used by this Policy entry.')
atiAclPolicySequence = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPolicySequence.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicySequence.setDescription('The sequence of the Policy entry.')
atiAclPolicyInProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPolicyInProfileIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyInProfileIndex.setDescription('The index of In-Profile entry used by this Policy entry.')
atiAclPolicyOutProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPolicyOutProfileIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyOutProfileIndex.setDescription('The index of Out-Profile entry used by this Policy entry. 0: Ignored')
atiAclPolicyPortListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiAclPolicyPortListIndex.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyPortListIndex.setDescription('The index of Port-List entry used by this Policy entry.')
atiAclPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 1, 6, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiAclPolicyRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiAclPolicyRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
atiDstMacFilterTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2, 1), )
if mibBuilder.loadTexts: atiDstMacFilterTable.setStatus('current')
if mibBuilder.loadTexts: atiDstMacFilterTable.setDescription('DstMacFilter entry table.')
atiDstMacFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2, 1, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "atiDstMacFilterIndex"))
if mibBuilder.loadTexts: atiDstMacFilterEntry.setStatus('current')
if mibBuilder.loadTexts: atiDstMacFilterEntry.setDescription('DstMacFilter is used to filter the packets by the specific Destination MAC.')
atiDstMacFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atiDstMacFilterIndex.setStatus('current')
if mibBuilder.loadTexts: atiDstMacFilterIndex.setDescription('The index of the DstMacFilter entry.')
atiDstMacFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2, 1, 1, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atiDstMacFilterAddress.setStatus('current')
if mibBuilder.loadTexts: atiDstMacFilterAddress.setDescription('Destnation MAC address')
atiDstMacFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 166, 2, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atiDstMacFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: atiDstMacFilterRowStatus.setDescription('The row status of the entry. 1: write - enable the entry read - entry is enabled 2: write - disable the entry read - entry is disabled 3: read - entry is not ready 5: write - create the entry 6: write - delete the entry')
dhcpSnoopSystemStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopSystemStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopSystemStatus.setDescription('Enable/Disable DHCP Snooping.')
dhcpSnoopOption82Insertion = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopOption82Insertion.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopOption82Insertion.setDescription('Determine if to insert DHCP option 82 into packets.')
dhcpSnoopPassThroughOption82 = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopPassThroughOption82.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopPassThroughOption82.setDescription('Determine if to pass through DHCP packets with option 82.')
dhcpSnoopVerifyMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopVerifyMACAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopVerifyMACAddress.setDescription('Determine if to verify MAC address for incoming DHCP packets.')
dhcpSnoopBackupDatabase = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBackupDatabase.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBackupDatabase.setDescription('Determine if to backup database to flash memory.')
dhcpSnoopBackupDatabaseInterval = MibScalar((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBackupDatabaseInterval.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBackupDatabaseInterval.setDescription('Determine the period to backup database.')
dhcpSnoopVLANSettingTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 7), )
if mibBuilder.loadTexts: dhcpSnoopVLANSettingTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopVLANSettingTable.setDescription('A table of DHCP snooping VLAN settings.')
dhcpSnoopVLANSettingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 7, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dhcpSnoopVLANSettingVID"))
if mibBuilder.loadTexts: dhcpSnoopVLANSettingEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopVLANSettingEntry.setDescription('The entry of DHCP snooping VLAN setting table.')
dhcpSnoopVLANSettingVID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopVLANSettingVID.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopVLANSettingVID.setDescription('The VLAN ID.')
dhcpSnoopVLANSettingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopVLANSettingStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopVLANSettingStatus.setDescription('The VLAN status.')
dhcpSnoopPortSettingTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 8), )
if mibBuilder.loadTexts: dhcpSnoopPortSettingTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopPortSettingTable.setDescription('A table of DHCP snooping port settings.')
dhcpSnoopPortSettingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 8, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dhcpSnoopPortSettingIndex"))
if mibBuilder.loadTexts: dhcpSnoopPortSettingEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopPortSettingEntry.setDescription('The entry of DHCP snooping port setting table.')
dhcpSnoopPortSettingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopPortSettingIndex.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopPortSettingIndex.setDescription('The port number.')
dhcpSnoopPortSettingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("untrusted", 0), ("trusted", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopPortSettingStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopPortSettingStatus.setDescription('The port status.')
dhcpSnoopBindindDatabaseTable = MibTable((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9), )
if mibBuilder.loadTexts: dhcpSnoopBindindDatabaseTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDatabaseTable.setDescription('A table of DHCP snooping bindind database.')
dhcpSnoopBindindDatabaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1), ).setIndexNames((0, "AT-GS950-16-MIB", "dhcpSnoopBindindDBMacAddress"))
if mibBuilder.loadTexts: dhcpSnoopBindindDatabaseEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDatabaseEntry.setDescription('The entry of DHCP snooping bindind database table.')
dhcpSnoopBindindDBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopBindindDBMacAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBMacAddress.setDescription('The MAC address.')
dhcpSnoopBindindDBVLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBindindDBVLANID.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBVLANID.setDescription('The VLAN ID.')
dhcpSnoopBindindDBIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBindindDBIPAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBIPAddress.setDescription('The IP address.')
dhcpSnoopBindindDBPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBindindDBPortNumber.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBPortNumber.setDescription('The port number.')
dhcpSnoopBindindDBType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("dynamic", 0), ("static", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBindindDBType.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBType.setDescription('The entry type.')
dhcpSnoopBindindDBLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopBindindDBLeaseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBLeaseTime.setDescription('The DHCP lease time.')
dhcpSnoopBindindDBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 1, 4, 166, 181, 9, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpSnoopBindindDBRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopBindindDBRowStatus.setDescription('The entry row status.')
mibBuilder.exportSymbols("AT-GS950-16-MIB", ifIpEntry=ifIpEntry, portBaseStaticUnicastTable=portBaseStaticUnicastTable, at_GS95016v3=at_GS95016v3, atiAclMib=atiAclMib, dot1qVlanCreationTime=dot1qVlanCreationTime, sysLaTraceOption=sysLaTraceOption, atiAclProfileActionRowStatus=atiAclProfileActionRowStatus, dot1qTpFdbStatus=dot1qTpFdbStatus, sysSnmpUserPrivProtocol=sysSnmpUserPrivProtocol, sysSntpTzGroup=sysSntpTzGroup, sysDefaultVlanId=sysDefaultVlanId, dot1sMemAllocFailureCount=dot1sMemAllocFailureCount, trafficSegTable=trafficSegTable, sysDscpType63=sysDscpType63, sysLBDStateEnable=sysLBDStateEnable, sysDscpEnable=sysDscpEnable, dot1dStpBridgeMaxAge=dot1dStpBridgeMaxAge, dot1dPortCapabilities=dot1dPortCapabilities, dot1wPortMigSmState=dot1wPortMigSmState, sysDfsClfrTable=sysDfsClfrTable, dot1wRstTrapsControlTable=dot1wRstTrapsControlTable, sysSnoopVlanFilterInetAddressType=sysSnoopVlanFilterInetAddressType, sysDscpMIBObjects=sysDscpMIBObjects, dot1qVlanEgressPortTable=dot1qVlanEgressPortTable, dot1dCompliances=dot1dCompliances, sysSnoopStatsDroppedPkts=sysSnoopStatsDroppedPkts, dot1dBasePortIfIndex=dot1dBasePortIfIndex, dot1dBasePort=dot1dBasePort, dot1wPortTxRstBpduCount=dot1wPortTxRstBpduCount, sysDfsClassifier=sysDfsClassifier, sysDlfOnOff=sysDlfOnOff, sysSnoopInstanceConfigInstId=sysSnoopInstanceConfigInstId, dot1qStaticUnicastEntry=dot1qStaticUnicastEntry, dot1wInvalidBpduRxdTrap=dot1wInvalidBpduRxdTrap, dot1dBaseContextId=dot1dBaseContextId, dot1sCistPortAdminP2P=dot1sCistPortAdminP2P, sysDscpType41=sysDscpType41, fsLldpLocChassisIdSubtype=fsLldpLocChassisIdSubtype, ifSecondaryIpBroadcastAddr=ifSecondaryIpBroadcastAddr, sysDscpType62=sysDscpType62, dot1dStpPortState=dot1dStpPortState, dhcpSnoopBindindDBType=dhcpSnoopBindindDBType, sysSnmpsnmpCommunityIndex=sysSnmpsnmpCommunityIndex, sysRadiusExtServerEntryStatus=sysRadiusExtServerEntryStatus, l2Bridge=l2Bridge, sysDfsPortId=sysDfsPortId, sysSnmpsnmpTrapManagerAddress=sysSnmpsnmpTrapManagerAddress, dot1sCistPortProtMigrationSemState=dot1sCistPortProtMigrationSemState, sysRmonHwStatsSupp=sysRmonHwStatsSupp, dot1qStaticMulticastReceivePort=dot1qStaticMulticastReceivePort, dot1dTrafficClassPriority=dot1dTrafficClassPriority, issJumboFramePerPortMtu=issJumboFramePerPortMtu, dhcpSnoopVLANSettingStatus=dhcpSnoopVLANSettingStatus, fsLldpLocPortIdSubtype=fsLldpLocPortIdSubtype, sysDscpType45=sysDscpType45, dot1dTpFdbPort=dot1dTpFdbPort, sysPnacGuestVlanEntry=sysPnacGuestVlanEntry, portBaseStaticMulticastAddress=portBaseStaticMulticastAddress, dot1sMstiPortState=dot1sMstiPortState, dot1sMstiSelectedPortRole=dot1sMstiSelectedPortRole, atiAclPortListIndex=atiAclPortListIndex, dot1qQBridge=dot1qQBridge, sysDscpType29=sysDscpType29, dot1sCistRegionalRootCost=dot1sCistRegionalRootCost, sysDscpTypeGroup=sysDscpTypeGroup, sysPowerSavingEnable=sysPowerSavingEnable, InetAddressIPv6=InetAddressIPv6, sysSnoopVlanRouterEntry=sysSnoopVlanRouterEntry, voicevlanPortControlIndex=voicevlanPortControlIndex, sysDfsEnterpriseCoSqAlgorithm=sysDfsEnterpriseCoSqAlgorithm, dot1qStaticUnicastRowStatus=dot1qStaticUnicastRowStatus, dot1dStpRootCost=dot1dStpRootCost, sysSnoopVlanMcastMacFwdGroupAddress=sysSnoopVlanMcastMacFwdGroupAddress, sysStormCtrlEntry=sysStormCtrlEntry, sysConfigSaveFileName=sysConfigSaveFileName, dhcpSnoopBackupDatabaseInterval=dhcpSnoopBackupDatabaseInterval, sysDscpType47=sysDscpType47, DscpOrAny=DscpOrAny, sysLaPortEntry=sysLaPortEntry, sysRadiusExtClient=sysRadiusExtClient, sysSnmpCommunityTable=sysSnmpCommunityTable, ifIpAddrAllocProtocol=ifIpAddrAllocProtocol, sysLaPortChannelPortCount=sysLaPortChannelPortCount, dot1sCistPortHelloTime=dot1sCistPortHelloTime, sysLaSystemControl=sysLaSystemControl, sysSshVersionCompatibility=sysSshVersionCompatibility, sysSnmpGroupName=sysSnmpGroupName, sysLedEcoModeStatus=sysLedEcoModeStatus, sysSshGeneralGroup=sysSshGeneralGroup, sysSnmpTrapManagerTable=sysSnmpTrapManagerTable, sysSnoopStatsTxGenQueries=sysSnoopStatsTxGenQueries, sysUserAuthMgrEntry=sysUserAuthMgrEntry, dot1qStaticMulticastStatus=dot1qStaticMulticastStatus, atiAclPolicyInProfileIndex=atiAclPolicyInProfileIndex, atiAclClassifierDstIp=atiAclClassifierDstIp, sysPnacModuleOperStatus=sysPnacModuleOperStatus, dot1dStpForwardDelay=dot1dStpForwardDelay, dot1dStpBridgeHelloTime=dot1dStpBridgeHelloTime, sysRadiusExtServerAccPort=sysRadiusExtServerAccPort, dot1wRstTraps=dot1wRstTraps, atiAclOutProfileActionCommittedRate=atiAclOutProfileActionCommittedRate, dot1sCistPortRxMstBpduCount=dot1sCistPortRxMstBpduCount, dot1sCistPortTxConfigBpduCount=dot1sCistPortTxConfigBpduCount, sysMirrorCtrlStatus=sysMirrorCtrlStatus, sysDfsOutProfileActionFlag=sysDfsOutProfileActionFlag, dot1dStpContextId=dot1dStpContextId, sysSnoopInstanceGlobalTable=sysSnoopInstanceGlobalTable, sysDfsInProfileActionEntry=sysDfsInProfileActionEntry, dot1sMstSetGlobalTrapOption=dot1sMstSetGlobalTrapOption, sysDfsClfrInProActionId=sysDfsClfrInProActionId, sysDfsMeterId=sysDfsMeterId, portBaseStaticMulticastTable=portBaseStaticMulticastTable, dot1sCistPortRestrictedTCN=dot1sCistPortRestrictedTCN, atiAclPortListRowStatus=atiAclPortListRowStatus, atiAclPolicyClassifierIndex=atiAclPolicyClassifierIndex, trafficSeg=trafficSeg, sysSnoopStatsTable=sysSnoopStatsTable, l2La=l2La, sysPnacPaeSecureVlan=sysPnacPaeSecureVlan, dot1sCistPortEffectivePortState=dot1sCistPortEffectivePortState, dot1wProtocolMigrationTrap=dot1wProtocolMigrationTrap, dot1qVlanOperStatus=dot1qVlanOperStatus, sysDfsMultiFieldClfrEntry=sysDfsMultiFieldClfrEntry, dot1sCistForwardDelay=dot1sCistForwardDelay, sysSnoopVlanOperatingVersion=sysSnoopVlanOperatingVersion, sysIpAuthMgrAllowedServices=sysIpAuthMgrAllowedServices, dot1dPBridge=dot1dPBridge, dot1wPortOperVersion=dot1wPortOperVersion, dot1dStpMaxAge=dot1dStpMaxAge, sysDscpType55=sysDscpType55, ifSetMgmtVlanList=ifSetMgmtVlanList, dot1sMstiPortForwardTransitions=dot1sMstiPortForwardTransitions, sysSslSecureHttpStatus=sysSslSecureHttpStatus, atiAclClassifierCos=atiAclClassifierCos, atiAclInProfileActionTable=atiAclInProfileActionTable, sysSntpTzDSTEndMinute=sysSntpTzDSTEndMinute, dot1sGenTrap=dot1sGenTrap, fsLldpSystemControl=fsLldpSystemControl, l2Dscp=l2Dscp, dot1dPortOutboundAccessPriorityTable=dot1dPortOutboundAccessPriorityTable, dot1qStaticMcastPortEntry=dot1qStaticMcastPortEntry, sysSnmpaccessSecurityModel=sysSnmpaccessSecurityModel, dot1dTpTable=dot1dTpTable, sysSntpTzDSTStatus=sysSntpTzDSTStatus, sysSnmpsnmpTrapManagerSecurityLevel=sysSnmpsnmpTrapManagerSecurityLevel, sysDscpType27=sysDscpType27, dot1wTraceOption=dot1wTraceOption, sysPortCtrlIndex=sysPortCtrlIndex, sysDfsInProfileActionId=sysDfsInProfileActionId, sysDscpType04=sysDscpType04, l2Syslog=l2Syslog, dot1dTpPortInOverflowDiscards=dot1dTpPortInOverflowDiscards, dot1qNumVlans=dot1qNumVlans, atiAclClassifierSrcMacMaskLen=atiAclClassifierSrcMacMaskLen, dot1sMstpUpCount=dot1sMstpUpCount, dot1sCistPortInvalidMstBpduRxCount=dot1sCistPortInvalidMstBpduRxCount, sysSnmpGroupEntry=sysSnmpGroupEntry, sysLaPortIndex=sysLaPortIndex, sysDscpType40=sysDscpType40, dot1sMst=dot1sMst, atiAclClassifierEntry=atiAclClassifierEntry, l2Rmon=l2Rmon, sysSnmpGroupTable=sysSnmpGroupTable, sysSnoopStatsTxAsmReports=sysSnoopStatsTxAsmReports, sysMirror=sysMirror, dot1dStpExtEntry=dot1dStpExtEntry, dot1sCistPortInvalidRstBpduRxCount=dot1sCistPortInvalidRstBpduRxCount, dot1qVlanContextId=dot1qVlanContextId, dot1qPortRestrictedVlanRegistration=dot1qPortRestrictedVlanRegistration, dot1wOldRoleType=dot1wOldRoleType, dot1sCistPortDesignatedPort=dot1sCistPortDesignatedPort, sysLaPortPartnerResetAdminState=sysLaPortPartnerResetAdminState, dot1dPortPriorityTable=dot1dPortPriorityTable, sysDscpType64=sysDscpType64, dot1sCistPortAdminEdgeStatus=dot1sCistPortAdminEdgeStatus, dot1wPortTxTcnBpduCount=dot1wPortTxTcnBpduCount, sysLaPortChannelEntry=sysLaPortChannelEntry, sysLaActorSystemID=sysLaActorSystemID, sysMirrorCtrlIndex=sysMirrorCtrlIndex, sysLaPortSelectAggregator=sysLaPortSelectAggregator, sysLBDPortLoopStatus=sysLBDPortLoopStatus, sysIpAuthMgrVlanList=sysIpAuthMgrVlanList, sysMulticastOnOff=sysMulticastOnOff, dot1dStaticTable=dot1dStaticTable, dot1dStaticStatus=dot1dStaticStatus, fsLldpModuleStatus=fsLldpModuleStatus, dot1sPortMigrationType=dot1sPortMigrationType, sysStormCtrlTable=sysStormCtrlTable, dot1dPortCapabilitiesTable=dot1dPortCapabilitiesTable, dot1dStpPort=dot1dStpPort, dot1sBufferOverFlowCount=dot1sBufferOverFlowCount, dot1dUserPriorityRegenTable=dot1dUserPriorityRegenTable, dot1wPortTrapNotificationEntry=dot1wPortTrapNotificationEntry, sysRateCtrlTable=sysRateCtrlTable, sysDfsOutProfileActionId=sysDfsOutProfileActionId, fsLldpLocPortEntry=fsLldpLocPortEntry, ifMainTable=ifMainTable, dot1sCistPortTxRstBpduCount=dot1sCistPortTxRstBpduCount, dot1wNewRootTrap=dot1wNewRootTrap, sysDscpType10=sysDscpType10, dhcpSnoopPortSettingIndex=dhcpSnoopPortSettingIndex, dot1qPvid=dot1qPvid, sysLaPortMode=sysLaPortMode, sysSyslogTimeStamp=sysSyslogTimeStamp, dot1dStaticAllowedToGoEntry=dot1dStaticAllowedToGoEntry, sysPnacPaePortNumber=sysPnacPaePortNumber, sysSnmpGroupAccessTable=sysSnmpGroupAccessTable, dot1qStaticAllowedToGoEntry=dot1qStaticAllowedToGoEntry, ifResetMgmtVlanList=ifResetMgmtVlanList, sysSnoopVlanMcastMacFwdVlanId=sysSnoopVlanMcastMacFwdVlanId, dot1dRegenPriorityGroup=dot1dRegenPriorityGroup, dot1wPortTxConfigBpduCount=dot1wPortTxConfigBpduCount, atiAclPortListEntry=atiAclPortListEntry, ifMaxInterfaces=ifMaxInterfaces, sysDscpType46=sysDscpType46, portBaseStaticUnicastAllowedToGoTo=portBaseStaticUnicastAllowedToGoTo, atiMacFilter=atiMacFilter, dot1dBaseTable=dot1dBaseTable, sysDscpType39=sysDscpType39, ifSecondaryIpAddressEntry=ifSecondaryIpAddressEntry, sysDscpType26=sysDscpType26, dot1dStpPortPriority=dot1dStpPortPriority, dot1qPortAcceptableFrameTypes=dot1qPortAcceptableFrameTypes, dot1qVlanFdbId=dot1qVlanFdbId, sysPnacPaeSystem=sysPnacPaeSystem, sysDfsMFClassifier=sysDfsMFClassifier, dot1sCistPortPathCost=dot1sCistPortPathCost, dot1sMstiCurrentPortRole=dot1sMstiCurrentPortRole, portBaseStaticUnicastAddress=portBaseStaticUnicastAddress, sysConfigSaveIpAddr=sysConfigSaveIpAddr, sysSnoopVlanMcastMacFwdInstId=sysSnoopVlanMcastMacFwdInstId, sysSnmpsnmpCommunityStatus=sysSnmpsnmpCommunityStatus, dot1dBaseBridgeAddress=dot1dBaseBridgeAddress, atiAclProfileActionCos=atiAclProfileActionCos, sysSslCipherList=sysSslCipherList, PortLaMode=PortLaMode, dot1wPortInvalidRstBpduRxCount=dot1wPortInvalidRstBpduRxCount, sysPortSecurity=sysPortSecurity, dot1dTpPort=dot1dTpPort, atiAclClassifierEtherType=atiAclClassifierEtherType, dhcpSnoopBindindDBIPAddress=dhcpSnoopBindindDBIPAddress, sysDscpType24=sysDscpType24, dot1qStaticMcastPort=dot1qStaticMcastPort, sysSnmpviewTreeSubtree=sysSnmpviewTreeSubtree, sysLBDdetect=sysLBDdetect, dot1dStpPortAdminPointToPoint=dot1dStpPortAdminPointToPoint, dot1sTxHoldCount=dot1sTxHoldCount, sysSnmpaccessReadViewName=sysSnmpaccessReadViewName, sysDlFirmwareName=sysDlFirmwareName, dot1dStpHelloTime=dot1dStpHelloTime, dot1sMstiPortDesignatedPort=dot1sMstiPortDesignatedPort, atiAclOutProfileActionIndex=atiAclOutProfileActionIndex, dot1wPortRestrictedTCN=dot1wPortRestrictedTCN, dot1sCistBridgeRoleSelectionSemState=dot1sCistBridgeRoleSelectionSemState)
mibBuilder.exportSymbols("AT-GS950-16-MIB", sysDfsClfrStatus=sysDfsClfrStatus, dot1sCistRootCost=dot1sCistRootCost, sysMirrorCtrlIngressMirroring=sysMirrorCtrlIngressMirroring, dot1wGlobalErrTrapType=dot1wGlobalErrTrapType, portBaseStaticMulticastStatus=portBaseStaticMulticastStatus, sysLogFileName=sysLogFileName, dot1sMstiTimeSinceTopologyChange=dot1sMstiTimeSinceTopologyChange, sysDefaultIpAddr=sysDefaultIpAddr, l2Dot1qVlan=l2Dot1qVlan, dot1dExtBaseTable=dot1dExtBaseTable, l2Mst=l2Mst, dot1qGvrpStatus=dot1qGvrpStatus, sysDefaultIpSubnetMask=sysDefaultIpSubnetMask, dot1sVlanInstanceMappingEntry=dot1sVlanInstanceMappingEntry, atiDstMacFilterIndex=atiDstMacFilterIndex, dhcpSnoopPortSettingStatus=dhcpSnoopPortSettingStatus, dot1qVlanStaticName=dot1qVlanStaticName, dot1sMstTrapsControlEntry=dot1sMstTrapsControlEntry, dhcpSnoopPassThroughOption82=dhcpSnoopPassThroughOption82, sysSnoopStatsRxAsmLeaves=sysSnoopStatsRxAsmLeaves, dot1dTpHCPortInFrames=dot1dTpHCPortInFrames, sysPortCtrlFlowControl=sysPortCtrlFlowControl, sysSnmpaccessSecurityLevel=sysSnmpaccessSecurityLevel, sysConfigCtrlTable=sysConfigCtrlTable, sysSnoopStatsInetAddressType=sysSnoopStatsInetAddressType, dot1dGmrpStatus=dot1dGmrpStatus, dot1sInstanceUpCount=dot1sInstanceUpCount, dot1sMstiPortEffectivePortState=dot1sMstiPortEffectivePortState, issJumboFramePerPortEnable=issJumboFramePerPortEnable, sysDscpType19=sysDscpType19, sysInitiateRemoteConfigRestore=sysInitiateRemoteConfigRestore, dot1wRstTable=dot1wRstTable, Timeout=Timeout, sysPnacPaePiggybackMode=sysPnacPaePiggybackMode, portBaseVlanCreationTime=portBaseVlanCreationTime, fsLldpTraceInput=fsLldpTraceInput, sysMirrorCtrlEntry=sysMirrorCtrlEntry, sysSnoopVlanMcastMacFwdInetAddressType=sysSnoopVlanMcastMacFwdInetAddressType, dot1sMstiRootCost=dot1sMstiRootCost, fsLldpDupChasisId=fsLldpDupChasisId, atiAclClassifierTable=atiAclClassifierTable, sysSystemInfo=sysSystemInfo, sysRateControl=sysRateControl, dot1dStpBridgeForwardDelay=dot1dStpBridgeForwardDelay, dot1qStaticMulticastEntry=dot1qStaticMulticastEntry, sysDscpType30=sysDscpType30, atiAclPolicyPortListIndex=atiAclPolicyPortListIndex, dhcpSnoopBindindDBPortNumber=dhcpSnoopBindindDBPortNumber, sysSnmpGroupAccess=sysSnmpGroupAccess, ifSecondaryIpAddressTable=ifSecondaryIpAddressTable, dot1dStpVersion=dot1dStpVersion, dot1dTrafficClass=dot1dTrafficClass, sysUserAuthMgrRowStatus=sysUserAuthMgrRowStatus, dot1dGroups=dot1dGroups, dot1qVlanVersionNumber=dot1qVlanVersionNumber, dot1sMstiPortDesignatedRoot=dot1sMstiPortDesignatedRoot, sysSnoopInstanceGlobalInstId=sysSnoopInstanceGlobalInstId, dot1sMstiPortRoleTransitionSemState=dot1sMstiPortRoleTransitionSemState, dot1sPktErrVal=dot1sPktErrVal, fsLldpMisConfigPortVlanID=fsLldpMisConfigPortVlanID, sysSnoopStatsRxGenQueries=sysSnoopStatsRxGenQueries, atiAclPolicyRowStatus=atiAclPolicyRowStatus, BridgeId=BridgeId, dot1wSystemControl=dot1wSystemControl, sysIpAuthMgrPortList=sysIpAuthMgrPortList, dot1qFdbId=dot1qFdbId, dot1dPortOutboundAccessPriority=dot1dPortOutboundAccessPriority, ifIvrTable=ifIvrTable, dot1sMapVlanIndex=dot1sMapVlanIndex, sysDscpType32=sysDscpType32, sysLaMaxPortChannels=sysLaMaxPortChannels, sysSnoopVlanRtrPortList=sysSnoopVlanRtrPortList, dot1dStpPortAdminEdgePort=dot1dStpPortAdminEdgePort, dot1wPortRxRstBpduCount=dot1wPortRxRstBpduCount, l2Rst=l2Rst, sysPnacASUserConfigPermission=sysPnacASUserConfigPermission, dot1dStpExtPortTable=dot1dStpExtPortTable, dot1dDefaultPriorityGroup=dot1dDefaultPriorityGroup, dot1dStpPortDesignatedCost=dot1dStpPortDesignatedCost, sysDfsOutProfileActionMID=sysDfsOutProfileActionMID, portBaseStaticUnicastVlanIndex=portBaseStaticUnicastVlanIndex, sysPnacPaeVlanAssignment=sysPnacPaeVlanAssignment, sysDfsMultiFieldClfrFilterId=sysDfsMultiFieldClfrFilterId, dot1wContextName=dot1wContextName, dot1wPortInvalidTcnBpduRxCount=dot1wPortInvalidTcnBpduRxCount, sysSnmpUserEntry=sysSnmpUserEntry, sysSslGeneralGroup=sysSslGeneralGroup, sysDfsOutProfileActionEntry=sysDfsOutProfileActionEntry, dot1sInstanceDownCount=dot1sInstanceDownCount, fsLldpSystem=fsLldpSystem, dot1dTpPortTable=dot1dTpPortTable, sysIpAuthMgrEntry=sysIpAuthMgrEntry, sysSnmpviewTreeType=sysSnmpviewTreeType, sysSnoopStatsRxAsmReports=sysSnoopStatsRxAsmReports, dot1qStaticMulticastRowStatus=dot1qStaticMulticastRowStatus, dot1dStpPortForwardTransitions=dot1dStpPortForwardTransitions, sysRateCtrlIndex=sysRateCtrlIndex, dot1dStpTable=dot1dStpTable, dot1dPriority=dot1dPriority, dot1dStpRootPort=dot1dStpRootPort, atiAclProfileActionIndex=atiAclProfileActionIndex, dot1sMstEntry=dot1sMstEntry, ifIpSubnetMask=ifIpSubnetMask, dot1sDebug=dot1sDebug, PYSNMP_MODULE_ID=at_GS95016v3, dot1dStpPortDesignatedPort=dot1dStpPortDesignatedPort, sysSnmpGroupStatus=sysSnmpGroupStatus, ifSecondaryIpAddress=ifSecondaryIpAddress, dot1sVlanInstanceMappingTable=dot1sVlanInstanceMappingTable, dot1dAccessPriorityGroup=dot1dAccessPriorityGroup, dot1sCistMaxAge=dot1sCistMaxAge, atiAclProfileActionDscp=atiAclProfileActionDscp, fsLldpDupSystemName=fsLldpDupSystemName, sysSnmpUserName=sysSnmpUserName, dot1qTpPort=dot1qTpPort, sysSntpTzMinutesWest=sysSntpTzMinutesWest, portBaseStaticUnicastStatus=portBaseStaticUnicastStatus, ifIvrBridgedIface=ifIvrBridgedIface, dot1sMstpDownCount=dot1sMstpDownCount, dot1sSetTraps=dot1sSetTraps, sysSntpGeneralGroup=sysSntpGeneralGroup, sysPnacASUserConfigAuthProtocol=sysPnacASUserConfigAuthProtocol, dot1dStpTxHoldCount=dot1dStpTxHoldCount, dot1sMstiPortDesignatedBridge=dot1sMstiPortDesignatedBridge, dot1sCistRegionalRoot=dot1sCistRegionalRoot, dot1sCistPortInfoSemState=dot1sCistPortInfoSemState, L2snmpLevel=L2snmpLevel, pysmi_if=pysmi_if, sysHttpPort=sysHttpPort, dot1dExtBaseEntry=dot1dExtBaseEntry, dot1sCistPortPriority=dot1sCistPortPriority, dot1sPortTrapNotificationTable=dot1sPortTrapNotificationTable, sysCliAutoTimeoutInterval=sysCliAutoTimeoutInterval, dot1wGenTrapType=dot1wGenTrapType, portBaseVlanCurrentTable=portBaseVlanCurrentTable, voicevlanOUIStatus=voicevlanOUIStatus, dot1sMaxMstInstanceNumber=dot1sMaxMstInstanceNumber, sysFDResetStateEnable=sysFDResetStateEnable, sysSnoopVlan=sysSnoopVlan, dot1dTpEntry=dot1dTpEntry, EnabledStatus=EnabledStatus, sysSntpTimeSeconds=sysSntpTimeSeconds, sysDscpType44=sysDscpType44, dot1qFdbTable=dot1qFdbTable, dot1sMstiPortTransmittedBPDUs=dot1sMstiPortTransmittedBPDUs, dot1dStpPortOperPointToPoint=dot1dStpPortOperPointToPoint, dot1qVlanNumDeletes=dot1qVlanNumDeletes, portBaseStaticUnicastRowStatus=portBaseStaticUnicastRowStatus, dot1wRstContextId=dot1wRstContextId, l2Dot1dStp=l2Dot1dStp, sysSslCiphers=sysSslCiphers, dot1qVlanStaticTable=dot1qVlanStaticTable, dot1wPortAutoEdge=dot1wPortAutoEdge, sysSnoopStatsRxGrpQueries=sysSnoopStatsRxGrpQueries, dot1qVlanEgressPortEntry=dot1qVlanEgressPortEntry, sysSyslogLogs=sysSyslogLogs, dot1wPortTopoChSmState=dot1wPortTopoChSmState, sysSnoopRouterPortPurgeInterval=sysSnoopRouterPortPurgeInterval, sysDfsCoSqAlgorithm=sysDfsCoSqAlgorithm, dot1qVlanDebug=dot1qVlanDebug, l2Cfa=l2Cfa, sysLaStatus=sysLaStatus, trafficSegIfIndex=trafficSegIfIndex, sysSyslogFacility=sysSyslogFacility, dot1sCistPortDesignatedCost=dot1sCistPortDesignatedCost, sysConfigCtrlEntry=sysConfigCtrlEntry, dot1dUserPriority=dot1dUserPriority, portBaseVlanStatus=portBaseVlanStatus, sysSnmpEngineID=sysSnmpEngineID, dot1sMstiPortPathCost=dot1sMstiPortPathCost, sysSnoopVlanFilterInstId=sysSnoopVlanFilterInstId, ifIpForwardingEnable=ifIpForwardingEnable, sysDfsMIBObjects=sysDfsMIBObjects, sysSnmpviewTreeName=sysSnmpviewTreeName, dot1wNewRootIdCount=dot1wNewRootIdCount, sysInitiateConfigSave=sysInitiateConfigSave, dot1wPortRole=dot1wPortRole, sysDscpType14=sysDscpType14, dot1sMstiForcePortState=dot1sMstiForcePortState, dot1dStpPriority=dot1dStpPriority, dot1dStpPortDesignatedBridge=dot1dStpPortDesignatedBridge, dot1wPortTrapNotificationTable=dot1wPortTrapNotificationTable, dot1sInstanceVlanMapped2k=dot1sInstanceVlanMapped2k, sysDfsMultiFieldClfrStatus=sysDfsMultiFieldClfrStatus, dot1sMstiBridgeTable=dot1sMstiBridgeTable, dot1sSystemControl=dot1sSystemControl, atiAclClassifierDstMac=atiAclClassifierDstMac, atiAclOutProfileActionPermitDeny=atiAclOutProfileActionPermitDeny, atiAclPolicyEntry=atiAclPolicyEntry, dot1wRst=dot1wRst, sysSnoopVlanRowStatus=sysSnoopVlanRowStatus, dot1wBufferFailureCount=dot1wBufferFailureCount, dot1wDebugOption=dot1wDebugOption, sysPnacASUserConfigDynamicVlanID=sysPnacASUserConfigDynamicVlanID, sysSyslogConfigLogLevel=sysSyslogConfigLogLevel, dot1sCistPortAutoEdgeStatus=dot1sCistPortAutoEdgeStatus, sysPnacPaePortNo=sysPnacPaePortNo, voicevlanPortState=voicevlanPortState, sysSntpStatus=sysSntpStatus, sysSnoopStatsEntry=sysSnoopStatsEntry, dot1dPortDefaultUserPriority=dot1dPortDefaultUserPriority, dot1wModuleStatus=dot1wModuleStatus, atiAclClassifierSrcMac=atiAclClassifierSrcMac, sysLaSystem=sysLaSystem, sysDfsInProfileActionStatus=sysDfsInProfileActionStatus, sysUserAuthMgrName=sysUserAuthMgrName, dot1qPortGvrpStatus=dot1qPortGvrpStatus, l2Vlan=l2Vlan, sysAsyVLANEnable=sysAsyVLANEnable, dot1dUserPriorityRegenEntry=dot1dUserPriorityRegenEntry, dot1wRstEntry=dot1wRstEntry, ifMainAdminStatus=ifMainAdminStatus, dot1sCistPortStateTransitionSemState=dot1sCistPortStateTransitionSemState, portBaseVlanName=portBaseVlanName, sysLaPortChannelIfIndex=sysLaPortChannelIfIndex, sysStormCtrlIndex=sysStormCtrlIndex, dot1qPortGvrpFailedRegistrations=dot1qPortGvrpFailedRegistrations, dot1sCistPortState=dot1sCistPortState, dot1sMstiRegionName=dot1sMstiRegionName, dot1dStpPortProtocolMigration=dot1dStpPortProtocolMigration, dot1dBasePortTable=dot1dBasePortTable, dot1sCistPortOperEdgeStatus=dot1sCistPortOperEdgeStatus, sysDscpType35=sysDscpType35, dot1dStatic=dot1dStatic, PermissionType=PermissionType, dot1qVlanLearningMode=dot1qVlanLearningMode, dhcpSnoopPortSettingTable=dhcpSnoopPortSettingTable, dot1dPriorityGroup=dot1dPriorityGroup, sysCpuPolicerStatus=sysCpuPolicerStatus, sysSyslogLogging=sysSyslogLogging, atiAclPolicyOutProfileIndex=atiAclPolicyOutProfileIndex, atiDstMacFilterRowStatus=atiDstMacFilterRowStatus, sysSnmpTrapManager=sysSnmpTrapManager, sysConfigRestoreFileName=sysConfigRestoreFileName, dot1dPortGarpTable=dot1dPortGarpTable, dot1sCistHoldTime=dot1sCistHoldTime, dot1dTpPortOverflowEntry=dot1dTpPortOverflowEntry, dhcpSnoopVLANSettingTable=dhcpSnoopVLANSettingTable, sysSntpTzDSTEndDay=sysSntpTzDSTEndDay, atiAclPolicyIndex=atiAclPolicyIndex, IfDirection=IfDirection, sysSnoopReportForwardInterval=sysSnoopReportForwardInterval, sysDfsOutProfileActionStatus=sysDfsOutProfileActionStatus, dot1qStaticUnicastAddress=dot1qStaticUnicastAddress, portBaseStaticUnicastIndex=portBaseStaticUnicastIndex, sysSnmpViewTreeTable=sysSnmpViewTreeTable, dot1qStaticMulticastTable=dot1qStaticMulticastTable, sysSyslogConfigEntry=sysSyslogConfigEntry, fsLldpLocPortId=fsLldpLocPortId, portBaseStatic=portBaseStatic, sysLBDRecoverTime=sysLBDRecoverTime, dot1sCistPortEntry=dot1sCistPortEntry, LacpState=LacpState, dot1dHCPortGroup=dot1dHCPortGroup)
mibBuilder.exportSymbols("AT-GS950-16-MIB", sysPnacPaeMultiAuthEnable=sysPnacPaeMultiAuthEnable, dot1dStaticReceivePort=dot1dStaticReceivePort, dot1wPortExtEntry=dot1wPortExtEntry, dot1wPortRoleTransSmState=dot1wPortRoleTransSmState, dot1sInstanceVlanMapped=dot1sInstanceVlanMapped, fsLldpRemTablesChange=fsLldpRemTablesChange, sysDscpType15=sysDscpType15, dot1sInstanceVlanMapped3k=dot1sInstanceVlanMapped3k, fsLldpPortConfigNotificationType=fsLldpPortConfigNotificationType, atiAclClassifierRowStatus=atiAclClassifierRowStatus, dot1dPortGarpGroup=dot1dPortGarpGroup, sysDscpType48=sysDscpType48, ifMaxPhysInterfaces=ifMaxPhysInterfaces, sysSnoopVlanMcastMacFwdEntry=sysSnoopVlanMcastMacFwdEntry, fsLldpMisConfigProtocolIdentity=fsLldpMisConfigProtocolIdentity, sysPnacPaePortTable=sysPnacPaePortTable, dhcpSnoopBackupDatabase=dhcpSnoopBackupDatabase, sysMirrorCtrlEgressMirroring=sysMirrorCtrlEgressMirroring, dot1sCistPortRegionalRoot=dot1sCistPortRegionalRoot, sysDscpType01=sysDscpType01, dot1dBasePortEntry=dot1dBasePortEntry, dot1dExtBase=dot1dExtBase, dhcpSnoopOption82Insertion=dhcpSnoopOption82Insertion, dhcpSnoopBindindDBVLANID=dhcpSnoopBindindDBVLANID, sysSntpTzDSTEndHour=sysSntpTzDSTEndHour, dot1wRstTrapsControl=dot1wRstTrapsControl, dot1sCistPortRxRstBpduCount=dot1sCistPortRxRstBpduCount, dot1qVlanCurrentEgressPort=dot1qVlanCurrentEgressPort, dot1sMstiPortPriority=dot1sMstiPortPriority, dot1dStpPortDesignatedRoot=dot1dStpPortDesignatedRoot, sysDfsCoSqAlgorithmTable=sysDfsCoSqAlgorithmTable, sysDscpType08=sysDscpType08, sysSnoopStats=sysSnoopStats, sysPortCtrlTable=sysPortCtrlTable, sysSslPort=sysSslPort, dot1dPortOverflowGroup=dot1dPortOverflowGroup, dot1qPortGvrpLastPduOrigin=dot1qPortGvrpLastPduOrigin, dot1sCistHelloTime=dot1sCistHelloTime, atiAclInProfileActionRowStatus=atiAclInProfileActionRowStatus, sysSnmpUserTable=sysSnmpUserTable, dot1sMstiBridgeEntry=dot1sMstiBridgeEntry, sysSwitchName=sysSwitchName, sysPortCtrlBPDUPassThrough=sysPortCtrlBPDUPassThrough, sysFirmwareVersion=sysFirmwareVersion, sysDscpType12=sysDscpType12, sysDscpType16=sysDscpType16, sysSnoopVlanRouterInstId=sysSnoopVlanRouterInstId, atiAclClassifierVlanId=atiAclClassifierVlanId, ifMainType=ifMainType, dot1qMIBObjects=dot1qMIBObjects, InetAddressDNS=InetAddressDNS, dot1wOldDesignatedRoot=dot1wOldDesignatedRoot, dot1sRegionConfigChangeCount=dot1sRegionConfigChangeCount, dot1sCistPortTable=dot1sCistPortTable, l2DhcpSnoop=l2DhcpSnoop, sysUploadLogFileToIp=sysUploadLogFileToIp, dot1dStpPortPathCost=dot1dStpPortPathCost, dot1dTp=dot1dTp, sysDfsInProfileActionFlag=sysDfsInProfileActionFlag, dot1dStpPortEntry=dot1dStpPortEntry, dot1sMstiConfigDigest=dot1sMstiConfigDigest, sysSnoopStatsTxAsmLeaves=sysSnoopStatsTxAsmLeaves, sysDfsOutProfileActionTable=sysDfsOutProfileActionTable, sysSntpTzDSTStartHour=sysSntpTzDSTStartHour, sysPnacAuthenticServer=sysPnacAuthenticServer, sysSnmpsnmpCommunityName=sysSnmpsnmpCommunityName, atiAclProfileActionTable=atiAclProfileActionTable, dot1sGlobalErrTrapType=dot1sGlobalErrTrapType, dot1sPortRoleType=dot1sPortRoleType, dot1sCistPortForwardTransitions=dot1sCistPortForwardTransitions, sysDscpType20=sysDscpType20, dot1sCistDynamicPathcostCalculation=dot1sCistDynamicPathcostCalculation, dot1wRstTrapsControlEntry=dot1wRstTrapsControlEntry, dot1dTrafficClassesEnabled=dot1dTrafficClassesEnabled, dhcpSnoopBindindDBRowStatus=dhcpSnoopBindindDBRowStatus, sysPnacGuestVlanId=sysPnacGuestVlanId, sysSnoopInstanceGlobalEntry=sysSnoopInstanceGlobalEntry, sysPortCtrlMode=sysPortCtrlMode, sysDscpType23=sysDscpType23, dot1qTpFdbAddress=dot1qTpFdbAddress, dot1dBasePortCircuit=dot1dBasePortCircuit, dot1qVlanGlobalsEntry=dot1qVlanGlobalsEntry, sysConfigSaveOption=sysConfigSaveOption, dot1wPort=dot1wPort, sysDscpType36=sysDscpType36, portBaseVlanIndex=portBaseVlanIndex, sysSntpTzDSTStartMinute=sysSntpTzDSTStartMinute, dot1wSetGlobalTraps=dot1wSetGlobalTraps, LacpKey=LacpKey, sysSntpTzDSTStartMon=sysSntpTzDSTStartMon, dot1dTpPortEntry=dot1dTpPortEntry, sysRadiusExtServerAuthPortNum=sysRadiusExtServerAuthPortNum, dot1dBasePortMtuExceededDiscards=dot1dBasePortMtuExceededDiscards, dot1sPortTrapIndex=dot1sPortTrapIndex, sysLBDCtrlIndex=sysLBDCtrlIndex, sysPortSecurityMLA=sysPortSecurityMLA, sysPnacASUserConfigRowStatus=sysPnacASUserConfigRowStatus, sysConfigSaveStatus=sysConfigSaveStatus, sysPnacPaePortEntry=sysPnacPaePortEntry, ifMainIndex=ifMainIndex, ifIpBroadcastAddr=ifIpBroadcastAddr, dot1sGlobalErrTrap=dot1sGlobalErrTrap, portBaseVlan=portBaseVlan, sysMirrorToPort=sysMirrorToPort, voicevlanOUIMask=voicevlanOUIMask, sysLBDPortStatus=sysLBDPortStatus, sysSnoopStatsInstId=sysSnoopStatsInstId, dot1sMstiNewRootBridgeCount=dot1sMstiNewRootBridgeCount, sysTrapEnable=sysTrapEnable, sysDscpType61=sysDscpType61, dot1sTopologyChgTrap=dot1sTopologyChgTrap, dot1sModuleStatus=dot1sModuleStatus, sysSnoopInstanceConfigTable=sysSnoopInstanceConfigTable, dot1dNotifications=dot1dNotifications, dot1sCistPortRestrictedRole=dot1sCistPortRestrictedRole, sysSnmpUserStatus=sysSnmpUserStatus, dot1sMstiPortReceivedBPDUs=dot1sMstiPortReceivedBPDUs, fsLldpTLV=fsLldpTLV, dot1sCistProtocolMigrationCount=dot1sCistProtocolMigrationCount, voiceVlanId=voiceVlanId, sysLaMaxPortsPerPortChannel=sysLaMaxPortsPerPortChannel, dot1sCistRootPort=dot1sCistRootPort, sysRadiusExtServerIndex=sysRadiusExtServerIndex, sysDscpType18=sysDscpType18, dot1dStaticRowStatus=dot1dStaticRowStatus, sysSnoopRetryCount=sysSnoopRetryCount, atiAclOutProfileActionRowStatus=atiAclOutProfileActionRowStatus, topologyChange=topologyChange, dot1sCistTopChanges=dot1sCistTopChanges, sysDscpType37=sysDscpType37, sysSnmpViewTree=sysSnmpViewTree, sysRadiusExtServerTable=sysRadiusExtServerTable, ifMainOperStatus=ifMainOperStatus, dot1dStaticAllowedToGoTable=dot1dStaticAllowedToGoTable, sysSnoopVlanCfgQuerier=sysSnoopVlanCfgQuerier, dot1dTpHCPortOutFrames=dot1dTpHCPortOutFrames, sysSyslogConfigTable=sysSyslogConfigTable, VlanIndex=VlanIndex, sysDhcpAutoConfiguration=sysDhcpAutoConfiguration, sysDscpType54=sysDscpType54, dot1sNewPortRoleTrap=dot1sNewPortRoleTrap, fsLldpDupManagmentAddress=fsLldpDupManagmentAddress, dot1dDeviceGmrpGroup=dot1dDeviceGmrpGroup, dot1sMstiBridgePriority=dot1sMstiBridgePriority, sysPortCtrlSpeed=sysPortCtrlSpeed, dot1sPortRoleTrapNotificationTable=dot1sPortRoleTrapNotificationTable, sysConfigCtrlIndex=sysConfigCtrlIndex, dot1qStaticMcastPortTable=dot1qStaticMcastPortTable, dot1sInstanceVlanMapped4k=dot1sInstanceVlanMapped4k, dot1dStpEntry=dot1dStpEntry, sysPnacSystemControl=sysPnacSystemControl, dot1sCistBridgeMaxAge=dot1sCistBridgeMaxAge, dot1sMstiRootPort=dot1sMstiRootPort, dot1wRstpDownCount=dot1wRstpDownCount, fsLldpMemAllocFailure=fsLldpMemAllocFailure, sysHardwareVersion=sysHardwareVersion, atiAclInProfileActionEntry=atiAclInProfileActionEntry, dot1sCistPortReceiveSemState=dot1sCistPortReceiveSemState, dot1qStaticAllowedToGoTable=dot1qStaticAllowedToGoTable, dot1sSetVlanList=dot1sSetVlanList, sysDfsClfrEntry=sysDfsClfrEntry, sysLaPortChannelAdminMacAddress=sysLaPortChannelAdminMacAddress, ifSecondaryIpSubnetMask=ifSecondaryIpSubnetMask, dot1dBaseNumPorts=dot1dBaseNumPorts, dot1dTpHCPortTable=dot1dTpHCPortTable, sysPnacAuthServer=sysPnacAuthServer, dot1dStpPathCostDefault=dot1dStpPathCostDefault, dot1dPortPriorityEntry=dot1dPortPriorityEntry, sysDscpType28=sysDscpType28, atiDstMacFilterEntry=atiDstMacFilterEntry, dot1qVlanStaticRowStatus=dot1qVlanStaticRowStatus, sysDscpType59=sysDscpType59, dot1sRegionConfigChangeTrap=dot1sRegionConfigChangeTrap, dot1wPortInfoSmState=dot1wPortInfoSmState, voicevlanPortAutoDetection=voicevlanPortAutoDetection, sysStormCtrlRowStatus=sysStormCtrlRowStatus, voicevlanOUI=voicevlanOUI, dhcpSnoopBindindDatabaseTable=dhcpSnoopBindindDatabaseTable, sysDscpType17=sysDscpType17, sysSyslogConfigModule=sysSyslogConfigModule, sysDscpType31=sysDscpType31, dot1dTpFdbTable=dot1dTpFdbTable, l2Snmp=l2Snmp, sysSnoopVlanFastLeave=sysSnoopVlanFastLeave, atiAclPortListTable=atiAclPortListTable, sysSshMacList=sysSshMacList, sysPnacGuestVlanTable=sysPnacGuestVlanTable, sysPortSecurityEntry=sysPortSecurityEntry, portBaseVlanRowStatus=portBaseVlanRowStatus, snmpGlobalState=snmpGlobalState, sysSslTrace=sysSslTrace, fsLldpExceedsMaxFrameSize=fsLldpExceedsMaxFrameSize, tabPortBaseStaticMulticastEntry=tabPortBaseStaticMulticastEntry, fsLldpTraceOption=fsLldpTraceOption, dot1sCistTimeSinceTopologyChange=dot1sCistTimeSinceTopologyChange, sysMirrorStatus=sysMirrorStatus, newRoot=newRoot, sysRadiusExtServerEntry=sysRadiusExtServerEntry, dot1qVlanCurrentEntry=dot1qVlanCurrentEntry, dot1dConformance=dot1dConformance, sysWebAutoTimeoutInterval=sysWebAutoTimeoutInterval, dot1sInstanceIndex=dot1sInstanceIndex, dot1wGlobalErrTrap=dot1wGlobalErrTrap, atiAclClassifierSrcPort=atiAclClassifierSrcPort, dot1wPortRoleSelSmState=dot1wPortRoleSelSmState, sysSnmpviewTreeMask=sysSnmpviewTreeMask, dot1sCistPortRegionalPathCost=dot1sCistPortRegionalPathCost, fsLldpMisConfigPortProtoVlanID=fsLldpMisConfigPortProtoVlanID, sysIpAuthMgr=sysIpAuthMgr, dot1qBaseTable=dot1qBaseTable, sysSntpPollInterval=sysSntpPollInterval, dot1qFdbDynamicCount=dot1qFdbDynamicCount, dot1dTrafficClassTable=dot1dTrafficClassTable, sysLaPortChannelMode=sysLaPortChannelMode, dot1sCistPort=dot1sCistPort, dot1sOldRoleType=dot1sOldRoleType, sysLoggingOption=sysLoggingOption, sysSyslogClearLog=sysSyslogClearLog, dot1dMIBObjects=dot1dMIBObjects, fsLldpInputQOverFlows=fsLldpInputQOverFlows, sysPnacASUserConfigAuthTimeout=sysPnacASUserConfigAuthTimeout, dot1dPortGarpLeaveAllTime=dot1dPortGarpLeaveAllTime, dot1sInvalidBpduRxdTrap=dot1sInvalidBpduRxdTrap, sysLaPortBundleState=sysLaPortBundleState, dot1sPktErrType=dot1sPktErrType, atiAclClassifierProtocol=atiAclClassifierProtocol, sysPnacASUserConfigPortList=sysPnacASUserConfigPortList, sysDscpType49=sysDscpType49, portBaseStaticMulticastVlanIndex=portBaseStaticMulticastVlanIndex, sysDfsClfrMFClfrId=sysDfsClfrMFClfrId, sysStormControl=sysStormControl, sysRadiusExtServerMaximumRetransmission=sysRadiusExtServerMaximumRetransmission, sysDfsInProfileActionTable=sysDfsInProfileActionTable, sysHttpStatus=sysHttpStatus, sysSysContact=sysSysContact, sysDscpType60=sysDscpType60, dot1dTpPortOutOverflowFrames=dot1dTpPortOutOverflowFrames, dot1sMstiPort=dot1sMstiPort, sysFDRInputPw=sysFDRInputPw, sysStormCtrlThreshold=sysStormCtrlThreshold, sysSnmpSecurityName=sysSnmpSecurityName, sysRmonEnableStatus=sysRmonEnableStatus, sysGuestVlan=sysGuestVlan, dot1wGenTrap=dot1wGenTrap, dot1dPortGarpJoinTime=dot1dPortGarpJoinTime, portBaseVlanCurrentEgressPorts=portBaseVlanCurrentEgressPorts, dot1dTpFdbAddress=dot1dTpFdbAddress, ifIvrEntry=ifIvrEntry, sysLaOperStatus=sysLaOperStatus, sysLaPortActorAdminPort=sysLaPortActorAdminPort, sysDscpType38=sysDscpType38, ifMainMtu=ifMainMtu, dot1sCistPortDesignatedRoot=dot1sCistPortDesignatedRoot, dot1sCistPortInvalidConfigBpduRxCount=dot1sCistPortInvalidConfigBpduRxCount)
mibBuilder.exportSymbols("AT-GS950-16-MIB", dot1dTrafficClassEntry=dot1dTrafficClassEntry, sysLoginAuthentication=sysLoginAuthentication, dot1dTpPortOutFrames=dot1dTpPortOutFrames, dot1sMstTrapsControlTable=dot1sMstTrapsControlTable, atiAclInProfileActionActionId=atiAclInProfileActionActionId, sysPortCtrlMDI=sysPortCtrlMDI, dot1sMaxHopCount=dot1sMaxHopCount, dot1sMstiPortEntry=dot1sMstiPortEntry, dot1dPortGarpLeaveTime=dot1dPortGarpLeaveTime, l2Snoop=l2Snoop, sysLaPortChannelGroup=sysLaPortChannelGroup, dot1qVlanCurrentTable=dot1qVlanCurrentTable, atiAclOutProfileActionTable=atiAclOutProfileActionTable, sysDscpType22=sysDscpType22, dhcpSnoopVerifyMACAddress=dhcpSnoopVerifyMACAddress, sysSnmpCommunityEntry=sysSnmpCommunityEntry, sysSntpTzDSTStartDay=sysSntpTzDSTStartDay, atiAclPolicySequence=atiAclPolicySequence, dot1wPortEffectivePortState=dot1wPortEffectivePortState, atiDstMacFilterAddress=atiDstMacFilterAddress, sysSnmpCommunity=sysSnmpCommunity, sysDfsMeterRefreshCount=sysDfsMeterRefreshCount, dot1dStaticEntry=dot1dStaticEntry, VlanId=VlanId, sysDfsMultiFieldClfrFilterType=sysDfsMultiFieldClfrFilterType, dot1sCistForcePortState=dot1sCistForcePortState, sysDfsMeterStatus=sysDfsMeterStatus, sysPnacPaePortStatus=sysPnacPaePortStatus, sysSshCipherList=sysSshCipherList, dot1dRegenUserPriority=dot1dRegenUserPriority, dot1qPortVlanTable=dot1qPortVlanTable, dhcpSnoopBindindDatabaseEntry=dhcpSnoopBindindDatabaseEntry, l2Sntp=l2Sntp, dot1dStpPortOperEdgePort=dot1dStpPortOperEdgePort, sysLaPortChannelTable=sysLaPortChannelTable, dot1wPortRxConfigBpduCount=dot1wPortRxConfigBpduCount, sysSnmpViewTreeEntry=sysSnmpViewTreeEntry, sysDscpType42=sysDscpType42, dot1dPortCapabilitiesEntry=dot1dPortCapabilitiesEntry, sysIpAuthMgrIpAddr=sysIpAuthMgrIpAddr, dot1sContextName=dot1sContextName, ifSecondaryIpRowStatus=ifSecondaryIpRowStatus, dot1dTpHCPortEntry=dot1dTpHCPortEntry, sysSnmpaccessNotifyViewName=sysSnmpaccessNotifyViewName, dot1sCistPortTransmitSemState=dot1sCistPortTransmitSemState, sysSyslogGeneralGroup=sysSyslogGeneralGroup, sysSslDefaultCipherList=sysSslDefaultCipherList, sysPnacASUserConfigPassword=sysPnacASUserConfigPassword, sysDscpType58=sysDscpType58, dot1dStpDesignatedRoot=dot1dStpDesignatedRoot, dot1qVlanNumDeletesEntry=dot1qVlanNumDeletesEntry, dot1wSetTraps=dot1wSetTraps, voicevlanOUITelephonyOUI=voicevlanOUITelephonyOUI, sysLaPortTable=sysLaPortTable, dot1qVlanGlobalsContextId=dot1qVlanGlobalsContextId, sysSnmpaccessStatus=sysSnmpaccessStatus, dot1dTpPortMaxInfo=dot1dTpPortMaxInfo, dot1qBaseEntry=dot1qBaseEntry, dot1wPktErrType=dot1wPktErrType, atiAclPolicyTable=atiAclPolicyTable, sysSnmpviewTreeStatus=sysSnmpviewTreeStatus, ifMainEncapType=ifMainEncapType, sysDscpType51=sysDscpType51, sysUserAuthMgrId=sysUserAuthMgrId, dhcpSnoopSystemStatus=dhcpSnoopSystemStatus, sysSyslogLogSrvAddr=sysSyslogLogSrvAddr, sysRmonHwEventSupp=sysRmonHwEventSupp, dot1sResetVlanList=dot1sResetVlanList, sysPnacASUserConfigEntry=sysPnacASUserConfigEntry, dot1sCistPortOperVersion=dot1sCistPortOperVersion, dot1qGarpShutdownStatus=dot1qGarpShutdownStatus, portBaseStaticMulticastStaticEgressPorts=portBaseStaticMulticastStaticEgressPorts, dot1wPortProtocolMigrationCount=dot1wPortProtocolMigrationCount, dot1dBridgeContextId=dot1dBridgeContextId, atiAclInProfileActionIndex=atiAclInProfileActionIndex, dot1dStpPortEnable=dot1dStpPortEnable, sysLaPortChannelActivePortCount=sysLaPortChannelActivePortCount, sysDscpType34=sysDscpType34, sysSnoopVlanQueryInterval=sysSnoopVlanQueryInterval, sysSnoopInst=sysSnoopInst, dot1wPktErrVal=dot1wPktErrVal, sysRadiusExtServerAddress=sysRadiusExtServerAddress, sysDscpType11=sysDscpType11, sysPortCtrlEAPPassThrough=sysPortCtrlEAPPassThrough, dot1dStaticAllowedIsMember=dot1dStaticAllowedIsMember, dot1qStaticUnicastReceivePort=dot1qStaticUnicastReceivePort, sysMirrorCtrlTable=sysMirrorCtrlTable, fsLldpTraps=fsLldpTraps, sysSnoopVlanFilterVlanId=sysSnoopVlanFilterVlanId, sysPnacNasId=sysPnacNasId, sysSyslogSysBuffers=sysSyslogSysBuffers, sysDfsInProfileAction=sysDfsInProfileAction, ifIpAddrAllocMethod=ifIpAddrAllocMethod, sysConfigRestoreStatus=sysConfigRestoreStatus, dot1qStaticUnicastStatus=dot1qStaticUnicastStatus, sysLBDCtrlEntry=sysLBDCtrlEntry, dot1sMstTraps=dot1sMstTraps, dot1dTpPortOverflowTable=dot1dTpPortOverflowTable, dot1sBrgAddress=dot1sBrgAddress, dot1sCistBridgeHelloTime=dot1sCistBridgeHelloTime, dot1dTpFdbEntry=dot1dTpFdbEntry, dot1sMstiBridgeRegionalRoot=dot1sMstiBridgeRegionalRoot, dot1dCompliance=dot1dCompliance, atiAclOutProfileActionActionId=atiAclOutProfileActionActionId, ifMainEntry=ifMainEntry, sysSnoopInstanceGlobalSystemControl=sysSnoopInstanceGlobalSystemControl, sysSnmpaccessWriteViewName=sysSnmpaccessWriteViewName, sysSnoopSendQueryOnTopoChange=sysSnoopSendQueryOnTopoChange, dot1wRstpUpCount=dot1wRstpUpCount, dot1qVlanStaticPortConfigTable=dot1qVlanStaticPortConfigTable, dot1dExtCapGroup=dot1dExtCapGroup, dot1wPortRestrictedRole=dot1wPortRestrictedRole, sysLaPortChannel=sysLaPortChannel, sysLaPort=sysLaPort, sysRateCtrlEntry=sysRateCtrlEntry, fsLldpMisConfigLinkAggStatus=fsLldpMisConfigLinkAggStatus, dot1sTrace=dot1sTrace, atiAclInProfileActionPermitDeny=atiAclInProfileActionPermitDeny, sysDscpType09=sysDscpType09, sysSnoopVlanMcastMacFwdPortList=sysSnoopVlanMcastMacFwdPortList, dot1wPortExtTable=dot1wPortExtTable, voicevlanOUIDescription=voicevlanOUIDescription, atiAclClassifierDscp=atiAclClassifierDscp, voicevlanPortControlEntry=voicevlanPortControlEntry, sysSnmpsnmpTrapManagerName=sysSnmpsnmpTrapManagerName, dot1wPortStateTransSmState=dot1wPortStateTransSmState, dot1qTpFdbEntry=dot1qTpFdbEntry, dot1sMstiPortTopologyChangeSemState=dot1sMstiPortTopologyChangeSemState, dot1qGvrpOperStatus=dot1qGvrpOperStatus, sysInitiateDlFirmware=sysInitiateDlFirmware, sysPortSecurityIndex=sysPortSecurityIndex, atiAclClassifierIndex=atiAclClassifierIndex, dhcpSnoopBindindDBMacAddress=dhcpSnoopBindindDBMacAddress, dot1sMstiPortTable=dot1sMstiPortTable, dot1sTraps=dot1sTraps, dot1sCistPortTxTcnBpduCount=dot1sCistPortTxTcnBpduCount, l2Security=l2Security, sysSntpSecondSrvAddr=sysSntpSecondSrvAddr, dot1sNewRootTrap=dot1sNewRootTrap, dot1sNoOfMstiSupported=dot1sNoOfMstiSupported, dot1qTpFdbPw=dot1qTpFdbPw, sysBroadcastOnOff=sysBroadcastOnOff, dot1dTpPortInDiscards=dot1dTpPortInDiscards, sysDlFirmwareFromIp=sysDlFirmwareFromIp, issCosEnable=issCosEnable, dot1sCistPortTxMstBpduCount=dot1sCistPortTxMstBpduCount, l2Dfs=l2Dfs, sysUserAuthMgr=sysUserAuthMgr, dot1dStpPortTable=dot1dStpPortTable, tabPortBaseStaticUnicastEntry=tabPortBaseStaticUnicastEntry, voicevlanSystem=voicevlanSystem, atiAcl=atiAcl, atiDstMacFilterTable=atiDstMacFilterTable, dot1dPortOutboundAccessPriorityEntry=dot1dPortOutboundAccessPriorityEntry, sysSnmpGroupAccessEntry=sysSnmpGroupAccessEntry, fsLldpLocPortTable=fsLldpLocPortTable, sysRateCtrlIngressLimitValue=sysRateCtrlIngressLimitValue, sysSnoopVlanRouterVlanId=sysSnoopVlanRouterVlanId, dot1qVlanIndex=dot1qVlanIndex, sysSnoopVlanRouterPortList=sysSnoopVlanRouterPortList, sysIpAuthMgrRowStatus=sysIpAuthMgrRowStatus, sysSntpPrimarySrvAddr=sysSntpPrimarySrvAddr, sysSwitchBaseMacAddress=sysSwitchBaseMacAddress, dot1dStpExtTable=dot1dStpExtTable, trafficSegEntry=trafficSegEntry, atiAclOutProfileActionBurstSize=atiAclOutProfileActionBurstSize, sysPortSecurityState=sysPortSecurityState, sysSnoopReportFwdOnAllPorts=sysSnoopReportFwdOnAllPorts, sysDfsClfrOutProActionId=sysDfsClfrOutProActionId, sysSnoopGrpQueryInterval=sysSnoopGrpQueryInterval, atiAclOutProfileActionEntry=atiAclOutProfileActionEntry, sysRadiusExtServerResponseTime=sysRadiusExtServerResponseTime, sysDfsCoSqAlgorithmEntry=sysDfsCoSqAlgorithmEntry, portBaseStaticMulticastIndex=portBaseStaticMulticastIndex, dot1sForceProtocolVersion=dot1sForceProtocolVersion, atiAclClassifierDstPort=atiAclClassifierDstPort, dot1sCistPortRoleTransitionSemState=dot1sCistPortRoleTransitionSemState, portBaseStaticMulticastRowStatus=portBaseStaticMulticastRowStatus, sysSnmpUserAuthProtocol=sysSnmpUserAuthProtocol, dot1wPortRxTcnBpduCount=dot1wPortRxTcnBpduCount, fsLldpLocChassisId=fsLldpLocChassisId, atiAclClassifierSrcIp=atiAclClassifierSrcIp, sysSntpTimeZoneMappingIndex=sysSntpTimeZoneMappingIndex, dot1qVlanStaticPort=dot1qVlanStaticPort, traps=traps, l2System=l2System, dot1dStpTopChanges=dot1dStpTopChanges, dot1sOldDesignatedRoot=dot1sOldDesignatedRoot, dot1dSr=dot1dSr, dot1wNewPortRoleTrap=dot1wNewPortRoleTrap, sysDscpType07=sysDscpType07, fsLldpMisConfigOperMauType=fsLldpMisConfigOperMauType, sysConfigCtrlEgressStatus=sysConfigCtrlEgressStatus, dot1sMstTable=dot1sMstTable, dot1wTopologyChgTrap=dot1wTopologyChgTrap, sysDscpType43=sysDscpType43, dot1sCistSelectedPortRole=dot1sCistSelectedPortRole, sysPortSecurityTable=sysPortSecurityTable, dot1wPortRoleType=dot1wPortRoleType, atiAclClassifierDstMacMaskLen=atiAclClassifierDstMacMaskLen, dot1sMstContextId=dot1sMstContextId, dot1dDeviceCapabilities=dot1dDeviceCapabilities, sysSnmpTrapManagerEntry=sysSnmpTrapManagerEntry, sysLaPortRestoreMtu=sysLaPortRestoreMtu, dot1sMstiPortInvalidBPDUsRcvd=dot1sMstiPortInvalidBPDUsRcvd, dot1qVlanGlobalsTable=dot1qVlanGlobalsTable, sysSnoopVlanRouterTable=sysSnoopVlanRouterTable, dot1qTpFdbTable=dot1qTpFdbTable, dot1qVlanStaticPortConfigEntry=dot1qVlanStaticPortConfigEntry, ifMainBrgPortType=ifMainBrgPortType, dot1wPortMigrationType=dot1wPortMigrationType, sysDfsMultiFieldClfrId=sysDfsMultiFieldClfrId, sysDscpType06=sysDscpType06, sysDfsClfrId=sysDfsClfrId, dot1dBasePortDelayExceededDiscards=dot1dBasePortDelayExceededDiscards, ifIpTable=ifIpTable, sysRemoteConfigRestoreIpAddr=sysRemoteConfigRestoreIpAddr, sysDscpType50=sysDscpType50, dot1qTp=dot1qTp, dot1sPortRoleTrapNotificationEntry=dot1sPortRoleTrapNotificationEntry, atiAclPortListString=atiAclPortListString, AuthenticMethod=AuthenticMethod, ifIpAddr=ifIpAddr, sysSnmpsnmpCommunityPolicy=sysSnmpsnmpCommunityPolicy, dot1dTpLearnedEntryDiscards=dot1dTpLearnedEntryDiscards, dot1dDevicePriorityGroup=dot1dDevicePriorityGroup, voiceVlanTimeout=voiceVlanTimeout, sysConfigCtrlStatsCollection=sysConfigCtrlStatsCollection, sysConfigRestoreOption=sysConfigRestoreOption, PaeControlledPortStatus=PaeControlledPortStatus, sysSnoopStatsTxGrpQueries=sysSnoopStatsTxGrpQueries, sysSnmpsnmpTrapManagerStatus=sysSnmpsnmpTrapManagerStatus, sysDefaultIpAddrCfgMode=sysDefaultIpAddrCfgMode, dot1qVlanStatus=dot1qVlanStatus, sysDscpType56=sysDscpType56, sysSnoopVlanSnoopStatus=sysSnoopVlanSnoopStatus, dot1sCistRoot=dot1sCistRoot, sysDscpType52=sysDscpType52, dot1sMstiTopChanges=dot1sMstiTopChanges, dot1sGenTrapType=dot1sGenTrapType, sysLaPortActorResetAdminState=sysLaPortActorResetAdminState, atiAclClassifierDstIpMaskLen=atiAclClassifierDstIpMaskLen, l2VoiceVlan=l2VoiceVlan, sysRateCtrlEgressLimitValue=sysRateCtrlEgressLimitValue, dot1sProtocolMigrationTrap=dot1sProtocolMigrationTrap, dot1qVlanStaticEntry=dot1qVlanStaticEntry, sysDfsInProfileActionNewPrio=sysDfsInProfileActionNewPrio, sysPortCtrlEntry=sysPortCtrlEntry, sysDscpType33=sysDscpType33, sysDscpType53=sysDscpType53, sysLaPortChannelDefaultPortIndex=sysLaPortChannelDefaultPortIndex, sysIpAuthMgrIpMask=sysIpAuthMgrIpMask, dot1dTpPortInFrames=dot1dTpPortInFrames, sysLBDInterval=sysLBDInterval)
mibBuilder.exportSymbols("AT-GS950-16-MIB", sysSntpTzDSTForwardOffset=sysSntpTzDSTForwardOffset, dot1dStpHoldTime=dot1dStpHoldTime, dot1qFdbEntry=dot1qFdbEntry, sysPnacASUserConfigTable=sysPnacASUserConfigTable, dot1sPortTrapNotificationEntry=dot1sPortTrapNotificationEntry, dot1dStpExtPortEntry=dot1dStpExtPortEntry, sysSnmpSecurityModel=sysSnmpSecurityModel, sysSnmpGroup=sysSnmpGroup, dot1dTpHCPortInDiscards=dot1dTpHCPortInDiscards, atiAclProfileActionEntry=atiAclProfileActionEntry, dot1sMstiConfigIdSel=dot1sMstiConfigIdSel, sysLaPortAggregateWaitTime=sysLaPortAggregateWaitTime, dhcpSnoopVLANSettingVID=dhcpSnoopVLANSettingVID, sysSysLocation=sysSysLocation, sysLBDCtrlTable=sysLBDCtrlTable, dot1sMstiBridgeRoleSelectionSemState=dot1sMstiBridgeRoleSelectionSemState, dot1dBase=dot1dBase, dot1dStpProtocolSpecification=dot1dStpProtocolSpecification, sysSnoopVlanQuerier=sysSnoopVlanQuerier, sysSnoopVlanFilterEntry=sysSnoopVlanFilterEntry, sysPnacPaeProtocolMode=sysPnacPaeProtocolMode, sysPortCtrlDuplex=sysPortCtrlDuplex, sysConfigCtrlStatus=sysConfigCtrlStatus, sysSshStatus=sysSshStatus, dot1sCistCurrentPortRole=dot1sCistCurrentPortRole, l2Ssl=l2Ssl, dot1qVlan=dot1qVlan, dot1qPortVlanEntry=dot1qPortVlanEntry, dot1sCistBridgePriority=dot1sCistBridgePriority, dot1sCistPortOperP2P=dot1sCistPortOperP2P, dot1sCistPortProtocolMigration=dot1sCistPortProtocolMigration, dot1sCistPortRxConfigBpduCount=dot1sCistPortRxConfigBpduCount, sysDscpType57=sysDscpType57, sysLaPortChannelSelectionPolicy=sysLaPortChannelSelectionPolicy, dot1qVlanGlobalTrace=dot1qVlanGlobalTrace, sysSnoopStatsVlanId=sysSnoopStatsVlanId, sysPnacASUserConfigUserName=sysPnacASUserConfigUserName, InetAddressIPv4=InetAddressIPv4, dot1qVlanTimeMark=dot1qVlanTimeMark, dot1qVlanNumDeletesTable=dot1qVlanNumDeletesTable, dot1qPortIngressFiltering=dot1qPortIngressFiltering, dot1sMstiRegionVersion=dot1sMstiRegionVersion, ifMainRowStatus=ifMainRowStatus, dot1qStaticAllowedIsMember=dot1qStaticAllowedIsMember, dot1dTpPortInOverflowFrames=dot1dTpPortInOverflowFrames, dot1sCistNewRootBridgeCount=dot1sCistNewRootBridgeCount, voiceVlanPriority=voiceVlanPriority, dot1qMaxSupportedVlans=dot1qMaxSupportedVlans, dot1dStaticAddress=dot1dStaticAddress, dot1dGarp=dot1dGarp, dot1dPortGarpEntry=dot1dPortGarpEntry, dot1sCistPortDesignatedBridge=dot1sCistPortDesignatedBridge, voicevlanOUIEntry=voicevlanOUIEntry, sysDfsMeter=sysDfsMeter, sysDscpType25=sysDscpType25, dhcpSnoopBindindDBLeaseTime=dhcpSnoopBindindDBLeaseTime, fsLldpMisConfigPowerMDI=fsLldpMisConfigPowerMDI, sysSwitchDate=sysSwitchDate, fsLldpMisConfigVlanName=fsLldpMisConfigVlanName, sysDfsOutProfileAction=sysDfsOutProfileAction, dot1sPathCostDefaultType=dot1sPathCostDefaultType, l2Ssh=l2Ssh, dot1sCistPortRxTcnBpduCount=dot1sCistPortRxTcnBpduCount, dot1qBase=dot1qBase, dot1qMaxVlanId=dot1qMaxVlanId, dot1wDynamicPathcostCalculation=dot1wDynamicPathcostCalculation, atiAclClassifierSrcIpMaskLen=atiAclClassifierSrcIpMaskLen, sysRmonHwAlarmSupp=sysRmonHwAlarmSupp, dot1sUnMapVlanIndex=dot1sUnMapVlanIndex, sysRestart=sysRestart, sysDscpType05=sysDscpType05, dot1qStaticMulticastAddress=dot1qStaticMulticastAddress, trafficSegMemberList=trafficSegMemberList, dot1sMstiInstanceIndex=dot1sMstiInstanceIndex, dot1sMstiPortInfoSemState=dot1sMstiPortInfoSemState, sysSnoopVlanFilterTable=sysSnoopVlanFilterTable, dot1sMstiPortStateTransitionSemState=dot1sMstiPortStateTransitionSemState, sysSnmpUser=sysSnmpUser, sysRadiusExtServerSharedSecret=sysRadiusExtServerSharedSecret, fsLldpMisConfigMaxFrameSize=fsLldpMisConfigMaxFrameSize, sysIpAuthMgrStatus=sysIpAuthMgrStatus, voicevlanOUITable=voicevlanOUITable, sysLaPortChannelMacSelection=sysLaPortChannelMacSelection, dot1qStatic=dot1qStatic, portBaseVlanEnablePerPort=portBaseVlanEnablePerPort, tabPortBaseVlanCurrentEntry=tabPortBaseVlanCurrentEntry, dhcpSnoopVLANSettingEntry=dhcpSnoopVLANSettingEntry, fslldp=fslldp, sysSnmpaccessGroupIndex=sysSnmpaccessGroupIndex, sysSshTrace=sysSshTrace, sysSnoopQuerierQueryInterval=sysSnoopQuerierQueryInterval, sysDfsInProfileActionDscp=sysDfsInProfileActionDscp, dot1dPortNumTrafficClasses=dot1dPortNumTrafficClasses, dot1wPortTxSmState=dot1wPortTxSmState, dot1wMemAllocFailureCount=dot1wMemAllocFailureCount, sysSnoopInetAddressType=sysSnoopInetAddressType, sysSnoopVlanRouterInetAddressType=sysSnoopVlanRouterInetAddressType, sysSnoopStatus=sysSnoopStatus, dot1sMstiPortDesignatedCost=dot1sMstiPortDesignatedCost, ifAvailableIndex=ifAvailableIndex, voiceVlanMode=voiceVlanMode, dhcpSnoopPortSettingEntry=dhcpSnoopPortSettingEntry, sysSntpTzDSTEndMon=sysSntpTzDSTEndMon, dot1dTpFdbStatus=dot1dTpFdbStatus, dot1wTraps=dot1wTraps, dot1sCistPortTopologyChangeSemState=dot1sCistPortTopologyChangeSemState, sysInitiateUlLogFile=sysInitiateUlLogFile, sysSnoopInstanceConfigEntry=sysSnoopInstanceConfigEntry, fsLldpNotification=fsLldpNotification, sysRmonHwHistorySupp=sysRmonHwHistorySupp, sysDscpType13=sysDscpType13, l2Radius=l2Radius, dot1dBaseType=dot1dBaseType, dot1qTpFdbPort=dot1qTpFdbPort, fsLldpStatsRemTablesUpdates=fsLldpStatsRemTablesUpdates, sysDfsMultiFieldClfrTable=sysDfsMultiFieldClfrTable, sysIpAuthMgrTable=sysIpAuthMgrTable, sysDfsMeterEntry=sysDfsMeterEntry, sysUserAuthMgrTable=sysUserAuthMgrTable, sysSnoopPortPurgeInterval=sysSnoopPortPurgeInterval, dot1sCistPortInvalidTcnBpduRxCount=dot1sCistPortInvalidTcnBpduRxCount, dot1dBaseEntry=dot1dBaseEntry, dot1dTpAgingTime=dot1dTpAgingTime, sysSnoopVlanMcastMacFwdTable=sysSnoopVlanMcastMacFwdTable, dot1wPortTrapIndex=dot1wPortTrapIndex, sysConfigControl=sysConfigControl, dot1dStpTimeSinceTopologyChange=dot1dStpTimeSinceTopologyChange, dot1sCistBridgeForwardDelay=dot1sCistBridgeForwardDelay, dot1sMstTrapsControl=dot1sMstTrapsControl, fsLldpStatistics=fsLldpStatistics, dot1wPortInvalidConfigBpduRxCount=dot1wPortInvalidConfigBpduRxCount, sysDfsMeterTable=sysDfsMeterTable, sysDscpType21=sysDscpType21, sysDscpType02=sysDscpType02, sysDscpType03=sysDscpType03, dot1qStaticUnicastTable=dot1qStaticUnicastTable, l2Pnac=l2Pnac, voicevlanPortControlTable=voicevlanPortControlTable, sysSnoopOperStatus=sysSnoopOperStatus)

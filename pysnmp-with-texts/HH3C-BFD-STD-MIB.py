#
# PySNMP MIB module HH3C-BFD-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-BFD-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetPortNumber, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetPortNumber", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, Integer32, Counter32, MibIdentifier, ObjectIdentity, TimeTicks, Gauge32, ModuleIdentity, iso, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "Integer32", "Counter32", "MibIdentifier", "ObjectIdentity", "TimeTicks", "Gauge32", "ModuleIdentity", "iso", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32")
TextualConvention, TimeStamp, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "DisplayString", "TruthValue")
hh3cBfdMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 72))
hh3cBfdMIB.setRevisions(('2014-01-17 12:00', '2006-05-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cBfdMIB.setRevisionsDescriptions(('Modified for bfd trap.', 'The first version. ',))
if mibBuilder.loadTexts: hh3cBfdMIB.setLastUpdated('201401171200Z')
if mibBuilder.loadTexts: hh3cBfdMIB.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cBfdMIB.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cBfdMIB.setDescription('Bidirectional Forwarding Management Information Base.')
hh3cBfdNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0))
hh3cBfdObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1))
hh3cBfdConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 72, 2))
hh3cBfdGlobalObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 1))
class BfdSessIndexTC(TextualConvention, Unsigned32):
    description = 'An index used to uniquely identify BFD sessions.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class BfdInterval(TextualConvention, Unsigned32):
    description = 'A time interval delay in microseconds, which is used by the BFD.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class BfdDiag(TextualConvention, Integer32):
    description = "The diagnostic code is used by the BFD specifying the local system's reason for the last session state change, and must be initialized to zero(No Diagnostic). The 'noDiagnostic' means the session keeps state up. The 'controlDetectionTimeExpired' indicates the reason the session enters state down from state up is that the control detection time expires. The 'echoFunctionFailed' indicates the reason the session enters state down from state up is that Echo Function fails. The 'neighborSignaledSessionDown' indicates the reason the session enters state down from state up is that neighbor signals session Down. The 'forwardingPlaneReset' indicates the reason the session enters state down from state up is that the Forwarding Plane resets. The 'pathDown' indicates the reason the session enters state down from state up is that the path state is down. The 'concatenatedPathDown' indicates the reason the session enters state down from state up is that the concatenated path state is down. The 'administrativelyDown' indicates the reason the session enters state down from state up is that the session is kept administratively down by entering the AdminDown state. The 'reverseConcatenatedPathDown' indicates the reason the session enters state down from state up is that reverse concatenated path state is down."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("noDiagnostic", 1), ("controlDetectionTimeExpired", 2), ("echoFunctionFailed", 3), ("neighborSignaledSessionDown", 4), ("forwardingPlaneReset", 5), ("pathDown", 6), ("concatenatedPathDown", 7), ("administrativelyDown", 8), ("reverseConcatenatedPathDown", 9))

hh3cBfdVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 1, 1), Unsigned32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdVersionNumber.setReference('BFD Version 1 (draft-ietf-bfd-base-04.txt)')
if mibBuilder.loadTexts: hh3cBfdVersionNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdVersionNumber.setDescription("It indicates the BFD session's current version number.")
hh3cBfdSysInitMode = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cBfdSysInitMode.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSysInitMode.setDescription("A system may take either an active role or a passive role in session initialization. A system taking the active role must send BFD control packets for a particular session, regardless of whether it has received any BFD packets for that session. A system taking the passive role must not begin sending BFD packets for a particular session until it has received a BFD packet for that session, and thus has learned the remote system's discriminator value.")
hh3cBfdSessNotificationsEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cBfdSessNotificationsEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessNotificationsEnable.setDescription('This variable enables the emission of hh3cBfdSessStateUp hh3cBfdSessStateDown and hh3cBfdSessReachLimit notifications if this variable is set to true(1); otherwise these notifications are not emitted.')
hh3cBfdSessNumberLimit = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessNumberLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessNumberLimit.setDescription('This variable is the active session limit of this device.')
hh3cBfdIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2), )
if mibBuilder.loadTexts: hh3cBfdIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfTable.setDescription('This Table describes the BFD interface specific information.')
hh3cBfdIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1), ).setIndexNames((0, "HH3C-BFD-STD-MIB", "hh3cBfdIfIndex"))
if mibBuilder.loadTexts: hh3cBfdIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfEntry.setDescription('This Entry describes the BFD interface specific information.')
hh3cBfdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cBfdIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfIndex.setDescription('This variable contains an index that represents a unique BFD interface on this device.')
hh3cBfdIfDesiredMinTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1, 2), BfdInterval()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cBfdIfDesiredMinTxInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfDesiredMinTxInterval.setDescription('This variable defines the minimum interval, in microseconds, that the interface would like to use when transmitting BFD Control packets.')
hh3cBfdIfDesiredMinRxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1, 3), BfdInterval()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cBfdIfDesiredMinRxInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfDesiredMinRxInterval.setDescription('This variable defines the minimum interval, in, microseconds, between received BFD Control packets the local system is capable of supporting.')
hh3cBfdIfDetectMult = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cBfdIfDetectMult.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfDetectMult.setDescription('The desired detect time multiplier for BFD control packets. The negotiated control packet transmission interval, multiplied by this variable, will be the detection time for this session (as seen by the remote system.) The variable must be a nonzero integer.')
hh3cBfdIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("md5", 3), ("mmd5", 4), ("sha1", 5), ("msha1", 6))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdIfAuthType.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdIfAuthType.setDescription("The Authentication Type used for this interface. This field is valid only when the Authentication Present bit is set. The 'none' indicates the session doesn't support authentication. The 'simple' indicates the session supports simple password authentication. The 'md5' indicates the session supports Keyed MD5 authentication. The 'mmd5' indicates the session supports Meticulous Keyed MD5 authentication. The 'sha1' indicates the session supports Keyed SHA1 authentication. The 'msha1' indicates the session supports Meticulous Keyed SHA1 authentication.")
hh3cBfdSessTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3), )
if mibBuilder.loadTexts: hh3cBfdSessTable.setReference('BFD Version 1 (draft-ietf-bfd-base-04.txt)')
if mibBuilder.loadTexts: hh3cBfdSessTable.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessTable.setDescription('This table describes the BFD sessions.')
hh3cBfdSessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1), ).setIndexNames((0, "HH3C-BFD-STD-MIB", "hh3cBfdSessIfIndex"), (0, "HH3C-BFD-STD-MIB", "hh3cBfdSessIndex"))
if mibBuilder.loadTexts: hh3cBfdSessEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessEntry.setDescription('This Entry describes the BFD sessions.')
hh3cBfdSessIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cBfdSessIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessIfIndex.setDescription("This variable contains an interface's index under which the BFD session runs.")
hh3cBfdSessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 2), BfdSessIndexTC()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cBfdSessIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessIndex.setDescription('This variable contains an index which represents a unique BFD session on this device.')
hh3cBfdSessAppSupportId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 3), Bits().clone(namedValues=NamedValues(("none", 0), ("ospf", 1), ("isis", 2), ("bgp", 3), ("mpls", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessAppSupportId.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessAppSupportId.setDescription('This variable contains an ID used to indicate a local application which owns or maintains this BFD session. Note, a BFD session can support several route protocols. This is a bit-map of possible conditions. The corresponding bit positions are: |0 |none | |1 |ospf | |2 |isis | |3 |bgp | |4 |mpls | ')
hh3cBfdSessLocalDiscr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessLocalDiscr.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessLocalDiscr.setDescription('This variable defines the local discriminator for this BFD session, used to uniquely identify it.')
hh3cBfdSessRemoteDiscr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessRemoteDiscr.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessRemoteDiscr.setDescription('This variable defines the session discriminator chosen by the remote system for this BFD session.')
hh3cBfdSessDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 6), InetPortNumber().clone(3784)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessDstPort.setReference('BFD Version 1 (draft-ietf-bfd-base-04.txt)')
if mibBuilder.loadTexts: hh3cBfdSessDstPort.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessDstPort.setDescription('The UDP Port for BFD. The default value is the well-known value for this port.')
hh3cBfdSessOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asynchModeWOEchoFun", 1), ("demandModeWOEchoFunction", 2), ("asyncModeWEchoFun", 3), ("demandModeWEchoFunction", 4))).clone('asynchModeWOEchoFun')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessOperMode.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessOperMode.setDescription("This variable defines current operating mode that BFD session is running in. The primary mode which the BFD session runs in is known as Asynchronous mode. In this mode, the systems periodically send BFD Control packets to one another, and if a number of those packets in a row are not received by the other system, the session is declared to be down. The second mode is known as Demand mode. In this mode, it is assumed that each system has an independent way of verifying that it has connectivity to the other system. Once a BFD session is established, the systems stop sending BFD Control packets, except when either system feels the need to verify connectivity explicitly, in which case a short sequence of BFD Control packets is sent, and then the protocol quiesces. An adjunct to both modes is the Echo function. When the Echo function is active, a stream of BFD Echo packets is transmitted in such a way as to have the other system loop them back through its forwarding path. If a number of packets of the echoed data stream are not received, the session is declared to be down. The Echo function may be used with either Asynchronous or Demand modes. The 'asynchModeWOEchoFun' indicates this BFD session operates in the Asynchronous mode, and doesn't support the Echo Function. The 'demandModeWOEchoFunction' indicates this BFD session operates in the Demand mode, and doesn't support the Echo Function. The 'asyncModeWEchoFun' indicates this BFD session operates in the Asynchronous mode, and also supports the Echo Function. The 'demandModeWEchoFunction' indicates this BFD session operates in the Demand mode, and also supports the Echo Function.")
hh3cBfdSessAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessAddrType.setDescription('This object defines IP address type of the interface associated with this BFD session. Only values unknown(0), ipv4(1) or ipv6(2) have to be supported. A value of unknown(0) is allowed only when the outgoing interface is of type point-to-point, or when the BFD session is not associated with a specific interface. If any other unsupported values are attempted in a set operation, the agent must return an inconsistentValue error.')
hh3cBfdSessLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessLocalAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessLocalAddr.setDescription('This variable defines IP address of the local interface from which the BFD packets is transmitted. It can also be used to enabled BFD on a specific interface. The value is set to zero when BFD session is not associated with a specific interface.')
hh3cBfdSessRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 10), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessRemoteAddr.setDescription('This variable defines IP address of the remote interface from which the BFD packets is transmitted. It can also be used to enabled BFD on a specific interface. The value is set to zero when BFD session is not associated with a specific interface.')
hh3cBfdSessLocalDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 11), BfdDiag().clone('noDiagnostic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessLocalDiag.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessLocalDiag.setDescription('The BFD diagnostic code for the BFD session was down with the neighbor. If no such event happens this object contains a zero value.')
hh3cBfdSessState = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("adminDown", 0), ("down", 1), ("init", 2), ("up", 3))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessState.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessState.setDescription('The state of the running BFD session. There are three states through which a session normally proceeds, two for establishing a session (Init and Up) and one for tearing down a session (Down.) This allows a three-way handshake for both session establishment and session teardown (assuring that both systems are aware of all session state changes.) A fourth state (AdminDown) exists so that a session can be administratively put down indefinitely. The Down state means that the session is down (or has just been created.) A session remains in Down state until the remote system indicates that it agrees that the session is down by sending a BFD Control packet with the State field set to anything other than Up. If that packet signals Down state, the session advances to Init state; if that packet signals Init state, the session advances to Up state. Init state means that the remote system is 0communicating, and the local system desires to bring the session up, but the remote system does not yet realize it. A session will remain in Init state until either a BFD Control Packet is received that is signaling Init or Up state (in which case the session advances to Up state) or until the detection time expires, meaning that communication with the remote system has been lost (in which case the session advances to Down state.) Up state means that the BFD session has successfully been established, and implies that connectivity between the systems is working. The session will remain in the Up state until either connectivity fails, or the session is taken down administratively. If either the remote system signals Down state, or the detection time expires, the session advances to Down state. AdminDown state means that the session is being held administratively down. This causes the remote system to enter Down state, and remain there until the local system exits AdminDown state.')
hh3cBfdSessControlPlanIndepFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 13), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessControlPlanIndepFlag.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessControlPlanIndepFlag.setDescription('This variable indicates whether the local system can continue to work while the control plane is out of work. Specifically, it is set to true(1) if the local system is independent of the control plane. Otherwise, the value is set to false(0)')
hh3cBfdSessAuthFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 14), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessAuthFlag.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessAuthFlag.setDescription('This variable indicates that the local system wants to use Authentication. Specifically, it is set to true(1) if the local system wishes the session to be authenticated or false(0) if not.')
hh3cBfdSessDemandModeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 3, 1, 15), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessDemandModeFlag.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessDemandModeFlag.setDescription('This variable indicates that the local system wants to use Demand mode. Specifically, it is set to true(1) if the local system wishes to use Demand mode or false(0) if not')
hh3cBfdSessStatTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4), )
if mibBuilder.loadTexts: hh3cBfdSessStatTable.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatTable.setDescription('The table defines BFD session state.')
hh3cBfdSessStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1), )
hh3cBfdSessEntry.registerAugmentions(("HH3C-BFD-STD-MIB", "hh3cBfdSessStatEntry"))
hh3cBfdSessStatEntry.setIndexNames(*hh3cBfdSessEntry.getIndexNames())
if mibBuilder.loadTexts: hh3cBfdSessStatEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatEntry.setDescription('An entry in this table is created by a BFD-enabled node for every BFD Session. It defines BFD session statistics.')
hh3cBfdSessStatPktInHC = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessStatPktInHC.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatPktInHC.setDescription('The total number of BFD messages received by this BFD session.')
hh3cBfdSessStatPktOutHC = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessStatPktOutHC.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatPktOutHC.setDescription('The total number of BFD messages sent by this BFD session.')
hh3cBfdSessStatDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessStatDownCount.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatDownCount.setDescription('The number of times this session has gone into the Down state since the router last rebooted.')
hh3cBfdSessStatPktDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessStatPktDiscard.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatPktDiscard.setDescription('The number of packets the local system has discarded since the router last rebooted.')
hh3cBfdSessStatPktLost = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessStatPktLost.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStatPktLost.setDescription('The number of packets the local system has failed to transmit since the router last rebooted.')
hh3cBfdSessPerfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 5), )
if mibBuilder.loadTexts: hh3cBfdSessPerfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessPerfTable.setDescription('The table defines BFD session performance.')
hh3cBfdSessPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 5, 1), )
hh3cBfdSessEntry.registerAugmentions(("HH3C-BFD-STD-MIB", "hh3cBfdSessPerfEntry"))
hh3cBfdSessPerfEntry.setIndexNames(*hh3cBfdSessEntry.getIndexNames())
if mibBuilder.loadTexts: hh3cBfdSessPerfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessPerfEntry.setDescription('An entry in this table is created by a BFD-enabled node for every BFD session. It defines BFD Session performance.')
hh3cBfdSessPerfCreatTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 5, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessPerfCreatTime.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessPerfCreatTime.setDescription('The value of sysUpTime when the session was created. If no such create event exists this object contains a zero value.')
hh3cBfdSessPerfLastUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 5, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessPerfLastUpTime.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessPerfLastUpTime.setDescription('The value of sysUpTime when the last time communication was lost. If no such up event exists this variable contains a zero value.')
hh3cBfdSessPerfLastDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 72, 1, 5, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBfdSessPerfLastDownTime.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessPerfLastDownTime.setDescription('The value of sysUpTime when the last time communication was lost with the neighbor. If no such event exist this variable contains a zero value.')
hh3cBfdSessStateChange = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0, 1)).setObjects(("HH3C-BFD-STD-MIB", "hh3cBfdSessIfIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessState"))
if mibBuilder.loadTexts: hh3cBfdSessStateChange.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStateChange.setDescription("A notification sent when a session changes state, entering state up or entering state down. The session will enter state up finishing three times handshakes , and will enter state down when the communication path is out of work. When the hh3cBfdSessState's value is state up, the session enters state up, and the session enters state down when the hh3cBfdSessState's value is state down. The hh3cBfdSessIfIndex contains an interface's index under which the BFD session runs. The hh3cBfdSessIndex contains an index which represents a unique BFD session on this device. The hh3cBfdSessState is the state of the running BFD session. ")
hh3cBfdSessAuthFail = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0, 2)).setObjects(("HH3C-BFD-STD-MIB", "hh3cBfdIfIndex"))
if mibBuilder.loadTexts: hh3cBfdSessAuthFail.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessAuthFail.setDescription('A notification sent when receiving a session with an authentication fail. The hh3cBfdIfIndex is an index which represents a unique BFD interface on this device. ')
hh3cBfdSessStateUp = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0, 3)).setObjects(("HH3C-BFD-STD-MIB", "hh3cBfdSessIfIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessState"))
if mibBuilder.loadTexts: hh3cBfdSessStateUp.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStateUp.setDescription("A notification sent when a session changes state to up. The session will enter state up finishing three times handshakes. The hh3cBfdSessIfIndex contains an interface's index under which the BFD session runs. The hh3cBfdSessIndex contains an index which represents a unique BFD session on this device. The hh3cBfdSessState is the state of the running BFD session.")
hh3cBfdSessStateDown = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0, 4)).setObjects(("HH3C-BFD-STD-MIB", "hh3cBfdSessIfIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessIndex"), ("HH3C-BFD-STD-MIB", "hh3cBfdSessState"))
if mibBuilder.loadTexts: hh3cBfdSessStateDown.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessStateDown.setDescription("A notification sent when a session changes state to down. The session will enter state down when the communication path is out of work. The hh3cBfdSessIfIndex contains an interface's index under which the BFD session runs. The hh3cBfdSessIndex contains an index which represents a unique BFD session on this device. The hh3cBfdSessState is the state of the running BFD session.")
hh3cBfdSessReachLimit = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 72, 0, 5)).setObjects(("HH3C-BFD-STD-MIB", "hh3cBfdSessNumberLimit"))
if mibBuilder.loadTexts: hh3cBfdSessReachLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cBfdSessReachLimit.setDescription("A notification would be sent when the number of active BFD sessions reached this device's upper limit and no more session could be activated. The hh3cBfdSessNumberLimit is the active session limit of this device.")
mibBuilder.exportSymbols("HH3C-BFD-STD-MIB", hh3cBfdConformance=hh3cBfdConformance, hh3cBfdSessAppSupportId=hh3cBfdSessAppSupportId, hh3cBfdSessRemoteDiscr=hh3cBfdSessRemoteDiscr, hh3cBfdSessPerfEntry=hh3cBfdSessPerfEntry, hh3cBfdSessStateChange=hh3cBfdSessStateChange, hh3cBfdMIB=hh3cBfdMIB, hh3cBfdSessPerfTable=hh3cBfdSessPerfTable, hh3cBfdSessTable=hh3cBfdSessTable, hh3cBfdGlobalObjects=hh3cBfdGlobalObjects, hh3cBfdSessControlPlanIndepFlag=hh3cBfdSessControlPlanIndepFlag, hh3cBfdSessAuthFail=hh3cBfdSessAuthFail, hh3cBfdSessEntry=hh3cBfdSessEntry, hh3cBfdIfTable=hh3cBfdIfTable, hh3cBfdSessReachLimit=hh3cBfdSessReachLimit, hh3cBfdSessAddrType=hh3cBfdSessAddrType, hh3cBfdSessStatPktDiscard=hh3cBfdSessStatPktDiscard, hh3cBfdSessStatPktInHC=hh3cBfdSessStatPktInHC, BfdDiag=BfdDiag, hh3cBfdSessDemandModeFlag=hh3cBfdSessDemandModeFlag, hh3cBfdSessNumberLimit=hh3cBfdSessNumberLimit, hh3cBfdIfDesiredMinTxInterval=hh3cBfdIfDesiredMinTxInterval, hh3cBfdIfDesiredMinRxInterval=hh3cBfdIfDesiredMinRxInterval, hh3cBfdSessOperMode=hh3cBfdSessOperMode, hh3cBfdSessLocalDiag=hh3cBfdSessLocalDiag, hh3cBfdSessAuthFlag=hh3cBfdSessAuthFlag, hh3cBfdSessStatDownCount=hh3cBfdSessStatDownCount, hh3cBfdSessState=hh3cBfdSessState, hh3cBfdSessLocalAddr=hh3cBfdSessLocalAddr, hh3cBfdSessPerfLastDownTime=hh3cBfdSessPerfLastDownTime, hh3cBfdVersionNumber=hh3cBfdVersionNumber, hh3cBfdNotifications=hh3cBfdNotifications, hh3cBfdSessPerfCreatTime=hh3cBfdSessPerfCreatTime, hh3cBfdIfAuthType=hh3cBfdIfAuthType, hh3cBfdSessDstPort=hh3cBfdSessDstPort, hh3cBfdSessIfIndex=hh3cBfdSessIfIndex, PYSNMP_MODULE_ID=hh3cBfdMIB, hh3cBfdIfDetectMult=hh3cBfdIfDetectMult, hh3cBfdIfEntry=hh3cBfdIfEntry, BfdSessIndexTC=BfdSessIndexTC, hh3cBfdSessStatEntry=hh3cBfdSessStatEntry, BfdInterval=BfdInterval, hh3cBfdSessNotificationsEnable=hh3cBfdSessNotificationsEnable, hh3cBfdObjects=hh3cBfdObjects, hh3cBfdSessIndex=hh3cBfdSessIndex, hh3cBfdSessStatPktOutHC=hh3cBfdSessStatPktOutHC, hh3cBfdSessPerfLastUpTime=hh3cBfdSessPerfLastUpTime, hh3cBfdIfIndex=hh3cBfdIfIndex, hh3cBfdSessStatPktLost=hh3cBfdSessStatPktLost, hh3cBfdSessStateUp=hh3cBfdSessStateUp, hh3cBfdSessRemoteAddr=hh3cBfdSessRemoteAddr, hh3cBfdSessStateDown=hh3cBfdSessStateDown, hh3cBfdSysInitMode=hh3cBfdSysInitMode, hh3cBfdSessStatTable=hh3cBfdSessStatTable, hh3cBfdSessLocalDiscr=hh3cBfdSessLocalDiscr)

#
# PySNMP MIB module JUNIPER-COLLECTOR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-COLLECTOR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
CounterBasedGauge64, = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
ifDescr, ifIndex = mibBuilder.importSymbols("IF-MIB", "ifDescr", "ifIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
jnxMibs, jnxCollectorNotifications = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs", "jnxCollectorNotifications")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, TimeTicks, iso, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Gauge32, Integer32, ModuleIdentity, IpAddress, Counter32, MibIdentifier, NotificationType, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "iso", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Gauge32", "Integer32", "ModuleIdentity", "IpAddress", "Counter32", "MibIdentifier", "NotificationType", "ObjectIdentity")
TextualConvention, DateAndTime, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DateAndTime", "DisplayString")
jnxCollectorMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 28))
jnxCollectorMIB.setRevisions(('2003-11-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxCollectorMIB.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: jnxCollectorMIB.setLastUpdated('200311130000Z')
if mibBuilder.loadTexts: jnxCollectorMIB.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxCollectorMIB.setContactInfo(' Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxCollectorMIB.setDescription('Provides data about each of the Collector PICs on a router.')
class JnxCollPicStateDef(TextualConvention, Bits):
    description = 'Identifies specific error conditions that may exist on a Collector PIC.'
    status = 'current'
    namedValues = NamedValues(("jnxCollStateSoftOverload", 0), ("jnxCollStateHardOverload", 1), ("jnxCollStateMemoryUnavail", 2))

jnxCollGlobalStats = ObjectIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 28, 1))
if mibBuilder.loadTexts: jnxCollGlobalStats.setStatus('current')
if mibBuilder.loadTexts: jnxCollGlobalStats.setDescription('Global, router-wide collector stats.')
jnxCollGlobalCreatedFiles = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollGlobalCreatedFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollGlobalCreatedFiles.setDescription('The total number of file created by all the collector pics on the router since the last time the router was reset.')
jnxCollGlobalOpenFiles = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollGlobalOpenFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollGlobalOpenFiles.setDescription('The total number of open collector files currently present on the router.')
jnxCollPicIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2), )
if mibBuilder.loadTexts: jnxCollPicIfTable.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfTable.setDescription('Data about each collector pic currently present on the router.')
jnxCollPicIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxCollPicIfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfEntry.setDescription('Each entry provides information about a single Collector PIC. Each Collector PIC contains a single interface and is identified by its ifIndex.')
jnxCollPicIfCreatedFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfCreatedFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfCreatedFiles.setDescription('The total number of files created by this Collector PIC since the last time the PIC was reset.')
jnxCollPicIfCreatedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfCreatedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfCreatedFileRate.setDescription('The number of files created per second, measured over the current 10 second interval.')
jnxCollPicIfPeakCreatedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakCreatedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakCreatedFileRate.setDescription('The peak number of files created per second.')
jnxCollPicIfExportedFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfExportedFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfExportedFiles.setDescription('The total number of files exported by this Collector PIC.')
jnxCollPicIfExportedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfExportedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfExportedFileRate.setDescription('The number of files exported per second, measured over the current 10 second interval.')
jnxCollPicIfPeakExportedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakExportedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakExportedFileRate.setDescription('The peak number of files exported per second.')
jnxCollPicIfDestroyedFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfDestroyedFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfDestroyedFiles.setDescription('The total number of files destroyed by this Collector PIC.')
jnxCollPicIfDestroyedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfDestroyedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfDestroyedFileRate.setDescription('The number of files destroyed per second, as measured over the current 10 second interval.')
jnxCollPicIfPeakDestroyedFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakDestroyedFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakDestroyedFileRate.setDescription('The peak number of files destroyed per second.')
jnxCollPicIfProcRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfProcRecords.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfProcRecords.setDescription('The total number of flow records processed by this Collector PIC.')
jnxCollPicIfProcRecordsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfProcRecordsRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfProcRecordsRate.setDescription('The number of flow records processed per seconds, measured during the current 10 second interval.')
jnxCollPicIfPeakProcRecordsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakProcRecordsRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakProcRecordsRate.setDescription('The peak number of flow records processed.')
jnxCollPicIfMemoryUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 13), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfMemoryUsed.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfMemoryUsed.setDescription('The amount of memory used, in bytes, by this Collector PIC.')
jnxCollPicIfMemoryFree = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 14), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfMemoryFree.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfMemoryFree.setDescription('The amount of memory free, in bytes, on this Collector PIC.')
jnxCollPicIfFtpBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfFtpBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfFtpBytes.setDescription('The total number of bytes transferred via FTP by this Collector PIC.')
jnxCollPicIfFtpByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfFtpByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfFtpByteRate.setDescription('The number of bytes per second transfered via FTP measured during the current 10 second interval.')
jnxCollPicIfPeakFtpByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakFtpByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakFtpByteRate.setDescription('The peak number of bytes per second transferred via FTP.')
jnxCollPicIfFtpFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfFtpFiles.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfFtpFiles.setDescription('The total number of files transferred via FTP by this Collector PIC.')
jnxCollPicIfFtpFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfFtpFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfFtpFileRate.setDescription('The number of files per second transferred via FTP.')
jnxCollPicIfPeakFtpFileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfPeakFtpFileRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfPeakFtpFileRate.setDescription('The peak number of files per second transferred via FTP.')
jnxCollPicIfFtpFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 21), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfFtpFailures.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfFtpFailures.setDescription('The total number of FTP transfer failures on this Collector PIC.')
jnxCollPicIfCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 22), JnxCollPicStateDef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfCurrentState.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfCurrentState.setDescription('The current state of various error conditions on this Collector PIC.')
jnxCollPicIfLastStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 23), JnxCollPicStateDef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfLastStateChange.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfLastStateChange.setDescription('Identifies the error condition that last changed state.')
jnxCollPicIfStateChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfStateChangeTime.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfStateChangeTime.setDescription('The value of sysUpTime when the management subsystem last learned of a change to the value of jnxCollPicIfCurrentState for this Collector PIC.')
jnxCollPicIfStateChangeDate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 25), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfStateChangeDate.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfStateChangeDate.setDescription('The system date and time when the management subsystem last learned of a change to the value of jnxCollPicIfCurrentState for this Collector PIC.')
jnxCollPicIfStateChangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("set", 2), ("cleared", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollPicIfStateChangeType.setStatus('current')
if mibBuilder.loadTexts: jnxCollPicIfStateChangeType.setDescription('This indicates whether the last state change set a new error condition or cleared an existing one.')
jnxCollFileTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3), )
if mibBuilder.loadTexts: jnxCollFileTable.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileTable.setDescription('Data about each collector file currently present on the router.')
jnxCollFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "JUNIPER-COLLECTOR-MIB", "jnxCollFileName"))
if mibBuilder.loadTexts: jnxCollFileEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileEntry.setDescription('Each entry provides information about a single file currently open on this Collector PIC. Each Collector PIC File is identified by the ifIndex associated with the Collector PIC and the name of the file.')
jnxCollFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 115)))
if mibBuilder.loadTexts: jnxCollFileName.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileName.setDescription('The name of a Collector File on this Collector PIC.')
jnxCollFileFname = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileFname.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileFname.setDescription("The name of a Collector File on this Collector PIC. This object is included for those NM applications that can't parse the file name from the instance portion of the OIDs and provides the value of jnxCollFileName explicitly.")
jnxCollFileRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileRecords.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileRecords.setDescription('The number of flow records in this file.')
jnxCollFileRecordRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileRecordRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileRecordRate.setDescription('The number of flow records per second added to this file, measured during the current 10 second interval.')
jnxCollFilePeakRecordRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFilePeakRecordRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFilePeakRecordRate.setDescription('The peak number of flow records per second added to this file.')
jnxCollFileUncompBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 6), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileUncompBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileUncompBytes.setDescription('The number of uncompressed bytes in this file.')
jnxCollFileUncompByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileUncompByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileUncompByteRate.setDescription('The number of uncompressed bytes per second added to this file.')
jnxCollFilePeakUncompByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFilePeakUncompByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFilePeakUncompByteRate.setDescription('The peak number of uncompressed bytes per second added to this file.')
jnxCollFileCompBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileCompBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileCompBytes.setDescription('The number of compressed bytes in this file.')
jnxCollFileCompByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileCompByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileCompByteRate.setDescription('The number of compressed bytes per second added to this file, measured during the current 10 second interval.')
jnxCollFilePeakCompByteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFilePeakCompByteRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollFilePeakCompByteRate.setDescription('The peak number of compressed bytes per second added to this file.')
jnxCollFileBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileBlocks.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileBlocks.setDescription('The number of blocks in this file.')
jnxCollFileCompBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileCompBlocks.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileCompBlocks.setDescription('The number of compressed blocks in this file.')
jnxCollFileTransferAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileTransferAttempts.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileTransferAttempts.setDescription('The number of FTP transfer attempts for this file.')
jnxCollFileState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 28, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("wait", 3), ("export1", 4), ("export2", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCollFileState.setStatus('current')
if mibBuilder.loadTexts: jnxCollFileState.setDescription('The current state of this file.')
jnxCollNotifyVars = ObjectIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4))
if mibBuilder.loadTexts: jnxCollNotifyVars.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyVars.setDescription('Notification object definitions.')
jnxCollNotifyUrl = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 1), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyUrl.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyUrl.setDescription('The URL associated with a file transfer destination.')
jnxCollNotifyInetType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 2), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyInetType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyInetType.setDescription('Used with jnxCollNotifyInetAddress to identify a specific file transfer destination.')
jnxCollNotifyInetAddress = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 3), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyInetAddress.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyInetAddress.setDescription('Used with jnxCollNotifyInetType to identify a specific file transfer destination.')
jnxCollNotifyError = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 4), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyError.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyError.setDescription('Description of error encountered when trying to transfer a file.')
jnxCollNotifyFile = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 5), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFile.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFile.setDescription('Identifies a specific file for notifications that refer to a file.')
jnxCollNotifyFtpResultCode = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 6), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFtpResultCode.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFtpResultCode.setDescription('Provides the FTP result code for file transfer notifications.')
jnxCollNotifyFtpErrorText = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 7), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFtpErrorText.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFtpErrorText.setDescription('Provides the FTP error text for file transfer notifications.')
jnxCollNotifyMemUtil = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 8), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyMemUtil.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyMemUtil.setDescription('Provides the current memory utilization for pic overload notifications.')
jnxCollNotifyMemFree = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 9), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyMemFree.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyMemFree.setDescription('Provides the current amount of free memory for pic overload notifications.')
jnxCollNotifyMemThresh = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 10), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyMemThresh.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyMemThresh.setDescription('Provides the current memory threshold used for determining memory unavailable conditions.')
jnxCollNotifyNewRecordRate = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 11), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyNewRecordRate.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyNewRecordRate.setDescription('Provides the current number of new records per second created on this Collector PIC.')
jnxCollNotifyOverloadType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("softOverload", 1), ("hardOverload", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyOverloadType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyOverloadType.setDescription('Identifies a specific type of flow overload condition on this Collector PIC.')
jnxCollNotifyDate = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 13), DateAndTime()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyDate.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyDate.setDescription('Provides the current system date and time.')
jnxCollNotifyFromFtpServerInetType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 14), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerInetType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerInetType.setDescription('Used with jnxCollNotifyFromFtpServerInetAddress to identify a specific FTP server address.')
jnxCollNotifyFromFtpServerInetAddress = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 15), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerInetAddress.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerInetAddress.setDescription('The FTP server address from which the switchover occurs.')
jnxCollNotifyFromFtpServerType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyFromFtpServerType.setDescription('The FTP server Type from which the switchover occurs.')
jnxCollNotifyToFtpServerInetType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 17), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerInetType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerInetType.setDescription('Used with jnxCollNotifyToFtpServerInetAddress to identify a specific FTP server address.')
jnxCollNotifyToFtpServerInetAddress = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 18), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerInetAddress.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerInetAddress.setDescription('The FTP server address to which the switchover occurs.')
jnxCollNotifyToFtpServerType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerType.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyToFtpServerType.setDescription('The FTP server Type to which the switchover occurs.')
jnxCollNotifyInitiatedBy = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 28, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cli", 1), ("automatic", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxCollNotifyInitiatedBy.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotifyInitiatedBy.setDescription('Identify what initiates the FTP switchover.')
jnxCollNotificationPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0))
if mibBuilder.loadTexts: jnxCollNotificationPrefix.setStatus('current')
if mibBuilder.loadTexts: jnxCollNotificationPrefix.setDescription('All collector notifications are registered under this branch.')
jnxCollUnavailableDest = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 1)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyUrl"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetAddress"))
if mibBuilder.loadTexts: jnxCollUnavailableDest.setStatus('current')
if mibBuilder.loadTexts: jnxCollUnavailableDest.setDescription('Notification of an unavailable destination failure encountered while transferring a collector file.')
jnxCollUnavailableDestCleared = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 2)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyUrl"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetAddress"))
if mibBuilder.loadTexts: jnxCollUnavailableDestCleared.setStatus('current')
if mibBuilder.loadTexts: jnxCollUnavailableDestCleared.setDescription('This indicates a previous unavailable destination failure has been resolved.')
jnxCollUnsuccessfulTransfer = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 3)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFile"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyUrl"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInetAddress"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyError"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFtpResultCode"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFtpErrorText"))
if mibBuilder.loadTexts: jnxCollUnsuccessfulTransfer.setStatus('current')
if mibBuilder.loadTexts: jnxCollUnsuccessfulTransfer.setDescription('This indicates an error was encountered while attempting a file transfer.')
jnxCollFlowOverload = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 4)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfStateChangeDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyOverloadType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyNewRecordRate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfCreatedFiles"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfDestroyedFiles"))
if mibBuilder.loadTexts: jnxCollFlowOverload.setStatus('current')
if mibBuilder.loadTexts: jnxCollFlowOverload.setDescription('This indicates a soft or hard flow overload condition has been triggered.')
jnxCollFlowOverloadCleared = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 5)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfStateChangeDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyOverloadType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyNewRecordRate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfCreatedFiles"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfDestroyedFiles"))
if mibBuilder.loadTexts: jnxCollFlowOverloadCleared.setStatus('current')
if mibBuilder.loadTexts: jnxCollFlowOverloadCleared.setDescription('This indicates a soft or hard flow overload condition has been cleared.')
jnxCollMemoryUnavailable = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 6)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfStateChangeDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemThresh"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemUtil"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemFree"))
if mibBuilder.loadTexts: jnxCollMemoryUnavailable.setStatus('current')
if mibBuilder.loadTexts: jnxCollMemoryUnavailable.setDescription('This indicates a memory unavailable condition has been triggered.')
jnxCollMemoryAvailable = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 7)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollPicIfStateChangeDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemThresh"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemUtil"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyMemFree"))
if mibBuilder.loadTexts: jnxCollMemoryAvailable.setStatus('current')
if mibBuilder.loadTexts: jnxCollMemoryAvailable.setDescription('This indicates a memory unavailable condition has been cleared.')
jnxCollFtpSwitchover = NotificationType((1, 3, 6, 1, 4, 1, 2636, 4, 8, 0, 8)).setObjects(("IF-MIB", "ifDescr"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyDate"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFromFtpServerInetType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFromFtpServerInetAddress"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyFromFtpServerType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyToFtpServerInetType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyToFtpServerInetAddress"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyToFtpServerType"), ("JUNIPER-COLLECTOR-MIB", "jnxCollNotifyInitiatedBy"))
if mibBuilder.loadTexts: jnxCollFtpSwitchover.setStatus('current')
if mibBuilder.loadTexts: jnxCollFtpSwitchover.setDescription('This indicates an FTP server switchover has occurred.')
mibBuilder.exportSymbols("JUNIPER-COLLECTOR-MIB", jnxCollNotifyMemUtil=jnxCollNotifyMemUtil, jnxCollFileUncompByteRate=jnxCollFileUncompByteRate, jnxCollPicIfFtpBytes=jnxCollPicIfFtpBytes, jnxCollPicIfEntry=jnxCollPicIfEntry, jnxCollPicIfPeakDestroyedFileRate=jnxCollPicIfPeakDestroyedFileRate, jnxCollPicIfStateChangeDate=jnxCollPicIfStateChangeDate, jnxCollPicIfLastStateChange=jnxCollPicIfLastStateChange, jnxCollPicIfExportedFileRate=jnxCollPicIfExportedFileRate, jnxCollFilePeakCompByteRate=jnxCollFilePeakCompByteRate, jnxCollNotificationPrefix=jnxCollNotificationPrefix, JnxCollPicStateDef=JnxCollPicStateDef, jnxCollUnsuccessfulTransfer=jnxCollUnsuccessfulTransfer, jnxCollFileRecordRate=jnxCollFileRecordRate, jnxCollNotifyInetType=jnxCollNotifyInetType, jnxCollNotifyFile=jnxCollNotifyFile, jnxCollGlobalCreatedFiles=jnxCollGlobalCreatedFiles, PYSNMP_MODULE_ID=jnxCollectorMIB, jnxCollFileState=jnxCollFileState, jnxCollMemoryUnavailable=jnxCollMemoryUnavailable, jnxCollNotifyToFtpServerInetAddress=jnxCollNotifyToFtpServerInetAddress, jnxCollNotifyFtpErrorText=jnxCollNotifyFtpErrorText, jnxCollPicIfPeakProcRecordsRate=jnxCollPicIfPeakProcRecordsRate, jnxCollNotifyInetAddress=jnxCollNotifyInetAddress, jnxCollPicIfMemoryUsed=jnxCollPicIfMemoryUsed, jnxCollFileEntry=jnxCollFileEntry, jnxCollFileBlocks=jnxCollFileBlocks, jnxCollPicIfFtpByteRate=jnxCollPicIfFtpByteRate, jnxCollFileCompByteRate=jnxCollFileCompByteRate, jnxCollFileFname=jnxCollFileFname, jnxCollNotifyMemThresh=jnxCollNotifyMemThresh, jnxCollPicIfPeakCreatedFileRate=jnxCollPicIfPeakCreatedFileRate, jnxCollNotifyFromFtpServerInetType=jnxCollNotifyFromFtpServerInetType, jnxCollPicIfProcRecordsRate=jnxCollPicIfProcRecordsRate, jnxCollPicIfPeakExportedFileRate=jnxCollPicIfPeakExportedFileRate, jnxCollPicIfDestroyedFileRate=jnxCollPicIfDestroyedFileRate, jnxCollFilePeakUncompByteRate=jnxCollFilePeakUncompByteRate, jnxCollNotifyFromFtpServerInetAddress=jnxCollNotifyFromFtpServerInetAddress, jnxCollFilePeakRecordRate=jnxCollFilePeakRecordRate, jnxCollUnavailableDestCleared=jnxCollUnavailableDestCleared, jnxCollFileCompBlocks=jnxCollFileCompBlocks, jnxCollNotifyFtpResultCode=jnxCollNotifyFtpResultCode, jnxCollPicIfMemoryFree=jnxCollPicIfMemoryFree, jnxCollFileTransferAttempts=jnxCollFileTransferAttempts, jnxCollPicIfStateChangeType=jnxCollPicIfStateChangeType, jnxCollPicIfCreatedFiles=jnxCollPicIfCreatedFiles, jnxCollPicIfFtpFileRate=jnxCollPicIfFtpFileRate, jnxCollPicIfPeakFtpFileRate=jnxCollPicIfPeakFtpFileRate, jnxCollNotifyDate=jnxCollNotifyDate, jnxCollPicIfStateChangeTime=jnxCollPicIfStateChangeTime, jnxCollectorMIB=jnxCollectorMIB, jnxCollPicIfTable=jnxCollPicIfTable, jnxCollPicIfCreatedFileRate=jnxCollPicIfCreatedFileRate, jnxCollNotifyToFtpServerType=jnxCollNotifyToFtpServerType, jnxCollMemoryAvailable=jnxCollMemoryAvailable, jnxCollGlobalStats=jnxCollGlobalStats, jnxCollNotifyFromFtpServerType=jnxCollNotifyFromFtpServerType, jnxCollPicIfFtpFiles=jnxCollPicIfFtpFiles, jnxCollNotifyInitiatedBy=jnxCollNotifyInitiatedBy, jnxCollGlobalOpenFiles=jnxCollGlobalOpenFiles, jnxCollFileRecords=jnxCollFileRecords, jnxCollFileName=jnxCollFileName, jnxCollPicIfFtpFailures=jnxCollPicIfFtpFailures, jnxCollPicIfPeakFtpByteRate=jnxCollPicIfPeakFtpByteRate, jnxCollFileTable=jnxCollFileTable, jnxCollNotifyToFtpServerInetType=jnxCollNotifyToFtpServerInetType, jnxCollFlowOverload=jnxCollFlowOverload, jnxCollPicIfCurrentState=jnxCollPicIfCurrentState, jnxCollFileCompBytes=jnxCollFileCompBytes, jnxCollPicIfProcRecords=jnxCollPicIfProcRecords, jnxCollPicIfExportedFiles=jnxCollPicIfExportedFiles, jnxCollFileUncompBytes=jnxCollFileUncompBytes, jnxCollNotifyOverloadType=jnxCollNotifyOverloadType, jnxCollNotifyNewRecordRate=jnxCollNotifyNewRecordRate, jnxCollNotifyError=jnxCollNotifyError, jnxCollUnavailableDest=jnxCollUnavailableDest, jnxCollNotifyVars=jnxCollNotifyVars, jnxCollNotifyMemFree=jnxCollNotifyMemFree, jnxCollFlowOverloadCleared=jnxCollFlowOverloadCleared, jnxCollNotifyUrl=jnxCollNotifyUrl, jnxCollFtpSwitchover=jnxCollFtpSwitchover, jnxCollPicIfDestroyedFiles=jnxCollPicIfDestroyedFiles)

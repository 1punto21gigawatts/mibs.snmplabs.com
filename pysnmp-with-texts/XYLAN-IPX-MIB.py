#
# PySNMP MIB module XYLAN-IPX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-IPX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Integer32, ObjectIdentity, MibIdentifier, Counter32, NotificationType, IpAddress, Unsigned32, Counter64, iso, Bits, Gauge32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "ObjectIdentity", "MibIdentifier", "Counter32", "NotificationType", "IpAddress", "Unsigned32", "Counter64", "iso", "Bits", "Gauge32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanIpxArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanIpxArch")
xylanIpxRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 1))
xylanIpxFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 2))
xylanIpxWatchdogSpoofGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 3))
xylanIpxSerialFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 4))
xylanSpxKeepaliveSpoofGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 5))
xylanIpxType20Group = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 6))
xylanIpxTimerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 7))
xylanIpxDefRouteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 8))
xylanIpxExtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 6, 9))
xylanIpxStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1), )
if mibBuilder.loadTexts: xylanIpxStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteTable.setDescription('The Static Routes table contains information about all destinations reached via statically configured routes.')
xylanIpxStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxStaticRouteNetNum"))
if mibBuilder.loadTexts: xylanIpxStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteEntry.setDescription('Each entry corresponds to one static route.')
xylanIpxStaticRouteNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxStaticRouteNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteNetNum.setDescription("The IPX network number of the route's destination.")
xylanIpxStaticRouteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxStaticRouteAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteAdminState.setDescription('The current status of this route. active (1) means the route is functioning, delete (2) tell SNMP to delete the route ')
xylanIpxStaticRouteNextHopNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxStaticRouteNextHopNet.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteNextHopNet.setDescription('The IPX network number of the router used to reach the first hop in the static route.')
xylanIpxStaticRouteNextHopNode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxStaticRouteNextHopNode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteNextHopNode.setDescription('The IPX node number of the router used to reach the first hop in the static route.')
xylanIpxStaticRouteTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanIpxStaticRouteTicks.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteTicks.setDescription("The delay, in ticks, to reach the route's destination.")
xylanIpxStaticRouteHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanIpxStaticRouteHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxStaticRouteHopCount.setDescription('The number of hops necessary to reach the destination.')
xylanIpxRipSapFilterTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1), )
if mibBuilder.loadTexts: xylanIpxRipSapFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterTable.setDescription('The IPX Rip/Sap Filter Table contains information about all filters that have been defined.')
xylanIpxRipSapFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxRipSapFilterNum"))
if mibBuilder.loadTexts: xylanIpxRipSapFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterEntry.setDescription('Each entry corresponds to one filter.')
xylanIpxRipSapFilterNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanIpxRipSapFilterNum.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterNum.setDescription('The number identifying this instance. This number can be used when specifying a filter to delete.')
xylanIpxRipSapFilterAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterAdminState.setDescription('The current status of this filter, active (1) means the filter is functioning, delete (2) tells SNMP to delete the filter ')
xylanIpxRipSapFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sap-output", 1), ("sap-input", 2), ("gns-output", 3), ("rip-output", 4), ("rip-input", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterType.setDescription('The type of filter. ')
xylanIpxRipSapFilterNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterNet.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterNet.setDescription("The IPX Network Address to filter. A network address of all 0's is used to denote All Networks.")
xylanIpxRipSapFilterNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterNetMask.setDescription('The IPX Network Mask to be used.')
xylanIpxRipSapFilterNode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterNode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterNode.setDescription("The IPX node address to filter. A node address of all 0's is used to denote All Nodes.")
xylanIpxRipSapFilterNodeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterNodeMask.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterNodeMask.setDescription('The IPX node address mask to be used.')
xylanIpxRipSapFilterSvcType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterSvcType.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterSvcType.setDescription('The SAP service type on which to filter. The SAP service types are defined by Novell. A value of ALL (65535) indicates that all services will be filtered.')
xylanIpxRipSapFilterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("block", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterMode.setDescription('The action defined by this filter. block (1) means packets matching this filter will be blocked, and allow (0) means that packets matching this filter will be allowed.')
xylanIpxRipSapFilterGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterGroupId.setDescription('The GroupId can be used to apply this filter to a particular interface. A GroupId of 0 means that the filter is global.')
xylanIpxRipSapFilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterVlanId.setDescription('The VlanId for this filter.')
xylanIpxRipSapFilterWanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-used", 1), ("frame-relay", 2), ("ppp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterWanType.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterWanType.setDescription('If the Vlan has Wan Routing enabled, this object can be used to specify whether this interface is a Frame Relay service or a PPP service. This will be used to determine whether the slot/port/vc or PeerId fields are applicable to this entry. A value of 1 implies that this field is not used. (The interface is not a WAN interface or the filter is not being applied to a specific VC or PeerId.) A value of 2 indicates that this is a Frame Relay service in which case the slot/port/vc fields can be used to apply the filter to a specific VC. A value of 3 indicates that this is a PPP service and the Peer ID field may be used.')
xylanIpxRipSapFilterSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterSlot.setDescription('If the WanType specifies a Frame Relay service, the slot/port/vc can be used to apply this filter to a particular Virtual Circuit (VC).')
xylanIpxRipSapFilterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterPort.setDescription('If the WanType specifies a Frame Relay service, the slot/port/vc can be used to apply this filter to a particular Virtual Circuit (VC).')
xylanIpxRipSapFilterVc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterVc.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterVc.setDescription('If the WanType specifies a Frame Relay service, the slot/port/vc can be used to apply this filter to a particular Virtual Circuit (VC).')
xylanIpxRipSapFilterPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 2, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxRipSapFilterPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxRipSapFilterPeerId.setDescription('If the WanType specifies a PPP service, the PeerId can be used to apply this filter to a particular Peer.')
xylanIpxWatchdogSpoofTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 3, 1), )
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofTable.setDescription('The IPX Watchdog Spoofing Table contains information about all of the WAN routing services and their current IPX spoofing status.')
xylanIpxWatchdogSpoofEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 3, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxWatchdogSpoofGroupId"))
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofEntry.setDescription('Each entry corresponds to one WAN routing service.')
xylanIpxWatchdogSpoofGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofGroupId.setDescription('The GroupId of the WAN routing service that this entry applies to.')
xylanIpxWatchdogSpoofMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxWatchdogSpoofMode.setDescription('This controls whether the IPX Watchdog Spoofing is enabled or disabled. When enabled, this routing service will spoof IPX Watchdog packets. When disabled, this routing service will not spoof IPX Watchdog packets.')
xylanIpxSerialFilterTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 4, 1), )
if mibBuilder.loadTexts: xylanIpxSerialFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxSerialFilterTable.setDescription('The IPX Serialization Filtering Table contains information about all of the WAN routing services and their current IPX Serialization Filtering status.')
xylanIpxSerialFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 4, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxSerialFilterGroupId"))
if mibBuilder.loadTexts: xylanIpxSerialFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxSerialFilterEntry.setDescription('Each entry corresponds to one WAN routing service.')
xylanIpxSerialFilterGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxSerialFilterGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxSerialFilterGroupId.setDescription('The GroupId of the WAN routing service that this entry applies to.')
xylanIpxSerialFilterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxSerialFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxSerialFilterMode.setDescription('This controls whether the IPX Serialization Filtering is enabled or disabled. When enabled, this routing service will filter IPX Serialization packets. When disabled, this routing service will not filter IPX Serialization packets.')
xylanSpxKeepaliveSpoofTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 5, 1), )
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofTable.setDescription('The SPX Keepalive Spoofing Table contains information about all of the WAN routing services and their current SPX Keepalive spoofing status.')
xylanSpxKeepaliveSpoofEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 5, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanSpxKeepaliveSpoofGroupId"))
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofEntry.setDescription('Each entry corresponds to one WAN routing service.')
xylanSpxKeepaliveSpoofGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofGroupId.setDescription('The GroupId of the WAN routing service that this entry applies to.')
xylanSpxKeepaliveSpoofMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanSpxKeepaliveSpoofMode.setDescription('This controls whether the SPX Keepalive Spoofing is enabled or disabled. When enabled, this routing service will spoof SPX Keepalive packets. When disabled, this routing service will not spoof SPX Keepalive packets.')
xylanIpxType20Table = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 6, 1), )
if mibBuilder.loadTexts: xylanIpxType20Table.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxType20Table.setDescription('The IPX Type 20 packets allow NetBios to use IPX. This can enable the passing of packet on each interface.')
xylanIpxType20Entry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 6, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxType20VlanId"))
if mibBuilder.loadTexts: xylanIpxType20Entry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxType20Entry.setDescription('Each entry corresponds to one Virtual LAN.')
xylanIpxType20VlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxType20VlanId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxType20VlanId.setDescription('The VLAN Id of the routing interface that this entry applies to.')
xylanIpxType20Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxType20Mode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxType20Mode.setDescription('This controls whether IPX Type 20 packet are enabled or disabled. When enabled, this routing interface will forward Type 20 packets. When disabled, the packets will not.')
xylanIpxTimerTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 7, 1), )
if mibBuilder.loadTexts: xylanIpxTimerTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxTimerTable.setDescription('The IPX Timer allows adjustable variation of the RIP and SAP timers.')
xylanIpxTimerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 7, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxTimerVlanId"))
if mibBuilder.loadTexts: xylanIpxTimerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxTimerEntry.setDescription('Each entry corresponds to one Virtual LAN.')
xylanIpxTimerVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxTimerVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxTimerVlanId.setDescription('The VLAN Id of the routing interface that this entry applies to.')
xylanIpxTimerSap = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 180))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxTimerSap.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxTimerSap.setDescription('This controls whether IPX SAP packet timer duration.')
xylanIpxTimerRip = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 180))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxTimerRip.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxTimerRip.setDescription('This controls whether IPX RIP packet timer duration.')
xylanIpxDefRouteTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 6, 8, 1), )
if mibBuilder.loadTexts: xylanIpxDefRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxDefRouteTable.setDescription('The default route table contains information about the destinations to which all packets are sent when the destination network is not known.')
xylanIpxDefRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 6, 8, 1, 1), ).setIndexNames((0, "XYLAN-IPX-MIB", "xylanIpxDefRouteNum"))
if mibBuilder.loadTexts: xylanIpxDefRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxDefRouteEntry.setDescription('One table entry per switch for default route.')
xylanIpxDefRouteNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 8, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxDefRouteNum.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxDefRouteNum.setDescription('The table row ID will always be 1.')
xylanIpxDefRouteNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 8, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxDefRouteNet.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxDefRouteNet.setDescription('The IPX network number of the router used to reach the first hop in the default route.')
xylanIpxDefRouteNode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 6, 8, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxDefRouteNode.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxDefRouteNode.setDescription('The IPX node number of the router used to reach the first hop in the default route.')
xylanIpxExtMsg = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 6, 9, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanIpxExtMsg.setStatus('mandatory')
if mibBuilder.loadTexts: xylanIpxExtMsg.setDescription(' A boolean variable that indicated whether extended RIP/SAP packets are sent and received.')
mibBuilder.exportSymbols("XYLAN-IPX-MIB", xylanIpxDefRouteEntry=xylanIpxDefRouteEntry, xylanIpxStaticRouteEntry=xylanIpxStaticRouteEntry, xylanIpxWatchdogSpoofTable=xylanIpxWatchdogSpoofTable, xylanIpxStaticRouteNextHopNet=xylanIpxStaticRouteNextHopNet, xylanSpxKeepaliveSpoofEntry=xylanSpxKeepaliveSpoofEntry, xylanIpxDefRouteNode=xylanIpxDefRouteNode, xylanIpxStaticRouteHopCount=xylanIpxStaticRouteHopCount, xylanIpxWatchdogSpoofGroupId=xylanIpxWatchdogSpoofGroupId, xylanSpxKeepaliveSpoofGroup=xylanSpxKeepaliveSpoofGroup, xylanIpxWatchdogSpoofEntry=xylanIpxWatchdogSpoofEntry, xylanIpxRipSapFilterTable=xylanIpxRipSapFilterTable, xylanIpxSerialFilterMode=xylanIpxSerialFilterMode, xylanIpxDefRouteNet=xylanIpxDefRouteNet, xylanIpxExtGroup=xylanIpxExtGroup, xylanIpxRipSapFilterSlot=xylanIpxRipSapFilterSlot, xylanIpxStaticRouteNetNum=xylanIpxStaticRouteNetNum, xylanIpxStaticRouteTable=xylanIpxStaticRouteTable, xylanIpxRipSapFilterGroupId=xylanIpxRipSapFilterGroupId, xylanIpxTimerGroup=xylanIpxTimerGroup, xylanIpxFilterGroup=xylanIpxFilterGroup, xylanIpxSerialFilterEntry=xylanIpxSerialFilterEntry, xylanIpxRipSapFilterNum=xylanIpxRipSapFilterNum, xylanIpxExtMsg=xylanIpxExtMsg, xylanIpxStaticRouteTicks=xylanIpxStaticRouteTicks, xylanIpxType20Table=xylanIpxType20Table, xylanIpxTimerRip=xylanIpxTimerRip, xylanIpxWatchdogSpoofMode=xylanIpxWatchdogSpoofMode, xylanIpxDefRouteGroup=xylanIpxDefRouteGroup, xylanIpxWatchdogSpoofGroup=xylanIpxWatchdogSpoofGroup, xylanIpxRipSapFilterNet=xylanIpxRipSapFilterNet, xylanIpxType20Mode=xylanIpxType20Mode, xylanIpxRipSapFilterWanType=xylanIpxRipSapFilterWanType, xylanIpxRipSapFilterVc=xylanIpxRipSapFilterVc, xylanIpxRipSapFilterPeerId=xylanIpxRipSapFilterPeerId, xylanIpxRipSapFilterType=xylanIpxRipSapFilterType, xylanIpxDefRouteTable=xylanIpxDefRouteTable, xylanIpxType20Group=xylanIpxType20Group, xylanIpxRipSapFilterNetMask=xylanIpxRipSapFilterNetMask, xylanIpxRipSapFilterAdminState=xylanIpxRipSapFilterAdminState, xylanIpxRipSapFilterNodeMask=xylanIpxRipSapFilterNodeMask, xylanIpxSerialFilterGroupId=xylanIpxSerialFilterGroupId, xylanIpxSerialFilterTable=xylanIpxSerialFilterTable, xylanIpxDefRouteNum=xylanIpxDefRouteNum, xylanIpxRoutingGroup=xylanIpxRoutingGroup, xylanIpxRipSapFilterNode=xylanIpxRipSapFilterNode, xylanIpxTimerEntry=xylanIpxTimerEntry, xylanIpxStaticRouteNextHopNode=xylanIpxStaticRouteNextHopNode, xylanIpxRipSapFilterSvcType=xylanIpxRipSapFilterSvcType, xylanSpxKeepaliveSpoofMode=xylanSpxKeepaliveSpoofMode, xylanSpxKeepaliveSpoofGroupId=xylanSpxKeepaliveSpoofGroupId, xylanIpxTimerSap=xylanIpxTimerSap, xylanIpxRipSapFilterVlanId=xylanIpxRipSapFilterVlanId, xylanIpxRipSapFilterMode=xylanIpxRipSapFilterMode, xylanIpxType20Entry=xylanIpxType20Entry, xylanIpxType20VlanId=xylanIpxType20VlanId, xylanIpxTimerTable=xylanIpxTimerTable, xylanIpxTimerVlanId=xylanIpxTimerVlanId, xylanIpxRipSapFilterPort=xylanIpxRipSapFilterPort, xylanSpxKeepaliveSpoofTable=xylanSpxKeepaliveSpoofTable, xylanIpxSerialFilterGroup=xylanIpxSerialFilterGroup, xylanIpxStaticRouteAdminState=xylanIpxStaticRouteAdminState, xylanIpxRipSapFilterEntry=xylanIpxRipSapFilterEntry)

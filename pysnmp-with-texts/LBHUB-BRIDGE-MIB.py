#
# PySNMP MIB module LBHUB-BRIDGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LBHUB-BRIDGE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:05:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
mgmt, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, enterprises, Integer32, ObjectIdentity, IpAddress, Unsigned32, Counter64, NotificationType, ModuleIdentity, iso, Bits, NotificationType, Counter32, Gauge32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "mgmt", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "enterprises", "Integer32", "ObjectIdentity", "IpAddress", "Unsigned32", "Counter64", "NotificationType", "ModuleIdentity", "iso", "Bits", "NotificationType", "Counter32", "Gauge32", "TimeTicks")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1))
terminalServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 1))
dedicatedBridgeServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 2))
dedicatedRouteServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 3))
brouter = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 4))
genericMSWorkstation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 5))
genericMSServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 6))
genericUnixServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 7))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8))
cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9))
linkBuilder3GH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 1))
linkBuilder10BTi = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 2))
linkBuilderECS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 3))
linkBuilderMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4))
linkBuilderFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 5))
linkBuilderFMSII = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 7))
linkBuilderFMSLBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 10))
linkBuilder3GH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 1)).setLabel("linkBuilder3GH-cards")
linkBuilder10BTi_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2)).setLabel("linkBuilder10BTi-cards")
linkBuilderECS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 3)).setLabel("linkBuilderECS-cards")
linkBuilderMSH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 4)).setLabel("linkBuilderMSH-cards")
linkBuilderFMS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5)).setLabel("linkBuilderFMS-cards")
linkBuilderFMSII_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6)).setLabel("linkBuilderFMSII-cards")
linkBuilder10BTi_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 1)).setLabel("linkBuilder10BTi-cards-utp")
linkBuilder10BT_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 2)).setLabel("linkBuilder10BT-cards-utp")
linkBuilderFMS_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 1)).setLabel("linkBuilderFMS-cards-utp")
linkBuilderFMS_cards_coax = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 2)).setLabel("linkBuilderFMS-cards-coax")
linkBuilderFMS_cards_fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 3)).setLabel("linkBuilderFMS-cards-fiber")
linkBuilderFMS_cards_12fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 4)).setLabel("linkBuilderFMS-cards-12fiber")
linkBuilderFMS_cards_24utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 5)).setLabel("linkBuilderFMS-cards-24utp")
linkBuilderFMSII_cards_12tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 1)).setLabel("linkBuilderFMSII-cards-12tp-rj45")
linkBuilderFMSII_cards_10coax_bnc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 2)).setLabel("linkBuilderFMSII-cards-10coax-bnc")
linkBuilderFMSII_cards_6fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 3)).setLabel("linkBuilderFMSII-cards-6fiber-st")
linkBuilderFMSII_cards_12fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 4)).setLabel("linkBuilderFMSII-cards-12fiber-st")
linkBuilderFMSII_cards_24tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 5)).setLabel("linkBuilderFMSII-cards-24tp-rj45")
linkBuilderFMSII_cards_24tp_telco = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 6)).setLabel("linkBuilderFMSII-cards-24tp-telco")
amp_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 3)).setLabel("amp-mib")
genericTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 4))
viewBuilderApps = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 5))
specificTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 6))
linkBuilder3GH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 7)).setLabel("linkBuilder3GH-mib")
linkBuilder10BTi_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8)).setLabel("linkBuilder10BTi-mib")
linkBuilderECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 9)).setLabel("linkBuilderECS-mib")
generic = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10))
genExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1))
setup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2))
sysLoader = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 3))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 4))
gauges = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 5))
asciiAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 6))
serialIf = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 7))
repeaterMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8))
endStation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 9))
localSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 10))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 11))
unusedGeneric12 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 12))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14))
mrmResilience = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 15))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16))
multiRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17))
bridgeMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18))
fault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 19))
poll = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 20))
powerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 21))
testData = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 1))
ifExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 2))
netBuilder_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 11)).setLabel("netBuilder-mib")
lBridgeECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 12)).setLabel("lBridgeECS-mib")
deskMan_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 13)).setLabel("deskMan-mib")
linkBuilderMSH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14)).setLabel("linkBuilderMSH-mib")
brControlPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18, 1))
brMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18, 2))
brDialoguePackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18, 3))
brClearCounters = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-action", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: brClearCounters.setDescription('Clears all the counters associated with the bridgeing function for all bridge ports. A read will always return a value of no-action(1), a write of no-action(1) will have no effect, while a write of clear(2) will clear all the counters.')
brSTAPMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brSTAPMode.setStatus('mandatory')
if mibBuilder.loadTexts: brSTAPMode.setDescription('Determines whether the STAP algorithm is on or off. If STAP mode is on then brForwardingMode may not be set to transparent. Conversley if brForwardingMode is set to transparent then brSTAPMode may not be set to on.')
brLearnMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brLearnMode.setStatus('mandatory')
if mibBuilder.loadTexts: brLearnMode.setDescription('Determines whether the bridge is not learning addresses (off), or learning addresses as permanent, deleteOnReset or deleteOnTimeout.')
brAgingMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brAgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: brAgingMode.setDescription('Determines whether the bridge will age out entries in its filtering database or not.')
brMonPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1), )
if mibBuilder.loadTexts: brMonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortTable.setDescription('A table that contains generic information about every port that is associated with this bridge.')
brMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1), ).setIndexNames((0, "LBHUB-BRIDGE-MIB", "brMonPort"))
if mibBuilder.loadTexts: brMonPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortEntry.setDescription('A list of information for each port of the bridge.')
brMonPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPort.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPort.setDescription('The port number of the port for which this entry contains bridge management information.')
brMonPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in [4,6], for the interface corresponding to this port.')
brMonPortPercentTrafficForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPortPercentTrafficForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortPercentTrafficForwarded.setDescription("This is a high level 'smart MIB' object. This object provides a running average of the proportion of the received frames that are forwarded. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics:- (1) The parameter will be recalculated at approx 60 second intervals (2) Every calculation period the device will read the value of dot1dTpPortInFrames and dot1dTpPortInDiscards. (3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(dot1dTpPortInDiscards(i)/dot1dTpPortInFrames(i)) * 1000/4 i=1 Which gives the percentage * 10 filtered, and then subtracting this from 1000 to give percentage * 10 forwarded. dot1dTpPortInDiscards(i) is dot1dTpPortInDiscards(i) - dot1dTpPortInDiscards(i-1). dot1dTpPortInFrames(i) is dot1dTpPortInFrames(i) - dot1dTpPortInFrames(i-1). The value is expressed as a percentage * 10. A default threshold exists on this average so that if a calculated average exceeds 85% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 50%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
brMonPortBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPortBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortBandwidthUsed.setDescription("This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: (1) The parameter will be recalculated at approx 60 second intervals (2) Every calculation period the device will read the value of ifInOctets plus ifOutOctets. (3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 1000/4 i=1 Sample(i) is (ifInOctets(i)+ifOutOctets(i))-(ifInOctets(i-1)+ifOutOctets(i-1)) time(i) is the time between sample(i-1) and sample(i) K is the max bytes per unit time (i.e. the available bandwidth) The value is expressed as a percentage * 10. A default threshold exists on this average so that if a calculated average exceeds 50% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 30%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
brMonPortErrorsPer10000Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPortErrorsPer10000Packets.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortErrorsPer10000Packets.setDescription("This is a high level 'smart MIB' object. This object provides a running average of the number of errors per 10000 packets. The value of this value is calculated locally on the agent and so does not require processor bandwidth from a management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following behaviour: (1) The parameter will be recalculated at approx 60 second intervals. (2) Every calculation period the device will read the value of portTotalErrors and dot1dTpPortInFrames. (3) The calculation will be performed on the most recent 4 samples as follows: 4 10000 * Sum(Errors(i)/Frames(i)) i=1 Errors(i) = portTotalErrors(i)-portTotalErrors(i-1) Frames(i) = dot1dTpPortInFrames(i)-dot1dTpPortInFrames(i-1) The value is an integer number of errors per 10,000 packets received by this port. A default threshold exists on this average so that if a calculated average exceeds 200 (i.e. 2% of frames are in error) a trap will be sent to the management station. Further traps will not be sent until the average drops to below 100 (i.e. 1% of frames are in error). A particular device may provide a means of changing the number of samples, the averaging period and threshold if it so wishes.")
brMonPortBroadcastBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 18, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMonPortBroadcastBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brMonPortBroadcastBandwidth.setDescription("This is a high level 'smart MIB' object. This object provides a running average of the Broadcast frame bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: (1) The parameter will be recalculated at approx 20 second intervals (2) Every calculation period the device will read the value of ifExtnsBroadcastsReceivedOks and ifExtnsBroadcastsTransmittedOks. (3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 1000/4 i=1 Sample(i) is (ifExtnsBroadcastsReceivedOks(i)+ifExtnsBroadcastsTransmittedOks(i))- (ifExtnsBroadcastsReceivedOks(i-1)+ifExtnsBroadcastsTransmittedOks(i-1)). time(i) is the time between sample(i-1) and sample(i) K is the max frames per unit time (i.e. the available bandwidth) The value is expressed as a percentage * 10. A default threshold exists on this average so that if a calculated average exceeds 20% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 10%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
brDataBase = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18, 4))
brDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18, 5))
brSizeOfFilteringDataBase = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brSizeOfFilteringDataBase.setStatus('mandatory')
if mibBuilder.loadTexts: brSizeOfFilteringDataBase.setDescription('The maximum possible number of Filtering database entries.')
brPercentageOfNonageingFDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPercentageOfNonageingFDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: brPercentageOfNonageingFDBEntries.setDescription('The number of entries currently in the filtering database that cannot be aged out, and are not in the permanent database. This is expressed as a percentage * 10 of the size of the filtering database :- ((number of non ageing entries)*1000)/(filtering db size).')
brPercentageOfAgeingFDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPercentageOfAgeingFDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: brPercentageOfAgeingFDBEntries.setDescription('The number of entries currently in the filtering database that can be aged out, and not held in the permanent database. This is expressed as a percentage * 10 of the size of the filtering database :- ((number of ageing entries)*1000)/(filtering db size).')
brPercentageOfPermanentFDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPercentageOfPermanentFDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: brPercentageOfPermanentFDBEntries.setDescription('The number of permanent entries currently in the filtering database. This is expressed as a percentage * 10 of the size of the filtering database :- ((number of permanent entries)*1000)/(filtering db size).')
brClearFilteringDataBase = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brClearFilteringDataBase.setStatus('mandatory')
if mibBuilder.loadTexts: brClearFilteringDataBase.setDescription('An attribute to clear all entries in the filtering database except for those which are permanent.')
brMaxNumberOfPermanentEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brMaxNumberOfPermanentEntries.setStatus('mandatory')
if mibBuilder.loadTexts: brMaxNumberOfPermanentEntries.setDescription('The maximum number of entries in the filtering database that can be permanent.')
brPercentageOfPermanentDatabaseUsed = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPercentageOfPermanentDatabaseUsed.setStatus('mandatory')
if mibBuilder.loadTexts: brPercentageOfPermanentDatabaseUsed.setDescription('The number of permanent entries in the filtering database. This is expressed as a percentage * 10 of the size of the permanent database :- ((number of permanent entries)*1000)/(permanent db size).')
brClearPermanentEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brClearPermanentEntries.setStatus('mandatory')
if mibBuilder.loadTexts: brClearPermanentEntries.setDescription('An attribute to clear the permanent entries from the filtering database.')
brSaveLearntAddresses = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("save", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brSaveLearntAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: brSaveLearntAddresses.setDescription('An attribute to make the learnt addresses held in the filtering database become permanent entries.')
brDatabaseModified = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChange", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brDatabaseModified.setStatus('mandatory')
if mibBuilder.loadTexts: brDatabaseModified.setDescription('This flag is used to indicate to a management application that the database (Forwarding or Static views) has altered while a manager is viewing it. The normal value of this parameter is noChange(1), it will remain at this value untill the database is modified by either:- - a manager mofifying the DB through the Static Table - the relay causing an entry to be inserted into the DB - the ageing process causing an entry to be deleted from the DB when it will be set to modified(2), where it will remain untill reset to noChange(1) by a manager.')
brDatabaseType = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filtering", 1), ("permanent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brDatabaseType.setStatus('mandatory')
if mibBuilder.loadTexts: brDatabaseType.setDescription('This dummy object enables the database full trap to differentiate between the filtering database and the permanent database.')
brDatabaseLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(90, 100))).clone(namedValues=NamedValues(("ninetyPercent", 90), ("oneHundredPercent", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brDatabaseLevel.setStatus('mandatory')
if mibBuilder.loadTexts: brDatabaseLevel.setDescription('This dummy object enables the database full trap to differentiate between the database being 90% and 100% full.')
brTrafficForwarded = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brTrafficForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: brTrafficForwarded.setDescription('This dummy object is used internally to calculate a running average of the percentage of traffic forwarded on a port. It should not be accessed by a management station.')
brPortBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPortBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brPortBandwidth.setDescription('This dummy object is used internally to calculate a running average of the port bandwidth in use. It should not be accessed by a management station.')
brPortBroadcastBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPortBroadcastBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: brPortBroadcastBandwidth.setDescription('This dummy object is used internally to calculate a running average of the port bandwidth in use. It should not be accessed by a management station.')
brPortErrors = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 18, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brPortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: brPortErrors.setDescription('This dummy object is used internally to calculate a running average of the errors per 10000 frames on a port. It should not be accessed by a management station.')
brDatabaseFull = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,65)).setObjects(("LBHUB-BRIDGE-MIB", "brDatabaseType"), ("LBHUB-BRIDGE-MIB", "brDatabaseLevel"))
if mibBuilder.loadTexts: brDatabaseFull.setDescription('This trap indicates that either the Filtering databse or the permanent database has become full. If the database occupancy exceeds 90% this trap will be sent also. The variable bindings enable the trap to be identified as refering to the filtering or permanet database, and to differentiate between 90% or 100% full.')
class BridgeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

mibBuilder.exportSymbols("LBHUB-BRIDGE-MIB", brClearCounters=brClearCounters, endStation=endStation, linkBuilderFMS=linkBuilderFMS, linkBuilder10BTi_mib=linkBuilder10BTi_mib, brDatabaseModified=brDatabaseModified, linkBuilderFMSII_cards_6fiber_st=linkBuilderFMSII_cards_6fiber_st, brPercentageOfPermanentFDBEntries=brPercentageOfPermanentFDBEntries, dedicatedRouteServer=dedicatedRouteServer, linkBuilder10BT_cards_utp=linkBuilder10BT_cards_utp, multiRepeater=multiRepeater, ifExtensions=ifExtensions, brPercentageOfNonageingFDBEntries=brPercentageOfNonageingFDBEntries, linkBuilderFMSII_cards=linkBuilderFMSII_cards, genericUnixServer=genericUnixServer, security=security, linkBuilder3GH=linkBuilder3GH, linkBuilderFMSII_cards_24tp_rj45=linkBuilderFMSII_cards_24tp_rj45, brPortBroadcastBandwidth=brPortBroadcastBandwidth, linkBuilder10BTi_cards=linkBuilder10BTi_cards, MacAddress=MacAddress, linkBuilderFMS_cards_12fiber=linkBuilderFMS_cards_12fiber, brMonPort=brMonPort, generic=generic, brDatabaseType=brDatabaseType, BridgeId=BridgeId, linkBuilderFMS_cards_24utp=linkBuilderFMS_cards_24utp, sysLoader=sysLoader, deskMan_mib=deskMan_mib, linkBuilderFMSII=linkBuilderFMSII, viewBuilderApps=viewBuilderApps, bridgeMgmt=bridgeMgmt, brMonPortBroadcastBandwidth=brMonPortBroadcastBandwidth, products=products, hub=hub, fault=fault, localSnmp=localSnmp, a3Com=a3Com, setup=setup, lBridgeECS_mib=lBridgeECS_mib, linkBuilderFMS_cards_fiber=linkBuilderFMS_cards_fiber, brSTAPMode=brSTAPMode, brouter=brouter, brClearFilteringDataBase=brClearFilteringDataBase, brSaveLearntAddresses=brSaveLearntAddresses, repeaterMgmt=repeaterMgmt, genExperimental=genExperimental, linkBuilderFMSII_cards_12tp_rj45=linkBuilderFMSII_cards_12tp_rj45, brControlPackage=brControlPackage, linkBuilderFMS_cards_utp=linkBuilderFMS_cards_utp, brMaxNumberOfPermanentEntries=brMaxNumberOfPermanentEntries, dedicatedBridgeServer=dedicatedBridgeServer, genericTrap=genericTrap, brMonPortTable=brMonPortTable, brMonPortErrorsPer10000Packets=brMonPortErrorsPer10000Packets, brAgingMode=brAgingMode, brDialoguePackage=brDialoguePackage, linkBuilder3GH_cards=linkBuilder3GH_cards, linkBuilderMSH_cards=linkBuilderMSH_cards, manager=manager, brTrafficForwarded=brTrafficForwarded, linkBuilderFMSII_cards_10coax_bnc=linkBuilderFMSII_cards_10coax_bnc, netBuilder_mib=netBuilder_mib, powerSupply=powerSupply, brLearnMode=brLearnMode, brMonitorPackage=brMonitorPackage, cards=cards, linkBuilderMSH=linkBuilderMSH, linkBuilder3GH_mib=linkBuilder3GH_mib, asciiAgent=asciiAgent, brMonPortIfIndex=brMonPortIfIndex, linkBuilderFMS_cards=linkBuilderFMS_cards, PhysAddress=PhysAddress, unusedGeneric12=unusedGeneric12, linkBuilder10BTi_cards_utp=linkBuilder10BTi_cards_utp, linkBuilderFMS_cards_coax=linkBuilderFMS_cards_coax, linkBuilder10BTi=linkBuilder10BTi, poll=poll, brDatabaseLevel=brDatabaseLevel, brMonPortPercentTrafficForwarded=brMonPortPercentTrafficForwarded, DisplayString=DisplayString, amp_mib=amp_mib, linkBuilderMSH_mib=linkBuilderMSH_mib, linkBuilderFMSLBridge=linkBuilderFMSLBridge, brPortErrors=brPortErrors, brClearPermanentEntries=brClearPermanentEntries, brDummyPackage=brDummyPackage, serialIf=serialIf, brMonPortBandwidthUsed=brMonPortBandwidthUsed, specificTrap=specificTrap, linkBuilderECS_cards=linkBuilderECS_cards, testData=testData, mrmResilience=mrmResilience, linkBuilderECS=linkBuilderECS, gauges=gauges, chassis=chassis, brMonPortEntry=brMonPortEntry, brPortBandwidth=brPortBandwidth, brDataBase=brDataBase, brPercentageOfPermanentDatabaseUsed=brPercentageOfPermanentDatabaseUsed, brPercentageOfAgeingFDBEntries=brPercentageOfAgeingFDBEntries, linkBuilderFMSII_cards_12fiber_st=linkBuilderFMSII_cards_12fiber_st, linkBuilderECS_mib=linkBuilderECS_mib, terminalServer=terminalServer, brDatabaseFull=brDatabaseFull, genericMSWorkstation=genericMSWorkstation, genericMSServer=genericMSServer, tokenRing=tokenRing, brSizeOfFilteringDataBase=brSizeOfFilteringDataBase, linkBuilderFMSII_cards_24tp_telco=linkBuilderFMSII_cards_24tp_telco, mib_2=mib_2)

#
# PySNMP MIB module ITOUCH-RMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ITOUCH-RMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
iTouch, DateTime = mibBuilder.importSymbols("ITOUCH-MIB", "iTouch", "DateTime")
etherStatsIndex, alarmIndex = mibBuilder.importSymbols("RFC1271-MIB", "etherStatsIndex", "alarmIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter64, MibIdentifier, ObjectIdentity, ModuleIdentity, IpAddress, Bits, Gauge32, NotificationType, TimeTicks, Integer32, iso, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter64", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "IpAddress", "Bits", "Gauge32", "NotificationType", "TimeTicks", "Integer32", "iso", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xRmon = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 31))
xRmonMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 31, 1))
xRmonMB = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 31, 2))
xRmonMonitorRemote = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonMonitorRemote.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMonitorRemote.setDescription(" Once an alarm is 'completed', monitoring for that variable may be distributed within an enclosure to another processor. Factors affecting this decision include variable type, slot number, and processor type. Furthermore, alarms which have identical parameters (variable, interval, thresholds, etc.) are viewed by the monitoring processor as a single 'object' to monitor. Alarm variables falling into this category are a subset of the repeater MIB and iTouch repeater MIB objects. This field represents the number of 'objects' this system CPU is monitoring on behalf of alarms which were distributed to it by a management processor.")
xRmonMonitorLocal = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonMonitorLocal.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMonitorLocal.setDescription(" Once an alarm is 'completed', monitoring for that variable may be distributed within an enclosure to another processor. Factors affecting this decision include variable type, slot number, and processor type. Furthermore, alarms which have identical parameters (variable, interval, thresholds, etc.) are viewed by the monitoring processor as a single 'object' to monitor. Alarm variables falling into this category are a subset of the repeater MIB and iTouch repeater MIB objects. This field represents the number of 'objects' this system CPU is monitoring, objects it did not distribute to another processor.")
xRmonLogClear = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonLogClear.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonLogClear.setDescription(" Set this field to 'execute' to delete all RMON log table entries. Setting to 'ready' has no effect.")
xRmonLogTotal = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonLogTotal.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonLogTotal.setDescription(' This field reports the total number of RMON log entries created since the system was initialized. Clearing the log table does not change this value.')
xRmonLogLastDateTime = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 5), DateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonLogLastDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonLogLastDateTime.setDescription(' The local date and time of the system at the time an RMON log entry was last created.')
xRmonTrapType = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standardFormat", 1), ("iTouchFormat", 2))).clone('standardFormat')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonTrapType.setDescription(" Use this field to specify the type of SNMP trap to generate when an alarm event occurs. The value 'standardFormat' formats the trap as a standard, RMON-compliant rising and falling event trap. The value 'iTouchFormat' formats the trap as a DisplayString containing a human-readable summary of the event. The text of the string is very similar to that of the log descriptions.")
xRmonRepeaterManagement = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonRepeaterManagement.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonRepeaterManagement.setDescription(" This field enables and disables RMON monitoring of certain repeater related variables in the chassis. Set this field to 'enabled' to allow this slot to activate alarms and report traps for variables from the standard repeater MIB (snmpDot3RptrMgt 1.3.6.1.2.1.22) and the iTouch repeater MIB (xRepeater 1.3.6.1.4.1.33.17). When you set this field to 'disabled', alarms may still be created for these repeater variables, but no monitoring will take place for them. The alarm state will be 'held' during this time. Only one slot in a chassis may have this field set to 'enabled' at any given time. Setting 'enabled' in any one slot automatically sets it to 'disabled' in every other slot. Repeater variable monitoring in those slots will cease and the corresponding alarm states will be 'held'.")
xRmonAlarmActivate = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("activateAll", 2), ("deactivateAll", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonAlarmActivate.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmActivate.setDescription(" Use this field to change the states of all completed alarms to 'active' or 'inactive'. Select 'activateAll' to make all completed alarms not in the 'active' state become 'active' again. This is useful for alarms whose error states are not automatically cleared by the system. Alarms whose error conditions have not cleared will remain in their current states. Select 'deactivateAll' to make all completed alarms that are in the 'active' state become 'inactive'. This is a convenient way to suppress alarm activity while making other configuration changes without actually deleting the alarms. Alarms which are incomplete (e.g., 'creating' state) are not affected by these actions. If you want to alter the state of a single alarm, modify the table entry for that alarm. Selecting noAction has no effect.")
xRmonAlarmClear = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("deleteAll", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonAlarmClear.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmClear.setDescription(" Set this field to 'deleteAll' to delete all alarm table entries and their associated event entries. Setting to 'noAction' has no effect.")
xRmonAlarmCount = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 31, 1, 10))
xRmonAlarmsIncomplete = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonAlarmsIncomplete.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmsIncomplete.setDescription(' This value represents the number of alarms that are not completed. Completing these alarms will make them active.')
xRmonAlarmsActive = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 10, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonAlarmsActive.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmsActive.setDescription(" This value represents the number of alarms whose state is 'active'. These are completed alarms which are actively monitored.")
xRmonAlarmsHeld = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonAlarmsHeld.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmsHeld.setDescription(" This value represents the number of alarms whose state is 'held'. These are completed alarms which will not be actively monitored because the Repeater Management feature for this processor is currently disabled. Enabling the feature will activate all alarms in this state.")
xRmonAlarmsOther = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 10, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonAlarmsOther.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmsOther.setDescription(" This value represents the number of completed alarms that are not 'active' and not 'held'. Monitoring is not active for these alarms.")
xRmonAlarmInitAction = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activateUponInit", 1), ("inactiveUponInit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonAlarmInitAction.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonAlarmInitAction.setDescription(" Use this field to specify whether all alarms read from the parameter file should be placed in the 'active' state or the 'inactive' state upon system initialization. Selecting 'activateUponInit' (the default) will activate all alarms read from the parameter file when the system initializes. Selecting 'inactiveUponInit' will place all alarms in the 'inactive' state when the system initializes. Modifying this value does not affect the present state of any alarm.")
xRmonMBConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 31, 2, 1))
mbAlarmIndex = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmIndex.setDescription(" This field can be either the index of an existing alarm (as seen in the alarm summary view) or a new number to create a new alarm. Specify the index of an existing alarm to fill the remaining fields with the corresponding settings from that alarm. To modify the settings of a completed alarm, set its status to underCreation. Specify an index which does not exist to create a new alarm. The initial settings of the remaining fields are taken from the alarm you were previously viewing, if any. This makes it easier to 'copy' an alarm definition when you want to change only a few of the settings, such as the alarm variable or keys. Specify a value of 0 to clear the remaining fields.")
mbAlarmInterval = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 2), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmInterval.setDescription(' The interval in seconds over which the variable is sampled and compared with the rising and falling thresholds. If the monitored variable exceeds the limit 2^31-1 (4294967295), the alarm value field may roll over to 0 and cause or suppress the generation of an alarm event during that interval. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmVariable = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmVariable.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmVariable.setDescription(" This value shows the SNMP object identifier of the variable being sampled. Only variables that have an SNMP 'SYNTAX' of INTEGER, Counter, Gauge, or TimeTicks may be sampled. When you specify an object identifier in this field, the quick list, key prompt, and key value fields are filled for you with the appropriate values. If you specify an object not found in the quick list, that field is set to 'unlistedAlarmVariable'. The key values will be set to zero in this case. If you specify an alarm variable and keys using the quick list and key fields, an SNMP object identifier is built for you and placed in this field. You may not modify this field at the same time that you modify the quick list field or either of the key values. You may not modify this field once the alarm is completed (see alarm status field).")
mbAlarmInterpretation = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117))).clone(namedValues=NamedValues(("unlistedAlarmVariable", 1), ("portReadableFrames", 2), ("portReadableOctets", 3), ("portTotalFrames", 4), ("portTotalOctets", 5), ("portBroadcastFrames", 6), ("portMulticastFrames", 7), ("portFrames64Octets", 8), ("portFrames65to127Octets", 9), ("portFrames128to255Octets", 10), ("portFrames256to511Octets", 11), ("portFrames512to1023Octets", 12), ("portFrames1024to1518Octets", 13), ("portPercentUtilization", 14), ("portTrafficRatio", 15), ("portCollisionRatio", 16), ("portErrorRatio", 17), ("portBroadcastRatio", 18), ("portMulticastRatio", 19), ("portUnicastRatio", 20), ("portAlignmentErrors", 21), ("portAutoPartitions", 22), ("portCollisions", 23), ("portCRCAlignErrors", 24), ("portCRCErrors", 25), ("portDataRateMismatches", 26), ("portFrameTooLongErrors", 27), ("portLateCollisionErrors", 28), ("portManchesterCodeViolations", 29), ("portRunts", 30), ("portShortPacketErrors", 31), ("portStartOfFrameMissing", 32), ("portVeryLongFrameErrors", 33), ("portTotalErrors", 34), ("portAccessState", 35), ("portAccessAddressViolations", 36), ("portGlobalAddressChanges", 37), ("portSourceAddressChanges", 38), ("portAdminStatus", 39), ("portAutoPartitionState", 40), ("portOperStatus", 41), ("portPulseStatus", 43), ("portPulseLosses", 44), ("portSecondsSinceCountersZeroed", 45), ("repeaterTotalFrames", 46), ("repeaterTotalOctets", 47), ("repeaterPercentUtilization", 48), ("repeaterCollisions", 49), ("repeaterFifoOverflows", 50), ("repeaterJabbers", 51), ("repeaterSQEErrors", 52), ("repeaterSecondsSinceCountersZeroed", 53), ("slotTotalFrames", 54), ("slotTotalOctets", 55), ("slotTotalErrors", 56), ("slotCpuUtilization", 57), ("slotMemoryUtilization", 58), ("slotAlarmCount", 59), ("slotFifoErrors", 60), ("slotOperStatus", 61), ("slotOperStatusChange", 62), ("slotSecurityLockState", 63), ("slotIOCardOperStatus", 64), ("redundancyGroupPathChanges", 67), ("redundancyGroupRollbackAttempts", 68), ("redundancySecondsSinceCountersZeroed", 69), ("redundancyPathTestAttempts", 70), ("redundancyPathTestStatus", 71), ("systemCurrentPctCPU", 72), ("systemCurrentPctMemory", 73), ("systemCurrentProcesses", 74), ("systemCurrentTimers", 75), ("systemCurrentPackets", 76), ("systemCurrentIPCs", 77), ("systemCurrentFreeMemory", 78), ("systemWorstPctCPU", 82), ("systemWorstPctMemory", 83), ("systemWorstProcesses", 84), ("systemWorstTimers", 85), ("systemWorstPackets", 86), ("systemWorstIPCs", 87), ("systemWorstFreeMemory", 88), ("systemUpTime", 92), ("chassisSlotOperStatus", 93), ("chassisSlotSecondsSinceReset", 94), ("chassisSlotIOCardOperStatus", 95), ("chassisSlotPlus5Status", 96), ("chassisSlotPlus12Status", 97), ("chassisSlotMinus12Status", 98), ("chassisSlotPlus5Watts", 99), ("chassisSlotPlus12Watts", 100), ("chassisSlotMinus12Watts", 101), ("powerSupplyRedundancyStatus", 102), ("powerSupplyPlus5Status", 103), ("powerSupplyPlus12Status", 104), ("powerSupplyMinus12Status", 105), ("powerSupplyThermalWarningStatus", 106), ("powerSupplyThermalShutdownStatus", 107), ("powerSupplyFanStatus", 108), ("powerSupplyHardwareInhibitStatus", 109), ("powerSupplyPlus5Volts", 110), ("powerSupplyPlus12Volts", 111), ("powerSupplyMinus12Volts", 112), ("powerSupplyWatts", 113), ("powerSupplyWattsMax", 114), ("powerSupplyChassisWatts", 115), ("powerSupplyChassisWattsMax", 116), ("powerSupplyHardwareType", 117)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmInterpretation.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmInterpretation.setDescription(' Use this field when you want to select an alarm variable without specifying its entire SNMP object identifier. First, modify this field by selecting a variable from the list. Then, read the key prompt fields. They will direct you to specify key values appropriate to the selected variable. The SNMP object identifier will be built for you when you are done. You may not modify this field at the same time that you modify the object identifier field. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmKey1Meaning = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbAlarmKey1Meaning.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmKey1Meaning.setDescription(" This field describes how its adjacent key value field will be interpreted when building a complete SNMP object identifier for the alarm variable. The value of this field changes as you select different items from the quick list or specify different SNMP object identifiers. This object has the value 'not applicable' if its key value is not necessary or the object is unknown.")
mbAlarmKey1 = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmKey1.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmKey1.setDescription(' Specify a value here according the the instructions given in its adjacent prompt field. That prompt explains how this field will be used. You may still modify this field even though the prompt field indicates that it is not applicable to the selected variable. It will be ignored. You may not modify this field at the same time that you modify the object identifier field. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmKey2Meaning = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbAlarmKey2Meaning.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmKey2Meaning.setDescription(" This field describes how its adjacent key value field will be interpreted when building a complete SNMP object identifier for the alarm variable. The value of this field changes as you select different items from the quick list or specify different SNMP object identifiers. This object has the value 'not applicable' if its key value is not necessary or the object is unknown.")
mbAlarmKey2 = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmKey2.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmKey2.setDescription(' Specify a value here according the the instructions given in its adjacent prompt field. That prompt explains how this field will be used. In some cases, the value zero has a special meaning. This often occurs when you are prompted to enter a port number. Zero indicates you want each port in the indicated slot to be monitored by this alarm. Only one alarm will exist, but it will generate an event each time any of the ports meets its criteria. You may still modify this field even though the prompt field indicates that it is not applicable to the selected variable. It will be ignored. You may not modify this field at the same time that you modify the object identifier field. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmSampleType = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("changeInValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmSampleType.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmSampleType.setDescription(" Use this field to select the method of calculating the value to be compared against the thresholds. When you set this to 'absoluteValue', the variable you specified is compared directly with the alarm thresholds at the end of each monitoring interval. When you set this to 'changeInValue', the change in the value of the variable over the interval is compared with the thresholds. This is useful for detecting changes in rates of activity. You may not modify this field once the alarm is completed (see alarm status field).")
mbAlarmValue = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbAlarmValue.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmValue.setDescription(" This field shows the value of the alarm variable at the end of the most recent monitoring interval. If the alarm sample type is 'changeInValue', it instead shows the change in value over that interval. This field is zero any time the alarm is not active, or when the alarm is a wildcard (that is, a port or repeater number of 0 was specified for key 2 value). The value of this field has meaning after the alarm configuration is complete and monitoring begins.")
mbAlarmRisingThreshold = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmRisingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmRisingThreshold.setDescription(' This is the rising threshold value for the alarm. When the current alarm value, specified by the alarm sample type, is greater than or equal to this threshold, and the value at the previous sampling interval was less than this threshold, a single rising alarm event will be generated. Another rising alarm event will not be generated until the sampled value falls below the falling threshold value. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmFallingThreshold = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmFallingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmFallingThreshold.setDescription(' This is the falling threshold value for the alarm. When the current alarm value, specified by the alarm sample type, is less than or equal to this threshold, and the value at the previous sampling interval was greater than this threshold, a single rising alarm event will be generated. Another rising alarm event will not be generated until the sampled value falls below the falling threshold value. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmRisingEventType = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("logOnly", 2), ("trapOnly", 3), ("logAndTrap", 4))).clone('logAndTrap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmRisingEventType.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmRisingEventType.setDescription(' Use this field to indicate the type of notification to make when the alarm variable exceeds its rising threshold. The default action is to generate both a log entry and a trap. Set this field to noAction to suppress notification of rising threshold events. Set this field to logOnly to generate an RMON alarm log entry. These log entries may be viewed through the RMON alarm log view. Set this field to trapOnly to generate an SNMP trap. Refer to the RMON alarm summary to specify whether traps are generated in standard RMON format or in iTouch format. Choosing logAndTrap invokes both these actions. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmFallingEventType = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("logOnly", 2), ("trapOnly", 3), ("logAndTrap", 4))).clone('logAndTrap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmFallingEventType.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmFallingEventType.setDescription(' Use this field to indicate the type of notification to make when the alarm variable exceeds its falling threshold. The default action is to generate both a log entry and a trap. Set this field to noAction to suppress notification of falling threshold events. Set this field to logOnly to generate an RMON alarm log entry. These log entries may be viewed through the RMON alarm log view. Set this field to trapOnly to generate an SNMP trap. Refer to the RMON alarm summary to specify whether traps are generated in standard RMON format or in iTouch format. Choosing logAndTrap invokes both these actions. You may not modify this field once the alarm is completed (see alarm status field).')
mbAlarmSummary = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbAlarmSummary.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmSummary.setDescription(" As you make changes to the to alarm settings, this field is filled with an easily readable summary of the alarm parameters. This is to make it easy for you to confirm that monitoring will behave as you expected once the alarm status is 'active'.")
mbAlarmStatus = MibScalar((1, 3, 6, 1, 4, 1, 33, 31, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("underCreation", 1), ("active", 2), ("inactive", 3), ("delete", 4), ("held", 5), ("noHubCard", 6), ("oldFirmware", 7), ("slotTimeout", 8), ("slotFailed", 9), ("monitorStopped", 10), ("unknownVariable", 11), ("keysMissing", 12), ("noResources", 13), ("loading", 14), ("activating", 15), ("deactivating", 16), ("unsupported", 17), ("unknownAlarm", 18), ("inconsistency", 19), ("invalidFlags", 20), ("invalidSlot", 21), ("inaccessible", 22), ("otherError", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmStatus.setDescription(" Describes the current operational state of the alarm and allows you to make limited changes in the state of the alarm for purposes of managing its state. You may set this field to one of: underCreation, active, inactive, and delete. All other values report current status. underCreation: Alarm configuration is incomplete. You may modify alarm parameters. No monitoring is taking place for the alarm. An alarm is saved in a parameter file after configuration complete. Select this state before changing a previously completed alarm. active: Alarm configuration is complete and active monitoring of the alarm variable is in progress. Select this state to complete an alarm or to begin active monitioring of the alarm variable. inactive: No monitoring of the alarm variable is actively taking place. Select this state when you want to temporarily suppress monitoring for the alarm. Select 'active' to begin monitoring again. delete: Select this state when you want to delete this alarm and all log entries associated with it. held: Active monitoring of the alarm variable is not taking place because this system does not have RMON Repeater Management set to 'enabled'. Once you do this, alarm monitoring begins automatically. noHubCard: The target slot does not contain a management card or repeater I/O card capable of monitoring. Monitoring will begin automatically once the target slot is loaded with a supported configuration. oldFirmware: The I/O card in the target slot does not contain monitoring firmware. Monitoring will begin automatically once that card has been loaded with current scm firmware. slotTimeout: The target slot did not respond to attempts to activate the alarm. May happen if the management card in the target slot does not contain monitoring software. Monitoring begins automatically once the target slot has been repaired or loaded with current software. slotFailed: Active monitoring of the alarm variable stopped because the target slot was not operating properly. Monitoring automatically resumes once the target slot has recovered. monitorStopped: Active monitoring of the alarm variable stopped due to some error. This can occur if the variable no longer exists because a related configuration change has made it invalid. Correct the condition and re-activate the alarm. unknownVariable: The alarm variable specified by the object ID is not recognized in the currently running system. Correct the entry. keysMissing: One or more required key values are not specified in the alarm variable object ID. Correct the entry. noResources: Not enough system resources exist to activate this alarm. Reduce the use of packet buffers or available memory and re-activate the alarm. loading: The alarm is being read from a parameter file and will soon be activated. This condition is transient. activating: Monitoring of the alarm variable will begin soon. This condition is transient. deactivating: Monitoring of the alarm variable will stop soon. This condition is transient. unsupported: Monitoring for the alarm variable is not supported by the target slot. Monitoring will begin once that card is loaded with current scm firmware or software. unknownAlarm: Monitoring stopped because the target slot reset. Monitoring will continue shortly. inconsistency: Internal system error. invalidFlags: Internal system error. invalidSlot: Alarm specified for a slot which does not exist in the chassis. Modify and re-activate. inaccessible: Monitoring of the alarm variable could not begin. This can occur if the key values are invalid for the variable. Correct and re-activate the alarm. otherError: An unspecified error has occurred.")
mbAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 33, 31, 2, 2), )
if mibBuilder.loadTexts: mbAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmTable.setDescription('A list of RMON alarms. This table is indexed by alarmIndex to provide an intuitive mapping between alarms and descriptions.')
mbAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 31, 2, 2, 1), ).setIndexNames((0, "RFC1271-MIB", "alarmIndex"))
if mibBuilder.loadTexts: mbAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmEntry.setDescription('A description of an RMON alarm which summarizes the actual RMON alarm and event parameters corresponding to this entry.')
mbAlarmCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("underCreation", 1), ("active", 2), ("inactive", 3), ("delete", 4), ("held", 5), ("noHubCard", 6), ("oldFirmware", 7), ("slotTimeout", 8), ("slotFailed", 9), ("monitorStopped", 10), ("unknownVariable", 11), ("keysMissing", 12), ("noResources", 13), ("loading", 14), ("activating", 15), ("deactivating", 16), ("unsupported", 17), ("unknownAlarm", 18), ("inconsistency", 19), ("invalidFlags", 20), ("invalidSlot", 21), ("inaccessible", 22), ("otherError", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbAlarmCondition.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmCondition.setDescription(" Describes the current operational state of the alarm and allows you to make limited changes in the state of the alarm for purposes of managing its state. You may set this field to one of: underCreation, active, inactive, and delete. All other values report current status. underCreation: Alarm configuration is incomplete. You may modify alarm parameters. No monitoring is taking place for the alarm. An alarm is saved in a parameter file after configuration complete. Select this state before changing a previously completed alarm. active: Alarm configuration is complete and active monitoring of the alarm variable is in progress. Select this state to complete an alarm or to begin active monitioring of the alarm variable. inactive: No monitoring of the alarm variable is actively taking place. Select this state when you want to temporarily suppress monitoring for the alarm. Select 'active' to begin monitoring again. delete: Select this state when you want to delete this alarm and all log entries associated with it. held: Active monitoring of the alarm variable is not taking place because this system does not have RMON Repeater Management set to 'enabled'. Once you do this, alarm monitoring begins automatically. noHubCard: The target slot does not contain a management card or repeater I/O card capable of monitoring. Monitoring will begin automatically once the target slot is loaded with a supported configuration. oldFirmware: The I/O card in the target slot does not contain monitoring firmware. Monitoring will begin automatically once that card has been loaded with current scm firmware. slotTimeout: The target slot did not respond to attempts to activate the alarm. May happen if the management card in the target slot does not contain monitoring software. Monitoring begins automatically once the target slot has been repaired or loaded with current software. slotFailed: Active monitoring of the alarm variable stopped because the target slot was not operating properly. Monitoring automatically resumes once the target slot has recovered. monitorStopped: Active monitoring of the alarm variable stopped due to some error. This can occur if the variable no longer exists because a related configuration change has made it invalid. Correct the condition and re-activate the alarm. unknownVariable: The alarm variable specified by the object ID is not recognized in the currently running system. Correct the entry. keysMissing: One or more required key values are not specified in the alarm variable object ID. Correct the entry. noResources: Not enough system resources exist to activate this alarm. Allocate more packet buffers or increase free memory and re-activate the alarm. loading: The alarm is being read from a parameter file and will soon be activated. This condition is transient. activating: Monitoring of the alarm variable will begin soon. This condition is transient. deactivating: Monitoring of the alarm variable will stop soon. This condition is transient. unsupported: Monitoring for the alarm variable is not supported by the target slot. Monitoring will begin once that card is loaded with current scm firmware or software. unknownAlarm: Monitoring stopped because the target slot reset. Monitoring will continue shortly. inconsistency: Internal system error. invalidFlags: Internal system error. invalidSlot: Alarm specified for a slot which does not exist in the chassis. Modify and re-activate. inaccessible: Monitoring of the alarm variable could not begin. This can occur if the key values are invalid for the variable. Correct and re-activate the alarm. otherError: An unspecified error has occurred.")
mbAlarmDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbAlarmDescription.setStatus('mandatory')
if mibBuilder.loadTexts: mbAlarmDescription.setDescription(" An easily-readable summary of an RMON alarm. The general format is: '<action> when <condition> <variable> <key2tag> <key1tag> is >= <r> or <= <f> <interval>.' <action> is from: 'Do nothing', 'Create log record', 'Generate trap', 'Create log and trap', or 'Various actions', based on the alarm rising and falling event types. <condition> is one of 'value of' or 'change in', according to the alarm sample type. <variable>, if recognized, describes the quick list selection. If unlisted, the object identifier is substituted. <key1tag> and <key2tag> appear only if <variable> is recognized and represent phrases like 'slot', 'port', and 'any port'. <r> and <f> represent the rising and falling threshold values, respectively. The <interval> phrase describes the units per N seconds or the length of the sample interval in seconds.")
mbLogTable = MibTable((1, 3, 6, 1, 4, 1, 33, 31, 2, 3), )
if mibBuilder.loadTexts: mbLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbLogTable.setDescription('A list of RMON logTable entries.')
mbLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 31, 2, 3, 1), ).setIndexNames((0, "ITOUCH-RMON-MIB", "mbLogIndex"))
if mibBuilder.loadTexts: mbLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbLogEntry.setDescription('A human-readable description of an RMON event.')
mbLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mbLogIndex.setDescription(' An index uniquely identifying an entry in this log table. Each such entry describes, in human-readable format, an RMON event occurring for an alarm. All RMON log table entries are shown, ordered most recent first.')
mbLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: mbLogDescription.setDescription(" An easily-readable summary of an RMON log entry. The general format is: '<time>: alarm <index> <condition> <variable> <key2tag> <key1tag> is <limit> <interval>.' <time> is the date and time the entry was created. <index> is the alarm index causing the report. <condition> is one of 'value of <V> for' or 'change of <V> for', according to the alarm sample type. <V> is the actual value triggering the report. <variable>, if recognized, describes the quick list selection. If unlisted, the object identifier is substituted. <key1tag> and <key2tag> appear only if <variable> is recognized and represent phrases like 'slot', 'port', and 'any port'. <limit> is one of '>= <r>' or '<= <f>' where <r> and <f> represent the rising and falling threshold values, respectively. The <interval> phrase describes the units per N seconds or the length of the sample interval in seconds.")
mbResourceTable = MibTable((1, 3, 6, 1, 4, 1, 33, 31, 2, 4), )
if mibBuilder.loadTexts: mbResourceTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceTable.setDescription('A list of RMON resource entries.')
mbResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1), ).setIndexNames((0, "ITOUCH-RMON-MIB", "mbResourceType"))
if mibBuilder.loadTexts: mbResourceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceEntry.setDescription('Values to control and monitor RMON resources.')
mbResourceType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rmonAlarms", 1), ("rmonEvents", 2), ("rmonLogEntries", 3), ("rmonStatistics", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbResourceType.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceType.setDescription('Identification of an RMON resource type. Typically each type corresponds to an RMON table whose size is to be controlled and monitored.')
mbResourceCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbResourceCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceCurrent.setDescription(' The number of entries currently allocated by RMON.')
mbResourceWorst = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbResourceWorst.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceWorst.setDescription(' The highest number of entries ever allocated by RMON since system initialization.')
mbResourceMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbResourceMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceMaximum.setDescription(' The desired maximum possible number of resources of this type RMON is permitted to use at any one time. Changes to alarm, event, and log entry resource settings take effect immediately. Changes to the statistics resource takes place after the system is initialized. For alarms and events, this value may not be set less than the current number of entries in use.')
mbResourceOperMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbResourceOperMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: mbResourceOperMaximum.setDescription(' The actual maximum number of resources of this type RMON will attempt to use at any one time. This is the limit in effect for the current system.')
xRmonMapTable = MibTable((1, 3, 6, 1, 4, 1, 33, 31, 3), )
if mibBuilder.loadTexts: xRmonMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMapTable.setDescription('A list of RMON map entries.')
xRmonMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 31, 3, 1), ).setIndexNames((0, "RFC1271-MIB", "etherStatsIndex"))
if mibBuilder.loadTexts: xRmonMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMapEntry.setDescription('Values to create RMON statistics tables for repeater ports.')
xRmonMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 3, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMapSlot.setDescription(' The slot the statistics will come from.')
xRmonMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xRmonMapPort.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMapPort.setDescription(' The port the statistics will come from.')
xRmonMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 31, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xRmonMapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xRmonMapIfIndex.setDescription(' The interface index (ifIndex) corresponding to this statistics table.')
iTouchAlarm = NotificationType((1, 3, 6, 1, 4, 1, 33, 31) + (0,1)).setObjects(("ITOUCH-RMON-MIB", "mbLogDescription"))
if mibBuilder.loadTexts: iTouchAlarm.setDescription('The SNMP trap that is generated when xRmonTrapType is set to iTouchFormat(2). These traps, like the RMON standardFormat(1) traps, occur when an alarm variable crosses its rising or falling threshold and generates an event configured to send SNMP traps. The format of the DisplayString embodied by the trap PDU is identical to that of mbLogDescription. The actual object identifier is not significant.')
mibBuilder.exportSymbols("ITOUCH-RMON-MIB", iTouchAlarm=iTouchAlarm, xRmonMapPort=xRmonMapPort, mbResourceCurrent=mbResourceCurrent, mbLogIndex=mbLogIndex, mbAlarmFallingEventType=mbAlarmFallingEventType, xRmonAlarmsActive=xRmonAlarmsActive, mbAlarmInterval=mbAlarmInterval, mbResourceMaximum=mbResourceMaximum, mbLogDescription=mbLogDescription, mbAlarmKey2Meaning=mbAlarmKey2Meaning, mbAlarmInterpretation=mbAlarmInterpretation, xRmonAlarmsHeld=xRmonAlarmsHeld, xRmonMBConfig=xRmonMBConfig, mbResourceWorst=mbResourceWorst, mbAlarmCondition=mbAlarmCondition, xRmonRepeaterManagement=xRmonRepeaterManagement, xRmonAlarmsIncomplete=xRmonAlarmsIncomplete, xRmonMapIfIndex=xRmonMapIfIndex, xRmonAlarmsOther=xRmonAlarmsOther, mbAlarmSampleType=mbAlarmSampleType, xRmonAlarmActivate=xRmonAlarmActivate, xRmonAlarmInitAction=xRmonAlarmInitAction, xRmonMonitorLocal=xRmonMonitorLocal, xRmonLogTotal=xRmonLogTotal, xRmonLogLastDateTime=xRmonLogLastDateTime, mbAlarmEntry=mbAlarmEntry, mbResourceType=mbResourceType, mbAlarmKey1=mbAlarmKey1, xRmonMB=xRmonMB, mbAlarmRisingThreshold=mbAlarmRisingThreshold, mbLogEntry=mbLogEntry, mbAlarmTable=mbAlarmTable, xRmonTrapType=xRmonTrapType, xRmonLogClear=xRmonLogClear, mbAlarmKey1Meaning=mbAlarmKey1Meaning, mbResourceTable=mbResourceTable, xRmon=xRmon, mbLogTable=mbLogTable, mbAlarmRisingEventType=mbAlarmRisingEventType, mbAlarmVariable=mbAlarmVariable, mbAlarmIndex=mbAlarmIndex, xRmonAlarmClear=xRmonAlarmClear, mbResourceOperMaximum=mbResourceOperMaximum, xRmonMonitorRemote=xRmonMonitorRemote, mbAlarmFallingThreshold=mbAlarmFallingThreshold, mbAlarmDescription=mbAlarmDescription, xRmonMapTable=xRmonMapTable, mbResourceEntry=mbResourceEntry, xRmonMapSlot=xRmonMapSlot, mbAlarmValue=mbAlarmValue, xRmonMonitor=xRmonMonitor, xRmonMapEntry=xRmonMapEntry, mbAlarmKey2=mbAlarmKey2, mbAlarmStatus=mbAlarmStatus, xRmonAlarmCount=xRmonAlarmCount, mbAlarmSummary=mbAlarmSummary)

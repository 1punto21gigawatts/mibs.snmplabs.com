#
# PySNMP MIB module HUAWEI-PIM-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HUAWEI-PIM-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:47:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
hwDatacomm, = mibBuilder.importSymbols("HUAWEI-MIB", "hwDatacomm")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetVersion, InetAddress, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetVersion", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Bits, Integer32, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter64, ObjectIdentity, IpAddress, mib_2, NotificationType, TimeTicks, ModuleIdentity, Gauge32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter64", "ObjectIdentity", "IpAddress", "mib-2", "NotificationType", "TimeTicks", "ModuleIdentity", "Gauge32", "MibIdentifier")
TruthValue, TextualConvention, RowStatus, StorageType, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "RowStatus", "StorageType", "TimeStamp", "DisplayString")
hwMcast = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149))
hwPimStdMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4))
hwPimStdMib.setRevisions(('2014-07-01 00:00', '2014-06-20 00:00', '2013-05-06 00:00', '2007-04-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hwPimStdMib.setRevisionsDescriptions(('1.Modify the description of hwPimStarGThresholdExceed. 2.Modify the description of hwPimStarGThresholdExceedClear. 3.Modify the description of hwPimStarGExceedClear. 4.Modify the description of hwPimSGThresholdExceed. 5.Modify the description of hwPimSGThresholdExceedClear. 6.Modify the description of hwPimSGExceedClear. ', '1.Add hwPimStarGThresholdExceed trap. 2.Add hwPimStarGThresholdExceedClear trap. 3.Add hwPimStarGExceed trap. 4.Add hwPimStarGExceedClear trap. 5.Add hwPimSGThresholdExceed trap. 6.Add hwPimSGThresholdExceedClear trap. 7.Add hwPimSGExceed trap. 8.Add hwPimSGExceedClear trap. ', 'Modify the description of hwPimNeighborLoss.', 'The initial revision of this Mib module.',))
if mibBuilder.loadTexts: hwPimStdMib.setLastUpdated('201407010000Z')
if mibBuilder.loadTexts: hwPimStdMib.setOrganization('Huawei Technologies Co.,Ltd.')
if mibBuilder.loadTexts: hwPimStdMib.setContactInfo("Huawei Industrial Base Bantian, Longgang Shenzhen 518129 People's Republic of China Website: http://www.huawei.com Email: support@huawei.com ")
if mibBuilder.loadTexts: hwPimStdMib.setDescription('The MIB module for management of PIM routers. Huawei Technologies co.,Ltd . Supplementary information may be available at: http://www.huawei.com')
class HWPimMode(TextualConvention, Integer32):
    description = 'The PIM mode in which a group is operating. none(1) The group is not using PIM, which may be the case if, for example, it is a link-local or unroutable group address. ssm(2) Source-Specific Multicast (SSM) with PIM Sparse Mode. asm(3) Any Source Multicast (ASM), with PIM Sparse Mode. bidir(4) Bi-directional PIM. dm(5) PIM Dense Mode. other(6) Any other PIM mode.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 1), ("ssm", 2), ("asm", 3), ("bidir", 4), ("dm", 5), ("other", 6))

class HWPimGroupMappingOriginType(TextualConvention, Integer32):
    reference = 'RFC 3596, RFC 3956 and I-D.ietf-pim-sm-bsr'
    description = 'The mechanism by which a PIM group mapping was learned. fixed(1) Link-local or unroutable group mappings. configRp(2) Local static RP configuration. configSsm(3) Local SSM Group configuration. bsr(4) The PIM Bootstrap Router (BSR) mechanism. autoRp(5) Auto-RP mechanism. embedded(6) The Embedded-RP mechanism where the RP address is embedded in the multicast group address. other(7) Any other mechanism.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("fixed", 1), ("configRp", 2), ("configSsm", 3), ("bsr", 4), ("autoRp", 5), ("embedded", 6), ("other", 7))

class HWPimCtlMsgState(TextualConvention, Integer32):
    description = 'The PIM control message state. recv(1) The PIM control message has been received. sent(2) The PIM control message has been sent. invalid(3) The invalid PIM control message has been received. filter(4) The PIM control message has been filtered.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("recv", 1), ("sent", 2), ("invalid", 3), ("filter", 4))

hwPimNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0))
hwPim = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1))
hwPimKeepalivePeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimKeepalivePeriod.setReference('RFC 4601 section 4.11')
if mibBuilder.loadTexts: hwPimKeepalivePeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimKeepalivePeriod.setDescription('The duration of the Keepalive Timer. This is the period during which the PIM router will maintain (S,G) state in the absence of explicit (S,G) local membership or (S,G) join messages received to maintain it. This timer period is called the Keepalive_Period in the PIM-SM specification. It is called the SourceLifetime in the PIM-DM specification. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 210 }')
hwPimRegisterSuppressionTime = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimRegisterSuppressionTime.setReference('RFC 4601 section 4.11')
if mibBuilder.loadTexts: hwPimRegisterSuppressionTime.setStatus('current')
if mibBuilder.loadTexts: hwPimRegisterSuppressionTime.setDescription('The duration of the Register Suppression Timer. This is the period during which a PIM Designated Router (DR) stops sending Register-encapsulated data to the Rendezvous Point (RP) after receiving a Register-Stop message. This object is used to run timers both at the DR and at the RP. This timer period is called the Register_Suppression_Time in the PIM-SM specification. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 60 }')
hwPimStarGEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGEntries.setDescription('The number of entries in the hwPimStarGTable.')
hwPimStarGIEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIEntries.setDescription('The number of entries in the hwPimStarGITable.')
hwPimSGEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimSGEntries.setDescription('The number of entries in the hwPimSGTable.')
hwPimSGIEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIEntries.setDescription('The number of entries in the hwPimSGITable.')
hwPimSGRptEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptEntries.setDescription('The number of entries in the hwPimSGRptTable.')
hwPimSGRptIEntries = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptIEntries.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIEntries.setDescription('The number of entries in the hwPimSGRptITable.')
hwPimOutAsserts = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimOutAsserts.setReference('RFC 4601 section 4.6')
if mibBuilder.loadTexts: hwPimOutAsserts.setStatus('current')
if mibBuilder.loadTexts: hwPimOutAsserts.setDescription('The number of Asserts sent by this router. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimInAsserts = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInAsserts.setReference('RFC 4601 section 4.6')
if mibBuilder.loadTexts: hwPimInAsserts.setStatus('current')
if mibBuilder.loadTexts: hwPimInAsserts.setDescription('The number of Asserts received by this router. Asserts are multicast to all routers on a network. This counter is incremented by all routers that receive an assert, not only those routers that are contesting the assert. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimLastAssertInterface = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 24), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimLastAssertInterface.setReference('RFC 4601 section 4.6')
if mibBuilder.loadTexts: hwPimLastAssertInterface.setStatus('current')
if mibBuilder.loadTexts: hwPimLastAssertInterface.setDescription('The interface on which this router most recently sent or received an assert, or zero if this router has not sent or received an assert.')
hwPimLastAssertGroupAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 25), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimLastAssertGroupAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimLastAssertGroupAddressType.setDescription('The address type of the multicast group address in the most recently sent or received assert. If this router has not sent or received an assert then this object is set to unknown(0).')
hwPimLastAssertGroupAddress = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 26), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimLastAssertGroupAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimLastAssertGroupAddress.setDescription('The multicast group address in the most recently sent or received assert. The InetAddressType is given by the hwPimLastAssertGroupAddressType object.')
hwPimLastAssertSourceAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 27), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimLastAssertSourceAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimLastAssertSourceAddressType.setDescription('The address type of the multicast source address in the most recently sent or received assert. If the most recent assert was (*,G), or if this router has not sent or received an assert, then this object is set to unknown(0).')
hwPimLastAssertSourceAddress = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 28), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimLastAssertSourceAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimLastAssertSourceAddress.setDescription('The multicast source address in the most recently sent or received assert. The InetAddressType is given by the hwPimLastAssertSourceAddressType object.')
hwPimNeighborLossNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimNeighborLossNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborLossNotificationPeriod.setDescription("The minimum time that must elapse between hwPimNeighborLoss notifications originated by this router. The maximum value 65535 represents an 'infinite' time, in which case no hwPimNeighborLoss notifications are ever sent. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 0 }")
hwPimNeighborLossCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborLossCount.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimNeighborLossCount.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborLossCount.setDescription('The number of neighbor loss events that have occurred. This counter is incremented when the neighbor timer expires. This counter is incremented whenever a hwPimNeighborLoss notification would be generated. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimInvalidRegisterNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimInvalidRegisterNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterNotificationPeriod.setDescription("The minimum time that must elapse between hwPimInvalidRegister notifications originated by this router. The default value of 65535 represents an 'infinite' time, in which case no hwPimInvalidRegister notifications are ever sent. The non-zero minimum allowed value provides resilience against propagation of denial-of-service attacks from the data and control planes to the network management plane. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 65535 }")
hwPimInvalidRegisterMsgsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidRegisterMsgsRcvd.setReference('RFC 4601 section 4.4.2, RFC 3569 and I-D.ietf-mboned-ip-mcast-mib ipMcastSsmRangeTable')
if mibBuilder.loadTexts: hwPimInvalidRegisterMsgsRcvd.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterMsgsRcvd.setDescription('The number of invalid PIM Register messages that have been received by this device. A PIM Register message is invalid if either o the destination address of the Register message does not match the Group to RP mapping on this device, or o this device believes the group address to be within an SSM address range, but this Register implies ASM usage. These conditions can occur transiently while RP mapping changes propagate through the network. If this counter is incremented repeatedly over several minutes, then there is a persisting configuration error that requires correction. The active Group to RP mapping on this device is specified by the object hwPimGroupMappingPimMode. If there is no such mapping, then the object hwPimGroupMappingPimMode is absent. The RP address contained in the invalid Register is hwPimInvalidRegisterRp. Multicast data carried by invalid Register messages is discarded. The discarded data is from a source directly connected to hwPimInvalidRegisterOrigin, and is addressed to hwPimInvalidRegisterGroup. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimInvalidRegisterAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 33), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidRegisterAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterAddressType.setDescription('The address type stored in hwPimInvalidRegisterOrigin, hwPimInvalidRegisterGroup and hwPimInvalidRegisterRp. If no unexpected Register messages have been received, then this object is set to unknown(0).')
hwPimInvalidRegisterOrigin = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 34), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidRegisterOrigin.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterOrigin.setDescription('The source address of the last unexpected Register message received by this device.')
hwPimInvalidRegisterGroup = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 35), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidRegisterGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterGroup.setDescription('The IP multicast group address to which the last unexpected Register message received by this device was addressed.')
hwPimInvalidRegisterRp = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 36), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidRegisterRp.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegisterRp.setDescription('The RP address to which the last unexpected Register message received by this device was delivered.')
hwPimInvalidJoinPruneNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 37), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneNotificationPeriod.setDescription("The minimum time that must elapse between hwPimInvalidJoinPrune notifications originated by this router. The default value of 65535 represents an 'infinite' time, in which case no hwPimInvalidJoinPrune notifications are ever sent. The non-zero minimum allowed value provides resilience against propagation of denial-of-service attacks from the control plane to the network management plane. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 65535 }")
hwPimInvalidJoinPruneMsgsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneMsgsRcvd.setReference('RFC 4601 section 4.5.2, RFC 3569 and I-D.ietf-mboned-ip-mcast-mib ipMcastSsmRangeTable')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneMsgsRcvd.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneMsgsRcvd.setDescription('The number of invalid PIM Join/Prune messages that have been received by this device. A PIM Join/Prune message is invalid if either o the Group to RP mapping specified by this message does not match the Group to RP mapping on this device, or o this device believes the group address to be within an SSM address range, but this Join/Prune (*,G) or (S,G,rpt) implies ASM usage. These conditions can occur transiently while RP mapping changes propagate through the network. If this counter is incremented repeatedly over several minutes, then there is a persisting configuration error that requires correction. The active Group to RP mapping on this device is specified by the object hwPimGroupMappingPimMode. If there is no such mapping, then the object hwPimGroupMappingPimMode is absent. The RP address contained in the invalid Join/Prune is hwPimInvalidJoinPruneRp. Invalid Join/Prune messages are discarded. This may result in loss of multicast data affecting listeners downstream of hwPimInvalidJoinPruneOrigin, for multicast data addressed to hwPimInvalidJoinPruneGroup. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimInvalidJoinPruneAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 39), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneAddressType.setDescription('The address type stored in hwPimInvalidJoinPruneOrigin, hwPimInvalidJoinPruneGroup and hwPimInvalidJoinPruneRp. If no unexpected Join/Prune messages have been received, this object is set to unknown(0).')
hwPimInvalidJoinPruneOrigin = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 40), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneOrigin.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneOrigin.setDescription('The source address of the last unexpected Join/Prune message received by this device.')
hwPimInvalidJoinPruneGroup = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 41), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneGroup.setDescription('The IP multicast group address carried in the last unexpected Join/Prune message received by this device.')
hwPimInvalidJoinPruneRp = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 42), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInvalidJoinPruneRp.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPruneRp.setDescription('The RP address carried in the last unexpected Join/Prune message received by this device.')
hwPimRpMappingNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimRpMappingNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimRpMappingNotificationPeriod.setDescription("The minimum time that must elapse between hwPimRpMappingChange notifications originated by this router. The default value of 65535 represents an 'infinite' time, in which case no hwPimRpMappingChange notifications are ever sent. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 65535 }")
hwPimRpMappingChangeCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimRpMappingChangeCount.setReference('I-D.ietf-pim-sm-bsr')
if mibBuilder.loadTexts: hwPimRpMappingChangeCount.setStatus('current')
if mibBuilder.loadTexts: hwPimRpMappingChangeCount.setDescription('The number of changes to active RP mappings on this device. Information about active RP mappings is available in hwPimGroupMappingTable. Only changes to active mappings cause this counter to be incremented. That is, changes that modify the hwPimGroupMappingEntry with the highest precedence for a group (lowest value of hwPimGroupMappingPrecedence). Such changes may result from manual configuration of this device, or from automatic RP mapping discovery methods including the PIM Bootstrap Router (BSR) mechanism. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimInterfaceElectionNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 45), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimInterfaceElectionNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceElectionNotificationPeriod.setDescription("The minimum time that must elapse between hwPimInterfaceElection notifications originated by this router. The default value of 65535 represents an 'infinite' time, in which case no hwPimInterfaceElection notifications are ever sent. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 65535 }")
hwPimInterfaceElectionWinCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceElectionWinCount.setReference('RFC 4601 section 4.3.2 and I-D.ietf-pim-bidir section 3.5.2')
if mibBuilder.loadTexts: hwPimInterfaceElectionWinCount.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceElectionWinCount.setDescription('The number of times this device has been elected DR or DF on any interface. Elections occur frequently on newly-active interfaces, as triggered Hellos establish adjacencies. This counter is not incremented for elections on an interface until the first periodic Hello has been sent. If this router is the DR or DF at the time of sending the first periodic Hello after interface activation, then this counter is incremented (once) at that time. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimRefreshInterval = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimRefreshInterval.setReference('RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimRefreshInterval.setDescription('The interval between successive State Refresh messages sent by an Originator. This timer period is called the RefreshInterval in the PIM-DM specification. This object is used only by PIM-DM. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 60 }')
hwPimDeviceConfigStorageType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 48), StorageType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimDeviceConfigStorageType.setStatus('current')
if mibBuilder.loadTexts: hwPimDeviceConfigStorageType.setDescription("The storage type used for the global PIM configuration of this device, comprised of the objects listed below. If this storage type takes the value 'permanent', write-access to the listed objects need not be allowed. The objects described by this storage type are: hwPimKeepalivePeriod, hwPimRegisterSuppressionTime, hwPimNeighborLossNotificationPeriod, hwPimInvalidRegisterNotificationPeriod, hwPimInvalidJoinPruneNotificationPeriod, hwPimRpMappingNotificationPeriod, hwPimInterfaceElectionNotificationPeriod, hwPimRefreshInterval, hwPimNeighborAddNotificationPeriod. DEFVAL { nonVolatile }")
hwPimNeighborAddCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborAddCount.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimNeighborAddCount.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborAddCount.setDescription('The number of new neighbor found events that have occurred. This counter is incremented when the new neighbor is come up. This counter is incremented whenever a hwPimNeighborLoss notification would be generated. Discontinuities in the value of this counter can occur at re-initialization of the management system, for example when the device is rebooted.')
hwPimNeighborAddNotificationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPimNeighborAddNotificationPeriod.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborAddNotificationPeriod.setDescription("The minimum time that must elapse between hwPimNeighborAdd notifications originated by this router. The maximum value 65535 represents an 'infinite' time, in which case no hwPimNeighborAdd notifications are ever sent. The storage type of this object is determined by hwPimDeviceConfigStorageType. DEFVAL { 0 }")
hwPimGRStartTime = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 51), TimeStamp()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimGRStartTime.setStatus('obsolete')
if mibBuilder.loadTexts: hwPimGRStartTime.setDescription('The time when PIM entered GR state.')
hwPimGRInterval = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 52), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(90, 3600))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimGRInterval.setStatus('obsolete')
if mibBuilder.loadTexts: hwPimGRInterval.setDescription('The minimum PIM GR period. DEFVAL { 120 }')
hwPimGREndTime = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 53), TimeStamp()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimGREndTime.setStatus('obsolete')
if mibBuilder.loadTexts: hwPimGREndTime.setDescription('The time when PIM left the GR state.')
hwPimMrtLimitAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 54), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimMrtLimitAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimMrtLimitAddressType.setDescription('The address type of the multicast group address.')
hwPimMrtLimitSource = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 55), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimMrtLimitSource.setStatus('current')
if mibBuilder.loadTexts: hwPimMrtLimitSource.setDescription('The source address of the entry.')
hwPimMrtLimitGroup = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 56), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimMrtLimitGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimMrtLimitGroup.setDescription('The group address of the entry.')
hwPimInstanceID = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 57), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimInstanceID.setStatus('current')
if mibBuilder.loadTexts: hwPimInstanceID.setDescription('The Instance ID of the trap.')
hwPimInstanceName = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 60), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimInstanceName.setStatus('current')
if mibBuilder.loadTexts: hwPimInstanceName.setDescription('The instance name of the trap.')
hwPimNeighborNotificationReason = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 100))).clone(namedValues=NamedValues(("holdTimeExpired", 1), ("notReceiveHelloForALongTime", 2), ("interfaceIsDown", 3), ("receiveHelloAgain", 4), ("neighbourIsDeleted", 5), ("alarmTimeOut", 6), ("receiveHelloHoldTimeZero", 7), ("bfdSessionDown", 8), ("userOperation", 9), ("alarmClear", 100)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimNeighborNotificationReason.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborNotificationReason.setDescription('The reason for trap sending: 1:holdTime expired; 2:Not receive hello for a long time; 3:Interface is down; 4:Receive Hello again; 5:neighbour is deleted; 6:Alarm time out; 7:Receive Hello HoldTime is Zero; 8:Bfd Session is Down; 9:User Operation; 100:Alarm Clear')
hwPimNotificationAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 62), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimNotificationAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimNotificationAddressType.setDescription('The address type of the multicast group address.')
hwPimStarGCurrentCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 63), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 262144))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimStarGCurrentCount.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGCurrentCount.setDescription('The current number of PIM (*, G) entries of all instances.')
hwPimStarGTotalCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 64), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 262144))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimStarGTotalCount.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGTotalCount.setDescription('The total number of PIM (*, G) entries of all instances.')
hwPimStarGThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 65), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimStarGThreshold.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGThreshold.setDescription('The threshold value of PIM (*, G) uppper limit(%).')
hwPimSGCurrentCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 66), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 262144))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimSGCurrentCount.setStatus('current')
if mibBuilder.loadTexts: hwPimSGCurrentCount.setDescription('The current number of PIM (S, G) entries of all instances.')
hwPimSGTotalCount = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 67), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 262144))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimSGTotalCount.setStatus('current')
if mibBuilder.loadTexts: hwPimSGTotalCount.setDescription('The total number of PIM (S, G) entries of all instances.')
hwPimSGThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 68), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimSGThreshold.setStatus('current')
if mibBuilder.loadTexts: hwPimSGThreshold.setDescription('The threshold value of PIM (S, G) uppper limit(%).')
hwPimNotificationSrcAddr = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 69), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimNotificationSrcAddr.setStatus('current')
if mibBuilder.loadTexts: hwPimNotificationSrcAddr.setDescription('The source address of the entry.')
hwPimNotificationGrpAddr = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 70), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimNotificationGrpAddr.setStatus('current')
if mibBuilder.loadTexts: hwPimNotificationGrpAddr.setDescription('The group address of the entry.')
hwPimInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1), )
if mibBuilder.loadTexts: hwPimInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceTable.setDescription("The (conceptual) table listing the router's PIM interfaces. PIM is enabled on all interfaces listed in this table.")
hwPimInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimInterfaceIfIndex"), (0, "HUAWEI-PIM-STD-MIB", "hwPimInterfaceIpVersion"))
if mibBuilder.loadTexts: hwPimInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceEntry.setDescription('An entry (conceptual row) in the hwPimInterfaceTable. This entry is preserved on agent restart.')
hwPimInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceIfIndex.setDescription('The ifIndex value of this PIM interface.')
hwPimInterfaceIpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 2), InetVersion())
if mibBuilder.loadTexts: hwPimInterfaceIpVersion.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceIpVersion.setDescription('The IP version of this PIM interface. A physical interface may be configured in multiple modes concurrently, e.g. IPv4 and IPv6, however the traffic is considered to be logically separate.')
hwPimInterfaceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceAddressType.setDescription('The address type of this PIM interface.')
hwPimInterfaceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceAddress.setReference('RFC 4601 sections 4.1.6, 4.3.1-4.3.4 and 4.5.1')
if mibBuilder.loadTexts: hwPimInterfaceAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceAddress.setDescription('The primary IP address of this router on this PIM interface. The InetAddressType is given by the hwPimInterfaceAddressType object.')
hwPimInterfaceGenerationIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceGenerationIdValue.setReference('RFC 4601 section 4.3.1')
if mibBuilder.loadTexts: hwPimInterfaceGenerationIdValue.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceGenerationIdValue.setDescription('The value of the Generation ID this router inserted in the last PIM Hello message it sent on this interface.')
hwPimInterfaceDr = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceDr.setReference('RFC 4601 section 4.3')
if mibBuilder.loadTexts: hwPimInterfaceDr.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceDr.setDescription('The primary IP address of the Designated Router on this PIM interface. The InetAddressType is given by the hwPimInterfaceAddressType object.')
hwPimInterfaceDrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 7), Unsigned32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceDrPriority.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimInterfaceDrPriority.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceDrPriority.setDescription('The Designated Router Priority value inserted into the DR Priority option on this interface. Numerically higher values for this object indicate higher priorities.')
hwPimInterfaceDrPriorityEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceDrPriorityEnabled.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimInterfaceDrPriorityEnabled.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceDrPriorityEnabled.setDescription('Evaluates to TRUE if all routers on this interface are using the DR Priority option.')
hwPimInterfaceHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 18000)).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceHelloInterval.setReference('RFC 4601 section 9')
if mibBuilder.loadTexts: hwPimInterfaceHelloInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceHelloInterval.setDescription("The frequency at which PIM Hello messages are transmitted on this interface. This object corresponds to the 'Hello_Period' timer value defined in the PIM-SM specification. A value of zero represents an 'infinite' interval, and indicates that periodic PIM Hello messages should not be sent on this interface.")
hwPimInterfaceTrigHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceTrigHelloInterval.setReference('RFC 4601 section 4.11')
if mibBuilder.loadTexts: hwPimInterfaceTrigHelloInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceTrigHelloInterval.setDescription("The maximum time before this router sends a triggered PIM Hello message on this interface. This object corresponds to the 'Trigered_Hello_Delay' timer value defined in the PIM-SM specification. A value of zero has no special meaning and indicates that triggered PIM Hello messages should always be sent immediately.")
hwPimInterfaceHelloHoldtime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(105)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceHelloHoldtime.setReference('RFC 4601 sections 4.3.2 and 4.9.2')
if mibBuilder.loadTexts: hwPimInterfaceHelloHoldtime.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceHelloHoldtime.setDescription("The value set in the Holdtime field of PIM Hello messages transmitted on this interface. A value of 65535 represents an 'infinite' holdtime. Implementations are recommended to use a holdtime that is 3.5 times the value of hwPimInterfaceHelloInterval, or 65535 if hwPimInterfaceHelloInterval is set to zero.")
hwPimInterfaceJoinPruneInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 18000)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneInterval.setReference('RFC 4601 section 4.11')
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneInterval.setDescription("The frequency at which this router sends PIM Join/Prune messages on this PIM interface. This object corresponds to the 't_periodic' timer value defined in the PIM-SM specification. A value of zero represents an 'infinite' interval, and indicates that periodic PIM Join/Prune messages should not be sent on this interface.")
hwPimInterfaceJoinPruneHoldtime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(210)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneHoldtime.setReference('RFC 4601 sections 4.5.3 and 4.9.5')
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneHoldtime.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceJoinPruneHoldtime.setDescription("The value inserted into the Holdtime field of a PIM Join/Prune message sent on this interface. A value of 65535 represents an 'infinite' holdtime. Implementations are recommended to use a holdtime that is 3.5 times the value of hwPimInterfaceJoinPruneInterval, or 65535 if hwPimInterfaceJoinPruneInterval is set to zero. PIM-DM implementations are recommended to use the value of hwPimInterfacePruneLimitInterval.")
hwPimInterfaceDfElectionRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 14), Unsigned32().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceDfElectionRobustness.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceDfElectionRobustness.setDescription('The minimum number of PIM DF-Election messages that must be lost in order for DF election on this interface to fail.')
hwPimInterfaceLanDelayEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceLanDelayEnabled.setReference('RFC 4601 sections 4.3.3 and 4.9.2')
if mibBuilder.loadTexts: hwPimInterfaceLanDelayEnabled.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceLanDelayEnabled.setDescription('Evaluates to TRUE if all routers on this interface are using the LAN Prune Delay option.')
hwPimInterfacePropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767)).clone(500)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfacePropagationDelay.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfacePropagationDelay.setDescription('The expected propagation delay between PIM routers on this network or link. This router inserts this value into the Propagation_Delay field of the LAN Prune Delay option in the PIM Hello messages sent on this interface. Implementations should enforce a lower bound on the permitted values for this object to allow for scheduling and processing delays within the local router.')
hwPimInterfaceOverrideInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2500)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceOverrideInterval.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimInterfaceOverrideInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceOverrideInterval.setDescription('The value this router inserts into the Override_Interval field of the LAN Prune Delay option in the PIM Hello messages it sends on this interface. When overriding a prune, PIM routers pick a random timer duration up to the value of this object. The more PIM routers that are active on a network, the more likely it is that the prune will be overridden after a small proportion of this time has elapsed. The more PIM routers are active on this network, the larger this object should be to obtain an optimal spread of prune override latencies.')
hwPimInterfaceEffectPropagDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceEffectPropagDelay.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimInterfaceEffectPropagDelay.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceEffectPropagDelay.setDescription('The Effective Propagation Delay on this interface. This object is always 500 if hwPimInterfaceLanDelayEnabled is FALSE.')
hwPimInterfaceEffectOverrideIvl = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceEffectOverrideIvl.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimInterfaceEffectOverrideIvl.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceEffectOverrideIvl.setDescription('The Effective Override Interval on this interface. This object is always 2500 if hwPimInterfaceLanDelayEnabled is FALSE.')
hwPimInterfaceSuppressionEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceSuppressionEnabled.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimInterfaceSuppressionEnabled.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceSuppressionEnabled.setDescription('Whether join suppression is enabled on this interface. This object is always TRUE if hwPimInterfaceLanDelayEnabled is FALSE.')
hwPimInterfaceBidirCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceBidirCapable.setReference('I-D.ietf-pim-bidir section 3.2 and 3.7.4')
if mibBuilder.loadTexts: hwPimInterfaceBidirCapable.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceBidirCapable.setDescription('Evaluates to TRUE if all routers on this interface are using the Bidirectional-PIM Capable option.')
hwPimInterfaceDomainBorder = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 22), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceDomainBorder.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceDomainBorder.setDescription('Whether or not this interface is a PIM domain border. This includes acting as a border for PIM Bootstrap Router (BSR) messages, if the BSR mechanism is in use.')
hwPimInterfaceStubInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceStubInterface.setReference('RFC 3376, RFC 3810')
if mibBuilder.loadTexts: hwPimInterfaceStubInterface.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceStubInterface.setDescription("Whether this interface is a 'stub interface'. If this object is set to TRUE, then no PIM packets are sent out this interface, and any received PIM packets are ignored. Setting this object to TRUE is a security measure for interfaces towards untrusted hosts. This allows an interface to be configured for use with IGMP (Internet Group Management Protocol) or MLD (Multicast Listener Discovery) only, which protects the PIM router from forged PIM messages on the interface. To communicate with other PIM routers using this interface, this object must remain set to FALSE. Changing the value of this object while the interface is operational causes the interface to be deactivated and then reactivated.")
hwPimInterfacePruneLimitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfacePruneLimitInterval.setReference('RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimInterfacePruneLimitInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfacePruneLimitInterval.setDescription("The minimum interval that must transpire between two successive Prunes sent by a router. This object corresponds to the 't_limit' timer value defined in the PIM-DM specification. This object is used only by PIM-DM.")
hwPimInterfaceGraftRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceGraftRetryInterval.setReference('RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimInterfaceGraftRetryInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceGraftRetryInterval.setDescription("The minimum interval that must transpire between two successive Grafts sent by a router. This object corresponds to the 'Graft_Retry_Period' timer value defined in the PIM-DM specification. This object is used only by PIM-DM.")
hwPimInterfaceSrPriorityEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 26), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceSrPriorityEnabled.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceSrPriorityEnabled.setDescription('Evaluates to TRUE if all routers on this interface are using the State Refresh option. This object is used only by PIM-DM.')
hwPimInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 27), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceStatus.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceStatus.setDescription('The status of this entry. Creating the entry enables PIM on the interface; destroying the entry disables PIM on the interface. This status object can be set to active(1) without setting any other columnar objects in this entry. All writeable objects in this entry can be modified when the status of this entry is active(1).')
hwPimInterfaceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 28), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPimInterfaceStorageType.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceStorageType.setDescription("The storage type for this row. Rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
hwPimInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 1, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimInterfaceName.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceName.setDescription('The name of this PIM interface.')
hwPimNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2), )
if mibBuilder.loadTexts: hwPimNeighborTable.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborTable.setDescription("The (conceptual) table listing the router's PIM neighbors.")
hwPimNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimNeighborIfIndex"), (0, "HUAWEI-PIM-STD-MIB", "hwPimNeighborAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimNeighborAddress"))
if mibBuilder.loadTexts: hwPimNeighborEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborEntry.setDescription('An entry (conceptual row) in the hwPimNeighborTable.')
hwPimNeighborIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimNeighborIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborIfIndex.setDescription('The value of ifIndex for the interface used to reach this PIM neighbor.')
hwPimNeighborAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 2), InetAddressType())
if mibBuilder.loadTexts: hwPimNeighborAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborAddressType.setDescription('The address type of this PIM neighbor.')
hwPimNeighborAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimNeighborAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborAddress.setDescription('The primary IP address of this PIM neighbor. The InetAddressType is given by the hwPimNeighborAddressType object.')
hwPimNeighborGenerationIdPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborGenerationIdPresent.setReference('RFC 4601 section 4.3.1')
if mibBuilder.loadTexts: hwPimNeighborGenerationIdPresent.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborGenerationIdPresent.setDescription('Evaluates to TRUE if this neighbor is using the Generation ID option.')
hwPimNeighborGenerationIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborGenerationIdValue.setReference('RFC 4601 section 4.3.1')
if mibBuilder.loadTexts: hwPimNeighborGenerationIdValue.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborGenerationIdValue.setDescription('The value of the Generation ID from the last PIM Hello message received from this neighbor. This object is always zero if hwPimNeighborGenerationIdPresent is FALSE.')
hwPimNeighborUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborUpTime.setDescription('The time since this PIM neighbor (last) became a neighbor of the local router.')
hwPimNeighborExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborExpiryTime.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborExpiryTime.setDescription('The minimum time remaining before this PIM neighbor will be aged out. The value zero indicates that this PIM neighbor will never be aged out.')
hwPimNeighborDrPriorityPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborDrPriorityPresent.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimNeighborDrPriorityPresent.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborDrPriorityPresent.setDescription('Evaluates to TRUE if this neighbor is using the DR Priority option.')
hwPimNeighborDrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborDrPriority.setReference('RFC 4601 section 4.3.2')
if mibBuilder.loadTexts: hwPimNeighborDrPriority.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborDrPriority.setDescription('The value of the Designated Router Priority from the last PIM Hello message received from this neighbor. This object is always zero if hwPimNeighborDrPriorityPresent is FALSE.')
hwPimNeighborLanPruneDelayPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborLanPruneDelayPresent.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimNeighborLanPruneDelayPresent.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborLanPruneDelayPresent.setDescription('Evaluates to TRUE if this neighbor is using the LAN Prune Delay option.')
hwPimNeighborTBit = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborTBit.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimNeighborTBit.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborTBit.setDescription('Whether the T bit was set in the LAN Prune Delay option received from this neighbor. The T bit specifies the ability of the neighbor to disable join suppression. This object is always TRUE if hwPimNeighborLanPruneDelayPresent is FALSE.')
hwPimNeighborPropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborPropagationDelay.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimNeighborPropagationDelay.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborPropagationDelay.setDescription('The value of the Propagation_Delay field of the LAN Prune Delay option received from this neighbor. This object is always zero if hwPimNeighborLanPruneDelayPresent is FALSE.')
hwPimNeighborOverrideInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborOverrideInterval.setReference('RFC 4601 section 4.3.3')
if mibBuilder.loadTexts: hwPimNeighborOverrideInterval.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborOverrideInterval.setDescription('The value of the Override_Interval field of the LAN Prune Delay option received from this neighbor. This object is always zero if hwPimNeighborLanPruneDelayPresent is FALSE.')
hwPimNeighborBidirCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborBidirCapable.setReference('I-D.ietf-pim-bidir section 3.2 and 3.7.4')
if mibBuilder.loadTexts: hwPimNeighborBidirCapable.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborBidirCapable.setDescription('Evaluates to TRUE if this neighbor is using the Bidirectional-PIM Capable option.')
hwPimNeighborSrCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNeighborSrCapable.setReference('RFC 3973 section 4.3.4')
if mibBuilder.loadTexts: hwPimNeighborSrCapable.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborSrCapable.setDescription('Evaluates to TRUE if this neighbor is using the State Refresh Capable option. This object is used only by PIM-DM.')
hwPimNeighborIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwPimNeighborIfName.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborIfName.setDescription('The name for the interface used to reach this PIM neighbor.')
hwPimNbrSecAddressTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3), )
if mibBuilder.loadTexts: hwPimNbrSecAddressTable.setReference('RFC 4601 section 4.3.4')
if mibBuilder.loadTexts: hwPimNbrSecAddressTable.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddressTable.setDescription('The (conceptual) table listing the secondary addresses advertised by each PIM neighbor (on a subset of the rows of the hwPimNeighborTable defined above).')
hwPimNbrSecAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimNbrSecAddressIfIndex"), (0, "HUAWEI-PIM-STD-MIB", "hwPimNbrSecAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimNbrSecAddressPrimary"), (0, "HUAWEI-PIM-STD-MIB", "hwPimNbrSecAddress"))
if mibBuilder.loadTexts: hwPimNbrSecAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddressEntry.setDescription('An entry (conceptual row) in the hwPimNbrSecAddressTable.')
hwPimNbrSecAddressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimNbrSecAddressIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddressIfIndex.setDescription('The value of ifIndex for the interface used to reach this PIM neighbor.')
hwPimNbrSecAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3, 1, 2), InetAddressType())
if mibBuilder.loadTexts: hwPimNbrSecAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddressType.setDescription('The address type of this PIM neighbor.')
hwPimNbrSecAddressPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimNbrSecAddressPrimary.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddressPrimary.setDescription('The primary IP address of this PIM neighbor. The InetAddressType is given by the hwPimNbrSecAddressType object.')
hwPimNbrSecAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 3, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimNbrSecAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimNbrSecAddress.setDescription('The secondary IP address of this PIM neighbor. The InetAddressType is given by the hwPimNbrSecAddressType object.')
hwPimStarGTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4), )
if mibBuilder.loadTexts: hwPimStarGTable.setReference('RFC 4601 section 4.1.3')
if mibBuilder.loadTexts: hwPimStarGTable.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGTable.setDescription('The (conceptual) table listing the non-interface specific (*,G) state that PIM has.')
hwPimStarGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimStarGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimStarGGrpAddress"))
if mibBuilder.loadTexts: hwPimStarGEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGEntry.setDescription('An entry (conceptual row) in the hwPimStarGTable.')
hwPimStarGAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: hwPimStarGAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGAddressType.setDescription('The address type of this multicast group.')
hwPimStarGGrpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimStarGGrpAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGGrpAddress.setDescription('The multicast group address. The InetAddressType is given by the hwPimStarGAddressType object.')
hwPimStarGUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGUpTime.setDescription('The time since this entry was created by the local router.')
hwPimStarGPimMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 4), HWPimMode().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("asm", 3), ("bidir", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGPimMode.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGPimMode.setDescription('Whether this entry represents an ASM (Any Source Multicast, used with PIM-SM) or BIDIR-PIM group.')
hwPimStarGRpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpAddressType.setDescription('The address type of the Rendezvous Point (RP), or unknown(0) if the RP address is unknown.')
hwPimStarGRpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpAddress.setDescription('The address of the Rendezvous Point (RP) for the group. The InetAddressType is given by the hwPimStarGRpAddressType.')
hwPimStarGPimModeOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 7), HWPimGroupMappingOriginType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGPimModeOrigin.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGPimModeOrigin.setDescription('The mechanism by which the PIM mode and RP for the group were learned.')
hwPimStarGRpIsLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpIsLocal.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpIsLocal.setDescription('Whether the local router is the RP for the group.')
hwPimStarGUpstreamJoinState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notJoined", 1), ("joined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinState.setReference('RFC 4601 section 4.5.6')
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinState.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinState.setDescription('Whether the local router should join the RP tree for the group. This corresponds to the state of the upstream (*,G) state machine in the PIM-SM specification.')
hwPimStarGUpstreamJoinTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinTimer.setReference('RFC 4601 section 4.10')
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGUpstreamJoinTimer.setDescription('The time remaining before the local router next sends a periodic (*,G) Join message on hwPimStarGRpfIfIndex. This timer is called the (*,G) Upstream Join Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimStarGUpstreamNeighborType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 11), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGUpstreamNeighborType.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGUpstreamNeighborType.setDescription('The primary address type of the upstream neighbor, or unknown(0) if the upstream neighbor address is unknown or is not a PIM neighbor.')
hwPimStarGUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 12), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGUpstreamNeighbor.setReference('RFC 4601 section 4.1.6')
if mibBuilder.loadTexts: hwPimStarGUpstreamNeighbor.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGUpstreamNeighbor.setDescription("The primary address of the neighbor on hwPimStarGRpfIfIndex that the local router is sending periodic (*,G) Join messages to. The InetAddressType is given by the hwPimStarGUpstreamNeighborType object. This address is called RPF'(*,G) in the PIM-SM specification.")
hwPimStarGRpfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 13), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfIfIndex.setDescription('The value of ifIndex for the RPF interface towards the RP, or zero if the RPF interface is unknown.')
hwPimStarGRpfNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 14), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfNextHopType.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfNextHopType.setDescription('The address type of the RPF next hop towards the RP, or unknown(0) if the RPF next hop is unknown.')
hwPimStarGRpfNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 15), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfNextHop.setReference('RFC 4601 section 4.5.5')
if mibBuilder.loadTexts: hwPimStarGRpfNextHop.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfNextHop.setDescription('The address of the RPF next hop towards the RP. The InetAddressType is given by the hwPimStarGRpfNextHopType object. This address is called MRIB.next_hop(RP(G)) in the PIM-SM specification.')
hwPimStarGRpfRouteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 16), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfRouteProtocol.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfRouteProtocol.setDescription('The routing mechanism via which the route used to find the RPF interface towards the RP was learned.')
hwPimStarGRpfRouteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 17), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfRouteAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfRouteAddress.setDescription('The IP address which when combined with the corresponding value of hwPimStarGRpfRoutePrefixLength identifies the route used to find the RPF interface towards the RP. The InetAddressType is given by the hwPimStarGRpfNextHopType object. This address object is only significant up to hwPimStarGRpfRoutePrefixLength bits. The remainder of the address bits are zero.')
hwPimStarGRpfRoutePrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 18), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfRoutePrefixLength.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfRoutePrefixLength.setDescription('The prefix length which when combined with the corresponding value of hwPimStarGRpfRouteAddress identifies the route used to find the RPF interface towards the RP. The InetAddressType is given by the hwPimStarGRpfNextHopType object.')
hwPimStarGRpfRouteMetricPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfRouteMetricPref.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfRouteMetricPref.setDescription('The metric preference of the route used to find the RPF interface towards the RP.')
hwPimStarGRpfRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 4, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGRpfRouteMetric.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGRpfRouteMetric.setDescription('The routing metric of the route used to find the RPF interface towards the RP.')
hwPimStarGITable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5), )
if mibBuilder.loadTexts: hwPimStarGITable.setReference('RFC 4601 section 4.1.3')
if mibBuilder.loadTexts: hwPimStarGITable.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGITable.setDescription('The (conceptual) table listing the interface-specific (*,G) state that PIM has.')
hwPimStarGIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimStarGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimStarGGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimStarGIIfIndex"))
if mibBuilder.loadTexts: hwPimStarGIEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIEntry.setDescription('An entry (conceptual row) in the hwPimStarGITable.')
hwPimStarGIIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimStarGIIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIIfIndex.setDescription('The ifIndex of the interface that this entry corresponds to.')
hwPimStarGIUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIUpTime.setDescription('The time since this entry was created by the local router.')
hwPimStarGILocalMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGILocalMembership.setReference('RFC 3376, RFC 3810, RFC 4601 section 4.1.6')
if mibBuilder.loadTexts: hwPimStarGILocalMembership.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGILocalMembership.setDescription('Whether the local router has (*,G) local membership on this interface (resulting from a mechanism such as IGMP or MLD). This corresponds to local_receiver_include(*,G,I) in the PIM-SM specification.')
hwPimStarGIJoinPruneState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInfo", 1), ("join", 2), ("prunePending", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIJoinPruneState.setReference('RFC 4601 section 4.5.2')
if mibBuilder.loadTexts: hwPimStarGIJoinPruneState.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIJoinPruneState.setDescription('The state resulting from (*,G) Join/Prune messages received on this interface. This corresponds to the state of the downstream per-interface (*,G) state machine in the PIM-SM specification.')
hwPimStarGIPrunePendingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIPrunePendingTimer.setReference('RFC 4601 section 4.5.1')
if mibBuilder.loadTexts: hwPimStarGIPrunePendingTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIPrunePendingTimer.setDescription('The time remaining before the local router acts on a (*,G) Prune message received on this interface, during which the router is waiting to see whether another downstream router will override the Prune message. This timer is called the (*,G) Prune-Pending Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimStarGIJoinExpiryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIJoinExpiryTimer.setReference('RFC 4601 section 4.10')
if mibBuilder.loadTexts: hwPimStarGIJoinExpiryTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIJoinExpiryTimer.setDescription("The time remaining before (*,G) Join state for this interface expires. This timer is called the (*,G) Join Expiry Timer in the PIM-SM specification. This object is zero if the timer is not running. A value of 'FFFFFFFF'h indicates an infinite expiry time.")
hwPimStarGIAssertState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInfo", 1), ("iAmAssertWinner", 2), ("iAmAssertLoser", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertState.setReference('RFC 4601 section 4.6.2')
if mibBuilder.loadTexts: hwPimStarGIAssertState.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertState.setDescription("The (*,G) Assert state for this interface. This corresponds to the state of the per-interface (*,G) Assert state machine in the PIM-SM specification. If hwPimStarGPimMode is 'bidir', this object must be 'noInfo'.")
hwPimStarGIAssertTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertTimer.setReference('RFC 4601 section 4.6.2')
if mibBuilder.loadTexts: hwPimStarGIAssertTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertTimer.setDescription("If hwPimStarGIAssertState is 'iAmAssertWinner', this is the time remaining before the local router next sends a (*,G) Assert message on this interface. If hwPimStarGIAssertState is 'iAmAssertLoser', this is the time remaining before the (*,G) Assert state expires. If hwPimStarGIAssertState is 'noInfo', this is zero. This timer is called the (*,G) Assert Timer in the PIM-SM specification.")
hwPimStarGIAssertWinnerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerAddressType.setDescription("If hwPimStarGIAssertState is 'iAmAssertLoser', this is the address type of the assert winner; otherwise, this object is unknown(0).")
hwPimStarGIAssertWinnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 10), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerAddress.setDescription("If hwPimStarGIAssertState is 'iAmAssertLoser', this is the address of the assert winner. The InetAddressType is given by the hwPimStarGIAssertWinnerAddressType object.")
hwPimStarGIAssertWinnerMetricPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerMetricPref.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerMetricPref.setDescription("If hwPimStarGIAssertState is 'iAmAssertLoser', this is the metric preference of the route to the RP advertised by the assert winner; otherwise, this object is zero.")
hwPimStarGIAssertWinnerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 5, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerMetric.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGIAssertWinnerMetric.setDescription("If hwPimStarGIAssertState is 'iAmAssertLoser', this is the routing metric of the route to the RP advertised by the assert winner; otherwise, this object is zero.")
hwPimSGTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6), )
if mibBuilder.loadTexts: hwPimSGTable.setReference('RFC 4601 section 4.1.4')
if mibBuilder.loadTexts: hwPimSGTable.setStatus('current')
if mibBuilder.loadTexts: hwPimSGTable.setDescription('The (conceptual) table listing the non-interface specific (S,G) state that PIM has.')
hwPimSGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimSGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGSrcAddress"))
if mibBuilder.loadTexts: hwPimSGEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimSGEntry.setDescription('An entry (conceptual row) in the hwPimSGTable.')
hwPimSGAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: hwPimSGAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimSGAddressType.setDescription('The address type of the source and multicast group for this entry.')
hwPimSGGrpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimSGGrpAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGGrpAddress.setDescription('The multicast group address for this entry. The InetAddressType is given by the hwPimSGAddressType object.')
hwPimSGSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimSGSrcAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGSrcAddress.setDescription('The source address for this entry. The InetAddressType is given by the hwPimSGAddressType object.')
hwPimSGUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpTime.setDescription('The time since this entry was created by the local router.')
hwPimSGPimMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 5), HWPimMode().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("ssm", 2), ("asm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGPimMode.setReference('RFC 4601 section 4.5.2, RFC 3569 and I-D.ietf-mboned-ip-mcast-mib ipMcastSsmRangeTable')
if mibBuilder.loadTexts: hwPimSGPimMode.setStatus('current')
if mibBuilder.loadTexts: hwPimSGPimMode.setDescription('Whether hwPimSGGrpAddress is an SSM (Source Specific Multicast, used with PIM-SM) or ASM (Any Source Multicast, used with PIM-SM) group.')
hwPimSGUpstreamJoinState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notJoined", 1), ("joined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpstreamJoinState.setReference('RFC 4601 section 4.5.7')
if mibBuilder.loadTexts: hwPimSGUpstreamJoinState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpstreamJoinState.setDescription('Whether the local router should join the shortest-path tree for the source and group represented by this entry. This corresponds to the state of the upstream (S,G) state machine in the PIM-SM specification.')
hwPimSGUpstreamJoinTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpstreamJoinTimer.setReference('RFC 4601 section 4.10 and 4.11')
if mibBuilder.loadTexts: hwPimSGUpstreamJoinTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpstreamJoinTimer.setDescription('The time remaining before the local router next sends a periodic (S,G) Join message on hwPimSGRpfIfIndex. This timer is called the (S,G) Upstream Join Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimSGUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpstreamNeighbor.setReference('RFC 4601 section 4.1.6')
if mibBuilder.loadTexts: hwPimSGUpstreamNeighbor.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpstreamNeighbor.setDescription("The primary address of the neighbor on hwPimSGRpfIfIndex that the local router is sending periodic (S,G) Join messages to. This is zero if the RPF next hop is unknown or is not a PIM neighbor. The InetAddressType is given by the hwPimSGAddressType object. This address is called RPF'(S,G) in the PIM-SM specification.")
hwPimSGRpfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfIfIndex.setDescription('The value of ifIndex for the RPF interface towards the source, or zero if the RPF interface is unknown.')
hwPimSGRpfNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfNextHopType.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfNextHopType.setDescription('The address type of the RPF next hop towards the source, or unknown(0) if the RPF next hop is unknown.')
hwPimSGRpfNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 11), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfNextHop.setReference('RFC 4601 section 4.5.5')
if mibBuilder.loadTexts: hwPimSGRpfNextHop.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfNextHop.setDescription('The address of the RPF next hop towards the source. The InetAddressType is given by the hwPimSGRpfNextHopType. This address is called MRIB.next_hop(S) in the PIM-SM specification.')
hwPimSGRpfRouteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 12), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfRouteProtocol.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfRouteProtocol.setDescription('The routing mechanism via which the route used to find the RPF interface towards the source was learned.')
hwPimSGRpfRouteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 13), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfRouteAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfRouteAddress.setDescription('The IP address which when combined with the corresponding value of hwPimSGRpfRoutePrefixLength identifies the route used to find the RPF interface towards the source. The InetAddressType is given by the hwPimSGRpfNextHopType object. This address object is only significant up to hwPimSGRpfRoutePrefixLength bits. The remainder of the address bits are zero.')
hwPimSGRpfRoutePrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 14), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfRoutePrefixLength.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfRoutePrefixLength.setDescription('The prefix length which when combined with the corresponding value of hwPimSGRpfRouteAddress identifies the route used to find the RPF interface towards the source. The InetAddressType is given by the hwPimSGRpfNextHopType object.')
hwPimSGRpfRouteMetricPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfRouteMetricPref.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfRouteMetricPref.setDescription('The metric preference of the route used to find the RPF interface towards the source.')
hwPimSGRpfRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpfRouteMetric.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpfRouteMetric.setDescription('The routing metric of the route used to find the RPF interface towards the source.')
hwPimSGSptBit = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGSptBit.setStatus('current')
if mibBuilder.loadTexts: hwPimSGSptBit.setDescription('Whether the SPT bit is set; and therefore whether forwarding is taking place on the shortest-path tree.')
hwPimSGKeepaliveTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 18), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGKeepaliveTimer.setReference('RFC 4601 section 4.1.4')
if mibBuilder.loadTexts: hwPimSGKeepaliveTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGKeepaliveTimer.setDescription('The time remaining before, in the absence of explicit (S,G) local membership or (S,G) Join messages received to maintain it, this (S,G) state expires. This timer is called the (S,G) Keepalive Timer in the PIM-SM specification.')
hwPimSGDrRegisterState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noInfo", 1), ("join", 2), ("joinPending", 3), ("prune", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGDrRegisterState.setReference('RFC 4601 section 4.4.1')
if mibBuilder.loadTexts: hwPimSGDrRegisterState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGDrRegisterState.setDescription("Whether the local router should encapsulate (S,G) data packets in Register messages and send them to the RP. This corresponds to the state of the per-(S,G) Register state machine in the PIM-SM specification. This object is always 'noInfo' unless hwPimSGPimMode is 'asm'.")
hwPimSGDrRegisterStopTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGDrRegisterStopTimer.setReference('RFC 4601 section 4.4')
if mibBuilder.loadTexts: hwPimSGDrRegisterStopTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGDrRegisterStopTimer.setDescription("If hwPimSGDrRegisterState is 'prune', this is the time remaining before the local router sends a Null-Register message to the RP. If hwPimSGDrRegisterState is 'joinPending', this is the time remaining before the local router resumes encapsulating data packets and sending them to the RP. Otherwise, this is zero. This timer is called the Register-Stop Timer in the PIM-SM specification.")
hwPimSGRpRegisterPmbrAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 21), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpRegisterPmbrAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpRegisterPmbrAddressType.setDescription('The address type of the first PIM Multicast Border Router to send a Register message with the Border bit set. This object is unknown(0) if the local router is not the RP for the group.')
hwPimSGRpRegisterPmbrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 22), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRpRegisterPmbrAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRpRegisterPmbrAddress.setDescription('The IP address of the first PIM Multicast Border Router to send a Register message with the Border bit set. The InetAddressType is given by the hwPimSGRpRegisterPmbrAddressType object.')
hwPimSGUpstreamPruneState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forwarding", 1), ("ackpending", 2), ("pruned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpstreamPruneState.setReference('RFC 3973 section 4.4.1')
if mibBuilder.loadTexts: hwPimSGUpstreamPruneState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpstreamPruneState.setDescription('Whether the local router has pruned itself from the tree. This corresponds to the state of the upstream prune (S,G) state machine in the PIM-DM specification. This object is used only by PIM-DM.')
hwPimSGUpstreamPruneLimitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGUpstreamPruneLimitTimer.setReference('RFC 2973 section 4.8')
if mibBuilder.loadTexts: hwPimSGUpstreamPruneLimitTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGUpstreamPruneLimitTimer.setDescription('The time remaining before the local router may send a (S,G) Prune message on hwPimSGRpfIfIndex. This timer is called the (S,G) Prune Limit Timer in the PIM-DM specification. This object is zero if the timer is not running. This object is used only by PIM-DM.')
hwPimSGOriginatorState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notOriginator", 1), ("originator", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGOriginatorState.setReference('RFC 3973 section 4.5.2')
if mibBuilder.loadTexts: hwPimSGOriginatorState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGOriginatorState.setDescription('Whether the router is an originator for an (S,G) message flow. This corresponds to the state of the per-(S,G) Originator state machine in the PIM-DM specification. This object is used only by PIM-DM.')
hwPimSGSourceActiveTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 26), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGSourceActiveTimer.setReference('RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimSGSourceActiveTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGSourceActiveTimer.setDescription("If hwPimSGOriginatorState is 'originator', this is the time remaining before the local router reverts to a notOriginator state. Otherwise, this is zero. This timer is called the Source Active Timer in the PIM-DM specification. This object is used only by PIM-DM.")
hwPimSGStateRefreshTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 6, 1, 27), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGStateRefreshTimer.setReference('RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimSGStateRefreshTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGStateRefreshTimer.setDescription("If hwPimSGOriginatorState is 'originator', this is the time remaining before the local router sends a State Refresh message. Otherwise, this is zero. This timer is called the State Refresh Timer in the PIM-DM specification. This object is used only by PIM-DM.")
hwPimSGITable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7), )
if mibBuilder.loadTexts: hwPimSGITable.setReference('RFC 4601 section 4.1.4')
if mibBuilder.loadTexts: hwPimSGITable.setStatus('current')
if mibBuilder.loadTexts: hwPimSGITable.setDescription('The (conceptual) table listing the interface-specific (S,G) state that PIM has.')
hwPimSGIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimSGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGSrcAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGIIfIndex"))
if mibBuilder.loadTexts: hwPimSGIEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIEntry.setDescription('An entry (conceptual row) in the hwPimSGITable.')
hwPimSGIIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimSGIIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIIfIndex.setDescription('The ifIndex of the interface that this entry corresponds to.')
hwPimSGIUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIUpTime.setDescription('The time since this entry was created by the local router.')
hwPimSGILocalMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGILocalMembership.setReference('RFC 3376, RFC 3810, RFC 4601 sections 4.1.6, 4.6.1 and 4.6.2')
if mibBuilder.loadTexts: hwPimSGILocalMembership.setStatus('current')
if mibBuilder.loadTexts: hwPimSGILocalMembership.setDescription('Whether the local router has (S,G) local membership on this interface (resulting from a mechanism such as IGMP or MLD). This corresponds to local_receiver_include(S,G,I) in the PIM-SM specification.')
hwPimSGIJoinPruneState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInfo", 1), ("join", 2), ("prunePending", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIJoinPruneState.setReference('RFC 4601 section 4.5.3 and RFC 3973 section 4.4.2')
if mibBuilder.loadTexts: hwPimSGIJoinPruneState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIJoinPruneState.setDescription('The state resulting from (S,G) Join/Prune messages received on this interface. This corresponds to the state of the downstream per-interface (S,G) state machine in the PIM-SM and PIM-DM specification.')
hwPimSGIPrunePendingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIPrunePendingTimer.setReference('RFC 4601 section 4.5.3 and 4.5.4')
if mibBuilder.loadTexts: hwPimSGIPrunePendingTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIPrunePendingTimer.setDescription('The time remaining before the local router acts on an (S,G) Prune message received on this interface, during which the router is waiting to see whether another downstream router will override the Prune message. This timer is called the (S,G) Prune-Pending Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimSGIJoinExpiryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIJoinExpiryTimer.setReference('RFC 4601 section 4.10 and RFC 3973 section 4.8')
if mibBuilder.loadTexts: hwPimSGIJoinExpiryTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIJoinExpiryTimer.setDescription("The time remaining before (S,G) Join state for this interface expires. This timer is called the (S,G) Join Expiry Timer in the PIM-SM specification. This object is zero if the timer is not running. A value of 'FFFFFFFF'h indicates an infinite expiry time. This timer is called the (S,G) Prune Timer in the PIM-DM specification.")
hwPimSGIAssertState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInfo", 1), ("iAmAssertWinner", 2), ("iAmAssertLoser", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertState.setReference('RFC 4601 section 4.6.1')
if mibBuilder.loadTexts: hwPimSGIAssertState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertState.setDescription('The (S,G) Assert state for this interface. This corresponds to the state of the per-interface (S,G) Assert state machine in the PIM-SM specification.')
hwPimSGIAssertTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertTimer.setReference('RFC 4601 section 4.6.1')
if mibBuilder.loadTexts: hwPimSGIAssertTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertTimer.setDescription("If hwPimSGIAssertState is 'iAmAssertWinner', this is the time remaining before the local router next sends a (S,G) Assert message on this interface. If hwPimSGIAssertState is 'iAmAssertLoser', this is the time remaining before the (S,G) Assert state expires. If hwPimSGIAssertState is 'noInfo', this is zero. This timer is called the (S,G) Assert Timer in the PIM-SM specification.")
hwPimSGIAssertWinnerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertWinnerAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertWinnerAddressType.setDescription("If hwPimSGIAssertState is 'iAmAssertLoser', this is the address type of the assert winner; otherwise, this object is unknown(0).")
hwPimSGIAssertWinnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 10), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertWinnerAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertWinnerAddress.setDescription("If hwPimSGIAssertState is 'iAmAssertLoser', this is the address of the assert winner. The InetAddressType is given by the hwPimSGIAssertWinnerAddressType object.")
hwPimSGIAssertWinnerMetricPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertWinnerMetricPref.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertWinnerMetricPref.setDescription("If hwPimSGIAssertState is 'iAmAssertLoser', this is the metric preference of the route to the source advertised by the assert winner; otherwise, this object is zero.")
hwPimSGIAssertWinnerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 7, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGIAssertWinnerMetric.setStatus('current')
if mibBuilder.loadTexts: hwPimSGIAssertWinnerMetric.setDescription("If hwPimSGIAssertState is 'iAmAssertLoser', this is the routing metric of the route to the source advertised by the assert winner; otherwise, this object is zero.")
hwPimSGRptTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8), )
if mibBuilder.loadTexts: hwPimSGRptTable.setReference('RFC 4601 section 4.1.5')
if mibBuilder.loadTexts: hwPimSGRptTable.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptTable.setDescription('The (conceptual) table listing the non-interface specific (S,G,rpt) state that PIM has.')
hwPimSGRptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimStarGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimStarGGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGRptSrcAddress"))
if mibBuilder.loadTexts: hwPimSGRptEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptEntry.setDescription('An entry (conceptual row) in the hwPimSGRptTable.')
hwPimSGRptSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8, 1, 1), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimSGRptSrcAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptSrcAddress.setDescription('The source address for this entry. The InetAddressType is given by the hwPimStarGAddressType object.')
hwPimSGRptUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptUpTime.setDescription('The time since this entry was created by the local router.')
hwPimSGRptUpstreamPruneState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rptNotJoined", 1), ("pruned", 2), ("notPruned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptUpstreamPruneState.setReference('RFC 4601 section 4.5.9')
if mibBuilder.loadTexts: hwPimSGRptUpstreamPruneState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptUpstreamPruneState.setDescription('Whether the local router should prune the source off the RP tree. This corresponds to the state of the upstream (S,G,rpt) state machine for triggered messages in the PIM-SM specification.')
hwPimSGRptUpstreamOverrideTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 8, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptUpstreamOverrideTimer.setReference('RFC 4601 section 4.5.9')
if mibBuilder.loadTexts: hwPimSGRptUpstreamOverrideTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptUpstreamOverrideTimer.setDescription('The time remaining before the local router sends a triggered (S,G,rpt) Join message on hwPimStarGRpfIfIndex. This timer is called the (S,G,rpt) Upstream Override Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimSGRptITable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9), )
if mibBuilder.loadTexts: hwPimSGRptITable.setReference('RFC 4601 section 4.1.5')
if mibBuilder.loadTexts: hwPimSGRptITable.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptITable.setDescription('The (conceptual) table listing the interface-specific (S,G,rpt) state that PIM has.')
hwPimSGRptIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimStarGAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimStarGGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGRptSrcAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimSGRptIIfIndex"))
if mibBuilder.loadTexts: hwPimSGRptIEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIEntry.setDescription('An entry (conceptual row) in the hwPimSGRptITable.')
hwPimSGRptIIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimSGRptIIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIIfIndex.setDescription('The ifIndex of the interface that this entry corresponds to.')
hwPimSGRptIUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptIUpTime.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIUpTime.setDescription('The time since this entry was created by the local router.')
hwPimSGRptILocalMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptILocalMembership.setReference('RFC 3376, RFC 3810, RFC 4601 section 4.1.6')
if mibBuilder.loadTexts: hwPimSGRptILocalMembership.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptILocalMembership.setDescription('Whether the local router has both (*,G) include local membership and (S,G) exclude local membership on this interface (resulting from a mechanism such as IGMP or MLD). This corresponds to local_receiver_exclude(S,G,I) in the PIM-SM specification.')
hwPimSGRptIJoinPruneState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInfo", 1), ("prune", 2), ("prunePending", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptIJoinPruneState.setReference('RFC 4601 section 4.5.4')
if mibBuilder.loadTexts: hwPimSGRptIJoinPruneState.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIJoinPruneState.setDescription('The state resulting from (S,G,rpt) Join/Prune messages received on this interface. This corresponds to the state of the downstream per-interface (S,G,rpt) state machine in the PIM-SM specification.')
hwPimSGRptIPrunePendingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptIPrunePendingTimer.setReference('RFC 4601 section 4.5.4')
if mibBuilder.loadTexts: hwPimSGRptIPrunePendingTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIPrunePendingTimer.setDescription('The time remaining before the local router starts pruning this source off the RP tree. This timer is called the (S,G,rpt) Prune-Pending Timer in the PIM-SM specification. This object is zero if the timer is not running.')
hwPimSGRptIPruneExpiryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 9, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimSGRptIPruneExpiryTimer.setReference('RFC 4601 section 4.5.4')
if mibBuilder.loadTexts: hwPimSGRptIPruneExpiryTimer.setStatus('current')
if mibBuilder.loadTexts: hwPimSGRptIPruneExpiryTimer.setDescription("The time remaining before (S,G,rpt) Prune state for this interface expires. This timer is called the (S,G,rpt) Prune Expiry Timer in the PIM-SM specification. This object is zero if the timer is not running. A value of 'FFFFFFFF'h indicates an infinite expiry time.")
hwPimGroupMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13), )
if mibBuilder.loadTexts: hwPimGroupMappingTable.setReference('RFC 4601 section 3.7, RFC 3956 and RFC 4610')
if mibBuilder.loadTexts: hwPimGroupMappingTable.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingTable.setDescription("The (conceptual) table listing mappings from multicast group prefixes to the PIM mode and RP address to use for groups within that group prefix. Rows in this table are created for a variety of reasons, indicated by the value of the hwPimGroupMappingOrigin object. - Rows with a hwPimGroupMappingOrigin value of 'fixed' are created automatically by the router at startup, to correspond to the well-defined prefixes of link-local and unroutable group addresses. These rows are never destroyed. - Rows with a hwPimGroupMappingOrigin value of 'embedded' are created by the router to correspond to group prefixes that are to be treated as being in Embedded-RP format. - Rows with a hwPimGroupMappingOrigin value of 'configRp' are created and destroyed as a result of rows in the pimStaticRPTable being created and destroyed. - Rows with a hwPimGroupMappingOrigin value of 'configSsm' are created and destroyed as a result of configuration of SSM address ranges to the local router. - Rows with a hwPimGroupMappingOrigin value of 'bsr' are created as a result of running the PIM Bootstrap Router (BSR) mechanism. If the local router is not the elected BSR, these rows are created to correspond to group prefixes in the PIM Bootstrap messages received from the elected BSR. If the local router is the elected BSR, these rows are created to correspond to group prefixes in the PIM Bootstrap messages that the local router sends. In either case, these rows are destroyed when the group prefixes are timed out by the BSR mechanism. - Rows with a hwPimGroupMappingOrigin value of 'other' are created and destroyed according to some other mechanism not specified here. Given the collection of rows in this table at any point in time, the PIM mode and RP address to use for a particular group is determined using the following algorithm. 1. From the set of all rows, the subset whose group prefix contains the group in question are selected. 2. If there are no such rows, the behavior is undefined. 3. From the selected subset of rows, the subset that have the greatest value of hwPimGroupMappingGrpPrefixLength are selected. 4. If there are multiple selected rows, and a subset are defined by pimStaticRPTable (hwPimGroupMappingOrigin value of 'configRp') with pimStaticRPOverrideDynamic set to TRUE, then this subset is selected. 5. If there are still multiple selected rows, the subset that have the highest precedence (the lowest numerical value for hwPimGroupMappingPrecedence) are selected. 6. If there are still multiple selected rows, the row selected is implementation dependent; the implementation might or might not apply the PIM hash function to select the row. 7. The group mode to use is given by the value of hwPimGroupMappingPimMode from the single selected row; the RP to use is given by the value of hwPimGroupMappingRpAddress, unless hwPimGroupMappingOrigin is 'embedded', in which case the RP is extracted from the group address in question.")
hwPimGroupMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingOrigin"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingGrpAddress"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingGrpPrefixLength"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingRpAddressType"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGroupMappingRpAddress"))
if mibBuilder.loadTexts: hwPimGroupMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingEntry.setDescription('An entry (conceptual row) in the hwPimGroupMappingTable.')
hwPimGroupMappingOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 1), HWPimGroupMappingOriginType())
if mibBuilder.loadTexts: hwPimGroupMappingOrigin.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingOrigin.setDescription('The mechanism by which this group mapping was learned.')
hwPimGroupMappingAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 2), InetAddressType())
if mibBuilder.loadTexts: hwPimGroupMappingAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingAddressType.setDescription('The address type of the IP multicast group prefix.')
hwPimGroupMappingGrpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimGroupMappingGrpAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingGrpAddress.setDescription('The IP multicast group address which, when combined with hwPimGroupMappingGrpPrefixLength, gives the group prefix for this mapping. The InetAddressType is given by the hwPimGroupMappingAddressType object. This address object is only significant up to hwPimGroupMappingGrpPrefixLength bits. The remainder of the address bits are zero. This is especially important for this index field, which is part of the index of this entry. Any non-zero bits would signify an entirely different entry.')
hwPimGroupMappingGrpPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 4), InetAddressPrefixLength().subtype(subtypeSpec=ValueRangeConstraint(4, 128)))
if mibBuilder.loadTexts: hwPimGroupMappingGrpPrefixLength.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingGrpPrefixLength.setDescription("The multicast group prefix length, which, when combined with hwPimGroupMappingGrpAddress, gives the group prefix for this mapping. The InetAddressType is given by the hwPimGroupMappingAddressType object. If hwPimGroupMappingAddressType is 'ipv4' or 'ipv4z', this object must be in the range 4..32. If hwPimGroupMappingAddressType is 'ipv6' or 'ipv6z', this object must be in the range 8..128.")
hwPimGroupMappingRpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 5), InetAddressType())
if mibBuilder.loadTexts: hwPimGroupMappingRpAddressType.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingRpAddressType.setDescription('The address type of the RP to be used for groups within this group prefix, or unknown(0) if no RP is to be used or if the RP address is unknown. This object must be unknown(0) if hwPimGroupMappingPimMode is ssm(2), or if hwPimGroupMappingOrigin is embedded(6).')
hwPimGroupMappingRpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(8, 8), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: hwPimGroupMappingRpAddress.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingRpAddress.setDescription('The IP address of the RP to be used for groups within this group prefix. The InetAddressType is given by the hwPimGroupMappingRpAddressType object.')
hwPimGroupMappingPimMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 7), HWPimMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGroupMappingPimMode.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingPimMode.setDescription('The PIM mode to be used for groups in this group prefix.')
hwPimGroupMappingPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 13, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGroupMappingPrecedence.setStatus('current')
if mibBuilder.loadTexts: hwPimGroupMappingPrecedence.setDescription('The precedence of this row, used in the algorithm that determines which row applies to a given group address (described above). Numerically higher values for this object indicate lower precedences, with the value zero denoting the highest precedence. The absolute values of this object have a significance only on the local router and do not need to be coordinated with other routers.')
hwPimInterfaceCtlMsgCountTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58), )
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountTable.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountTable.setDescription('The (conceptual) table listing the control message counter of all PIM interfaces.')
hwPimInterfaceCtlMsgCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimInterfaceCtlMsgCountIfIndex"), (0, "HUAWEI-PIM-STD-MIB", "hwPimInterfaceCtlMsgCountIpVersion"), (0, "HUAWEI-PIM-STD-MIB", "hwPimInterfaceCtlMsgCountMsgState"))
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountEntry.setDescription('An entry (conceptual row) in the hwPimCtlMsgCountTable. This entry is preserved on agent restart.')
hwPimInterfaceCtlMsgCountIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountIfIndex.setDescription('The ifIndex value of this PIM interface.')
hwPimInterfaceCtlMsgCountIpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 2), InetVersion())
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountIpVersion.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountIpVersion.setDescription('The IP version of this PIM interface. A physical interface may be configured in multiple modes concurrently, e.g. IPv4 and IPv6, however the traffic is considered to be logically separate.')
hwPimInterfaceCtlMsgCountMsgState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 3), HWPimCtlMsgState())
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountMsgState.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountMsgState.setDescription('The PIM control message state.')
hwPimInterfaceCtlMsgCountAssert = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountAssert.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountAssert.setDescription('The number of PIM Assert messages on this interface.')
hwPimInterfaceCtlMsgCountHello = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountHello.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountHello.setDescription('The number of PIM Hello messages on this interface.')
hwPimInterfaceCtlMsgCountJoinPrune = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountJoinPrune.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountJoinPrune.setDescription('The number of PIM Join/Prune messages on this interface.')
hwPimInterfaceCtlMsgCountBsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 58, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountBsr.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceCtlMsgCountBsr.setDescription('The number of PIM BSR messages on this interface.')
hwPimGlobalCtlMsgCountTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59), )
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountTable.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountTable.setDescription('The (conceptual) table listing the control message counter on the router.')
hwPimGlobalCtlMsgCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1), ).setIndexNames((0, "HUAWEI-PIM-STD-MIB", "hwPimGlobalCtlMsgCountIpVersion"), (0, "HUAWEI-PIM-STD-MIB", "hwPimGlobalCtlMsgCountMsgState"))
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountEntry.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountEntry.setDescription('An entry (conceptual row) in the hwPimGlobalCtlMsgCountTable. This entry is preserved on agent restart.')
hwPimGlobalCtlMsgCountIpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 1), InetVersion())
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountIpVersion.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountIpVersion.setDescription('The IP version of this PIM instance, e.g. IPv4 and IPv6.')
hwPimGlobalCtlMsgCountMsgState = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 2), HWPimCtlMsgState())
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountMsgState.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountMsgState.setDescription('The PIM control message state.')
hwPimGlobalCtlMsgCountRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountRegister.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountRegister.setDescription('The number of PIM Register messages on the router.')
hwPimGlobalCtlMsgCountRegisterStop = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountRegisterStop.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountRegisterStop.setDescription('The number of PIM Register-stop messages on the router.')
hwPimGlobalCtlMsgCountProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountProbe.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountProbe.setDescription('The number of PIM Probe messages on the router.')
hwPimGlobalCtlMsgCountCrp = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 1, 59, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountCrp.setStatus('current')
if mibBuilder.loadTexts: hwPimGlobalCtlMsgCountCrp.setDescription('The number of PIM CRP messages on the router.')
hwPimNeighborLoss = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 1)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNeighborUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborIfName"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborNotificationReason"))
if mibBuilder.loadTexts: hwPimNeighborLoss.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborLoss.setDescription('A hwPimNeighborLoss notification signifies the loss of an adjacency with a neighbor. This notification should be generated when the neighbor is lost. This notification is generated whenever the counter hwPimNeighborLossCount is incremented, subject to the rate limit specified by hwPimNeighborLossNotificationPeriod.')
if mibBuilder.loadTexts: hwPimNeighborLoss.setReference('RFC 4601 section 4.3.2')
hwPimInvalidRegister = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 2)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterOrigin"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterRp"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimInvalidRegister.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidRegister.setDescription('A hwPimInvalidRegister notification signifies that an invalid PIM Register message was received by this device. This notification is generated whenever the counter hwPimInvalidRegisterMsgsRcvd is incremented, subject to the rate limit specified by hwPimInvalidRegisterNotificationPeriod.')
if mibBuilder.loadTexts: hwPimInvalidRegister.setReference('RFC 4601 section 4.4.2')
hwPimInvalidJoinPrune = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 3)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneOrigin"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneRp"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborIfName"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimInvalidJoinPrune.setStatus('current')
if mibBuilder.loadTexts: hwPimInvalidJoinPrune.setDescription('A hwPimInvalidJoinPrune notification signifies that an invalid PIM Join/Prune message was received by this device. This notification is generated whenever the counter hwPimInvalidJoinPruneMsgsRcvd is incremented, subject to the rate limit specified by hwPimInvalidJoinPruneNotificationPeriod.')
if mibBuilder.loadTexts: hwPimInvalidJoinPrune.setReference('RFC 4601 section 4.5.2')
hwPimRpMappingChange = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 4)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPrecedence"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimRpMappingChange.setStatus('current')
if mibBuilder.loadTexts: hwPimRpMappingChange.setDescription('A hwPimRpMappingChange notification signifies a change to the active RP mapping on this device. This notification is generated whenever the counter hwPimRpMappingChangeCount is incremented, subject to the rate limit specified by pimRPMappingChangeNotificationPeriod.')
hwPimInterfaceElection = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 5)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInterfaceAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceName"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimInterfaceElection.setStatus('current')
if mibBuilder.loadTexts: hwPimInterfaceElection.setDescription('A hwPimInterfaceElection notification signifies that a new DR or DF has been elected on a network. This notification is generated whenever the counter hwPimInterfaceElectionWinCount is incremented, subject to the rate limit specified by hwPimInterfaceElectionNotificationPeriod.')
if mibBuilder.loadTexts: hwPimInterfaceElection.setReference('RFC 4601 section 4.3.2 and I-D.ietf-pim-bidir section 3.5.2')
hwPimNeighborAdd = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 6)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNeighborExpiryTime"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimNeighborAdd.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborAdd.setDescription('A hwPimNeighborAdd notification signifies the new neighbor. This notification should be generated when receiving the hello report of a new neighbor. This notification is generated whenever the counter hwPimNeighborAddCount is incremented, subject to the rate limit specified by hwPimNeighborAddNotificationPeriod.')
if mibBuilder.loadTexts: hwPimNeighborAdd.setReference('RFC 4601 section 4.3.1')
hwPimGRStart = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 7)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGRStartTime"), ("HUAWEI-PIM-STD-MIB", "hwPimGRInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"))
if mibBuilder.loadTexts: hwPimGRStart.setStatus('obsolete')
if mibBuilder.loadTexts: hwPimGRStart.setDescription('A hwPimGRStart notification signifies that the router enters the PIM GR state.')
hwPimGREnd = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 8)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGREndTime"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"))
if mibBuilder.loadTexts: hwPimGREnd.setStatus('obsolete')
if mibBuilder.loadTexts: hwPimGREnd.setDescription('A hwPimGREnd notification signifies that the router leaves the PIM GR state.')
hwPimMrtLimit = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 9)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitSource"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimMrtLimit.setStatus('current')
if mibBuilder.loadTexts: hwPimMrtLimit.setDescription('A hwPimMrtLimit notification signifies that PIM entries cannot be created because the upper limit is crossed.')
hwPimNeighborUnavailable = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 10)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNeighborIfName"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborNotificationReason"))
if mibBuilder.loadTexts: hwPimNeighborUnavailable.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborUnavailable.setDescription('A hwPimNeighborUnavailable notification signifies that the PIM neighbor is unavailable.')
hwPimNeighborUnavailableClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 11)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNeighborIfName"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborNotificationReason"))
if mibBuilder.loadTexts: hwPimNeighborUnavailableClear.setStatus('current')
if mibBuilder.loadTexts: hwPimNeighborUnavailableClear.setDescription('A hwPimNeighborUnavailableClear notification signifies that the PIM neighbor is available.')
hwPimMrtLimitClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 12)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitSource"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimMrtLimitClear.setStatus('current')
if mibBuilder.loadTexts: hwPimMrtLimitClear.setDescription('A hwPimMrtLimit notification signifies that PIM entries can created.')
hwPimStarGThresholdExceed = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 13)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGTotalCount"))
if mibBuilder.loadTexts: hwPimStarGThresholdExceed.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGThresholdExceed.setDescription('A hwPimStarGThresholdExceed notification signifies that PIM (*, G) entries count of all instances reached the upper threshold.')
hwPimStarGThresholdExceedClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 14)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGTotalCount"))
if mibBuilder.loadTexts: hwPimStarGThresholdExceedClear.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGThresholdExceedClear.setDescription('A hwPimStarGThresholdExceedClear notification signifies that PIM (*, G) entries count of all instances fell below the lower threshold.')
hwPimStarGExceed = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 15)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationSrcAddr"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGrpAddr"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGTotalCount"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimStarGExceed.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGExceed.setDescription('A hwPimStarGExceed notification signifies that PIM (*, G) entries count of all instances reached the limit.')
hwPimStarGExceedClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 16)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"))
if mibBuilder.loadTexts: hwPimStarGExceedClear.setStatus('current')
if mibBuilder.loadTexts: hwPimStarGExceedClear.setDescription('A hwPimStarGExceedClear notification signifies that PIM(*, G) entries count of all instances fell below the limit.')
hwPimSGThresholdExceed = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 17)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimSGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimSGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimSGTotalCount"))
if mibBuilder.loadTexts: hwPimSGThresholdExceed.setStatus('current')
if mibBuilder.loadTexts: hwPimSGThresholdExceed.setDescription('A hwPimSGThresholdExceed notification signifies that PIM (S, G) entries count of all instances reached the upper threshold.')
hwPimSGThresholdExceedClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 18)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimSGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimSGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimSGTotalCount"))
if mibBuilder.loadTexts: hwPimSGThresholdExceedClear.setStatus('current')
if mibBuilder.loadTexts: hwPimSGThresholdExceedClear.setDescription('A hwPimSGThresholdExceedClear notification signifies that PIM (S, G) entries count of all instances fell below the lower threshold.')
hwPimSGExceed = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 19)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationSrcAddr"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGrpAddr"), ("HUAWEI-PIM-STD-MIB", "hwPimSGTotalCount"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"))
if mibBuilder.loadTexts: hwPimSGExceed.setStatus('current')
if mibBuilder.loadTexts: hwPimSGExceed.setDescription('A hwPimSGExceed notification signifies that PIM (S, G) entries count of all instances reached the limit.')
hwPimSGExceedClear = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 0, 20)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"))
if mibBuilder.loadTexts: hwPimSGExceedClear.setStatus('current')
if mibBuilder.loadTexts: hwPimSGExceedClear.setDescription('A hwPimSGExceedClear notification signifies that the number of PIM(S, G) entries count of all instances fell below the limit.')
hwPimMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2))
hwPimMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 1))
hwPimMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2))
hwPimMibComplianceAsm = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 1, 1)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimTopologyGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSsmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRpConfigGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimTuningParametersGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRouterStatisticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationObjects"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDiagnosticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDeviceStorageGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimMibComplianceAsm = hwPimMibComplianceAsm.setStatus('current')
if mibBuilder.loadTexts: hwPimMibComplianceAsm.setDescription('The compliance statement for PIM-SM MIB.')
hwPimMibComplianceBidir = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 1, 2)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimTopologyGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRpConfigGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimBidirGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimTuningParametersGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRouterStatisticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationObjects"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDiagnosticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDeviceStorageGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimMibComplianceBidir = hwPimMibComplianceBidir.setStatus('current')
if mibBuilder.loadTexts: hwPimMibComplianceBidir.setDescription('The compliance statement for Bidir-PIM MIB.')
hwPimMibComplianceSsm = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 1, 3)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimTopologyGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSsmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimTuningParametersGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRouterStatisticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationObjects"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDiagnosticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDeviceStorageGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimMibComplianceSsm = hwPimMibComplianceSsm.setStatus('current')
if mibBuilder.loadTexts: hwPimMibComplianceSsm.setDescription('The compliance statement for PIM SSM MIB.')
hwPimMibComplianceDm = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 1, 4)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimTopologyGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSsmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRpConfigGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimSmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDmGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimTuningParametersGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimRouterStatisticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationObjects"), ("HUAWEI-PIM-STD-MIB", "hwPimNetMgmtNotificationGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDiagnosticsGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimDeviceStorageGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimMibComplianceDm = hwPimMibComplianceDm.setStatus('current')
if mibBuilder.loadTexts: hwPimMibComplianceDm.setDescription('The compliance statement for PIM-DM MIB.')
hwPimTopologyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 1)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInterfaceAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceGenerationIdValue"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceDr"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceDrPriorityEnabled"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceHelloHoldtime"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceJoinPruneHoldtime"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceLanDelayEnabled"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceEffectPropagDelay"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceEffectOverrideIvl"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceSuppressionEnabled"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceBidirCapable"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborGenerationIdPresent"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborGenerationIdValue"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborExpiryTime"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborDrPriorityPresent"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborDrPriority"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborLanPruneDelayPresent"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborTBit"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborPropagationDelay"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborOverrideInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborBidirCapable"), ("HUAWEI-PIM-STD-MIB", "hwPimNbrSecAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborIfName"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimTopologyGroup = hwPimTopologyGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimTopologyGroup.setDescription('A collection of read-only objects used to report local PIM topology.')
hwPimNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 2)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimNeighborLoss"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimNotificationGroup = hwPimNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimNotificationGroup.setDescription('A collection of notifications for signaling important PIM events.')
hwPimTuningParametersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 3)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimKeepalivePeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimRegisterSuppressionTime"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceDrPriority"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceHelloInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceTrigHelloInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceJoinPruneInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfacePropagationDelay"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceOverrideInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceDomainBorder"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceStubInterface"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceStatus"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimTuningParametersGroup = hwPimTuningParametersGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimTuningParametersGroup.setDescription('A collection of writeable objects used to configure PIM behavior and to tune performance.')
hwPimRouterStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 4)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimStarGEntries"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIEntries"), ("HUAWEI-PIM-STD-MIB", "hwPimSGEntries"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIEntries"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptEntries"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptIEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimRouterStatisticsGroup = hwPimRouterStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimRouterStatisticsGroup.setDescription('A collection of statistics global to the PIM router.')
hwPimSsmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 5)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimSGUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimSGPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimSGUpstreamJoinState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGUpstreamJoinTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGUpstreamNeighbor"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfIfIndex"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfNextHopType"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfNextHop"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfRouteProtocol"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfRouteAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfRoutePrefixLength"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfRouteMetricPref"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpfRouteMetric"), ("HUAWEI-PIM-STD-MIB", "hwPimSGSptBit"), ("HUAWEI-PIM-STD-MIB", "hwPimSGKeepaliveTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGDrRegisterState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGDrRegisterStopTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpRegisterPmbrAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRpRegisterPmbrAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimSGILocalMembership"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIJoinPruneState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIPrunePendingTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIJoinExpiryTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertWinnerAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertWinnerAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertWinnerMetricPref"), ("HUAWEI-PIM-STD-MIB", "hwPimSGIAssertWinnerMetric"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimSsmGroup = hwPimSsmGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimSsmGroup.setDescription('A collection of objects to support management of PIM routers running the PIM SSM (Source Specific Multicast) protocol, in PIM mode SM (Sparse Mode).')
hwPimRpConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 6)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimGroupMappingPrecedence"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimRpConfigGroup = hwPimRpConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimRpConfigGroup.setDescription('A collection of objects to support configuration of RPs (Rendezvous Points) and Group Mappings.')
hwPimSmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 7)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimStarGUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGPimMode"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGPimModeOrigin"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpIsLocal"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGUpstreamJoinState"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGUpstreamJoinTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGUpstreamNeighborType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGUpstreamNeighbor"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfIfIndex"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfNextHopType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfNextHop"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfRouteProtocol"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfRouteAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfRoutePrefixLength"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfRouteMetricPref"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGRpfRouteMetric"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGILocalMembership"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIJoinPruneState"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIPrunePendingTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIJoinExpiryTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertState"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertWinnerAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertWinnerAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertWinnerMetricPref"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGIAssertWinnerMetric"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptUpstreamPruneState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptUpstreamOverrideTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptIUpTime"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptILocalMembership"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptIJoinPruneState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptIPrunePendingTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGRptIPruneExpiryTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimSmGroup = hwPimSmGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimSmGroup.setDescription('A collection of objects to support management of PIM routers running PIM-SM (Sparse Mode). The groups hwPimSsmGroup and hwPimRpConfigGroup are also required.')
hwPimBidirGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 8)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInterfaceDfElectionRobustness"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimBidirGroup = hwPimBidirGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimBidirGroup.setDescription('A collection of objects to support management of PIM routers running BIDIR mode. The groups hwPimSsmGroup, hwPimSmGroup and hwPimRpConfigGroup are also required.')
hwPimNetMgmtNotificationObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 11)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterMsgsRcvd"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterOrigin"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegisterRp"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneMsgsRcvd"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneOrigin"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPruneRp"), ("HUAWEI-PIM-STD-MIB", "hwPimRpMappingNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimRpMappingChangeCount"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceElectionNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceElectionWinCount"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborAddNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborAddCount"), ("HUAWEI-PIM-STD-MIB", "hwPimGRStartTime"), ("HUAWEI-PIM-STD-MIB", "hwPimGRInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimGREndTime"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitSource"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitGroup"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceID"), ("HUAWEI-PIM-STD-MIB", "hwPimInstanceName"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborNotificationReason"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGTotalCount"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimSGCurrentCount"), ("HUAWEI-PIM-STD-MIB", "hwPimSGTotalCount"), ("HUAWEI-PIM-STD-MIB", "hwPimSGThreshold"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationSrcAddr"), ("HUAWEI-PIM-STD-MIB", "hwPimNotificationGrpAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimNetMgmtNotificationObjects = hwPimNetMgmtNotificationObjects.setStatus('current')
if mibBuilder.loadTexts: hwPimNetMgmtNotificationObjects.setDescription('A collection of objects to support notification of PIM network management events.')
hwPimNetMgmtNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 12)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInvalidRegister"), ("HUAWEI-PIM-STD-MIB", "hwPimInvalidJoinPrune"), ("HUAWEI-PIM-STD-MIB", "hwPimRpMappingChange"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceElection"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborAdd"), ("HUAWEI-PIM-STD-MIB", "hwPimGRStart"), ("HUAWEI-PIM-STD-MIB", "hwPimGREnd"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimit"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborUnavailable"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborUnavailableClear"), ("HUAWEI-PIM-STD-MIB", "hwPimMrtLimitClear"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGThresholdExceed"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGThresholdExceedClear"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGExceed"), ("HUAWEI-PIM-STD-MIB", "hwPimStarGExceedClear"), ("HUAWEI-PIM-STD-MIB", "hwPimSGThresholdExceed"), ("HUAWEI-PIM-STD-MIB", "hwPimSGThresholdExceedClear"), ("HUAWEI-PIM-STD-MIB", "hwPimSGExceed"), ("HUAWEI-PIM-STD-MIB", "hwPimSGExceedClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimNetMgmtNotificationGroup = hwPimNetMgmtNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimNetMgmtNotificationGroup.setDescription('A collection of notifications for signaling PIM network management events.')
hwPimDiagnosticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 13)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimInAsserts"), ("HUAWEI-PIM-STD-MIB", "hwPimOutAsserts"), ("HUAWEI-PIM-STD-MIB", "hwPimLastAssertInterface"), ("HUAWEI-PIM-STD-MIB", "hwPimLastAssertGroupAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimLastAssertGroupAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimLastAssertSourceAddressType"), ("HUAWEI-PIM-STD-MIB", "hwPimLastAssertSourceAddress"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborLossNotificationPeriod"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborLossCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimDiagnosticsGroup = hwPimDiagnosticsGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimDiagnosticsGroup.setDescription('Objects providing additional diagnostics related to a PIM router.')
hwPimDmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 14)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimRefreshInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfacePruneLimitInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceGraftRetryInterval"), ("HUAWEI-PIM-STD-MIB", "hwPimInterfaceSrPriorityEnabled"), ("HUAWEI-PIM-STD-MIB", "hwPimNeighborSrCapable"), ("HUAWEI-PIM-STD-MIB", "hwPimSGUpstreamPruneState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGUpstreamPruneLimitTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGOriginatorState"), ("HUAWEI-PIM-STD-MIB", "hwPimSGSourceActiveTimer"), ("HUAWEI-PIM-STD-MIB", "hwPimSGStateRefreshTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimDmGroup = hwPimDmGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimDmGroup.setDescription('A collection of objects required for management of PIM Dense Mode (PIM-DM) function. The groups hwPimSsmGroup and hwPimSmGroup are also required.')
if mibBuilder.loadTexts: hwPimDmGroup.setReference('RFC 3973')
hwPimDeviceStorageGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 149, 4, 2, 2, 15)).setObjects(("HUAWEI-PIM-STD-MIB", "hwPimDeviceConfigStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwPimDeviceStorageGroup = hwPimDeviceStorageGroup.setStatus('current')
if mibBuilder.loadTexts: hwPimDeviceStorageGroup.setDescription('An object that specifies the volatility of global PIM configuration settings on this device.')
mibBuilder.exportSymbols("HUAWEI-PIM-STD-MIB", hwPimLastAssertGroupAddressType=hwPimLastAssertGroupAddressType, hwPimInterfaceAddressType=hwPimInterfaceAddressType, hwPimSGIAssertState=hwPimSGIAssertState, hwPimSGDrRegisterStopTimer=hwPimSGDrRegisterStopTimer, hwPimNeighborUnavailableClear=hwPimNeighborUnavailableClear, hwPimSGExceedClear=hwPimSGExceedClear, hwPimStarGIEntry=hwPimStarGIEntry, hwPimSGRptIEntries=hwPimSGRptIEntries, hwPimLastAssertInterface=hwPimLastAssertInterface, hwPimGREnd=hwPimGREnd, hwPimNeighborTBit=hwPimNeighborTBit, hwPimGlobalCtlMsgCountRegister=hwPimGlobalCtlMsgCountRegister, hwPimStarGRpAddress=hwPimStarGRpAddress, hwPimOutAsserts=hwPimOutAsserts, hwPimStarGIAssertWinnerAddressType=hwPimStarGIAssertWinnerAddressType, hwPimLastAssertSourceAddress=hwPimLastAssertSourceAddress, hwPimSGIEntry=hwPimSGIEntry, hwPimStarGRpfIfIndex=hwPimStarGRpfIfIndex, hwPimSGUpstreamJoinTimer=hwPimSGUpstreamJoinTimer, hwPimInterfaceAddress=hwPimInterfaceAddress, hwPimNeighborExpiryTime=hwPimNeighborExpiryTime, hwPimNetMgmtNotificationGroup=hwPimNetMgmtNotificationGroup, hwPimSGRpfRouteMetricPref=hwPimSGRpfRouteMetricPref, hwPimNeighborBidirCapable=hwPimNeighborBidirCapable, hwPimSGIAssertTimer=hwPimSGIAssertTimer, hwPimSGIJoinPruneState=hwPimSGIJoinPruneState, hwPimStarGIEntries=hwPimStarGIEntries, hwPimStarGEntry=hwPimStarGEntry, hwPimSGIJoinExpiryTimer=hwPimSGIJoinExpiryTimer, hwPimNeighborDrPriorityPresent=hwPimNeighborDrPriorityPresent, hwPimInterfaceHelloInterval=hwPimInterfaceHelloInterval, hwPimStarGPimModeOrigin=hwPimStarGPimModeOrigin, hwPimMrtLimitGroup=hwPimMrtLimitGroup, hwPimSGRptTable=hwPimSGRptTable, hwPimSGRptIIfIndex=hwPimSGRptIIfIndex, hwPimGlobalCtlMsgCountTable=hwPimGlobalCtlMsgCountTable, hwPimInterfaceElection=hwPimInterfaceElection, hwPimRpConfigGroup=hwPimRpConfigGroup, hwPimStarGIAssertState=hwPimStarGIAssertState, hwPimInvalidRegister=hwPimInvalidRegister, hwPimDeviceStorageGroup=hwPimDeviceStorageGroup, hwPimSGUpstreamNeighbor=hwPimSGUpstreamNeighbor, hwPimSGRpfRouteProtocol=hwPimSGRpfRouteProtocol, hwPim=hwPim, hwPimBidirGroup=hwPimBidirGroup, hwPimInterfaceGenerationIdValue=hwPimInterfaceGenerationIdValue, hwPimInterfaceName=hwPimInterfaceName, hwPimNbrSecAddressIfIndex=hwPimNbrSecAddressIfIndex, hwPimStarGUpstreamNeighborType=hwPimStarGUpstreamNeighborType, hwPimInvalidRegisterOrigin=hwPimInvalidRegisterOrigin, hwPimStarGGrpAddress=hwPimStarGGrpAddress, hwPimSGRpRegisterPmbrAddress=hwPimSGRpRegisterPmbrAddress, hwPimSGIAssertWinnerAddress=hwPimSGIAssertWinnerAddress, hwPimInvalidRegisterMsgsRcvd=hwPimInvalidRegisterMsgsRcvd, hwPimInterfaceSuppressionEnabled=hwPimInterfaceSuppressionEnabled, hwPimStarGUpTime=hwPimStarGUpTime, hwPimStarGThreshold=hwPimStarGThreshold, hwPimInterfaceElectionWinCount=hwPimInterfaceElectionWinCount, hwPimSGDrRegisterState=hwPimSGDrRegisterState, hwPimInvalidRegisterGroup=hwPimInvalidRegisterGroup, hwPimInvalidJoinPruneOrigin=hwPimInvalidJoinPruneOrigin, hwPimGREndTime=hwPimGREndTime, hwPimNeighborUpTime=hwPimNeighborUpTime, hwPimStarGPimMode=hwPimStarGPimMode, hwPimSGIIfIndex=hwPimSGIIfIndex, hwPimStarGIAssertWinnerMetricPref=hwPimStarGIAssertWinnerMetricPref, hwPimInterfaceCtlMsgCountTable=hwPimInterfaceCtlMsgCountTable, hwPimStarGAddressType=hwPimStarGAddressType, hwPimNotificationAddressType=hwPimNotificationAddressType, hwMcast=hwMcast, hwPimInterfaceCtlMsgCountHello=hwPimInterfaceCtlMsgCountHello, hwPimInterfaceIpVersion=hwPimInterfaceIpVersion, HWPimCtlMsgState=HWPimCtlMsgState, hwPimInvalidRegisterRp=hwPimInvalidRegisterRp, hwPimMrtLimitClear=hwPimMrtLimitClear, hwPimNeighborGenerationIdPresent=hwPimNeighborGenerationIdPresent, hwPimSGExceed=hwPimSGExceed, hwPimStarGIJoinPruneState=hwPimStarGIJoinPruneState, hwPimNotificationGroup=hwPimNotificationGroup, hwPimSGIPrunePendingTimer=hwPimSGIPrunePendingTimer, hwPimGroupMappingTable=hwPimGroupMappingTable, hwPimInterfaceCtlMsgCountEntry=hwPimInterfaceCtlMsgCountEntry, hwPimStarGIAssertTimer=hwPimStarGIAssertTimer, hwPimRpMappingChangeCount=hwPimRpMappingChangeCount, hwPimNotificationSrcAddr=hwPimNotificationSrcAddr, HWPimGroupMappingOriginType=HWPimGroupMappingOriginType, hwPimSGRptUpstreamPruneState=hwPimSGRptUpstreamPruneState, hwPimNeighborNotificationReason=hwPimNeighborNotificationReason, hwPimInterfaceCtlMsgCountAssert=hwPimInterfaceCtlMsgCountAssert, hwPimInterfaceTrigHelloInterval=hwPimInterfaceTrigHelloInterval, hwPimSGIAssertWinnerAddressType=hwPimSGIAssertWinnerAddressType, hwPimSGRptIPruneExpiryTimer=hwPimSGRptIPruneExpiryTimer, hwPimGRStart=hwPimGRStart, hwPimSGEntries=hwPimSGEntries, hwPimSGKeepaliveTimer=hwPimSGKeepaliveTimer, hwPimLastAssertSourceAddressType=hwPimLastAssertSourceAddressType, hwPimInterfaceEffectOverrideIvl=hwPimInterfaceEffectOverrideIvl, hwPimStarGCurrentCount=hwPimStarGCurrentCount, hwPimSGILocalMembership=hwPimSGILocalMembership, hwPimSGRptIUpTime=hwPimSGRptIUpTime, hwPimDeviceConfigStorageType=hwPimDeviceConfigStorageType, hwPimNeighborAddNotificationPeriod=hwPimNeighborAddNotificationPeriod, hwPimSGRptIPrunePendingTimer=hwPimSGRptIPrunePendingTimer, hwPimInterfaceSrPriorityEnabled=hwPimInterfaceSrPriorityEnabled, hwPimInvalidJoinPruneNotificationPeriod=hwPimInvalidJoinPruneNotificationPeriod, hwPimSGRpfNextHopType=hwPimSGRpfNextHopType, hwPimSGRpfNextHop=hwPimSGRpfNextHop, hwPimSGTable=hwPimSGTable, hwPimStarGRpfNextHop=hwPimStarGRpfNextHop, hwPimInterfacePruneLimitInterval=hwPimInterfacePruneLimitInterval, hwPimInterfaceStorageType=hwPimInterfaceStorageType, hwPimNeighborSrCapable=hwPimNeighborSrCapable, hwPimInvalidJoinPruneGroup=hwPimInvalidJoinPruneGroup, hwPimSGStateRefreshTimer=hwPimSGStateRefreshTimer, hwPimInterfaceDfElectionRobustness=hwPimInterfaceDfElectionRobustness, hwPimInterfaceCtlMsgCountJoinPrune=hwPimInterfaceCtlMsgCountJoinPrune, hwPimStarGRpfRouteMetricPref=hwPimStarGRpfRouteMetricPref, hwPimInAsserts=hwPimInAsserts, hwPimSGRpfRouteAddress=hwPimSGRpfRouteAddress, hwPimSGOriginatorState=hwPimSGOriginatorState, hwPimSGIAssertWinnerMetricPref=hwPimSGIAssertWinnerMetricPref, hwPimInterfaceLanDelayEnabled=hwPimInterfaceLanDelayEnabled, hwPimGroupMappingOrigin=hwPimGroupMappingOrigin, hwPimSGRpfRoutePrefixLength=hwPimSGRpfRoutePrefixLength, hwPimGroupMappingPimMode=hwPimGroupMappingPimMode, hwPimNeighborGenerationIdValue=hwPimNeighborGenerationIdValue, hwPimInterfaceStubInterface=hwPimInterfaceStubInterface, hwPimNeighborLoss=hwPimNeighborLoss, hwPimRpMappingChange=hwPimRpMappingChange, hwPimGroupMappingEntry=hwPimGroupMappingEntry, hwPimStarGRpfRouteProtocol=hwPimStarGRpfRouteProtocol, hwPimInterfaceCtlMsgCountIfIndex=hwPimInterfaceCtlMsgCountIfIndex, hwPimStarGExceed=hwPimStarGExceed, hwPimMibCompliances=hwPimMibCompliances, hwPimLastAssertGroupAddress=hwPimLastAssertGroupAddress, hwPimSGSrcAddress=hwPimSGSrcAddress, hwPimInterfaceTable=hwPimInterfaceTable, hwPimNeighborIfName=hwPimNeighborIfName, hwPimSGPimMode=hwPimSGPimMode, hwPimSGRptILocalMembership=hwPimSGRptILocalMembership, hwPimMrtLimitAddressType=hwPimMrtLimitAddressType, hwPimStarGThresholdExceedClear=hwPimStarGThresholdExceedClear, hwPimGlobalCtlMsgCountIpVersion=hwPimGlobalCtlMsgCountIpVersion, PYSNMP_MODULE_ID=hwPimStdMib, hwPimStarGIPrunePendingTimer=hwPimStarGIPrunePendingTimer, hwPimStarGIJoinExpiryTimer=hwPimStarGIJoinExpiryTimer, hwPimSGITable=hwPimSGITable, hwPimNotificationGrpAddr=hwPimNotificationGrpAddr, hwPimStarGTotalCount=hwPimStarGTotalCount, hwPimSGIUpTime=hwPimSGIUpTime, hwPimGroupMappingAddressType=hwPimGroupMappingAddressType, hwPimInterfaceEffectPropagDelay=hwPimInterfaceEffectPropagDelay, hwPimMibComplianceBidir=hwPimMibComplianceBidir, hwPimStarGIAssertWinnerMetric=hwPimStarGIAssertWinnerMetric, hwPimSGAddressType=hwPimSGAddressType, hwPimInvalidJoinPruneMsgsRcvd=hwPimInvalidJoinPruneMsgsRcvd, hwPimMibConformance=hwPimMibConformance, hwPimSGUpstreamPruneLimitTimer=hwPimSGUpstreamPruneLimitTimer, hwPimNeighborUnavailable=hwPimNeighborUnavailable, hwPimNeighborLossCount=hwPimNeighborLossCount, hwPimStarGThresholdExceed=hwPimStarGThresholdExceed, hwPimMibComplianceAsm=hwPimMibComplianceAsm, hwPimGroupMappingPrecedence=hwPimGroupMappingPrecedence, hwPimGRStartTime=hwPimGRStartTime, hwPimSmGroup=hwPimSmGroup, hwPimNeighborAdd=hwPimNeighborAdd, hwPimSGRptUpTime=hwPimSGRptUpTime, hwPimGlobalCtlMsgCountCrp=hwPimGlobalCtlMsgCountCrp, hwPimNeighborDrPriority=hwPimNeighborDrPriority, hwPimGRInterval=hwPimGRInterval, hwPimGroupMappingRpAddressType=hwPimGroupMappingRpAddressType, hwPimStarGUpstreamNeighbor=hwPimStarGUpstreamNeighbor, hwPimInterfaceCtlMsgCountMsgState=hwPimInterfaceCtlMsgCountMsgState, hwPimKeepalivePeriod=hwPimKeepalivePeriod, hwPimGlobalCtlMsgCountProbe=hwPimGlobalCtlMsgCountProbe, hwPimRegisterSuppressionTime=hwPimRegisterSuppressionTime, hwPimSGIEntries=hwPimSGIEntries, hwPimNeighborAddress=hwPimNeighborAddress, hwPimSGThresholdExceed=hwPimSGThresholdExceed, hwPimMibGroups=hwPimMibGroups, hwPimSGRptSrcAddress=hwPimSGRptSrcAddress, hwPimInterfaceBidirCapable=hwPimInterfaceBidirCapable, hwPimStarGUpstreamJoinState=hwPimStarGUpstreamJoinState, hwPimNbrSecAddressTable=hwPimNbrSecAddressTable, hwPimSGUpstreamJoinState=hwPimSGUpstreamJoinState, hwPimInvalidRegisterNotificationPeriod=hwPimInvalidRegisterNotificationPeriod, hwPimInstanceName=hwPimInstanceName, hwPimSGRpfRouteMetric=hwPimSGRpfRouteMetric, hwPimSGSourceActiveTimer=hwPimSGSourceActiveTimer, hwPimStarGUpstreamJoinTimer=hwPimStarGUpstreamJoinTimer, hwPimSGIAssertWinnerMetric=hwPimSGIAssertWinnerMetric, hwPimInterfaceEntry=hwPimInterfaceEntry, hwPimGlobalCtlMsgCountMsgState=hwPimGlobalCtlMsgCountMsgState, hwPimSGRpfIfIndex=hwPimSGRpfIfIndex, HWPimMode=HWPimMode, hwPimInvalidJoinPrune=hwPimInvalidJoinPrune, hwPimInterfaceJoinPruneHoldtime=hwPimInterfaceJoinPruneHoldtime, hwPimNeighborOverrideInterval=hwPimNeighborOverrideInterval, hwPimInterfaceDomainBorder=hwPimInterfaceDomainBorder, hwPimSGUpstreamPruneState=hwPimSGUpstreamPruneState, hwPimNeighborLossNotificationPeriod=hwPimNeighborLossNotificationPeriod, hwPimGroupMappingRpAddress=hwPimGroupMappingRpAddress, hwPimSsmGroup=hwPimSsmGroup, hwPimSGRptIJoinPruneState=hwPimSGRptIJoinPruneState, hwPimStarGExceedClear=hwPimStarGExceedClear, hwPimMibComplianceSsm=hwPimMibComplianceSsm, hwPimStarGRpfRoutePrefixLength=hwPimStarGRpfRoutePrefixLength, hwPimNeighborTable=hwPimNeighborTable, hwPimInterfaceIfIndex=hwPimInterfaceIfIndex, hwPimGroupMappingGrpPrefixLength=hwPimGroupMappingGrpPrefixLength, hwPimRpMappingNotificationPeriod=hwPimRpMappingNotificationPeriod, hwPimInterfaceDr=hwPimInterfaceDr, hwPimStarGTable=hwPimStarGTable, hwPimInterfaceCtlMsgCountIpVersion=hwPimInterfaceCtlMsgCountIpVersion, hwPimStarGIAssertWinnerAddress=hwPimStarGIAssertWinnerAddress, hwPimTuningParametersGroup=hwPimTuningParametersGroup, hwPimRouterStatisticsGroup=hwPimRouterStatisticsGroup, hwPimSGRptUpstreamOverrideTimer=hwPimSGRptUpstreamOverrideTimer, hwPimNeighborIfIndex=hwPimNeighborIfIndex, hwPimStarGRpfRouteMetric=hwPimStarGRpfRouteMetric, hwPimDmGroup=hwPimDmGroup, hwPimNbrSecAddress=hwPimNbrSecAddress, hwPimStarGRpfRouteAddress=hwPimStarGRpfRouteAddress, hwPimStarGILocalMembership=hwPimStarGILocalMembership, hwPimSGRptIEntry=hwPimSGRptIEntry, hwPimInterfaceCtlMsgCountBsr=hwPimInterfaceCtlMsgCountBsr, hwPimSGEntry=hwPimSGEntry, hwPimInvalidJoinPruneRp=hwPimInvalidJoinPruneRp, hwPimSGGrpAddress=hwPimSGGrpAddress, hwPimInvalidRegisterAddressType=hwPimInvalidRegisterAddressType, hwPimGlobalCtlMsgCountRegisterStop=hwPimGlobalCtlMsgCountRegisterStop, hwPimGroupMappingGrpAddress=hwPimGroupMappingGrpAddress, hwPimSGRpRegisterPmbrAddressType=hwPimSGRpRegisterPmbrAddressType, hwPimRefreshInterval=hwPimRefreshInterval, hwPimInterfaceOverrideInterval=hwPimInterfaceOverrideInterval, hwPimNeighborAddCount=hwPimNeighborAddCount, hwPimInterfaceGraftRetryInterval=hwPimInterfaceGraftRetryInterval, hwPimSGRptEntries=hwPimSGRptEntries, hwPimNeighborEntry=hwPimNeighborEntry, hwPimDiagnosticsGroup=hwPimDiagnosticsGroup, hwPimStarGITable=hwPimStarGITable, hwPimStarGIIfIndex=hwPimStarGIIfIndex, hwPimNetMgmtNotificationObjects=hwPimNetMgmtNotificationObjects, hwPimNbrSecAddressType=hwPimNbrSecAddressType, hwPimSGThreshold=hwPimSGThreshold, hwPimMrtLimitSource=hwPimMrtLimitSource, hwPimNeighborAddressType=hwPimNeighborAddressType, hwPimInterfaceDrPriority=hwPimInterfaceDrPriority, hwPimStarGRpIsLocal=hwPimStarGRpIsLocal, hwPimMrtLimit=hwPimMrtLimit, hwPimNbrSecAddressPrimary=hwPimNbrSecAddressPrimary, hwPimSGRptEntry=hwPimSGRptEntry, hwPimStarGRpfNextHopType=hwPimStarGRpfNextHopType, hwPimStarGEntries=hwPimStarGEntries)
mibBuilder.exportSymbols("HUAWEI-PIM-STD-MIB", hwPimInstanceID=hwPimInstanceID, hwPimInterfacePropagationDelay=hwPimInterfacePropagationDelay, hwPimInvalidJoinPruneAddressType=hwPimInvalidJoinPruneAddressType, hwPimInterfaceElectionNotificationPeriod=hwPimInterfaceElectionNotificationPeriod, hwPimNotifications=hwPimNotifications, hwPimStarGIUpTime=hwPimStarGIUpTime, hwPimSGUpTime=hwPimSGUpTime, hwPimInterfaceStatus=hwPimInterfaceStatus, hwPimSGSptBit=hwPimSGSptBit, hwPimGlobalCtlMsgCountEntry=hwPimGlobalCtlMsgCountEntry, hwPimInterfaceHelloHoldtime=hwPimInterfaceHelloHoldtime, hwPimInterfaceDrPriorityEnabled=hwPimInterfaceDrPriorityEnabled, hwPimStarGRpAddressType=hwPimStarGRpAddressType, hwPimInterfaceJoinPruneInterval=hwPimInterfaceJoinPruneInterval, hwPimNeighborLanPruneDelayPresent=hwPimNeighborLanPruneDelayPresent, hwPimStdMib=hwPimStdMib, hwPimSGThresholdExceedClear=hwPimSGThresholdExceedClear, hwPimMibComplianceDm=hwPimMibComplianceDm, hwPimSGTotalCount=hwPimSGTotalCount, hwPimNbrSecAddressEntry=hwPimNbrSecAddressEntry, hwPimSGRptITable=hwPimSGRptITable, hwPimSGCurrentCount=hwPimSGCurrentCount, hwPimNeighborPropagationDelay=hwPimNeighborPropagationDelay, hwPimTopologyGroup=hwPimTopologyGroup)

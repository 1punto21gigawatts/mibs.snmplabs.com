#
# PySNMP MIB module RBN-APS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RBN-APS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:52:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
rbnMgmt, = mibBuilder.importSymbols("RBN-SMI", "rbnMgmt")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Gauge32, Integer32, ModuleIdentity, Counter64, Counter32, MibIdentifier, ObjectIdentity, TimeTicks, NotificationType, iso, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "ModuleIdentity", "Counter64", "Counter32", "MibIdentifier", "ObjectIdentity", "TimeTicks", "NotificationType", "iso", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
rbnApsMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2352, 2, 5))
rbnApsMIB.setRevisions(('1999-05-07 23:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rbnApsMIB.setRevisionsDescriptions(('Creation of the linear APS MIB.',))
if mibBuilder.loadTexts: rbnApsMIB.setLastUpdated('9905072300Z')
if mibBuilder.loadTexts: rbnApsMIB.setOrganization('RedBack Networks, Inc.')
if mibBuilder.loadTexts: rbnApsMIB.setContactInfo(' RedBack Networks, Inc. Postal: 1389 Moffett Park Drive Sunnyvale, CA 94089-1134 USA Phone: +1 408 548 3500 Fax: +1 408 548 3599 E-mail: mib-info@RedBackNetworks.com')
if mibBuilder.loadTexts: rbnApsMIB.setDescription('This management information module supports the configuration and management of SONET linear APS groups. The definitions and descriptions used in this mib have been derived from GR-253-CORE Revision 2, January 1999, section 5.3. The mib contains four tables. The apsConfigTable supports addition, modification and deletion of entries representing linear APS groups. Ring APS groups are not currently supported by this MIB. Entries are indexed by a text group name. Each entry contains parameters that specify the configuration of a particular linear APS group. The apsCommandTable provides linear APS commands that support protection switching and the ability to modify APS operation. Commands may only be entered if the corresponding apsConfigRowStatus instance is set to active. The apsStatusTable provides statistics and information about the current APS group state. The apsChanTable provides the ability to add and delete SONET LTE channels from APS groups. Additionally statistics and current state information are provided at the APS channel level. The table contains entries for each SONET LTE interface available on the system. The field apsChanGroupName is initially set to a string of size zero indicating that the SONET LTE is not part of an APS group. Fields that are associated with APS configuration may be modified. An apsChanEntry instance may not be added or deleted through rbnApsMIB mib access operations. However, an apsChanEntry may be added or deleted through other system mechanisms, such as hot swap. An APS group is created and configured with the following sequence of events: CHANNEL CONFIGURATION Set the apsChanGroupName in an apsChanEntry to a user-friendly text string. The string must not be equal to the apsConfigName of an existing apsConfigEntry with apsConfigRowStatus set to active, since a channel cannot be added to an active group. The string may be set equal to the apsConfigName of a row which is currently not set to active, or it may be set to a string which does not currently exist in any instance of apsConfigName. A channel number is entered in apsChanNumber. A channel priority is entered in apsChanPriority, if the intended architecture is 1:n. apsChanPriority is ignored if the architecture is 1+1. This step is repeated for all apsChanEntry instances which are to be included in the APS group. ACTIVATING THE GROUP If the apsChanGroupName does not exist in an instance of apsConfigName, an apsGroupEntry is created with the apsChanGroupName value used as the index for the row. The apsConfigRowStatus value may be set to createAndGo. The apsGroupConfigEntry and apsChanEntry instances with matching name fields will be checked for consistency. If any errors in the channel numbers, architecture or configuration are uncovered the apsConfigRowStatus set will return inconsistentValue , otherwise noError is returned. If the apsChanGroupName value used in channel configuration exists in a previously created, inactive apsChanEntry instance, the apsConfigRowStatus value may be set to active. ')
rbnApsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 0))
rbnApsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1))
rbnApsMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2))
class ApsK1K2(TextualConvention, Integer32):
    description = 'This Textual Convention describes an object that stores a SONET K1 and K2 byte APS protocol field. K1 is located in the low order byte, K2 is located in the higher order second byte. Bits 1-4 of the K1 byte indicate a request. 1111 Lockout of Protection 1110 Forced Switch 1101 SF - High Priority 1100 SF - Low Priority 1011 SD - High Priority 1010 SD - Low Priority 1001 not used 1000 Manual Switch 0111 not used 0110 Wait-to-Restore 0101 not used 0100 Exercise 0011 not used 0010 Reverse Request 0001 Do Not Revert 0000 No Request Bits 5-8 of the K1 byte indicate the channel associated with the request defined in bits 1-4. 0000 is the Null channel 1-14 are working channels. 15 is the extra traffic channel Bits 1-4 of the K2 byte indicate a channel. The channel is defined with the same syntax as K1 Bits 5-8. Bits 5 of the K2 byte indicates the architecture. 0 if the architecture is 1+1 1 if the architecture is 1:n Bits 6-8 of the K2 byte indicates the mode. 000 - 011 are reserved for future use 100 indicates the mode is unidirectional 101 indicates the mode is bidirectional 110 RDI-L 111 AIS-L '
    status = 'current'

apsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1))
apsConfigGroups = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsConfigGroups.setStatus('current')
if mibBuilder.loadTexts: apsConfigGroups.setDescription('The count of APS groups.')
apsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2), )
if mibBuilder.loadTexts: apsConfigTable.setStatus('current')
if mibBuilder.loadTexts: apsConfigTable.setDescription('This table lists the APS groups that have been configured on the system.')
apsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1), ).setIndexNames((1, "RBN-APS-MIB", "apsConfigName"))
if mibBuilder.loadTexts: apsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apsConfigEntry.setDescription('A conceptual row in the apsConfigTable.')
apsConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: apsConfigName.setStatus('current')
if mibBuilder.loadTexts: apsConfigName.setDescription('A textual name for the APS group. ')
apsConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 2), Bits().clone(namedValues=NamedValues(("onePlusOne", 0), ("oneToN", 1), ("revertive", 2), ("bidirectional", 3), ("extraTrafficAllowed", 4))).clone(hexValue="1")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigMode.setStatus('current')
if mibBuilder.loadTexts: apsConfigMode.setDescription("The architecture and mode of the APS group. The values mean: onePlusOne The 1+1 architecture permanently bridges the working line to the protection line. oneToN The 1:n architecture allows one protection channel to protect up to n working channels. When a fault is detected on one of the n working channels that channel is bridged over the protection channel. Note: onePlusOne and oneToN are mutually exclusive. revertive When the condition that caused a switch to the protection line has been cleared the signal is switched back to the working line. If this bit is clear it indicates a non-revertive system which remains on the protection line until another switch request is received. bidirectional The bi-directional mode provides protection in both directions. If this bit is clear it indicates unidirectional mode which provides protection in one direction. The default for 1:n is bidirectional. The default for 1+1 is unidirectional. extraTrafficAllowed Extra traffic may be carried on the protection channel in a 1:n architecture if this flag is set. It may be necessary to disable this in order to interwork with other SONET network elements that don't support extra traffic. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).")
apsConfigSdBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigSdBerThreshold.setStatus('current')
if mibBuilder.loadTexts: apsConfigSdBerThreshold.setDescription('The Signal Degrade Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigSfBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 5)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigSfBerThreshold.setStatus('current')
if mibBuilder.loadTexts: apsConfigSfBerThreshold.setDescription('The Signal Failure Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigWaitToRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 720)).clone(600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: apsConfigWaitToRestore.setDescription('The Wait To Restore period in seconds. This field only applies if revertive switching is enabled, otherwise this value is ignored. After clearing of a condition that necessitated an automatic switch, the wait to restore period must elapse before reverting. This is intended to avoid rapid switch oscillations. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: apsConfigRowStatus.setDescription('The status of this APS group entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. If this object is set to destroy, all associated instances of apsChanGroupName will be set to a string of size 0 and all associated instances of apsChanNumber will be set to 0.')
apsCommandTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 2), )
if mibBuilder.loadTexts: apsCommandTable.setStatus('current')
if mibBuilder.loadTexts: apsCommandTable.setDescription('This table allows commands to be sent to configured APS groups.')
apsCommandEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 2, 1), ).setIndexNames((1, "RBN-APS-MIB", "apsConfigName"))
if mibBuilder.loadTexts: apsCommandEntry.setStatus('current')
if mibBuilder.loadTexts: apsCommandEntry.setDescription('A conceptual row in the apsCommandTable.')
apsCommandSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsCommandSwitch.setStatus('current')
if mibBuilder.loadTexts: apsCommandSwitch.setDescription('This field accepts an Integer32 value containing a 16 bit switch command in the low order word and a channel number in lowest four bits of the high order word. The Switch command values are: Clear(0) Clears all of the switch commands listed below for the specified channel. Lockout of Protection(1) Prevents any of the working channels from switching to the protection line. Forced Switch of Working (to Protection)(2) Switches the specified working channel to the protection line. Forced Switch of Protection (to Working)(3) Switches the working channel back from the protection line to the working line. Manual Switch of Working (to Protection)(4) Switches the specified working channel to the protection line. Manual Switch of Protection (to Working)(5) Switches the working channel back from the protection line to the working line. Exercise(6) Exercises the protocol for a protection switch of the specified channel by issuing an Exercise request for that channel and checking the response on the APS channel. ')
apsCommandControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsCommandControl.setStatus('current')
if mibBuilder.loadTexts: apsCommandControl.setDescription('This field accepts an Integer32 value containing a 16 bit control command in the low order word and a channel number in lowest four bits of the high order word. The Control command values are: Lockout a Working Channel(0) Prevents the specified working channel from switching to the protection line. Clear Lockout a Working Channel(1) Clears the lockout a working channel command for the channel specified. ')
apsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3), )
if mibBuilder.loadTexts: apsStatusTable.setStatus('current')
if mibBuilder.loadTexts: apsStatusTable.setDescription('This table provides status information about APS groups that have been configured on the system.')
apsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1), ).setIndexNames((1, "RBN-APS-MIB", "apsConfigName"))
if mibBuilder.loadTexts: apsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apsStatusEntry.setDescription('A conceptual row in the apsStatusTable.')
apsStatusK1K2Rcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 1), ApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusK1K2Rcv.setStatus('current')
if mibBuilder.loadTexts: apsStatusK1K2Rcv.setDescription('The current value of the K1 and K2 bytes received on the protection channel.')
apsStatusK1K2Trans = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 2), ApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusK1K2Trans.setStatus('current')
if mibBuilder.loadTexts: apsStatusK1K2Trans.setDescription('The current value of the K1 and K2 bytes transmitted on the protection channel.')
apsStatusCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 3), Bits().clone(namedValues=NamedValues(("modeMismatch", 0), ("channelMismatch", 1), ("psbf", 2), ("extraTraffic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: apsStatusCurrent.setDescription('The current status of the APS group. modeMismatch Modes other than 1+1 unidirectional monitor protection line K2 bit 5, which indicates the architecture and K2 bits 6-8, which indicate if the mode is unidirectional or bidirectional. A conflict between the current local mode and the received K2 mode information constitutes a mode mismatch. channelMismatch This bit indicates a mismatch between the transmitted K1 channel and the received K2 channel has been detected. psbf This bit indicates a Protection Switch Byte Failure (PSBF) is in effect. This condition occurs when an invalid code or persistently unacceptable codes in the K1 byte are received. extraTraffic This bit indicates whether extra traffic is currently being accepted on the protection line. ')
apsStatusModeMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusModeMismatches.setStatus('current')
if mibBuilder.loadTexts: apsStatusModeMismatches.setDescription('A count of Mode Mismatch conditions.')
apsStatusChannelMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusChannelMismatches.setStatus('current')
if mibBuilder.loadTexts: apsStatusChannelMismatches.setDescription('A count of Channel Mismatch conditions.')
apsStatusPSBFs = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusPSBFs.setStatus('current')
if mibBuilder.loadTexts: apsStatusPSBFs.setDescription('A count of Protection Switch Byte Failure conditions. This condition occurs when an invalid code or persistently unacceptable codes in the K1 byte are received.')
apsStatusCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 3, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusCreationTime.setStatus('current')
if mibBuilder.loadTexts: apsStatusCreationTime.setDescription('The value of sysUpTime at the time the associated apsConfigRowStatus instance was set to active.')
apsChan = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4))
apsChanLTEs = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanLTEs.setStatus('current')
if mibBuilder.loadTexts: apsChanLTEs.setDescription('The count of available SONET LTE interfaces that may be included in APS groups.')
apsChanTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2), )
if mibBuilder.loadTexts: apsChanTable.setStatus('current')
if mibBuilder.loadTexts: apsChanTable.setDescription('This table lists the SONET LTE interfaces that may be included in APS groups.')
apsChanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1), ).setIndexNames((0, "RBN-APS-MIB", "apsChanIfIndex"))
if mibBuilder.loadTexts: apsChanEntry.setStatus('current')
if mibBuilder.loadTexts: apsChanEntry.setDescription('A conceptual row in the apsChanTable.')
apsChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: apsChanIfIndex.setStatus('current')
if mibBuilder.loadTexts: apsChanIfIndex.setDescription('The Interface Index assigned to a SONET LTE.')
apsChanGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsChanGroupName.setStatus('current')
if mibBuilder.loadTexts: apsChanGroupName.setDescription('A textual name for the APS group which this channel is included in. This object may not be modified if an instance of apsConfigName exists with the same value and the associated apsConfigRowStatus object is equal to active. If the channel is not part of an APS group this value is set to a string of size 0. This field can be changed from a string of size 0 to a value of apsConfigName which has an associated apsConfigRowStatus object which is not set to active. This action includes the SONET LTE into the inactive APS group. This field can be changed from a string of size 0 to a value which is not equal to any existing instance of apsConfigName. This action is the initial step in adding a SONET LTE to a new APS group. An instance of apsConfigName equal to this instance of apsChanGroupName will subsequently be created. If this field is set to any non-empty string it may only be set to a string of size 0. If an attempt is made to set this field from a non-empty string to another non-empty string the error inconsistentValue will be returned. This prevents a manager from inadvertantly re-assigning a channel.')
apsChanNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsChanNumber.setStatus('current')
if mibBuilder.loadTexts: apsChanNumber.setDescription('This field is set to a unique channel number within an APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. If the port is not part of an APS group this value is set to 0. If an attempt is made to set this field when the associated apsChanGroupName field is a string of size 0 the error inconsistentValue is returned. If an attempt is made to set this field when an associated apsConfigName field exists and the corresponding apsConfigRowStatus field is set to active the error inconsistentValue is returned. This field must be assigned a unique number within the group. When an attempt is made to set the corresponding apsConfigRowStatus field to active the apsChanNumber values of all entries with equal apsChanGroupName fields must represent a set of consecutive integer values beginning with 0 and ending with n, where n is greater than or equal to 1 and less than or equal to 14. Otherwise the error inconsistentValue is returned to the apsConfigRowStatus set attempt.')
apsChanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsChanPriority.setStatus('current')
if mibBuilder.loadTexts: apsChanPriority.setDescription('The priority of the channel. This field deterimines whether high or low priority SD and SF codes are used in K1 requests. This field is only applicable if the channel is to be included in a group using the 1:n architecture. It is not applicable if the channel is to be included in a group using the 1+1 architecture, and is ignored in that case. ')
apsChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 5), Bits().clone(namedValues=NamedValues(("lockedOut", 0), ("sd", 1), ("sf", 2), ("switched", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatus.setStatus('current')
if mibBuilder.loadTexts: apsChanStatus.setDescription('Indicates the current state of the port. lockedOut This bit, when applied to a working channel, indicates that the channel is prevented from switching to the protection line. When applied to the null channel, this bit indicates that no working channel may switch to the protection line. sd A signal degrade condition is in effect. sf A signal failure condition is in effect. switched The switched bit is applied to a working channel if that channel is currently switched to the protection line. ')
apsChanSignalDegrades = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanSignalDegrades.setStatus('current')
if mibBuilder.loadTexts: apsChanSignalDegrades.setDescription('A count of Signal Degrade conditions. This condition occurs when the line Bit Error Rate exceeds the currently configured threshold.')
apsChanSignalFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanSignalFailures.setStatus('current')
if mibBuilder.loadTexts: apsChanSignalFailures.setDescription('A count of Signal Failure conditions that have been detected on the incoming signal. This condition occurs when a loss of signal, loss of frame, AIS-L or a Line bit error rate exceeding 10^-3 is detected on an incoming line.')
apsChanSwitchovers = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanSwitchovers.setStatus('current')
if mibBuilder.loadTexts: apsChanSwitchovers.setDescription('The number of switchovers that have occurred on this port.')
apsChanLastSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 5, 1, 4, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanLastSwitchover.setStatus('current')
if mibBuilder.loadTexts: apsChanLastSwitchover.setDescription('The value of sysUpTime when this port last switched over.')
apsTrapSwitchover = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 5, 0, 1)).setObjects(("RBN-APS-MIB", "apsChanSwitchovers"), ("RBN-APS-MIB", "apsChanStatus"))
if mibBuilder.loadTexts: apsTrapSwitchover.setStatus('current')
if mibBuilder.loadTexts: apsTrapSwitchover.setDescription('An apsTrapSwitchover notification is sent when the value of an instance of apsChanSwitchovers increments.')
apsTrapModeMismatch = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 5, 0, 2)).setObjects(("RBN-APS-MIB", "apsStatusModeMismatches"), ("RBN-APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsTrapModeMismatch.setStatus('current')
if mibBuilder.loadTexts: apsTrapModeMismatch.setDescription('An apsTrapModeMismatch notification is sent when the value of an instance of apsStatusModeMismatches increments.')
apsTrapChannelMismatch = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 5, 0, 3)).setObjects(("RBN-APS-MIB", "apsStatusChannelMismatches"), ("RBN-APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsTrapChannelMismatch.setStatus('current')
if mibBuilder.loadTexts: apsTrapChannelMismatch.setDescription('An apsTrapChannelMismatch notification is sent when the value of an instance of apsStatusChannelMismatches increments.')
apsTrapPSBF = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 5, 0, 4)).setObjects(("RBN-APS-MIB", "apsStatusPSBFs"), ("RBN-APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsTrapPSBF.setStatus('current')
if mibBuilder.loadTexts: apsTrapPSBF.setDescription('An apsTrapPSBF notification is sent when the value of an instance of apsStatusPSBFs increments.')
apsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1))
apsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 2))
apsCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 2, 1)).setObjects(("RBN-APS-MIB", "apsConfigGeneral"), ("RBN-APS-MIB", "apsStatusGeneral"), ("RBN-APS-MIB", "apsChanGeneral"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsCompliance = apsCompliance.setStatus('current')
if mibBuilder.loadTexts: apsCompliance.setDescription('The compliance statement for linear APS groups.')
apsConfigGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 1)).setObjects(("RBN-APS-MIB", "apsConfigMode"), ("RBN-APS-MIB", "apsConfigSdBerThreshold"), ("RBN-APS-MIB", "apsConfigSfBerThreshold"), ("RBN-APS-MIB", "apsConfigRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsConfigGeneral = apsConfigGeneral.setStatus('current')
if mibBuilder.loadTexts: apsConfigGeneral.setDescription('A collection of apsConfigTable objects providing configuration information applicable to all linear APS groups.')
apsConfigOneToN = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 2)).setObjects(("RBN-APS-MIB", "apsConfigWaitToRestore"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsConfigOneToN = apsConfigOneToN.setStatus('current')
if mibBuilder.loadTexts: apsConfigOneToN.setDescription('The apsConfigTable object that provides information which is only applicable to groups implementing the linear APS 1:n architecture.')
apsCommandOnePlusOne = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 3)).setObjects(("RBN-APS-MIB", "apsCommandSwitch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsCommandOnePlusOne = apsCommandOnePlusOne.setStatus('current')
if mibBuilder.loadTexts: apsCommandOnePlusOne.setDescription('The apsCommandTable object which is applicable to groups implementing the linear APS 1+1 architecture. Also, set operations must be supported.')
apsCommandOneToN = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 4)).setObjects(("RBN-APS-MIB", "apsCommandSwitch"), ("RBN-APS-MIB", "apsCommandControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsCommandOneToN = apsCommandOneToN.setStatus('current')
if mibBuilder.loadTexts: apsCommandOneToN.setDescription('A collection of apsCommandTable objects which are applicable to groups implementing the linear APS 1:n architecture. Also, set operations must be supported.')
apsStatusGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 5)).setObjects(("RBN-APS-MIB", "apsStatusK1K2Rcv"), ("RBN-APS-MIB", "apsStatusK1K2Trans"), ("RBN-APS-MIB", "apsStatusCurrent"), ("RBN-APS-MIB", "apsStatusModeMismatches"), ("RBN-APS-MIB", "apsStatusChannelMismatches"), ("RBN-APS-MIB", "apsStatusPSBFs"), ("RBN-APS-MIB", "apsStatusCreationTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsStatusGeneral = apsStatusGeneral.setStatus('current')
if mibBuilder.loadTexts: apsStatusGeneral.setDescription('A collection of apsStatusTable objects providing status information applicable to all linear APS groups.')
apsChanGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 6)).setObjects(("RBN-APS-MIB", "apsChanGroupName"), ("RBN-APS-MIB", "apsChanNumber"), ("RBN-APS-MIB", "apsChanStatus"), ("RBN-APS-MIB", "apsChanSignalDegrades"), ("RBN-APS-MIB", "apsChanSignalFailures"), ("RBN-APS-MIB", "apsChanSwitchovers"), ("RBN-APS-MIB", "apsChanLastSwitchover"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsChanGeneral = apsChanGeneral.setStatus('current')
if mibBuilder.loadTexts: apsChanGeneral.setDescription('A collection of apsChanTable objects providing information applicable to all linear APS channels.')
apsChanOneToN = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 7)).setObjects(("RBN-APS-MIB", "apsChanPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsChanOneToN = apsChanOneToN.setStatus('current')
if mibBuilder.loadTexts: apsChanOneToN.setDescription('The apsChanTable object that provides information which is only applicable to groups implementing the linear APS 1:n architecture.')
apsTotalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 8)).setObjects(("RBN-APS-MIB", "apsConfigGroups"), ("RBN-APS-MIB", "apsChanLTEs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsTotalsGroup = apsTotalsGroup.setStatus('current')
if mibBuilder.loadTexts: apsTotalsGroup.setDescription('A collection of objects providing optional counts of configured APS groups and SONET LTE interfaces.')
apsTrapOptional = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 5, 2, 1, 9)).setObjects(("RBN-APS-MIB", "apsTrapSwitchover"), ("RBN-APS-MIB", "apsTrapModeMismatch"), ("RBN-APS-MIB", "apsTrapChannelMismatch"), ("RBN-APS-MIB", "apsTrapPSBF"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsTrapOptional = apsTrapOptional.setStatus('current')
if mibBuilder.loadTexts: apsTrapOptional.setDescription('A collection of SONET linear APS notifications that may optionally be implemented.')
mibBuilder.exportSymbols("RBN-APS-MIB", apsChanIfIndex=apsChanIfIndex, apsStatusChannelMismatches=apsStatusChannelMismatches, apsConfigGeneral=apsConfigGeneral, apsChanLastSwitchover=apsChanLastSwitchover, apsChanSignalFailures=apsChanSignalFailures, apsCommandControl=apsCommandControl, apsCommandOneToN=apsCommandOneToN, apsCompliances=apsCompliances, apsConfigGroups=apsConfigGroups, apsConfigName=apsConfigName, apsChanSwitchovers=apsChanSwitchovers, ApsK1K2=ApsK1K2, apsChanLTEs=apsChanLTEs, apsCommandOnePlusOne=apsCommandOnePlusOne, rbnApsMIBConformance=rbnApsMIBConformance, apsStatusModeMismatches=apsStatusModeMismatches, apsTrapChannelMismatch=apsTrapChannelMismatch, apsConfigRowStatus=apsConfigRowStatus, apsConfigSdBerThreshold=apsConfigSdBerThreshold, apsTrapSwitchover=apsTrapSwitchover, apsChanOneToN=apsChanOneToN, apsStatusPSBFs=apsStatusPSBFs, apsTrapPSBF=apsTrapPSBF, apsChanTable=apsChanTable, apsStatusK1K2Rcv=apsStatusK1K2Rcv, apsConfigMode=apsConfigMode, apsGroups=apsGroups, apsStatusEntry=apsStatusEntry, rbnApsMIBNotifications=rbnApsMIBNotifications, PYSNMP_MODULE_ID=rbnApsMIB, apsConfigTable=apsConfigTable, apsChanNumber=apsChanNumber, apsConfigEntry=apsConfigEntry, apsStatusCurrent=apsStatusCurrent, apsChanStatus=apsChanStatus, apsChanGroupName=apsChanGroupName, apsCommandSwitch=apsCommandSwitch, rbnApsMIBObjects=rbnApsMIBObjects, apsStatusK1K2Trans=apsStatusK1K2Trans, apsChanSignalDegrades=apsChanSignalDegrades, apsStatusTable=apsStatusTable, apsTrapModeMismatch=apsTrapModeMismatch, apsTotalsGroup=apsTotalsGroup, apsCompliance=apsCompliance, apsConfigOneToN=apsConfigOneToN, apsTrapOptional=apsTrapOptional, rbnApsMIB=rbnApsMIB, apsConfigSfBerThreshold=apsConfigSfBerThreshold, apsChanPriority=apsChanPriority, apsStatusCreationTime=apsStatusCreationTime, apsChanEntry=apsChanEntry, apsCommandTable=apsCommandTable, apsChan=apsChan, apsCommandEntry=apsCommandEntry, apsChanGeneral=apsChanGeneral, apsConfigWaitToRestore=apsConfigWaitToRestore, apsConfig=apsConfig, apsStatusGeneral=apsStatusGeneral)

#
# PySNMP MIB module GDCSC611-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCSC611-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Counter32, NotificationType, MibIdentifier, IpAddress, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Integer32, ModuleIdentity, Gauge32, Unsigned32, Counter64, enterprises, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "NotificationType", "MibIdentifier", "IpAddress", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Integer32", "ModuleIdentity", "Gauge32", "Unsigned32", "Counter64", "enterprises", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
bql2 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12))
bql611 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 2))
bql621 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 3))
bql611MIBVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 12, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611MIBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bql611MIBVersion.setDescription('The version number of the MIB, to allow products to know which MIB is being supported. The version number will be x.yzT where x is a major revision (1-9), y is a minor revision(0-9), z is a typo revision (0-9) and T indicates the MIB is still a test revision(A-Z). When a release is complete no T should exist.')
bql611WhatAreYouTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 2), )
if mibBuilder.loadTexts: bql611WhatAreYouTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611WhatAreYouTable.setDescription('The GDC SC611 and DC621 What Are You Table.')
bql611WhatAreYouEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611WhatAreYouIndex"))
if mibBuilder.loadTexts: bql611WhatAreYouEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611WhatAreYouEntry.setDescription('An entry in the GDC SC611 What Are You table.')
bql611WhatAreYouIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611WhatAreYouIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611WhatAreYouIndex.setDescription('This object is the identifier of the SC611/DC621 What Are You table.')
bql611BaseCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 7))).clone(namedValues=NamedValues(("sc611", 5), ("dc621", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611BaseCardType.setStatus('mandatory')
if mibBuilder.loadTexts: bql611BaseCardType.setDescription('This function returns the value the Base Card Type.')
bql611OptionCard = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611OptionCard.setStatus('mandatory')
if mibBuilder.loadTexts: bql611OptionCard.setDescription('This indicates whether the option card is installed or not on the DC621.')
bql611DTECardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7))).clone(namedValues=NamedValues(("eia530", 1), ("x21", 2), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611DTECardType.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DTECardType.setDescription('This object is the DTE plug-in card type. This variable is used for a SC611 or DC621.')
bql611CodeRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611CodeRev.setStatus('mandatory')
if mibBuilder.loadTexts: bql611CodeRev.setDescription('This function returns the firmware code level. Example A- ,B- ')
bql611AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmStatus.setDescription('The current alarms of the unit without the alarm masks.')
bql611ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 3), )
if mibBuilder.loadTexts: bql611ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ConfigTable.setDescription('The GDC SC611, DC621 2B1Q configuration table.')
bql611ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611ConfigIndex"))
if mibBuilder.loadTexts: bql611ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ConfigEntry.setDescription('A listing of GDC 2B1Q SC611/DC621 options.')
bql611ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ConfigIndex.setDescription('A unique index for the Configuration Table.')
bql611DteRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 9, 10))).clone(namedValues=NamedValues(("kBps2Dot4", 1), ("kBps4Dot8", 2), ("kBps9Dot6", 3), ("kBps19Dot2", 4), ("kBps48", 6), ("kBps64", 9), ("kBps128", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611DteRate.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DteRate.setDescription('Object to select the DTE rate for the SC611 or DC621.')
bql611RateAdaption = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("x50Div3", 1), ("x50Div2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RateAdaption.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RateAdaption.setDescription('Object to select the DTE Rate Adaption for the SC611 or DC621.')
bql611DteOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("async", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611DteOperation.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DteOperation.setDescription('Object to select the DTE Operation for the SC611 or DC621.')
bql611TxClkSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611TxClkSource.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TxClkSource.setDescription('Object to select the Transmit Clock Source for the SC611 ONLY.')
bql611WordLength = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bitWord8", 1), ("bitWord9", 2), ("bitWord10", 3), ("bitWord11", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611WordLength.setStatus('mandatory')
if mibBuilder.loadTexts: bql611WordLength.setDescription('Object to select the Word Length for the SC611 or DC621 when selected for async mode.')
bql611OverSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("onePercent", 1), ("twoPointThreePercent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611OverSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: bql611OverSpeed.setDescription('Object to select the Over Speed for the SC611 or DC621.')
bql611RTS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("force", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RTS.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RTS.setDescription('Object to select RTS for SC611 and DC621 only.')
bql611RTSCTSDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noDelay", 1), ("delay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RTSCTSDelay.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RTSCTSDelay.setDescription('Object to select RTS CTS Delay for SC611 and DC621.')
bql611DCD = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("inBandRTS", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611DCD.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DCD.setDescription('Object to select DCD for SC611 and DC621.')
bql611RDL = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RDL.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RDL.setDescription('Object to select the RDL respond for SC611 and DC621.')
bql611RDLMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v54", 1), ("eocorpn127", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RDLMethod.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RDLMethod.setDescription('Object to select RDL Method for SC611 and DC621. SC611 Valid Choices DC621 Valid Choices =================== =================== V54 V54 EOC PN127')
bql611RDLTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("minutes10", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611RDLTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bql611RDLTimeout.setDescription('Object to select RDL Timeout for SC611 or DC621.')
bql611TestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pattern2047", 1), ("pattern511", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611TestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TestPattern.setDescription('Object to Test Pattern for SC611 and DC621.')
bql611DiagnosticTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 4), )
if mibBuilder.loadTexts: bql611DiagnosticTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticTable.setDescription('The GDC SC611/DC621 diagnostics table.')
bql611DiagnosticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611DiagnosticIndex"))
if mibBuilder.loadTexts: bql611DiagnosticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticEntry.setDescription('A listing of GDC SC611/DC621 diagnostic tests')
bql611DiagnosticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611DiagnosticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticIndex.setDescription('A unique index for the Diagnostic Table.')
bql611DiagnosticTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611DiagnosticTest.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticTest.setDescription('This function selects or reads the test. 0 = no test currently operating 1 = remote loopback test 2 = channel loopback test 4 = data loopback test 8 = selftest 16 = line loopback test 32 = terminate test All other values are test combinations such as 9 = selftest and remote loopback.')
bql611DiagnosticActive = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611DiagnosticActive.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticActive.setDescription('This function represents the test condition.')
bql611DiagnosticResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611DiagnosticResults.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticResults.setDescription('This function reads the self test results in bit errors.')
bql611DiagnosticResetErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611DiagnosticResetErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: bql611DiagnosticResetErrorCount.setDescription('Object to reset selftest error count during diagnostic self testing for SC611 and DC621.')
bql611Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9))
bql611AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1))
bql611NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 1))
bql611DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 2))
bql611PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 3))
bql611OutofSyncAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 4))
bql611TxClkOutOfToleranceAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 5))
bql611ExtClkAbsentAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 6))
bql611SealingCurrentNoContinuityAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 7))
bql611DtrNotPresentAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 8))
bql611MajorAlarmBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 9))
bql611MinorAlarmBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 9, 1, 10))
bql621Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11))
bql621AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1))
bql621NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 1))
bql621DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 2))
bql621PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 3))
bql621DtrNotPresentAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 4))
bql621MajorAlarmBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 5))
bql621MinorAlarmBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 11, 1, 6))
bql611AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 9, 2), )
if mibBuilder.loadTexts: bql611AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmConfigTable.setDescription('The bql611AlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
bql611AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 9, 2, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611AlarmConfigIndex"), (0, "GDCSC611-MIB", "bql611AlarmConfigIdentifier"))
if mibBuilder.loadTexts: bql611AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmConfigEntry.setDescription('An entry in the bql611AlarmConfigTable table.')
bql611AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 9, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
bql611AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 9, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
bql611AlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thres10E03", 1), ("thres10E04", 2), ("thres10E05", 3), ("thres10E06", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611AlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bql611AlarmThreshold.setDescription('This function sets/reads the Major or Minor BER alarm threshold criteria for a SC611 or DC621.')
bql611ControlTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 5), )
if mibBuilder.loadTexts: bql611ControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ControlTable.setDescription('The GDC SC611 and DC621 Control Table.')
bql611ControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611ControlIndex"))
if mibBuilder.loadTexts: bql611ControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ControlEntry.setDescription('An entry in the GDC SC611/DC621 Control table.')
bql611ControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611ControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ControlIndex.setDescription('This object is the identifier of the SC611/DC621 Control table.')
bql611SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: bql611SoftReset.setDescription('Forces a soft reset on the network element. The reset selection is write only. The normal selection is read only.')
bql611EraseConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("erase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611EraseConfig.setStatus('mandatory')
if mibBuilder.loadTexts: bql611EraseConfig.setDescription('Forces an erase of the stored configuration in the network element. The erase selection is write only. The normal selection is read only.')
bql611FrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611FrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: bql611FrontPanel.setDescription('Object used to enable or disable the units front panel switches.')
bql611LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bql611LEDStatus.setDescription('The GDC SC611 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - not used 1.5 - not used 1.4 - test mode 1.3 - alarm transitions 1.2 - self test 1.1 - line loopback 1.0 - remote loopback 2.7 - not used 2.6 - not used 2.5 - not used 2.4 - not used 2.3 - send data transitions 2.2 - receive data transitions 2.1 - request to send 2.0 - data carrier detect 3.7 - not used 3.6 - not used 3.5 - not used 3.4 - not used 3.3 - not used 3.2 - not used 3.1 - not used 3.0 - not used')
bql621LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql621LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bql621LEDStatus.setDescription('The GDC DC621 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - sync 1.4 - request to send 1.3 - clear to send 1.2 - carrier 1.1 - send data transitions 1.0 - receive data transitions 2.7 - not used 2.6 - not used 2.5 - not used 2.4 - not used 2.3 - not used 2.2 - not used 2.1 - not used 2.0 - not used 3.7 - not used 3.6 - not used 3.5 - not used 3.4 - not used 3.3 - not used 3.2 - not used 3.1 - not used 3.0 - not used')
bql611CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 6), )
if mibBuilder.loadTexts: bql611CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611CurrentTable.setDescription('The SC611/DC621 Current table.')
bql611CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 6, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611CurrentIndex"))
if mibBuilder.loadTexts: bql611CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611CurrentEntry.setDescription('An entry in the SC611/DC621 Current table.')
bql611CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611CurrentIndex.setDescription('The index value which uniquely identifies the SC611 interface to which this entry is applicable.')
bql611CurrentStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611CurrentStats.setStatus('mandatory')
if mibBuilder.loadTexts: bql611CurrentStats.setDescription('The number of Errored Seconds, Severely Errored Seconds & Unavailable Errored Seconds encountered by an ISDN interface in the current 15 minute interval.')
bql611IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 8), )
if mibBuilder.loadTexts: bql611IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalTable.setDescription('The SC611/DC621 Interval table.')
bql611IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 8, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611IntervalIndex"), (0, "GDCSC611-MIB", "bql611IntervalNumber"))
if mibBuilder.loadTexts: bql611IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalEntry.setDescription('An entry in the SC611/DC621 Interval table.')
bql611IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalIndex.setDescription('The index value which uniquely identifies the ISDN interface to which this entry is applicable.')
bql611IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minute inter- val (assuming that all 96 intervals are valid).')
bql611IntervalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611IntervalStats.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalStats.setDescription('The number of Errored Seconds, Severely Errored Seconds and Unavailable Errored Seconds encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
bql611TotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 9), )
if mibBuilder.loadTexts: bql611TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TotalTable.setDescription('The SC611/DC621 Total table. 24 hour interval.')
bql611TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 9, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611TotalIndex"))
if mibBuilder.loadTexts: bql611TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TotalEntry.setDescription('An entry in the SC611/DC621 Total table.')
bql611TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 9, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TotalIndex.setDescription('The index value which uniquely identifies the ISDN interface to which this entry is applicable.')
bql611TotalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 9, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611TotalStats.setStatus('mandatory')
if mibBuilder.loadTexts: bql611TotalStats.setDescription('The number of Errored Seconds,Severely Errored Seconds & Unavailable Errored Seconds encountered by an ISDN interface in the previous 24 hour interval.')
bql611IntervalMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 2, 10), )
if mibBuilder.loadTexts: bql611IntervalMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalMaintenanceTable.setDescription('The SC611, DC621 Loop Interval Maintenance table. ')
bql611IntervalMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1), ).setIndexNames((0, "GDCSC611-MIB", "bql611IntervalMaintenanceIndex"))
if mibBuilder.loadTexts: bql611IntervalMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalMaintenanceEntry.setDescription('The SC611, DC621 Interval Maintenance table entry. ')
bql611IntervalMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611IntervalMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bql611IntervalMaintenanceIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a Loop interface.')
bql611ResetIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611ResetIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ResetIntervals.setDescription(' This variable is used to reset Loop performance intervals. When it is set to reset, the Loop performance tables are reset to zero.')
bql611NumberofValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bql611NumberofValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: bql611NumberofValidIntervals.setDescription(' This variable is used to read the number of intervals collected. Each interval is an increment of 15 minutes.')
bql611ResetMajorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611ResetMajorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ResetMajorAlarm.setDescription(' This variable is used to reset alarm per Loop basis.')
bql611ResetMinorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bql611ResetMinorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: bql611ResetMinorAlarm.setDescription(' This variable is used to reset alarm per Loop basis.')
mibBuilder.exportSymbols("GDCSC611-MIB", bql611AlarmStatus=bql611AlarmStatus, bql611ConfigEntry=bql611ConfigEntry, bql611IntervalMaintenanceTable=bql611IntervalMaintenanceTable, bql611IntervalMaintenanceEntry=bql611IntervalMaintenanceEntry, bql611WhatAreYouTable=bql611WhatAreYouTable, bql611RDLTimeout=bql611RDLTimeout, bql611AlarmConfigIdentifier=bql611AlarmConfigIdentifier, bql611IntervalTable=bql611IntervalTable, bql611=bql611, bql611RDLMethod=bql611RDLMethod, bql611DiagnosticActive=bql611DiagnosticActive, bql621Alarm=bql621Alarm, bql621DiagRxErrAlm=bql621DiagRxErrAlm, bql611RateAdaption=bql611RateAdaption, bql611OutofSyncAlm=bql611OutofSyncAlm, bql611TotalStats=bql611TotalStats, bql611ResetMinorAlarm=bql611ResetMinorAlarm, bql611AlarmConfigEntry=bql611AlarmConfigEntry, bql611TotalEntry=bql611TotalEntry, bql611DiagnosticEntry=bql611DiagnosticEntry, bql611WordLength=bql611WordLength, bql611AlarmThreshold=bql611AlarmThreshold, bql611TxClkSource=bql611TxClkSource, bql621MinorAlarmBERAlm=bql621MinorAlarmBERAlm, bql611DteOperation=bql611DteOperation, bql611WhatAreYouIndex=bql611WhatAreYouIndex, bql611LEDStatus=bql611LEDStatus, bql611DiagnosticResults=bql611DiagnosticResults, bql611RTS=bql611RTS, bql611DCD=bql611DCD, bql611IntervalIndex=bql611IntervalIndex, bql611ControlTable=bql611ControlTable, bql611TotalTable=bql611TotalTable, bql621=bql621, bql611WhatAreYouEntry=bql611WhatAreYouEntry, bql611FrontPanel=bql611FrontPanel, bql621PowerUpAlm=bql621PowerUpAlm, bql611DiagnosticResetErrorCount=bql611DiagnosticResetErrorCount, bql621LEDStatus=bql621LEDStatus, bql611IntervalMaintenanceIndex=bql611IntervalMaintenanceIndex, bql611ResetMajorAlarm=bql611ResetMajorAlarm, bql611OptionCard=bql611OptionCard, bql611IntervalStats=bql611IntervalStats, bql611IntervalEntry=bql611IntervalEntry, bql611DtrNotPresentAlm=bql611DtrNotPresentAlm, bql611OverSpeed=bql611OverSpeed, bql611DiagRxErrAlm=bql611DiagRxErrAlm, bql611CurrentTable=bql611CurrentTable, bql611CurrentStats=bql611CurrentStats, bql611AlarmData=bql611AlarmData, bql611AlarmConfigIndex=bql611AlarmConfigIndex, bql611CodeRev=bql611CodeRev, bql621MajorAlarmBERAlm=bql621MajorAlarmBERAlm, gdc=gdc, bql611MinorAlarmBERAlm=bql611MinorAlarmBERAlm, bql611SealingCurrentNoContinuityAlm=bql611SealingCurrentNoContinuityAlm, bql611MajorAlarmBERAlm=bql611MajorAlarmBERAlm, bql611DiagnosticTest=bql611DiagnosticTest, bql611AlarmConfigTable=bql611AlarmConfigTable, bql611TestPattern=bql611TestPattern, bql611TotalIndex=bql611TotalIndex, bql611EraseConfig=bql611EraseConfig, bql611IntervalNumber=bql611IntervalNumber, bql611RDL=bql611RDL, bql611ControlIndex=bql611ControlIndex, bql611ExtClkAbsentAlm=bql611ExtClkAbsentAlm, bql611ResetIntervals=bql611ResetIntervals, bql611DteRate=bql611DteRate, bql611BaseCardType=bql611BaseCardType, bql611MIBVersion=bql611MIBVersion, bql611DiagnosticIndex=bql611DiagnosticIndex, bql611NumberofValidIntervals=bql611NumberofValidIntervals, bql611PowerUpAlm=bql611PowerUpAlm, bql611TxClkOutOfToleranceAlm=bql611TxClkOutOfToleranceAlm, bql611Alarm=bql611Alarm, bql611ControlEntry=bql611ControlEntry, bql611ConfigIndex=bql611ConfigIndex, bql621AlarmData=bql621AlarmData, bql621DtrNotPresentAlm=bql621DtrNotPresentAlm, bql611RTSCTSDelay=bql611RTSCTSDelay, bql611SoftReset=bql611SoftReset, bql621NoResponseAlm=bql621NoResponseAlm, bql611CurrentEntry=bql611CurrentEntry, bql2=bql2, bql611ConfigTable=bql611ConfigTable, bql611DiagnosticTable=bql611DiagnosticTable, bql611NoResponseAlm=bql611NoResponseAlm, bql611DTECardType=bql611DTECardType, bql611CurrentIndex=bql611CurrentIndex)

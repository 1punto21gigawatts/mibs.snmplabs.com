#
# PySNMP MIB module NETSERVER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETSERVER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:20:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, mib_2, Bits, Counter64, NotificationType, NotificationType, enterprises, ObjectIdentity, Counter32, ModuleIdentity, TimeTicks, IpAddress, MibIdentifier, iso, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "mib-2", "Bits", "Counter64", "NotificationType", "NotificationType", "enterprises", "ObjectIdentity", "Counter32", "ModuleIdentity", "TimeTicks", "IpAddress", "MibIdentifier", "iso", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
auspex = MibIdentifier((1, 3, 6, 1, 4, 1, 80))
netServer = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3))
axProductInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 1))
axNP = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 2))
axFSP = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3))
axTrapData = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4))
axFP = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 2))
fpHTFS = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3))
axSP = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 3))
spRaid = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 3, 2))
npProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 2, 3))
axFab = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 4))
fabRaid = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5))
axProductName = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axProductName.setStatus('mandatory')
if mibBuilder.loadTexts: axProductName.setDescription('Name of the file server product.')
axSWVersion = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: axSWVersion.setDescription('Version of the M16 Kernel on Netserver')
axNumNPFSP = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axNumNPFSP.setStatus('mandatory')
if mibBuilder.loadTexts: axNumNPFSP.setDescription('Number of NPFSP boards on file server.')
npTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 1), )
if mibBuilder.loadTexts: npTable.setStatus('mandatory')
if mibBuilder.loadTexts: npTable.setDescription('A table for all NPs(Network Processors) on the file server.')
npEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npEntry.setDescription('An entry for each NP on the file server.')
npIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIndex.setStatus('mandatory')
if mibBuilder.loadTexts: npIndex.setDescription('A unique number for identifying an NP in the system.')
npBusyCount = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npBusyCount.setStatus('mandatory')
if mibBuilder.loadTexts: npBusyCount.setDescription('Busy counts of NP.')
npIdleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIdleCount.setStatus('mandatory')
if mibBuilder.loadTexts: npIdleCount.setDescription('Idle counts of NP.')
npIfTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 2), )
if mibBuilder.loadTexts: npIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: npIfTable.setDescription('Table containing information for each interface of NP. It maps the interface with the NP')
npIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"), (0, "NETSERVER-MIB", "npIfIndex"))
if mibBuilder.loadTexts: npIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npIfEntry.setDescription('Entry for each interface')
npIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: npIfIndex.setDescription('A unique number for an interface for a given NP')
npIfifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: npIfifIndex.setDescription('Corresponding ifINdex in ifTable of mib-2')
npIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfType.setStatus('mandatory')
if mibBuilder.loadTexts: npIfType.setDescription('Type of network interface ')
npIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: npIfSpeed.setDescription('Nominal Interface Speed (in millions of bits per second)')
npIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInOctets.setDescription('The total number of octets received on the interface, including framing characters')
npIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInUcastPkts.setDescription('The number of subnetwork-unicast packets delivered to a higher-layer protocol')
npIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork-broadcast or multicast) packets delivered to a higher-layer protocol')
npIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInDiscards.setDescription('The inbound packet discard count even though no errors were detected. One reason for discarding could be to free up buffer space')
npIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInErrors.setDescription('The input-packet error count for an interface for a given NP')
npIfInUnknownProto = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfInUnknownProto.setStatus('mandatory')
if mibBuilder.loadTexts: npIfInUnknownProto.setDescription('The input-packet discard count due to an unknown or unsupported protocol')
npIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters')
npIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a subnetwork-unicast address, including those that were discarded or not sent')
npIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non-unicast (i.e., a subnetwork-broadcast or multicast) address, including those that were discarded or not sent')
npIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutDiscards.setDescription('The number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possibel reason for discarding such a packet could be to free up buffer space')
npIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors')
npIfOutCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutCollisions.setDescription('The output-packet collision count for an interface for a given NP')
npIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOutQLen.setDescription('The output-packet queue length (in packets) for an interface for a given NP')
npIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: npIfAdminStatus.setDescription('The desired state of the interface. The testing(3) state indicates that no operational packets can be passed.')
npIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: npIfOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational packets can be passed.')
npIPTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1), )
if mibBuilder.loadTexts: npIPTable.setStatus('mandatory')
if mibBuilder.loadTexts: npIPTable.setDescription('Table for Internet Protocol statistics for each NP of the system.')
npIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npIPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npIPEntry.setDescription('An entry for each NP in the system.')
npIPForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("not-forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: npIPForwarding.setDescription('It has two values : forwarding(1) -- acting as gateway notforwarding(2) -- NOT acting as gateway')
npIPDefaultTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPDefaultTTL.setStatus('mandatory')
if mibBuilder.loadTexts: npIPDefaultTTL.setDescription('NP IP default Time To Live.')
npIPInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInReceives.setDescription('NP IP received packet count.')
npIPInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInHdrErrors.setDescription('NP IP header error count.')
npIPInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInAddrErrors.setDescription('NP IP address error count.')
npIPForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: npIPForwDatagrams.setDescription('NP IP forwarded datagram count.')
npIPInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInUnknownProtos.setDescription('NP IP input packet with unknown protocol.')
npIPInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInDiscards.setDescription('NP IP discarded input packet count.')
npIPInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: npIPInDelivers.setDescription('NP IP delivered input packet count.')
npIPOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: npIPOutRequests.setDescription('NP IP tx packet count.')
npIPOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: npIPOutDiscards.setDescription('NP IP discarded out packet count.')
npIPOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: npIPOutNoRoutes.setDescription('NP IP tx fails due to no route count.')
npIPReasmTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPReasmTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: npIPReasmTimeout.setDescription('NP IP reassembly time out count.')
npIPReasmReqds = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPReasmReqds.setStatus('mandatory')
if mibBuilder.loadTexts: npIPReasmReqds.setDescription('NP IP reassembly required count.')
npIPReasmOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPReasmOKs.setStatus('mandatory')
if mibBuilder.loadTexts: npIPReasmOKs.setDescription('NP IP reassembly success count.')
npIPReasmFails = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPReasmFails.setStatus('mandatory')
if mibBuilder.loadTexts: npIPReasmFails.setDescription('NP IP reassembly failure count.')
npIPFragOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPFragOKs.setStatus('mandatory')
if mibBuilder.loadTexts: npIPFragOKs.setDescription('NP IP fragmentation success count.')
npIPFragFails = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPFragFails.setStatus('mandatory')
if mibBuilder.loadTexts: npIPFragFails.setDescription('NP IP fragmentation failure count.')
npIPFragCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPFragCreates.setStatus('mandatory')
if mibBuilder.loadTexts: npIPFragCreates.setDescription('NP IP fragment created count.')
npIPRoutingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npIPRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: npIPRoutingDiscards.setDescription('NP IP discarded route count.')
npICMPTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2), )
if mibBuilder.loadTexts: npICMPTable.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPTable.setDescription('Table for Internet Control Message Protocol statistics for each NP of the system.')
npICMPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npICMPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPEntry.setDescription('An entry for each NP in the system.')
npICMPInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInMsgs.setDescription('NP ICMP input message count.')
npICMPInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInErrors.setDescription('NP ICMP input error packet count.')
npICMPInDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInDestUnreachs.setDescription('NP ICMP input destination unreachable count.')
npICMPInTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInTimeExcds.setDescription('NP ICMP input time exceeded count.')
npICMPInParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInParmProbs.setDescription('NP ICMP input parameter problem packet count.')
npICMPInSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInSrcQuenchs.setDescription('NP ICMP input source quench packet count.')
npICMPInRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInRedirects.setDescription('NP ICMP input redirect packet count.')
npICMPInEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInEchos.setDescription('NP ICMP input echo count.')
npICMPInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInEchoReps.setDescription('NP ICMP input echo reply count.')
npICMPInTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInTimestamps.setDescription('NP ICMP input timestamp count.')
npICMPInTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInTimestampReps.setDescription('NP ICMP input timestamp reply count.')
npICMPInAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInAddrMasks.setDescription('NP ICMP input address mask count.')
npICMPInAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPInAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPInAddrMaskReps.setDescription('NP ICMP input address mask reply count.')
npICMPOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutMsgs.setDescription('NP ICMP output message count.')
npICMPOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutErrors.setDescription('NP ICMP output error packet count.')
npICMPOutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutDestUnreachs.setDescription('NP ICMP output destination unreachable count.')
npICMPOutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutTimeExcds.setDescription('NP ICMP output time exceeded count.')
npICMPOutParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutParmProbs.setDescription('NP ICMP output parameter problem packet count.')
npICMPOutSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutSrcQuenchs.setDescription('NP ICMP output source quench packet count.')
npICMPOutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutRedirects.setDescription('NP ICMP output redirect packet count.')
npICMPOutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutEchos.setDescription('NP ICMP output echo count.')
npICMPOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutEchoReps.setDescription('NP ICMP output echo reply count.')
npICMPOutTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutTimestamps.setDescription('NP ICMP output timestamp count.')
npICMPOutTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutTimestampReps.setDescription('NP ICMP output timestamp reply count.')
npICMPOutAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutAddrMasks.setDescription('NP ICMP output address mask count.')
npICMPOutAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npICMPOutAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: npICMPOutAddrMaskReps.setDescription('NP ICMP output address mask reply count.')
npTCPTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3), )
if mibBuilder.loadTexts: npTCPTable.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPTable.setDescription('Table for Transmission Control Protocol statistics for each NP of the system.')
npTCPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npTCPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPEntry.setDescription('An entry for each NP in the system.')
npTCPRtoAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("constant", 2), ("rsre", 3), ("vanj", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPRtoAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPRtoAlgorithm.setDescription('NP TCP Round Trip Algorithm type.')
npTCPRtoMin = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPRtoMin.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPRtoMin.setDescription('NP TCP minimum RTO.')
npTCPRtoMax = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPRtoMax.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPRtoMax.setDescription('NP TCP maximum RTO.')
npTCPMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPMaxConn.setDescription('NP TCP maximum number of connections.')
npTCPActiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPActiveOpens.setDescription('NP TCP active open count.')
npTCPPassiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPPassiveOpens.setDescription('NP TCP passive open count.')
npTCPAttemptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPAttemptFails.setDescription('NP TCP connect attempt fails.')
npTCPEstabResets = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPEstabResets.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPEstabResets.setDescription('NP TCP reset of established session.')
npTCPCurrEstab = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPCurrEstab.setDescription('NP TCP current established session count.')
npTCPInSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPInSegs.setDescription('NP TCP input segments count.')
npTCPOutSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPOutSegs.setDescription('NP TCP output segments count.')
npTCPRetransSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPRetransSegs.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPRetransSegs.setDescription('NP TCP retransmitted segments count.')
npTCPInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPInErrs.setDescription('NP TCP input error packets count.')
npTCPOutRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npTCPOutRsts.setStatus('mandatory')
if mibBuilder.loadTexts: npTCPOutRsts.setDescription('NP TCP output reset packets count.')
npUDPTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4), )
if mibBuilder.loadTexts: npUDPTable.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPTable.setDescription('Table for User Datagram Protocol statistics for each NP of the system.')
npUDPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npUDPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPEntry.setDescription('An entry for each NP in the system.')
npUDPInDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npUDPInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPInDatagrams.setDescription('NP UDP input datagram count.')
npUDPNoPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npUDPNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPNoPorts.setDescription('NP UDP number of ports.')
npUDPInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npUDPInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPInErrors.setDescription('NP UDP input error count.')
npUDPOutDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npUDPOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: npUDPOutDatagrams.setDescription('Np UDP output datagram count.')
npNFSTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 5), )
if mibBuilder.loadTexts: npNFSTable.setStatus('mandatory')
if mibBuilder.loadTexts: npNFSTable.setDescription('Table for Network File System statistics for each NP in the system.')
npNFSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 5, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npNFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npNFSEntry.setDescription('An entry for each NP in the system.')
npNFSDCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npNFSDCounts.setStatus('mandatory')
if mibBuilder.loadTexts: npNFSDCounts.setDescription('NP NFS count (obtained from NFS daemon)')
npNFSDNJobs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npNFSDNJobs.setStatus('mandatory')
if mibBuilder.loadTexts: npNFSDNJobs.setDescription('NP NFS number of jobs (obtained from NFS daemon)')
npNFSDBusyCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npNFSDBusyCounts.setStatus('mandatory')
if mibBuilder.loadTexts: npNFSDBusyCounts.setDescription('NP NFS busy count (obtained from NFS daemon)')
npSMBTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6), )
if mibBuilder.loadTexts: npSMBTable.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBTable.setDescription('Contains statistical counts for the SMB protocol per NP')
npSMBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1), ).setIndexNames((0, "NETSERVER-MIB", "npIndex"))
if mibBuilder.loadTexts: npSMBEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBEntry.setDescription('An entry for each NP in the system.')
npSMBRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBRcvd.setDescription('The total number of SMB netbios messages received.')
npSMBBytesRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBBytesRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBBytesRcvd.setDescription('The total number of SMB related bytes rvcd by this NP from a client (does not include netbios header bytes).')
npSMBBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBBytesSent.setDescription('The total SMB related bytes sent by this NP to a client (does not include netbios header bytes).')
npSMBReads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBReads.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBReads.setDescription('The total number of SMB reads consisting of the following opcodes: SMB-COM-READ, SMB-COM-LOCK-AND-READ, SMB-COM-READ-RAW, SMB-COM-READ-MPX, SMB-COM-READ-MPX-SECONDARY and SMB-COM-READ-ANDX.')
npSMBWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBWrites.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBWrites.setDescription('The total number of SMB writes consisting of the following opcodes: SMB-COM-WRITE, SMB-COM-WRITE-AND-UNLOCK, SMB-COM-WRITE-RAW, SMB-COM-WRITE-MPX, SMB-COM-WRITE-COMPLETE, SMB-COM-WRITE-ANDX and SMB-COM-WRITE-AND-CLOSE.')
npSMBOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBOpens.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBOpens.setDescription('The total number of SMB opens consisting of the SMB-COM-OPEN, SMB-COM-CREATE,SMB-COM-CREATE-TEMPORARY,SMB-COM-CREATE-NEW, TRANS2-OPEN2, NT-TRANSACT-CREATE and SMB-COM-OPEN-ANDX opcodes received.')
npSMBCloses = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBCloses.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBCloses.setDescription('The total number of SMB SMB-COM-CLOSE opcodes recieved.')
npSMBErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBErrors.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBErrors.setDescription('The total number of invalid netbios messages recieved.')
npSMBLocksHeld = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 2, 3, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npSMBLocksHeld.setStatus('mandatory')
if mibBuilder.loadTexts: npSMBLocksHeld.setDescription('The total number of locks currently held')
fspTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 1), )
if mibBuilder.loadTexts: fspTable.setStatus('mandatory')
if mibBuilder.loadTexts: fspTable.setDescription('A table for all FSPs(File and Storage Processors) on the file server.')
fspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fspEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fspEntry.setDescription('An entry for one FSP on the file server.')
fspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fspIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fspIndex.setDescription('A unique number for identifying an FSP in the system.')
fspBusyCount = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fspBusyCount.setStatus('mandatory')
if mibBuilder.loadTexts: fspBusyCount.setDescription('Busy counts of FSP.')
fspIdleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fspIdleCount.setStatus('mandatory')
if mibBuilder.loadTexts: fspIdleCount.setDescription('Idle counts of FSP.')
fpLFSTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1), )
if mibBuilder.loadTexts: fpLFSTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSTable.setDescription('Table for FP File System Services Statistics for each FSP on the system.')
fpLFSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fpLFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSEntry.setDescription('An entry for each FSP in the system.')
fpLFSVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSVersion.setDescription('FP file system services statistics version.')
fpLFSMounts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSMounts.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSMounts.setDescription('FP file system services - FC-MOUNT - Counter.')
fpLFSUMounts = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSUMounts.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSUMounts.setDescription('FP file system services - FC-UMOUNT - Counter.')
fpLFSReads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSReads.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSReads.setDescription('FP file system services - FC-READ - Counter.')
fpLFSWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSWrites.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSWrites.setDescription('FP file system services - FC-WRITE - Counter.')
fpLFSReaddirs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSReaddirs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSReaddirs.setDescription('FP file system services - FC-READDIR - Counter.')
fpLFSReadlinks = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSReadlinks.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSReadlinks.setDescription('FP file system services - FC-READLINK - Counter.')
fpLFSMkdirs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSMkdirs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSMkdirs.setDescription('FP file system services - FC-MKDIR - Counter.')
fpLFSMknods = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSMknods.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSMknods.setDescription('FP file system services - FC-MKNOD - Counter.')
fpLFSReaddirPluses = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSReaddirPluses.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSReaddirPluses.setDescription('FP file system services - FC-READDIR-PLUS - Counter.')
fpLFSFsstats = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSFsstats.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSFsstats.setDescription('FP file system services - FC-FSSTAT - Counter.')
fpLFSNull = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSNull.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSNull.setDescription('FP file system services - FC-NULL - Counter.')
fpLFSFsinfo = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSFsinfo.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSFsinfo.setDescription('FP file system services - FC-FSINFO - Counter.')
fpLFSGetattrs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSGetattrs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSGetattrs.setDescription('FP file system services - FC-GETATTR - Counter.')
fpLFSSetattrs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSSetattrs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSSetattrs.setDescription('FP file system services - FC-SETATTR - Counter.')
fpLFSLookups = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSLookups.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSLookups.setDescription('FP file system services - FC-LOOKUP - Counter.')
fpLFSCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSCreates.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSCreates.setDescription('FP file system services - FC-CREATE - Counter.')
fpLFSRemoves = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSRemoves.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSRemoves.setDescription('FP file system services - FC-REMOVE - Counter.')
fpLFSRenames = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSRenames.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSRenames.setDescription('FP file system services - FC-RENAME - Counter.')
fpLFSLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSLinks.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSLinks.setDescription('FP file system services - FC-LINK - Counter.')
fpLFSSymlinks = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSSymlinks.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSSymlinks.setDescription('FP file system services - FC-SYMLINK - Counter.')
fpLFSRmdirs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSRmdirs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSRmdirs.setDescription('FP file system services - FC-RMDIR - Counter.')
fpLFSCkpntons = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSCkpntons.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSCkpntons.setDescription('FP file system services - FC-CKPNTON - Counter.')
fpLFSCkpntoffs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSCkpntoffs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSCkpntoffs.setDescription('FP file system services - FC-CKPNTOFFS - Counter.')
fpLFSClears = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSClears.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSClears.setDescription('FP file system services - FC-CLEAR - Counter.')
fpLFSIsolateFs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSIsolateFs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSIsolateFs.setDescription('FP file system services - FC-ISOLATE-FS - Counter.')
fpLFSReleaseFs = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSReleaseFs.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSReleaseFs.setDescription('FP file system services - FC-RELEASE-FS - Counter.')
fpLFSIsolationStates = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSIsolationStates.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSIsolationStates.setDescription('FP file system services - FC-ISOLATION-STATE - Counter.')
fpLFSDiagnostics = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSDiagnostics.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSDiagnostics.setDescription('FP file system services - FC-DIAGNOSTIC - Counter.')
fpLFSPurges = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpLFSPurges.setStatus('mandatory')
if mibBuilder.loadTexts: fpLFSPurges.setDescription('FP file system services - FC-PURGE - Counter.')
fpFileSystemTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 2), )
if mibBuilder.loadTexts: fpFileSystemTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpFileSystemTable.setDescription('Table containg File systems on each FSP')
fpFSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "fpFSIndex"))
if mibBuilder.loadTexts: fpFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpFSEntry.setDescription('Entry for each File System')
fpFSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpFSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fpFSIndex.setDescription('Uniquely identifies each FS on FSP')
fpHrFSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpHrFSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fpHrFSIndex.setDescription('Index of the corresponding FS entry in host resource mib')
fpDNLCTStatTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1), )
if mibBuilder.loadTexts: fpDNLCTStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCTStatTable.setDescription('DNLC is part of StackOS module. This table displays DNLC Statistics.')
fpDNLCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fpDNLCSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCSEntry.setDescription('Each entry for a FSP board.')
fpDNLCHit = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCHit.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCHit.setDescription('DNLC hit on a given FSP.')
fpDNLCMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCMiss.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCMiss.setDescription('DNLC miss on a given FSP.')
fpDNLCEnter = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCEnter.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCEnter.setDescription('Number of DNLC entries made (total).')
fpDNLCConflict = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCConflict.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCConflict.setDescription('Times entry found in DNLC on dnlc-enter.')
fpDNLCPurgevfsp = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCPurgevfsp.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCPurgevfsp.setDescription('Entries purged based on vfsp.')
fpDNLCPurgevp = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCPurgevp.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCPurgevp.setDescription('Entries purge based on vp.')
fpDNLCHashsz = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpDNLCHashsz.setStatus('mandatory')
if mibBuilder.loadTexts: fpDNLCHashsz.setDescription('Number of hash buckets in dnlc hash table.')
fpPageStatTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2), )
if mibBuilder.loadTexts: fpPageStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpPageStatTable.setDescription('Page is part of StackOS module. This table gives the Page Statistics for all FSPs.')
fpPageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fpPageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpPageEntry.setDescription('Each Entry in the table displays Page Statistics for a FSP.')
fpPAGETotalmem = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGETotalmem.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGETotalmem.setDescription('Allocated memory for pages.')
fpPAGEFreelistcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEFreelistcnt.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEFreelistcnt.setDescription('Pages on freelist.')
fpPAGECachelistcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGECachelistcnt.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGECachelistcnt.setDescription('Pages on cachelist.')
fpPAGEDirtyflistcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEDirtyflistcnt.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEDirtyflistcnt.setDescription('Pages on dirtyflist.')
fpPAGEDirtydlistcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEDirtydlistcnt.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEDirtydlistcnt.setDescription('Pages on dirtydlist')
fpPAGECachehit = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGECachehit.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGECachehit.setDescription('Page cache hit.')
fpPAGECachemiss = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGECachemiss.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGECachemiss.setDescription('Page cache miss.')
fpPAGEWritehit = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEWritehit.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEWritehit.setDescription('Page cache write hit.')
fpPAGEWritemiss = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEWritemiss.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEWritemiss.setDescription('Page cache write miss.')
fpPAGEZcref = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEZcref.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEZcref.setDescription('Page Zref.')
fpPAGEZcbreak = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEZcbreak.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEZcbreak.setDescription('Page Zbreak.')
fpPAGEOutscan = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEOutscan.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEOutscan.setDescription('Page out scan.')
fpPAGEOutputpage = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEOutputpage.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEOutputpage.setDescription('Output Page.')
fpPAGEFsflushscan = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEFsflushscan.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEFsflushscan.setDescription('Flush scan.')
fpPAGEFsflushputpage = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEFsflushputpage.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEFsflushputpage.setDescription('Flush output page.')
fpPAGEOutcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpPAGEOutcnt.setStatus('mandatory')
if mibBuilder.loadTexts: fpPAGEOutcnt.setDescription('Page out count.')
fpBufferStatTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3), )
if mibBuilder.loadTexts: fpBufferStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpBufferStatTable.setDescription('BufferIO is one of the modules present in StackOS. This table displays the bufferIO statistics for all FSPs.')
fpBufferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fpBufferEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpBufferEntry.setDescription('Each entry in the table for a single FSP.')
fpBUFLreads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFLreads.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFLreads.setDescription('Number of buffered reads.')
fpBUFBreads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFBreads.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFBreads.setDescription('Number of breads doing sp-read.')
fpBUFLwrites = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFLwrites.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFLwrites.setDescription('Number of buffered writes (incl. delayed).')
fpBUFBwrites = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFBwrites.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFBwrites.setDescription('Number of bwrites doing sp-write.')
fpBUFIOwaits = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFIOwaits.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFIOwaits.setDescription('Number of processes blocked in biowait.')
fpBUFResid = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFResid.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFResid.setDescription('Running total of unused buf memory.')
fpBUFBufsize = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFBufsize.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFBufsize.setDescription('Running total of memory on free list.')
fpBUFBcount = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpBUFBcount.setStatus('mandatory')
if mibBuilder.loadTexts: fpBUFBcount.setDescription('Running total of memory on hash lists.')
fpInodeTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4), )
if mibBuilder.loadTexts: fpInodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fpInodeTable.setDescription('Inode table displays the Inode Statistics for all FSPs. Inode is part of StackOS module.')
fpInodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"))
if mibBuilder.loadTexts: fpInodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fpInodeEntry.setDescription('Each entry in the table displays Inode Statistics for a FSP.')
fpINODEIgetcalls = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpINODEIgetcalls.setStatus('mandatory')
if mibBuilder.loadTexts: fpINODEIgetcalls.setDescription('Number of calls to htfs-iget.')
fpFoundinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpFoundinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpFoundinodes.setDescription('Inode cache hits.')
fpTotalinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpTotalinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpTotalinodes.setDescription('Total number of inodes in memory.')
fpGoneinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpGoneinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpGoneinodes.setDescription('Number of inodes on gone list.')
fpFreeinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpFreeinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpFreeinodes.setDescription('Number of inodes on free list.')
fpCacheinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpCacheinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpCacheinodes.setDescription('Number of inodes on cache list.')
fpSyncinodes = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 2, 3, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpSyncinodes.setStatus('mandatory')
if mibBuilder.loadTexts: fpSyncinodes.setDescription('Number of inodes on sync list.')
class RaidLevel(TextualConvention, Integer32):
    description = 'Defines the type of Raid Level present in the system'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 3, 5, 6, 7))
    namedValues = NamedValues(("raid0", 0), ("raid1", 1), ("raid3", 3), ("raid5", 5), ("raid6", 6), ("raid7", 7))

class RebuildFlag(TextualConvention, Integer32):
    description = 'Defines the Rebuild Flag type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 240, 241, 242, 243, 244, 255))
    namedValues = NamedValues(("none", 0), ("autorebuild", 1), ("manualrebuild", 2), ("check", 3), ("expandcapacity", 4), ("phydevfailed", 240), ("logdevfailed", 241), ("justfailed", 242), ("canceled", 243), ("expandcapacityfailed", 244), ("autorebuildfailed", 255))

class BusType(TextualConvention, Integer32):
    description = 'Defines Bus type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("eisa", 1), ("mca", 2), ("pci", 3), ("vesa", 4), ("isa", 5), ("scsi", 6))

class ControllerType(TextualConvention, Integer32):
    description = 'This textual Convention defines the type of Controller.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 8, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 80, 96, 97, 98, 99, 100, 129, 130, 131, 132, 133, 134, 136, 137, 138, 139, 140, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 192, 193, 194, 195))
    namedValues = NamedValues(("dac960E", 1), ("dac960M", 8), ("dac960PD", 16), ("dac960PL", 17), ("dac960PDU", 18), ("dac960PE", 19), ("dac960PG", 20), ("dac960PJ", 21), ("dac960PTL", 22), ("dac960PR", 23), ("dac960PRL", 24), ("dac960PT", 25), ("dac1164P", 26), ("dacI20", 80), ("dac960S", 96), ("dac960SU", 97), ("dac960SX", 98), ("dac960SF", 99), ("dac960FL", 100), ("hba440", 129), ("hba440C", 130), ("hba445", 131), ("hba445C", 132), ("hba440xC", 133), ("hba445S", 134), ("hba640", 136), ("hba640A", 137), ("hba446", 138), ("hba446D", 139), ("hba446S", 140), ("hba742", 144), ("hba742A", 145), ("hba747", 146), ("hba747D", 147), ("hba747S", 148), ("hba74xC", 149), ("hba757", 150), ("hba757D", 151), ("hba757S", 152), ("hba757CD", 153), ("hba75xC", 154), ("hba747C", 155), ("hba757C", 156), ("hba540", 160), ("hba540C", 161), ("hba542", 162), ("hba542B", 163), ("hba542C", 164), ("hba542D", 165), ("hba545", 166), ("hba545C", 167), ("hba545S", 168), ("hba54xC", 169), ("hba946", 176), ("hba946C", 177), ("hba948", 178), ("hba948C", 179), ("hba956", 180), ("hba956C", 181), ("hba958", 182), ("hba958C", 183), ("hba958D", 184), ("hba956CD", 185), ("hba958CD", 186), ("hba930", 192), ("hba932", 193), ("hba950", 194), ("hba952", 195))

class VendorName(TextualConvention, Integer32):
    description = 'Name of the Vendors'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("mylex", 0), ("ibm", 1), ("hp", 2), ("dec", 3), ("att", 4), ("dell", 5), ("nec", 6), ("sni", 7), ("ncr", 8))

class U08Bits(TextualConvention, Integer32):
    description = 'Integer type of range 0..255'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class U16Bits(TextualConvention, Integer32):
    description = 'Integer type of range 0..65535'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

fabLogDevTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1), )
if mibBuilder.loadTexts: fabLogDevTable.setStatus('mandatory')
if mibBuilder.loadTexts: fabLogDevTable.setDescription('This table contains information for logical devices.')
fabLogDevEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "ldIndex"))
if mibBuilder.loadTexts: fabLogDevEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fabLogDevEntry.setDescription('Entry for each logical device')
ldIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ldIndex.setDescription(' Index of the logical device')
ldSectorReads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldSectorReads.setStatus('mandatory')
if mibBuilder.loadTexts: ldSectorReads.setDescription(' Number of sectors read ')
ldWBufReads = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldWBufReads.setStatus('mandatory')
if mibBuilder.loadTexts: ldWBufReads.setDescription(' Number of sectors read from WBUF ')
ldSectorWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldSectorWrites.setStatus('mandatory')
if mibBuilder.loadTexts: ldSectorWrites.setDescription('Number of sector writes ')
ldReadIO = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldReadIO.setStatus('mandatory')
if mibBuilder.loadTexts: ldReadIO.setDescription("Number of read IO's ")
ldWriteIO = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldWriteIO.setStatus('mandatory')
if mibBuilder.loadTexts: ldWriteIO.setDescription("Number of write IO's ")
ldMediaErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldMediaErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ldMediaErrors.setDescription('Number of media errors ')
ldDriveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldDriveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ldDriveErrors.setDescription('Number of drive errors ')
ldTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldTotalTime.setStatus('mandatory')
if mibBuilder.loadTexts: ldTotalTime.setDescription('Total time for the logical device')
fabAdptTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1), )
if mibBuilder.loadTexts: fabAdptTable.setStatus('mandatory')
if mibBuilder.loadTexts: fabAdptTable.setDescription('Table containing information for all fibre channel adapters information on the Auspex IO node')
fabAdptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "fabIndex"))
if mibBuilder.loadTexts: fabAdptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fabAdptEntry.setDescription('Entry for each fibre channel adapter')
fabIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fabIndex.setDescription('Fabric adapter index')
fabPCIBusNum = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 2), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabPCIBusNum.setStatus('mandatory')
if mibBuilder.loadTexts: fabPCIBusNum.setDescription('Fabric adapter PCI BUS number')
fabSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 3), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: fabSlotNum.setDescription('Fabric adapter Slot number')
fabIntLine = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 4), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabIntLine.setStatus('mandatory')
if mibBuilder.loadTexts: fabIntLine.setDescription('Fabric adapter Interrupt line')
fabIntPin = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 5), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabIntPin.setStatus('mandatory')
if mibBuilder.loadTexts: fabIntPin.setDescription('Fabric adapter Interrupt pin')
fabType = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 6), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabType.setStatus('mandatory')
if mibBuilder.loadTexts: fabType.setDescription('Fabric adapter Type')
fabVendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 7), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabVendorId.setStatus('mandatory')
if mibBuilder.loadTexts: fabVendorId.setDescription('Fabric adapter Vendor ID')
fabDeviceId = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 8), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabDeviceId.setStatus('mandatory')
if mibBuilder.loadTexts: fabDeviceId.setDescription('Fabric adapter Device ID')
fabRevisionId = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 9), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabRevisionId.setStatus('mandatory')
if mibBuilder.loadTexts: fabRevisionId.setDescription('Fabric adapter Revision ID')
fabWWN = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabWWN.setStatus('mandatory')
if mibBuilder.loadTexts: fabWWN.setDescription('Fabric adapter World Wide Number')
fabNumOfTargets = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 11), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabNumOfTargets.setStatus('mandatory')
if mibBuilder.loadTexts: fabNumOfTargets.setDescription('Number of targets found for the adapter')
fabAdptNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 1, 1, 12), U08Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabAdptNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabAdptNumber.setDescription('Fabric adapter Number')
fabTargetTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2), )
if mibBuilder.loadTexts: fabTargetTable.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetTable.setDescription('Table containing information for all fibre channel adapters information on the Auspex IO node')
fabTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "fabTargetIndex"))
if mibBuilder.loadTexts: fabTargetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetEntry.setDescription('Entry for each fibre channel adapter')
fabTargetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetIndex.setDescription('The Fabric target adapter index ')
fabTargetAdapterNum = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 2), U08Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetAdapterNum.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetAdapterNum.setDescription('The fabric target Adapter number')
fabTargetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 3), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetNumber.setDescription('The fabric target number')
fabTargetWWN = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetWWN.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetWWN.setDescription('The fabric target WWN number')
fabTargetPortWWN = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetPortWWN.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetPortWWN.setDescription('The fabric target Port WWN number')
fabTargetAliasName = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetAliasName.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetAliasName.setDescription('The fabric target Alias Name')
fabTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disk", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetType.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetType.setDescription('The fabric target Type disk - other ')
fabTargetNumOfLuns = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 2, 1, 8), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabTargetNumOfLuns.setStatus('mandatory')
if mibBuilder.loadTexts: fabTargetNumOfLuns.setDescription('The number of luns on the target')
fabLunTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3), )
if mibBuilder.loadTexts: fabLunTable.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunTable.setDescription('Table containing information for all Luns ')
fabLunEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "fabLunIndex"))
if mibBuilder.loadTexts: fabLunEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunEntry.setDescription('Entry for each Lun')
fabLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunIndex.setDescription('Unique Lun identifier')
fabLunNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 2), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunNumber.setDescription(' Lun Number ')
fabLunAdptNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 3), U08Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunAdptNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunAdptNumber.setDescription('The adapter number for the lun')
fabLunTarNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 4), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunTarNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunTarNumber.setDescription('The Target number for the lun')
fabLunWWN = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunWWN.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunWWN.setDescription('The worldwide number for the lun')
fabLunType = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 6), U08Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunType.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunType.setDescription('The type of the lun')
fabLunSize = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunSize.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunSize.setDescription('The size of the lun')
fabLunMap = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unmapped", 0), ("mapped", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunMap.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMap.setDescription('Identifier for the lun mapping')
fabLunMapTable = MibTable((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4), )
if mibBuilder.loadTexts: fabLunMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMapTable.setDescription('Table containing mapping information for all Luns ')
fabLunMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1), ).setIndexNames((0, "NETSERVER-MIB", "fspIndex"), (0, "NETSERVER-MIB", "fabLunMapIndex"))
if mibBuilder.loadTexts: fabLunMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMapEntry.setDescription('Entry for each mapped Lun')
fabLunMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMapIndex.setDescription('Unique Mapped Lun identifier')
fabLunMNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1, 2), U16Bits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunMNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMNumber.setDescription(' Mapped Lun Number ')
fabLunAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunAlias.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunAlias.setDescription('The Alias name associated with the lun')
fabLunMapWWN = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunMapWWN.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunMapWWN.setDescription('The WWN associated with the lun')
fabLunLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 80, 3, 3, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unlabelled", 0), ("labelled", 1), ("labelledactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fabLunLabel.setStatus('mandatory')
if mibBuilder.loadTexts: fabLunLabel.setDescription('The label of the lun')
trapFSFull = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 1))
trapFSDegradation = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 2))
trapDiskUpdation = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 3))
trapFCAdptLinkFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 4))
trapFCAdptLinkUp = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 5))
trapFCLossOfLinkFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 6))
trapLunDisappear = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 7))
trapLunSizeChange = MibIdentifier((1, 3, 6, 1, 4, 1, 80, 3, 4, 8))
trapFSFullMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFSFullMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapFSFullMsg.setDescription('Name of the file system which got full and for which fileSystemFull trap has to be sent.')
trapFSFullTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFSFullTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapFSFullTimeStamp.setDescription('Time at which file system identified by trapFSFullMsg got full.')
trapFSDegradationMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFSDegradationMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapFSDegradationMsg.setDescription('Name of the file system which got degraded and for which fileSystemDegradation trap has to be sent.')
trapFSDegradationTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFSDegradationTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapFSDegradationTimeStamp.setDescription('Time at which file system identified by trapFSDegradationMsg got degraded.')
trapDiskMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDiskMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapDiskMsg.setDescription('Name of the disk which got removed from the system and for which diskStackUpdation trap has to be sent.')
trapDiskTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 3, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDiskTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapDiskTimeStamp.setDescription('Time at which disk identified by trapDiskIndex was added/removed.')
trapFCAdptLinkFailureMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 4, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCAdptLinkFailureMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCAdptLinkFailureMsg.setDescription('Name of the fibre channel adapter on which link failure occured.')
trapFCAdptLinkFailureTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 4, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCAdptLinkFailureTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCAdptLinkFailureTimeStamp.setDescription('Time at which the fibre channel adapter link failure occured.')
trapFCAdptLinkUpMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 5, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCAdptLinkUpMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCAdptLinkUpMsg.setDescription('Name of the fibre channel adapter on which link up occured.')
trapFCAdptLinkUpTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 5, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCAdptLinkUpTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCAdptLinkUpTimeStamp.setDescription('Time at which the fibre channel adapter link up occured.')
trapFCLossOfLinkFailureMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 6, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCLossOfLinkFailureMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCLossOfLinkFailureMsg.setDescription('Name of the SD device which had complete loss of link.')
trapFCLossOfLinkFailureTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 6, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapFCLossOfLinkFailureTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapFCLossOfLinkFailureTimeStamp.setDescription('Time at which complete loss of link occured.')
trapLunDisappearMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 7, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLunDisappearMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapLunDisappearMsg.setDescription('Mapped lun which disappeared')
trapLunDisappearTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 7, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLunDisappearTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapLunDisappearTimeStamp.setDescription('Time at which mapped lun disappeared')
trapLunSizeChangeMsg = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 8, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLunSizeChangeMsg.setStatus('mandatory')
if mibBuilder.loadTexts: trapLunSizeChangeMsg.setDescription('Mapped lun whose lun size changed')
trapLunSizeChangeTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 80, 3, 4, 8, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLunSizeChangeTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapLunSizeChangeTimeStamp.setDescription('Time at which mapped lun size changed')
fileSystemFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,1)).setObjects(("NETSERVER-MIB", "trapFSFullMsg"), ("NETSERVER-MIB", "trapFSFullTimeStamp"))
if mibBuilder.loadTexts: fileSystemFullTrap.setDescription('Trap indicating that a file system got full.')
if mibBuilder.loadTexts: fileSystemFullTrap.setReference('None')
fileSystemDegradationTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,2)).setObjects(("NETSERVER-MIB", "trapFSDegradationMsg"), ("NETSERVER-MIB", "trapFSDegradationTimeStamp"))
if mibBuilder.loadTexts: fileSystemDegradationTrap.setDescription('Trap indicating that a file system got degradated.')
if mibBuilder.loadTexts: fileSystemDegradationTrap.setReference('None')
diskStackUpdationTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,3)).setObjects(("NETSERVER-MIB", "trapDiskMsg"), ("NETSERVER-MIB", "trapDiskTimeStamp"))
if mibBuilder.loadTexts: diskStackUpdationTrap.setDescription('Trap indicating that a disk was removed.')
if mibBuilder.loadTexts: diskStackUpdationTrap.setReference('None')
fcLinkFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,4)).setObjects(("NETSERVER-MIB", "trapFCAdptLinkFailureMsg"), ("NETSERVER-MIB", "trapFCAdptLinkFailureTimeStamp"))
if mibBuilder.loadTexts: fcLinkFailureTrap.setDescription('Trap indicating that a adapter link failure occured.')
if mibBuilder.loadTexts: fcLinkFailureTrap.setReference('None')
fcLinkUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,5)).setObjects(("NETSERVER-MIB", "trapFCAdptLinkUpMsg"), ("NETSERVER-MIB", "trapFCAdptLinkUpTimeStamp"))
if mibBuilder.loadTexts: fcLinkUpTrap.setDescription('Trap indicating that a adapter link up occured.')
if mibBuilder.loadTexts: fcLinkUpTrap.setReference('None')
fcCompleteLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,6)).setObjects(("NETSERVER-MIB", "trapFCLossOfLinkFailureMsg"), ("NETSERVER-MIB", "trapFCLossOfLinkFailureTimeStamp"))
if mibBuilder.loadTexts: fcCompleteLossTrap.setDescription('Trap indicating that complete loss of link occured.')
if mibBuilder.loadTexts: fcCompleteLossTrap.setReference('None')
lunDisappearTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,7)).setObjects(("NETSERVER-MIB", "trapLunDisappearMsg"), ("NETSERVER-MIB", "trapLunDisappearTimeStamp"))
if mibBuilder.loadTexts: lunDisappearTrap.setDescription('Trap indicating that a mapped lun disappeared.')
if mibBuilder.loadTexts: lunDisappearTrap.setReference('None')
lunSizeChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 80) + (0,8)).setObjects(("NETSERVER-MIB", "trapLunSizeChangeMsg"), ("NETSERVER-MIB", "trapLunSizeChangeTimeStamp"))
if mibBuilder.loadTexts: lunSizeChangeTrap.setDescription('Trap indicating that lun size change occured on a mapped lun.')
if mibBuilder.loadTexts: lunSizeChangeTrap.setReference('None')
host = MibIdentifier((1, 3, 6, 1, 2, 1, 25))
hrSystem = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 1))
hrStorage = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2))
hrDevice = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3))
class Boolean(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class KBytes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class ProductID(ObjectIdentifier):
    pass

class DateAndTime(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(11, 11), )
class InternationalDisplayString(OctetString):
    pass

hrSystemUptime = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrSystemUptime.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemUptime.setDescription('The amount of time since this host was last initialized. Note that this is different from sysUpTime in MIB-II [3] because sysUpTime is the uptime of the network management portion of the system.')
hrSystemDate = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrSystemDate.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemDate.setDescription("The host's notion of the local date and time of day.")
hrSystemInitialLoadDevice = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrSystemInitialLoadDevice.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemInitialLoadDevice.setDescription('The index of the hrDeviceEntry for the device from which this host is configured to load its initial operating system configuration.')
hrSystemInitialLoadParameters = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 4), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrSystemInitialLoadParameters.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemInitialLoadParameters.setDescription('This object contains the parameters (e.g. a pathname and parameter) supplied to the load device when requesting the initial operating system configuration from that device.')
hrSystemNumUsers = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrSystemNumUsers.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemNumUsers.setDescription('The number of user sessions for which this host is storing state information. A session is a collection of processes requiring a single act of user authentication and possibly subject to collective job control.')
hrSystemProcesses = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrSystemProcesses.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemProcesses.setDescription('The number of process contexts currently loaded or running on this system.')
hrSystemMaxProcesses = MibScalar((1, 3, 6, 1, 2, 1, 25, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrSystemMaxProcesses.setStatus('mandatory')
if mibBuilder.loadTexts: hrSystemMaxProcesses.setDescription('The maximum number of process contexts this system can support. If there is no fixed maximum, the value should be zero. On systems that have a fixed maximum, this object can help diagnose failures that occur when this maximum is reached.')
hrStorageTypes = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1))
hrStorageOther = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 1))
hrStorageRam = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 2))
hrStorageVirtualMemory = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 3))
hrStorageFixedDisk = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 4))
hrStorageRemovableDisk = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 5))
hrStorageFloppyDisk = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 6))
hrStorageCompactDisc = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 7))
hrStorageRamDisk = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 2, 1, 8))
hrMemorySize = MibScalar((1, 3, 6, 1, 2, 1, 25, 2, 2), KBytes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: hrMemorySize.setDescription('The amount of physical main memory contained by the host.')
hrStorageTable = MibTable((1, 3, 6, 1, 2, 1, 25, 2, 3), )
if mibBuilder.loadTexts: hrStorageTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageTable.setDescription("The (conceptual) table of logical storage areas on the host. An entry shall be placed in the storage table for each logical area of storage that is allocated and has fixed resource limits. The amount of storage represented in an entity is the amount actually usable by the requesting entity, and excludes loss due to formatting or file system reference information. These entries are associated with logical storage areas, as might be seen by an application, rather than physical storage entities which are typically seen by an operating system. Storage such as tapes and floppies without file systems on them are typically not allocated in chunks by the operating system to requesting applications, and therefore shouldn't appear in this table. Examples of valid storage for this table include disk partitions, file systems, ram (for some architectures this is further segmented into regular memory, extended memory, and so on), backing store for virtual memory (`swap space'). This table is intended to be a useful diagnostic for `out of memory' and `out of buffers' types of failures. In addition, it can be a useful performance monitoring tool for tracking memory, disk, or buffer usage.")
hrStorageEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 2, 3, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrStorageIndex"))
if mibBuilder.loadTexts: hrStorageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageEntry.setDescription('A (conceptual) entry for one logical storage area on the host. As an example, an instance of the hrStorageType object might be named hrStorageType.3')
hrStorageIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageIndex.setDescription('A unique value for each logical storage area contained by the host.')
hrStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageType.setDescription('The type of storage represented by this entry.')
hrStorageDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageDescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageDescr.setDescription('A description of the type and instance of the storage described by this entry.')
hrStorageAllocationUnits = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageAllocationUnits.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageAllocationUnits.setDescription('The size, in bytes, of the data objects allocated from this pool. If this entry is monitoring sectors, blocks, buffers, or packets, for example, this number will commonly be greater than one. Otherwise this number will typically be one.')
hrStorageSize = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrStorageSize.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageSize.setDescription('The size of the storage represented by this entry, in units of hrStorageAllocationUnits.')
hrStorageUsed = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageUsed.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageUsed.setDescription('The amount of the storage represented by this entry that is allocated, in units of hrStorageAllocationUnits.')
hrStorageAllocationFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrStorageAllocationFailures.setStatus('mandatory')
if mibBuilder.loadTexts: hrStorageAllocationFailures.setDescription('The number of requests for storage represented by this entry that could not be honored due to not enough storage. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero.')
hrDeviceTypes = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1))
hrDeviceOther = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 1))
hrDeviceUnknown = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 2))
hrDeviceProcessor = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 3))
hrDeviceNetwork = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 4))
hrDevicePrinter = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 5))
hrDeviceDiskStorage = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 6))
hrDeviceVideo = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 10))
hrDeviceAudio = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 11))
hrDeviceCoprocessor = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 12))
hrDeviceKeyboard = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 13))
hrDeviceModem = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 14))
hrDeviceParallelPort = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 15))
hrDevicePointing = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 16))
hrDeviceSerialPort = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 17))
hrDeviceTape = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 18))
hrDeviceClock = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 19))
hrDeviceVolatileMemory = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 20))
hrDeviceNonVolatileMemory = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 1, 21))
hrDeviceTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 2), )
if mibBuilder.loadTexts: hrDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceTable.setDescription('The (conceptual) table of devices contained by the host.')
hrDeviceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 2, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: hrDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceEntry.setDescription('A (conceptual) entry for one device contained by the host. As an example, an instance of the hrDeviceType object might be named hrDeviceType.3')
hrDeviceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceIndex.setDescription('A unique value for each device contained by the host. The value for each device must remain constant at least from one re-initialization of the agent to the next re-initialization.')
hrDeviceType = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceType.setDescription("An indication of the type of device. If this value is `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry exists in the hrProcessorTable which corresponds to this device. If this value is `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry exists in the hrNetworkTable which corresponds to this device. If this value is `hrDevicePrinter { hrDeviceTypes 5 }', then an entry exists in the hrPrinterTable which corresponds to this device. If this value is `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an entry exists in the hrDiskStorageTable which corresponds to this device.")
hrDeviceDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceDescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceDescr.setDescription("A textual description of this device, including the device's manufacturer and revision, and optionally, its serial number.")
hrDeviceID = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 4), ProductID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceID.setDescription('The product ID for this device.')
hrDeviceStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("running", 2), ("warning", 3), ("testing", 4), ("down", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceStatus.setDescription("The current operational state of the device described by this row of the table. A value unknown(1) indicates that the current state of the device is unknown. running(2) indicates that the device is up and running and that no unusual error conditions are known. The warning(3) state indicates that agent has been informed of an unusual error condition by the operational software (e.g., a disk device driver) but that the device is still 'operational'. An example would be high number of soft errors on a disk. A value of testing(4), indicates that the device is not available for use because it is in the testing state. The state of down(5) is used only when the agent has been informed that the device is not available for any use.")
hrDeviceErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDeviceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hrDeviceErrors.setDescription('The number of errors detected on this device. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero.')
hrProcessorTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 3), )
if mibBuilder.loadTexts: hrProcessorTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrProcessorTable.setDescription("The (conceptual) table of processors contained by the host. Note that this table is potentially sparse: a (conceptual) entry exists only if the correspondent value of the hrDeviceType object is `hrDeviceProcessor'.")
hrProcessorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 3, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: hrProcessorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrProcessorEntry.setDescription('A (conceptual) entry for one processor contained by the host. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the hrProcessorEntry. As an example of how objects in this table are named, an instance of the hrProcessorFrwID object might be named hrProcessorFrwID.3')
hrProcessorFrwID = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 3, 1, 1), ProductID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrProcessorFrwID.setStatus('mandatory')
if mibBuilder.loadTexts: hrProcessorFrwID.setDescription('The product ID of the firmware associated with the processor.')
hrProcessorLoad = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrProcessorLoad.setStatus('mandatory')
if mibBuilder.loadTexts: hrProcessorLoad.setDescription('The average, over the last minute, of the percentage of time that this processor was not idle.')
hrNetworkTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 4), )
if mibBuilder.loadTexts: hrNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrNetworkTable.setDescription("The (conceptual) table of network devices contained by the host. Note that this table is potentially sparse: a (conceptual) entry exists only if the correspondent value of the hrDeviceType object is `hrDeviceNetwork'.")
hrNetworkEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 4, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: hrNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrNetworkEntry.setDescription('A (conceptual) entry for one network device contained by the host. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the hrNetworkEntry. As an example of how objects in this table are named, an instance of the hrNetworkIfIndex object might be named hrNetworkIfIndex.3')
hrNetworkIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrNetworkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrNetworkIfIndex.setDescription('The value of ifIndex which corresponds to this network device.')
hrPrinterTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 5), )
if mibBuilder.loadTexts: hrPrinterTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrPrinterTable.setDescription("The (conceptual) table of printers local to the host. Note that this table is potentially sparse: a (conceptual) entry exists only if the correspondent value of the hrDeviceType object is `hrDevicePrinter'.")
hrPrinterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 5, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: hrPrinterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrPrinterEntry.setDescription('A (conceptual) entry for one printer local to the host. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the hrPrinterEntry. As an example of how objects in this table are named, an instance of the hrPrinterStatus object might be named hrPrinterStatus.3')
hrPrinterStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("idle", 3), ("printing", 4), ("warmup", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPrinterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrPrinterStatus.setDescription('The current status of this printer device. When in the idle(1), printing(2), or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or warning(3). When in the unknown state, the corresponding hrDeviceStatus should be unknown(1).')
hrPrinterDetectedErrorState = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPrinterDetectedErrorState.setStatus('mandatory')
if mibBuilder.loadTexts: hrPrinterDetectedErrorState.setDescription('This object represents any error conditions detected by the printer. The error conditions are encoded as bits in an octet string, with the following definitions: Condition Bit # hrDeviceStatus lowPaper 0 warning(3) noPaper 1 down(5) lowToner 2 warning(3) noToner 3 down(5) doorOpen 4 down(5) jammed 5 down(5) offline 6 down(5) serviceRequested 7 warning(3) If multiple conditions are currently detected and the hrDeviceStatus would not otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to the worst state of those indicated, where down(5) is worse than warning(3) which is worse than running(2). Bits are numbered starting with the most significant bit of the first byte being bit 0, the least significant bit of the first byte being bit 7, the most significant bit of the second byte being bit 8, and so on. A one bit encodes that the condition was detected, while a zero bit encodes that the condition was not detected. This object is useful for alerting an operator to specific warning or error conditions that may occur, especially those requiring human intervention.')
hrDiskStorageTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 6), )
if mibBuilder.loadTexts: hrDiskStorageTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageTable.setDescription("The (conceptual) table of long-term storage devices contained by the host. In particular, disk devices accessed remotely over a network are not included here. Note that this table is potentially sparse: a (conceptual) entry exists only if the correspondent value of the hrDeviceType object is `hrDeviceDiskStorage'.")
hrDiskStorageEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 6, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: hrDiskStorageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageEntry.setDescription('A (conceptual) entry for one long-term storage device contained by the host. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the hrDiskStorageEntry. As an example, an instance of the hrDiskStorageCapacity object might be named hrDiskStorageCapacity.3')
hrDiskStorageAccess = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readWrite", 1), ("readOnly", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDiskStorageAccess.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageAccess.setDescription('An indication if this long-term storage device is readable and writable or only readable. This should reflect the media type, any write-protect mechanism, and any device configuration that affects the entire device.')
hrDiskStorageMedia = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("hardDisk", 3), ("floppyDisk", 4), ("opticalDiskROM", 5), ("opticalDiskWORM", 6), ("opticalDiskRW", 7), ("ramDisk", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDiskStorageMedia.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageMedia.setDescription('An indication of the type of media used in this long-term storage device.')
hrDiskStorageRemoveble = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 3), Boolean()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDiskStorageRemoveble.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageRemoveble.setDescription('Denotes whether or not the disk media may be removed from the drive.')
hrDiskStorageCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 4), KBytes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrDiskStorageCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: hrDiskStorageCapacity.setDescription('The total size for this long-term storage device.')
hrPartitionTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 7), )
if mibBuilder.loadTexts: hrPartitionTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionTable.setDescription('The (conceptual) table of partitions for long-term storage devices contained by the host. In particular, partitions accessed remotely over a network are not included here.')
hrPartitionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 7, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrDeviceIndex"), (0, "NETSERVER-MIB", "hrPartitionIndex"))
if mibBuilder.loadTexts: hrPartitionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionEntry.setDescription('A (conceptual) entry for one partition. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the hrPartitionEntry. As an example of how objects in this table are named, an instance of the hrPartitionSize object might be named hrPartitionSize.3.1')
hrPartitionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPartitionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionIndex.setDescription('A unique value for each partition on this long- term storage device. The value for each long-term storage device must remain constant at least from one re-initialization of the agent to the next re- initialization.')
hrPartitionLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 2), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPartitionLabel.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionLabel.setDescription('A textual description of this partition.')
hrPartitionID = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPartitionID.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionID.setDescription('A descriptor which uniquely represents this partition to the responsible operating system. On some systems, this might take on a binary representation.')
hrPartitionSize = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 4), KBytes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPartitionSize.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionSize.setDescription('The size of this partition.')
hrPartitionFSIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrPartitionFSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrPartitionFSIndex.setDescription('The index of the file system mounted on this partition. If no file system is mounted on this partition, then this value shall be zero. Note that multiple partitions may point to one file system, denoting that that file system resides on those partitions. Multiple file systems may not reside on one partition.')
hrFSTable = MibTable((1, 3, 6, 1, 2, 1, 25, 3, 8), )
if mibBuilder.loadTexts: hrFSTable.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSTable.setDescription("The (conceptual) table of file systems local to this host or remotely mounted from a file server. File systems that are in only one user's environment on a multi-user system will not be included in this table.")
hrFSEntry = MibTableRow((1, 3, 6, 1, 2, 1, 25, 3, 8, 1), ).setIndexNames((0, "NETSERVER-MIB", "hrFSIndex"))
if mibBuilder.loadTexts: hrFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSEntry.setDescription("A (conceptual) entry for one file system local to this host or remotely mounted from a file server. File systems that are in only one user's environment on a multi-user system will not be included in this table. As an example of how objects in this table are named, an instance of the hrFSMountPoint object might be named hrFSMountPoint.3")
hrFSTypes = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9))
hrFSOther = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 1))
hrFSUnknown = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 2))
hrFSBerkeleyFFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 3))
hrFSSys5FS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 4))
hrFSFat = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 5))
hrFSHPFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 6))
hrFSHFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 7))
hrFSMFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 8))
hrFSNTFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 9))
hrFSVNode = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 10))
hrFSJournaled = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 11))
hrFSiso9660 = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 12))
hrFSRockRidge = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 13))
hrFSNFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 14))
hrFSNetware = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 15))
hrFSAFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 16))
hrFSDFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 17))
hrFSAppleshare = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 18))
hrFSRFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 19))
hrFSDGCFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 20))
hrFSBFS = MibIdentifier((1, 3, 6, 1, 2, 1, 25, 3, 9, 21))
hrFSIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSIndex.setDescription('A unique value for each file system local to this host. The value for each file system must remain constant at least from one re-initialization of the agent to the next re-initialization.')
hrFSMountPoint = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 2), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSMountPoint.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSMountPoint.setDescription('The path name of the root of this file system.')
hrFSRemoteMountPoint = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 3), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSRemoteMountPoint.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSRemoteMountPoint.setDescription('A description of the name and/or address of the server that this file system is mounted from. This may also include parameters such as the mount point on the remote file system. If this is not a remote file system, this string should have a length of zero.')
hrFSType = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSType.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSType.setDescription('The value of this object identifies the type of this file system.')
hrFSAccess = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readWrite", 1), ("readOnly", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSAccess.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSAccess.setDescription('An indication if this file system is logically configured by the operating system to be readable and writable or only readable. This does not represent any local access-control policy, except one that is applied to the file system as a whole.')
hrFSBootable = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 6), Boolean()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSBootable.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSBootable.setDescription('A flag indicating whether this file system is bootable.')
hrFSStorageIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrFSStorageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSStorageIndex.setDescription('The index of the hrStorageEntry that represents information about this file system. If there is no such information available, then this value shall be zero. The relevant storage entry will be useful in tracking the percent usage of this file system and diagnosing errors that may occur when it runs out of space.')
hrFSLastFullBackupDate = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 8), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrFSLastFullBackupDate.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSLastFullBackupDate.setDescription("The last date at which this complete file system was copied to another storage device for backup. This information is useful for ensuring that backups are being performed regularly. If this information is not known, then this variable shall have the value corresponding to January 1, year 0000, 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'.")
hrFSLastPartialBackupDate = MibTableColumn((1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 9), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrFSLastPartialBackupDate.setStatus('mandatory')
if mibBuilder.loadTexts: hrFSLastPartialBackupDate.setDescription("The last date at which a portion of this file system was copied to another storage device for backup. This information is useful for ensuring that backups are being performed regularly. If this information is not known, then this variable shall have the value corresponding to January 1, year 0000, 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'.")
mibBuilder.exportSymbols("NETSERVER-MIB", fabAdptEntry=fabAdptEntry, diskStackUpdationTrap=diskStackUpdationTrap, trapLunDisappear=trapLunDisappear, npIndex=npIndex, npIfEntry=npIfEntry, BusType=BusType, trapFCAdptLinkUpMsg=trapFCAdptLinkUpMsg, fpDNLCHit=fpDNLCHit, fabLunMapEntry=fabLunMapEntry, hrFSTypes=hrFSTypes, npICMPOutMsgs=npICMPOutMsgs, ldDriveErrors=ldDriveErrors, fpDNLCConflict=fpDNLCConflict, npSMBRcvd=npSMBRcvd, hrDeviceNonVolatileMemory=hrDeviceNonVolatileMemory, fpLFSPurges=fpLFSPurges, npICMPInTimestampReps=npICMPInTimestampReps, hrStorageTable=hrStorageTable, hrFSIndex=hrFSIndex, fpPAGECachelistcnt=fpPAGECachelistcnt, npUDPEntry=npUDPEntry, netServer=netServer, hrPrinterEntry=hrPrinterEntry, fabAdptTable=fabAdptTable, RebuildFlag=RebuildFlag, ldMediaErrors=ldMediaErrors, fpHTFS=fpHTFS, fpLFSReaddirPluses=fpLFSReaddirPluses, npTCPActiveOpens=npTCPActiveOpens, fileSystemDegradationTrap=fileSystemDegradationTrap, fspBusyCount=fspBusyCount, npIPOutNoRoutes=npIPOutNoRoutes, hrFSDFS=hrFSDFS, fspTable=fspTable, npSMBCloses=npSMBCloses, fpLFSLinks=fpLFSLinks, hrFSVNode=hrFSVNode, fabIntLine=fabIntLine, npICMPOutTimestampReps=npICMPOutTimestampReps, npIfOutUcastPkts=npIfOutUcastPkts, fpPAGEDirtydlistcnt=fpPAGEDirtydlistcnt, fpPAGEWritehit=fpPAGEWritehit, trapFCAdptLinkUp=trapFCAdptLinkUp, npIPRoutingDiscards=npIPRoutingDiscards, fabTargetTable=fabTargetTable, fabLunMapIndex=fabLunMapIndex, npEntry=npEntry, fabTargetEntry=fabTargetEntry, hrPartitionTable=hrPartitionTable, npIfInErrors=npIfInErrors, npUDPNoPorts=npUDPNoPorts, fabLunNumber=fabLunNumber, axSP=axSP, ldWriteIO=ldWriteIO, fpLFSEntry=fpLFSEntry, fpPAGEZcbreak=fpPAGEZcbreak, npSMBWrites=npSMBWrites, npTCPRetransSegs=npTCPRetransSegs, npTable=npTable, axProductInfo=axProductInfo, npIPInDiscards=npIPInDiscards, axFP=axFP, trapFSDegradation=trapFSDegradation, hrStorageVirtualMemory=hrStorageVirtualMemory, hrFSAFS=hrFSAFS, fpInodeTable=fpInodeTable, fabLunMap=fabLunMap, fpLFSGetattrs=fpLFSGetattrs, fabRaid=fabRaid, fpDNLCHashsz=fpDNLCHashsz, npIfInDiscards=npIfInDiscards, npTCPCurrEstab=npTCPCurrEstab, fpLFSClears=fpLFSClears, fpBUFBufsize=fpBUFBufsize, hrStorageIndex=hrStorageIndex, hrFSUnknown=hrFSUnknown, fabTargetIndex=fabTargetIndex, npIPInUnknownProtos=npIPInUnknownProtos, KBytes=KBytes, fcLinkUpTrap=fcLinkUpTrap, fpLFSCreates=fpLFSCreates, hrStorageRam=hrStorageRam, fabSlotNum=fabSlotNum, npIPReasmReqds=npIPReasmReqds, npICMPOutEchos=npICMPOutEchos, ldSectorWrites=ldSectorWrites, hrDiskStorageRemoveble=hrDiskStorageRemoveble, DateAndTime=DateAndTime, Boolean=Boolean, fpFSEntry=fpFSEntry, npIdleCount=npIdleCount, hrPartitionLabel=hrPartitionLabel, npSMBTable=npSMBTable, hrSystem=hrSystem, hrDeviceProcessor=hrDeviceProcessor, fabLunType=fabLunType, hrNetworkIfIndex=hrNetworkIfIndex, fspEntry=fspEntry, hrPartitionIndex=hrPartitionIndex, ProductID=ProductID, trapFCLossOfLinkFailure=trapFCLossOfLinkFailure, npICMPTable=npICMPTable, hrFSBFS=hrFSBFS, fabLunEntry=fabLunEntry, npICMPOutAddrMasks=npICMPOutAddrMasks, trapDiskMsg=trapDiskMsg, hrMemorySize=hrMemorySize, hrFSAppleshare=hrFSAppleshare, hrPartitionID=hrPartitionID, axFSP=axFSP, hrFSNetware=hrFSNetware, fpGoneinodes=fpGoneinodes, fcCompleteLossTrap=fcCompleteLossTrap, hrFSMountPoint=hrFSMountPoint, fpHrFSIndex=fpHrFSIndex, hrStorageTypes=hrStorageTypes, hrStorageSize=hrStorageSize, npICMPOutAddrMaskReps=npICMPOutAddrMaskReps, fpLFSMkdirs=fpLFSMkdirs, npIPEntry=npIPEntry, InternationalDisplayString=InternationalDisplayString, hrDeviceVideo=hrDeviceVideo, npIPInReceives=npIPInReceives, fpPAGECachemiss=fpPAGECachemiss, fabDeviceId=fabDeviceId, fpDNLCSEntry=fpDNLCSEntry, npIfSpeed=npIfSpeed, npIPDefaultTTL=npIPDefaultTTL, npSMBBytesRcvd=npSMBBytesRcvd, fabTargetNumOfLuns=fabTargetNumOfLuns, hrSystemUptime=hrSystemUptime, U08Bits=U08Bits, npNFSDCounts=npNFSDCounts, auspex=auspex, fpLFSMounts=fpLFSMounts, hrFSiso9660=hrFSiso9660, fpPAGEOutscan=fpPAGEOutscan, npTCPRtoAlgorithm=npTCPRtoAlgorithm, npIfInUnknownProto=npIfInUnknownProto, npTCPTable=npTCPTable, fpPAGEFsflushscan=fpPAGEFsflushscan, fabTargetPortWWN=fabTargetPortWWN, fabAdptNumber=fabAdptNumber, fabLunMapWWN=fabLunMapWWN, hrFSDGCFS=hrFSDGCFS, trapFSFull=trapFSFull, hrDeviceOther=hrDeviceOther, hrDiskStorageTable=hrDiskStorageTable, hrDeviceTable=hrDeviceTable, fabTargetNumber=fabTargetNumber, fpLFSRenames=fpLFSRenames, fpINODEIgetcalls=fpINODEIgetcalls, npTCPRtoMin=npTCPRtoMin, ldReadIO=ldReadIO, fpBUFLwrites=fpBUFLwrites, fpLFSNull=fpLFSNull, fpTotalinodes=fpTotalinodes, hrProcessorLoad=hrProcessorLoad, npSMBErrors=npSMBErrors, fpPageStatTable=fpPageStatTable, npIfOutDiscards=npIfOutDiscards, fpBufferStatTable=fpBufferStatTable, hrProcessorEntry=hrProcessorEntry, npTCPMaxConn=npTCPMaxConn, hrStorageAllocationUnits=hrStorageAllocationUnits, npIfOutErrors=npIfOutErrors, hrStorageFixedDisk=hrStorageFixedDisk, hrFSTable=hrFSTable, npTCPOutRsts=npTCPOutRsts, hrStorageType=hrStorageType, trapFCAdptLinkFailure=trapFCAdptLinkFailure, npICMPOutSrcQuenchs=npICMPOutSrcQuenchs, fpPAGETotalmem=fpPAGETotalmem, trapFSFullMsg=trapFSFullMsg, hrDeviceType=hrDeviceType, trapLunSizeChangeMsg=trapLunSizeChangeMsg, hrPrinterTable=hrPrinterTable, hrDeviceParallelPort=hrDeviceParallelPort, hrStorageUsed=hrStorageUsed, axNP=axNP, lunDisappearTrap=lunDisappearTrap, spRaid=spRaid, hrSystemInitialLoadDevice=hrSystemInitialLoadDevice, npICMPInTimeExcds=npICMPInTimeExcds, fpSyncinodes=fpSyncinodes, fpPageEntry=fpPageEntry, npICMPInErrors=npICMPInErrors, fabWWN=fabWWN, hrPartitionFSIndex=hrPartitionFSIndex, fpPAGEFsflushputpage=fpPAGEFsflushputpage, hrProcessorFrwID=hrProcessorFrwID, ldTotalTime=ldTotalTime, npIfOutOctets=npIfOutOctets, fpLFSCkpntoffs=fpLFSCkpntoffs, fpPAGEOutcnt=fpPAGEOutcnt, fpPAGECachehit=fpPAGECachehit, npIfInOctets=npIfInOctets, fabLogDevTable=fabLogDevTable, hrDiskStorageCapacity=hrDiskStorageCapacity, fpLFSFsstats=fpLFSFsstats, fabLunAlias=fabLunAlias, trapFCAdptLinkUpTimeStamp=trapFCAdptLinkUpTimeStamp, npIfOperStatus=npIfOperStatus, fabNumOfTargets=fabNumOfTargets, fpLFSCkpntons=fpLFSCkpntons, fpFSIndex=fpFSIndex, fpLFSUMounts=fpLFSUMounts, fpLFSRemoves=fpLFSRemoves, RaidLevel=RaidLevel, VendorName=VendorName, hrFSOther=hrFSOther, fileSystemFullTrap=fileSystemFullTrap, npICMPOutParmProbs=npICMPOutParmProbs, hrFSRemoteMountPoint=hrFSRemoteMountPoint, hrDeviceClock=hrDeviceClock, hrFSEntry=hrFSEntry, npIPTable=npIPTable, trapLunDisappearTimeStamp=trapLunDisappearTimeStamp, hrFSAccess=hrFSAccess, npIfInUcastPkts=npIfInUcastPkts, fpLFSSymlinks=fpLFSSymlinks, hrFSNTFS=hrFSNTFS, hrFSType=hrFSType, fabType=fabType, ldIndex=ldIndex, npTCPInSegs=npTCPInSegs, npICMPInAddrMaskReps=npICMPInAddrMaskReps, fpPAGEOutputpage=fpPAGEOutputpage, axFab=axFab, npSMBEntry=npSMBEntry, hrFSNFS=hrFSNFS, hrFSHFS=hrFSHFS, hrFSLastFullBackupDate=hrFSLastFullBackupDate, npTCPAttemptFails=npTCPAttemptFails, npSMBBytesSent=npSMBBytesSent, fpBUFBcount=fpBUFBcount, fpLFSSetattrs=fpLFSSetattrs, hrFSMFS=hrFSMFS, npICMPInEchoReps=npICMPInEchoReps, hrStorageDescr=hrStorageDescr, npIPForwarding=npIPForwarding, npICMPInEchos=npICMPInEchos, hrDeviceErrors=hrDeviceErrors, npTCPPassiveOpens=npTCPPassiveOpens, fpFileSystemTable=fpFileSystemTable, hrDeviceDescr=hrDeviceDescr, fpFoundinodes=fpFoundinodes, hrDeviceUnknown=hrDeviceUnknown, hrProcessorTable=hrProcessorTable, npNFSDNJobs=npNFSDNJobs, fabRevisionId=fabRevisionId, hrFSBootable=hrFSBootable, trapFCAdptLinkFailureMsg=trapFCAdptLinkFailureMsg, hrDeviceNetwork=hrDeviceNetwork)
mibBuilder.exportSymbols("NETSERVER-MIB", hrDevicePointing=hrDevicePointing, fpPAGEFreelistcnt=fpPAGEFreelistcnt, axNumNPFSP=axNumNPFSP, npICMPOutTimestamps=npICMPOutTimestamps, npNFSTable=npNFSTable, npNFSDBusyCounts=npNFSDBusyCounts, hrDeviceTape=hrDeviceTape, hrDeviceTypes=hrDeviceTypes, hrDiskStorageEntry=hrDiskStorageEntry, npSMBOpens=npSMBOpens, hrStorageOther=hrStorageOther, hrPrinterDetectedErrorState=hrPrinterDetectedErrorState, fabLunTarNumber=fabLunTarNumber, npUDPOutDatagrams=npUDPOutDatagrams, fpLFSRmdirs=fpLFSRmdirs, fpBUFLreads=fpBUFLreads, fpCacheinodes=fpCacheinodes, fabIndex=fabIndex, npIPFragCreates=npIPFragCreates, fpBUFIOwaits=fpBUFIOwaits, npNFSEntry=npNFSEntry, lunSizeChangeTrap=lunSizeChangeTrap, fpBUFBreads=fpBUFBreads, fabTargetAliasName=fabTargetAliasName, hrPrinterStatus=hrPrinterStatus, hrDeviceVolatileMemory=hrDeviceVolatileMemory, hrFSFat=hrFSFat, fabLunTable=fabLunTable, npICMPInSrcQuenchs=npICMPInSrcQuenchs, npIPFragOKs=npIPFragOKs, fpLFSVersion=fpLFSVersion, trapDiskUpdation=trapDiskUpdation, hrStorageFloppyDisk=hrStorageFloppyDisk, fpLFSReleaseFs=fpLFSReleaseFs, trapFSDegradationTimeStamp=trapFSDegradationTimeStamp, fpLFSReaddirs=fpLFSReaddirs, fpBUFResid=fpBUFResid, fabLunMapTable=fabLunMapTable, hrStorageAllocationFailures=hrStorageAllocationFailures, npICMPOutErrors=npICMPOutErrors, hrFSRockRidge=hrFSRockRidge, fabLunMNumber=fabLunMNumber, fpLFSReads=fpLFSReads, fpLFSFsinfo=fpLFSFsinfo, fabVendorId=fabVendorId, npIfifIndex=npIfifIndex, hrSystemProcesses=hrSystemProcesses, fpLFSMknods=fpLFSMknods, fabTargetWWN=fabTargetWWN, hrDevicePrinter=hrDevicePrinter, hrStorageEntry=hrStorageEntry, npUDPInDatagrams=npUDPInDatagrams, npICMPOutTimeExcds=npICMPOutTimeExcds, ControllerType=ControllerType, npProtocols=npProtocols, U16Bits=U16Bits, hrDeviceEntry=hrDeviceEntry, npUDPInErrors=npUDPInErrors, fpLFSWrites=fpLFSWrites, npICMPOutEchoReps=npICMPOutEchoReps, fabLunIndex=fabLunIndex, fspIndex=fspIndex, npIfIndex=npIfIndex, trapFCAdptLinkFailureTimeStamp=trapFCAdptLinkFailureTimeStamp, npIfTable=npIfTable, npTCPEstabResets=npTCPEstabResets, npIPReasmTimeout=npIPReasmTimeout, hrSystemNumUsers=hrSystemNumUsers, hrSystemMaxProcesses=hrSystemMaxProcesses, trapFCLossOfLinkFailureMsg=trapFCLossOfLinkFailureMsg, hrFSStorageIndex=hrFSStorageIndex, hrDiskStorageAccess=hrDiskStorageAccess, hrDeviceStatus=hrDeviceStatus, hrDiskStorageMedia=hrDiskStorageMedia, fpLFSLookups=fpLFSLookups, hrPartitionEntry=hrPartitionEntry, hrFSLastPartialBackupDate=hrFSLastPartialBackupDate, fpBufferEntry=fpBufferEntry, axTrapData=axTrapData, npICMPOutRedirects=npICMPOutRedirects, hrFSSys5FS=hrFSSys5FS, hrDeviceDiskStorage=hrDeviceDiskStorage, hrSystemDate=hrSystemDate, hrStorage=hrStorage, npUDPTable=npUDPTable, npICMPInMsgs=npICMPInMsgs, ldWBufReads=ldWBufReads, trapFCLossOfLinkFailureTimeStamp=trapFCLossOfLinkFailureTimeStamp, trapLunDisappearMsg=trapLunDisappearMsg, npIfType=npIfType, trapDiskTimeStamp=trapDiskTimeStamp, fpLFSIsolationStates=fpLFSIsolationStates, fabTargetAdapterNum=fabTargetAdapterNum, fabLunWWN=fabLunWWN, fpDNLCMiss=fpDNLCMiss, fspIdleCount=fspIdleCount, npICMPInAddrMasks=npICMPInAddrMasks, hrDeviceModem=hrDeviceModem, fpDNLCPurgevp=fpDNLCPurgevp, fpBUFBwrites=fpBUFBwrites, hrFSJournaled=hrFSJournaled, hrStorageCompactDisc=hrStorageCompactDisc, fpLFSDiagnostics=fpLFSDiagnostics, npICMPEntry=npICMPEntry, trapFSFullTimeStamp=trapFSFullTimeStamp, hrSystemInitialLoadParameters=hrSystemInitialLoadParameters, hrDevice=hrDevice, hrDeviceSerialPort=hrDeviceSerialPort, npICMPInParmProbs=npICMPInParmProbs, hrFSBerkeleyFFS=hrFSBerkeleyFFS, trapLunSizeChange=trapLunSizeChange, npIPReasmFails=npIPReasmFails, fabLunSize=fabLunSize, host=host, fpDNLCTStatTable=fpDNLCTStatTable, fpPAGEDirtyflistcnt=fpPAGEDirtyflistcnt, npIPReasmOKs=npIPReasmOKs, npICMPInRedirects=npICMPInRedirects, fpFreeinodes=fpFreeinodes, fpDNLCPurgevfsp=fpDNLCPurgevfsp, fabLunLabel=fabLunLabel, hrDeviceID=hrDeviceID, hrDeviceIndex=hrDeviceIndex, npTCPRtoMax=npTCPRtoMax, hrPartitionSize=hrPartitionSize, npIPInHdrErrors=npIPInHdrErrors, npICMPInTimestamps=npICMPInTimestamps, fabIntPin=fabIntPin, npTCPInErrs=npTCPInErrs, hrFSHPFS=hrFSHPFS, fpLFSIsolateFs=fpLFSIsolateFs, fpDNLCEnter=fpDNLCEnter, npTCPOutSegs=npTCPOutSegs, fabTargetType=fabTargetType, fpPAGEZcref=fpPAGEZcref, hrFSRFS=hrFSRFS, fpPAGEWritemiss=fpPAGEWritemiss, npIPOutRequests=npIPOutRequests, npIfAdminStatus=npIfAdminStatus, fpLFSTable=fpLFSTable, ldSectorReads=ldSectorReads, hrStorageRamDisk=hrStorageRamDisk, npIfOutQLen=npIfOutQLen, hrStorageRemovableDisk=hrStorageRemovableDisk, fpInodeEntry=fpInodeEntry, axProductName=axProductName, fcLinkFailureTrap=fcLinkFailureTrap, fabPCIBusNum=fabPCIBusNum, npSMBLocksHeld=npSMBLocksHeld, trapLunSizeChangeTimeStamp=trapLunSizeChangeTimeStamp, npIPInAddrErrors=npIPInAddrErrors, hrNetworkTable=hrNetworkTable, npIPOutDiscards=npIPOutDiscards, hrDeviceAudio=hrDeviceAudio, npSMBReads=npSMBReads, axSWVersion=axSWVersion, fabLunAdptNumber=fabLunAdptNumber, trapFSDegradationMsg=trapFSDegradationMsg, npIPFragFails=npIPFragFails, fabLogDevEntry=fabLogDevEntry, npIfOutNUcastPkts=npIfOutNUcastPkts, npIfInNUcastPkts=npIfInNUcastPkts, hrNetworkEntry=hrNetworkEntry, hrDeviceCoprocessor=hrDeviceCoprocessor, fpLFSReadlinks=fpLFSReadlinks, npIfOutCollisions=npIfOutCollisions, npIPForwDatagrams=npIPForwDatagrams, npICMPInDestUnreachs=npICMPInDestUnreachs, hrDeviceKeyboard=hrDeviceKeyboard, npBusyCount=npBusyCount, npIPInDelivers=npIPInDelivers, npICMPOutDestUnreachs=npICMPOutDestUnreachs, npTCPEntry=npTCPEntry)

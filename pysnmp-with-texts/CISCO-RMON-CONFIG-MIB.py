#
# PySNMP MIB module CISCO-RMON-CONFIG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-RMON-CONFIG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:10:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
Dscp, = mibBuilder.importSymbols("CISCO-QOS-PIB-MIB", "Dscp")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
portCopyEntry, = mibBuilder.importSymbols("SMON-MIB", "portCopyEntry")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
iso, Gauge32, Counter32, ObjectIdentity, NotificationType, TimeTicks, IpAddress, Counter64, MibIdentifier, ModuleIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "Counter32", "ObjectIdentity", "NotificationType", "TimeTicks", "IpAddress", "Counter64", "MibIdentifier", "ModuleIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Bits")
TextualConvention, DisplayString, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TruthValue")
ciscoRmonConfigMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 103))
ciscoRmonConfigMIB.setRevisions(('2010-08-03 00:00', '2008-05-02 00:00', '2008-04-04 00:00', '2006-02-21 00:00', '2005-09-28 12:10', '2005-05-02 00:00', '2005-01-24 00:00', '2004-02-04 00:00', '2004-02-03 00:00', '2003-04-29 00:00', '2002-10-08 00:00', '2001-04-01 00:00', '2001-02-22 00:00', '1998-12-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoRmonConfigMIB.setRevisionsDescriptions(("Add enumerator 'reflector' in crcSpanCapacityType.", 'Added rmonConfiguredAlarms,rmonConfiguredHcAlarms. deprecated ciscoRmonConfigComplianceRev9 and added rmonAlarmCapacityGroup, ciscoRmonConfigComplianceRev10', 'Add crcSpanCapacityGroup.', 'Add TC SpanTxReplicationMode and object group crcSpanEgressReplicationGroup.', 'Add crcERSpanIFOptionGroup and deprecate crcDstERSpanOption.', "Add crcSpanSessionDescr and value 'localTx' to portCopySessionType.", 'Add MIB group crcSpanDstPermitListGroup.', 'Updated crcERSpanSessionType.', 'Add the following MIB objects: crcSpanSessionNo, crcSpanSessionType, crcSpanSessionEnabled, crcERSpanSessionNo, crcERSpanSessionType, crcERSpanSessionDescr, crcERSpanEncapID, crcERSpanIpType, crcERSpanIp, crcSrcERSpanIpTTL, crcSrcERSpanDscpOrPrec, crcSrcERSpanIpPrec, crcSrcERSpanIpDscp, crcERSpanIpVRF, crcSrcERSpanLoVlanMask, crcSrcERSpanHiVlanMask, crcSrcERSpanOrigIpType, crcSrcERSpanOrigIp, crcDstERSpanOption, crcERSpanSessionRowStatus, crcERSpanIFIndex, crcERSpanIFDirection, crcERSpanIFRowStatus.', 'Added the portCopyInpktVlan MIB object. Add the following bit definitions to the existing MIB object portCopyOption: unicastDisable, broadcastDisable, goodDisable, badDisable.', 'Added rmonMaxAlarms and rmonAlarmEnable.', 'Add the portCopyReflectorPort MIB object', 'Add the following MIB objects: portCopyDestLoVlanMask, portCopyDestHiVlanMask, portCopyOption, portCopySessionNo, portCopySessionType, portCopyRemoveSrc, portCopyMaxIngressSessions, portCopyMinEgressSessions.', 'Updated the portCopyXTable; portCopyDirection moved to SMON standard, and multiple VLANs per source port now supported.',))
if mibBuilder.loadTexts: ciscoRmonConfigMIB.setLastUpdated('201008030000Z')
if mibBuilder.loadTexts: ciscoRmonConfigMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoRmonConfigMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-rmon@cisco.com')
if mibBuilder.loadTexts: ciscoRmonConfigMIB.setDescription("This module defines configuration extensions for some of the IETF RMON MIBs. The following terms are used throughout this MIB: A SPAN session is an association of one or more destination(s) with a set of source(s), along with other parameters, to specify the network traffic to be monitored. Each SPAN session is denoted by an unique number. The term 'remote SPAN', also called 'RSPAN', refers to the analysis of network traffic remotely, from destination port(s) for one or more source ports, distributed in one or more switches in a switched network, through a RSPAN VLAN.")
ciscoRmonConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1))
ciscoRmonConfigNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 2))
ciscoRmonConfigConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 3))
ciscoRmon2ConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 1))
ciscoSmonConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2))
ciscoSampleConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 3))
ciscoAlarmConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 4))
ciscoSpanTxReplicationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 5))
ciscoSpanCapacityObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6))
class SpanTxReplicationMode(TextualConvention, Integer32):
    description = 'Describes whether egress SPAN packets replication is centralized in the device or distributed to where traffic is sourced.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("centralized", 1), ("distributed", 2))

rmonTimeFilterMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stopAfterOne", 1), ("stopAfterAll", 2))).clone('stopAfterAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonTimeFilterMode.setStatus('current')
if mibBuilder.loadTexts: rmonTimeFilterMode.setDescription("This object controls the way the SNMP agent implements the getnext operation for tables with a TimeFilter index, such as those found in the RMON2-MIB module. If this object has the value `stopAfterOne(1)', then a GetNext or GetBulk operation will provide one pass through a given table, i.e., the agent will continue to the next object or table, instead of incrementing a TimeMark INDEX value, even if there exists higher TimeMark values which are valid for the same conceptual row. This mode is not strictly compliant with the TimeFilter textual convention definition, because potentially many conceptual rows will be skipped instead of returned in a GetNext or GetBulk operation. Such rows are identical to each other, except for the returned TimeMark INDEX value. This mode is intended only for testing purposes, however it may also be useful if an NMS wishes to utilize the GetBulk PDU. This mode will prevent the GetBulk responses from containing duplicate rows due to the TimeFilter mechanism. If this object has the value `stopAfterAll(2)', then a getNext or getBulk MIB walk will repeat through the same MIB table until the TimeMark for the most-recently changed entry is reached. Note that as long as traffic occurs on the monitored interface, it is possible a highest value of the TimeFilter INDEX may never be reached. This mode is strictly compliant with the TimeFilter textual convention definition. Note that GetBulk PDU responses in this mode will likely contain multiple copies of the same MIB instances, differing only in the TimeMark INDEX value. As an example, consider row 'fooEntry' which was last updated at 'time 1000'. An NMS may use any TimeMark INDEX value in the range '0' to '1000', and the current (i.e., time of get request) counter values for the 'fooEntry' will be returned by agent. In the 'stopAfterOne' mode, the agent will not increment the fooEntry TimeMark index under any conditions. In the 'stopAfterAll' mode, the agent will increment any fooEntry TimeMark INDEX value in the range '0' to '999', up until the TimeMark value of '1000' is reached.")
portCopyXTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1), )
if mibBuilder.loadTexts: portCopyXTable.setStatus('current')
if mibBuilder.loadTexts: portCopyXTable.setDescription('This table extends the port copy capability found in the SMON MIB portCopyTable. This table is intended to augment every portCopyEntry, but not all features provided may be available on all RMON platforms. In such a case, a particular MIB object will be implemented with read-only access.')
portCopyXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1), )
portCopyEntry.registerAugmentions(("CISCO-RMON-CONFIG-MIB", "portCopyXEntry"))
portCopyXEntry.setIndexNames(*portCopyEntry.getIndexNames())
if mibBuilder.loadTexts: portCopyXEntry.setStatus('current')
if mibBuilder.loadTexts: portCopyXEntry.setDescription("Describes a particular port copy extension entry. When creating an entry in this table using the 'createAndwait' method, the following rules are applied: - no SPAN consistency check is done for the entry until the entry is activated. An entry will not be activated if it fails the SPAN consistency check described for the 'createAndGo' method. -an instance remains in the 'notReady' state until the associated portCopyStatus changes to 'active'. When the agent processes a request of adding an entry using 'createAndGo' method or a request that sets the value of portCopyStatus object to 'active', the following rules are applied: The agent will add the entry to a SPAN session having the same portCopySessionNo, or create a new session if it does not exist. To join an existing session, either portCopySource or portCopyDest, but not both, must exist in one of the entries from the same SPAN session. In addition, the following actions will be taken after a successful join: 1. The portCopyDirection, portCopyLoVlanMask, and portCopyHiVlanMask values will overwrite the existing values associated with this port copy session. 2. The portCopyDestLoVlanMask, portCopyDestHiVlanMask, and portCopyOption values will overwrite the existing values associated the same portCopyDest and this port copy session. 3. If the value of portCopyDest object does not exist in the existing SPAN session, each of the ports identified in the portCopySource is added to this SPAN session. For example, given an existing SPAN session having ports 1, 2, and 3 as source ports, and port A as the destination port, if an entry is added by an NMS with indices of (2,B), the agent will also add entries for the other source ports (e.g. (1,B) and (3,B)) to the session. The same algorithm for adding entries will be applied if the portCopySource does not already belong to this SPAN session. When the agent processes a request to change the RowStatus of an entry from 'active' to 'notInService', the following rules are applied: - That entry will be removed from its participating SPAN session. The new RowStatus state will be 'notInService'. - all entries in the table that have the same value of portCopySessionNo and same value of portCopySource are also set to 'NotInService'. When agent processes a request to delete an entry, the following rules are applied: - the entry is simply removed if it is not currently active. - if the portCopySessionNo value is non-zero and the value of portCopyRemoveSrc object is set to 'true', then all entries with the same value of portCopySessionNo and same value of portCopySource are deleted. - if the portCopySessionNo value is non-zero and the value of portCopyRemoveSrc object is set to 'false', then all entries with the same value of portCopySessionNo and same value of portCopyDest are deleted. - if the last portCopy entry is removed from a session, then the session information is also removed.")
portCopyLoVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyLoVlanMask.setStatus('current')
if mibBuilder.loadTexts: portCopyLoVlanMask.setDescription("This object affects the way VLAN-based traffic is copied from a switch source port, for the indicated port copy operation. It is used in tandem with the portCopyHiVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 0 though 2047. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated portCopyHiVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. If this object has a non-zero length, and at least one octet contains a non-zero value, or the portCopyHiVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination port. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 0 through 7; the second octet to VLANs 8 through 15; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. The creation and deletion of instances of this object is controlled by the portCopyStatus object found in the augmented portCopyEntry. It is an implementation-specific matter as to how many VLANs may be selected from a particular physical source port at any one time, or whether this object may be modified while the associated portCopyStatus object is equal to 'active'.")
portCopyHiVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyHiVlanMask.setStatus('current')
if mibBuilder.loadTexts: portCopyHiVlanMask.setDescription("This object affects the way VLAN-based traffic is copied from a switch source port, for the indicated port copy operation. It is used in tandem with the portCopyLoVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 2048 though 4095. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated portCopyLoVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. If this object has a non-zero length, and at least one octet contains a non-zero value, or the portCopyLoVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination port. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 2048 through 2055; the second octet to VLANs 2056 through 2063; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. The creation and deletion of instances of this object is controlled by the portCopyStatus object found in the augmented portCopyEntry. It is an implementation-specific matter as to how many VLANs may be selected from a particular physical source port at any one time, or whether this object may be modified while the associated portCopyStatus object is equal to 'active'.")
portCopyDestLoVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyDestLoVlanMask.setStatus('current')
if mibBuilder.loadTexts: portCopyDestLoVlanMask.setDescription("This object affects the way VLAN-based traffic to a switch destination port is filtered for the indicated port copy operation. It is used in tandem with the portCopyDestHiVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 0 though 2047. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated portCopyDestHiVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. If this object has a non-zero length, and at least one octet contains a non-zero value, or the portCopyDestHiVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination port. If a VLAN is included in the portCopyDestLoVlanMask object, it should also be included in the portCopyLoVlanMask object and vice versa. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 0 through 7; the second octet to VLANs 8 through 15; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. The creation and deletion of instances of this object is controlled by the portCopyStatus object found in the augmented portCopyEntry. It is an implementation-specific matter as to how many VLANs may be selected from a particular physical source port at any one time, or whether this object may be modified while the associated portCopyStatus object is equal to 'active'.")
portCopyDestHiVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyDestHiVlanMask.setStatus('current')
if mibBuilder.loadTexts: portCopyDestHiVlanMask.setDescription("This object affects the way VLAN-based traffic to a switch destination port is filtered for the indicated port copy operation. It is used in tandem with the portCopyDestLoVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 2048 though 4095. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated portCopyDestLoVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. If this object has a non-zero length, and at least one octet contains a non-zero value, or the portCopyDestLoVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination port. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination port. If a VLAN is included in the portCopyDestHiVlanMask object, it should also be included in the portCopyHiVlanMask object and vice versa. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 2048 through 2055; the second octet to VLANs 2056 through 2063; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. The creation and deletion of instances of this object is controlled by the portCopyStatus object found in the augmented portCopyEntry. It is an implementation-specific matter as to how many VLANs may be selected from a particular physical source port at any one time, or whether this object may be modified while the associated portCopyStatus object is equal to 'active'.")
portCopyOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 5), Bits().clone(namedValues=NamedValues(("inpkts", 0), ("learningDisable", 1), ("dot1q", 2), ("isl", 3), ("multicast", 4), ("unicastDisable", 5), ("broadcastDisable", 6), ("goodDisable", 7), ("badDisable", 8)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyOption.setStatus('current')
if mibBuilder.loadTexts: portCopyOption.setDescription('Indicates the additional SPAN configuration on destination port. Instances of same portCopyDest index must have same values in portCopyOption. Changes on portCopyOption of one instance will be applied to all other instances of same portCopyDest index. - inpkts(0) This bit is set to enable the destination port to receive normal incoming traffic. - learningDisable(1) This bit is set to suppress MAC learning for incoming traffic at the destination port. - dot1q(2) This bit is set for dot1q trunking encapsulation of forwarded traffic at the destination port. This bit can not be set when isl(3) bit is 1. - isl(3) This bit is set for isl trunking encapsulation of forwarded traffic at the destination port. This bit can not be set when dot1q(2) bit is 1. - multicast(4) This bit is set to enable the destination port to receive multicast traffic. - unicastDisable(5) This bit is set to disable the destination port to receive unicast traffic. - broadcastDisable(6) This bit is set to disable the destination port to receive broadcast traffic. - goodDisable(7) This bit is set to disable the destination port to receive good packets. - badDisable(8) This bit is set to disable the destination port to receive bad packets.')
portCopySessionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopySessionNo.setStatus('current')
if mibBuilder.loadTexts: portCopySessionNo.setDescription("Indicates the arbitrary unique identifier for this SPAN session. If a non zero value is specified, the agent will check if a SPAN session that has the same session number exists. If so, the agent will use this session number when this entry is activated. This entry will be added to the existing SPAN session (identified by all entries with the same portCopySessionNo value). If no such session exists, a new SPAN session is created and assigned the specified value. Otherwise, the agent will check if the destination port belongs to an existing SPAN session. If so, the agent will assign that session number when this entry is activated. This entry will be added to the existing SPAN session (identified by all entries with the same portCopySessionNo value). If no such session exists, a new SPAN session is created and assigned an arbitrary, locally unique value. If the associated portCopyStatus object is equal to 'active', then this object may not be modified.")
portCopySessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSpecified", 1), ("local", 2), ("remoteSource", 3), ("remoteDestination", 4), ("localTx", 5))).clone('notSpecified')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopySessionType.setStatus('current')
if mibBuilder.loadTexts: portCopySessionType.setDescription("Indicates the SPAN session type. 'remoteSource' refers to session where traffic is copied from source port to RSPAN VLAN as its destination port. 'remoteDestination' refers to session where traffic is copied from RSPAN VLAN to the destination port. For 'local' SPAN session, both source and destination ports reside in the same switch. 'localTx' refers to session where only traffic transmitted out the indicated source port will be copied to the destination port, i.e. the corresponding portCopyDirection can only have the value of 'copyTxOnly'. In a set operation, agent will decide the actual SPAN type for the session if this MIB object is 'notSpecified' based on type of source and destination ports. A read operation will return one of the other three types. Changes on portCopySessionType of one entry will be applied to all existing active entries having the same value of portCopySessionNo if such change is allowed by the implementation. If the associated portCopyStatus object is equal to 'active', then this object may not be modified.")
portCopyRemoveSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyRemoveSrc.setStatus('current')
if mibBuilder.loadTexts: portCopyRemoveSrc.setDescription("Indicates how the agent will modify a SPAN session when an entry belonging to this session is deleted. The value 'true' specifies source port based entry deletion. In source port based deletion, all entries of same index portCopySource from the session are to be deleted. The value 'false' specifies destination based entry deletion. In destination port based deletion, all entries of same index portCopyDest from the session are to be deleted.")
portCopyReflectorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 9), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyReflectorPort.setStatus('current')
if mibBuilder.loadTexts: portCopyReflectorPort.setDescription('Indicates the reflector port of this SPAN session. The value of this object is ignored whenever the value of portCopySessionType is not remoteSource(3).')
portCopyInpktVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyInpktVlan.setStatus('current')
if mibBuilder.loadTexts: portCopyInpktVlan.setDescription("This object indicates the default VLAN that is used for the untagged incoming traffic from the portCopyDest when portCopyOption's inpkts bit is set. The range is defined to identify all possible 4096 IEEE 802.1Q VLAN ID values although only 1 - 4094 are valid VLAN IDs that could be configured as the default VLAN for the untagged incoming traffic. If this object contains a value of zero and portCopyOption's inpkts bit is set, then the switch is free to use its default VLAN for untagged incoming packets. On platforms that do not have a dedicated default VLAN for this purpose, error is returned. If portCopyOption's inpkts bit is not set or isl bit is set, the value in this object is ignored by the agent.")
portCopyMaxIngressSessions = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCopyMaxIngressSessions.setStatus('current')
if mibBuilder.loadTexts: portCopyMaxIngressSessions.setDescription('The maximum number of local ingress (rx or both) SPAN session that can be configured on this agent.')
portCopyMaxEgressSessions = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCopyMaxEgressSessions.setStatus('current')
if mibBuilder.loadTexts: portCopyMaxEgressSessions.setDescription('The maximum number of local egress SPAN sessions that can be configured on this agent.')
crcSpanSessionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4), )
if mibBuilder.loadTexts: crcSpanSessionTable.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionTable.setDescription('Contains SPAN session entries. A row is created for each SPAN session configured in a device.')
crcSpanSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-RMON-CONFIG-MIB", "crcSpanSessionNo"))
if mibBuilder.loadTexts: crcSpanSessionEntry.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionEntry.setDescription('Describes a particular SPAN session.')
crcSpanSessionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: crcSpanSessionNo.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionNo.setDescription('Defines a SPAN session number.')
crcSpanSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 1), ("remote", 2), ("erspan", 3), ("service", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanSessionType.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionType.setDescription("Defines the SPAN session type. 'local' refers to SPAN session where both source and destination ports reside in the same switch. This type of SPAN is manageable via portCopyTable and portCopyXTable. 'remote' refers to session where traffic is copied from source port to RSPAN VLAN as its destination port or vise versa. This type of SPAN is manageable via portCopyTable and portCopyXTable. 'erspan' refers to a session where traffic is copied from crcERSpanIFIndex of crcERSpanIFTable as source to crcERSpanIp as destination or vise versa. This type of SPAN is manageable via crcERSpanSessionTable and crcERSpanIFTable. 'service' refers to special SPAN service session. 'other' refers to any other SPAN session type not enumerated for the MIB object.")
crcSpanSessionEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crcSpanSessionEnabled.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionEnabled.setDescription("Indicates whether the SPAN session is enabled. Modifying the value of crcSpanSessionEnabled to 'false' stops the SPAN monitoring but does not remove this SPAN configuration from the system.")
crcSpanSessionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 4, 1, 4), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crcSpanSessionDescr.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionDescr.setDescription('Provides description of this SPAN session.')
crcERSpanSessionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5), )
if mibBuilder.loadTexts: crcERSpanSessionTable.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionTable.setDescription('Contains ERSPAN session entries. A row is created for each SPAN session configured in a device. A row can only be created if an instance of the same session number is not present in crcSpanSessionEntry. ERSPAN, or Encapsulated Remote SPAN, provides the ability to copy all frames from a specified source to a specified destination across a layer 3 network, allowing source and destination to be from different devices. Depending on type of ERSPAN, the source can be an interface from crcERSpanIFIndex of crcERSpanIFTable, the destination be a layer 3 internet address defined by crcERSpanIp of this table, or vise versa.')
crcERSpanSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-RMON-CONFIG-MIB", "crcERSpanSessionNo"))
if mibBuilder.loadTexts: crcERSpanSessionEntry.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionEntry.setDescription('Describes a particular SPAN session.')
crcERSpanSessionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: crcERSpanSessionNo.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionNo.setDescription('Defines an ERSPAN session number.')
crcERSpanSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eRSpanSource", 1), ("eRSpanDestination", 2))).clone('eRSpanSource')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanSessionType.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionType.setDescription("Defines the ERSPAN session type. This object may not be modified if the value of the corresponding instance of crcERSpanSessionRowStatus is active. 'eRSpanSource' refers to a session where traffic is copied from crcERSpanIFIndex of crcERSpanIFTable as source to crcERSpanIp as destination. 'eRSpanDestination' refers to a session where traffic is copied from crcERSpanIp as source to crcERSpanIFIndex of crcERSpanIFTable as destination.")
crcERSpanSessionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 3), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanSessionDescr.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionDescr.setDescription('Provides description of this ERSPAN session. This object may be modified when the row is active.')
crcERSpanEncapID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanEncapID.setStatus('current')
if mibBuilder.loadTexts: crcERSpanEncapID.setDescription("Defines ERSPAN's encapsulation id for this entry. This object may be modified when the row is active.")
crcERSpanIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 5), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIpType.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIpType.setDescription('Defines the type of Internet address for crcERSpanIp used by this entry. This object may be modified when the row is active.')
crcERSpanIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIp.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIp.setDescription('Defines Internet address of copy source or destination. If crcERSanSessionType has value of eRSpanSource(1), crcERSpanIp is a copy destination. If crcERSpanSessionType has value of eRSpanDestination(2), crcERSpanIp is a copy source. This object may be modified when the row is active.')
crcSrcERSpanIpTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanIpTTL.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanIpTTL.setDescription('The IP TTL value for this traffic type. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.')
crcSrcERSpanDscpOrPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dscp", 1), ("precedence", 2))).clone('dscp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanDscpOrPrec.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanDscpOrPrec.setDescription('The QOS classification used - precedence or DSCP based. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.')
crcSrcERSpanIpPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanIpPrec.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanIpPrec.setDescription('The IP precedence value for this traffic type. This object is only significant when object crcERSpanSessionType is eRSpanSource(1) and object crcSrcERSpanDscpOrPrec is precedence(1). This object may be modified when the row is active.')
crcSrcERSpanIpDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 10), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanIpDscp.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanIpDscp.setDescription('The IP DSCP value for this traffic type. This object is only significant when object crcERSpanSessionType is eRSpanSource(1) and object crcSrcERSpanDscpOrPrec is dscp(1). This object may be modified when the row is active.')
crcERSpanIpVRF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 11), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIpVRF.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIpVRF.setDescription('Specifies VRF used for the traffic type. This object may be modified when the row is active.')
crcSrcERSpanLoVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanLoVlanMask.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanLoVlanMask.setDescription("This object affects the way VLAN-based traffic is copied from a switch source port, for the indicated port copy operation. It is used in tandem with the crcSrcERSpanHiVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 0 though 2047. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated crcSrcERSpanHiVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination. If this object has a non-zero length, and at least one octet contains a non-zero value, or the crcSrcERSpanHiVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 0 through 7; the second octet to VLANs 8 through 15; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.")
crcSrcERSpanHiVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanHiVlanMask.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanHiVlanMask.setDescription("This object affects the way VLAN-based traffic is copied from a switch source port, for the indicated port copy operation. It is used in tandem with the crcSrcERSpanLoVlanMask to identify all possible 4096 IEEE 802.1Q VLAN ID values. This object is used to select or deselect VLAN IDs 2048 though 4095. If this object contains a zero-length string, or none of the octets contain a non-zero value, and the associated crcSrcERSpanLoVlanMask is not instantiated, contains a zero-length string, or contains only zero-valued octets, then network traffic will not be filtered, based on IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination. If this object has a non-zero length, and at least one octet contains a non-zero value, or the crcSrcERSpanLoVlanMask contains at least one non-zero octet, then traffic will be filtered, based on the indicated IEEE 802.1Q or ISL VLAN ID, before it is copied to the indicated destination. Only frames (tagged or untagged) which match the indicated VLAN ID(s) will be copied to the indicated destination. VLAN IDs are encoded as a string of octets containing one bit per VLAN to be included in the port copy operation. The first octet corresponds to VLANs with VlanIndex values of 2048 through 2055; the second octet to VLANs 2056 through 2063; etc. The most significant bit of each octet corresponds to the lowest value VlanIndex in that octet. If the bit corresponding to a VLAN is set to '1', then the traffic associated with that VLAN will be selected for the indicated port copy operation. Note that if the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.")
crcSrcERSpanOrigIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 14), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanOrigIpType.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanOrigIpType.setDescription('Defines the type of Internet address for crcSrcERSpanOrigIp used by this entry. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.')
crcSrcERSpanOrigIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 15), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSrcERSpanOrigIp.setStatus('current')
if mibBuilder.loadTexts: crcSrcERSpanOrigIp.setDescription('Defines the Internet address of copy source. This object is only significant when object crcERSpanSessionType is eRSpanSource(1). This object may be modified when the row is active.')
crcDstERSpanOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 16), Bits().clone(namedValues=NamedValues(("inpkts", 0), ("learningDisable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcDstERSpanOption.setStatus('deprecated')
if mibBuilder.loadTexts: crcDstERSpanOption.setDescription('Indicates the additional ERSPAN configuration on destination port. - inpkts(0) This bit is set to enable the destination port to receive incoming traffic. - learningDisable(1) This bit is set to suppress MAC learning for incoming traffic at the destination port. This object only takes effect when object crcERSpanSessionType is eRSpanDestination(2) and crcERSpanIfIndex of same ERSPAN session from crcERSpanIFTable points to a physical port. This object may be modified when the row is active. This object is deprecated and replaced by crcERSpanIFOption.')
crcERSpanSessionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 5, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanSessionRowStatus.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionRowStatus.setDescription('Defines the status of this entry.')
crcERSpanIFTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6), )
if mibBuilder.loadTexts: crcERSpanIFTable.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFTable.setDescription('This table in conjunction with crcERSpanSessionTable, provides the ability to copy all frames from a specified source to a specified destination across a layer 3 network. A row is created for each interface from ifEntries that is configured as ERSPAN source or destination while crcERSpanSessionRowStatus is active(1) for the corresponding session.')
crcERSpanIFEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-RMON-CONFIG-MIB", "crcERSpanSessionNo"), (0, "CISCO-RMON-CONFIG-MIB", "crcERSpanIFIndex"))
if mibBuilder.loadTexts: crcERSpanIFEntry.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFEntry.setDescription('Describes a particular ERSPAN copy source or copy destination entry.')
crcERSpanIFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: crcERSpanIFIndex.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFIndex.setDescription("Defines the device interface's ifIndex. Mapped via crcERSpanSessionNo, if crcERSanSessionType from crcERSpanSessionTable has value of eRSpanSource(1), crcRSpanIFIndex is a copy source. If crcERSpanSessionType has value of eRSpanDestination(2), crcRSpanIFIndex is a copy destination.")
crcERSpanIFDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("copyRxOnly", 1), ("copyTxOnly", 2), ("copyBoth", 3))).clone('copyBoth')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIFDirection.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFDirection.setDescription("This object affects the way traffic is copied from a device's source. If this object has the value 'copyRxOnly(1)', then only traffic received on crcERSpanIFIndex will be copied to the destination. If this object has the value 'copyTxOnly(2)', then only traffic transmitted out the crcERSpanIFIndex will be copied to the destination. If this object has the value 'copyBoth(3)', then all traffic received or transmitted on crcERSpanIFIndex will be copied to the destination. This object is only significant when object crcERSpanSessionType of the corresponding crcERSpanSessionTable, mapped via crcERSpanSessionNo, is eRSpanSource(1). This object may be modified when the row is active.")
crcERSpanIFRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIFRowStatus.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFRowStatus.setDescription("Defines the status of this entry. For this object to be active(1), the crcERSpanSessionRowStatus from crcERSpanSessionTable, mapped via crcERSpanSessionNo, must be active(1). If the said crcERSpanSessionRowStatus transistions to notInService(2) or destroy(6), all corresponding entries from crcERSpanIFTable will be deleted. In order to configure a source to destination traffic copy relationship, crcERSpanIFIndex MUST be present as an ifEntry in the ifTable and its respective ifAdminStatus and ifOperStatus values MUST be equal to 'up(1)'. If the value of any of those two objects changes after the crcERSpanSessionEntry is activated, crcERSpanSessionRowStatus will transition to 'notReady(3)'. The capability of crcERSpanIFIndex to be source or destination of a port copy operation is described by the 'copySourcePort(0)' and 'copyDestPort(1)' bits in dataSourceCopyCaps. Those bits SHOULD be appropriately set by the agent, in order to allow for a crcERSpanIFEntry to be created.")
crcERSpanIFOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 6, 1, 4), Bits().clone(namedValues=NamedValues(("inpkts", 0), ("learningDisable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcERSpanIFOption.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFOption.setDescription('Indicates the additional ERSPAN configuration on destination port. - inpkts This bit is set to enable the destination port to receive incoming traffic. - learningDisable This bit is set to suppress MAC learning for incoming traffic at the destination port. This object can only be modified when object crcERSpanSessionType of the corresponding crcERSpanSessionTable, mapped via crcERSpanSessionNo, is eRSpanDestination and the crcERSpanIfIndex points to a physical port. This object may be modified when the row is active.')
crcSpanDstPermitListEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crcSpanDstPermitListEnabled.setStatus('current')
if mibBuilder.loadTexts: crcSpanDstPermitListEnabled.setDescription("Indicates whether the SPAN destination permit list feature is enabled. When crcSpanDstPermitListEnabled is 'true', only ports that have an entry in crcSpanDstPermitListTable are allowed to set as SPAN destination. There is no such restriction when crcSpanDstPermitListEnabled is 'false'.")
crcSpanDstPermitListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 8), )
if mibBuilder.loadTexts: crcSpanDstPermitListTable.setStatus('current')
if mibBuilder.loadTexts: crcSpanDstPermitListTable.setDescription("Contains a list of ports that are configured as allowed SPAN destination ports. Entry of portCopyTable with its portCopyDest can not be created if crcSpanDstPermitListEnabled is 'true' and a corresponding entry does not exist in the crcSpanDstPermitListTable table. In other words the InterfaceIndex specified by portCopyDest object from SMON-MIB must match ifIndex of entries in this table.")
crcSpanDstPermitListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: crcSpanDstPermitListEntry.setStatus('current')
if mibBuilder.loadTexts: crcSpanDstPermitListEntry.setDescription('Describes a particular entry that can be set as SPAN destination.')
crcSpanDstPermitListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 2, 8, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crcSpanDstPermitListRowStatus.setStatus('current')
if mibBuilder.loadTexts: crcSpanDstPermitListRowStatus.setDescription('Defines the status of this entry. An active entry means that the port of this ifIndex can be set as SPAN destination port. The valid values are active(1), createAndGo(4) and destroy(6).')
crcSpanEgressReplicationMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 5, 1), SpanTxReplicationMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crcSpanEgressReplicationMode.setStatus('current')
if mibBuilder.loadTexts: crcSpanEgressReplicationMode.setDescription('Describes where SPAN egress packets get replicated, centralized in the device or distributed to where traffic is sourced')
crcSpanSessionEgressModeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 5, 2), )
if mibBuilder.loadTexts: crcSpanSessionEgressModeTable.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionEgressModeTable.setDescription('A table containing operational SPAN egress packet replication mode for each SPAN session. A row is created for each SPAN session that is capable of monitoring egress traffic in a device.')
crcSpanSessionEgressModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 5, 2, 1), ).setIndexNames((0, "CISCO-RMON-CONFIG-MIB", "crcSpanSessionNo"))
if mibBuilder.loadTexts: crcSpanSessionEgressModeEntry.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionEgressModeEntry.setDescription('Describes a particular SPAN session that is capable of monitoring egress traffic.')
crcSpanEgressReplicationOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 5, 2, 1, 1), SpanTxReplicationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanEgressReplicationOperMode.setStatus('current')
if mibBuilder.loadTexts: crcSpanEgressReplicationOperMode.setDescription('The current egress replication mode in operation.')
crcSpanCapacityTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1), )
if mibBuilder.loadTexts: crcSpanCapacityTable.setStatus('current')
if mibBuilder.loadTexts: crcSpanCapacityTable.setDescription('This table lists the resource capacity for each SPAN session type that is capable of providing such information.')
crcSpanCapacityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-RMON-CONFIG-MIB", "crcSpanCapacityType"))
if mibBuilder.loadTexts: crcSpanCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: crcSpanCapacityEntry.setDescription('Indicating resource capacity and usage information for a particular SPAN capacity session type.')
crcSpanCapacityType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("allSrc", 1), ("allDst", 2), ("localSrc", 3), ("localTx", 4), ("rspanSrc", 5), ("rspanDst", 6), ("erspanSrc", 7), ("erspanDst", 8), ("serviceModule", 9), ("oamLoopback", 10), ("capture", 11), ("reflector", 12))))
if mibBuilder.loadTexts: crcSpanCapacityType.setStatus('current')
if mibBuilder.loadTexts: crcSpanCapacityType.setDescription("Indicating the SPAN resource capacity session type. 'allSrc' refers to all SPAN source sessions. 'allDst' refers to all SPAN destination sessions. 'localSrc' refers to local SPAN session where both source and destination ports reside in the same switch. 'localTx' refers to local Tx only SPAN session. 'rspanSrc' refers to remote span source in a RSPAN session where traffic is copied from source port to RSPAN VLAN as its destination port. 'rspanDst' refers to remote span destination in a RSPAN session where traffic is copied from RSPAN VLAN as its source to its destination port. 'erspanSrc' refers to a session where traffic is copied from crcERSpanIFIndex of crcERSpanIFTable as source to crcERSpanIp as destination. 'erspanDst' refers to a session where traffic is copied from crcERSpanIp as source to crcERSpanIFIndex of crcERSpanIFTable as destination. 'serviceModule' refers to special SPAN service module session. 'oamLoopback' refers to special SPAN service for OAM (Operations, Administration and Maintenance) loopback. 'capture' refers to Packet Capture Span Session. 'reflector' refers to Reflector Span Session.")
crcSpanCapacityShared = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("source", 2), ("destination", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanCapacityShared.setStatus('current')
if mibBuilder.loadTexts: crcSpanCapacityShared.setDescription("Indicating the shared SPAN capacity type. 'none' means the capacity is not shared out of crcSpanSharedSource or crcSpanSharedDestination. 'source' means the capacity is counted against crcSpanSharedSource. The sum of crcSpanUsedSession for all entries with crcSpanCapacityShared being 'source' shall not exceed crcSpanSharedSource. 'destination' means the capacity is counted against crcSpanSharedDestination. The sum of crcSpanUsedSession for all entries with crcSpanCapacityShared being 'destination' shall not exceed crcSpanSharedDestination.")
crcSpanMaxSession = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanMaxSession.setStatus('current')
if mibBuilder.loadTexts: crcSpanMaxSession.setDescription('The maximum number of sessions allowed for the SPAN type defined by crcSpanCapacityType. A value of zero indicates no specific limit for this SPAN capacity session type.')
crcSpanUsedSession = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanUsedSession.setStatus('current')
if mibBuilder.loadTexts: crcSpanUsedSession.setDescription('The number of sessions currently used for the SPAN capacity session type defined.')
crcSpanSharedSource = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanSharedSource.setStatus('current')
if mibBuilder.loadTexts: crcSpanSharedSource.setDescription('The number of maximum shared span source sessions.')
crcSpanSharedDestination = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 6, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crcSpanSharedDestination.setStatus('current')
if mibBuilder.loadTexts: crcSpanSharedDestination.setDescription('The number of maximum shared span destination sessions.')
rmonSampleConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 3, 1), )
if mibBuilder.loadTexts: rmonSampleConfigTable.setStatus('current')
if mibBuilder.loadTexts: rmonSampleConfigTable.setDescription("This table controls the configuration of RMON collection based on statistical sampling techniques, for each monitored interface on the RMON probe. It is a SPARSE-AUGMENTS of the ifEntry found in the IF-MIB module. An entry is created in this table at the same time the augmented ifEntry is created (usually at system startup time), for each interface which can be monitored by the RMON agent. An associated entry in the SMON MIB dataSourceCapsTable is also created for each RMON-capable interface at the same time. An RMON collection is associated with a particular interface if the control table dataSource OBJECT IDENTIFIER is of the form 'ifIndex.I', and 'I' is the same value as the ifIndex value for the ifEntry and rmonSampleConfigEntry.")
rmonSampleConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rmonSampleConfigEntry.setStatus('current')
if mibBuilder.loadTexts: rmonSampleConfigEntry.setDescription('Describes a particular sampling configuration for the indicated RMON-capable interface.')
rmonSamplingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 3, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonSamplingEnabled.setStatus('current')
if mibBuilder.loadTexts: rmonSamplingEnabled.setDescription("This object affects the way the RMON probe uses statistical sampling to collect packets from the indicated interface. If this object has the value 'false', then the probe will attempt to monitor all packets detected on the indicated interface, in the event any RMON collections are actually configured. The data returned in all RMON collection tables associated with this interface will represent non-sampled monitored counter values. If this object has the value 'true', then the probe will use adaptive statistical sampling techniques to monitor the indicated interface, in the event any RMON collections are actually configured. The data returned in RMON collection tables associated with this interface may be based on statistical approximations. In this mode, the RMON agent will also maintain additional MIB objects to provide the confidence interval information for each sampled counter. These objects can be found in the CISCO-RMON-SAMPLING-MIB. When this object transitions from 'false' to 'true', all active packet capture functions will be suspended, without affecting the contents of any associated filterEntry, filter2Entry, channelEntry, channel2Entry, bufferControlEntry, captureBufferEntry, or captureBufferHighCapacityEntry. Only the low-level packet capture processing is deactivated. When this object transitions from 'true' to 'false', all suspended packet capture functions associated with the interface will be reactivated. Note that an NMS application which is unaware of this MIB object will not be able to detect suspended packet capture operations or sampled collections, however multi-manager mis-configuration issues are beyond the scope of this MIB. The packet capture function Get and Set operations are not affected by this object. If an interface cannot be sampled, or the sampling configuration cannot be modified, then such an instance of this object will be implemented with read-only access.")
rmonMaxAlarms = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 4, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonMaxAlarms.setStatus('current')
if mibBuilder.loadTexts: rmonMaxAlarms.setDescription('The maximum number of entries allowed in the alarmTable.')
rmonAlarmEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 4, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmEnable.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmEnable.setDescription("This object determines if the RMON alarm feature is enabled/disabled on this device. If this object is set to 'true', the RMON alarm feature enabled. If this object is 'false', RMON alarm feature is disabled. If the RMON feature is disabled, all the RMON alarm related polling are stopped. Note that this object is only intended for temporary disabling of RMON alarm feature to ensure that the CPU usage by RMON alarms is not detrimental. For permanent disabling on this feature, it suggested that all the entries in the alarmTable are removed.")
rmonConfiguredAlarms = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 4, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonConfiguredAlarms.setStatus('current')
if mibBuilder.loadTexts: rmonConfiguredAlarms.setDescription('Total number of entries configured in the alarmTable.')
rmonConfiguredHcAlarms = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 103, 1, 4, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonConfiguredHcAlarms.setStatus('current')
if mibBuilder.loadTexts: rmonConfiguredHcAlarms.setDescription('Total number of entries configured in the hcAlarmTable.')
ciscoRmonConfigCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1))
ciscoRmonConfigGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2))
ciscoRmonConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 1)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigCompliance = ciscoRmonConfigCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigCompliance.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 2)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions3Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev1 = ciscoRmonConfigComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev1.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 3)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions3Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev2 = ciscoRmonConfigComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev2.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 4)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev3 = ciscoRmonConfigComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev3.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 5)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev4 = ciscoRmonConfigComplianceRev4.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev4.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 6)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev5 = ciscoRmonConfigComplianceRev5.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev5.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 7)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions9Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev6 = ciscoRmonConfigComplianceRev6.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev6.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 8)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroupRev1"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions9Group"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFOptionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev7 = ciscoRmonConfigComplianceRev7.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev7.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 9)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroupRev1"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions9Group"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFOptionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanEgressReplicationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev8 = ciscoRmonConfigComplianceRev8.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev8.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev9 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 10)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroupRev1"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions9Group"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFOptionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanEgressReplicationGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanCapacityGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev9 = ciscoRmonConfigComplianceRev9.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev9.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
ciscoRmonConfigComplianceRev10 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 1, 11)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmon2ExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensionsGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions2Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions4Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions5Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions6Group"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions7Group"), ("CISCO-RMON-CONFIG-MIB", "rmonSampleConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmConfigGroup"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmCapacityGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions8Group"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionGroupRev1"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListGroup"), ("CISCO-RMON-CONFIG-MIB", "smonExtensions9Group"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFOptionGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanEgressReplicationGroup"), ("CISCO-RMON-CONFIG-MIB", "crcSpanCapacityGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRmonConfigComplianceRev10 = ciscoRmonConfigComplianceRev10.setStatus('current')
if mibBuilder.loadTexts: ciscoRmonConfigComplianceRev10.setDescription('Describes the requirements for conformance to Cisco RMON Configuration Extensions MIB.')
rmon2ExtensionsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 1)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmonTimeFilterMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rmon2ExtensionsGroup = rmon2ExtensionsGroup.setStatus('current')
if mibBuilder.loadTexts: rmon2ExtensionsGroup.setDescription('A collection of objects providing configuration extensions for the RMON2-MIB module.')
smonExtensionsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 2)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopyLoVlanMask"), ("CISCO-RMON-CONFIG-MIB", "portCopyHiVlanMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensionsGroup = smonExtensionsGroup.setStatus('current')
if mibBuilder.loadTexts: smonExtensionsGroup.setDescription('A collection of objects providing configuration extensions for the SMON-MIB module.')
rmonSampleConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 3)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmonSamplingEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rmonSampleConfigGroup = rmonSampleConfigGroup.setStatus('current')
if mibBuilder.loadTexts: rmonSampleConfigGroup.setDescription('A collection of objects providing configuration extensions for RMON agent implementations which support statistical sampling techniques.')
smonExtensions2Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 4)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopyDestLoVlanMask"), ("CISCO-RMON-CONFIG-MIB", "portCopyDestHiVlanMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions2Group = smonExtensions2Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions2Group.setDescription('A collection of objects providing additional port copy configuration for destination vlan filtering for the SMON-MIB module.')
smonExtensions3Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 5)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopyOption"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions3Group = smonExtensions3Group.setStatus('deprecated')
if mibBuilder.loadTexts: smonExtensions3Group.setDescription('A collection of objects providing additional port copy configuration extensions at destination port for the SMON-MIB module. This group is deprecated by smonExtensions8Group.')
smonExtensions4Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 6)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopySessionNo"), ("CISCO-RMON-CONFIG-MIB", "portCopyRemoveSrc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions4Group = smonExtensions4Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions4Group.setDescription('A collection of objects providing additional port copy configuration extensions for agent that supports SPAN session concept.')
smonExtensions5Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 7)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopySessionType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions5Group = smonExtensions5Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions5Group.setDescription('A collection of objects providing additional port copy configuration extensions for agent that supports local and remote SPAN.')
smonExtensions6Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 8)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopyMaxIngressSessions"), ("CISCO-RMON-CONFIG-MIB", "portCopyMaxEgressSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions6Group = smonExtensions6Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions6Group.setDescription('A collection of objects providing additional port copy information for the SMON-MIB module.')
smonExtensions7Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 9)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopySessionType"), ("CISCO-RMON-CONFIG-MIB", "portCopyReflectorPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions7Group = smonExtensions7Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions7Group.setDescription('A collection of objects providing additional port copy configuration extensions for agent that supports reflector port for SPAN session.')
rmonAlarmConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 10)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmonMaxAlarms"), ("CISCO-RMON-CONFIG-MIB", "rmonAlarmEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rmonAlarmConfigGroup = rmonAlarmConfigGroup.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmConfigGroup.setDescription('A collection of objects providing additional RMON configurations to control number alarms and to enable/disable alarms in the alarmTable in RMON-MIB.')
smonExtensions8Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 11)).setObjects(("CISCO-RMON-CONFIG-MIB", "portCopyOption"), ("CISCO-RMON-CONFIG-MIB", "portCopyInpktVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions8Group = smonExtensions8Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions8Group.setDescription('A collection of objects providing additional port copy configuration extensions for agent that supports ingress traffic at destination port for the SPAN session.')
crcSpanSessionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 12)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcSpanSessionType"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSessionEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcSpanSessionGroup = crcSpanSessionGroup.setStatus('current')
if mibBuilder.loadTexts: crcSpanSessionGroup.setDescription('A collection of objects providing SPAN session information.')
crcERSpanSessionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 13)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionType"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionDescr"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanEncapID"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIpType"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIp"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpTTL"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanDscpOrPrec"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpPrec"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpDscp"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIpVRF"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanLoVlanMask"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanHiVlanMask"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanOrigIpType"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanOrigIp"), ("CISCO-RMON-CONFIG-MIB", "crcDstERSpanOption"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcERSpanSessionGroup = crcERSpanSessionGroup.setStatus('deprecated')
if mibBuilder.loadTexts: crcERSpanSessionGroup.setDescription('A collection of objects providing ERSPAN session information.')
crcERSpanIFGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 14)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcERSpanIFDirection"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIFRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcERSpanIFGroup = crcERSpanIFGroup.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFGroup.setDescription('A collection of objects providing ERSPAN copy source or copy destination information.')
crcSpanDstPermitListGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 15)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListEnabled"), ("CISCO-RMON-CONFIG-MIB", "crcSpanDstPermitListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcSpanDstPermitListGroup = crcSpanDstPermitListGroup.setStatus('current')
if mibBuilder.loadTexts: crcSpanDstPermitListGroup.setDescription('A collection of objects used to control selection of destination port information.')
smonExtensions9Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 16)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcSpanSessionDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonExtensions9Group = smonExtensions9Group.setStatus('current')
if mibBuilder.loadTexts: smonExtensions9Group.setDescription('Providing SPAN session description information.')
crcERSpanIFOptionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 17)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcERSpanIFOption"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcERSpanIFOptionGroup = crcERSpanIFOptionGroup.setStatus('current')
if mibBuilder.loadTexts: crcERSpanIFOptionGroup.setDescription('Providing additional port copy configuration extensions for agent that supports ingress traffic at destination port for the ERSPAN session.')
crcERSpanSessionGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 18)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionType"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionDescr"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanEncapID"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIpType"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIp"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpTTL"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanDscpOrPrec"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpPrec"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanIpDscp"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanIpVRF"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanLoVlanMask"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanHiVlanMask"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanOrigIpType"), ("CISCO-RMON-CONFIG-MIB", "crcSrcERSpanOrigIp"), ("CISCO-RMON-CONFIG-MIB", "crcERSpanSessionRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcERSpanSessionGroupRev1 = crcERSpanSessionGroupRev1.setStatus('current')
if mibBuilder.loadTexts: crcERSpanSessionGroupRev1.setDescription('A collection of objects providing ERSPAN session information.')
crcSpanEgressReplicationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 19)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcSpanEgressReplicationMode"), ("CISCO-RMON-CONFIG-MIB", "crcSpanEgressReplicationOperMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcSpanEgressReplicationGroup = crcSpanEgressReplicationGroup.setStatus('current')
if mibBuilder.loadTexts: crcSpanEgressReplicationGroup.setDescription('A collection of objects providing SPAN egress packets replication mode information.')
crcSpanCapacityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 20)).setObjects(("CISCO-RMON-CONFIG-MIB", "crcSpanCapacityShared"), ("CISCO-RMON-CONFIG-MIB", "crcSpanMaxSession"), ("CISCO-RMON-CONFIG-MIB", "crcSpanUsedSession"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSharedSource"), ("CISCO-RMON-CONFIG-MIB", "crcSpanSharedDestination"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    crcSpanCapacityGroup = crcSpanCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: crcSpanCapacityGroup.setDescription('A collection of objects providing SPAN capacity information.')
rmonAlarmCapacityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 103, 3, 2, 21)).setObjects(("CISCO-RMON-CONFIG-MIB", "rmonConfiguredAlarms"), ("CISCO-RMON-CONFIG-MIB", "rmonConfiguredHcAlarms"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rmonAlarmCapacityGroup = rmonAlarmCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmCapacityGroup.setDescription('A collection of objects providing additional RMON,HCRMON configurations details about alarms in the alarmTable in RMON-MIB and hcalarms in cHcAlarmTable in HCALARM-MIB')
mibBuilder.exportSymbols("CISCO-RMON-CONFIG-MIB", crcERSpanIFDirection=crcERSpanIFDirection, crcSpanCapacityGroup=crcSpanCapacityGroup, portCopyOption=portCopyOption, ciscoRmonConfigMIB=ciscoRmonConfigMIB, rmonSampleConfigTable=rmonSampleConfigTable, rmonMaxAlarms=rmonMaxAlarms, ciscoRmonConfigComplianceRev5=ciscoRmonConfigComplianceRev5, crcERSpanSessionGroup=crcERSpanSessionGroup, crcERSpanSessionGroupRev1=crcERSpanSessionGroupRev1, SpanTxReplicationMode=SpanTxReplicationMode, crcERSpanIFGroup=crcERSpanIFGroup, portCopySessionNo=portCopySessionNo, portCopyLoVlanMask=portCopyLoVlanMask, crcSpanUsedSession=crcSpanUsedSession, crcERSpanSessionType=crcERSpanSessionType, ciscoRmonConfigComplianceRev7=ciscoRmonConfigComplianceRev7, crcSrcERSpanOrigIp=crcSrcERSpanOrigIp, rmonSampleConfigGroup=rmonSampleConfigGroup, crcSrcERSpanIpTTL=crcSrcERSpanIpTTL, ciscoSampleConfigObjects=ciscoSampleConfigObjects, portCopyInpktVlan=portCopyInpktVlan, crcERSpanEncapID=crcERSpanEncapID, portCopyMaxEgressSessions=portCopyMaxEgressSessions, ciscoRmonConfigObjects=ciscoRmonConfigObjects, crcSpanCapacityType=crcSpanCapacityType, crcSpanSessionGroup=crcSpanSessionGroup, crcERSpanIpType=crcERSpanIpType, crcERSpanSessionRowStatus=crcERSpanSessionRowStatus, crcSpanSessionTable=crcSpanSessionTable, crcSpanDstPermitListEnabled=crcSpanDstPermitListEnabled, crcSrcERSpanLoVlanMask=crcSrcERSpanLoVlanMask, smonExtensionsGroup=smonExtensionsGroup, PYSNMP_MODULE_ID=ciscoRmonConfigMIB, crcSrcERSpanHiVlanMask=crcSrcERSpanHiVlanMask, rmonAlarmConfigGroup=rmonAlarmConfigGroup, portCopySessionType=portCopySessionType, smonExtensions3Group=smonExtensions3Group, smonExtensions9Group=smonExtensions9Group, smonExtensions6Group=smonExtensions6Group, smonExtensions5Group=smonExtensions5Group, ciscoRmonConfigConformance=ciscoRmonConfigConformance, crcSpanDstPermitListTable=crcSpanDstPermitListTable, ciscoAlarmConfigObjects=ciscoAlarmConfigObjects, rmonTimeFilterMode=rmonTimeFilterMode, rmonConfiguredAlarms=rmonConfiguredAlarms, ciscoRmonConfigComplianceRev1=ciscoRmonConfigComplianceRev1, ciscoRmonConfigGroups=ciscoRmonConfigGroups, crcERSpanIFRowStatus=crcERSpanIFRowStatus, smonExtensions2Group=smonExtensions2Group, crcSpanMaxSession=crcSpanMaxSession, ciscoRmonConfigComplianceRev8=ciscoRmonConfigComplianceRev8, smonExtensions4Group=smonExtensions4Group, crcSpanSharedSource=crcSpanSharedSource, crcERSpanIFEntry=crcERSpanIFEntry, crcSpanEgressReplicationOperMode=crcSpanEgressReplicationOperMode, ciscoRmonConfigCompliance=ciscoRmonConfigCompliance, ciscoRmonConfigComplianceRev9=ciscoRmonConfigComplianceRev9, crcSpanSessionEnabled=crcSpanSessionEnabled, portCopyDestHiVlanMask=portCopyDestHiVlanMask, crcSpanCapacityShared=crcSpanCapacityShared, ciscoRmonConfigNotifications=ciscoRmonConfigNotifications, portCopyXTable=portCopyXTable, crcSpanSharedDestination=crcSpanSharedDestination, crcERSpanSessionTable=crcERSpanSessionTable, crcSpanCapacityEntry=crcSpanCapacityEntry, crcERSpanSessionNo=crcERSpanSessionNo, crcSrcERSpanOrigIpType=crcSrcERSpanOrigIpType, ciscoRmonConfigComplianceRev3=ciscoRmonConfigComplianceRev3, ciscoRmonConfigComplianceRev4=ciscoRmonConfigComplianceRev4, crcSpanSessionEntry=crcSpanSessionEntry, crcSpanSessionDescr=crcSpanSessionDescr, crcSpanSessionEgressModeTable=crcSpanSessionEgressModeTable, crcERSpanIFOption=crcERSpanIFOption, crcSrcERSpanDscpOrPrec=crcSrcERSpanDscpOrPrec, portCopyReflectorPort=portCopyReflectorPort, rmon2ExtensionsGroup=rmon2ExtensionsGroup, ciscoSpanCapacityObjects=ciscoSpanCapacityObjects, ciscoSmonConfigObjects=ciscoSmonConfigObjects, crcSpanSessionType=crcSpanSessionType, crcSpanCapacityTable=crcSpanCapacityTable, ciscoRmonConfigCompliances=ciscoRmonConfigCompliances, rmonSamplingEnabled=rmonSamplingEnabled, crcERSpanIFOptionGroup=crcERSpanIFOptionGroup, ciscoRmonConfigComplianceRev6=ciscoRmonConfigComplianceRev6, ciscoRmonConfigComplianceRev2=ciscoRmonConfigComplianceRev2, crcERSpanSessionDescr=crcERSpanSessionDescr, portCopyMaxIngressSessions=portCopyMaxIngressSessions, rmonSampleConfigEntry=rmonSampleConfigEntry, crcERSpanIp=crcERSpanIp, crcERSpanIFTable=crcERSpanIFTable, portCopyRemoveSrc=portCopyRemoveSrc, crcERSpanIFIndex=crcERSpanIFIndex, rmonAlarmCapacityGroup=rmonAlarmCapacityGroup, crcSrcERSpanIpDscp=crcSrcERSpanIpDscp, portCopyDestLoVlanMask=portCopyDestLoVlanMask, crcERSpanIpVRF=crcERSpanIpVRF, crcDstERSpanOption=crcDstERSpanOption, smonExtensions8Group=smonExtensions8Group, crcSpanEgressReplicationGroup=crcSpanEgressReplicationGroup, crcSpanDstPermitListRowStatus=crcSpanDstPermitListRowStatus, crcSpanEgressReplicationMode=crcSpanEgressReplicationMode, crcERSpanSessionEntry=crcERSpanSessionEntry, rmonConfiguredHcAlarms=rmonConfiguredHcAlarms, crcSpanSessionEgressModeEntry=crcSpanSessionEgressModeEntry, ciscoRmonConfigComplianceRev10=ciscoRmonConfigComplianceRev10, ciscoRmon2ConfigObjects=ciscoRmon2ConfigObjects, crcSpanDstPermitListEntry=crcSpanDstPermitListEntry, portCopyXEntry=portCopyXEntry, smonExtensions7Group=smonExtensions7Group, crcSpanSessionNo=crcSpanSessionNo, portCopyHiVlanMask=portCopyHiVlanMask, ciscoSpanTxReplicationObjects=ciscoSpanTxReplicationObjects, crcSpanDstPermitListGroup=crcSpanDstPermitListGroup, crcSrcERSpanIpPrec=crcSrcERSpanIpPrec, rmonAlarmEnable=rmonAlarmEnable)

#
# PySNMP MIB module NBS-SIGLANE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NBS-SIGLANE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:17:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
NbsCmmcChannelBand, = mibBuilder.importSymbols("NBS-CMMCENUM-MIB", "NbsCmmcChannelBand")
NbsTcMHz, nbs, NbsTcTemperature, NbsTcMilliDb, NbsTcMicroAmp = mibBuilder.importSymbols("NBS-MIB", "NbsTcMHz", "nbs", "NbsTcTemperature", "NbsTcMilliDb", "NbsTcMicroAmp")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, TimeTicks, Counter32, Counter64, Integer32, ObjectIdentity, ModuleIdentity, NotificationType, IpAddress, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "TimeTicks", "Counter32", "Counter64", "Integer32", "ObjectIdentity", "ModuleIdentity", "NotificationType", "IpAddress", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
nbsSigLaneMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 629, 236))
if mibBuilder.loadTexts: nbsSigLaneMib.setLastUpdated('201503120000Z')
if mibBuilder.loadTexts: nbsSigLaneMib.setOrganization('NBS')
if mibBuilder.loadTexts: nbsSigLaneMib.setContactInfo('For technical support, please contact your service channel')
if mibBuilder.loadTexts: nbsSigLaneMib.setDescription('Signaling Lane mib - objects for the management of multi-lane ports such as QSFP, CXP, and CFP.')
nbsSigLanePortGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 10))
if mibBuilder.loadTexts: nbsSigLanePortGrp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortGrp.setDescription('Ports which aggregate multiple signaling lanes')
nbsSigLaneLaneGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 20))
if mibBuilder.loadTexts: nbsSigLaneLaneGrp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneGrp.setDescription('Individual signaling lanes within a port')
nbsSigLaneTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 100))
if mibBuilder.loadTexts: nbsSigLaneTraps.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneTraps.setDescription('OBJECT-TYPE macros to be used in SNMP NOTIFICATION macros')
nbsSigLaneTraps0 = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 100, 0))
if mibBuilder.loadTexts: nbsSigLaneTraps0.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneTraps0.setDescription('NOTIFICATION-TYPE macros')
nbsSigLanePortTable = MibTable((1, 3, 6, 1, 4, 1, 629, 236, 10, 1), )
if mibBuilder.loadTexts: nbsSigLanePortTable.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortTable.setDescription('A table that describes signaling lanes for a QSFP[+] or CFP port.')
nbsSigLanePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1), ).setIndexNames((0, "NBS-SIGLANE-MIB", "nbsSigLanePortIfIndex"))
if mibBuilder.loadTexts: nbsSigLanePortEntry.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortEntry.setDescription('Contains a description of a particular port signaling lane.')
nbsSigLanePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortIfIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortIfIndex.setDescription('The index to the MIB-II Interface table entry which represents this port. This value should be 0 if there is no corresponding MIB-II interface entry.')
nbsSigLanePortFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("fiber", 2), ("lambda", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortFacility.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortFacility.setDescription('fiber(2) indicates that lane signaling is conducted on separate fibers. lambda(3) indicates that lane signaling is conducted on different wavelengths on a single SMF fiber.')
nbsSigLanePortLanes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortLanes.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortLanes.setDescription('The number of signaling lanes in this port')
nbsSigLaneLaneTable = MibTable((1, 3, 6, 1, 4, 1, 629, 236, 20, 1), )
if mibBuilder.loadTexts: nbsSigLaneLaneTable.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTable.setDescription('A table that describes (fiber/lambda) network signaling lanes for a multi-lane port.')
nbsSigLaneLaneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1), ).setIndexNames((0, "NBS-SIGLANE-MIB", "nbsSigLaneLaneIfIndex"), (0, "NBS-SIGLANE-MIB", "nbsSigLaneLaneIndex"))
if mibBuilder.loadTexts: nbsSigLaneLaneEntry.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEntry.setDescription('Contains a description of a particular (fiber/lambda) signaling lane.')
nbsSigLaneLaneIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneIfIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneIfIndex.setDescription('The index to the MIB-II Interface table entry which contains this (fiber/lambda) lane.')
nbsSigLaneLaneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneIndex.setDescription('Ordinal index for the signaling lane in a port: 1..4 for QSFP[+] 4 x 10G 1..4 for CFP 4 x 25G 1..4 for CFP 4 x 28G 1..10 for CFP 10 x 10G')
nbsSigLaneLaneFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 10), NbsTcMHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneFrequency.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneFrequency.setDescription('The nominal frequency, in MHz.')
nbsSigLaneLaneWavelengthX = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneWavelengthX.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneWavelengthX.setDescription("The nominal wavelength (nanometers) is an ASCII string to be human-readable. CWDM wavelengths use 4 digits. DWDM wavelengths use seven digits and a decimal point. Not supported value: 'N/A'")
nbsSigLaneLaneChannelBand = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 12), NbsCmmcChannelBand()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneChannelBand.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneChannelBand.setDescription("The ITU grid labels DWDM channels with a letter 'band' and a numeric channel. Within this mib, the band is indicated by this object, and the channel number is shown in the object nbsOsaChannelNumber. Frequencies of at least 180100 GHz but less than 190100 GHz are considered the L spectrum, and frequencies of at least 190100 but less than 200100 GHz are considered the C spectrum. Frequencies evenly divisible by 100 GHz are designated with a 'C' or 'L' prepended to the channel number. Frequencies that are offset by 50 GHz are designated 'H' within the C spectrum, and 'Q' within the L spectrum.")
nbsSigLaneLaneChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneChannelNumber.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneChannelNumber.setDescription('The channel number can be derived by extracting the two middle digits from the six digit frequency in GHz.')
nbsSigLaneLaneTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerLevel.setDescription("This object indicates the status of this lane's measured received power, reported in nbsSigLaneLaneTxPower: notSupported(1), if (nbsSigLaneLaneTxPower = 0x80000000); lowAlarm(2), if nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerVendorMin; lowWarning(3), if nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerVendorMin and nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerUserMin; ok(4), if nbsSigLaneLaneTxPower is within thresholds; highWarning(5), if nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerVendorMax and nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerUserMax; highAlarm(6), if nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerVendorMax")
nbsSigLaneLaneTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 21), NbsTcMilliDb().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneTxPower.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxPower.setDescription('The output power (in milli dBm) of this lane. Not supported value: 0x80000000')
nbsSigLaneLaneRxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneRxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneRxPowerLevel.setDescription("This object indicates the status of this lane's measured received power, reported in nbsSigLaneLaneRxPower: notSupported(1), if (nbsSigLaneLaneRxPower = 0x80000000); lowAlarm(2), if nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerVendorMin; lowWarning(3), if nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerVendorMin and nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerUserMin; ok(4), if nbsSigLaneLaneRxPower is within thresholds; highWarning(5), if nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerVendorMax and nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerUserMax; highAlarm(6), if nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerVendorMax")
nbsSigLaneLaneRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 31), NbsTcMilliDb().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneRxPower.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneRxPower.setDescription('The received optical power (in milli dBm) of this lane. Not supported value: 0x80000000')
nbsSigLaneLaneBiasAmpsLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmpsLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmpsLevel.setDescription('This object indicates the status of laser bias current, as reported in nbsSigLaneLaneBiasAmps: notSupported(1), if (nbsSigLaneLaneBiasAmps = -1); lowAlarm(2), if below nbsSigLanePortBiasAmpsVendorMin; ok(4), if within the recommended operating range; highAlarm(6), if above nbsSigLanePortBiasAmpsVendorMax.')
nbsSigLaneLaneBiasAmps = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 41), NbsTcMicroAmp().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmps.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmps.setDescription('The bias current (in microAmps) of this lane. Not supported value: -1')
nbsSigLaneLaneLaserTempLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTempLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTempLevel.setDescription('This object indicates the status of laser temperature, as reported in nbsSigLaneLaneLaserTemp: notSupported(1), if (nbsSigLaneLaneLaserTemp = 0x80000000); lowAlarm(2), if below nbsSigLanePortLaserTempVendorMin; ok(4), if within the recommended operating range; highAlarm(6), if above nbsSigLanePortLaserTempVendorMax.')
nbsSigLaneLaneLaserTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 51), NbsTcTemperature().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTemp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTemp.setDescription('The temperature (in degrees Celsius) of this lane. Not supported value: 0x80000000')
mibBuilder.exportSymbols("NBS-SIGLANE-MIB", nbsSigLaneLaneEntry=nbsSigLaneLaneEntry, nbsSigLaneLaneChannelBand=nbsSigLaneLaneChannelBand, nbsSigLanePortEntry=nbsSigLanePortEntry, PYSNMP_MODULE_ID=nbsSigLaneMib, nbsSigLaneLaneIndex=nbsSigLaneLaneIndex, nbsSigLanePortGrp=nbsSigLanePortGrp, nbsSigLaneLaneBiasAmpsLevel=nbsSigLaneLaneBiasAmpsLevel, nbsSigLaneLaneChannelNumber=nbsSigLaneLaneChannelNumber, nbsSigLaneTraps0=nbsSigLaneTraps0, nbsSigLaneLaneTxPowerLevel=nbsSigLaneLaneTxPowerLevel, nbsSigLanePortLanes=nbsSigLanePortLanes, nbsSigLaneLaneRxPower=nbsSigLaneLaneRxPower, nbsSigLaneLaneTable=nbsSigLaneLaneTable, nbsSigLaneLaneIfIndex=nbsSigLaneLaneIfIndex, nbsSigLanePortIfIndex=nbsSigLanePortIfIndex, nbsSigLaneLaneFrequency=nbsSigLaneLaneFrequency, nbsSigLaneLaneLaserTempLevel=nbsSigLaneLaneLaserTempLevel, nbsSigLaneMib=nbsSigLaneMib, nbsSigLaneLaneRxPowerLevel=nbsSigLaneLaneRxPowerLevel, nbsSigLaneLaneGrp=nbsSigLaneLaneGrp, nbsSigLaneTraps=nbsSigLaneTraps, nbsSigLanePortTable=nbsSigLanePortTable, nbsSigLaneLaneTxPower=nbsSigLaneLaneTxPower, nbsSigLaneLaneBiasAmps=nbsSigLaneLaneBiasAmps, nbsSigLanePortFacility=nbsSigLanePortFacility, nbsSigLaneLaneWavelengthX=nbsSigLaneLaneWavelengthX, nbsSigLaneLaneLaserTemp=nbsSigLaneLaneLaserTemp)

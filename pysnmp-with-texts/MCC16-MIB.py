#
# PySNMP MIB module MCC16-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MCC16-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:11:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Gauge32, enterprises, ObjectIdentity, NotificationType, Bits, NotificationType, TimeTicks, Unsigned32, iso, Counter32, Integer32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Gauge32", "enterprises", "ObjectIdentity", "NotificationType", "Bits", "NotificationType", "TimeTicks", "Unsigned32", "iso", "Counter32", "Integer32", "Counter64")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class CpsConnector(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))
    namedValues = NamedValues(("rj-45", 10), ("stmm", 11), ("stsm", 12), ("scmm", 13), ("scsm", 14), ("scsmlh", 15), ("scsmelh", 16), ("scsmlhlw", 17), ("mtrjmm", 18), ("lc", 19), ("bnc", 20), ("stsmlh", 21), ("stsmelh", 22), ("scmm1300", 23), ("stmm1300", 24), ("mtrjsm", 25), ("serial26", 26), ("stmmlh", 27), ("scsmsh", 28), ("scsimplex", 29), ("bncdual", 30), ("db9rsxxx", 31), ("termblock", 32), ("rj11", 33), ("sc40km", 34), ("sc125km", 35))

transition = MibIdentifier((1, 3, 6, 1, 4, 1, 868))
productId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1))
chassisProdsId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4))
chassisSlotTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1))
chSlMc20p = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1))
chSlcps = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2))
chassisMcc16Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 2))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2))
ceTbtFrl03Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 1))
ceCxTbt04Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 2))
ceCxFrl04Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 3))
cfSmMm02Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 4))
cfSmMm05Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 5))
caCf02Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 6))
cfSmMm06Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 7))
ct1e1Cf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 8))
ceRTxFx01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 9))
ce100BtxFx04Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 10))
cpsCf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 12))
cbCf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 13))
carCf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 14))
carCf02Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 15))
cePswFx03Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 16))
cePswSx01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 17))
cRs232Cf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 18))
cfSmMm04Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 24))
ce100BtxSx01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 26))
ce100BtxFx04MtId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 27))
cfdCd01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 28))
ctrCf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 29))
ce100BtxFrl03Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 30))
mc20pEmptyId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 31))
mc20pErrorId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 32))
mc20pDblWideId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 33))
chstrCf01Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 34))
ceTxSx02Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 35))
ceTbtFrl04Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 1, 36))
cpsmM100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1))
cpsmM200Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 2))
cettf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 3))
cfetf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 4))
cfmff100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 5))
cpsmp100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 6))
csetf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 7))
cgetf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 8))
csdtf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 9))
cpsmp110Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 10))
cbftf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 11))
cetct100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 12))
ccscf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 13))
cfetf105Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 14))
smacf100PId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 15))
cpsld100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 16))
cdftf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 17))
cpsvt100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 18))
cemtf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 19))
captf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 20))
cfetf205Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 21))
cbftf150Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 22))
cgfeb100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 23))
crmfe100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 24))
crs2f100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 25))
crs4f100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 26))
cmefg100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 27))
cpsEmptyId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1001))
cpsDblWideId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1002))
cpsUnknownDeviceId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1003))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4))
card = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 1))
slotMc20p = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1))
slotCps = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2))
backplane = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2))
mcc16 = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1))
mcc16Common = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1))
mcc16Ver1 = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 2))
cps = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2))
cpsSlotSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1))
cpsSlotDetail = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2))
chassisCpsmc1800Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 3))
chassisCpsmc1850Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 4))
chassisCpsmc0800Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 5))
chassisCpsmc1300Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 6))
chassisCpsmc0200Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 7))
chassisSmacf100LCId = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 8))
chassisCpsmc1900Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 9))
chassisSmacf100Id = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 1, 4, 10))
cpsCabSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1))
cpsCabDetail = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2))
cpsAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3))
ceTbtFrl03Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1), )
if mibBuilder.loadTexts: ceTbtFrl03Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-TBT-FRL-03 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceTbtFrl03Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1), ).setIndexNames((0, "MCC16-MIB", "ceTbtFrl03Index"))
if mibBuilder.loadTexts: ceTbtFrl03Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03Entry.setDescription('State of LEDs on a single C/E-TBT-FRL-03')
ceTbtFrl03Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03Index.setDescription('The index of a slot in a media converter chassis')
ceTbtFrl03FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ceTbtFrl03FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03FiberLink.setDescription("The state of the converter's Fiber Link LED")
ceTbtFrl03TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
ceTbtFrl03TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03TPLink.setDescription("The state of the converter's Twisted Pair Link LED")
ceTbtFrl03Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl03Power.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl03Power.setDescription("The state of the converter's Power LED")
ceCxTbt04Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2), )
if mibBuilder.loadTexts: ceCxTbt04Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-CX-TBT-04 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceCxTbt04Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1), ).setIndexNames((0, "MCC16-MIB", "ceCxTbt04Index"))
if mibBuilder.loadTexts: ceCxTbt04Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04Entry.setDescription('State of LEDs on a single C/E-CX-TBT-04')
ceCxTbt04Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04Index.setDescription('The index of a slot in a media converter chassis')
ceCxTbt04Jabber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04Jabber.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04Jabber.setDescription("The state of the converter's Jabber LED")
ceCxTbt04CoaxRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04CoaxRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04CoaxRecv.setDescription("The state of the converter's CoaxRecv LED")
ceCxTbt04TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04TPRecv.setDescription("The state of the converter's TPRecv LED")
ceCxTbt04TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04TPLink.setDescription("The state of the converter's TPLink LED")
ceCxTbt04Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxTbt04Power.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxTbt04Power.setDescription("The state of the converter's Power LED")
ceCxFrl04Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3), )
if mibBuilder.loadTexts: ceCxFrl04Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-CX-FRL-04 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceCxFrl04Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1), ).setIndexNames((0, "MCC16-MIB", "ceCxFrl04Index"))
if mibBuilder.loadTexts: ceCxFrl04Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04Entry.setDescription('State of LEDs on a single C/E-CX-FRL-04')
ceCxFrl04Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04Index.setDescription('The index of a slot in a media converter chassis')
ceCxFrl04Jabber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04Jabber.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04Jabber.setDescription("The state of the converter's Jabber LED")
ceCxFrl04CoaxRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04CoaxRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04CoaxRecv.setDescription("The state of the converter's CoaxRecv LED")
ceCxFrl04FLRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04FLRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04FLRecv.setDescription("The state of the converter's FLRecv LED")
ceCxFrl04FLLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04FLLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04FLLink.setDescription("The state of the converter's FLLink LED")
ceCxFrl04Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceCxFrl04Power.setStatus('mandatory')
if mibBuilder.loadTexts: ceCxFrl04Power.setDescription("The state of the converter's Power LED")
cfSmMm02Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4), )
if mibBuilder.loadTexts: cfSmMm02Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/F-SM-MM-02 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cfSmMm02Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4, 1), ).setIndexNames((0, "MCC16-MIB", "cfSmMm02Index"))
if mibBuilder.loadTexts: cfSmMm02Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02Entry.setDescription('State of LEDs on a single C/F-SM-MM-02')
cfSmMm02Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm02Index.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02Index.setDescription('The index of a slot in a media converter chassis')
cfSmMm02MMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm02MMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02MMSignalDetect.setDescription("The state of the converter's MMSignalDetect LED")
cfSmMm02SMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm02SMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02SMSignalDetect.setDescription("The state of the converter's SMSignalDetect LED")
cfSmMm02Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm02Power.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm02Power.setDescription("The state of the converter's Power LED")
cfSmMm05Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5), )
if mibBuilder.loadTexts: cfSmMm05Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/F-SM-MM-05 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cfSmMm05Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5, 1), ).setIndexNames((0, "MCC16-MIB", "cfSmMm05Index"))
if mibBuilder.loadTexts: cfSmMm05Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05Entry.setDescription('State of LEDs on a single C/F-SM-MM-05')
cfSmMm05Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm05Index.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05Index.setDescription('The index of a slot in a media converter chassis')
cfSmMm05SMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm05SMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05SMSignalDetect.setDescription("The state of the converter's SMSignalDetect LED")
cfSmMm05MMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm05MMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05MMSignalDetect.setDescription("The state of the converter's MMSignalDetect LED")
cfSmMm05Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm05Power.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm05Power.setDescription("The state of the converter's Power LED")
caCf02Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6), )
if mibBuilder.loadTexts: caCf02Table.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/A-CF-02 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
caCf02Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6, 1), ).setIndexNames((0, "MCC16-MIB", "caCf02Index"))
if mibBuilder.loadTexts: caCf02Entry.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02Entry.setDescription('State of LEDs on a single C/A-CF-02')
caCf02Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: caCf02Index.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02Index.setDescription('The index of a slot in a media converter chassis')
caCf02CopperSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: caCf02CopperSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02CopperSignalDetect.setDescription("The state of the converter's CopperSignalDetect LED")
caCf02FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: caCf02FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02FiberSignalDetect.setDescription("The state of the converter's FiberSignalDetect LED")
caCf02Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: caCf02Power.setStatus('mandatory')
if mibBuilder.loadTexts: caCf02Power.setDescription("The state of the converter's Power LED")
cfSmMm06Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7), )
if mibBuilder.loadTexts: cfSmMm06Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/F-SM-MM-06 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cfSmMm06Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7, 1), ).setIndexNames((0, "MCC16-MIB", "cfSmMm06Index"))
if mibBuilder.loadTexts: cfSmMm06Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06Entry.setDescription('State of LEDs on a single C/F-SM-MM-06')
cfSmMm06Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm06Index.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06Index.setDescription('The index of a slot in a media converter chassis')
cfSmMm06MMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm06MMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06MMSignalDetect.setDescription("The state of the converter's MMSignalDetect LED")
cfSmMm06SMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm06SMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06SMSignalDetect.setDescription("The state of the converter's SMSignalDetect LED")
cfSmMm06Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm06Power.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm06Power.setDescription("The state of the converter's Power LED")
ct1e1Cf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8), )
if mibBuilder.loadTexts: ct1e1Cf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/T1E1-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ct1e1Cf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8, 1), ).setIndexNames((0, "MCC16-MIB", "ct1e1Cf01Index"))
if mibBuilder.loadTexts: ct1e1Cf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01Entry.setDescription('State of LEDs on a single C/T1E1-CF-01')
ct1e1Cf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ct1e1Cf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01Index.setDescription('The index of a slot in a media converter chassis')
ct1e1Cf01CopperSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ct1e1Cf01CopperSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01CopperSignalDetect.setDescription("The state of the converter's CopperSignalDetect LED")
ct1e1Cf01FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ct1e1Cf01FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01FiberSignalDetect.setDescription("The state of the converter's FiberSignalDetect LED")
ct1e1Cf01CoaxActive = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ct1e1Cf01CoaxActive.setStatus('mandatory')
if mibBuilder.loadTexts: ct1e1Cf01CoaxActive.setDescription("The state of the converter's Coax Active LED")
ceRTxFx01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9), )
if mibBuilder.loadTexts: ceRTxFx01Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-R-TX-FX-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceRTxFx01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1), ).setIndexNames((0, "MCC16-MIB", "ceRTxFx01Index"))
if mibBuilder.loadTexts: ceRTxFx01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01Entry.setDescription('State of LEDs on a single C/E-R-TX-FX-01')
ceRTxFx01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceRTxFx01Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01Index.setDescription('The index of a slot in a media converter chassis')
ceRTxFx01TPPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceRTxFx01TPPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01TPPrimary.setDescription("The state of the converter's Twisted Pair Primary LED")
ceRTxFx01FiberPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceRTxFx01FiberPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01FiberPrimary.setDescription("The state of the converter's Fiber Primary LED")
ceRTxFx01TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceRTxFx01TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01TPSignalDetect.setDescription("The state of the converter's Twisted Pair Signal Detect LED")
ceRTxFx01FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceRTxFx01FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ceRTxFx01FiberSignalDetect.setDescription("The state of the converter's Fiber Signal Detect LED")
ce100BtxFx04Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10), )
if mibBuilder.loadTexts: ce100BtxFx04Table.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-100-BTX-FX-04(ST/SC) media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ce100BtxFx04Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1), ).setIndexNames((0, "MCC16-MIB", "ce100BtxFx04Index"))
if mibBuilder.loadTexts: ce100BtxFx04Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04Entry.setDescription('State of LEDs on a single C/E-100-BTX-FX-04(ST/SC)')
ce100BtxFx04Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04Index.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04Index.setDescription('The index of a slot in a media converter chassis')
ce100BtxFx04TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
ce100BtxFx04FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ce100BtxFx04TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04TPSignalDetect.setDescription("The state of the converter's Twisted Pair signal detect LED")
ce100BtxFx04FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04FiberSignalDetect.setDescription("The state of the converter's fiber signal detect LED")
ce100BtxFx04Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04Power.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04Power.setDescription("The state of the converter's Power LED")
cpsCf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12), )
if mibBuilder.loadTexts: cpsCf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/PS-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cpsCf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12, 1), ).setIndexNames((0, "MCC16-MIB", "cpsCf01Index"))
if mibBuilder.loadTexts: cpsCf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01Entry.setDescription('State of LEDs on a single C/PS-CF-01')
cpsCf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01Index.setDescription('The index of a slot in a media converter chassis')
cpsCf01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCf01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
cpsCf01TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCf01TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
cpsCf01Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCf01Power.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCf01Power.setDescription("The state of the converter's Power LED")
cbCf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13), )
if mibBuilder.loadTexts: cbCf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/B-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cbCf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13, 1), ).setIndexNames((0, "MCC16-MIB", "cbCf01Index"))
if mibBuilder.loadTexts: cbCf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01Entry.setDescription('State of LEDs on a single C/B-CF-01')
cbCf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbCf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01Index.setDescription('The index of a slot in a media converter chassis')
cbCf01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbCf01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
cbCf01TPCoaxRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbCf01TPCoaxRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01TPCoaxRecv.setDescription("The state of the converter's Twisted Pair/Coax Receive LED")
cbCf01Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbCf01Power.setStatus('mandatory')
if mibBuilder.loadTexts: cbCf01Power.setDescription("The state of the converter's Power LED")
carCf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14), )
if mibBuilder.loadTexts: carCf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/AR-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
carCf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14, 1), ).setIndexNames((0, "MCC16-MIB", "carCf01Index"))
if mibBuilder.loadTexts: carCf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01Entry.setDescription('State of LEDs on a single C/AR-CF-01')
carCf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01Index.setDescription('The index of a slot in a media converter chassis')
carCf01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
carCf01TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf01TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
carCf01Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf01Power.setStatus('mandatory')
if mibBuilder.loadTexts: carCf01Power.setDescription("The state of the converter's Power LED")
carCf02Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15), )
if mibBuilder.loadTexts: carCf02Table.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/AR-CF-02 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
carCf02Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15, 1), ).setIndexNames((0, "MCC16-MIB", "carCf02Index"))
if mibBuilder.loadTexts: carCf02Entry.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02Entry.setDescription('State of LEDs on a single C/AR-CF-02')
carCf02Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf02Index.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02Index.setDescription('The index of a slot in a media converter chassis')
carCf02FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf02FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
carCf02CoaxRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf02CoaxRecv.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02CoaxRecv.setDescription("The state of the converter's Coax Receive LED")
carCf02Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: carCf02Power.setStatus('mandatory')
if mibBuilder.loadTexts: carCf02Power.setDescription("The state of the converter's Power LED")
cePswFx03Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16), )
if mibBuilder.loadTexts: cePswFx03Table.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-PSW-FX-03 ethernet switch, then entry 'n' in this table exists and describes the state of the switch's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cePswFx03Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1), ).setIndexNames((0, "MCC16-MIB", "cePswFx03Index"))
if mibBuilder.loadTexts: cePswFx03Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03Entry.setDescription('State of LEDs on a single C/E-PSW-FX-03')
cePswFx03Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03Index.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03Index.setDescription('The index of a slot in a media converter chassis')
cePswFx03TPFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03TPFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03TPFullDuplex.setDescription("The state of the converter's Twisted Pair FDX LED")
cePswFx03FiberFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03FiberFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03FiberFullDuplex.setDescription("The state of the converter's Fiber FDX LED")
cePswFx03TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03TPLink.setDescription("The state of the converter's Twisted Pair Link LED")
cePswFx03FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03FiberLink.setDescription("The state of the converter's Fiber Link LED")
cePswFx03TP100Mbps = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswFx03TP100Mbps.setStatus('mandatory')
if mibBuilder.loadTexts: cePswFx03TP100Mbps.setDescription("The state of the converter's Twisted Pair 100Mbps LED")
cePswSx01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17), )
if mibBuilder.loadTexts: cePswSx01Table.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-PSW-SX-01 ethernet switch, then entry 'n' in this table exists and describes the state of the switch's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cePswSx01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1), ).setIndexNames((0, "MCC16-MIB", "cePswSx01Index"))
if mibBuilder.loadTexts: cePswSx01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01Entry.setDescription('State of LEDs on a single C/E-PSW-SX-01')
cePswSx01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01Index.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01Index.setDescription('The index of a slot in a media converter chassis')
cePswSx01TPFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01TPFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01TPFullDuplex.setDescription("The state of the converter's Twisted Pair FDX LED")
cePswSx01FiberFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01FiberFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01FiberFullDuplex.setDescription("The state of the converter's Fiber FDX LED")
cePswSx01TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01TPLink.setDescription("The state of the converter's Twisted Pair Link LED")
cePswSx01FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01FiberLink.setDescription("The state of the converter's Fiber Link LED")
cePswSx01TP100Mbps = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cePswSx01TP100Mbps.setStatus('mandatory')
if mibBuilder.loadTexts: cePswSx01TP100Mbps.setDescription("The state of the converter's Twisted Pair 100Mbps LED")
cRs232Cf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 18), )
if mibBuilder.loadTexts: cRs232Cf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: cRs232Cf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/RS232-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cRs232Cf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 18, 1), ).setIndexNames((0, "MCC16-MIB", "cRs232Cf01Index"))
if mibBuilder.loadTexts: cRs232Cf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cRs232Cf01Entry.setDescription('State of LEDs on a single C/RS232-CF-01')
cRs232Cf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRs232Cf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: cRs232Cf01Index.setDescription('The index of a slot in a media converter chassis')
cRs232Cf01FiberLock = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRs232Cf01FiberLock.setStatus('mandatory')
if mibBuilder.loadTexts: cRs232Cf01FiberLock.setDescription("The state of the converter's Fiber Lock LED")
cfSmMm04Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24), )
if mibBuilder.loadTexts: cfSmMm04Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/F-SM-MM-04 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cfSmMm04Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24, 1), ).setIndexNames((0, "MCC16-MIB", "cfSmMm04Index"))
if mibBuilder.loadTexts: cfSmMm04Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04Entry.setDescription('State of LEDs on a single C/F-SM-MM-04')
cfSmMm04Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm04Index.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04Index.setDescription('The index of a slot in a media converter chassis')
cfSmMm04MMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm04MMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04MMSignalDetect.setDescription("The state of the converter's Multi-Mode signal detect LED")
cfSmMm04SMSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm04SMSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04SMSignalDetect.setDescription("The state of the converter's Single-Mode signal detect LED")
cfSmMm04Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 24, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSmMm04Power.setStatus('mandatory')
if mibBuilder.loadTexts: cfSmMm04Power.setDescription("The state of the converter's Power LED")
ce100BtxSx01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26), )
if mibBuilder.loadTexts: ce100BtxSx01Table.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-100-BTX-SX-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ce100BtxSx01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1), ).setIndexNames((0, "MCC16-MIB", "ce100BtxSx01Index"))
if mibBuilder.loadTexts: ce100BtxSx01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01Entry.setDescription('State of LEDs on a single C/E-100-BTX-SX-01')
ce100BtxSx01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01Index.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01Index.setDescription('The index of a slot in a media converter chassis')
ce100BtxSx01TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
ce100BtxSx01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ce100BtxSx01TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01TPSignalDetect.setDescription("The state of the converter's Twisted Pair signal detect LED")
ce100BtxSx01FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01FiberSignalDetect.setDescription("The state of the converter's fiber signal detect LED")
ce100BtxSx01Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 26, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxSx01Power.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxSx01Power.setDescription("The state of the converter's Power LED")
ce100BtxFx04MtTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27), )
if mibBuilder.loadTexts: ce100BtxFx04MtTable.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtTable.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-100-BTX-FX-04(MT) media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ce100BtxFx04MtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1), ).setIndexNames((0, "MCC16-MIB", "ce100BtxFx04MtIndex"))
if mibBuilder.loadTexts: ce100BtxFx04MtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtEntry.setDescription('State of LEDs on a single C/E-100-BTX-FX-04(MT)')
ce100BtxFx04MtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtIndex.setDescription('The index of a slot in a media converter chassis')
ce100BtxFx04MtTPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtTPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtTPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
ce100BtxFx04MtFiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtFiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtFiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ce100BtxFx04MtTPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtTPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtTPSignalDetect.setDescription("The state of the converter's Twisted Pair signal detect LED")
ce100BtxFx04MtFiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtFiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtFiberSignalDetect.setDescription("The state of the converter's fiber signal detect LED")
ce100BtxFx04MtPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 27, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFx04MtPower.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFx04MtPower.setDescription("The state of the converter's Power LED")
cfdCd01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28), )
if mibBuilder.loadTexts: cfdCd01Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/FD-CD-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
cfdCd01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1), ).setIndexNames((0, "MCC16-MIB", "cfdCd01Index"))
if mibBuilder.loadTexts: cfdCd01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01Entry.setDescription('State of LEDs on a single C/FD-CD-01')
cfdCd01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01Index.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01Index.setDescription('The index of a slot in a media converter chassis')
cfdCd01Lock = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01Lock.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01Lock.setDescription("The state of the converter's Lock LED")
cfdCd01TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01TPRecv.setDescription("The state of the converter's TPRecv LED")
cfdCd01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01FiberRecv.setDescription("The state of the converter's FiberRecv LED")
cfdCd01TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01TPSignalDetect.setDescription("The state of the converter's TPSignalDetect LED")
cfdCd01FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 28, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfdCd01FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: cfdCd01FiberSignalDetect.setDescription("The state of the converter's FiberSignalDetect LED")
ctrCf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29), )
if mibBuilder.loadTexts: ctrCf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/TR-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ctrCf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29, 1), ).setIndexNames((0, "MCC16-MIB", "ctrCf01Index"))
if mibBuilder.loadTexts: ctrCf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01Entry.setDescription('State of LEDs on a single C/TR-CF-01')
ctrCf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctrCf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01Index.setDescription('The index of a slot in a media converter chassis')
ctrCf01FiberinOK = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctrCf01FiberinOK.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01FiberinOK.setDescription("The state of the converter's FiberinOK LED")
ctrCf01TPinOK = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctrCf01TPinOK.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01TPinOK.setDescription("The state of the converter's TPinOK LED")
ctrCf01Inserted = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 29, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctrCf01Inserted.setStatus('mandatory')
if mibBuilder.loadTexts: ctrCf01Inserted.setDescription("The state of the converter's Inserted LED")
ce100BtxFrl03Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30), )
if mibBuilder.loadTexts: ce100BtxFrl03Table.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-100BTX-FRL-03 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ce100BtxFrl03Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1), ).setIndexNames((0, "MCC16-MIB", "ce100BtxFrl03Index"))
if mibBuilder.loadTexts: ce100BtxFrl03Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03Entry.setDescription('State of LEDs on a single C/E-100BTX-FRL-03')
ce100BtxFrl03Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03Index.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03Index.setDescription('The index of a slot in a media converter chassis')
ce100BtxFrl03Lock = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03Lock.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03Lock.setDescription("The state of the converter's signal lock pin")
ce100BtxFrl03TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03TPRecv.setDescription("The state of the converter's Twisted pair receive LED")
ce100BtxFrl03FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ce100BtxFrl03TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03TPSignalDetect.setDescription("The state of the converter's Twisted pair signal detect LED")
ce100BtxFrl03FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 30, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ce100BtxFrl03FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ce100BtxFrl03FiberSignalDetect.setDescription("The state of the converter's Fiber signal detect LED")
chstrCf01Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34), )
if mibBuilder.loadTexts: chstrCf01Table.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/HSTR-CF-01 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
chstrCf01Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1), ).setIndexNames((0, "MCC16-MIB", "chstrCf01Index"))
if mibBuilder.loadTexts: chstrCf01Entry.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01Entry.setDescription('State of LEDs on a single C/HSTR-CF-01')
chstrCf01Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chstrCf01Index.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01Index.setDescription('The index of a slot in a media converter chassis')
chstrCf01TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chstrCf01TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
chstrCf01FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chstrCf01FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
chstrCf01TPSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chstrCf01TPSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01TPSignalDetect.setDescription("The state of the converter's Twisted Pair signal detect LED")
chstrCf01FiberSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 34, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chstrCf01FiberSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: chstrCf01FiberSignalDetect.setDescription("The state of the converter's fiber signal detect LED")
ceTxSx02Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35), )
if mibBuilder.loadTexts: ceTxSx02Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-TX-SX-02 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceTxSx02Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35, 1), ).setIndexNames((0, "MCC16-MIB", "ceTxSx02Index"))
if mibBuilder.loadTexts: ceTxSx02Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02Entry.setDescription('State of LEDs on a single C/E-TX-SX-02')
ceTxSx02Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTxSx02Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02Index.setDescription('The index of a slot in a media converter chassis')
ceTxSx02TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTxSx02TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02TPLink.setDescription("The state of the converter's Twisted Pair Link LED")
ceTxSx02FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTxSx02FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02FiberLink.setDescription("The state of the converter's Fiber Link LED")
ceTxSx02100Mbps = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 35, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTxSx02100Mbps.setStatus('mandatory')
if mibBuilder.loadTexts: ceTxSx02100Mbps.setDescription("The state of the converter's 100 Megabit Per Second LED")
ceTbtFrl04Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36), )
if mibBuilder.loadTexts: ceTbtFrl04Table.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04Table.setDescription("One table entry per slot in the media converter chassis. If physical slot 'n' contains a working C/E-TBT-FRL-04 media converter, then entry 'n' in this table exists and describes the state of the converter's LEDs If slot 'n' is empty, does not exist, or contains a different type of device, then table entry 'n' does not exist.")
ceTbtFrl04Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1), ).setIndexNames((0, "MCC16-MIB", "ceTbtFrl04Index"))
if mibBuilder.loadTexts: ceTbtFrl04Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04Entry.setDescription('State of LEDs on a single C/E-TBT-FRL-04')
ceTbtFrl04Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl04Index.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04Index.setDescription('The index of a slot in a media converter chassis')
ceTbtFrl04FiberRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl04FiberRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04FiberRecv.setDescription("The state of the converter's Fiber Receive LED")
ceTbtFrl04FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl04FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04FiberLink.setDescription("The state of the converter's Fiber Link LED")
ceTbtFrl04TPRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl04TPRecv.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04TPRecv.setDescription("The state of the converter's Twisted Pair Receive LED")
ceTbtFrl04TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 1, 36, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceTbtFrl04TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: ceTbtFrl04TPLink.setDescription("The state of the converter's Twisted Pair Link LED")
cpsModuleTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1, 1), )
if mibBuilder.loadTexts: cpsModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpsModuleTable.setDescription('A table from which one can extract the model number of any device in the stack, given the serial number (BIA) of the cabinet and the slot number in which the device is installed.')
cpsModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1, 1, 1), ).setIndexNames((0, "MCC16-MIB", "cpsModuleBiaIndex"), (0, "MCC16-MIB", "cpsModuleSlotIndex"))
if mibBuilder.loadTexts: cpsModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsModuleEntry.setDescription('The model number entry for a single device.')
cpsModuleBiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsModuleBiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsModuleBiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsModuleSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsModuleSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsModuleSlotIndex.setDescription('The slot in which the device is installed')
cpsModuleModel = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 1, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsModuleModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpsModuleModel.setDescription('The model number of the device. See OIDs under chSlcps')
cpsmm100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1), )
if mibBuilder.loadTexts: cpsmm100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100Table.setDescription('Sparse table containing one entry for each CPSMM100-200 and other CPSMM100-xxx Point System Base Management Module in the stack, indexed by cabinet serial number and slot.')
cpsmm100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1), ).setIndexNames((0, "MCC16-MIB", "cpsmm100BiaIndex"), (0, "MCC16-MIB", "cpsmm100SlotIndex"))
if mibBuilder.loadTexts: cpsmm100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100Entry.setDescription('Status and configuration entries for a single CPSMM100')
cpsmm100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsmm100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SlotIndex.setDescription('The slot in which the device is installed')
cpsmm100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CPSMM100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cpsmm100Reset = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("noReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100Reset.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100Reset.setDescription('Set this to reset(1) to cause the CPSMM100 to reboot.')
cpsmm100SaveConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saveConfig", 1), ("noSaveConfig", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SaveConfig.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SaveConfig.setDescription('Set this to saveConfig(1) to force configuration changes made since the last saveConfig to be copied from RAM to flash memory. If changes are made to the configuration of a CPSMM100 and SaveConfig is not subsequently set to 1, the changes will be made only in RAM and the device will revert to its previous configuration at the next reboot. After the save completes, SaveConfig automatically reverts to noSaveConfig(2).')
cpsmm100HwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100HwRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100HwRevision.setDescription('The hardware revision of this device')
cpsmm100SwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100SwRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SwRevision.setDescription('The revision of the agent firmware for this device.')
cpsmm100IPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100IPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100IPAddress.setDescription('The IP Address of the Ethernet interface of this device')
cpsmm100SubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SubnetMask.setDescription('The subnet mask used by the Ethernet interface of this device')
cpsmm100Gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100Gateway.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100Gateway.setDescription('The IP gateway used by the Ethernet interface of this device')
cpsmm100IsPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100IsPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100IsPrimary.setDescription('In a given Point System stack, multiple base management modules can be installed, but only one can be the Primary. The Primary is responsible for scanning the stack for modules, collecting status information and distributing new configuration settings. The Primary management module is therefore the only one that can accept an SNMP SET PDU. Compare this variable with cpsIsPrimary.0')
cpsmm100WantPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("always", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100WantPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100WantPrimary.setDescription('Normally, the Management Module installed in the cabinet with the lowest serial number (BIA) in the lowest (leftmost) slot that has fully established network connectivity will be selected as the Primary. Setting WantPrimary to yes(1) causes this device to be preferred over all devices with a WantPrimary value of no(2) during these Primary/Standby negotiations. If more than one device is configured with the value yes(1), these modules negotiate amongst themselves using the default rule above. Setting WantPrimary to always(3) causes the module to ignore the results of the negotiations and immediately and persistently assert primary status. Use of always(3) is not recommended except on advice of Transition Networks technical support, since it may cause your system to behave unpredictably. Setting more than one module in a stack to always(3) will cause erratic behavior.')
cpsmm100CanPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100CanPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100CanPrimary.setDescription('Value is yes(1) if this device is eligible to become the Primary Management Module. Currently, lack of IP/Ethernet connectivity is the only reason that a module can be ineligible.')
cpsmm100EthernetLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100EthernetLink.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100EthernetLink.setDescription('Does the management interface of this management module have ethernet link?')
cpsmm100TntRIP = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100TntRIP.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100TntRIP.setDescription("This feature in obsolete as of 08/17/2001. Telnet 'trusted' IP address. Telnet access to the CPSMM100 can be limited to a single station by placing its IP address in TntRIP. Any incoming Telnet request from a station whose IP address does not match TntRIP is ignored. The TntRIP can be modified to accept an entire subnet or other group of IP stations by using TntRIPMask, defined below.")
cpsmm100TntRIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100TntRIPMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100TntRIPMask.setDescription("This feature in obsolete as of 08/17/2001. Telnet 'trusted' address mask. See cpsmm100TntRIP. This value can be used to exclude bit positions from consideration when applying TntRIP (above) to a Telnet connection request. For each bit position in TntRIPMask that is a 1, the corresponding bits in the TntRIP and the IP address of the connecting client must be the same. If this is not true, the connection attempt is ignored. Note that the TntRIPMask differs from a true subnet mask (which must have all '1' bits at the left and all '0' bits at the right) in that it may use any bit pattern.")
cpsmm100SNMPTrapMgr = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr.setDescription('Traps generated by this management module will be sent to this IP address.')
cpsmm100SNMPTrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SNMPTrapInterval.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SNMPTrapInterval.setDescription('For future expansion, not currently implemented.')
cpsmm100SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 19), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SysUpTime.setDescription("Mirror of this Management Module's system.sysUpTime.0")
cpsmm100SysContact = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SysContact.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SysContact.setDescription("Mirror of this Management Module's system.sysContact.0")
cpsmm100SysName = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 21), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SysName.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SysName.setDescription("Mirror of this Management Module's system.sysName.0")
cpsmm100SysLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 22), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SysLocation.setDescription("Mirror of this Management Module's system.sysLocation.0")
cpsmm100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cpsmm100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SerialNumber.setDescription('The serial number of this device.')
cpsmm100ICIF = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100ICIF.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100ICIF.setDescription('Multiple Management Modules can be installed in a Point System stack. For each cabinet in the stack, exactly one module must be selected to communicate configuration changes to the cabinet hardware and provide a communications pathway to other cabinets. This module is known as the Inter-Cabinet Communications Interface. If there are any Base Management Modules in the cabinet, the one in the lowest slot will be the ICIF. Otherwise, it will be the Expansion Management Module in the lowest slot.')
cpsmm100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100MRevision.setDescription('The marketing revision of this device')
cpsmm100LastGasp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100LastGasp.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100LastGasp.setDescription('Last Gasp support for this device.')
cpsmm100SNMPTrapMgr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr2.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr2.setDescription('Traps generated by this management module will be sent to this IP address.')
cpsmm100SNMPTrapMgr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 29), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr3.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr3.setDescription('Traps generated by this management module will be sent to this IP address.')
cpsmm100SNMPTrapMgr4 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 30), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr4.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100SNMPTrapMgr4.setDescription('Traps generated by this management module will be sent to this IP address.')
cpsmm100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cpsmm200Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2), )
if mibBuilder.loadTexts: cpsmm200Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200Table.setDescription('Sparse table containing one entry for each CPSMM200-210 and other CPSMM200-xxx Point System Expansion Management Module in the stack, indexed by cabinet serial number and slot.')
cpsmm200Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1), ).setIndexNames((0, "MCC16-MIB", "cpsmm200BiaIndex"), (0, "MCC16-MIB", "cpsmm200SlotIndex"))
if mibBuilder.loadTexts: cpsmm200Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200Entry.setDescription('Status entries for a single cpsmm200. (The CPSMM200 has no configuration)')
cpsmm200BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm200BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsmm200SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm200SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200SlotIndex.setDescription('The slot in which the device is installed')
cpsmm200SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm200SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200SerialNumber.setDescription('The serial number of this device')
cpsmm200ICIF = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm200ICIF.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200ICIF.setDescription('Multiple Management Modules can be installed in a Point System stack. For each cabinet in the stack, exactly one module must be selected to communicate configuration changes to the cabinet hardware and provide a communications pathway to other cabinets. This module is known as the Inter-Cabinet Communications Interface. If there are any Base Management Modules in the cabinet, the one in the lowest slot will be the ICIF. Otherwise, it will be the Expansion Management Module in the lowest slot.')
cpsmm200MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmm200MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmm200MRevision.setDescription('The marketing revision of this device')
cettf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3), )
if mibBuilder.loadTexts: cettf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100Table.setDescription('Sparse table containing one entry for each CETTF100 10Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cettf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1), ).setIndexNames((0, "MCC16-MIB", "cettf100BiaIndex"), (0, "MCC16-MIB", "cettf100SlotIndex"))
if mibBuilder.loadTexts: cettf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100Entry.setDescription('Status and configuration entries for a single CETTF100')
cettf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cettf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100SlotIndex.setDescription('The slot in which the device is installed')
cettf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cettf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CETTF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cettf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100MRevision.setDescription('The marketing revision of this device')
cettf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cettf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100SerialNumber.setDescription('The serial number of this device')
cettf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100ConnA.setDescription('The style of Fiber connector built into this device')
cettf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100ConnB.setDescription('The style of Copper connector built into this device')
cettf100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100TPLink.setDescription('Status of Copper Link for this device')
cettf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100FiberLink.setDescription('Status of Fiber Link for this device')
cettf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100Fault.setDescription('Value is yes(1) when either TPLink or FiberLink has value linkDown(2)')
cettf100TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100TPActivity.setDescription('Network traffic indicator for Copper side of this device')
cettf100FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100FiberActivity.setDescription('Network traffic indicator for Fiber side of this device')
cettf100AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cettf100AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100AutoCross.setDescription('Enable/Disable for automatic copper TX/RX pair correction')
cettf100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cettf100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100LinkPassThrough.setDescription('Enable/Disable for Link Pass Through, a feature that causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see the fault condition.')
cettf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cettf100Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cettf100Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100Enabled.setDescription('When this configuration item is set to no(2), the device passes no network traffic.')
cettf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cettf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cettf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cfetf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4), )
if mibBuilder.loadTexts: cfetf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Table.setDescription('Sparse table containing one entry for each CFTEF100 100Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cfetf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1), ).setIndexNames((0, "MCC16-MIB", "cfetf100BiaIndex"), (0, "MCC16-MIB", "cfetf100SlotIndex"))
if mibBuilder.loadTexts: cfetf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Entry.setDescription('Status and configuration entries for a single CFETF100')
cfetf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cfetf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100SlotIndex.setDescription('The slot in which the device is installed')
cfetf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CFETF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cfetf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100MRevision.setDescription('The marketing revision of this device')
cfetf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cfetf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100SerialNumber.setDescription('The serial number of this device')
cfetf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100ConnA.setDescription('The style of Fiber connector built into this device')
cfetf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100ConnB.setDescription('The style of Copper connector built into this device')
cfetf100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100TPLink.setDescription('Status of Twisted Pair Link for this device')
cfetf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100FiberLink.setDescription('Status of Fiber Link for this device')
cfetf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Fault.setDescription('Value is yes(1) when either TPLink or FiberLink has value linkDown(2)')
cfetf100FastLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autonegotiate", 1), ("hdx100Btx", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100FastLinkPulse.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100FastLinkPulse.setDescription("When set to autonegotiate(1), converter sends Fast Link Pulses on its twisted pair port, thereby participating in autonegotiation of duplex between the converter's twisted pair port and that of the connected station. If that station supports Full- Duplex (FDX) operation, FDX will be used. If not, the twisted pair will operate in Half-Duplex (HDX) mode. When set to hdx100Btx(2), the converter instead sends 100Mbps idles (rather than Fast Link Pulses) on its twisted pair port (i.e. it declines to negotiate), which forces the twisted pair to operate in HDX mode regardless of the capabilities of the connected station. When operating in HDX mode, the twisted pair can support traffic in only one direction at a time. In FDX mode, traffic can pass in both directions simultaneously, thus theoretically doubling network performance.")
cfetf100Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Enabled.setDescription('When this configuration item is set to no(2), the device passes no network traffic.')
cfetf100Pause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100Pause.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100Pause.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. Support for Pause is negotiated at the physical level and passed up to the MAC. While the MAC's Pause messages themselves can pass over the fiber link that this pair of media converters introduces, the TP physical layer negotiations to enable Pause can not. Therefore, if both end station MACs support Pause and wish to use it, the Pause negotiation must be re-generated by the media converters on both ends. By setting this configuration option to enabled(1), you are indicating to the local twisted pair station that the twisted pair station on the other side of the other media converter supports Pause and wishes to use it. This variable must be set consistently on both of the paired media converters.")
cfetf100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100LinkPassThrough.setDescription('Enable/Disable for Link Pass Through, a feature that causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see the fault condition.')
cfetf100AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100AutoCross.setDescription('Enable/Disable for automatic copper TX/RX pair correction. When disabled, the port operates in MDI mode.')
cfetf100TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100TPActivity.setDescription('Network traffic indicator for Copper side of this device')
cfetf100FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100FiberActivity.setDescription('Network traffic indicator for Fiber side of this device')
cfetf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cfetf100FarEndFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf100FarEndFault.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100FarEndFault.setDescription('Far End Fault configuration of this device. This setting can only be changed by the physical jumper setting on the slide in card, for some devices, if it is available. Far End Fault is software read-write on other devices. Far End Fault causes the fiber transmitter to generate a Far End Fault pattern upon the loss of a receiver signal detect. When the receiver detects signal again, the transmitter stops transmitting the Far End Fault pattern.')
cfetf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cfmff100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5), )
if mibBuilder.loadTexts: cfmff100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100Table.setDescription('Sparse table containing one entry for each CFMFF100 SingleMode to MultiMode Fiber Media Converter in the stack, indexed by cabinet serial number and slot.')
cfmff100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1), ).setIndexNames((0, "MCC16-MIB", "cfmff100BiaIndex"), (0, "MCC16-MIB", "cfmff100SlotIndex"))
if mibBuilder.loadTexts: cfmff100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100Entry.setDescription('Status and configuration entries for a single CFMFF100')
cfmff100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cfmff100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100SlotIndex.setDescription('The slot in which the device is installed')
cfmff100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfmff100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CFMFF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cfmff100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100MRevision.setDescription('The marketing revision of the device')
cfmff100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cfmff100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 6), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100ConnA.setDescription('The style of SingleMode connector built into this device')
cfmff100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100ConnB.setDescription('The style of MultiMode connector built into this device')
cfmff100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100SerialNumber.setDescription('The serial number of this device')
cfmff100SMSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("signalUp", 1), ("signalDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100SMSignal.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100SMSignal.setDescription('Status of singlemode signal detect for this device')
cfmff100MMSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("signalUp", 1), ("signalDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100MMSignal.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100MMSignal.setDescription('Status of singlemode signal detect for this device')
cfmff100Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("yes", 1), ("noP1", 2), ("noP2", 3), ("no", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfmff100Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100Enabled.setDescription('Ports on this device can be disabled individually. When this control is set to yes(1), the entire device is enabled. When it is set to noP1(2), the SingleMode port is disabled. noP2(3) disables the MultiMode port only, and no(4) disables both. For most purposes, the values noP1(2), noP2(3), and no(4) are equivalent.')
cfmff100PortShutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100PortShutOff.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100PortShutOff.setDescription('This variable reflects the status of the DPT/OPP jumper on the board. This jumper controls the behavior of the converter when a loss of signal is detected. When the jumper is in the default OPP position, the loss of signal detect on one port causes the opposite port to be shut down. In this case, Port Shutoff is said to be disabled(2). In the DPT (enabled(1)) position, both ports are shut down. Use of the DPT position is discouraged, as it is more likely to lead to a signal loss condition from which the converter is unable to recover.')
cfmff100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cfmff100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfmff100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cfmff100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cpsmp100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6), )
if mibBuilder.loadTexts: cpsmp100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100Table.setDescription('Sparse table containing one entry for each CPSMP100 IFO (Instant Fail-Over) Power Supply in the stack, indexed by cabinet serial number and slot.')
cpsmp100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1), ).setIndexNames((0, "MCC16-MIB", "cpsmp100BiaIndex"), (0, "MCC16-MIB", "cpsmp100SlotIndex"))
if mibBuilder.loadTexts: cpsmp100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100Entry.setDescription('Status and configuration entries for a single CPSMP100')
cpsmp100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsmp100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100SlotIndex.setDescription('The slot in which the device is installed. Power Supplies occupy special slots numbered 125 and higher.')
cpsmp100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmp100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CPSMP100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cpsmp100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100MRevision.setDescription('The marketing revision of this device')
cpsmp100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cpsmp100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100SerialNumber.setDescription('The serial number of this device')
cpsmp100Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmp100Mode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100Mode.setDescription('When one power supply is set to master(1) and the other is set to slave(2), the master will supply all power to the cabinet, and the slave will take over if the master stops supplying power. This is useful when (for example) one supply is attached to a wall socket and the other to a battery backup. The cabinet can be directed to only draw power from batteries when there is no alternative. When both power supplies are set to master(1), the results are determined automatically. WARNING: It is up to the system administrator to ensure that at least one power supply is set to master(1). It is illegal to set all power supplies to slave(2). If this occurs, the cabinet may lose all power under certain circumstances, even if power is available.')
cpsmp100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cpsmp100RemoteFan = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("installed", 1), ("notInstalled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100RemoteFan.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100RemoteFan.setDescription('A Remote Fan is a device that fits in a power supply slot but contains no power supply, only a fan. These devices are not manageable, but if present they will be reported by the manageable supply that accompanies it.')
cpsmp100PowerOK = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100PowerOK.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100PowerOK.setDescription('This variable has the value yes(1) any time this supply is capable of supplying at least 11.6 volts to the cabinet. Note that a value of no(2) does not necessarily indicate hard failure. A power supply can be detected even if it is powered down or not plugged in as long as another power supply has PowerOK=yes(1) and InUse=yes(1). In this case, PowerOK will be no(2) for the disabled power supply.')
cpsmp100InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100InUse.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100InUse.setDescription('Value is yes(1) when this supply is currently selected to supply power to the cabinet.')
cpsmp100ChassisPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100ChassisPower.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100ChassisPower.setDescription('Power currently supplied to the cabinet, in milliwatts')
cpsmp100ChassisTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100ChassisTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100ChassisTemp.setDescription('The temperature inside the cabinet as detected by the power supply, in tenths of degrees centigrade')
cpsmp100RFanFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100RFanFault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100RFanFault.setDescription('Normally no(2), this value changes to yes(1) when an installed Remote fan is drawing excessive current or none at all.')
cpsmp100LFanFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100LFanFault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100LFanFault.setDescription('Normally no(2), this value changes to yes(1) when the Local fan is drawing excessive current or none at all.')
cpsmp100SupplyType = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ac", 1), ("dc48", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100SupplyType.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100SupplyType.setDescription('The supply voltage that this unit is designed to accept. If AC(1), the supply accepts 90-260VAC, 47 to 400Hz. If DC48(2), the supply accepts 38-75VDC.')
cpsmp100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
csetf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7), )
if mibBuilder.loadTexts: csetf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100Table.setDescription('Sparse table containing one entry for each CSETF100 10/100Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
csetf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1), ).setIndexNames((0, "MCC16-MIB", "csetf100BiaIndex"), (0, "MCC16-MIB", "csetf100SlotIndex"))
if mibBuilder.loadTexts: csetf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100Entry.setDescription("One table entry per piece of management module information. Entry 'n' does not exist.")
csetf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
csetf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100SlotIndex.setDescription('The slot in which the device is installed')
csetf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csetf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CSETF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
csetf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100MRevision.setDescription('The marketing revision of this device')
csetf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
csetf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100SerialNumber.setDescription('The serial number of this device')
csetf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100ConnA.setDescription('The style of Fiber connector built into this device')
csetf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100ConnB.setDescription('The style of Copper connector built into this device')
csetf100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100TPLink.setDescription('Status of Twisted Pair Link for this device')
csetf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100FiberLink.setDescription('Status of Fiber Link for this device')
csetf100AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csetf100AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100AutoCross.setDescription('Enable/Disable for automatic copper TX/RX pair correction')
csetf100SpeedConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("mbps10", 2), ("mbps100", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csetf100SpeedConfig.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100SpeedConfig.setDescription('This variable allows the user to set the requested data transfer rate for this converter.')
csetf100Speed100Mbps = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100Speed100Mbps.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100Speed100Mbps.setDescription('This variable reports the current data transfer rate for this converter.')
csetf100TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activity", 1), ("noActivity", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100TPActivity.setDescription('Network traffic indicator for Copper side of this device')
csetf100FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activity", 1), ("noActivity", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100FiberActivity.setDescription('Network traffic indicator for Fiber side of this device')
csetf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
csetf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csetf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: csetf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cgetf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8), )
if mibBuilder.loadTexts: cgetf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Table.setDescription('Sparse table containing one entry for each CGETF100 Gigabit Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cgetf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1), ).setIndexNames((0, "MCC16-MIB", "cgetf100BiaIndex"), (0, "MCC16-MIB", "cgetf100SlotIndex"))
if mibBuilder.loadTexts: cgetf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Entry.setDescription("One table entry per piece of management module information. Entry 'n' does not exist.")
cgetf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cgetf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100SlotIndex.setDescription('The slot in which the device is installed')
cgetf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CGETF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cgetf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100MRevision.setDescription('The marketing revision of this device')
cgetf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cgetf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100SerialNumber.setDescription('The serial number of this device')
cgetf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100ConnA.setDescription('The style of Fiber connector built into this device')
cgetf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100ConnB.setDescription('The style of Copper connector built into this device')
cgetf100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100TPLink.setDescription('Status of Twisted Pair Link for this device')
cgetf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100FiberLink.setDescription('Status of Fiber Link for this device')
cgetf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Fault.setDescription('Value is yes(1) when either TPLink or FiberLink has value linkDown(2)')
cgetf100Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Enabled.setDescription('When this variable is set to no(1), the device allows no traffic to pass.')
cgetf100Pause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100Pause.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100Pause.setDescription('Enable/Disable control for the advertising of Pause capability on the copper interface. This MIB variable is retained for compatibility with older applications and firmware. If you have a current version of the CGETF100 device (which supports asymmetric pause), you should both read and write the MIB variable cgetf100PauseType(21) for complete monitoring and control of pause capability advertising. If you are using a current Transition Networks application, this is automatic. On all versions of the CGETF100 device, this MIB variable can be used to enable and disable advertising of symmetric pause. For current versions of the CGETF100, this variable reads enabled(1) any time any type of pause is enabled, and forces cgetf100PauseType(21) to symmetric(1) when changed from disabled(2) to enabled(1). On new versions of the CGETF100 device, when cgetf100FiberAutoNegot(19) has the value enabled(1), this variable takes on the read-only value enabled(1).')
cgetf100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100LinkPassThrough.setDescription('Enable/Disable for Link Pass Through, a feature that causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see the fault condition.')
cgetf100FullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullDuplex", 1), ("halfDuplex", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100FullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100FullDuplex.setDescription('Controls advertizing of duplex capability for the copper side of the converter. When set to fullDuplex(1), the converter advertizes full duplex capability. When set to halfDuplex(2), the converter advertizes half duplex capability. The converter never advertizes both simultaneously. If the advertized setting is not supported by the remote, link cannot be established.')
cgetf100ClockMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100ClockMaster.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100ClockMaster.setDescription('When yes(1), the converter is supplying clock to the twisted pair. When no(2), the remote supplies the clock.')
cgetf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cgetf100TPLength = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ln-lt50", 1), ("ln-50-80", 2), ("ln-80-110", 3), ("ln-110-140", 4), ("ln-gt140", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100TPLength.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100TPLength.setDescription("Twisted-pair length estimated via the converter's internal Time Domain Reflectometer. 1 means less than 50 meters, 2 means 50 to 80 meters, 3 means 80 to 110 meters, 4 means 110 to 140 meters, and 5 means more than 140 meters.")
cgetf100FiberAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100FiberAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100FiberAutoNegot.setDescription('Fiber port autonegotiation configuration.')
cgetf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgetf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cgetf100PauseType = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 8, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("symmetric", 1), ("asymRX", 2), ("asymTX", 3), ("disabled", 4), ("notApplicable", 5), ("symmetricRO", 6), ("asymRXRO", 7), ("asymTXRO", 8), ("disabledRO", 9), ("all", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgetf100PauseType.setStatus('mandatory')
if mibBuilder.loadTexts: cgetf100PauseType.setDescription('Enable/Disable control for the advertising of Pause capability on the copper interface. This MIB variable is only functional on CGETF100 devices that support asymmetric pause (i.e. current versions). If your CGETF100 does not support asymmetric pause, this variable will return the read-only value notApplicable(5) regardless of any other factors. On current CGETF100 devices, selectable values for this variable are symmetric(1), asymRX(2) (asymmetric, pause frames flow towards the converter), asymTX(3) (asymmetric, pause frames flow towards the link partner), and disabled(4). Note: Changing cgetf100PauseType(21) to disabled(4) causes cgetf100Pause(13) to take on the value disabled(2). Changing cgetf100PauseType(21) to any selectable value other than disabled(4) causes cgetf100Pause(13) to take on the value enabled(1). If cgetf100FiberAutoNegot(19) has the value enabled(1), then this variable returns the read-only value all(10), which indicates that all advertised modes received from the twisted pair link partner are reflected back to the link partner. Otherwise, if cgetf100ConfigMode(17) has the value hardware(2), one of the following read-only values will be returned: symmetricRO(6) or disabledRO(9). The read-only values asymRXRO(7) and asymTXRO(8) are defined for future expansion.')
csdtf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9), )
if mibBuilder.loadTexts: csdtf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100Table.setDescription('Sparse table containing one entry for each CSDTF100 T1/E1 Copper to Fiber Media Converter in the stack, indexed by cabinet serial number and slot.')
csdtf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1), ).setIndexNames((0, "MCC16-MIB", "csdtf100BiaIndex"), (0, "MCC16-MIB", "csdtf100SlotIndex"))
if mibBuilder.loadTexts: csdtf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100Entry.setDescription('Status and configuration entries for a single CSDTF100')
csdtf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
csdtf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100SlotIndex.setDescription('The slot in which the device is installed')
csdtf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CSDTF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
csdtf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100MRevision.setDescription('The marketing revision of this device')
csdtf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
csdtf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100SerialNumber.setDescription('The serial number of this device')
csdtf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100ConnA.setDescription('The style of Fiber connector built into this device')
csdtf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100ConnB.setDescription('The style of Copper connector built into this device')
csdtf100CopperLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100CopperLink.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CopperLink.setDescription('Status of Copper Link for this device')
csdtf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100FiberLink.setDescription('Status of Fiber Link for this device')
csdtf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100Fault.setDescription('Value is yes(1) when either CopperLink or FiberLink has value linkDown(2)')
csdtf100TAOSFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100TAOSFiber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100TAOSFiber.setDescription('Transmit All Ones on Fiber as an error signal when Copper interface is down. When this error signal is transmitted, the AIS of the device on the other end is activated, if supported.')
csdtf100TAOSCopper = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100TAOSCopper.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100TAOSCopper.setDescription('Transmit All Ones on Copper as an error signal when Fiber interface is down. When this error signal is transmitted, the AIS of the device on the other end is activated, if supported.')
csdtf100AISFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100AISFiber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100AISFiber.setDescription('Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
csdtf100AISCopper = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100AISCopper.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100AISCopper.setDescription('Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
csdtf100CopperLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100CopperLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CopperLoopback.setDescription('Enable loopback on the copper interface. Copper Loopback causes all data that is sent to the copper interface to be transmitted back out the copper interface. NOT SUPPORTED on initial version of the product. ')
csdtf100CopperLongHaul = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100CopperLongHaul.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CopperLongHaul.setDescription("This variable indicates the current position of the device's long/short haul configuration switch.")
csdtf100T1E1 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1", 1), ("e1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100T1E1.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100T1E1.setDescription('This variable indicates whether the current device is the T1 or the E1 version.')
csdtf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
csdtf100TPCoax = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tp", 1), ("coax", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100TPCoax.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100TPCoax.setDescription('Indicates the connector type installed on the copper interface. For E1 converters, this can be either Twisted Pair or Coax. For T1, it is always Twisted Pair.')
csdtf100CopperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("e13-0V120ohm", 1), ("e12-37V75ohm", 2), ("t1SH-DSX-0-133ANSIT1403", 3), ("t1SH-DSX-133-266", 4), ("t1SH-DSX-266-399", 5), ("t1SH-DSX-399-533", 6), ("t1SH-DSX-533-655", 7), ("t1SH-DSX-6V", 8), ("t1LH-0dB", 9), ("t1LH-m7-5dB", 10), ("t1LH-m15dB", 11), ("t1LH-m22-5dB", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100CopperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CopperLineBuildout.setDescription('The characteristics of the copper interface')
csdtf100FiberLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100FiberLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100FiberLoopback.setDescription('Enable loopback on the Fiber interface. Fiber Loopback causes all data that is sent to the Fiber interface to be transmitted back out the Fiber interface.')
csdtf100RmtSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtSupported.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtSupported.setDescription('Has the value yes(1) if this converter is capable of managing the media converter at the remote end of the fiber.')
csdtf100RmtDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtDetected.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtDetected.setDescription('Has the value yes(1) if management communcations have been established with a remote media converter. Always no(2) if TAOS is enabled or the remote converter does not support remote management.')
csdtf100RmtMRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtMRevision.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtMRevision.setDescription('Remote Marketing Revision. Same as csdtf100MRevision, only for the remote device.')
csdtf100RmtSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtSerialNumber.setDescription('Serial Number reported by remote device.')
csdtf100RmtConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 27), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtConnA.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtConnA.setDescription('The style of Fiber connector reported by remote device.')
csdtf100RmtConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 28), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtConnB.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtConnB.setDescription('The style of Fiber connector reported by remote device.')
csdtf100RmtCopperLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtCopperLink.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtCopperLink.setDescription('Link status of remote Copper Port.')
csdtf100RmtFiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtFiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtFiberLink.setDescription('Link status of remote Fiber Port.')
csdtf100RmtFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtFault.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtFault.setDescription('Remote Fault status. Value is yes(1) when either CopperLink or FiberLink has value linkDown(2)')
csdtf100RmtTAOSFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100RmtTAOSFiber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtTAOSFiber.setDescription('Remote Fiber TAOS configuration. Transmit All Ones on Fiber as an error signal when Copper interface is down. When this error signal is transmitted, the AIS of the device on the other end is activated, if supported.')
csdtf100RmtTAOSCopper = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100RmtTAOSCopper.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtTAOSCopper.setDescription('Remote Copper TAOS configuration. Transmit All Ones on Copper as an error signal when Fiber interface is down. When this error signal is transmitted, the AIS of the device on the other end is activated, if supported.')
csdtf100RmtAISFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtAISFiber.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtAISFiber.setDescription('Remote Fiber AIS status. Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
csdtf100RmtAISCopper = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtAISCopper.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtAISCopper.setDescription('Remote Copper AIS status. Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
csdtf100RmtCopperLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100RmtCopperLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtCopperLoopback.setDescription('Remote Copper Loopback configuration. Enable loopback on the copper interface. Copper Loopback causes all data that is sent to the copper interface to be transmitted back out the copper interface. NOT SUPPORTED on initial version of the product.')
csdtf100RmtCopperLongHaul = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtCopperLongHaul.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtCopperLongHaul.setDescription("This variable indicates the current position of the remote device's Short/Long haul configuration switch.")
csdtf100RmtConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtConfigMode.setDescription('Remote Configuration Mode. This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
csdtf100RmtTPCoax = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tp", 1), ("coax", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtTPCoax.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtTPCoax.setDescription('Indicates the connector type installed on the remote copper interface. For E1 converters, this can be either Twisted Pair or Coax. For T1, it is always Twisted Pair.')
csdtf100RmtCopperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("e13-0V120ohm", 1), ("e12-37V75ohm", 2), ("t1SH-DSX-0-133ANSIT1403", 3), ("t1SH-DSX-133-266", 4), ("t1SH-DSX-266-399", 5), ("t1SH-DSX-399-533", 6), ("t1SH-DSX-533-655", 7), ("t1SH-DSX-6V", 8), ("t1LH-0dB", 9), ("t1LH-m7-5dB", 10), ("t1LH-m15dB", 11), ("t1LH-m22-5dB", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100RmtCopperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtCopperLineBuildout.setDescription('The electrical characteristics of the remote Copper interface. Values are the same as the values for csdtf100CopperLineBuildout(21)')
csdtf100RmtFiberLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csdtf100RmtFiberLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100RmtFiberLoopback.setDescription('Enable loopback on the remote Fiber interface. Fiber Loopback causes all data that is sent to the Fiber interface to be transmitted back out the Fiber interface.')
csdtf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 9, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csdtf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: csdtf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cpsmp110Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10), )
if mibBuilder.loadTexts: cpsmp110Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110Table.setDescription("Sparse table containing one entry for each CPSMP110 IFO (Instant Fail-Over) Power Supply in the stack. indexed by sub-device index, cabinet serial number, and slot. Note that some columns of this table support multiple subdevices, and some do not. For example, there is exactly one SerialNumber for each CPSMP110. No subdevices exist, so the placeholder value 1 is used as the subdevice index. However, a CPSMP110 has zero or more current sensors, which (if they exist) are indexed as different subdevices, starting with 1. Columns with subdevices have names ending in 'Tbl'")
cpsmp110Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1), ).setIndexNames((0, "MCC16-MIB", "cpsmp110SubDeviceIndex"), (0, "MCC16-MIB", "cpsmp110BiaIndex"), (0, "MCC16-MIB", "cpsmp110SlotIndex"))
if mibBuilder.loadTexts: cpsmp110Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110Entry.setDescription('Status and configuration entries for a single CPSMP100')
cpsmp110SubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110SubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110SubDeviceIndex.setDescription("Generally, individual devices in this MIB are distinguished by BiaIndex and SlotIndex. This device differs from many in that it contains multiple subdevices (in this case, fans, temperature sensors, current sensors, and power supplies). The number of subdevices varies with the manufactured configuration. Subdevices within devices are indexed by BiaIndex, SlotIndex, and SubDeviceIndex. When the subdevice column is read from the table, the value '1' is always returned.")
cpsmp110BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110SlotIndex.setDescription('The slot in which the device is installed. Power Supplies occupy special slots numbered 125 and higher. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmp110Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CPSMP110' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]' There are no subdevices for this value, so the placeholder value 1 is always used for that index.")
cpsmp110MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110MRevision.setDescription('The marketing revision of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110SerialNumber.setDescription('The serial number of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110ConfigMode.setDescription('This device may have a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110MasterTempFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110MasterTempFault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110MasterTempFault.setDescription('The master temperature fault indicator for this device. A value of yes(1) indicates that at least one temperature sensor encountered a fault condition since the last time the device was queried by the management module. The statuses of individual temperature sensors can be found in cpsmp110TemperatureTbl. Note that in the unusual case that a sensor spikes (i.e. encounters a fault, and then quickly returns to normal), it will be difficult to determine which sensor faulted. However, the fact that any sensor faulted is sufficient cause to examine the cabinet further. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110MasterCurrentFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110MasterCurrentFault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110MasterCurrentFault.setDescription('The master current fault indicator for this device. A value of yes(1) indicates that at least one current sensor encountered a fault condition since the last time the device was queried by the management module. The statuses of individual current sensors can be found in cpsmp110CurrentTbl. Note that in the unusual case that a sensor spikes (i.e. encounters a fault, and then quickly returns to normal), it will be difficult to determine which sensor faulted. However, the fact that any sensor faulted is sufficient cause to examine the cabinet further. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110MasterFanFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110MasterFanFault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110MasterFanFault.setDescription('The master fan fault indicator for this device. A value of yes(1) indicates that at least one fan current sensor encountered a fault condition since the last time the device was queried by the management module. The statuses of individual fan current sensors can be found in cpsmp110FanStatusTbl. Note that in the unusual case that a sensor spikes (i.e. encounters a fault, and then quickly returns to normal), it will be difficult to determine which sensor faulted. However, the fact that any sensor faulted is sufficient cause to examine the cabinet further. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110FirmwareRevision.setDescription('The firmware revision level for this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cpsmp110PSSupplyTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ac", 1), ("dc", 2), ("reserved3", 3), ("reserved4", 4), ("notInstalled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110PSSupplyTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110PSSupplyTbl.setDescription('The supply voltage that this unit is designed to accept. If AC(1), the supply accepts VAC. If DC(2), the supply accepts. A single CPSMP110 control unit can support multiple subdevices of this type. There will be one entry per subdevice.')
cpsmp110PSRoleTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("shared", 3), ("notInstalled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsmp110PSRoleTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110PSRoleTbl.setDescription('Some power supplies support a Master/Slave relationship: When one power supply is set to master(1) and the other is set to slave(2), the master will supply all power to the cabinet, and the slave will take over if the master stops supplying power. This is useful when (for example) one supply is attached to a wall socket and the other to a battery backup. The cabinet can be directed to only draw power from batteries when there is no alternative. When both power supplies are set to master(1), the results are determined automatically. WARNING: It is up to the system administrator to ensure that at least one power supply is set to master(1). It is illegal to set all power supplies to slave(2). If this occurs, the cabinet may lose all power under certain circumstances, even if power is available. In some cases, the Master/Slave relationship cannot be configured via management; it is determined by other means, such as the slot locations in which the supplies are installed, or switches on the supplies. In this case, attempts to change the value of this variable from management will be ignored. The ConfigMode variable will have the value hardware(2) in this case. If a supply does not support (or can disable) Master/Slave functionality, the value shared(3) is returned. In this case, all ready power supplies share the load evenly. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110PSReadyTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110PSReadyTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110PSReadyTbl.setDescription('The readiness of this power supply module. A value of yes(1) indicates the module is ready to supply power to the cabinet. A value of no(2) indicates that the supply has no output power to offer, either because it is malfunctioning or because it has no input power. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110PSInUseTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110PSInUseTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110PSInUseTbl.setDescription('The use status of this power supply module. A value of yes(1) indicates the module is supplying power to the cabinet. This variable is useful in configurations where master/slave role functionality is supported to determine whether the Master or the Slave is active. In shared configurations, the value of PSReadyTbl is strongly preferred as an indication of the status of the supply. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110TemperatureTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110TemperatureTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110TemperatureTbl.setDescription('The temperature, in tenths of degrees centigrade, read by this temperature sensor. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110CurrentTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110CurrentTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110CurrentTbl.setDescription('The current, in milliwatts, read by this current sensor. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110FanStatusTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fault", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110FanStatusTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110FanStatusTbl.setDescription('The status of a fan. A value of fault(2) indicates that the control unit has detected a problem with the fan, usually that it is is drawing excessive current. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110TempFaultTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110TempFaultTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110TempFaultTbl.setDescription('Each entry in this column corresponds to an entry with the same indices in cpsmp110TemperatureTable. It indicates whether or not the temperature read by the sensor is within the acceptable range. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110CurrFaultTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110CurrFaultTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110CurrFaultTbl.setDescription('Each entry in this column corresponds to an entry with the same indices in cpsmp110CurrentTable. It indicates whether or not the current read by the sensor is within the acceptable range. A single CPSMP110 control unit can support multiple subdevices of this type.')
cpsmp110PSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110PSCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110PSCount.setDescription('The maximum number of power supplies supported in this configuration.')
cpsmp110TempSensorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110TempSensorCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110TempSensorCount.setDescription('The number of temperature sensors supported in this device.')
cpsmp110CurrSensorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110CurrSensorCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110CurrSensorCount.setDescription('The number of current sensors supported in this device.')
cpsmp110FanCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110FanCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110FanCount.setDescription('The number of fans supported in this device.')
cpsmp110CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 10, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsmp110CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cpsmp110CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cbftf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11), )
if mibBuilder.loadTexts: cbftf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Table.setDescription("Sparse table containing one entry for each CBFTF100 switch in the stack. Indexed by sub-device index, cabinet serial number, and slot. Note that some columns of this table support multiple subdevices, and some do not. For example, there is exactly one SerialNumber for each CBFTF100. No subdevices exist, so the placeholder value 1 is used as the subdevice index. However, a CBFTF100 has multiple switch ports, which are indexed as different subdevices, starting with 1. Columns with subdevices have names ending in 'Tbl'")
cbftf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1), ).setIndexNames((0, "MCC16-MIB", "cbftf100SubDeviceIndex"), (0, "MCC16-MIB", "cbftf100BiaIndex"), (0, "MCC16-MIB", "cbftf100SlotIndex"))
if mibBuilder.loadTexts: cbftf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Entry.setDescription('Status and configuration entries for a single CBFTF100')
cbftf100SubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100SubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SubDeviceIndex.setDescription("Generally, individual devices in this MIB are distinguished by BiaIndex and SlotIndex. This device differs from many in that it contains multiple subdevices (in this case, switch ports). The number of subdevices varies with the manufactured configuration. Subdevices within devices are indexed by BiaIndex, SlotIndex, and SubDeviceIndex. When the subdevice column is read from the table, the value '1' is always returned.")
cbftf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SlotIndex.setDescription('The slot in which the device is installed. Power Supplies occupy special slots numbered 125 and higher. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'cbftf100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]' There are no subdevices for this value, so the placeholder value 1 is always used for that index.")
cbftf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100MRevision.setDescription('The marketing revision of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SerialNumber.setDescription('The serial number of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100ConfigMode.setDescription('This device may have a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100FirmwareRevision.setDescription('The firmware revision level for this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf100SelfTestFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100SelfTestFailed.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SelfTestFailed.setDescription('This variable indicates the status of the pass/fail power on test. If the power on test fails, normal operation of this device is probably not possible. ')
cbftf100SpanningTree = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100SpanningTree.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SpanningTree.setDescription('This variable allows the agent to enable or disable Spanning Tree if it is supported. Not all versions of the hardware support Spanning Tree.')
cbftf100MirrorCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100MirrorCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100MirrorCfg.setDescription('Global enable/disable for mirror port functionality. When this variable is set to disabled, the values of cbftf100MirrorSelTbl, cbftf100MirrorInTbl, and cbftf100MirrorOutTbl are ignored.')
cbftf100SACMasterCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100SACMasterCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SACMasterCfg.setDescription('Global enable/disable for Source Address Change detection functionality. When this variable is set to disabled the values in cbtf100SACCfgTbl are ignored.')
cbftf100FormFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("s1W2a", 1), ("s1W1N2a", 2), ("s1W1N1a", 3), ("s2W2N4a", 4), ("s2W1N5a", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100FormFactor.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100FormFactor.setDescription('A code corresponding to a physical configuration of the product. This code indicates the number of slots occupied and the number of physical connectors present. In the labels for the values above, s indicates the number of slots occupied, W is a count of Wide port positions (which can built as almost any type of connector), and N is a count of narrow port positions (which are typically twisted pair ports). The lowercase letter at the end differentiates different form factors that would otherwise have identical descriptions under this limited scheme.')
cbftf100AutoNegotTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100AutoNegotTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100AutoNegotTbl.setDescription('Enables or disables autonegtiation of link speed and duplex for twisted pair ports. Not supported on Fiber ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100FullDuplexTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullDuplex", 1), ("halfDuplex", 2), ("negotiating", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100FullDuplexTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100FullDuplexTbl.setDescription('In most cases this is a configuration setting that controls the duplex mode; fullDuplex is full duplex and halfDuplex is half duplex. On twisted pair ports with autonegotiation enabled, this is a status indication showing the duplex value decided upon during the negotiation. When link is down, autonegotiation has not been completed yet, and the duplex setting is therefore unknown and the value is negotiating(3). There are multiple subdevices in this table, numbering one entry per port.')
cbftf100100MbpsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mbps100", 1), ("mbps10", 2), ("negotiating", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100100MbpsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100100MbpsTbl.setDescription('In most cases this is a configuration setting that controls the link speed. On twisted pair ports with autonegotiation enabled, this is a status indication showing the link speed decided upon during negotiation. When link is down, autonegotiation has not been completed yet, and the link speed is therefore unknown and is negotiating(3). This variable is an indicator only for fiber ports; all fiber ports report mbps100(1) at all times. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100Adv10HDXTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100Adv10HDXTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Adv10HDXTbl.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 10Mbps, half duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100Adv10FDXTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100Adv10FDXTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Adv10FDXTbl.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 10Mbps, full duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100Adv100HDXTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100Adv100HDXTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Adv100HDXTbl.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 100Mbps, half duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100Adv100FDXTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100Adv100FDXTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100Adv100FDXTbl.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 100Mbps, full duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100CrossTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("mdi", 2), ("mdix", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100CrossTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100CrossTbl.setDescription('Configuration setting for copper TX/RX pair correction. A setting of auto(1) causes the port to automatically correct TX/RX pairs if necessary. If autonegotiation is disabled on the port, the auto(1) setting is not supported. A setting of mdi(2) causes the TX/RX pairs to be passed straight through with no correction. A setting of mdix(3) causes the TX/RX pairs to be swapped. This setting is supprted for copper ports only; a read-only value of notSupported(4) is returned for fiber ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100PauseCfgTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100PauseCfgTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100PauseCfgTbl.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. A setting of enabled(1) causes this port to advertise pause capability and a setting of disabled(2) disables pause capability advertising. On fiber ports, a read-only value of notSupported(3) is returned. There are multiple subdevices in this table, numbering one entry per port.")
cbftf100PauseStatTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("paused", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100PauseStatTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100PauseStatTbl.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. A value of paused(1) indicated the port is in a paused state, and a value of normal(2) indicates the port is operating normally. There are multiple subdevices in this table, numbering one entry per port.")
cbftf100FarEndFaultTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100FarEndFaultTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100FarEndFaultTbl.setDescription('When Far End Fault is set to enabled(1), a loss of link on receive will cause the transmitter to shut down, in order to inform the device at the far end of the link that a fault has occurred. Far End Fault is only supported on fiber ports. A read-only value of notSupported(3) is returned for copper ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100ConnectorTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 26), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100ConnectorTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100ConnectorTbl.setDescription('The style of connectors built into each port of this device. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100SACCfgTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100SACCfgTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SACCfgTbl.setDescription('This configuration setting controls whether changes in source MAC address are reported. When set to enabled(1), a change in MAC address will result in a momentary change in the value of SACStatTbl from same(2) to changed(1) and back, and the transmission of a trap, if the management module is so configured. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100SACStatTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("same", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100SACStatTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100SACStatTbl.setDescription("This status value indicates whether or not the source MAC address attached to this port changed in the last polling period. This value tends to change quite quickly; therefore, the 'ERROR' traps that are sent when SAC is detected are a much more reliable indicator. There are multiple subdevices in this table, numbering one entry per port.")
cbftf100MirrorSelTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mirror", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100MirrorSelTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100MirrorSelTbl.setDescription('This configuration setting allows a mirror port to be selected. The selected port will re-transmit copies of all packets transmitted on ports whose MirrorOutTbl value is set to mirrorOut(1), and will also transmit copies of all packets received by all ports whose MirrorInTbl value is set to mirrorIn(1). It is recommended that a maximum of one MirrorSelTbl, one MirrorInTbl, and one MirrorOutTbl port be selected at once, since the switch may have trouble handling the traffic that can result from other configurations. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100MirrorInTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mirrorIn", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100MirrorInTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100MirrorInTbl.setDescription('This configuration setting allows a mirror source port to be selected. All packets received on each port with a MirrorInTbl setting of mirrorIn(1) will be retransmitted on all ports whose MirrorSelTbl setting is mirror(1). It is recommended that a maximum of one MirrorSelTbl, one MirrorInTbl, and one MirrorOutTbl port be selected at once, since the switch may have trouble handling the traffic that can result from other configurations. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100MirrorOutTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mirrorOut", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100MirrorOutTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100MirrorOutTbl.setDescription('This configuration setting allows a mirror source port to be selected. All packets transmitted on each port with a MirrorInTbl setting of mirrorOut(1) will be retransmitted on all ports whose MirrorSelTbl setting is mirror(1). It is recommended that a maximum of one MirrorSelTbl, one MirrorInTbl, and one MirrorOutTbl port be selected at once, since the switch may have trouble handling the traffic that can result from other configurations. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100LinkTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100LinkTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100LinkTbl.setDescription('This table contains the link status of each port in the switch. There are multiple subdevices in this table, numbering one entry per port.')
cbftf100PortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100PortCount.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100PortCount.setDescription('A count of the switch ports in this device. i.e. the maximum subdevice index supported by this switch.')
cbftf100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100LinkPassThrough.setDescription('If Link Passthrough is enabled on a port, loss of link on the opposite port will be propegated through to this port so that the switch does not prevent one end device from detecting loss of link on the opposite end device. Far end fault is only supported on copper ports and only in switch configurations that have exactly two ports.')
cbftf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cbftf100RedundantPath = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 11, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf100RedundantPath.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf100RedundantPath.setDescription('This variable shows the status of the redundant fiber capability. If the value is enabled(1), this means that the hardware switch to enable redundant fiber is on, and the two fiber ports on the device are presumed to be connected to the same remote device. Even if both fibers have link, traffic flows to and from that device through only one of the two fiber pairs at once. This provides a redundant path should one of the fibers be compromised. If the value is disabled(2), the hardware switch to enable redundant fiber is off, and the two fiber ports on the device pass traffic normally (i.e. independently and simultaneously). If the value is notSupported(3), the device does not have redundant fiber capability.')
cetct100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12), )
if mibBuilder.loadTexts: cetct100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100Table.setDescription('Sparse table containing one entry for each CETCT100 10Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cetct100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1), ).setIndexNames((0, "MCC16-MIB", "cetct100BiaIndex"), (0, "MCC16-MIB", "cetct100SlotIndex"))
if mibBuilder.loadTexts: cetct100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100Entry.setDescription('Status and configuration entries for a single CETCT100')
cetct100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cetct100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100SlotIndex.setDescription('The slot in which the device is installed')
cetct100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cetct100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CETCT100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cetct100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100MRevision.setDescription('The marketing revision of this device')
cetct100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cetct100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100SerialNumber.setDescription('The serial number of this device')
cetct100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cetct100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100FirmwareRevision.setDescription('The firmware revision level for this device.')
cetct100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100TPLink.setDescription('Status of Copper Link for this device')
cetct100Collision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100Collision.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100Collision.setDescription('This status variable indicates whether or not an Ethernet collision occurred during the most recent polling cycle.')
cetct100CoaxActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100CoaxActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100CoaxActivity.setDescription('This status variable indicates whether or not Ethernet traffic was detected on the Coax interface during the most recent polling cycle.')
cetct100TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100TPActivity.setDescription('This status variable indicates whether or not Ethernet traffic was detected on the Twisted Pair interface during the most recent polling cycle.')
cetct100CollisionsPerMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100CollisionsPerMinute.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100CollisionsPerMinute.setDescription('The number of Ethernet collisions that occurred during the most recently completed measured minute. Every 60 seconds, the device moves its previous collision count into this variable, and restarts the counter at zero.')
cetct100CollisionsPerHour = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100CollisionsPerHour.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100CollisionsPerHour.setDescription('The number of Ethernet collisions that occurred during the most recently completed measured hour. Every 60 minutes, the device moves its previous collision count into this variable, and restarts the counter at zero.')
cetct100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 15), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100ConnA.setDescription('The style of media connector built into this device.')
cetct100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 16), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100ConnB.setDescription('The style of media connector built into this device.')
cetct100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cetct100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cetct100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
ccscf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13), )
if mibBuilder.loadTexts: ccscf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100Table.setDescription('Sparse table containing one entry for each ccscf100 T3/E3 Copper to Fiber Media Converter in the stack, indexed by cabinet serial number and slot.')
ccscf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1), ).setIndexNames((0, "MCC16-MIB", "ccscf100BiaIndex"), (0, "MCC16-MIB", "ccscf100SlotIndex"))
if mibBuilder.loadTexts: ccscf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100Entry.setDescription('Status and configuration entries for a single ccscf100')
ccscf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
ccscf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100SlotIndex.setDescription('The slot in which the device is installed')
ccscf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccscf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'ccscf100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
ccscf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100MRevision.setDescription('The marketing revision of this device')
ccscf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
ccscf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100SerialNumber.setDescription('The serial number of this device')
ccscf100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
ccscf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100FiberLink.setDescription('Status of Fiber Link for this device')
ccscf100CopperLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100CopperLink.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100CopperLink.setDescription('Status of Copper Link for this device')
ccscf100AISFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100AISFiber.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100AISFiber.setDescription('Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
ccscf100AISCopper = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100AISCopper.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100AISCopper.setDescription('Alarm Indication Signal. When equal to alarm(1), this means that the other end has TAOS enabled and is currently transmitting an alarm condition.')
ccscf100DS3LineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("boost", 1), ("normal", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccscf100DS3LineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100DS3LineBuildout.setDescription('The characteristics of the copper interface')
ccscf100E3DS3 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("e3", 1), ("ds3", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100E3DS3.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100E3DS3.setDescription('This variable indicates whether the current device is the T1 or the E1 version.')
ccscf100CopperLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccscf100CopperLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100CopperLoopback.setDescription('Enable loopback on the copper interface.')
ccscf100FiberLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccscf100FiberLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100FiberLoopback.setDescription('Enable loopback on the copper interface.')
ccscf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 16), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100ConnA.setDescription('The style of Fiber connector built into this device')
ccscf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 17), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100ConnB.setDescription('The style of Copper connector built into this device')
ccscf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 13, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccscf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: ccscf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cfetf105Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14), )
if mibBuilder.loadTexts: cfetf105Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105Table.setDescription('Sparse table containing one entry for each CFTEF105 100Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cfetf105Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1), ).setIndexNames((0, "MCC16-MIB", "cfetf105BiaIndex"), (0, "MCC16-MIB", "cfetf105SlotIndex"))
if mibBuilder.loadTexts: cfetf105Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105Entry.setDescription('Status and configuration entries for a single CFETF105')
cfetf105BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cfetf105SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105SlotIndex.setDescription('The slot in which the device is installed')
cfetf105Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf105Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CFETF105' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cfetf105MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105MRevision.setDescription('The marketing revision of this device')
cfetf105CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cfetf105SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105SerialNumber.setDescription('The serial number of this device')
cfetf105ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105ConnA.setDescription('The style of Fiber connector built into this device')
cfetf105ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105ConnB.setDescription('The style of Copper connector built into this device')
cfetf105TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105TPLink.setDescription('Status of Twisted Pair Link for this device')
cfetf105FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105FiberLink.setDescription('Status of Fiber Link for this device')
cfetf105AutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf105AutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105AutoNegot.setDescription('Enable/Disable Autonegotiation')
cfetf105LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf105LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105LinkPassThrough.setDescription('Enable/Disable for Link Pass Through, a feature that causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see the fault condition.')
cfetf105AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf105AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105AutoCross.setDescription('Enable/Disable for automatic copper TX/RX pair correction')
cfetf105TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105TPActivity.setDescription('Network traffic indicator for Copper side of this device')
cfetf105FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105FiberActivity.setDescription('Network traffic indicator for Fiber side of this device')
cfetf105ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cfetf105CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 14, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf105CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf105CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
smacf100PTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15), )
if mibBuilder.loadTexts: smacf100PTable.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTable.setDescription('Sparse table containing one entry for each SMACF100P virtual slide-in device. This table dexcribes ONE port on a SMACFxxx colony switch')
smacf100PEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1), ).setIndexNames((0, "MCC16-MIB", "smacf100PSubDeviceIndex"), (0, "MCC16-MIB", "smacf100PBiaIndex"), (0, "MCC16-MIB", "smacf100PSlotIndex"))
if mibBuilder.loadTexts: smacf100PEntry.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PEntry.setDescription('Status and configuration entries for a single SMACF100P')
smacf100PSubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PSubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PSubDeviceIndex.setDescription("Generally, individual devices in this MIB are distinguished by BiaIndex and SlotIndex. This device differs from many in that it contains multiple subdevices. The number of subdevices varies with the manufactured configuration. Subdevices within devices are indexed by BiaIndex, SlotIndex, and SubDeviceIndex. When the subdevice column is read from the table, the value '1' is always returned.")
smacf100PBiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PBiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PBiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
smacf100PSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PSlotIndex.setDescription('The slot in which the device is installed')
smacf100PGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PGroups.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PGroups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'SMACF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
smacf100PCfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PCfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PCfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
smacf100PConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 6), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PConnA.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PConnA.setDescription('The style of Fiber or Copper connector built into this device')
smacf100PLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PLink.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PLink.setDescription('Status of Port Link for this device')
smacf100P100Mbps = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mbps100", 1), ("mbps10", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100P100Mbps.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100P100Mbps.setDescription('Communication speed for this port.')
smacf100PFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullDuplex", 1), ("halfDuplex", 2), ("negotiating", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PFullDuplex.setDescription('In most cases this is a configuration setting that controls the duplex mode; fullDuplex is full duplex and halfDuplex is half duplex. On twisted pair ports with autonegotiation enabled, this is a status indication showing the duplex value decided upon during the negotiation. When link is down, autonegotiation has not been completed yet, and the duplex setting is therefore unknown and the value is negotiating(3).')
smacf100PSACStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("same", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PSACStat.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PSACStat.setDescription("This status value indicates whether or not the source MAC address attached to this port changed in the last polling period. This value tends to change quite quickly; therefore, the 'ERROR' traps that are sent when SAC is detected are a much more reliable indicator.")
smacf100PEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PEnabled.setDescription("Status of of this Port. A value of yes(1) indicates this port is 'enabled'. A value of no(2) indicates this port is 'disabled'.")
smacf100PAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAutoNegot.setDescription('Enables or disables autonegtiation of link speed and duplex for twisted pair ports. Not supported on Fiber ports.')
smacf100PAdv10HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAdv10HDX.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAdv10HDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 10Mbps, half duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
smacf100PAdv10FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAdv10FDX.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAdv10FDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 10Mbps, full duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
smacf100PAdv100HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAdv100HDX.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAdv100HDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 100Mbps, half duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
smacf100PAdv100FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAdv100FDX.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAdv100FDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 100Mbps, full duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
smacf100PSTPState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("disabled", 2), ("blocking", 3), ("listening", 4), ("learning", 5), ("forwarding", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PSTPState.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PSTPState.setDescription('Port spanning tree state.')
smacf100PLastMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PLastMAC.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PLastMAC.setDescription('Last MAC Address this port communicated with.')
smacf100PFarEndFaultCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PFarEndFaultCfg.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PFarEndFaultCfg.setDescription('Far end fault configuration of this Port.')
smacf100PFarEndFaultStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PFarEndFaultStat.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PFarEndFaultStat.setDescription('Far end fault status of this port.')
smacf100PTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxOctets.setDescription('The number of bytes of data transmitted through this interface.')
smacf100PWrapTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PWrapTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PWrapTxOctets.setDescription('The number of times that the unsigned 32-bit smacf100PTxOctets(21) MIB variable has wrapped.')
smacf100PRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxOctets.setDescription('The number of bytes of data received through this interface.')
smacf100PWrapRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PWrapRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PWrapRxOctets.setDescription('The number of times that the unsigned 32-bit smacf100PRxOctets(23) MIB variable has wrapped.')
smacf100PSACCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PSACCfg.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PSACCfg.setDescription('Source Address Change detection configuration. Enables or Disables the generation of traps related to source address change for this port. When disabled, the smacf100PSACStat(10) variable always reads no.')
smacf100PBlockMgmt = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PBlockMgmt.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PBlockMgmt.setDescription('Through this variable and others, the SMACF100 supports port- based VLANs. The SMACF100 will pass tags for IEEE 802.3ac VLANs, but will neither insert nor strip them. When this variable is set to block(1), this port may neither transmit packets to nor receive packets from management entities within this switch, i.e. the reporting unit (present in every SMACF100) and the management module (present in SMACF100 Main Management Units). This feature is intended to block traffic between particular Ethernet interfaces inside a single switch; it cannot identify or block management traffic from external sources. A single port is selected for configuration via the slot index. The subdevice index for this variable must always be 1. The logical soundness of VLAN rules cannot be validated. If you set smacf100PBlockMgmt(26) to block(1) on a port that provides a path between a reporting unit and its management module, or between a management module and its Network Management Station, you will be unable to manage the SMACF100 until the situation is rectified (by recabling to work around the misconfiguration, or by resetting the SMACF100 to factory defaults via the serial port).')
smacf100PBlockPort = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PBlockPort.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PBlockPort.setDescription('Through this variable and others, the SMACF100 supports port- based VLANs. The SMACF100 will pass tags for IEEE 802.3ac VLANs, but will neither insert nor strip them. This table allows the network administrator to block traffic between pairs of ports within a single SMACF100. A pair of ports is selected for configuration by specifying a slot index and a subdevice index. The order in which the two ports are specified is unimportant, the effects of the configuration are identical on both ports. Each port has a smacf100PBlockPort(27) entry for every other port. So, communication between ports <p1> and <p2> in cabinet serial <serial> can be blocked by setting either smacf100PBlockPort.<p1>.<serial>.<p2> or smacf100PBlockPort.<p2>.<serial>.<p1> to block(1). Attempts to prevent a port from communicating with itself are ignored. Beyond that, the logical soundness of VLAN rules cannot be validated. There is one entry per subdevice, and one subdevice per port on the SMACF100.')
smacf100PTxDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxDropPkts.setDescription('This counter is incremented every time a transmit packet is dropped due to lack of resources (e.g. transmit FIFO underflow), or an internal MAC sublayer transmit error occurs that is not counted by either TxLateCollision or TxExcessiveCollision counters.')
smacf100PTxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxBroadcastPkts.setDescription('The number of good packets transmitted by this port that are directed to a broadcast address. This counter includes neither errored broadcast packets nor valid multicast packets.')
smacf100PTxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxMulticastPkts.setDescription('The number of good packets transmitted by this port that are directed to a multicast address. This counter includes neither errored multicast packets nor valid broadcast packets.')
smacf100PTxUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxUnicastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxUnicastPkts.setDescription('The number of good packets transmitted by this port that are directed to a unicast address.')
smacf100PTxCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxCollisions.setDescription('The number of collisions experienced by this port during packet transmissions.')
smacf100PTxSingleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxSingleCollision.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxSingleCollision.setDescription('The number of packets successfully transmitted by this port that experienced exactly one collision.')
smacf100PTxMultipleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxMultipleCollision.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxMultipleCollision.setDescription('The number of packets successfully transmitted by this port that experienced more than one collision.')
smacf100PTxDeferredTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxDeferredTransmit.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxDeferredTransmit.setDescription('The number of packets transmitted by a this port for which the first transmission attempt was delayed because the medium was busy.')
smacf100PTxLateCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxLateCollision.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxLateCollision.setDescription('The number of times that a collision was detected later than 512 bit-times into the transmission of a packet.')
smacf100PTxExcessiveCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxExcessiveCollision.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxExcessiveCollision.setDescription('The number of packets that were not transmitted from this port because 16 unsucessful attempts were made to transmit the packet.')
smacf100PTxFrameInDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PTxFrameInDisc.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxFrameInDisc.setDescription('The number of valid packets received which are discarded by the forwarding process due to lack of space on an output queue. This attribute only increments if a network device is not acting in compliance with a flow control request.')
smacf100PTxPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PTxPausePkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PTxPausePkts.setDescription('The number of PAUSE frames transmitted by this port. This implies that the port is in full duplex mode and that 802.3x flow control was enabled at the completion of autonegotiation.')
smacf100PRxUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxUndersizePkts.setDescription('The number of good packets received by this port that are less than 64 bytes long (excluding framing bits but including the Frame Check Sequence).')
smacf100PRxPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PRxPausePkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxPausePkts.setDescription('The number of PAUSE frames recieved by this port. The PAUSE frame must have a valid MAC Control Frame EtherType field (88- 08h), have a destination MAC address of either the MAC Control frame reseved multicast address (01:80:C2:00:00:01), be a minimum of 64 bytes long (excluding preamble but including Frame Check Sequence), and have a valid CRC. Although an 802.3 compliant MAC is only permitted to transmit PAUSE frames when in full duplex mode with flow control enabled and with the transfer of PAUSE frames determined by the result of autonegotiation, an 802.3 MAC receiver is required to count all received PAUSE frames, regardless of its half/full-duplex status. An indication that a MAC is in half-duplex mode with this counter incrementing indicates a non- compliant transmitting device on the network.')
smacf100PPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts64Octets.setDescription('The number of packets, including error packets, that are 64 bytes long.')
smacf100PPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts65to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts65to127Octets.setDescription('The number of packets, including error packets, that are between 65 and 127 bytes long.')
smacf100PPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts128to255Octets.setDescription('The number of packets, including error packets, that are between 128 and 255 bytes long.')
smacf100PPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts256to511Octets.setDescription('The number of packets, including error packets, that are between 256 and 511 bytes long.')
smacf100PPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts512to1023Octets.setDescription('The number of packets, including error packets, that are between 512 and 1023 bytes long.')
smacf100PPkts1024to1522Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PPkts1024to1522Octets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PPkts1024to1522Octets.setDescription('The number of packets, including error packets, that are between 1024 and 1522 bytes long.')
smacf100PRxOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxOversizePkts.setDescription('The number of good packets received by this port that are longer than 1522 bytes inclusive (excluding framing bits but including the Frame Check Sequence). Note that this counter alone will be incremented for packets in the range 1523 to 1536 bytes inclusive, whereas both this counter and the RxExcessSizeDisc counter will be incremented for packets of 1537 bytes and longer.')
smacf100PRxJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxJabbers.setDescription('The number of packets received by a port that are longer than 1522 bytes and have either a Frame Check Sequence error or an alignment error.')
smacf100PRxAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxAlignmentErrors.setDescription('The number of packets received by this port that have a length (excluding framing bits but including the Frame Check Sequence) between 64 and 1522 bytes inclusive, and have a bad Frame Check Sequence with a non-integral number of bytes.')
smacf100PRxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxFCSErrors.setDescription('The number of packets received by this port that have a length (excluding framing bits but including the Frame Check Sequence) between 64 and 1522 bytes inclusive, and have a bad Frame Check Sequence with a integral number of bytes.')
smacf100PRxGoodOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxGoodOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxGoodOctets.setDescription('The total number of bytes in all good packets received by a port (excluding framing bits but including Frame Check Sequences).')
smacf100PWrapRxGoodOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PWrapRxGoodOctets.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PWrapRxGoodOctets.setDescription('The number of times that the unsigned 32-bit smacf100PRxGoodOctets(52) MIB variable for this port has wrapped.')
smacf100PRxDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxDropPkts.setDescription('The number of good packets received by this port that were dropped due to lack of resources (e.g. lack of input buffers) or were dropped due to a lack of resources before a determination of the validity of the packet could be made (e.g. receive FIFO overflow). The counter is only incremented if the receive error was not counted by either the RxExcessSizeDisc, the RxAlignmentErrors or the RxFCSErrors counters.)')
smacf100PRxUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 55), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxUnicastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxUnicastPkts.setDescription('The number of good packets received by this port that are addressed to a unicast address.')
smacf100PRxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxMulticastPkts.setDescription('The number of good packets received by this port that are directed to a multicast address. This counter includes neither errored multicast packets nor valid broadcast packets.')
smacf100PRxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxBroadcastPkts.setDescription('The number of good packets received by this port that are directed to the broadcast address. This counter includes neither errored broadcast packets nor valid multicast packets.')
smacf100PRxSAChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxSAChanges.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxSAChanges.setDescription('The number of times the Source Ethernet Address of good receive packets has changed from the previous value. A count greater than one generally indicates that the port is connected to a repeater-based network.')
smacf100PRxFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 59), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxFragments.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxFragments.setDescription('The number of packets received by a port that are shorter than 64 bytes (excluding framing bits) and have either an Frame Check Sequence error or an alignment error.')
smacf100PRxExcessSizeDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxExcessSizeDisc.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxExcessSizeDisc.setDescription('The number of good packets received by this port that are longer than 1536 bytes (excluding framing bits but including Frame Check Sequences) and were discarded due to excessive length. Note that the RxOversizePkts counter alone is incremented for packets in the range 1523-1536 bytes inclusive, whereas both RxExcessSizeDisc and RxOversizePkts are incremented for packets of 1537 bytes and longer.')
smacf100PRxSymbolError = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PRxSymbolError.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PRxSymbolError.setDescription('The total number of times this port received a packet which had a valid length, but contained at least one invalid symbol. The counter only increments once per carrier event, and does not increment if a collision is detected during the carrier event.')
smacf100PQosPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 62), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PQosPriority.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PQosPriority.setDescription("When this variable is set to 'high(1)', this port becomes a high-priority port. This means that all packets received on this port for transission on other ports and all packets received on other ports for transmission on this port are placed in the high-priority queues. When the variable is set to 'default(2)', the low priority queue is used unless other conditions (i.e. an 802.1p tag or a high-priority setting for another port) prompt the use of the high priority queue.")
smacf100PQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 63), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PQosPause.setDescription("When the global variable smacf100QosEnable(7) is set to 'enabled(1)', then the port-specific variable smacf100PQosPause(63) controls whether or not the port supports half-duplex back pressure and full-duplex flow control. Otherwise, only dropping of frames is supported for the port.")
smacf100PAdvPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 64), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100PAdvPause.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PAdvPause.setDescription("Enable/disable control for this advertised autonegotiation mode. When Pause capability is autonegotiated (at the Physical level), the MAC layer may then send Pause packets to pace data coming across the link. smacf100PAutoNegot(12) must be set to 'enabled(1)'. The results of this autonegotiation are ignored if smacf100QosEnable(7) is set to 'enabled(1)' and smacf100PQosPause(63) is set to 'disabled(2)'. In this case, no 'Pause' capability is supported.")
smacf100PCacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 15, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100PCacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100PCacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cpsld100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16), )
if mibBuilder.loadTexts: cpsld100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Table.setDescription('Sparse table containing one entry for each CPSLD100 in the stack, indexed by cabinet serial number and slot.')
cpsld100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1), ).setIndexNames((0, "MCC16-MIB", "cpsld100BiaIndex"), (0, "MCC16-MIB", "cpsld100SlotIndex"))
if mibBuilder.loadTexts: cpsld100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Entry.setDescription('Status and configuration entries for a single CPSLD100')
cpsld100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsld100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100SlotIndex.setDescription('The slot in which the device is installed')
cpsld100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100SerialNumber.setDescription('The serial number of this device')
cpsld100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100MRevision.setDescription('The marketing revision of this device')
cpsld100Ps1Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100Ps1Power.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Ps1Power.setDescription('Power status, first power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsld100Ps1InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100Ps1InUse.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Ps1InUse.setDescription('Power status, first power supply slot. Value is yes(1) when the power is selected to supply power to the cabinet.')
cpsld100Ps2Power = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100Ps2Power.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Ps2Power.setDescription('Power status, second power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsld100Ps2InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 16, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsld100Ps2InUse.setStatus('mandatory')
if mibBuilder.loadTexts: cpsld100Ps2InUse.setDescription('Power status, second power supply slot. Value is yes(1) when the power is selected to supply power to the cabinet.')
cdftf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17), )
if mibBuilder.loadTexts: cdftf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100Table.setDescription('Sparse table containing one entry for each CDFTF100 Dual telco Media Converter in the stack, indexed by cabinet serial number and slot.')
cdftf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1), ).setIndexNames((0, "MCC16-MIB", "cdftf100SubDeviceIndex"), (0, "MCC16-MIB", "cdftf100BiaIndex"), (0, "MCC16-MIB", "cdftf100SlotIndex"))
if mibBuilder.loadTexts: cdftf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100Entry.setDescription('Status and configuration entries for a single CDFTF100')
cdftf100SubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100SubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100SubDeviceIndex.setDescription("Generally, individual devices in this MIB are distinguished by BiaIndex and SlotIndex. This device differs from many in that it contains multiple subdevices (in this case, switch ports). The number of subdevices varies with the manufactured configuration. Subdevices within devices are indexed by BiaIndex, SlotIndex, and SubDeviceIndex. When the subdevice column is read from the table, the value '1' is always returned.")
cdftf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cdftf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100SlotIndex.setDescription('The slot in which the device is installed')
cdftf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdftf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CDFTF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cdftf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cdftf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100SerialNumber.setDescription('The serial number of this device')
cdftf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100MRevision.setDescription('The marketing revision of the device')
cdftf100TPLinkTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100TPLinkTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100TPLinkTbl.setDescription('This table contains the link status of each twisted pair port in the CDFTF100. There are multiple subdevices in this table, numbering one entry per port.')
cdftf100FiberLinkTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100FiberLinkTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100FiberLinkTbl.setDescription('This table contains the link status of each fiber port in the CDFTF100. There are multiple subdevices in this table, numbering one entry per port.')
cdftf100TPActivityTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100TPActivityTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100TPActivityTbl.setDescription('Netowrk traffic indicator for the copper port(s) on this device. There are multiple subdevices in this table, numbering one entry per port.')
cdftf100FiberActivityTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100FiberActivityTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100FiberActivityTbl.setDescription('Netowrk traffic indicator for the fiber port(s) on this device. There are multiple subdevices in this table, numbering one entry per port.')
cdftf100ConnectorTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100ConnectorTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100ConnectorTbl.setDescription('This table contains the link status of each port of this device. There are multiple subdevices in this table, numbering one entry per port.')
cdftf100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 13), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100FirmwareRevision.setDescription('The style of connectors built into each port of this device.')
cdftf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 17, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdftf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cdftf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cpsvt100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18), )
if mibBuilder.loadTexts: cpsvt100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100Table.setDescription('Sparse table containing one entry for each CPSVT100 in the stack, indexed by cabinet serial number and slot.')
cpsvt100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1), ).setIndexNames((0, "MCC16-MIB", "cpsvt100BiaIndex"), (0, "MCC16-MIB", "cpsvt100SlotIndex"))
if mibBuilder.loadTexts: cpsvt100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100Entry.setDescription('Status and configuration entries for a single CPSVT100')
cpsvt100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cpsvt100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100SlotIndex.setDescription('The slot in which the device is installed')
cpsvt100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CPSVT100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cpsvt100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100MRevision.setDescription('The marketing revision of this device')
cpsvt100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cpsvt100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100SerialNumber.setDescription('The serial number of this device')
cpsvt100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100FiberLink.setDescription('Status of Fiber Link for this device')
cpsvt100CopperLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100CopperLink.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100CopperLink.setDescription('Status of Copper Link for this device')
cpsvt100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100Fault.setDescription('Value is yes(1) when either CopperLink or FiberLink has value linkDown(2)')
cpsvt100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 10), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100ConnA.setDescription('The style of Fiber connector built into this device')
cpsvt100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 11), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100ConnB.setDescription('The style of Copper connector built into this device')
cpsvt100TermTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rxc", 1), ("kbps56", 2), ("kbps64", 3), ("kbps112", 4), ("kbps128", 5), ("kbps256", 6), ("kbps384", 7), ("kbps512", 8), ("kbps768", 9), ("kbps1024", 10), ("kbps1554", 11), ("kbps2048", 12), ("kbps3072", 13), ("kbps4096", 14), ("kbps6144", 15), ("asynchronous", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100TermTiming.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100TermTiming.setDescription('Local Terminal Timing setting. Terminal timing is a signal sent from a DCE to a DTE to control the rate of data the DTE sends to the DCE. Since this signal cannot be sent across the fiber after media converters are introduced, the converter must generate this signal and supply it to the DTE. The converter gets the setting from a thumbwheel. For converters attached to DTEs, the thumbwheel setting influences the transmit data rate. If the Terminal Timing setting is RXC, the DTE derives its transmit clock from the receive clock supplied by the DCE. For converters attached to DCEs, the thumbwheel setting has no effect. If two DTEs are connected via media converters, the thumbwheel settings must not be RXC.')
cpsvt100LoopBack = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100LoopBack.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100LoopBack.setDescription('Remote fiber and copper loopback setting. Loopback is a testing aid available on several different products. When Loopback is enabled on an interface, all data that is sent to the interface is reflected back to the sender, and the actual condition (or even existence) of the equipment on the opposite interface is ignored.')
cpsvt100CableMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notValid", 1), ("rs-530A", 2), ("rs-530", 3), ("x-21", 4), ("v-35", 5), ("rs-449", 6), ("rs-232", 7), ("disconnected", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100CableMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100CableMode.setDescription('A description of the type of cable that is attached to the Copper interface of the local device.')
cpsvt100DCE = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100DCE.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100DCE.setDescription('An indication of whether this device is attached to a DCE (a computer) or a DTE (a terminal). Like cpsvt100CableMode(14), this status is derived from the type of cable that is attached to the copper interface.')
cpsvt100InvertTX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rising", 1), ("falling", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100InvertTX.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100InvertTX.setDescription('Local transmit clock usage. Some types of high-speed serial equipment read the data signal on the rising edge of the clock, and others on the falling edge of the clock. The CPSVT100-xxx High Speed Serial converter is compatible with both types of equipment. The expectations of the equipment attached to the copper interface can be matched via jumper settings on the converter. The cpsvt100InvertTX(16) and cpsvt100InvertRX(17) status variables indicate the status of these jumpers. Most high-speed serial equipment uses the rising edge of the clock.')
cpsvt100InvertRX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rising", 1), ("falling", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100InvertRX.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100InvertRX.setDescription('Local receive clock usage. Some types of high-speed serial equipment read the data signal on the rising edge of the clock, and others on the falling edge of the clock. The CPSVT100-xxx High Speed Serial converter is compatible with both types of equipment. The expectations of the equipment attached to the copper interface can be matched via jumper settings on the converter. The cpsvt100InvertTX(16) and cpsvt100InvertRX(17) status variables indicate the status of these jumpers. Most high-speed serial equipment uses the rising edge of the clock.')
cpsvt100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cpsvt100FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100FirmwareRev.setDescription('Local firmware revision.')
cpsvt100RmtDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100RmtDetected.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtDetected.setDescription('Has the value yes(1) if management communcations have been established with a remote media converter.')
cpsvt100RmtTermTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rxc", 1), ("kbps56", 2), ("kbps64", 3), ("kbps112", 4), ("kbps128", 5), ("kbps256", 6), ("kbps384", 7), ("kbps512", 8), ("kbps768", 9), ("kbps1024", 10), ("kbps1554", 11), ("kbps2048", 12), ("kbps3072", 13), ("kbps4096", 14), ("kbps6144", 15), ("asynchronous", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtTermTiming.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtTermTiming.setDescription('Local Terminal Timing setting of the remotely managed CPSVTxxx. Terminal timing is a signal sent from a DCE to a DTE to control the rate of data the DTE sends to the DCE. Since this signal cannot be sent across the fiber after media converters are introduced, the converter must generate this signal and supply it to the DTE. The converter gets the setting from a thumbwheel. For converters attached to DTEs, the thumbwheel setting influences the transmit data rate. If the Terminal Timing setting is RXC, the DTE derives its transmit clock from the receive clock supplied by the DCE. For converters attached to DCEs, the thumbwheel setting has no effect. If two DTEs are connected via media converters, the thumbwheel settings must not be RXC.')
cpsvt100RmtLoopBack = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtLoopBack.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtLoopBack.setDescription('Remote fiber and copper loopback setting. Loopback is a testing aid available on several different products. When Loopback is enabled on an interface, all data that is sent to the interface is reflected back to the sender, and the actual condition (or even existence) of the equipment on the opposite interface is ignored. This variable is identical to cpsvt100LoopBack, except that it is for the remotely managed cpsvt100.')
cpsvt100RmtCableMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtCableMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtCableMode.setDescription('A description of the type of cable that is attached to the Copper interface of the local device.')
cpsvt100RmtDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtDCE.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtDCE.setDescription('An indication of whether this device is attached to a DCE (a computer) or a DTE (a terminal). Like cpsvt100CableMode(14), this status is derived from the type of cable that is attached to the copper interface.')
cpsvt100RmtInvertTX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtInvertTX.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtInvertTX.setDescription('Local transmit clock usage. Some types of high-speed serial equipment read the data signal on the rising edge of the clock, and others on the falling edge of the clock. The CPSVT100-xxx High Speed Serial converter is compatible with both types of equipment. The expectations of the equipment attached to the copper interface can be matched via jumper settings on the converter. The cpsvt100InvertTX(16) and cpsvt100InvertRX(17) status variables indicate the status of these jumpers. Most high-speed serial equipment uses the rising edge of the clock.')
cpsvt100RmtInvertRX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsvt100RmtInvertRX.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtInvertRX.setDescription('Local receive clock usage. Some types of high-speed serial equipment read the data signal on the rising edge of the clock, and others on the falling edge of the clock. The CPSVT100-xxx High Speed Serial converter is compatible with both types of equipment. The expectations of the equipment attached to the copper interface can be matched via jumper settings on the converter. The cpsvt100InvertTX(16) and cpsvt100InvertRX(17) status variables indicate the status of these jumpers. Most high-speed serial equipment uses the rising edge of the clock.')
cpsvt100RmtConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100RmtConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cpsvt100RmtFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100RmtFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtFirmwareRev.setDescription('Local firmware revision.')
cpsvt100RmtCopperLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100RmtCopperLink.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtCopperLink.setDescription('Status of Copper Link for this device')
cpsvt100RmtFiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100RmtFiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100RmtFiberLink.setDescription('Status of Fiber Link for this device')
cpsvt100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 18, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsvt100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cpsvt100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cemtf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19), )
if mibBuilder.loadTexts: cemtf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100Table.setDescription('Sparse table containing one entry for each CEMTF100 in the stack, indexed by cabinet serial number and slot.')
cemtf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1), ).setIndexNames((0, "MCC16-MIB", "cemtf100BiaIndex"), (0, "MCC16-MIB", "cemtf100SlotIndex"))
if mibBuilder.loadTexts: cemtf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100Entry.setDescription('Status and configuration entries for a single CEMTF100')
cemtf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cemtf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100SlotIndex.setDescription('The slot in which the device is installed')
cemtf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cemtf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CEMTF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cemtf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100MRevision.setDescription('The marketing revision of this device')
cemtf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cemtf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100SerialNumber.setDescription('The serial number of this device')
cemtf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100FiberLink.setDescription('Status of Fiber Link for this device')
cemtf100OffHook = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100OffHook.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100OffHook.setDescription('Status of Twisted Pair Link for this device')
cemtf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100Fault.setDescription('Value is yes(1) when either OffHook or FiberLink has value of down')
cemtf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 10), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100ConnA.setDescription('The style of Fiber connector built into this device')
cemtf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 11), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100ConnB.setDescription('The style of Copper connector built into this device')
cemtf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 19, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cemtf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cemtf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
captf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20), )
if mibBuilder.loadTexts: captf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: captf100Table.setDescription('Sparse table containing one entry for each CAPTF100 in the stack, indexed by cabinet serial number and slot.')
captf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1), ).setIndexNames((0, "MCC16-MIB", "captf100BiaIndex"), (0, "MCC16-MIB", "captf100SlotIndex"))
if mibBuilder.loadTexts: captf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: captf100Entry.setDescription('Status and configuration entries for a single CAPTF100')
captf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: captf100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
captf100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: captf100SlotIndex.setDescription('The slot in which the device is installed')
captf100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: captf100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: captf100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CAPTF100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
captf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: captf100MRevision.setDescription('The marketing revision of this device')
captf100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: captf100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
captf100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: captf100SerialNumber.setDescription('The serial number of this device')
captf100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: captf100FiberLink.setDescription('Status of Fiber Link for this device')
captf100InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100InUse.setStatus('mandatory')
if mibBuilder.loadTexts: captf100InUse.setDescription('Status of Twisted Pair Link for this device')
captf100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: captf100Fault.setDescription('Value is yes(1) when either OffHook or FiberLink has value of down')
captf100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 10), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: captf100ConnA.setDescription('The style of Fiber connector built into this device')
captf100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 11), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: captf100ConnB.setDescription('The style of Copper connector built into this device')
captf100FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: captf100FirmwareRev.setDescription('The firmware revision level for this device.')
captf100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: captf100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
captf100Emulates = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 20, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("phone", 1), ("coStandard", 2), ("coAutoRingDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captf100Emulates.setStatus('mandatory')
if mibBuilder.loadTexts: captf100Emulates.setDescription("This read-only variable indicates the emulation type and configuration of the device. CAPTF100 devices exist in two varieties, the CAPTF10033xx-100, the copper port of which emulates a telephone, and the CAPTF10033xx-110, the copper port of which emulates the Central Office (CO) (i.e. a wall jack that one would plug a telephone into). The Standard CAPTF100 configuration is employed when a fiber extension between a wall jack and a distant telephone is desired. The CAPTF100 whose copper port was plugged into the wall jack must be of the variety that emulates a telephone. The value of the captf100Emulates(14) variable of such a device will be phone(1). The CAPTF100 whose copper port was plugged into the telephone must be of the variety that emulates the CO, and that device must be jumpered for 'Standard' operation. The value of its captf100Emulates(14) variable would be coStandard(2). Alternatively, CAPTF100 converters can be used to provide a point-to-point fiber link between two telephones. This is known as the Automatic Ring-Down configuration. When one telephone goes off-hook, the other rings. When both are off hook, voice communication is possible. In this configuration, both CAPTF100 devices must be of the variety that emulates the CO, and both devices must be jumpered for 'Automatic Ring-Down' operation. The value of their captf100Emulates(14) variables would be coAutoRingDown(3).")
cfetf205Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21), )
if mibBuilder.loadTexts: cfetf205Table.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Table.setDescription('Sparse table containing one entry for each CFTEF205 100Mbps Twisted-Pair to Fiber Ethernet Media Converter in the stack, indexed by cabinet serial number and slot.')
cfetf205Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1), ).setIndexNames((0, "MCC16-MIB", "cfetf205BiaIndex"), (0, "MCC16-MIB", "cfetf205SlotIndex"))
if mibBuilder.loadTexts: cfetf205Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Entry.setDescription('Status and configuration entries for a single CFETF205')
cfetf205BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
cfetf205SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205SlotIndex.setDescription('The slot in which the device is installed')
cfetf205Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CFETF205' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
cfetf205MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205MRevision.setDescription('The marketing revision of this device')
cfetf205CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cfetf205SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205SerialNumber.setDescription('The serial number of this device')
cfetf205ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205ConnA.setDescription('The style of Fiber connector built into this device')
cfetf205ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205ConnB.setDescription('The style of Copper connector built into this device')
cfetf205TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205TPLink.setDescription('Status of Twisted Pair Link for this device')
cfetf205FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205FiberLink.setDescription('Status of Fiber Link for this device')
cfetf205Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205Fault.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Fault.setDescription('Value is yes(1) when either TPLink or FiberLink has value linkDown(2)')
cfetf205FastLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autonegotiate", 1), ("hdx100Btx", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205FastLinkPulse.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205FastLinkPulse.setDescription("When set to autonegotiate(1), converter sends Fast Link Pulses on its twisted pair port, thereby participating in autonegotiation of duplex between the converter's twisted pair port and that of the connected station. If that station supports Full- Duplex (FDX) operation, FDX will be used. If not, the twisted pair will operate in Half-Duplex (HDX) mode. When set to hdx100Btx(2), the converter instead sends 100Mbps idles (rather than Fast Link Pulses) on its twisted pair port (i.e. it declines to negotiate), which forces the twisted pair to operate in HDX mode regardless of the capabilities of the connected station. When operating in HDX mode, the twisted pair can support traffic in only one direction at a time. In FDX mode, traffic can pass in both directions simultaneously, thus theoretically doubling network performance.")
cfetf205Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Enabled.setDescription('When this configuration item is set to no(2), the device passes no network traffic.')
cfetf205Pause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205Pause.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205Pause.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. Support for Pause is negotiated at the physical level and passed up to the MAC. While the MAC's Pause messages themselves can pass over the fiber link that this pair of media converters introduces, the TP physical layer negotiations to enable Pause can not. Therefore, if both end station MACs support Pause and wish to use it, the Pause negotiation must be re-generated by the media converters on both ends. By setting this configuration option to enabled(1), you are indicating to the local twisted pair station that the twisted pair station on the other side of the other media converter supports Pause and wishes to use it. This variable must be set consistently on both of the paired media converters.")
cfetf205LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205LinkPassThrough.setDescription('Enable/Disable for Link Pass Through, a feature that causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see the fault condition.')
cfetf205AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205AutoCross.setDescription('Enable/Disable for automatic copper TX/RX pair correction. When disabled, the port operates in MDI mode.')
cfetf205TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205TPActivity.setDescription('Network traffic indicator for Copper side of this device')
cfetf205FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205FiberActivity.setDescription('Network traffic indicator for Fiber side of this device')
cfetf205ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cfetf205FarEndFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfetf205FarEndFault.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205FarEndFault.setDescription('Far End Fault configuration of this device. Far End Fault causes the fiber transmitter to generate a Far End Fault pattern upon the loss of a receiver signal detect. When the receiver detects signal again, the transmitter stops transmitting the Far End Fault pattern.')
cfetf205CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 21, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfetf205CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cfetf205CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cbftf150Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22), )
if mibBuilder.loadTexts: cbftf150Table.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150Table.setDescription("Sparse table containing one entry for each CBFTF150 switch in the stack. Indexed by sub-device index, cabinet serial number, and slot. Note that some columns of this table support multiple subdevices, and some do not. For example, there is exactly one SerialNumber for each CBFTF150. No subdevices exist, so the placeholder value 1 is used as the subdevice index. However, a CBFTF150 has multiple switch ports, which are indexed as different subdevices, starting with 1. Columns with subdevices have names ending in 'Tbl'")
cbftf150Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1), ).setIndexNames((0, "MCC16-MIB", "cbftf150SubDeviceIndex"), (0, "MCC16-MIB", "cbftf150BiaIndex"), (0, "MCC16-MIB", "cbftf150SlotIndex"))
if mibBuilder.loadTexts: cbftf150Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150Entry.setDescription('Status and configuration entries for a single CBFTF150')
cbftf150SubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150SubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150SubDeviceIndex.setDescription("Generally, individual devices in this MIB are distinguished by BiaIndex and SlotIndex. This device differs from many in that it contains multiple subdevices (in this case, switch ports). The number of subdevices varies with the manufactured configuration. Subdevices within devices are indexed by BiaIndex, SlotIndex, and SubDeviceIndex. When the subdevice column is read from the table, the value '1' is always returned.")
cbftf150BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150SlotIndex.setDescription('The slot in which the device is installed. Power Supplies occupy special slots numbered 125 and higher. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'cbftf150' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]' There are no subdevices for this value, so the placeholder value 1 is always used for that index.")
cbftf150MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150MRevision.setDescription('The marketing revision of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150SerialNumber.setDescription('The serial number of this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150ConfigMode.setDescription('This device may have a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150FirmwareRevision.setDescription('The firmware revision level for this device. There are no subdevices for this value, so the placeholder value 1 is always used for that index.')
cbftf150FormFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("s1W2a", 1), ("s1W1N2a", 2), ("s1W1N1a", 3), ("s2W2N4a", 4), ("s2W1N5a", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150FormFactor.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150FormFactor.setDescription('A code corresponding to a physical configuration of the product. This code indicates the number of slots occupied and the number of physical connectors present. In the labels for the values above, s indicates the number of slots occupied, W is a count of Wide port positions (which can built as almost any type of connector), and N is a count of narrow port positions (which are typically twisted pair ports). The lowercase letter at the end differentiates different form factors that would otherwise have identical descriptions under this limited scheme.')
cbftf150AutoNegotTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150AutoNegotTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150AutoNegotTbl.setDescription('Enables or disables autonegtiation of link speed and duplex for twisted pair ports. Not supported on Fiber ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150FullDuplexTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullDuplex", 1), ("halfDuplex", 2), ("negotiating", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150FullDuplexTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150FullDuplexTbl.setDescription('In most cases this is a configuration setting that controls the duplex mode; fullDuplex is full duplex and halfDuplex is half duplex. On twisted pair ports with autonegotiation enabled, this is a status indication showing the duplex value decided upon during the negotiation. When link is down, autonegotiation has not been completed yet, and the duplex setting is therefore unknown and the value is negotiating(3). There are multiple subdevices in this table, numbering one entry per port.')
cbftf150100MbpsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mbps100", 1), ("mbps10", 2), ("negotiating", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150100MbpsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150100MbpsTbl.setDescription('In most cases this is a configuration setting that controls the link speed. On twisted pair ports with autonegotiation enabled, this is a status indication showing the link speed decided upon during negotiation. When link is down, autonegotiation has not been completed yet, and the link speed is therefore unknown and is negotiating(3). This variable is an indicator only for fiber ports; all fiber ports report mbps100(1) at all times. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150CrossTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("mdi", 2), ("mdix", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150CrossTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150CrossTbl.setDescription('Configuration setting for copper TX/RX pair correction. A setting of auto(1) causes the port to automatically correct TX/RX pairs if necessary. If autonegotiation is disabled on the port, the auto(1) setting is not supported. A setting of mdi(2) causes the TX/RX pairs to be passed straight through with no correction. A setting of mdix(3) causes the TX/RX pairs to be swapped. This setting is supprted for copper ports only; a read-only value of notSupported(4) is returned for fiber ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150FarEndFaultTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbftf150FarEndFaultTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150FarEndFaultTbl.setDescription('When Far End Fault is set to enabled(1), a loss of link on receive will cause the transmitter to shut down, in order to inform the device at the far end of the link that a fault has occurred. Far End Fault is only supported on fiber ports. A read-only value of notSupported(3) is returned for copper ports. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150ConnectorTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 16), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150ConnectorTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150ConnectorTbl.setDescription('The style of connectors built into each port of this device. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150LinkTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150LinkTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150LinkTbl.setDescription('This table contains the link status of each port in the switch. There are multiple subdevices in this table, numbering one entry per port.')
cbftf150PortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150PortCount.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150PortCount.setDescription('A count of the switch ports in this device. i.e. the maximum subdevice index supported by this switch.')
cbftf150CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 22, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbftf150CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cbftf150CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cgfeb100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23), )
if mibBuilder.loadTexts: cgfeb100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100Table.setDescription('Sparse table containing one entry for each CGFEB100 10/100/1000 Ethernet to Fiber converter in the stack. Indexed by cabinet serial number and slot.')
cgfeb100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1), ).setIndexNames((0, "MCC16-MIB", "cgfeb100BiaIndex"), (0, "MCC16-MIB", "cgfeb100SlotIndex"))
if mibBuilder.loadTexts: cgfeb100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100Entry.setDescription('Status and configuration entries for a single CGFEB100')
cgfeb100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed.')
cgfeb100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100SlotIndex.setDescription('The slot in which the device is installed. Power Supplies occupy special slots numbered 125 and higher.')
cgfeb100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'cgfeb100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'.")
cgfeb100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100MRevision.setDescription('The marketing revision of this device.')
cgfeb100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
cgfeb100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100SerialNumber.setDescription('The serial number of this device.')
cgfeb100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100ConfigMode.setDescription('This device may have a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
cgfeb100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FirmwareRevision.setDescription('The firmware revision level for this device.')
cgfeb100SelfTestFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100SelfTestFailed.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100SelfTestFailed.setDescription('This variable indicates the status of the pass/fail power on test. If the power on test fails, normal operation of this device is probably not possible.')
cgfeb100MonitorType = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fiber", 1), ("twistedPair", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100MonitorType.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100MonitorType.setDescription("Some versions of this device support the monitoring of network traffic passing through the converter's fiber interface via a dedicated monitoring port to which a capture device can be attached. There are two different versions of the monitoring capability. One has a fiber connector, and the other has a twisted pair connector. Both versions monitor the fiber port. If this variable has the value fiber(1) or twistedPair(2), this means that a monitoring port is present and that port has the specified type of interface. In this case, the device occupies two slots. If the value is notInstalled(3), there is no monitoring capability and the device occupies one slot. See also cgfeb100MonitorTap(56).")
cgfeb100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100LinkPassThrough.setDescription('This configuration item allows Link Pass Through to be enabled(1) or disabled(2). Link Passthrough causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see fault conditions that would otherwise be hidden by the media converters. On some models, the Link Passthrough logic views receipt of a Far End Fault error pattern as being equivalent to loss of link. The net effect of this is that when either fiber is disconnected, link is dropped on the other side of the converter. Normally, only the disconnection of the Receive fiber would cause this reaction. ')
cgfeb100QosEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100QosEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100QosEnabled.setDescription('This variable allows Quality of Service functions to be enabled or disabled. This includes the processing of 802.1p tags (See cgfeb100QosHPThreshold(13), cgfeb100QosLqWeight(14), and smacf100QosHqWeight(15)), and half-duplex back pressure and full-duplex flow control. (See cgfeb100TpQosPause(39) and cgfeb100FiberQosPause(52)).')
cgfeb100QosHPThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100QosHPThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100QosHPThreshold.setDescription("When an incoming 802.1p priority tag value is greater than or equal to this value (from 0 to 7), the incoming packet will be classified as high-priority. Ignored when cgfeb100QosEnable(13) is set to 'disabled(2)'.")
cgfeb100QosLqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100QosLqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100QosLqWeight.setDescription("A value between 1 and 15 indicating the number of packets that should be processed from the low-priority queue before attention is turned to the high-priority queue. Ignored when cgfeb100QosEnable(13) is set to 'disabled(2)'.")
cgfeb100QosHqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100QosHqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100QosHqWeight.setDescription("A value between 1 and 15 indicating the number of packets that should be processed from the high-priority queue before attention is turned to the low-priority queue. Ignored when cgfeb100QosEnable(13) is set to 'disabled(2)'.")
cgfeb100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 16), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100ConnA.setDescription('The style of copper connector built into this device.')
cgfeb100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLink.setDescription('Twisted Pair link status.')
cgfeb100TPSpeedCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mbps10", 1), ("mbps100", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPSpeedCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPSpeedCfg.setDescription('The desired speed of the Twisted Pair interface. This speed can be set to 10Mbps(1) or 100Mbps(2). Operation at 1000Mbps requires autonegotiation. When cgfeb100TpAutonegot(24) has the value enabled(1) or cgfeb100ConfigMode(7) has the value hardware(2), this variable has the read-only value auto(3).')
cgfeb100TPSpeedStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mbps10", 1), ("mbps100", 2), ("mbps1000", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPSpeedStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPSpeedStat.setDescription('The actual speed of the Twisted Pair interface: 10Mbps(1), 100Mbps(2), or 1000Mbps(3). If cgfeb100TpAutonegot(24) has the value enabled(1) and cgfeb100TpLink(17) has the value down(2), this variable has the value notApplicable(4).')
cgfeb100TPFullDuplexCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fdx", 1), ("hdx", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPFullDuplexCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPFullDuplexCfg.setDescription('The desired duplex setting of the Twisted Pair interface. This can be set to fdx(1) (full duplex) or hdx(2) (half duplex). When cgfeb100TpAutonegot(24) has the value enabled(1) or cgfeb100ConfigMode(7) has the value hardware(2), this variable has the read-only value auto(3).')
cgfeb100TPFullDuplexStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fdx", 1), ("hdx", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPFullDuplexStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPFullDuplexStat.setDescription('The actual duplex behavior of the Twisted Pair interface. If cgfeb100TpAutonegot(24) has the value enabled(1) and cgfeb100TpLink(17) has the value down(2), this variable has the value notApplicable(4).')
cgfeb100TPCrossCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mdi", 1), ("mdix", 2), ("auto", 3), ("notApplicable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPCrossCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPCrossCfg.setDescription('The desired TX/RX Pair orientation of the Twisted Pair interface. This can be set to mdi(1) (straight through), mdix(2) (crossed over), or auto(3). When cgfeb100ConfigMode(7) has the value hardware(2), this variable has the read-only value notApplicable(4).')
cgfeb100TPCrossStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mdi", 1), ("mdix", 2), ("auto", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPCrossStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPCrossStat.setDescription('The actual TX/RX Pair orientation of the Twisted Pair interface, usually mdi(1) (straight through) or mdix(2) (crossed over). When the device does not know the pair orientation, this variable has the value auto(3). Depending on the version of the device, it may not be able to report the pair orientation when it is decided automatically. The device will never have an orientation to report when If cgfeb100TpCrossConfig(22) has the value auto(3) and cgfeb100TpLink(17) has the value down(2).')
cgfeb100TPAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAutoNegot.setDescription('Enables or disables autonegtiation of link speed and duplex for twisted pair ports. Not supported on Fiber ports.')
cgfeb100TPAdv10HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv10HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv10HDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPAdv10FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv10FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv10FDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPAdv100HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv100HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv100HDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPAdv100FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv100FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv100FDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv1000HDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdv1000FDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read- only values enabledRO(4) or disabledRO(5).')
cgfeb100TPLpAdvPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("symetric", 1), ("asymRX", 2), ("asymTX", 3), ("disabled", 4), ("notApplicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdvPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdvPause.setDescription("This read-only variable shows the pause capability advertised by the twisted pair port's link partner. Values 1 through 4 for this variable are the same as those for cgfeb100TpAdvPause(38). If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(5).")
cgfeb100TPLpAdv10HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPLpAdv10HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv10HDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 10Mbps Half Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPLpAdv10FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdv10FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv10FDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 10Mbps Full Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPLpAdv100HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdv100HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv100HDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 100Mbps Half Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPLpAdv100FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdv100FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv100FDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 100Mbps Full Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPLpAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv1000HDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 1000Mbps Half Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPLpAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPLpAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPLpAdv1000FDX.setDescription("This read-only variable shows twisted pair port's link partner's willingness to connect at 1000Mbps Full Duplex. If the device does not support the reporting of link partner autonegotiation or cgfeb100TpAutonegot(24) has the value disabled(2), this variable will have the value notApplicable(3).")
cgfeb100TPAdvPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("symetric", 1), ("asymRX", 2), ("asymTX", 3), ("disabled", 4), ("notApplicable", 5), ("symmetricRO", 6), ("asymRXRO", 7), ("asymTXRO", 8), ("disabledRO", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPAdvPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPAdvPause.setDescription('Enable/disable control for autonegotiation advertising of Twisted Pair Pause capability. Selectable values are symmetric(1), asymRX(2) (asymmetric, pause frames flow towards the converter), asymTX(3) (asymmetric, pause frames flow towards the link partner), and disabled(4). If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then this variable has no meaning and the read-only value notApplicable(5) is returned. When cgfeb100TpQosPause(39) has the value disabled(2), negotiated pause is suppressed and the read-only value notApplicable(5) is returned. If cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is enabled, then one of the following read-only values will be returned: symmetricRO(6), asymRXRO(7) (asymmetric, pause frames flow towards the converter), asymTXRO(8) (asymmetric, pause frames flow towards the link partner), and disabledRO(9).')
cgfeb100TPQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPQosPause.setDescription('This variable allows Twisted Pair Quality Of Service Pause to be enabled or disabled. When cgfeb100QosEnabled(12) is set to enabled(1) and this variable is set to disabled(2), any pause functionality negotiated according to cgfeb100TpAdvPause(38) is suppressed. When cgfeb100QosEnabled(12) is set to disabled(2), this variable has the read-only value notApplicable(3).')
cgfeb100TPSacCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100TPSacCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPSacCfg.setDescription("This variable allows Source Address Change traps to be enabled or disabled. If enabled, 'Error' traps will be sent as frequently one per polling cycle any time the ethernet source address of any packet received on the Twisted Pair interface is different from the last address received on that interface during the previous polling cycle.")
cgfeb100TPSacStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("constant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100TPSacStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100TPSacStat.setDescription("This read-only variable has the value changed(1) if the Ethernet source address received on the Twisted Pair interface changed since the device's previous report to the Mangement Module, and the value constant(2) otherwise. To cause the Management Module to generate a trap when this occurs, set cgfeb100SacConfig(41) to enabled(1).")
cgfeb100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 42), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100ConnB.setDescription('The style of Fiber connector built into this device.')
cgfeb100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberLink.setDescription('The Fiber Link status for this device.')
cgfeb100FiberFullDuplexCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fdx", 1), ("hdx", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberFullDuplexCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberFullDuplexCfg.setDescription('The desired duplex setting of the Fiber interface. This can be set to fdx(1) (full duplex) or hdx(2) (half duplex). When cgfeb100TpAutonegot(24) has the value enabled(1) or cgfeb100ConfigMode(7) has the value hardware(2), this variable has the read-only value auto(3).')
cgfeb100FiberFullDuplexStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fdx", 1), ("hdx", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100FiberFullDuplexStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberFullDuplexStat.setDescription('The actual duplex behavior of the Fiber interface: fdx(1) (full duplex) or hdx(2) (half duplex). If cgfeb100FiberAutonegot(46) has the value disabled(2) and this version of the device does not support manual fiber duplex control, Fiber duplex is forced to HDX. If cgfeb100FiberAutonegot(46) has the value enabled(1) and cgfeb100FiberLink(43) has the value down(2), then no duplex setting is available, and this variable has the value notApplicable(3).')
cgfeb100FiberAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberAutoNegot.setDescription("Autonegotiation configuration. Fiber autonegotiation is limited to the duplex setting. The fiber's speed is fixed at 1000Mbps.")
cgfeb100FiberAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberAdv1000HDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read-only values enabledRO(4) or disabledRO(5). If manual control of Fiber Autonegotiaion advertised modes is not supported by the device, this variable has no meaning and the read-only value notApplicable(3) is returned.')
cgfeb100FiberAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberAdv1000FDX.setDescription('Enable/disable control for these advertised autonegotiation modes. If autonegotiation is disabled (because cgfeb100TpAutonegot(24) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then these variables have no meaning and return read-only value notApplicable(3). If the value cannot be changed (because cgfeb100ConfigMode(7) has the value hardware(2)) and Autonegotiation is enabled, these variables return the read-only values enabledRO(4) or disabledRO(5). If manual control of Fiber Autonegotiaion advertised modes is not supported by the device, this variable has no meaning and the read-only value notApplicable(3) is returned.')
cgfeb100FiberLpAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3), ("enabledRO", 4), ("disabledRO", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberLpAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberLpAdv1000HDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 1000Mbps, half duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
cgfeb100FiberLpAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberLpAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberLpAdv1000FDX.setDescription('This configuration setting controls whether or not each port advertises willingness to connect at 1000Mbps, full duplex. This setting is not supported on fiber ports, and is ignored when autonegotiation is disabled.')
cgfeb100FiberLpAdvPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("symetric", 1), ("asymRX", 2), ("asymTX", 3), ("disabled", 4), ("notApplicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100FiberLpAdvPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberLpAdvPause.setDescription("This read-only variable shows the pause capability advertised by the fiber port's link partner. Values 1 through 4 for this variable are the same as those for cgfeb100TpAdvPause(38). If the device does not support the reporting of link partner autonegotiation or cgfeb100FiberAutonegot(46) has the value disabled(2), this variable will have the value notApplicable(5).")
cgfeb100FiberAdvPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("symetric", 1), ("asymRX", 2), ("asymTX", 3), ("disabled", 4), ("notApplicable", 5), ("symetricRO", 6), ("asymRXRO", 7), ("asymTXRO", 8), ("disabledRO", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberAdvPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberAdvPause.setDescription('Enable/disable control for autonegotiation advertising of Fiber Pause capability. Selectable values are symmetric(1), asymRX(2) (asymmetric, pause frames flow towards the converter), asymTX(3) (asymmetric, pause frames flow towards the link partner), and disabled(4). If autonegotiation is disabled (because cgfeb100FiberAutonegot(46) has the value disabled(2) or cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is disabled), then this variable has no meaning and the read-only value notApplicable(5) is returned. cgfeb100FiberQosPause(53) has the value disabled(2), negotiated pause is suppressed and the read-only value notApplicable(5) is returned. If cgfeb100ConfigMode(7) has the value hardware(2) and the Autonegotiation hardware switch is enabled, then one of the following read-only values will be returned: symmetricRO(6), asymRXRO(7) (asymmetric, pause frames flow towards the converter), asymTXRO(8) (asymmetric, pause frames flow towards the link partner), and disabledRO(9).')
cgfeb100FiberQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberQosPause.setDescription('This variable allows Fiber Quality Of Service Pause to be enabled or disabled. When cgfeb100QosEnabled(12) is set to enabled(1) and this variable is set to disabled(2), any pause functionality negotiated according to cgfeb100FiberAdvPause(52) is suppressed. When cgfeb100QosEnabled(12) is set to disabled(2), this variable has the read-only value notApplicable(3).')
cgfeb100FiberSacCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberSacCfg.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberSacCfg.setDescription("This variable allows Source Address Change traps to be enabled or disabled. If enabled, 'Error' traps will be sent as frequently one per polling cycle any time the ethernet source address of any packet received on the Fiber interface is different from the last address received on that interface during the previous polling cycle.")
cgfeb100FiberSacStat = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("constant", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100FiberSacStat.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100FiberSacStat.setDescription("This read-only variable has the value changed(1) if the Ethernet source address received on the fiber interface changed since the device's previous report to the Mangement Module, and the value constant(2) otherwise. To cause the Management Module to generate a trap when this occurs, set cgfeb100FiberSacConfig(54) to enabled(1).")
cgfeb100MonitorTap = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transmit", 1), ("receive", 2), ("notInstalled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgfeb100MonitorTap.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100MonitorTap.setDescription('Before reading this description, see cgfeb100MonitorType(10). This variable controls which side of the fiber port (transmit(1) or receive(2)) is monitored by the monitoring port. If no monitoring port is present, this variable has the value notInstalled(3).')
cgfeb100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 23, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cgfeb100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cgfeb100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
crmfe100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24), )
if mibBuilder.loadTexts: crmfe100Table.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Table.setDescription('Sparse table containing one entry for each CRMFE100 in the stack, indexed by cabinet serial number and slot.')
crmfe100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1), ).setIndexNames((0, "MCC16-MIB", "crmfe100BiaIndex"), (0, "MCC16-MIB", "crmfe100SlotIndex"))
if mibBuilder.loadTexts: crmfe100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Entry.setDescription('Status and configuration entries for a single CRMFE100')
crmfe100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
crmfe100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100SlotIndex.setDescription('The slot in which the device is installed')
crmfe100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CRMFE100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
crmfe100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100MRevision.setDescription('The marketing revision of this device')
crmfe100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
crmfe100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100SerialNumber.setDescription('The serial number of this device')
crmfe100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100ConnA.setDescription('The style of Fiber connector built into this device')
crmfe100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100ConnB.setDescription('The style of Copper connector built into this device')
crmfe100TPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100TPLink.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100TPLink.setDescription('Status of Copper Link for this device')
crmfe100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FiberLink.setDescription('Status of Fiber Link for this device')
crmfe100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Fault.setDescription('Value is yes(1) when either CopperLink or FiberLink has value linkDown(2)')
crmfe100Autonegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100Autonegot.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Autonegot.setDescription('Autonegotiation configuration for this device.')
crmfe100Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100Enabled.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Enabled.setDescription('When the Enabled configuration item is set to no(2), the converter passes no network traffic in either direction.')
crmfe100Pause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100Pause.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100Pause.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. Support for Pause is negotiated at the physical level and passed up to the MAC. While the MAC's Pause messages themselves can pass over the fiber link that this pair of media converters introduces, the TP physical layer negotiations to enable Pause can not. Therefore, if both end station MACs support Pause and wish to use it, the Pause negotiation must be re-generated by the media converters on both ends. By setting this configuration option to enabled(1), you are indicating to the local twisted pair station that the twisted pair station on the other side of the other media converter supports Pause and wishes to use it. This variable must be set consistently on both of the paired media converters.")
crmfe100LinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100LinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100LinkPassThrough.setDescription('This configuration item allows Link Pass Through to be enabled(1) or disabled(2). Link Passthrough causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see fault conditions that would otherwise be hidden by the media converters.')
crmfe100AutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100AutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100AutoCross.setDescription("On certain devices, it is possible for hardware to automatically correct errors in cable selection, making the distinction between a 'straight through' cable and a 'crossover' cable unimportant. This capability is known as Auto Cross. When disabled, the port reverts to MDI mode.")
crmfe100TPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100TPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100TPActivity.setDescription('Twisted Pair Activity. Some versions of the CRMFE100 do not support the reporting of interface activity. The value of this variable for such a device will be notApplicable.')
crmfe100FiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100FiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FiberActivity.setDescription('Fiber Activity. Some versions of the CRMFE100 do not support the reporting of interface activity. The value of this variable for such a device will be notApplicable.')
crmfe100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
crmfe100FarEndFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100FarEndFault.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FarEndFault.setDescription('Far End Fault configuration of this device. Far End Fault causes the fiber transmitter to generate a Far End Fault pattern upon the loss of a receiver signal detect. When the receiver detects signal again, the transmitter stops transmitting the Far End Fault pattern.')
crmfe100NetworkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tokenRing", 1), ("ethernet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100NetworkMode.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100NetworkMode.setDescription('Read-only indicator for High Speed Token Ring jumper configuration. If the variable reads tokenRing(1), then the converter is jumpered for High Speed Token Ring mode. If the variable reads ethernet(2), then the converter is jumpered for Ethernet mode. The jumper settings for the converters on both ends of the fiber must be the same.')
crmfe100UpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 22), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100UpTime.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100UpTime.setDescription('Time since the last reboot in Time Ticks (hundredths of seconds). If the value 0 is written to this variable, the timer is reset. No other write value is accepted.')
crmfe100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FirmwareRevision.setDescription('Firmware revision level of this CRMFE100.')
crmfe100RmtDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("detected", 1), ("notDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtDetected.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtDetected.setDescription('Has the value yes(1) if management communcations have been established with a remote media converter.')
crmfe100RmtTPLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtTPLink.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtTPLink.setDescription('Status of Copper Link for this device')
crmfe100RmtFiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtFiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtFiberLink.setDescription('Status of Fiber Link for this device')
crmfe100RmtFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtFault.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtFault.setDescription('Value is yes(1) when either TPLink or FiberLink has value linkDown(2)')
crmfe100RmtAutonegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtAutonegot.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtAutonegot.setDescription('Autonegotiation configuration for this device.')
crmfe100RmtPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtPause.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtPause.setDescription("The Pause feature allows Ethernet MACs that support it to send data pacing 'Pause' messages to each other. Support for Pause is negotiated at the physical level and passed up to the MAC. While the MAC's Pause messages themselves can pass over the fiber link that this pair of media converters introduces, the TP physical layer negotiations to enable Pause can not. Therefore, if both end station MACs support Pause and wish to use it, the Pause negotiation must be re-generated by the media converters on both ends. By setting this configuration option to enabled(1), you are indicating to the local twisted pair station that the twisted pair station on the other side of the other media converter supports Pause and wishes to use it. This variable must be set consistently on both of the paired media converters.")
crmfe100RmtLinkPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtLinkPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtLinkPassThrough.setDescription('This configuration item allows Link Pass Through to be enabled(1) or disabled(2). Link Passthrough causes loss of link on one side of a media converter to be passed through to the other side, so that upstream equipment can see fault conditions that would otherwise be hidden by the media converters.')
crmfe100RmtAutoCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtAutoCross.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtAutoCross.setDescription("On certain devices, it is possible for hardware to automatically correct errors in cable selection, making the distinction between a 'straight through' cable and a 'crossover' cable unimportant. This capability is known as Auto Cross. When disabled, the port reverts to MDI mode.")
crmfe100RmtTPActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtTPActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtTPActivity.setDescription('Twisted Pair Activity. Some versions of the CRMFE100 do not support the reporting of interface activity. The value of this variable for such a device will be notApplicable.')
crmfe100RmtFiberActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtFiberActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtFiberActivity.setDescription('Fiber Activity. Some versions of the CRMFE100 do not support the reporting of interface activity. The value of this variable for such a device will be notApplicable.')
crmfe100RmtConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
crmfe100RmtFarEndFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtFarEndFault.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtFarEndFault.setDescription('Far End Fault configuration of this device. Far End Fault causes the fiber transmitter to generate a Far End Fault pattern upon the loss of a receiver signal detect. When the receiver detects signal again, the transmitter stops transmitting the Far End Fault pattern.')
crmfe100RmtLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtLoopback.setDescription('When Remote Loopback is enabled, all packets sent out from the local fiber interface are reflected back by the remote converter rather than being passed out through the remote twisted pair interface, and all packets received on the remote Twisted Pair interface are discarded.')
crmfe100RmtNetworkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tokenRing", 1), ("ethernet", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100RmtNetworkMode.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtNetworkMode.setDescription('Read-only indicator for High Speed Token Ring jumper configuration. If the variable reads tokenRing(1), then the converter is jumpered for High Speed Token Ring mode. If the variable reads ethernet(2), then the converter is jumpered for Ethernet mode. The jumper settings for the converters on both ends of the fiber must be the same.')
crmfe100RmtUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 38), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100RmtUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100RmtUpTime.setDescription('Time since the last reboot in Time Ticks (hundredths of seconds). If the value 0 is written to this variable, the timer is reset. No other write value is accepted.')
crmfe100TxFxBwa = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100TxFxBwa.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100TxFxBwa.setDescription('This variable allows the control of bandwidth allocation. The value of this variable is entered in Kilobytes per Second, and is automatically rounded to the nearest 64KBps. A value of zero disables data transfer, and the maximum value is 12224KBps. Data traffic is measured from the beginning of each second. Once the traffic reaches the cap specified, all traffic is discarded until the start of the next second, when the counters are reset and traffic begins to flow again. crmfe100TxFxBwa(39) limits the data flowing from the Twisted Pair interface to the Fiber interface.')
crmfe100FxTxBwa = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100FxTxBwa.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FxTxBwa.setDescription('This variable allows the control of bandwidth allocation. The value of this variable is entered in Kilobytes per Second, and is automatically rounded to the nearest 64KBps. A value of zero disables data transfer, and the maximum value is 12224KBps. Data traffic is measured from the beginning of each second. Once the traffic reaches the cap specified, all traffic is discarded until the start of the next second, when the counters are reset and traffic begins to flow again. crmfe100FxTxBwa(39) limits the data flowing from the fiber interface to the twisted pair interface.')
crmfe100TxBytesH = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 41), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100TxBytesH.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100TxBytesH.setDescription("These variables measure the traffic (in Bytes) received by the two interfaces of the converter (and therefore transmitted by the opposite interface). 'Tx' refers to data received by the Twisted Pair interface (and transmitted on the Fiber interface), and 'Fx' refers to data received on the Fiber interface (and transmitted on the Twisted Pair interface). In order to limit each variable to the 32-bit maximum commonly supported in the SNMP world, these 64-bit counters are split into a high-order and low-order 32-bit sections. Transition Networks' applications generally treat the High order portion of the counter as a counter of the number of times the Low order section has wrapped to 0. To reconstruct the original 64-bit value, multiply the 'High' section by 2^32 and add the 'Low' section. If you write the value 0 to any of these four variables, all four are reset to zero.")
crmfe100TxBytesL = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100TxBytesL.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100TxBytesL.setDescription('See the DESCRIPTION for cfmfe100TxBytesH(42) above.')
crmfe100FxBytesH = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100FxBytesH.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FxBytesH.setDescription('See the DESCRIPTION for cfmfe100TxBytesH(42) above.')
crmfe100FxBytesL = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 44), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100FxBytesL.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100FxBytesL.setDescription('See the DESCRIPTION for cfmfe100TxBytesH(42) above.')
crmfe100MscRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100MscRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100MscRxBytes.setDescription("This variable measures the traffic (in Bytes) received and transmitted by the Management Subchannel within the Fiber interface. 'Management Subchannel' refers to the transfer of management data to and from the Remote SRMFExxx in the inter-packet gaps normally found in Ethernet traffic. This allows management data to be transferred with no reduction in the bandwidth available for normal network traffic. If you write the value 0 to this variable or crmfe100MscTxBytes(47), both are reset to zero.")
crmfe100MscTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100MscTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100MscTxBytes.setDescription("This variable measures the traffic (in Bytes) received and transmitted by the Management Subchannel within the Fiber interface. 'Management Subchannel' refers to the transfer of management data to and from the Remote SRMFExxx in the inter-packet gaps normally found in Ethernet traffic. This allows management data to be transferred with no reduction in the bandwidth available for normal network traffic. If you write the value 0 to this variable or crmfe100MscRxBytes(46), both are reset to zero.")
crmfe100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crmfe100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
crmfe100MbTxFxBwa = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100MbTxFxBwa.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100MbTxFxBwa.setDescription('This variable allows the control of bandwidth allocation. The value of this variable is entered in Megabits per Second, and is automatically rounded to the nearest 64KBps. A value of zero disables data transfer, and the maximum value is 12224KBps. Data traffic is measured from the beginning of each second. Once the traffic reaches the cap specified, all traffic is discarded until the start of the next second, when the counters are reset and traffic begins to flow again. crmfe100MbTxFxBwa(48) limits the data flowing from the Twisted Pair interface to the Fiber interface. This variable does the same thing as crmfe100TxFxBwa(39), only the units are different.')
crmfe100MbFxTxBwa = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 24, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crmfe100MbFxTxBwa.setStatus('mandatory')
if mibBuilder.loadTexts: crmfe100MbFxTxBwa.setDescription('This variable allows the control of bandwidth allocation. The value of this variable is entered in Megabits per Second, and is automatically rounded to the nearest 64KBps. A value of zero disables data transfer, and the maximum value is 12224KBps. Data traffic is measured from the beginning of each second. Once the traffic reaches the cap specified, all traffic is discarded until the start of the next second, when the counters are reset and traffic begins to flow again. crmfe100MbFxTxBwa(49) limits the data flowing from the fiber interface to the twisted pair interface. This variable does the same thing as crmfe100TxFxBwa(40), only the units are different.')
crs2f100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25), )
if mibBuilder.loadTexts: crs2f100Table.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100Table.setDescription('Sparse table containing one entry for each CRS2F100 in the stack, indexed by cabinet serial number and slot.')
crs2f100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1), ).setIndexNames((0, "MCC16-MIB", "crs2f100BiaIndex"), (0, "MCC16-MIB", "crs2f100SlotIndex"))
if mibBuilder.loadTexts: crs2f100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100Entry.setDescription('Status and configuration entries for a single CRS2F100')
crs2f100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
crs2f100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100SlotIndex.setDescription('The slot in which the device is installed')
crs2f100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crs2f100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CRS2F100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
crs2f100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100MRevision.setDescription('The marketing revision of this device')
crs2f100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
crs2f100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100SerialNumber.setDescription('The serial number of this device')
crs2f100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100ConnA.setDescription('The style of Fiber connector built into this device')
crs2f100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100ConnB.setDescription('The style of Copper connector built into this device')
crs2f100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100FiberLink.setDescription('Status of Fiber Link for this device')
crs2f100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100Fault.setDescription('Value is yes(1) when FiberLink has value linkDown(2)')
crs2f100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100FirmwareRevision.setDescription("The Firmware Revision MIB Variable reports the revision of software running on the processor on this particular device. You can discover the revisions on these devices by entering the PICREV command at the command line interface. Device Firmware Revisions are normally discussed in terms of a single letter, e.g. revision 'B'. However, when the firmware revision is displayed by generic MIB processing code that is unaware of this convention, the revision is displayed as a decimal value. The table in crs2f100.html provides some examples of how decimal revision values correspond to letter revision values.")
crs2f100Loopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crs2f100Loopback.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100Loopback.setDescription('Loopback is a testing aid available on several different products. When Loopback is enabled on an interface, all data that is sent to the interface is reflected back to the sender, and the actual condition (or even existence) of the equipment on the opposite interface is ignored.')
crs2f100DCE = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dCE", 1), ("dTE", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100DCE.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100DCE.setDescription('An indication of whether this device is attached to a DCE (a modem) or a DTE (a terminal or computer).')
crs2f100CopperActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100CopperActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100CopperActivity.setDescription('The activity indicator has the value yes(1) when the hardware has recently detected network traffic on the associated network port, and no(2) otherwise.')
crs2f100ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100ConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device.')
crs2f100RmtDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100RmtDetected.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100RmtDetected.setDescription('Has the value yes(1) if management communcations have been established with a remote media device.')
crs2f100RmtLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crs2f100RmtLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100RmtLoopback.setDescription('Loopback is a testing aid available on several different products. When Loopback is enabled on an interface, all data that is sent to the interface is reflected back to the sender, and the actual condition (or even existence) of the equipment on the opposite interface is ignored. When no remote device is present, this variable has the value notApplicable(3).')
crs2f100RmtDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dCE", 1), ("dTE", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100RmtDCE.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100RmtDCE.setDescription('This variable describes the status of a remotely managed device. This is an indicator of whether this device is attached to a DCE (a modem) or a DTE (a terminal or computer). When no remote device is present, this variable has the value notApplicable(3).')
crs2f100RmtCopperActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100RmtCopperActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100RmtCopperActivity.setDescription('The activity indicator has the value yes(1) when the hardware has recently detected network traffic on the associated network port, and no(2) otherwise. When no remote device is present, this variable has the value notApplicable(3).')
crs2f100RmtConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("software", 1), ("hardware", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100RmtConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100RmtConfigMode.setDescription('This device has a jumper or switch that disables software management of the device. When ConfigMode is hardware(2), SNMP management is disabled, and all configuration control comes from physical switches or jumpers on the device. When no remote device is present, this variable has the value notApplicable(3).')
crs2f100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 25, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs2f100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: crs2f100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
crs4f100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26), )
if mibBuilder.loadTexts: crs4f100Table.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100Table.setDescription('Sparse table containing one entry for each CRS4F100 in the stack, indexed by cabinet serial number and slot.')
crs4f100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1), ).setIndexNames((0, "MCC16-MIB", "crs4f100BiaIndex"), (0, "MCC16-MIB", "crs4f100SlotIndex"))
if mibBuilder.loadTexts: crs4f100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100Entry.setDescription('Status and configuration entries for a single CRS4F100')
crs4f100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100BiaIndex.setDescription('The serial number (BIA) of the cabinet in which the device is installed')
crs4f100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100SlotIndex.setDescription('The slot in which the device is installed')
crs4f100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crs4f100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100Groups.setDescription("User-defined keywords that group this device together with other devices under a user-defined scheme. By placing matching keywords in cpsGroupCtrl.0, the agent can be instructed to apply configuration changes simultaneously to all group members rather than to individual devices. Every Groups string has three automatically defined implied values: 1) The model family of the device, e.g. 'CRS4F100' 2) The serial number of the cabinet in which the device is installed, in decimal with no leading zeroes, e.g. '12345', and 3) same as 2, with the slot in which the device is installed appended, enclosed in square brackets. e.g. '12345[9]'")
crs4f100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100MRevision.setDescription('The marketing revision of this device')
crs4f100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100CfgMatch.setDescription('yes(1) indicates that the conditions specified in cpsGroupCtrl.0 match the Groups value for this device. no(2) means that there is no match. notApplicable(3) indicates that cpsGroupCtrl.0 is null and therefore no comparison was performed.')
crs4f100SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100SerialNumber.setDescription('The serial number of this device')
crs4f100ConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 7), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100ConnA.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100ConnA.setDescription('The style of Fiber connector built into this device')
crs4f100ConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 8), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100ConnB.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100ConnB.setDescription('The style of Copper connector built into this device')
crs4f100FiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100FiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100FiberLink.setDescription('Status of Fiber Link for this device')
crs4f100Fault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100Fault.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100Fault.setDescription('Value is yes(1) when FiberLink has value linkDown(2)')
crs4f100FirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100FirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100FirmwareRevision.setDescription("The Firmware Revision MIB Variable reports the revision of software running on the processor on this particular device. You can discover the revisions on these devices by entering the PICREV command at the command line interface. Device Firmware Revisions are normally discussed in terms of a single letter, e.g. revision 'B'. However, when the firmware revision is displayed by generic MIB processing code that is unaware of this convention, the revision is displayed as a decimal value. The table in crs4f100.html provides some examples of how decimal revision values correspond to letter revision values.")
crs4f100CopperActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100CopperActivity.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100CopperActivity.setDescription('The activity indicator has the value yes(1) when the hardware has recently detected network traffic on the associated network port, and no(2) otherwise.')
crs4f100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 26, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean", 1), ("dirty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crs4f100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: crs4f100CacheClean.setDescription('When the value is clean(1)Device and Management Module cache are synchronized, no automatic corrections to configuration will occur. When the value is dirty(2) Device and Management Module cache are not synchronized. The configuration currently displayed by the application has not been validated by the device. The device may need to correct the configuration, in which case the displayed configuration will change.')
cmefg100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27), )
if mibBuilder.loadTexts: cmefg100Table.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100Table.setDescription('Generated CMEFG100 MIB Version 041110a ')
cmefg100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1), ).setIndexNames((0, "MCC16-MIB", "cmefg100SubDeviceIndex"), (0, "MCC16-MIB", "cmefg100BiaIndex"), (0, "MCC16-MIB", "cmefg100SlotIndex"))
if mibBuilder.loadTexts: cmefg100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100Entry.setDescription('Status and configuration entries for a single CMEFG100')
cmefg100SubDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100SubDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100SubDeviceIndex.setDescription("If the name of a particular MIB variable does not end in 'Tbl', then it uses the placeholder value '1' in the subdevice index column. ")
cmefg100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100BiaIndex.setDescription('')
cmefg100SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100SlotIndex.setDescription('')
cmefg100Groups = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100Groups.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100Groups.setDescription('')
cmefg100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100MRevision.setDescription('')
cmefg100CfgMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100CfgMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100CfgMatch.setDescription('')
cmefg100ImcLocEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100ImcLocEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcLocEnable.setDescription('Enable periodic upload of local Interface MIB Counters from CMEFG100 to Agent. cmefg100ImcxxxTbl subdevice 1=local tp, subdevice 2=local fiber. ')
cmefg100ImcLocReset = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("doNothing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100ImcLocReset.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcLocReset.setDescription('set to reset(1) to clear all local cmefg100Imc counters. ')
cmefg100ImcRmtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100ImcRmtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRmtEnable.setDescription('Enable periodic upload of remote Interface MIB Counters from CMEFG100 to Agent. cmefg100ImcxxxTbl subdevice 3=remote tp, subdevice 4=remote fiber. ')
cmefg100ImcRmtReset = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("doNothing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100ImcRmtReset.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRmtReset.setDescription('set to reset(1) to clear all remote cmefg100Imc counters. ')
cmefg100ImcRxAlignmentErrorsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxAlignmentErrorsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxAlignmentErrorsTbl.setDescription('')
cmefg100ImcRxBroadcastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxBroadcastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxBroadcastPktsTbl.setDescription('')
cmefg100ImcRxDropPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxDropPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxDropPktsTbl.setDescription('')
cmefg100ImcRxExcessSizeDiscTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxExcessSizeDiscTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxExcessSizeDiscTbl.setDescription('')
cmefg100ImcRxFCSErrorsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxFCSErrorsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxFCSErrorsTbl.setDescription('')
cmefg100ImcRxFragmentsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxFragmentsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxFragmentsTbl.setDescription('')
cmefg100ImcRxGoodOctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxGoodOctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxGoodOctetsTbl.setDescription('')
cmefg100ImcRxGoodOctetsWrapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxGoodOctetsWrapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxGoodOctetsWrapTbl.setDescription('')
cmefg100ImcRxJabbersTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxJabbersTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxJabbersTbl.setDescription('')
cmefg100ImcRxMulticastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxMulticastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxMulticastPktsTbl.setDescription('')
cmefg100ImcRxOctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxOctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxOctetsTbl.setDescription('')
cmefg100ImcRxOctetsWrapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxOctetsWrapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxOctetsWrapTbl.setDescription('')
cmefg100ImcRxOversizePktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxOversizePktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxOversizePktsTbl.setDescription('')
cmefg100ImcRxPausePktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPausePktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPausePktsTbl.setDescription('')
cmefg100ImcRxPkts1024to1522OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts1024to1522OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts1024to1522OctetsTbl.setDescription('')
cmefg100ImcRxPkts128to255OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts128to255OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts128to255OctetsTbl.setDescription('')
cmefg100ImcRxPkts256to511OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts256to511OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts256to511OctetsTbl.setDescription('')
cmefg100ImcRxPkts512to1023OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts512to1023OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts512to1023OctetsTbl.setDescription('')
cmefg100ImcRxPkts64OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts64OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts64OctetsTbl.setDescription('')
cmefg100ImcRxPkts65to127OctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxPkts65to127OctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxPkts65to127OctetsTbl.setDescription('')
cmefg100ImcRxQosOctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxQosOctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxQosOctetsTbl.setDescription('')
cmefg100ImcRxQosOctetsWrapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxQosOctetsWrapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxQosOctetsWrapTbl.setDescription('')
cmefg100ImcRxQosPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxQosPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxQosPktsTbl.setDescription('')
cmefg100ImcRxSAChangesTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxSAChangesTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxSAChangesTbl.setDescription('')
cmefg100ImcRxSymbolErrorTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxSymbolErrorTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxSymbolErrorTbl.setDescription('')
cmefg100ImcRxUndersizePktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxUndersizePktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxUndersizePktsTbl.setDescription('')
cmefg100ImcRxUnicastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcRxUnicastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcRxUnicastPktsTbl.setDescription('')
cmefg100ImcTxBroadcastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxBroadcastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxBroadcastPktsTbl.setDescription('')
cmefg100ImcTxCollisionsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxCollisionsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxCollisionsTbl.setDescription('')
cmefg100ImcTxDeferredTransmitTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxDeferredTransmitTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxDeferredTransmitTbl.setDescription('')
cmefg100ImcTxDropPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxDropPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxDropPktsTbl.setDescription('')
cmefg100ImcTxExcessiveCollisionTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxExcessiveCollisionTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxExcessiveCollisionTbl.setDescription('')
cmefg100ImcTxFrameInDiscTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxFrameInDiscTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxFrameInDiscTbl.setDescription('')
cmefg100ImcTxLateCollisionTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxLateCollisionTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxLateCollisionTbl.setDescription('')
cmefg100ImcTxMulticastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxMulticastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxMulticastPktsTbl.setDescription('')
cmefg100ImcTxMultipleCollisionTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxMultipleCollisionTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxMultipleCollisionTbl.setDescription('')
cmefg100ImcTxOctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxOctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxOctetsTbl.setDescription('')
cmefg100ImcTxOctetsWrapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxOctetsWrapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxOctetsWrapTbl.setDescription('')
cmefg100ImcTxPausePktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxPausePktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxPausePktsTbl.setDescription('')
cmefg100ImcTxQosOctetsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxQosOctetsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxQosOctetsTbl.setDescription('')
cmefg100ImcTxQosOctetsWrapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxQosOctetsWrapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxQosOctetsWrapTbl.setDescription('')
cmefg100ImcTxQosPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxQosPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxQosPktsTbl.setDescription('')
cmefg100ImcTxSingleCollisionTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxSingleCollisionTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxSingleCollisionTbl.setDescription('')
cmefg100ImcTxUnicastPktsTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100ImcTxUnicastPktsTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100ImcTxUnicastPktsTbl.setDescription('')
cmefg100LadCacheCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loadCache", 1), ("doNothing", 2), ("release", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadCacheCmd.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadCacheCmd.setDescription("All variables starting with cmefg100Lad relate to the Learned MAC Address Database. Due to the large size of the LAD database and the limited memory within the Agent, the cache is loaded into the cache memory buffer only when it is requested via this MIB variable. Setting this var to loadCache commands the agent to upload the LAD from the device exactly one time. Note that the contents of this cache are NOT automatically refreshed. Setting this variable to 'release' causes the data in the cache to be purged, even if the cache buffer contains data of an entirely different type, such as the VLAN table cache. Thus, it is not necessary to know what type of data was most recently loaded into the cache buffer, but it is necessary to take care not to release data that is currently in use. A genErr will be returned if any other command involving reading or writing the LAD or the VLAN table is in progress. ")
cmefg100LadCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ready", 1), ("empty", 2), ("transferring", 3), ("bufferBusy", 4), ("stale", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadCacheState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadCacheState.setDescription("This variable shows the current state of the Agent's cache buffer with respect to the Learned Address Database. A value of 'ready' means that the cache buffer contains a complete copy of the LAD that is less than 300 seconds old. A value of 'stale' means that the cache buffer contains a complete copy of the LAD that is more than 300 seconds old. A value of 'empty' means that the buffer has been purged, and the system is ready to accept a cmefg100LadCacheCmd of 'loadCache.' A value of 'transferring' means that no command can be issued and the cache cannot be read because data is currently being transferred into the cache buffer. The data may or may not be related to the LAD. A value of 'bufferBusy' means that the buffer contains a complete copy (ready or stale) of something other than the LAD. The contents of the buffer can be overwritten with the LAD by issuing a 'loadCache' command. ")
cmefg100LadEditCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("write", 1), ("delete", 2), ("doNothing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadEditCmd.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadEditCmd.setDescription("Setting this var to 'write' causes LadEditMac, LadEditPort, and LadEditVid to be written (insert/overwrite as required) to the LAD. Setting this var to 'delete' causes the address represented by LadEditMac to be deleted from the LAD. Changes made are not reflected in the LAD cache until the device accepts them and the cache is reloaded. A genErr will be returned if any other command involving reading or writing the LAD or the VLAN table is in progress. ")
cmefg100LadEditMac = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 58), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadEditMac.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadEditMac.setDescription('A plain-text representation of a MAC address to be used the next time cmefg100LadEditCmd is set to write or delete. ')
cmefg100LadEditPort = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("twistedPair", 1), ("fiber", 2), ("drop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadEditPort.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadEditPort.setDescription('A port to be used the next time cmefg100LadEditCmd is set to write. ')
cmefg100LadEditVid = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 60), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LadEditVid.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadEditVid.setDescription('A VLAN Id to be used the next time cmefg100LadEditCmd is set to write. Not valid when cmefg100VlanEnable is disabled(2) ')
cmefg100LadEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LadEntries.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadEntries.setDescription('A count of the number of entries currently in the LAD Cache. See also cmefg100LadCacheState. If a LAD cache-filling transfer is in progress, this variable can be read for a progress report. ')
cmefg100LadMacTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 62), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LadMacTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadMacTbl.setDescription("An Ethernet MAC address in the LAD table. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100LadEntries. If cmefg100LadEntries is 0 (either because cmefg100LadCacheState is not 'ready/stale' or because there simply are no entries), this table contains a solitary dummy entry, SubDeviceIndex==1. ")
cmefg100LadPortTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("twistedPair", 1), ("fiber", 2), ("drop", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LadPortTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadPortTbl.setDescription("A port in the LAD table. Drop means 'forward to neither port' The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100LadEntries. If cmefg100LadEntries is 0 (either because cmefg100LadCacheState is not 'ready/stale' or because there simply are no entries), this table contains a solitary entry, SubDeviceIndex==1, value notApplicable. ")
cmefg100LadStaticTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LadStaticTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadStaticTbl.setDescription("An indication of whether the indexed entry in the LAD is static or dynamic. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100LadEntries. If cmefg100LadEntries is 0 (either because cmefg100LadCacheState is not 'ready/stale' or because there simply are no entries), this table contains a solitary entry, SubDeviceIndex==1, value notApplicable. ")
cmefg100LadVidTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LadVidTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LadVidTbl.setDescription("A VLAN Id in the LAD table. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100LadEntries. If cmefg100LadEntries is 0 (either because cmefg100LadCacheState is not 'ready/stale' or because there simply are no entries), this table contains a solitary dummy entry, SubDeviceIndex==1. Always returns the dummy value '0' when cmefg100VlanEnable is disabled(2). ")
cmefg100LocColdstart = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocColdstart.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocColdstart.setDescription('')
cmefg100LocDmiRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 67), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiRxPower.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiRxPower.setDescription('DMI: Diagnostic Monitoring Interface for fiber transceivers ')
cmefg100LocDmiRxPowerAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiRxPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiRxPowerAlarm.setDescription('')
cmefg100LocDmiTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 69), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTemp.setDescription('In tenths of degrees C ')
cmefg100LocDmiTempAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTempAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTempAlarm.setDescription('')
cmefg100LocDmiTxBiasAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTxBiasAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTxBiasAlarm.setDescription('')
cmefg100LocDmiTxBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 72), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTxBiasCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTxBiasCurrent.setDescription('In microamperes ')
cmefg100LocDmiTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTxPower.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTxPower.setDescription('In microwatts ')
cmefg100LocDmiTxPowerAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocDmiTxPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocDmiTxPowerAlarm.setDescription('')
cmefg100LocFiberAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberAdv1000FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocFiberAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberAdv1000HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocFiberAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberAutoNegot.setDescription('')
cmefg100LocFiberConnA = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 78), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocFiberConnA.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberConnA.setDescription('')
cmefg100LocFiberDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 79), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("forceFDX", 1), ("forceHDX", 2), ("autoFDX", 3), ("autoHDX", 4), ("negotiating", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberDuplex.setDescription('Read-only values 3..5 are returned when autonegotiation is enabled ')
cmefg100LocFiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocFiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberLink.setDescription('')
cmefg100LocFiberPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asymmetricRx", 1), ("asymmetricTx", 2), ("symmetric", 3), ("disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberPause.setDescription('')
cmefg100LocFiberQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberQosPause.setDescription('')
cmefg100LocFiberSacEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFiberSacEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberSacEnable.setDescription('Enable/disable traps for Source Address Change ')
cmefg100LocFiberSacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("constant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocFiberSacStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFiberSacStatus.setDescription('')
cmefg100LocFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 85), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocFirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFirmwareRevision.setDescription('')
cmefg100LocFpgaRev = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 86), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocFpgaRev.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFpgaRev.setDescription('Field-Programmable Gate Array revision ')
cmefg100LocFxTxBwaKb = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 87), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 122112))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFxTxBwaKb.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFxTxBwaKb.setDescription('FX to TX bandwidth allocation, in Kbps ')
cmefg100LocFxTxBwaMb = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 88), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocFxTxBwaMb.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocFxTxBwaMb.setDescription('FX to TX bandwidth allocation, in Mbps ')
cmefg100LocOamActiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamActiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamActiveMode.setDescription('OAM: Operation, Administration, and Maintenance ')
cmefg100LocOamAdminControl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocOamAdminControl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamAdminControl.setDescription('')
cmefg100LocOamConfigRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 91), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamConfigRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamConfigRevision.setDescription('')
cmefg100LocOamControlInUnknownOpcodes = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 92), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamControlInUnknownOpcodes.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamControlInUnknownOpcodes.setDescription('')
cmefg100LocOamCriticalEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("critical", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamCriticalEvent.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamCriticalEvent.setDescription('')
cmefg100LocOamDuplicateEventNotificationRx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 94), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamDuplicateEventNotificationRx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamDuplicateEventNotificationRx.setDescription('')
cmefg100LocOamFramesLostDueToOamError = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 95), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamFramesLostDueToOamError.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamFramesLostDueToOamError.setDescription('')
cmefg100LocOamInformationRx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 96), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamInformationRx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamInformationRx.setDescription('')
cmefg100LocOamInformationTx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 97), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamInformationTx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamInformationTx.setDescription('')
cmefg100LocOamLastGasp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failure", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLastGasp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLastGasp.setDescription('')
cmefg100LocOamLinkEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLinkEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLinkEvents.setDescription('')
cmefg100LocOamLinkFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fault", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLinkFault.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLinkFault.setDescription('')
cmefg100LocOamLocDteDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 101), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("completed", 1), ("notCompleted", 2), ("unsatisfied", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLocDteDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLocDteDisc.setDescription('discovery state ')
cmefg100LocOamLoopbackControlRx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 102), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLoopbackControlRx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLoopbackControlRx.setDescription('')
cmefg100LocOamLoopbackControlTx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 103), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamLoopbackControlTx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamLoopbackControlTx.setDescription('')
cmefg100LocOamMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 104), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamMacAddress.setDescription('The MAC address of the OAM entity. ')
cmefg100LocOamMaxOamPduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 105), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamMaxOamPduSize.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamMaxOamPduSize.setDescription('')
cmefg100LocOamMultiplexorState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 106), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("discarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamMultiplexorState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamMultiplexorState.setDescription('')
cmefg100LocOamOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 107), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("linkFault", 1), ("activeSendLocal", 2), ("passiveWait", 3), ("sendLocalRemote", 4), ("sendLocalRemoteOk", 5), ("sendAny", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamOperStatus.setDescription('')
cmefg100LocOamOrgSpecificRx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 108), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamOrgSpecificRx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamOrgSpecificRx.setDescription('')
cmefg100LocOamOrgSpecificTx = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 109), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamOrgSpecificTx.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamOrgSpecificTx.setDescription('')
cmefg100LocOamParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forwarding", 1), ("discarding", 2), ("looping", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamParserState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamParserState.setDescription('')
cmefg100LocOamRmtDteDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 111), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("completed", 1), ("notCompleted", 2), ("unsatisfied", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamRmtDteDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamRmtDteDisc.setDescription('')
cmefg100LocOamRmtLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 112), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamRmtLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamRmtLoopback.setDescription('Indicates whether or not local has support to allow remote to initiate remote loopback mode. ')
cmefg100LocOamUnidirectional = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 113), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamUnidirectional.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamUnidirectional.setDescription('')
cmefg100LocOamVarRetrieval = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 114), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocOamVarRetrieval.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocOamVarRetrieval.setDescription('')
cmefg100LocSelfTestFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 115), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocSelfTestFailed.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocSelfTestFailed.setDescription('')
cmefg100LocSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 116), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocSerialNumber.setDescription('')
cmefg100LocTpAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 117), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv1000FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 118), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv1000HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAdv100FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 119), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv100FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv100FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAdv100HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv100HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv100HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAdv10FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv10FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv10FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAdv10HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 122), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAdv10HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAdv10HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100LocTpAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 123), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpAutoNegot.setDescription('')
cmefg100LocTpConnB = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 124), CpsConnector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocTpConnB.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpConnB.setDescription('')
cmefg100LocTpCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 125), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forceMDI", 1), ("forceMDI-X", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpCross.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpCross.setDescription('')
cmefg100LocTpDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("forceFDX", 1), ("forceHDX", 2), ("autoFDX", 3), ("autoHDX", 4), ("negotiating", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpDuplex.setDescription('Read-only values 3..5 are returned when autonegotiation is enabled ')
cmefg100LocTpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 127), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocTpLink.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpLink.setDescription('')
cmefg100LocTpPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 128), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asymmetricRx", 1), ("asymmetricTx", 2), ("symmetric", 3), ("disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpPause.setDescription('')
cmefg100LocTpQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 129), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpQosPause.setDescription('QOS: Quality of Service ')
cmefg100LocTpSacEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 130), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpSacEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpSacEnable.setDescription('Enable/disable traps for Source Address Change ')
cmefg100LocTpSacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 131), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("constant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100LocTpSacStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpSacStatus.setDescription('')
cmefg100LocTpSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 132), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("force10Mbps", 1), ("force100Mbps", 2), ("auto10Mbps", 3), ("auto100Mbps", 4), ("auto1000Mbps", 5), ("negotiating", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTpSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTpSpeed.setDescription('Read-only values 3..6 are returned when autonegotiation is enabled ')
cmefg100LocTxFxBwaKb = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 133), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 122112))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTxFxBwaKb.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTxFxBwaKb.setDescription('TX to FX bandwidth allocation, in Kbps ')
cmefg100LocTxFxBwaMb = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 134), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocTxFxBwaMb.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocTxFxBwaMb.setDescription('TX to FX bandwidth allocation, in Mbps ')
cmefg100LocUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 135), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100LocUptime.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100LocUptime.setDescription('Write with 0 to reset. ')
cmefg100QosHqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 136), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100QosHqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100QosHqWeight.setDescription('')
cmefg100QosLqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 137), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100QosLqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100QosLqWeight.setDescription('')
cmefg100QosPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 138), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100QosPriority.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100QosPriority.setDescription('')
cmefg100RmtColdStart = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 139), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtColdStart.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtColdStart.setDescription('')
cmefg100RmtDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 140), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDetected.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDetected.setDescription('')
cmefg100RmtDmiRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 141), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiRxPower.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiRxPower.setDescription('')
cmefg100RmtDmiRxPowerAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 142), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiRxPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiRxPowerAlarm.setDescription('')
cmefg100RmtDmiTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 143), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTemp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTemp.setDescription('In tenths of degrees C ')
cmefg100RmtDmiTempAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 144), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTempAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTempAlarm.setDescription('')
cmefg100RmtDmiTxBiasAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 145), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTxBiasAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTxBiasAlarm.setDescription('')
cmefg100RmtDmiTxBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 146), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTxBiasCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTxBiasCurrent.setDescription('In microamperes ')
cmefg100RmtDmiTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 147), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTxPower.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTxPower.setDescription('In microwatts ')
cmefg100RmtDmiTxPowerAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 148), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("notSupported", 2), ("lowWarn", 3), ("highWarn", 4), ("lowAlarm", 5), ("highAlarm", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtDmiTxPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtDmiTxPowerAlarm.setDescription('')
cmefg100RmtFactoryReset = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 149), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("doNothing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtFactoryReset.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFactoryReset.setDescription('')
cmefg100RmtFiberAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 150), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtFiberAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFiberAutoNegot.setDescription('')
cmefg100RmtFiberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 151), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtFiberLink.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFiberLink.setDescription('')
cmefg100RmtFiberPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 152), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asymmetricRx", 1), ("asymmetricTx", 2), ("symmetric", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtFiberPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFiberPause.setDescription('')
cmefg100RmtFiberQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 153), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtFiberQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFiberQosPause.setDescription('')
cmefg100RmtFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 154), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtFirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFirmwareRevision.setDescription('')
cmefg100RmtFpgaRev = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 155), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtFpgaRev.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtFpgaRev.setDescription('Field-Programmable Gate Array revision ')
cmefg100RmtOamActiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 156), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamActiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamActiveMode.setDescription('')
cmefg100RmtOamCriticalEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 157), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("critical", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamCriticalEvent.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamCriticalEvent.setDescription('')
cmefg100RmtOamLastGasp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 158), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failure", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamLastGasp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamLastGasp.setDescription('')
cmefg100RmtOamLinkEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 159), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamLinkEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamLinkEvents.setDescription('')
cmefg100RmtOamLinkFault = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 160), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fault", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamLinkFault.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamLinkFault.setDescription('')
cmefg100RmtOamLocDteDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 161), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("completed", 1), ("notCompleted", 2), ("unsatisfied", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamLocDteDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamLocDteDisc.setDescription('')
cmefg100RmtOamPeerConfigRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 162), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerConfigRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerConfigRevision.setDescription('')
cmefg100RmtOamPeerMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 163), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerMacAddress.setDescription('')
cmefg100RmtOamPeerMaxOamPduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 164), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerMaxOamPduSize.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerMaxOamPduSize.setDescription('')
cmefg100RmtOamPeerMultiplexorState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 165), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("discarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerMultiplexorState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerMultiplexorState.setDescription('')
cmefg100RmtOamPeerParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 166), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forwarding", 1), ("discarding", 2), ("looping", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerParserState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerParserState.setDescription('')
cmefg100RmtOamPeerVendorInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 167), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerVendorInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerVendorInfo.setDescription('')
cmefg100RmtOamPeerVendorOui = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 168), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamPeerVendorOui.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamPeerVendorOui.setDescription('')
cmefg100RmtOamRmtDteDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 169), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("completed", 1), ("notCompleted", 2), ("unsatisfied", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamRmtDteDisc.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamRmtDteDisc.setDescription('')
cmefg100RmtOamRmtLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 170), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabledOam", 1), ("enabledAlternate", 2), ("disabled", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtOamRmtLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamRmtLoopback.setDescription('Initiates remote loopback mode if the remote supports it. See RmtOamPeerParserState for status information ')
cmefg100RmtOamUnidirectional = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 171), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamUnidirectional.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamUnidirectional.setDescription('')
cmefg100RmtOamVarRetrieval = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 172), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtOamVarRetrieval.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtOamVarRetrieval.setDescription('')
cmefg100RmtSelfTestFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 173), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtSelfTestFailed.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtSelfTestFailed.setDescription('')
cmefg100RmtSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 174), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtSerialNumber.setDescription('')
cmefg100RmtTpAdv1000FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 175), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv1000FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv1000FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAdv1000HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 176), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv1000HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv1000HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAdv100FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 177), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv100FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv100FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAdv100HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 178), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv100HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv100HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAdv10FDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 179), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv10FDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv10FDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAdv10HDX = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 180), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAdv10HDX.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAdv10HDX.setDescription('Read-only value notApplicable returned when autonegotiation is disabled ')
cmefg100RmtTpAutoNegot = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 181), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpAutoNegot.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpAutoNegot.setDescription('')
cmefg100RmtTpCross = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 182), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forceMDI", 1), ("forceMDI-X", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpCross.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpCross.setDescription('')
cmefg100RmtTpDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 183), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("forceFDX", 1), ("forceHDX", 2), ("autoFDX", 3), ("autoHDX", 4), ("negotiating", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpDuplex.setDescription('Read-only values 3..5 are returned when autonegotiation is enabled ')
cmefg100RmtTpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 184), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100RmtTpLink.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpLink.setDescription('')
cmefg100RmtTpPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 185), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asymmetricRx", 1), ("asymmetricTx", 2), ("symmetric", 3), ("notSupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpPause.setDescription('')
cmefg100RmtTpQosPause = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 186), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpQosPause.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpQosPause.setDescription('')
cmefg100RmtTpSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 187), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("force10Mbps", 1), ("force100Mbps", 2), ("auto10Mbps", 3), ("auto100Mbps", 4), ("auto1000Mbps", 5), ("negotiating", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtTpSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtTpSpeed.setDescription('Read-only values 3..6 are returned when autonegotiation is enabled ')
cmefg100RmtUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 188), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100RmtUptime.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100RmtUptime.setDescription('Write with 0 to reset. ')
cmefg100VlanCacheCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 189), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loadCache", 1), ("doNothing", 2), ("release", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanCacheCmd.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanCacheCmd.setDescription('All variables starting with cmefg100Lad relate to 802.1Q VLAN controls. Setting this var to loadCache commands the agent to upload the VLAN table from the device exactly one time. Note that the contents of this cache are NOT automatically refreshed. A genErr will be returned if any other command involving reading or writing the LAD or the VLAN table is in progress. ')
cmefg100VlanCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 190), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ready", 1), ("empty", 2), ("transferring", 3), ("bufferBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanCacheState.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanCacheState.setDescription("The agent discards the VLAN table shortly after uploading it to prevent the reporting of outdated information. This variable shows the current state of the cache. If it reads 'empty,' set VlanCacheCmd to loadCache to upload the VLAN table. ")
cmefg100VlanEditCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 191), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("write", 1), ("delete", 2), ("doNothing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanEditCmd.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditCmd.setDescription('Setting this var to write causes VlanEditFwdFiber, VlanEditFwdTp, VlanEditUntagFiber, VlanEditUntagTp, and VlanEditVid to be written to the VLAN tablei (i.e. insert/overwrite). Setting this var to delete causes the VLAN Id represented by VlanEditVlanId to be deleted from the VLAN table. A genErr will be returned if any other command involving reading or writing the LAD or the VLAN table is in progress. ')
cmefg100VlanEditFwdFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 192), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanEditFwdFiber.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditFwdFiber.setDescription('A fiber egress rule to be acted upon by VlanEditCmd ')
cmefg100VlanEditFwdTp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 193), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanEditFwdTp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditFwdTp.setDescription('A twisted pair egress rule to be acted upon by VlanEditCmd ')
cmefg100VlanEditUntagFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 194), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untag", 1), ("asIs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanEditUntagFiber.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditUntagFiber.setDescription('A fiber untag rule to be acted upon by VlanEditCmd ')
cmefg100VlanEditUntagTp = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 195), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untag", 1), ("asIs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanEditUntagTp.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditUntagTp.setDescription('A twisted pair untag rule to be acted upon by VlanEditCmd ')
cmefg100VlanEditVid = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 196), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanEditVid.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEditVid.setDescription('A VLAN Id to be acted upon by VlanEditCmd ')
cmefg100VlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 197), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEnable.setDescription('Enable/disable for 802.1Q VLAN tag processing. ')
cmefg100VlanEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 198), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanEntries.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanEntries.setDescription('A count of the number of entries currently in the VLAN table cache. See also VlanCacheState. If a VLAN cache-filling transfer is in progress, this variable can be read for a progress report. ')
cmefg100VlanFiberDefaultPri = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 199), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanFiberDefaultPri.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanFiberDefaultPri.setDescription('')
cmefg100VlanFiberDefaultVid = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 200), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanFiberDefaultVid.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanFiberDefaultVid.setDescription('')
cmefg100VlanFiberInUntaggedDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 201), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanFiberInUntaggedDrop.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanFiberInUntaggedDrop.setDescription('')
cmefg100VlanFwdFiberTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 202), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanFwdFiberTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanFwdFiberTbl.setDescription('Indicates whether packets with the VLAN Id specified by the corresponding cmefg100VlanVidTbl entry (i.e. the one with the same SubDeviceIndex) are forwarded or dropped when they are routed for fiber egress. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100VlanEntries. ')
cmefg100VlanFwdTpTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 203), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanFwdTpTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanFwdTpTbl.setDescription('Indicates whether packets with the VLAN Id specified by the corresponding cmefg100VlanVidTbl entry (i.e. the one with the same SubDeviceIndex) are forwarded or dropped when they are routed for twisted pair egress. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100VlanEntries. ')
cmefg100VlanIngressVidHitNoMem = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 204), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forward", 1), ("drop", 2), ("learn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanIngressVidHitNoMem.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanIngressVidHitNoMem.setDescription("Ingress violation - port from which frame originates is not a member of the VLAN indicated by the frame's tag ")
cmefg100VlanIngressVidMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 205), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flood", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanIngressVidMiss.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanIngressVidMiss.setDescription("Ingress violation - the VLAN indicated by the frame's tag is undefined in the VLAN table. ")
cmefg100VlanPriMapTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 206), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanPriMapTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanPriMapTbl.setDescription("A table containing new priority values for priority remapping. The SubDeviceIndex is 'original priority', range 0..7. ")
cmefg100VlanPriTagCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 207), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("asIs", 1), ("remapPriority", 2), ("remapVid", 3), ("remapBoth", 4), ("notApplicable", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanPriTagCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanPriTagCtrl.setDescription('')
cmefg100VlanSetFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 208), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanSetFailed.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanSetFailed.setDescription('')
cmefg100VlanTagIn = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 209), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tag", 1), ("noTag", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanTagIn.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanTagIn.setDescription('')
cmefg100VlanTpDefaultPri = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 210), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanTpDefaultPri.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanTpDefaultPri.setDescription('')
cmefg100VlanTpDefaultVid = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 211), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanTpDefaultVid.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanTpDefaultVid.setDescription('')
cmefg100VlanTpInUntaggedDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 212), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("forward", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanTpInUntaggedDrop.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanTpInUntaggedDrop.setDescription('')
cmefg100VlanUntagFiberTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 213), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untag", 1), ("asIs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanUntagFiberTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanUntagFiberTbl.setDescription('Indicates whether VLAN Ids are stripped from packets with the VLAN Id specified by the corresponding cmefg100VlanVidTbl entry (i.e. the one with the same SubDeviceIndex) when they are routed for fiber egress. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100VlanEntries. ')
cmefg100VlanUntagTpTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 214), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untag", 1), ("asIs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanUntagTpTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanUntagTpTbl.setDescription('Indicates whether VLAN Ids are stripped from packets with the VLAN Id specified by the corresponding cmefg100VlanVidTbl entry (i.e. the one with the same SubDeviceIndex) when they are routed for twisted pair egress. The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100VlanEntries. ')
cmefg100VlanVidTagCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 215), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("asIs", 1), ("remapPriority", 2), ("remapVid", 3), ("remapBoth", 4), ("notApplicable", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100VlanVidTagCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanVidTagCtrl.setDescription('')
cmefg100VlanVidTbl = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 216), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmefg100VlanVidTbl.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100VlanVidTbl.setDescription('The SubDeviceIndex is an arbitrary integer sequence number, range 1..cmefg100VlanEntries. ')
cmefg100CacheClean = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 1, 2, 2, 27, 1, 217), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmefg100CacheClean.setStatus('mandatory')
if mibBuilder.loadTexts: cmefg100CacheClean.setDescription('And all of the MIB variables lived happily ever after. The End. ')
mcc16ComHwReset = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcc16ComHwReset.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComHwReset.setDescription('Save configuration to FLASH and perform a hardware reset')
mcc16ComMgmtHwRev = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComMgmtHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComMgmtHwRev.setDescription('The management h/w board revision.')
mcc16ComMgmtSwRev = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComMgmtSwRev.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComMgmtSwRev.setDescription('The downloadable management s/w code revision.')
mcc16ComIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcc16ComIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComIpAddr.setDescription('The IP address of the management interface.')
mcc16ComNetMask = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcc16ComNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComNetMask.setDescription('The subnet mask associated with the IP address of the management interface. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
mcc16ComGateway = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcc16ComGateway.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComGateway.setDescription("The managment interface's default gateway.")
mcc16ComPS1Power = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComPS1Power.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComPS1Power.setDescription('On if power supply 1 is installed and powered')
mcc16ComPS1InUse = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComPS1InUse.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComPS1InUse.setDescription('On if power supply 1 is currently active')
mcc16ComPS2Power = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComPS2Power.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComPS2Power.setDescription('On if power supply 2 is installed and powered')
mcc16ComPS2InUse = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16ComPS2InUse.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComPS2InUse.setDescription('On if power supply 2 is currently active')
mcc16ComNotes = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcc16ComNotes.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16ComNotes.setDescription('Enduser-defined text notes')
mcc16SlotTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 2, 1), )
if mibBuilder.loadTexts: mcc16SlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16SlotTable.setDescription('One table entry per slot in the media converter chassis. Value of entry is type of device in the slot, or a value indicating that the slot is empty.')
mcc16SlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 2, 1, 1), ).setIndexNames((0, "MCC16-MIB", "mcc16Index"))
if mibBuilder.loadTexts: mcc16SlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16SlotEntry.setDescription('The type of device inserted in a single chassis slot')
mcc16Index = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16Index.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16Index.setDescription('The index of a slot in a media converter chassis')
mcc16DeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 1, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcc16DeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: mcc16DeviceType.setDescription('The object ID of the device in the a slot')
mcc16Error = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 2) + (0,101))
if mibBuilder.loadTexts: mcc16Error.setDescription("A monitored MIB variable has changed from its 'operational' state to 'not present' or its 'error' state.")
mcc16ErrorClear = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 2) + (0,102))
if mibBuilder.loadTexts: mcc16ErrorClear.setDescription("A monitored MIB variable has changed from a 'not present' or 'error' state to its 'operational' state.")
mcc16PSState = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 2) + (0,103))
if mibBuilder.loadTexts: mcc16PSState.setDescription('The power indication on a power supply has changed, or a power supply was non-operational at the time of a warm start.')
pSError = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,111))
if mibBuilder.loadTexts: pSError.setDescription("A monitored MIB variable has changed from its 'operational' state to its 'error' state.")
pSErrorClear = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,112))
if mibBuilder.loadTexts: pSErrorClear.setDescription("A monitored MIB variable has changed from its 'error' state to its 'operational' state.")
pSDeviceInserted = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,113))
if mibBuilder.loadTexts: pSDeviceInserted.setDescription('A new slide-in device (this includes some power supplies) was detected on the bus.')
pSDeviceRemoved = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,114))
if mibBuilder.loadTexts: pSDeviceRemoved.setDescription('A slide-in device that had previously been detected on the bus has not been heard from in a long time, and is presumed to have been physically removed.')
pSDeviceColdStart = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,115))
if mibBuilder.loadTexts: pSDeviceColdStart.setDescription('A slide-in device has indicated that it has rebooted. This is most common when the device is inserted into its slot, but in a few cases this trap indicates a warm start.')
pSPowerLost = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,116))
if mibBuilder.loadTexts: pSPowerLost.setDescription('The cabinet into which this management module is installed has lost power. Both the cabinet and the management module must support this feature for this trap to be sent.')
pSCabinetAdded = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,117))
if mibBuilder.loadTexts: pSCabinetAdded.setDescription('A new cabinet was detected on the bus.')
pSCabinetRemoved = NotificationType((1, 3, 6, 1, 4, 1, 868, 1, 4, 1, 2, 1) + (0,118))
if mibBuilder.loadTexts: pSCabinetRemoved.setDescription('A cabinet that had previously been detected on the bus has not been heard from in a long time, and is presumed to have been physically removed.')
cpsCabinetTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1), )
if mibBuilder.loadTexts: cpsCabinetTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetTable.setDescription('Sparse table containing one entry for each Cabinet in the stack, indexed by cabinet serial number.')
cpsCabinetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1, 1), ).setIndexNames((0, "MCC16-MIB", "cpsCabinetBiaIndex"))
if mibBuilder.loadTexts: cpsCabinetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetEntry.setDescription('Status and Configuration entries for a single Cabinet.')
cpsCabinetBiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCabinetBiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetBiaIndex.setDescription('The serial number (BIA) of the Cabinet')
cpsCabinetModel = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCabinetModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetModel.setDescription('The model number of the cabinet')
cpsCabinetDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsCabinetDescription.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetDescription.setDescription('User defined text description of the cabinet. This description is a mirror of the ones that can be found under cpsCabDetail.')
cpsCabinetSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsCabinetSequence.setStatus('mandatory')
if mibBuilder.loadTexts: cpsCabinetSequence.setDescription('An arbitrary sequence number assigned to the cabinet by the agent for the use of the Focal Point application. Cabinets are sorted by BiaIndex in the table, and numbered sequentially.')
cpsMc1800Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1), )
if mibBuilder.loadTexts: cpsMc1800Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800Table.setDescription('Sparse table containing one entry for each CPSMC1800 in the stack, indexed by cabinet serial number.')
cpsMc1800Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1), ).setIndexNames((0, "MCC16-MIB", "cpsMc1800BiaIndex"))
if mibBuilder.loadTexts: cpsMc1800Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800Entry.setDescription('Status and configuration entries for a single CPSMC1800')
cpsMc1800BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800BiaIndex.setDescription('The serial number (BIA) of the cabinet')
cpsMc1800Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800Description.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
cpsMc1800PSPower1 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800PSPower1.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800PSPower1.setDescription('Power status, first power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsMc1800PSInUse1 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800PSInUse1.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800PSInUse1.setDescription('Power status, first power supply slot. Value is yes(1) when the power is selected to supply power to the cabinet')
cpsMc1800PSPower2 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800PSPower2.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800PSPower2.setDescription('Power status, second power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsMc1800PSInUse2 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800PSInUse2.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800PSInUse2.setDescription('Power status, second power supply slot. Value is yes(1) when the power is selected to supply power to the cabinet')
cpsMc1800MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1800MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1800MRevision.setDescription('The marketing revision of this device')
cpsMc1300Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2), )
if mibBuilder.loadTexts: cpsMc1300Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300Table.setDescription('Sparse table containing one entry for each CPSMC1300 in the stack, indexed by cabinet serial number.')
cpsMc1300Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1), ).setIndexNames((0, "MCC16-MIB", "cpsMc1300BiaIndex"))
if mibBuilder.loadTexts: cpsMc1300Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300Entry.setDescription('Status and configuration entries for a single CPSMC1300')
cpsMc1300BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300BiaIndex.setDescription('The serial number (BIA) of the cabinet')
cpsMc1300Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300Description.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
cpsMc1300PSPower1 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300PSPower1.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300PSPower1.setDescription('Power status, first power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsMc1300PSInUse1 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300PSInUse1.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300PSInUse1.setDescription("For future expansion. At the time of this writing, the CPSMC1300 did not accept any power supplies capable of supporting a master/slave relationship, meaning that all 'ready' power supplies share load and therefore are 'in use'. If master/slave support were present, inuse would indicate whether or not this supply was currently supplying power to the cabinet.")
cpsMc1300PSPower2 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300PSPower2.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300PSPower2.setDescription('Power status, second power supply slot. Value is on(1) when the supply is capable of supplying power.')
cpsMc1300PSInUse2 = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300PSInUse2.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300PSInUse2.setDescription("For future expansion. At the time of this writing, the CPSMC1300 did not accept any power supplies capable of supporting a master/slave relationship, meaning that all 'ready' power supplies share load and therefore are 'in use'. If master/slave support were present, inuse would indicate whether or not this supply was currently supplying power to the cabinet.")
cpsMc1300MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1300MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1300MRevision.setDescription('The marketing revision of this device')
cpsMc0200Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 3), )
if mibBuilder.loadTexts: cpsMc0200Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0200Table.setDescription('Sparse table containing one entry for each CPSMC0200 in the stack, indexed by cabinet serial number.')
cpsMc0200Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 3, 1), ).setIndexNames((0, "MCC16-MIB", "cpsMc0200BiaIndex"))
if mibBuilder.loadTexts: cpsMc0200Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0200Entry.setDescription('Status and configuration entries for a single CPSMC0200')
cpsMc0200BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0200BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0200BiaIndex.setDescription('The serial number (BIA) of the cabinet')
cpsMc0200Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0200Description.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0200Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
cpsMc0200MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0200MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0200MRevision.setDescription('The marketing revision of this device')
cpsMc1900Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 4), )
if mibBuilder.loadTexts: cpsMc1900Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1900Table.setDescription('Sparse table containing one entry for each CPSMC1900 in the stack, indexed by cabinet serial number.')
cpsMc1900Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 4, 1), ).setIndexNames((0, "MCC16-MIB", "cpsMc1900BiaIndex"))
if mibBuilder.loadTexts: cpsMc1900Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1900Entry.setDescription('Status and configuration entries for a single CPSMC1900')
cpsMc1900BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1900BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1900BiaIndex.setDescription('The serial number (BIA) of the cabinet')
cpsMc1900Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1900Description.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1900Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
cpsMc1900MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc1900MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc1900MRevision.setDescription('The marketing revision of this device')
smacf100Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5), )
if mibBuilder.loadTexts: smacf100Table.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100Table.setDescription('Sparse table containing one entry for each SMACF100 in the stack, indexed by cabinet serial number.')
smacf100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1), ).setIndexNames((0, "MCC16-MIB", "smacf100BiaIndex"))
if mibBuilder.loadTexts: smacf100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100Entry.setDescription('Status and configuration entries for a single SMACF100')
smacf100BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100BiaIndex.setDescription('The serial number (BIA) of the cabinet')
smacf100Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100Description.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
smacf100MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100MRevision.setDescription('The marketing revision of this device')
smacf100SpanningTree = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100SpanningTree.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100SpanningTree.setDescription('This variable allows the agent to enable or disable Spanning Tree if it is supported. Not all versions of the hardware support Spanning Tree.')
smacf100ResetCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("doNothing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100ResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100ResetCounters.setDescription('When this variable is set to reset(1), all counters for all ports are reset to zero.')
smacf100SelfTest = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("selfTest", 1), ("doNothing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100SelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100SelfTest.setDescription('When this variable is set to selfTest(1), the cabinet will perform a self test.')
smacf100QosEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100QosEnable.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100QosEnable.setDescription('This variable allows Quality of Service functions to be enabled or disabled. This includes the processing of 802.1p tags (See smacf100QosHPThreshold(8), smacf100QosLqWeight(9), and smacf100QosHqWeight(10)), half-duplex back pressure and full-duplex flow control. (See smacf100PQosPause(63)). Port priority functionality (smacf100PQosPriority(62)) is always enabled.')
smacf100QosHPThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100QosHPThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100QosHPThreshold.setDescription("When an incoming 802.1p priority tag value is greater than or equal to this value (from 0 to 7), the incoming packet will be classified as high-priority. Ignored when smacf100QosEnable(7) is set to 'disabled(2)'.")
smacf100QosLqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100QosLqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100QosLqWeight.setDescription("A value between 1 and 15 indicating the number of packets that should be processed from the low-priority queue before attention is turned to the high-priority queue. Ignored when smacf100QosEnable(7) is set to 'disabled(2)'.")
smacf100QosHqWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100QosHqWeight.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100QosHqWeight.setDescription("A value between 1 and 15 indicating the number of packets that should be processed from the high-priority queue before attention is turned to the low-priority queue. Ignored when smacf100QosEnable(7) is set to 'disabled(2)'.")
smacf100SNMPModuleInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smacf100SNMPModuleInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100SNMPModuleInstalled.setDescription('When this variable is set to yes(1), a management module is installed in this particular SMACF100 cabinet.')
smacf100AgingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 5, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smacf100AgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: smacf100AgingTimer.setDescription("This configuration varible allows the MAC address aging timer to be adjusted. When an automatically discovered MAC address has not been heard from (i.e. no packets with this source address have been received) for longer than the time specified by this variable, it is deleted from the SMACF100's address cache. The time is specified in seconds (up to 1,048,575). If smacf100AgingTimer(12) is set to 0, MAC address aging is disabled.")
cpsMc0800Table = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 6), )
if mibBuilder.loadTexts: cpsMc0800Table.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0800Table.setDescription('Sparse table containing one entry for each CPSMC0800 in the stack, indexed by cabinet serial number.')
cpsMc0800Entry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 6, 1), ).setIndexNames((0, "MCC16-MIB", "cpsMc0800BiaIndex"))
if mibBuilder.loadTexts: cpsMc0800Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0800Entry.setDescription('Status and configuration entries for a single CPSMC0800')
cpsMc0800BiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0800BiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0800BiaIndex.setDescription('The serial number (BIA) of the cabinet')
cpsMc0800Description = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0800Description.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0800Description.setDescription('User defined text description of the cabinet. A mirror of cpsCabinetDescription.')
cpsMc0800MRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 2, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsMc0800MRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpsMc0800MRevision.setDescription('The marketing revision of this device')
cpsGroupCtrl = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsGroupCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: cpsGroupCtrl.setDescription("This string is used to select one or more groups of devices to receive mass configuration operations. When cpsGroupCtrl.0 is null, SNMP operations are performed in the standard way for SNMPv1. When cpsGroupCtrl.0 is not null, the Cabinet (BiaIndex) and Slot (SlotIndex) index values that uniquely identify a device are ignored, and instead the operation is applied to all devices that have Groups variables that contain user- or system-defined keywords that match those in cpsGroupCtrl.0. The CfgMatch variables (cpsSlotDetail) for each of these devices will be yes(1). Advanced options are invoked by prepending one of the following command characters to the keywords in cpsGroupCtrl.0: 1) '.' means 'Pick-One'. When any 'Pick-One' operators are present in the Group Control String, then one or more of the keywords so marked must appear in the Device Group String of the slide-in device for configuration changes to be allowed. 'Pick-One' is the default operation that is used when no command character is present on a keyword. 2) '-' or '!' means 'Prohibited'. When any 'Prohibited' operators are present in the Group Control String, then if any of the keywords so marked appears in the Device Group String of the slide-in device, then no configuration changes are applied. 3) '+' is the 'Required' operator. When any 'Required' operators are present in the Group Control String, then all of the keywords so marked must appear in the Device Group String of the slide-in device for configuration changes to be allowed. 4) '*' is a Wildcard that matches zero or more characters. It is the only command character that does not need to appear at the beginning of the keyword. It is also the only one that can be used in combination with the others within a single keyword.")
cpsSlotPwrTable = MibTable((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 2), )
if mibBuilder.loadTexts: cpsSlotPwrTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpsSlotPwrTable.setDescription('Sparse table containing one power control entry for each slot in the stack, indexed by cabinet serial number and slot.')
cpsSlotPwrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 2, 1), ).setIndexNames((0, "MCC16-MIB", "cpsSlotPwrBiaIndex"), (0, "MCC16-MIB", "cpsSlotPwrSlotIndex"))
if mibBuilder.loadTexts: cpsSlotPwrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpsSlotPwrEntry.setDescription('The power on/off control for a single Point System slot.')
cpsSlotPwrBiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsSlotPwrBiaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsSlotPwrBiaIndex.setDescription('The cabinet serial number (BIA) of the slot')
cpsSlotPwrSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpsSlotPwrSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpsSlotPwrSlotIndex.setDescription('The slot number of the slot')
cpsSlotPwrState = MibTableColumn((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsSlotPwrState.setStatus('mandatory')
if mibBuilder.loadTexts: cpsSlotPwrState.setDescription('The power control for the slot. When off(2), no power is supplied to the slot. If examined, the slot will appear empty.')
cpsIsPrimary = MibScalar((1, 3, 6, 1, 4, 1, 868, 2, 4, 2, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpsIsPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: cpsIsPrimary.setDescription("Indicates whether or not this Management Module is the primary Management Module in the stack. This variable contains the same information as the cpsmm100IsPrimary variable, but answers a slightly different question: cpsmm100IsPrimary answers 'what is the primary status of the management module in cabinet C slot S?' and cpsIsPrimary answers 'what is the primary status of the management module I am talking to now?' The difference is that cpsIsPrimary does not require that the requestor translate the IP address of the management module they are communicating with into a cabinet serial number (BIA) and slot index. This could otherwise only be accomplished via a sequential search through cpsmm100Table")
mibBuilder.exportSymbols("MCC16-MIB", crmfe100RmtFault=crmfe100RmtFault, smacf100PRxDropPkts=smacf100PRxDropPkts, cemtf100ConnB=cemtf100ConnB, smacf100PFarEndFaultCfg=smacf100PFarEndFaultCfg, ct1e1Cf01Id=ct1e1Cf01Id, cbftf100BiaIndex=cbftf100BiaIndex, crmfe100RmtLinkPassThrough=crmfe100RmtLinkPassThrough, cdftf100FiberLinkTbl=cdftf100FiberLinkTbl, cettf100Groups=cettf100Groups, cetct100Groups=cetct100Groups, smacf100Description=smacf100Description, cmefg100Groups=cmefg100Groups, cpsmp110MasterCurrentFault=cpsmp110MasterCurrentFault, carCf02Table=carCf02Table, cpsvt100MRevision=cpsvt100MRevision, cmefg100ImcRxJabbersTbl=cmefg100ImcRxJabbersTbl, cdftf100SlotIndex=cdftf100SlotIndex, cfetf100Fault=cfetf100Fault, cfetf100FiberLink=cfetf100FiberLink, ceCxFrl04Jabber=ceCxFrl04Jabber, ceTxSx02TPLink=ceTxSx02TPLink, cmefg100VlanEditFwdTp=cmefg100VlanEditFwdTp, cpsmm100IsPrimary=cpsmm100IsPrimary, csetf100FiberLink=csetf100FiberLink, cpsvt100SlotIndex=cpsvt100SlotIndex, cmefg100VlanEditFwdFiber=cmefg100VlanEditFwdFiber, captf100Id=captf100Id, captf100MRevision=captf100MRevision, cfetf205TPLink=cfetf205TPLink, cpsSlotPwrBiaIndex=cpsSlotPwrBiaIndex, cpsmp110MasterTempFault=cpsmp110MasterTempFault, cettf100TPActivity=cettf100TPActivity, ceTbtFrl03FiberLink=ceTbtFrl03FiberLink, cpsSlotDetail=cpsSlotDetail, crs2f100CfgMatch=crs2f100CfgMatch, cemtf100MRevision=cemtf100MRevision, smacf100PTxMultipleCollision=smacf100PTxMultipleCollision, crmfe100RmtUpTime=crmfe100RmtUpTime, cmefg100ImcRxQosPktsTbl=cmefg100ImcRxQosPktsTbl, cmefg100LocDmiTxBiasAlarm=cmefg100LocDmiTxBiasAlarm, smacf100PSACCfg=smacf100PSACCfg, captf100Fault=captf100Fault, cbftf100FullDuplexTbl=cbftf100FullDuplexTbl, cmefg100ImcRxFragmentsTbl=cmefg100ImcRxFragmentsTbl, cpsvt100DCE=cpsvt100DCE, cgfeb100TPQosPause=cgfeb100TPQosPause, cfetf105FiberLink=cfetf105FiberLink, cfetf105Id=cfetf105Id, cmefg100RmtColdStart=cmefg100RmtColdStart, cemtf100FiberLink=cemtf100FiberLink, cpsmm100Entry=cpsmm100Entry, cetct100Entry=cetct100Entry, cbftf150CfgMatch=cbftf150CfgMatch, ce100BtxFx04MtFiberSignalDetect=ce100BtxFx04MtFiberSignalDetect, crmfe100Autonegot=crmfe100Autonegot, cfetf105SlotIndex=cfetf105SlotIndex, cgfeb100QosHPThreshold=cgfeb100QosHPThreshold, cpsmp100LFanFault=cpsmp100LFanFault, cbftf150FirmwareRevision=cbftf150FirmwareRevision, cmefg100VlanEditCmd=cmefg100VlanEditCmd, cpsMc1300PSPower1=cpsMc1300PSPower1, cmefg100Entry=cmefg100Entry, cfetf105BiaIndex=cfetf105BiaIndex, cpsmm200MRevision=cpsmm200MRevision, cpsmm100IPAddress=cpsmm100IPAddress, cpsmp110SubDeviceIndex=cpsmp110SubDeviceIndex, cpsMc0800Entry=cpsMc0800Entry, smacf100PQosPriority=smacf100PQosPriority, ctrCf01Index=ctrCf01Index, cpsvt100SerialNumber=cpsvt100SerialNumber, cfetf105ConnB=cfetf105ConnB, cmefg100ImcTxDropPktsTbl=cmefg100ImcTxDropPktsTbl, crmfe100RmtAutonegot=crmfe100RmtAutonegot, crs2f100Fault=crs2f100Fault, chstrCf01Entry=chstrCf01Entry, cgfeb100FiberLpAdvPause=cgfeb100FiberLpAdvPause, cmefg100ImcTxQosOctetsWrapTbl=cmefg100ImcTxQosOctetsWrapTbl, cpsmm100WantPrimary=cpsmm100WantPrimary, pSCabinetRemoved=pSCabinetRemoved, crs2f100ConnA=crs2f100ConnA, ce100BtxSx01Index=ce100BtxSx01Index, smacf100PTable=smacf100PTable, cpsvt100ConnB=cpsvt100ConnB, cpsMc0800Description=cpsMc0800Description, ceTbtFrl03Id=ceTbtFrl03Id, chstrCf01TPRecv=chstrCf01TPRecv, captf100SlotIndex=captf100SlotIndex, csetf100CacheClean=csetf100CacheClean, carCf02FiberRecv=carCf02FiberRecv, cpsmm100SerialNumber=cpsmm100SerialNumber, cePswSx01Table=cePswSx01Table, cpsmm200BiaIndex=cpsmm200BiaIndex, smacf100Entry=smacf100Entry, smacf100BiaIndex=smacf100BiaIndex, cgfeb100FiberAutoNegot=cgfeb100FiberAutoNegot, caCf02Table=caCf02Table, crs4f100Table=crs4f100Table, csdtf100TPCoax=csdtf100TPCoax, smacf100PPkts1024to1522Octets=smacf100PPkts1024to1522Octets, cbftf150ConnectorTbl=cbftf150ConnectorTbl, ctrCf01Entry=ctrCf01Entry, cpsvt100RmtConfigMode=cpsvt100RmtConfigMode, cePswSx01FiberFullDuplex=cePswSx01FiberFullDuplex, cmefg100LocFiberPause=cmefg100LocFiberPause, cfetf205AutoCross=cfetf205AutoCross, cfetf100Id=cfetf100Id, ce100BtxFx04MtTPRecv=ce100BtxFx04MtTPRecv, crmfe100SerialNumber=crmfe100SerialNumber, mcc16ComMgmtSwRev=mcc16ComMgmtSwRev, cettf100Id=cettf100Id, cbftf100PauseCfgTbl=cbftf100PauseCfgTbl, cpsmp100PowerOK=cpsmp100PowerOK, csdtf100CacheClean=csdtf100CacheClean, crmfe100CfgMatch=crmfe100CfgMatch, cpsvt100RmtFiberLink=cpsvt100RmtFiberLink, cpsMc1800Entry=cpsMc1800Entry, smacf100PRxExcessSizeDisc=smacf100PRxExcessSizeDisc, cgfeb100FiberAdvPause=cgfeb100FiberAdvPause, cmefg100RmtFactoryReset=cmefg100RmtFactoryReset, cpsvt100Groups=cpsvt100Groups, cmefg100LocFxTxBwaKb=cmefg100LocFxTxBwaKb, ceTbtFrl04TPLink=ceTbtFrl04TPLink, cePswFx03TP100Mbps=cePswFx03TP100Mbps, cbftf100100MbpsTbl=cbftf100100MbpsTbl, crs2f100RmtDCE=crs2f100RmtDCE, cpsvt100CopperLink=cpsvt100CopperLink, cgetf100ConnA=cgetf100ConnA, cmefg100LadEditVid=cmefg100LadEditVid, cmefg100RmtDmiTxBiasAlarm=cmefg100RmtDmiTxBiasAlarm, cdftf100FiberActivityTbl=cdftf100FiberActivityTbl, cpsvt100RmtFirmwareRev=cpsvt100RmtFirmwareRev, smacf100PSubDeviceIndex=smacf100PSubDeviceIndex, cpsMc1300PSInUse2=cpsMc1300PSInUse2, cbftf100SpanningTree=cbftf100SpanningTree, cgfeb100FiberLpAdv1000HDX=cgfeb100FiberLpAdv1000HDX, cgfeb100Table=cgfeb100Table, ceRTxFx01TPSignalDetect=ceRTxFx01TPSignalDetect, cfSmMm04Entry=cfSmMm04Entry, ce100BtxFx04FiberRecv=ce100BtxFx04FiberRecv, cfdCd01TPSignalDetect=cfdCd01TPSignalDetect, cmefg100LocFiberDuplex=cmefg100LocFiberDuplex, ceTbtFrl04Id=ceTbtFrl04Id, cmefg100RmtOamPeerMultiplexorState=cmefg100RmtOamPeerMultiplexorState, cgfeb100TPLpAdvPause=cgfeb100TPLpAdvPause, cmefg100ImcRxQosOctetsWrapTbl=cmefg100ImcRxQosOctetsWrapTbl, cmefg100RmtFpgaRev=cmefg100RmtFpgaRev, cpsCabinetModel=cpsCabinetModel, cmefg100RmtDmiTxPower=cmefg100RmtDmiTxPower, cfetf205Table=cfetf205Table, cpsMc0800Table=cpsMc0800Table, cettf100BiaIndex=cettf100BiaIndex, carCf02Power=carCf02Power, csetf100TPActivity=csetf100TPActivity, cmefg100LocOamInformationTx=cmefg100LocOamInformationTx, cgfeb100TPLpAdv100FDX=cgfeb100TPLpAdv100FDX, captf100Table=captf100Table, ccscf100Entry=ccscf100Entry, ccscf100FiberLoopback=ccscf100FiberLoopback, ccscf100ConfigMode=ccscf100ConfigMode, cpsvt100RmtCopperLink=cpsvt100RmtCopperLink, ce100BtxFrl03FiberSignalDetect=ce100BtxFrl03FiberSignalDetect, slotCps=slotCps, cmefg100LocFirmwareRevision=cmefg100LocFirmwareRevision, csdtf100BiaIndex=csdtf100BiaIndex, cgfeb100TPSacStat=cgfeb100TPSacStat, cmefg100LocDmiRxPower=cmefg100LocDmiRxPower, chassisCpsmc1850Id=chassisCpsmc1850Id, cgetf100Enabled=cgetf100Enabled, cmefg100LocOamVarRetrieval=cmefg100LocOamVarRetrieval, smacf100PRxUndersizePkts=smacf100PRxUndersizePkts, cbftf100ConfigMode=cbftf100ConfigMode, smacf100PRxGoodOctets=smacf100PRxGoodOctets, cmefg100LocTpLink=cmefg100LocTpLink, cettf100Fault=cettf100Fault, ce100BtxFx04MtPower=ce100BtxFx04MtPower, smacf100PTxSingleCollision=smacf100PTxSingleCollision, cmefg100LadPortTbl=cmefg100LadPortTbl, captf100FiberLink=captf100FiberLink, csdtf100RmtConnA=csdtf100RmtConnA, cetct100CfgMatch=cetct100CfgMatch, cbftf100Groups=cbftf100Groups, cdftf100TPLinkTbl=cdftf100TPLinkTbl, cmefg100RmtOamPeerVendorInfo=cmefg100RmtOamPeerVendorInfo, cmefg100LocOamOrgSpecificRx=cmefg100LocOamOrgSpecificRx, mcc16Error=mcc16Error, cmefg100LocOamMultiplexorState=cmefg100LocOamMultiplexorState, cfetf105ConnA=cfetf105ConnA, cfetf105LinkPassThrough=cfetf105LinkPassThrough, cbftf150MRevision=cbftf150MRevision, cpsmp100ChassisPower=cpsmp100ChassisPower, ctrCf01Table=ctrCf01Table, smacf100PSlotIndex=smacf100PSlotIndex, cpsmp110PSReadyTbl=cpsmp110PSReadyTbl, ce100BtxSx01FiberSignalDetect=ce100BtxSx01FiberSignalDetect, cmefg100LocOamActiveMode=cmefg100LocOamActiveMode, ceCxFrl04Table=ceCxFrl04Table, ceCxTbt04Entry=ceCxTbt04Entry, ccscf100FiberLink=ccscf100FiberLink, smacf100PEnabled=smacf100PEnabled, cettf100CacheClean=cettf100CacheClean, csetf100SlotIndex=csetf100SlotIndex, cbftf100Entry=cbftf100Entry, ce100BtxFrl03Lock=ce100BtxFrl03Lock, ccscf100CopperLink=ccscf100CopperLink, cpsvt100InvertRX=cpsvt100InvertRX, crs4f100CacheClean=crs4f100CacheClean, cePswFx03TPFullDuplex=cePswFx03TPFullDuplex, cpsMc1300Table=cpsMc1300Table, cfSmMm06Entry=cfSmMm06Entry, cbCf01Index=cbCf01Index, crmfe100TPLink=crmfe100TPLink, cetct100ConnA=cetct100ConnA, MacAddress=MacAddress, cfSmMm02Id=cfSmMm02Id, cePswFx03TPLink=cePswFx03TPLink, csdtf100TAOSFiber=csdtf100TAOSFiber, crs4f100FiberLink=crs4f100FiberLink, cgfeb100FiberAdv1000FDX=cgfeb100FiberAdv1000FDX, cmefg100RmtDetected=cmefg100RmtDetected, cemtf100Groups=cemtf100Groups, ccscf100MRevision=ccscf100MRevision, cpsvt100RmtDCE=cpsvt100RmtDCE, cpsMc0800BiaIndex=cpsMc0800BiaIndex, cpsMc1800PSPower1=cpsMc1800PSPower1, csdtf100RmtMRevision=csdtf100RmtMRevision, cfSmMm06Power=cfSmMm06Power, cmefg100ImcTxCollisionsTbl=cmefg100ImcTxCollisionsTbl, smacf100PBlockPort=smacf100PBlockPort, cfSmMm02Table=cfSmMm02Table, crs2f100RmtCopperActivity=crs2f100RmtCopperActivity, pSErrorClear=pSErrorClear, ce100BtxFrl03Id=ce100BtxFrl03Id, cgfeb100FiberSacStat=cgfeb100FiberSacStat, cpsMc1300PSInUse1=cpsMc1300PSInUse1, cfetf100Entry=cfetf100Entry, cmefg100RmtOamRmtLoopback=cmefg100RmtOamRmtLoopback, cbftf100Id=cbftf100Id, cemtf100Fault=cemtf100Fault, ceCxFrl04Power=ceCxFrl04Power, cfetf100Enabled=cfetf100Enabled, cmefg100LocTpAdv10FDX=cmefg100LocTpAdv10FDX, cmefg100ImcRxPkts128to255OctetsTbl=cmefg100ImcRxPkts128to255OctetsTbl, cpsmm100TntRIPMask=cpsmm100TntRIPMask, cpsmp110PSInUseTbl=cpsmp110PSInUseTbl, cfetf205SlotIndex=cfetf205SlotIndex, cpsmm100SNMPTrapInterval=cpsmm100SNMPTrapInterval, cfSmMm05Power=cfSmMm05Power, cfetf105MRevision=cfetf105MRevision, cfetf100SlotIndex=cfetf100SlotIndex, cmefg100LadCacheState=cmefg100LadCacheState, cpsmm200Table=cpsmm200Table, cbftf100FarEndFaultTbl=cbftf100FarEndFaultTbl, crs2f100Loopback=crs2f100Loopback, ce100BtxFx04MtTable=ce100BtxFx04MtTable)
mibBuilder.exportSymbols("MCC16-MIB", cfetf105Groups=cfetf105Groups, chassisSlotTypes=chassisSlotTypes, crmfe100RmtNetworkMode=crmfe100RmtNetworkMode, cmefg100RmtDmiTempAlarm=cmefg100RmtDmiTempAlarm, carCf02Entry=carCf02Entry, cpsmm100SysName=cpsmm100SysName, cettf100ConfigMode=cettf100ConfigMode, smacf100PAdv10FDX=smacf100PAdv10FDX, cpsld100Table=cpsld100Table, cpsmm100LastGasp=cpsmm100LastGasp, cmefg100VlanVidTagCtrl=cmefg100VlanVidTagCtrl, crs2f100Groups=crs2f100Groups, cpsmm200Entry=cpsmm200Entry, ceCxTbt04CoaxRecv=ceCxTbt04CoaxRecv, chassisCpsmc1300Id=chassisCpsmc1300Id, cgfeb100FiberAdv1000HDX=cgfeb100FiberAdv1000HDX, chstrCf01TPSignalDetect=chstrCf01TPSignalDetect, cpsMc1900Table=cpsMc1900Table, cfetf205Entry=cfetf205Entry, cdftf100MRevision=cdftf100MRevision, cbftf100FirmwareRevision=cbftf100FirmwareRevision, cpsmp110Id=cpsmp110Id, crmfe100Id=crmfe100Id, cfetf100Groups=cfetf100Groups, cfSmMm05Id=cfSmMm05Id, smacf100PTxOctets=smacf100PTxOctets, crmfe100RmtDetected=crmfe100RmtDetected, smacf100PRxUnicastPkts=smacf100PRxUnicastPkts, crs4f100BiaIndex=crs4f100BiaIndex, cmefg100ImcRxAlignmentErrorsTbl=cmefg100ImcRxAlignmentErrorsTbl, smacf100PTxMulticastPkts=smacf100PTxMulticastPkts, cpsvt100Table=cpsvt100Table, cmefg100LocFiberSacStatus=cmefg100LocFiberSacStatus, cgetf100Groups=cgetf100Groups, cetct100Table=cetct100Table, cmefg100VlanIngressVidHitNoMem=cmefg100VlanIngressVidHitNoMem, cmefg100RmtOamVarRetrieval=cmefg100RmtOamVarRetrieval, cmefg100LadEditMac=cmefg100LadEditMac, cfetf205FiberActivity=cfetf205FiberActivity, caCf02Index=caCf02Index, cpsmp110MasterFanFault=cpsmp110MasterFanFault, cemtf100Entry=cemtf100Entry, cmefg100RmtTpSpeed=cmefg100RmtTpSpeed, cpsmp100SerialNumber=cpsmp100SerialNumber, cmefg100ImcTxMultipleCollisionTbl=cmefg100ImcTxMultipleCollisionTbl, cmefg100ImcRxPkts512to1023OctetsTbl=cmefg100ImcRxPkts512to1023OctetsTbl, cettf100ConnA=cettf100ConnA, cmefg100LocOamLoopbackControlRx=cmefg100LocOamLoopbackControlRx, cetct100CollisionsPerHour=cetct100CollisionsPerHour, cpsMc1300BiaIndex=cpsMc1300BiaIndex, cettf100AutoCross=cettf100AutoCross, cmefg100LocOamMaxOamPduSize=cmefg100LocOamMaxOamPduSize, cettf100SerialNumber=cettf100SerialNumber, cpsSlotPwrSlotIndex=cpsSlotPwrSlotIndex, cpsMc1300PSPower2=cpsMc1300PSPower2, smacf100SpanningTree=smacf100SpanningTree, smacf100PId=smacf100PId, csdtf100RmtConnB=csdtf100RmtConnB, ctrCf01Id=ctrCf01Id, cgetf100PauseType=cgetf100PauseType, cpsvt100RmtInvertTX=cpsvt100RmtInvertTX, cgetf100TPLength=cgetf100TPLength, cbCf01Table=cbCf01Table, cfdCd01Lock=cfdCd01Lock, cpsmm100SysContact=cpsmm100SysContact, ct1e1Cf01CoaxActive=ct1e1Cf01CoaxActive, cpsvt100RmtDetected=cpsvt100RmtDetected, cfdCd01Index=cfdCd01Index, cfetf100BiaIndex=cfetf100BiaIndex, cePswFx03Index=cePswFx03Index, csetf100AutoCross=csetf100AutoCross, cmefg100ImcLocEnable=cmefg100ImcLocEnable, cgfeb100ConnB=cgfeb100ConnB, crs2f100SlotIndex=crs2f100SlotIndex, cgfeb100TPAdv1000FDX=cgfeb100TPAdv1000FDX, ccscf100Table=ccscf100Table, cpsMc0200Description=cpsMc0200Description, cmefg100ImcRmtEnable=cmefg100ImcRmtEnable, cfetf100CacheClean=cfetf100CacheClean, csetf100ConnB=csetf100ConnB, cgfeb100TPFullDuplexCfg=cgfeb100TPFullDuplexCfg, ceCxFrl04FLRecv=ceCxFrl04FLRecv, cmefg100RmtUptime=cmefg100RmtUptime, cpsModuleBiaIndex=cpsModuleBiaIndex, crs2f100CopperActivity=crs2f100CopperActivity, cgfeb100TPFullDuplexStat=cgfeb100TPFullDuplexStat, smacf100QosLqWeight=smacf100QosLqWeight, cmefg100QosHqWeight=cmefg100QosHqWeight, cmefg100RmtTpAutoNegot=cmefg100RmtTpAutoNegot, cbftf100MirrorOutTbl=cbftf100MirrorOutTbl, cmefg100LocFiberAdv1000FDX=cmefg100LocFiberAdv1000FDX, cfdCd01Id=cfdCd01Id, crs4f100Id=crs4f100Id, cmefg100LocTpAdv10HDX=cmefg100LocTpAdv10HDX, cmefg100VlanTagIn=cmefg100VlanTagIn, cgetf100CacheClean=cgetf100CacheClean, cmefg100ImcRxSAChangesTbl=cmefg100ImcRxSAChangesTbl, cbftf100SACStatTbl=cbftf100SACStatTbl, caCf02Power=caCf02Power, cmefg100ImcRxPausePktsTbl=cmefg100ImcRxPausePktsTbl, csdtf100Entry=csdtf100Entry, cpsMc1800BiaIndex=cpsMc1800BiaIndex, cePswSx01TP100Mbps=cePswSx01TP100Mbps, cmefg100LocOamConfigRevision=cmefg100LocOamConfigRevision, ccscf100AISFiber=ccscf100AISFiber, ce100BtxFrl03Table=ce100BtxFrl03Table, cpsmm100EthernetLink=cpsmm100EthernetLink, crs2f100Entry=crs2f100Entry, crmfe100MbTxFxBwa=crmfe100MbTxFxBwa, cgfeb100CfgMatch=cgfeb100CfgMatch, cgfeb100TPAdv100FDX=cgfeb100TPAdv100FDX, cgfeb100TPLpAdv1000FDX=cgfeb100TPLpAdv1000FDX, chstrCf01Id=chstrCf01Id, ceTbtFrl03TPRecv=ceTbtFrl03TPRecv, cmefg100LocUptime=cmefg100LocUptime, cpsmm100Groups=cpsmm100Groups, csdtf100ConnA=csdtf100ConnA, cfetf205ConnB=cfetf205ConnB, cgetf100CfgMatch=cgetf100CfgMatch, ceTbtFrl03Index=ceTbtFrl03Index, csetf100MRevision=csetf100MRevision, cdftf100Entry=cdftf100Entry, mcc16ComIpAddr=mcc16ComIpAddr, captf100CfgMatch=captf100CfgMatch, cpsMc1800PSInUse2=cpsMc1800PSInUse2, cmefg100LadMacTbl=cmefg100LadMacTbl, crs4f100ConnB=crs4f100ConnB, cfetf100ConnA=cfetf100ConnA, cfmff100MRevision=cfmff100MRevision, crs4f100FirmwareRevision=crs4f100FirmwareRevision, cgetf100FiberAutoNegot=cgetf100FiberAutoNegot, cettf100Enabled=cettf100Enabled, cgetf100Fault=cgetf100Fault, cmefg100LocFiberConnA=cmefg100LocFiberConnA, transition=transition, cfetf205Pause=cfetf205Pause, cpsModuleSlotIndex=cpsModuleSlotIndex, cpsCabDetail=cpsCabDetail, cePswSx01TPLink=cePswSx01TPLink, cettf100FiberActivity=cettf100FiberActivity, smacf100PRxFCSErrors=smacf100PRxFCSErrors, cmefg100RmtFiberPause=cmefg100RmtFiberPause, smacf100PWrapTxOctets=smacf100PWrapTxOctets, cfmff100Entry=cfmff100Entry, cpsmm100HwRevision=cpsmm100HwRevision, cmefg100RmtTpLink=cmefg100RmtTpLink, cbftf150SlotIndex=cbftf150SlotIndex, crs2f100RmtConfigMode=crs2f100RmtConfigMode, csdtf100RmtCopperLoopback=csdtf100RmtCopperLoopback, cettf100SlotIndex=cettf100SlotIndex, cePswSx01Entry=cePswSx01Entry, cpsGroupCtrl=cpsGroupCtrl, ce100BtxFx04MtTPSignalDetect=ce100BtxFx04MtTPSignalDetect, cmefg100QosPriority=cmefg100QosPriority, crmfe100TxBytesL=crmfe100TxBytesL, cbCf01FiberRecv=cbCf01FiberRecv, cfetf105SerialNumber=cfetf105SerialNumber, cetct100CollisionsPerMinute=cetct100CollisionsPerMinute, cmefg100LocTpAdv1000FDX=cmefg100LocTpAdv1000FDX, cfmff100PortShutOff=cfmff100PortShutOff, cpsIsPrimary=cpsIsPrimary, cpsMc1300MRevision=cpsMc1300MRevision, csdtf100RmtFiberLink=csdtf100RmtFiberLink, cpsCabSummary=cpsCabSummary, ce100BtxFx04Table=ce100BtxFx04Table, cetct100TPLink=cetct100TPLink, cmefg100RmtTpAdv10FDX=cmefg100RmtTpAdv10FDX, cmefg100ImcRxMulticastPktsTbl=cmefg100ImcRxMulticastPktsTbl, cfmff100CacheClean=cfmff100CacheClean, cpsvt100Fault=cpsvt100Fault, cfetf105TPLink=cfetf105TPLink, cdftf100CacheClean=cdftf100CacheClean, cmefg100CacheClean=cmefg100CacheClean, cettf100TPLink=cettf100TPLink, csdtf100CopperLoopback=csdtf100CopperLoopback, CpsConnector=CpsConnector, cbftf100CfgMatch=cbftf100CfgMatch, ce100BtxFrl03Entry=ce100BtxFrl03Entry, cmefg100LocTpCross=cmefg100LocTpCross, cmefg100LocTpAdv100FDX=cmefg100LocTpAdv100FDX, cmefg100RmtOamLinkEvents=cmefg100RmtOamLinkEvents, smacf100PSTPState=smacf100PSTPState, ceTxSx02Entry=ceTxSx02Entry, cpsld100Entry=cpsld100Entry, cfetf105CfgMatch=cfetf105CfgMatch, mcc16ComGateway=mcc16ComGateway, ce100BtxFx04FiberSignalDetect=ce100BtxFx04FiberSignalDetect, ccscf100CopperLoopback=ccscf100CopperLoopback, smacf100PTxLateCollision=smacf100PTxLateCollision, cbftf100FormFactor=cbftf100FormFactor, cpsmp100InUse=cpsmp100InUse, ceCxFrl04Entry=ceCxFrl04Entry, cmefg100ImcTxDeferredTransmitTbl=cmefg100ImcTxDeferredTransmitTbl, cpsMc1800PSInUse1=cpsMc1800PSInUse1, cmefg100CfgMatch=cmefg100CfgMatch, cpsmm100SNMPTrapMgr2=cpsmm100SNMPTrapMgr2, cbftf100MirrorSelTbl=cbftf100MirrorSelTbl, cpsld100SlotIndex=cpsld100SlotIndex, cmefg100LocSelfTestFailed=cmefg100LocSelfTestFailed, cfdCd01FiberRecv=cfdCd01FiberRecv, cfmff100Table=cfmff100Table, cemtf100SlotIndex=cemtf100SlotIndex, cpsmp110Table=cpsmp110Table, mcc16PSState=mcc16PSState, ceCxFrl04CoaxRecv=ceCxFrl04CoaxRecv, cfSmMm02MMSignalDetect=cfSmMm02MMSignalDetect, cePswFx03Id=cePswFx03Id, cmefg100LocDmiTxPowerAlarm=cmefg100LocDmiTxPowerAlarm, crmfe100ConnB=crmfe100ConnB, csdtf100AISFiber=csdtf100AISFiber, cemtf100SerialNumber=cemtf100SerialNumber, cmefg100LocOamDuplicateEventNotificationRx=cmefg100LocOamDuplicateEventNotificationRx, cmefg100VlanFiberInUntaggedDrop=cmefg100VlanFiberInUntaggedDrop, ceTbtFrl04Index=ceTbtFrl04Index, cfmff100SerialNumber=cfmff100SerialNumber, cbftf100CacheClean=cbftf100CacheClean, cfetf205FastLinkPulse=cfetf205FastLinkPulse, cmefg100ImcRxOversizePktsTbl=cmefg100ImcRxOversizePktsTbl, carCf01Id=carCf01Id, cgetf100SerialNumber=cgetf100SerialNumber, ct1e1Cf01Table=ct1e1Cf01Table, ceRTxFx01Index=ceRTxFx01Index, cfetf100ConfigMode=cfetf100ConfigMode, cfmff100Id=cfmff100Id, cmefg100ImcRxUnicastPktsTbl=cmefg100ImcRxUnicastPktsTbl, cmefg100ImcRxQosOctetsTbl=cmefg100ImcRxQosOctetsTbl, cmefg100ImcTxOctetsWrapTbl=cmefg100ImcTxOctetsWrapTbl, cemtf100CfgMatch=cemtf100CfgMatch, cRs232Cf01Entry=cRs232Cf01Entry, cpsmp110FanStatusTbl=cpsmp110FanStatusTbl, cfSmMm02Index=cfSmMm02Index, ceTbtFrl04FiberLink=ceTbtFrl04FiberLink, cfetf105Entry=cfetf105Entry, cmefg100LocTpAdv1000HDX=cmefg100LocTpAdv1000HDX, smacf100PRxOversizePkts=smacf100PRxOversizePkts, cmefg100RmtDmiRxPowerAlarm=cmefg100RmtDmiRxPowerAlarm, cbftf150SubDeviceIndex=cbftf150SubDeviceIndex, smacf100PAutoNegot=smacf100PAutoNegot, cbftf100SelfTestFailed=cbftf100SelfTestFailed, crmfe100RmtAutoCross=crmfe100RmtAutoCross, cgfeb100TPCrossStat=cgfeb100TPCrossStat, cmefg100ImcRxGoodOctetsTbl=cmefg100ImcRxGoodOctetsTbl, smacf100PRxSAChanges=smacf100PRxSAChanges, cfetf205FiberLink=cfetf205FiberLink, cfSmMm02Entry=cfSmMm02Entry, smacf100PTxUnicastPkts=smacf100PTxUnicastPkts, cpsmp100Table=cpsmp100Table, cbCf01Entry=cbCf01Entry, cpsModuleTable=cpsModuleTable, smacf100PGroups=smacf100PGroups, cetct100ConnB=cetct100ConnB, cbftf150Table=cbftf150Table, cmefg100RmtTpAdv100HDX=cmefg100RmtTpAdv100HDX, cdftf100Id=cdftf100Id)
mibBuilder.exportSymbols("MCC16-MIB", cpsmM200Id=cpsmM200Id, ct1e1Cf01Entry=ct1e1Cf01Entry, smacf100PCacheClean=smacf100PCacheClean, crmfe100RmtPause=crmfe100RmtPause, cpsEmptyId=cpsEmptyId, cmefg100LadEditPort=cmefg100LadEditPort, crs2f100RmtLoopback=crs2f100RmtLoopback, csdtf100RmtAISFiber=csdtf100RmtAISFiber, cpsmm100BiaIndex=cpsmm100BiaIndex, ceRTxFx01Entry=ceRTxFx01Entry, cpsvt100CacheClean=cpsvt100CacheClean, smacf100PWrapRxOctets=smacf100PWrapRxOctets, smacf100QosHPThreshold=smacf100QosHPThreshold, cgetf100LinkPassThrough=cgetf100LinkPassThrough, cbftf150Id=cbftf150Id, cfSmMm04Index=cfSmMm04Index, ceTxSx02100Mbps=ceTxSx02100Mbps, crs4f100SlotIndex=crs4f100SlotIndex, csdtf100SlotIndex=csdtf100SlotIndex, ceTbtFrl04FiberRecv=ceTbtFrl04FiberRecv, cfetf205BiaIndex=cfetf205BiaIndex, ceTbtFrl03Power=ceTbtFrl03Power, cdftf100CfgMatch=cdftf100CfgMatch, cettf100MRevision=cettf100MRevision, cmefg100LocTpSpeed=cmefg100LocTpSpeed, cbCf01Id=cbCf01Id, csdtf100ConnB=csdtf100ConnB, cmefg100LocOamOrgSpecificTx=cmefg100LocOamOrgSpecificTx, cmefg100ImcRxUndersizePktsTbl=cmefg100ImcRxUndersizePktsTbl, ce100BtxFx04MtIndex=ce100BtxFx04MtIndex, cfetf205LinkPassThrough=cfetf205LinkPassThrough, cbftf100CrossTbl=cbftf100CrossTbl, crmfe100MbFxTxBwa=crmfe100MbFxTxBwa, smacf100PSACStat=smacf100PSACStat, cpsvt100LoopBack=cpsvt100LoopBack, crmfe100MscRxBytes=crmfe100MscRxBytes, ceRTxFx01Table=ceRTxFx01Table, cgfeb100TPSpeedCfg=cgfeb100TPSpeedCfg, ce100BtxSx01TPRecv=ce100BtxSx01TPRecv, ceCxTbt04Id=ceCxTbt04Id, cetct100Id=cetct100Id, ce100BtxSx01Entry=ce100BtxSx01Entry, cps=cps, ccscf100Id=ccscf100Id, ce100BtxFx04TPSignalDetect=ce100BtxFx04TPSignalDetect, cgfeb100Groups=cgfeb100Groups, cemtf100CacheClean=cemtf100CacheClean, cgetf100Table=cgetf100Table, smacf100PBiaIndex=smacf100PBiaIndex, crmfe100RmtTPActivity=crmfe100RmtTPActivity, cmefg100LadEntries=cmefg100LadEntries, cgfeb100BiaIndex=cgfeb100BiaIndex, csdtf100CfgMatch=csdtf100CfgMatch, smacf100PTxDropPkts=smacf100PTxDropPkts, csetf100CfgMatch=csetf100CfgMatch, cpsmp100SupplyType=cpsmp100SupplyType, ccscf100ConnB=ccscf100ConnB, crmfe100FarEndFault=crmfe100FarEndFault, cmefg100RmtOamCriticalEvent=cmefg100RmtOamCriticalEvent, cmefg100LocOamControlInUnknownOpcodes=cmefg100LocOamControlInUnknownOpcodes, csetf100Speed100Mbps=csetf100Speed100Mbps, cgfeb100Entry=cgfeb100Entry, crmfe100TPActivity=crmfe100TPActivity, cbftf100MRevision=cbftf100MRevision, crmfe100FiberActivity=crmfe100FiberActivity, captf100SerialNumber=captf100SerialNumber, pSPowerLost=pSPowerLost, cdftf100Groups=cdftf100Groups, cfetf100TPActivity=cfetf100TPActivity, mcc16SlotEntry=mcc16SlotEntry, cmefg100LocTpDuplex=cmefg100LocTpDuplex, cmefg100VlanFiberDefaultVid=cmefg100VlanFiberDefaultVid, ccscf100AISCopper=ccscf100AISCopper, cbftf150100MbpsTbl=cbftf150100MbpsTbl, cmefg100ImcTxPausePktsTbl=cmefg100ImcTxPausePktsTbl, cpsMc1900MRevision=cpsMc1900MRevision, ctrCf01Inserted=ctrCf01Inserted, ceRTxFx01FiberSignalDetect=ceRTxFx01FiberSignalDetect, cpsmp110MRevision=cpsmp110MRevision, crs4f100SerialNumber=crs4f100SerialNumber, cpsld100BiaIndex=cpsld100BiaIndex, ccscf100Groups=ccscf100Groups, cpsmp100RemoteFan=cpsmp100RemoteFan, csetf100BiaIndex=csetf100BiaIndex, cRs232Cf01FiberLock=cRs232Cf01FiberLock, crmfe100Groups=crmfe100Groups, csdtf100RmtTAOSFiber=csdtf100RmtTAOSFiber, crs4f100Entry=crs4f100Entry, ct1e1Cf01FiberSignalDetect=ct1e1Cf01FiberSignalDetect, cpsUnknownDeviceId=cpsUnknownDeviceId, cpsvt100RmtCableMode=cpsvt100RmtCableMode, mcc16ErrorClear=mcc16ErrorClear, cfetf205CfgMatch=cfetf205CfgMatch, captf100FirmwareRev=captf100FirmwareRev, cetct100BiaIndex=cetct100BiaIndex, cpsmm100SysUpTime=cpsmm100SysUpTime, cfetf105ConfigMode=cfetf105ConfigMode, cmefg100RmtOamPeerMaxOamPduSize=cmefg100RmtOamPeerMaxOamPduSize, cmefg100VlanEntries=cmefg100VlanEntries, cpsmp100Entry=cpsmp100Entry, mcc16ComPS1Power=mcc16ComPS1Power, cetct100Collision=cetct100Collision, cmefg100LocTpQosPause=cmefg100LocTpQosPause, cgetf100SlotIndex=cgetf100SlotIndex, cmefg100MRevision=cmefg100MRevision, cpsmp110Groups=cpsmp110Groups, cpsMc1900BiaIndex=cpsMc1900BiaIndex, smacf100MRevision=smacf100MRevision, csdtf100SerialNumber=csdtf100SerialNumber, cbftf100SlotIndex=cbftf100SlotIndex, pSError=pSError, csdtf100RmtTPCoax=csdtf100RmtTPCoax, ct1e1Cf01CopperSignalDetect=ct1e1Cf01CopperSignalDetect, cmefg100RmtDmiTemp=cmefg100RmtDmiTemp, csdtf100RmtSupported=csdtf100RmtSupported, cpsmp100Mode=cpsmp100Mode, pSDeviceInserted=pSDeviceInserted, cfetf105TPActivity=cfetf105TPActivity, captf100Groups=captf100Groups, cfSmMm04Power=cfSmMm04Power, cdftf100ConnectorTbl=cdftf100ConnectorTbl, crmfe100FxBytesL=crmfe100FxBytesL, smacf100PRxOctets=smacf100PRxOctets, mcc16DeviceType=mcc16DeviceType, cbftf100SerialNumber=cbftf100SerialNumber, slotMc20p=slotMc20p, carCf01Index=carCf01Index, cmefg100ImcRxFCSErrorsTbl=cmefg100ImcRxFCSErrorsTbl, cpsCabinetDescription=cpsCabinetDescription, cRs232Cf01Id=cRs232Cf01Id, cmefg100LocOamCriticalEvent=cmefg100LocOamCriticalEvent, cfetf205Enabled=cfetf205Enabled, cfetf105AutoCross=cfetf105AutoCross, cmefg100LocFiberAdv1000HDX=cmefg100LocFiberAdv1000HDX, crs4f100Groups=crs4f100Groups, cdftf100TPActivityTbl=cdftf100TPActivityTbl, cfetf205ConnA=cfetf205ConnA, cmefg100LadEditCmd=cmefg100LadEditCmd, cbftf100SACCfgTbl=cbftf100SACCfgTbl, cmefg100ImcTxBroadcastPktsTbl=cmefg100ImcTxBroadcastPktsTbl, cmefg100RmtDmiRxPower=cmefg100RmtDmiRxPower, cpsmm100SaveConfig=cpsmm100SaveConfig, ce100BtxFx04MtId=ce100BtxFx04MtId, cfdCd01TPRecv=cfdCd01TPRecv, crs4f100ConnA=crs4f100ConnA, cmefg100ImcRxBroadcastPktsTbl=cmefg100ImcRxBroadcastPktsTbl, captf100Emulates=captf100Emulates, cpsMc0800MRevision=cpsMc0800MRevision, crs2f100Id=crs2f100Id, captf100Entry=captf100Entry, smacf100QosEnable=smacf100QosEnable, cmefg100RmtSerialNumber=cmefg100RmtSerialNumber, crmfe100RmtFiberActivity=crmfe100RmtFiberActivity, productId=productId, cmefg100RmtFiberLink=cmefg100RmtFiberLink, csdtf100RmtDetected=csdtf100RmtDetected, cgfeb100TPAdvPause=cgfeb100TPAdvPause, cmefg100ImcRxDropPktsTbl=cmefg100ImcRxDropPktsTbl, cfetf100ConnB=cfetf100ConnB, cpsmp100SlotIndex=cpsmp100SlotIndex, smacf100ResetCounters=smacf100ResetCounters, crs2f100BiaIndex=crs2f100BiaIndex, cmefg100VlanFwdTpTbl=cmefg100VlanFwdTpTbl, cgfeb100QosEnabled=cgfeb100QosEnabled, cmefg100LocFiberSacEnable=cmefg100LocFiberSacEnable, cmefg100ImcRxPkts1024to1522OctetsTbl=cmefg100ImcRxPkts1024to1522OctetsTbl, cpsDblWideId=cpsDblWideId, cpsvt100RmtInvertRX=cpsvt100RmtInvertRX, cpsmp100Groups=cpsmp100Groups, cmefg100RmtTpDuplex=cmefg100RmtTpDuplex, cmefg100RmtTpAdv1000FDX=cmefg100RmtTpAdv1000FDX, cbftf150ConfigMode=cbftf150ConfigMode, cettf100FiberLink=cettf100FiberLink, csetf100ConnA=csetf100ConnA, smacf100PPkts128to255Octets=smacf100PPkts128to255Octets, cgfeb100TPSacCfg=cgfeb100TPSacCfg, crmfe100RmtTPLink=crmfe100RmtTPLink, smacf100PRxPausePkts=smacf100PRxPausePkts, cmefg100ImcTxMulticastPktsTbl=cmefg100ImcTxMulticastPktsTbl, cfetf100TPLink=cfetf100TPLink, csdtf100ConfigMode=csdtf100ConfigMode, cbftf100SACMasterCfg=cbftf100SACMasterCfg, cmefg100LadStaticTbl=cmefg100LadStaticTbl, cpsCf01FiberRecv=cpsCf01FiberRecv, cRs232Cf01Table=cRs232Cf01Table, cgfeb100TPAdv1000HDX=cgfeb100TPAdv1000HDX, smacf100PConnA=smacf100PConnA, cpsMc1800Table=cpsMc1800Table, cePswSx01Id=cePswSx01Id, cpsvt100Entry=cpsvt100Entry, csdtf100Table=csdtf100Table, cbftf100Adv10FDXTbl=cbftf100Adv10FDXTbl, cfetf205MRevision=cfetf205MRevision, cbftf150CacheClean=cbftf150CacheClean, csdtf100RmtFault=csdtf100RmtFault, csdtf100RmtSerialNumber=csdtf100RmtSerialNumber, cgfeb100TPAdv10HDX=cgfeb100TPAdv10HDX, smacf100Table=smacf100Table, csdtf100Groups=csdtf100Groups, cmefg100ImcRmtReset=cmefg100ImcRmtReset, cfmff100SMSignal=cfmff100SMSignal, cbftf150PortCount=cbftf150PortCount, crs2f100FirmwareRevision=crs2f100FirmwareRevision, cettf100Entry=cettf100Entry, cemtf100BiaIndex=cemtf100BiaIndex, ce100BtxSx01TPSignalDetect=ce100BtxSx01TPSignalDetect, crmfe100Enabled=crmfe100Enabled, cpsmp110Entry=cpsmp110Entry, mcc16Ver1=mcc16Ver1, chSlMc20p=chSlMc20p, ceTbtFrl03Entry=ceTbtFrl03Entry, cpsmm100CacheClean=cpsmm100CacheClean, cmefg100LocOamFramesLostDueToOamError=cmefg100LocOamFramesLostDueToOamError, cmefg100RmtTpPause=cmefg100RmtTpPause, cgfeb100TPAutoNegot=cgfeb100TPAutoNegot, cmefg100LocDmiRxPowerAlarm=cmefg100LocDmiRxPowerAlarm, crmfe100Pause=crmfe100Pause, cmefg100SubDeviceIndex=cmefg100SubDeviceIndex, cmefg100RmtTpAdv1000HDX=cmefg100RmtTpAdv1000HDX, cgfeb100TPLink=cgfeb100TPLink, cmefg100RmtTpAdv100FDX=cmefg100RmtTpAdv100FDX, csdtf100MRevision=csdtf100MRevision, cmefg100LocDmiTemp=cmefg100LocDmiTemp, smacf100PAdv100HDX=smacf100PAdv100HDX, cmefg100RmtTpCross=cmefg100RmtTpCross, crmfe100FxTxBwa=crmfe100FxTxBwa, ce100BtxFx04MtFiberRecv=ce100BtxFx04MtFiberRecv, cpsCabinetEntry=cpsCabinetEntry, mcc16ComPS2Power=mcc16ComPS2Power, csetf100Table=csetf100Table, cbftf100AutoNegotTbl=cbftf100AutoNegotTbl, cfmff100ConnB=cfmff100ConnB, crmfe100AutoCross=crmfe100AutoCross, cmefg100QosLqWeight=cmefg100QosLqWeight, csdtf100Id=csdtf100Id, cfetf105FiberActivity=cfetf105FiberActivity, cpsld100Ps2InUse=cpsld100Ps2InUse, cmefg100LocOamParserState=cmefg100LocOamParserState, cmefg100LocOamLoopbackControlTx=cmefg100LocOamLoopbackControlTx, cmefg100LocOamMacAddress=cmefg100LocOamMacAddress, cpsCf01Id=cpsCf01Id, cmefg100ImcTxSingleCollisionTbl=cmefg100ImcTxSingleCollisionTbl, cpsvt100FiberLink=cpsvt100FiberLink, csdtf100TAOSCopper=csdtf100TAOSCopper, cpsmm200ICIF=cpsmm200ICIF, cmefg100ImcTxLateCollisionTbl=cmefg100ImcTxLateCollisionTbl, cpsSlotSummary=cpsSlotSummary, cmefg100RmtOamActiveMode=cmefg100RmtOamActiveMode, cmefg100LocSerialNumber=cmefg100LocSerialNumber, cdftf100SerialNumber=cdftf100SerialNumber, csdtf100RmtConfigMode=csdtf100RmtConfigMode, smacf100PPkts512to1023Octets=smacf100PPkts512to1023Octets, smacf100PRxBroadcastPkts=smacf100PRxBroadcastPkts, smacf100PLink=smacf100PLink)
mibBuilder.exportSymbols("MCC16-MIB", smacf100PFullDuplex=smacf100PFullDuplex, ceTbtFrl04TPRecv=ceTbtFrl04TPRecv, ceTbtFrl03FiberRecv=ceTbtFrl03FiberRecv, cpsvt100InvertTX=cpsvt100InvertTX, cmefg100LocTpSacEnable=cmefg100LocTpSacEnable, cmefg100VlanTpDefaultPri=cmefg100VlanTpDefaultPri, cpsld100MRevision=cpsld100MRevision, crmfe100ConnA=crmfe100ConnA, cmefg100VlanEnable=cmefg100VlanEnable, crmfe100Entry=crmfe100Entry, smacf100PRxFragments=smacf100PRxFragments, ce100BtxFx04MtEntry=ce100BtxFx04MtEntry, ceRTxFx01TPPrimary=ceRTxFx01TPPrimary, mc20pEmptyId=mc20pEmptyId, backplane=backplane, smacf100PTxDeferredTransmit=smacf100PTxDeferredTransmit, cpsSlotPwrTable=cpsSlotPwrTable, caCf02CopperSignalDetect=caCf02CopperSignalDetect, cfetf105Table=cfetf105Table, cmefg100LocTxFxBwaMb=cmefg100LocTxFxBwaMb, cgfeb100FiberLink=cgfeb100FiberLink, ct1e1Cf01Index=ct1e1Cf01Index, crmfe100MscTxBytes=crmfe100MscTxBytes, ce100BtxFrl03TPRecv=ce100BtxFrl03TPRecv, captf100ConnB=captf100ConnB, cfSmMm05Entry=cfSmMm05Entry, captf100InUse=captf100InUse, cpsMc0200BiaIndex=cpsMc0200BiaIndex, csdtf100FiberLink=csdtf100FiberLink, crmfe100FirmwareRevision=crmfe100FirmwareRevision, cfSmMm06Index=cfSmMm06Index, cpsvt100RmtLoopBack=cpsvt100RmtLoopBack, cfSmMm06MMSignalDetect=cfSmMm06MMSignalDetect, cfetf100SerialNumber=cfetf100SerialNumber, cpsModuleModel=cpsModuleModel, cmefg100LocFxTxBwaMb=cmefg100LocFxTxBwaMb, ce100BtxFrl03FiberRecv=ce100BtxFrl03FiberRecv, smacf100PTxExcessiveCollision=smacf100PTxExcessiveCollision, crmfe100RmtConfigMode=crmfe100RmtConfigMode, cgfeb100MRevision=cgfeb100MRevision, cbftf100LinkPassThrough=cbftf100LinkPassThrough, cfmff100MMSignal=cfmff100MMSignal, cgfeb100SerialNumber=cgfeb100SerialNumber, cpsmm100SlotIndex=cpsmm100SlotIndex, cgfeb100SelfTestFailed=cgfeb100SelfTestFailed, cmefg100VlanSetFailed=cmefg100VlanSetFailed, cpsmm100CfgMatch=cpsmm100CfgMatch, ceCxTbt04TPLink=ceCxTbt04TPLink, crmfe100TxFxBwa=crmfe100TxFxBwa, crs4f100MRevision=crs4f100MRevision, cmefg100RmtSelfTestFailed=cmefg100RmtSelfTestFailed, cgetf100FiberLink=cgetf100FiberLink, crs2f100SerialNumber=crs2f100SerialNumber, cfSmMm04Table=cfSmMm04Table, ceTxSx02FiberLink=ceTxSx02FiberLink, cgfeb100FiberSacCfg=cgfeb100FiberSacCfg, smacf100PCfgMatch=smacf100PCfgMatch, cmefg100LadVidTbl=cmefg100LadVidTbl, chassisCpsmc1900Id=chassisCpsmc1900Id, cgetf100ClockMaster=cgetf100ClockMaster, carCf01Entry=carCf01Entry, cmefg100VlanUntagTpTbl=cmefg100VlanUntagTpTbl, cpsmm100Reset=cpsmm100Reset, cfmff100BiaIndex=cfmff100BiaIndex, caCf02FiberSignalDetect=caCf02FiberSignalDetect, cpsld100Ps1InUse=cpsld100Ps1InUse, csetf100Entry=csetf100Entry, crmfe100FxBytesH=crmfe100FxBytesH, ceTbtFrl04Entry=ceTbtFrl04Entry, cbftf100PauseStatTbl=cbftf100PauseStatTbl, smacf100PQosPause=smacf100PQosPause, csdtf100AISCopper=csdtf100AISCopper, csetf100SerialNumber=csetf100SerialNumber, cbftf100MirrorCfg=cbftf100MirrorCfg, cmefg100LocColdstart=cmefg100LocColdstart, cmefg100LocDmiTempAlarm=cmefg100LocDmiTempAlarm, card=card, cgetf100ConfigMode=cgetf100ConfigMode, ceCxTbt04Index=ceCxTbt04Index, ce100BtxSx01Table=ce100BtxSx01Table, caCf02Id=caCf02Id, csdtf100RmtCopperLineBuildout=csdtf100RmtCopperLineBuildout, cetct100SlotIndex=cetct100SlotIndex, csetf100FiberActivity=csetf100FiberActivity, cgfeb100ConfigMode=cgfeb100ConfigMode, cmefg100RmtOamPeerParserState=cmefg100RmtOamPeerParserState, cpsmp100BiaIndex=cpsmp100BiaIndex, pSDeviceRemoved=pSDeviceRemoved, carCf01TPRecv=carCf01TPRecv, caCf02Entry=caCf02Entry, ce100BtxSx01Id=ce100BtxSx01Id, captf100BiaIndex=captf100BiaIndex, cfSmMm05Index=cfSmMm05Index, ccscf100BiaIndex=ccscf100BiaIndex, smacf100PPkts256to511Octets=smacf100PPkts256to511Octets, cpsmp100RFanFault=cpsmp100RFanFault, smacf100PLastMAC=smacf100PLastMAC, ccscf100CfgMatch=ccscf100CfgMatch, crmfe100LinkPassThrough=crmfe100LinkPassThrough, carCf01FiberRecv=carCf01FiberRecv, ctrCf01TPinOK=ctrCf01TPinOK, cpsmp110FirmwareRevision=cpsmp110FirmwareRevision, cpsmm100Table=cpsmm100Table, crs4f100Fault=crs4f100Fault, cmefg100LocTpSacStatus=cmefg100LocTpSacStatus, cettf100CfgMatch=cettf100CfgMatch, cbftf100SubDeviceIndex=cbftf100SubDeviceIndex, cpsvt100CableMode=cpsvt100CableMode, crs2f100MRevision=crs2f100MRevision, ctrCf01FiberinOK=ctrCf01FiberinOK, cmefg100VlanTpInUntaggedDrop=cmefg100VlanTpInUntaggedDrop, cfSmMm06SMSignalDetect=cfSmMm06SMSignalDetect, cbftf100RedundantPath=cbftf100RedundantPath, cmefg100LocOamLinkFault=cmefg100LocOamLinkFault, cpsld100SerialNumber=cpsld100SerialNumber, cfdCd01Entry=cfdCd01Entry, chassisCpsmc0800Id=chassisCpsmc0800Id, cmefg100LocOamRmtLoopback=cmefg100LocOamRmtLoopback, csdtf100RmtCopperLongHaul=csdtf100RmtCopperLongHaul, cpsmp100MRevision=cpsmp100MRevision, cmefg100ImcTxOctetsTbl=cmefg100ImcTxOctetsTbl, carCf02Index=carCf02Index, crs4f100CopperActivity=crs4f100CopperActivity, cgfeb100TPAdv100HDX=cgfeb100TPAdv100HDX, cpsMc1800MRevision=cpsMc1800MRevision, cgetf100Entry=cgetf100Entry, cfetf205TPActivity=cfetf205TPActivity, cdftf100BiaIndex=cdftf100BiaIndex, cgfeb100MonitorType=cgfeb100MonitorType, cpsmp110ConfigMode=cpsmp110ConfigMode, chassisSmacf100LCId=chassisSmacf100LCId, cfSmMm04MMSignalDetect=cfSmMm04MMSignalDetect, pSDeviceColdStart=pSDeviceColdStart, cpsMc1900Entry=cpsMc1900Entry, crmfe100RmtFiberLink=crmfe100RmtFiberLink, cpsmp110BiaIndex=cpsmp110BiaIndex, smacf100PTxCollisions=smacf100PTxCollisions, cetct100MRevision=cetct100MRevision, cmefg100VlanUntagFiberTbl=cmefg100VlanUntagFiberTbl, cgfeb100QosLqWeight=cgfeb100QosLqWeight, cmefg100Table=cmefg100Table, cmefg100RmtTpQosPause=cmefg100RmtTpQosPause, cpsmm100SNMPTrapMgr4=cpsmm100SNMPTrapMgr4, cmefg100VlanCacheCmd=cmefg100VlanCacheCmd, ceRTxFx01FiberPrimary=ceRTxFx01FiberPrimary, chassisCpsmc1800Id=chassisCpsmc1800Id, ceCxTbt04Table=ceCxTbt04Table, captf100ConnA=captf100ConnA, cmefg100RmtOamLocDteDisc=cmefg100RmtOamLocDteDisc, cpsvt100ConnA=cpsvt100ConnA, cbftf150BiaIndex=cbftf150BiaIndex, smacf100PWrapRxGoodOctets=smacf100PWrapRxGoodOctets, cmefg100SlotIndex=cmefg100SlotIndex, crs2f100FiberLink=crs2f100FiberLink, cmefg100VlanIngressVidMiss=cmefg100VlanIngressVidMiss, crmfe100CacheClean=crmfe100CacheClean, cpsmp110TempFaultTbl=cpsmp110TempFaultTbl, crs2f100Table=crs2f100Table, cgetf100MRevision=cgetf100MRevision, cpsSlotPwrState=cpsSlotPwrState, crs4f100CfgMatch=crs4f100CfgMatch, cettf100LinkPassThrough=cettf100LinkPassThrough, cfetf105CacheClean=cfetf105CacheClean, cpsmm100SNMPTrapMgr=cpsmm100SNMPTrapMgr, cmefg100LocFiberQosPause=cmefg100LocFiberQosPause, cpsmp100Id=cpsmp100Id, ccscf100E3DS3=ccscf100E3DS3, mcc16ComNotes=mcc16ComNotes, cfSmMm04Id=cfSmMm04Id, cfetf205FarEndFault=cfetf205FarEndFault, cpsmp110TemperatureTbl=cpsmp110TemperatureTbl, cbftf150LinkTbl=cbftf150LinkTbl, cfmff100SlotIndex=cfmff100SlotIndex, cetct100ConfigMode=cetct100ConfigMode, cmefg100RmtOamPeerVendorOui=cmefg100RmtOamPeerVendorOui, cmefg100ImcLocReset=cmefg100ImcLocReset, cmefg100ImcRxPkts256to511OctetsTbl=cmefg100ImcRxPkts256to511OctetsTbl, cpsMc1800Description=cpsMc1800Description, carCf02Id=carCf02Id, crmfe100ConfigMode=crmfe100ConfigMode, cpsCf01Power=cpsCf01Power, smacf100PTxBroadcastPkts=smacf100PTxBroadcastPkts, cemtf100ConnA=cemtf100ConnA, cbftf100PortCount=cbftf100PortCount, crmfe100UpTime=crmfe100UpTime, cbftf100ConnectorTbl=cbftf100ConnectorTbl, cbftf150SerialNumber=cbftf150SerialNumber, cpsmm100Gateway=cpsmm100Gateway, cpsmp110CurrFaultTbl=cpsmp110CurrFaultTbl, cfdCd01Table=cfdCd01Table, cfetf205CacheClean=cfetf205CacheClean, cePswFx03Entry=cePswFx03Entry, cpsvt100RmtTermTiming=cpsvt100RmtTermTiming, cmefg100VlanPriTagCtrl=cmefg100VlanPriTagCtrl, cgfeb100FiberLpAdv1000FDX=cgfeb100FiberLpAdv1000FDX, cePswFx03FiberFullDuplex=cePswFx03FiberFullDuplex, smacf100PAdv100FDX=smacf100PAdv100FDX, cmefg100LocTpAutoNegot=cmefg100LocTpAutoNegot, cpsld100Ps1Power=cpsld100Ps1Power, cpsmm200SerialNumber=cpsmm200SerialNumber, cbftf100Adv10HDXTbl=cbftf100Adv10HDXTbl, cpsCabinetSequence=cpsCabinetSequence, mc20pDblWideId=mc20pDblWideId, ce100BtxSx01Power=ce100BtxSx01Power, chSlcps=chSlcps, cmefg100LadCacheCmd=cmefg100LadCacheCmd, csdtf100CopperLink=csdtf100CopperLink, cfSmMm05MMSignalDetect=cfSmMm05MMSignalDetect, csetf100SpeedConfig=csetf100SpeedConfig, cgfeb100FiberFullDuplexCfg=cgfeb100FiberFullDuplexCfg, cmefg100RmtDmiTxBiasCurrent=cmefg100RmtDmiTxBiasCurrent, cmefg100LocDmiTxPower=cmefg100LocDmiTxPower, csdtf100RmtAISCopper=csdtf100RmtAISCopper, cetct100CacheClean=cetct100CacheClean, ceTbtFrl04Table=ceTbtFrl04Table, cgfeb100TPLpAdv10FDX=cgfeb100TPLpAdv10FDX, crmfe100SlotIndex=crmfe100SlotIndex, cbftf150CrossTbl=cbftf150CrossTbl, cRs232Cf01Index=cRs232Cf01Index, ccscf100DS3LineBuildout=ccscf100DS3LineBuildout, cfetf100MRevision=cfetf100MRevision, ceCxFrl04Id=ceCxFrl04Id, cgfeb100TPCrossCfg=cgfeb100TPCrossCfg, cbftf100Adv100FDXTbl=cbftf100Adv100FDXTbl, cfetf100CfgMatch=cfetf100CfgMatch, smacf100PRxSymbolError=smacf100PRxSymbolError, cbftf150FullDuplexTbl=cbftf150FullDuplexTbl, cmefg100LocDmiTxBiasCurrent=cmefg100LocDmiTxBiasCurrent, cpsCf01TPRecv=cpsCf01TPRecv, cbftf150FarEndFaultTbl=cbftf150FarEndFaultTbl, cpsmp100ConfigMode=cpsmp100ConfigMode, csetf100ConfigMode=csetf100ConfigMode, cfmff100Groups=cfmff100Groups, cmefg100VlanEditUntagFiber=cmefg100VlanEditUntagFiber, cmefg100ImcTxQosPktsTbl=cmefg100ImcTxQosPktsTbl, cbftf150FormFactor=cbftf150FormFactor, cgetf100TPLink=cgetf100TPLink, cmefg100RmtFirmwareRevision=cmefg100RmtFirmwareRevision, csdtf100T1E1=csdtf100T1E1, cfetf100Pause=cfetf100Pause, cgetf100Pause=cgetf100Pause, csetf100TPLink=csetf100TPLink, cpsvt100TermTiming=cpsvt100TermTiming, cmefg100ImcTxFrameInDiscTbl=cmefg100ImcTxFrameInDiscTbl, cpsAgent=cpsAgent, cmefg100VlanCacheState=cmefg100VlanCacheState, csdtf100FiberLoopback=csdtf100FiberLoopback, cmefg100RmtDmiTxPowerAlarm=cmefg100RmtDmiTxPowerAlarm, cpsmm100SwRevision=cpsmm100SwRevision, cgfeb100FirmwareRevision=cgfeb100FirmwareRevision, cbftf150Groups=cbftf150Groups, smacf100PTxFrameInDisc=smacf100PTxFrameInDisc, ce100BtxFx04Entry=ce100BtxFx04Entry, mc20pErrorId=mc20pErrorId)
mibBuilder.exportSymbols("MCC16-MIB", cmefg100LocOamInformationRx=cmefg100LocOamInformationRx, cmefg100ImcRxSymbolErrorTbl=cmefg100ImcRxSymbolErrorTbl, cpsMc1800PSPower2=cpsMc1800PSPower2, chassisCpsmc0200Id=chassisCpsmc0200Id, cfetf205ConfigMode=cfetf205ConfigMode, cpsld100Ps2Power=cpsld100Ps2Power, carCf02CoaxRecv=carCf02CoaxRecv, crmfe100TxBytesH=crmfe100TxBytesH, cfetf205Groups=cfetf205Groups, cpsCf01Index=cpsCf01Index, smacf100SelfTest=smacf100SelfTest, cpsmp100CfgMatch=cpsmp100CfgMatch, cpsMc1300Description=cpsMc1300Description, ceCxFrl04FLLink=ceCxFrl04FLLink, cmefg100ImcTxExcessiveCollisionTbl=cmefg100ImcTxExcessiveCollisionTbl, crmfe100Table=crmfe100Table, cpsmp110SerialNumber=cpsmp110SerialNumber, chassis=chassis, csetf100Id=csetf100Id, cfSmMm06Table=cfSmMm06Table, cpsmp110CfgMatch=cpsmp110CfgMatch, ceTxSx02Id=ceTxSx02Id, products=products, cpsvt100Id=cpsvt100Id, cpsmm100SNMPTrapMgr3=cpsmm100SNMPTrapMgr3, captf100CacheClean=captf100CacheClean, cmefg100LocFiberLink=cmefg100LocFiberLink, cmefg100LocOamLocDteDisc=cmefg100LocOamLocDteDisc, chassisMcc16Id=chassisMcc16Id, cetct100SerialNumber=cetct100SerialNumber, cmefg100LocFiberAutoNegot=cmefg100LocFiberAutoNegot, cmefg100VlanEditVid=cmefg100VlanEditVid, crs2f100DCE=crs2f100DCE, cmefg100VlanFiberDefaultPri=cmefg100VlanFiberDefaultPri, ceCxTbt04Jabber=ceCxTbt04Jabber, cePswSx01Index=cePswSx01Index, cgfeb100TPLpAdv10HDX=cgfeb100TPLpAdv10HDX, cfdCd01FiberSignalDetect=cfdCd01FiberSignalDetect, cbftf150AutoNegotTbl=cbftf150AutoNegotTbl, ceTbtFrl03TPLink=ceTbtFrl03TPLink, cpsMc0200Entry=cpsMc0200Entry, ce100BtxFx04Power=ce100BtxFx04Power, cfmff100CfgMatch=cfmff100CfgMatch, cbftf150Entry=cbftf150Entry, cetct100TPActivity=cetct100TPActivity, cpsmm100SubnetMask=cpsmm100SubnetMask, chstrCf01FiberSignalDetect=chstrCf01FiberSignalDetect, ceCxTbt04TPRecv=ceCxTbt04TPRecv, cfetf105AutoNegot=cfetf105AutoNegot, cmefg100RmtFiberQosPause=cmefg100RmtFiberQosPause, cpsMc0200Table=cpsMc0200Table, cfSmMm05SMSignalDetect=cfSmMm05SMSignalDetect, cfetf100Table=cfetf100Table, chassisProdsId=chassisProdsId, mcc16ComHwReset=mcc16ComHwReset, cfetf205Id=cfetf205Id, cfetf100FastLinkPulse=cfetf100FastLinkPulse, cetct100CoaxActivity=cetct100CoaxActivity, cpsmp110CurrSensorCount=cpsmp110CurrSensorCount, cemtf100Table=cemtf100Table, csdtf100RmtFiberLoopback=csdtf100RmtFiberLoopback, cmefg100ImcRxGoodOctetsWrapTbl=cmefg100ImcRxGoodOctetsWrapTbl, cmefg100LocTpConnB=cmefg100LocTpConnB, ceTxSx02Table=ceTxSx02Table, cpsMc1300Entry=cpsMc1300Entry, cgfeb100ConnA=cgfeb100ConnA, cmefg100VlanTpDefaultVid=cmefg100VlanTpDefaultVid, cpsmp100ChassisTemp=cpsmp100ChassisTemp, cmefg100VlanFwdFiberTbl=cmefg100VlanFwdFiberTbl, chstrCf01Index=chstrCf01Index, cfetf205SerialNumber=cfetf205SerialNumber, cgfeb100FiberQosPause=cgfeb100FiberQosPause, chstrCf01FiberRecv=chstrCf01FiberRecv, carCf01Power=carCf01Power, cmefg100LocTpAdv100HDX=cmefg100LocTpAdv100HDX, cpsModuleEntry=cpsModuleEntry, cgfeb100SlotIndex=cgfeb100SlotIndex, cpsmp110PSSupplyTbl=cpsmp110PSSupplyTbl, cpsMc0200MRevision=cpsMc0200MRevision, cfmff100ConfigMode=cfmff100ConfigMode, mcc16ComPS1InUse=mcc16ComPS1InUse, cgfeb100TPLpAdv100HDX=cgfeb100TPLpAdv100HDX, cpsmm100MRevision=cpsmm100MRevision, cmefg100LocTpPause=cmefg100LocTpPause, cbftf100Table=cbftf100Table, cfSmMm05Table=cfSmMm05Table, cfmff100Enabled=cfmff100Enabled, cmefg100LocFpgaRev=cmefg100LocFpgaRev, cfSmMm02SMSignalDetect=cfSmMm02SMSignalDetect, cgfeb100TPSpeedStat=cgfeb100TPSpeedStat, crmfe100BiaIndex=crmfe100BiaIndex, crmfe100FiberLink=crmfe100FiberLink, cePswSx01TPFullDuplex=cePswSx01TPFullDuplex, cpsCabinetBiaIndex=cpsCabinetBiaIndex, cbftf100LinkTbl=cbftf100LinkTbl, cettf100Table=cettf100Table, cmefg100RmtOamUnidirectional=cmefg100RmtOamUnidirectional, crs2f100RmtDetected=crs2f100RmtDetected, csdtf100Fault=csdtf100Fault, ccscf100SlotIndex=ccscf100SlotIndex, cdftf100FirmwareRevision=cdftf100FirmwareRevision, cmefg100RmtTpAdv10HDX=cmefg100RmtTpAdv10HDX, cpsmp100CacheClean=cpsmp100CacheClean, ce100BtxFrl03Index=ce100BtxFrl03Index, cfSmMm06Id=cfSmMm06Id, smacf100PBlockMgmt=smacf100PBlockMgmt, crmfe100MRevision=crmfe100MRevision, mcc16Common=mcc16Common, cfSmMm02Power=cfSmMm02Power, crs2f100ConfigMode=crs2f100ConfigMode, smacf100PRxAlignmentErrors=smacf100PRxAlignmentErrors, cmefg100ImcRxOctetsTbl=cmefg100ImcRxOctetsTbl, mcc16ComMgmtHwRev=mcc16ComMgmtHwRev, cmefg100ImcRxOctetsWrapTbl=cmefg100ImcRxOctetsWrapTbl, ce100BtxFx04Index=ce100BtxFx04Index, cbCf01TPCoaxRecv=cbCf01TPCoaxRecv, mcc16ComPS2InUse=mcc16ComPS2InUse, crmfe100RmtLoopback=crmfe100RmtLoopback, ce100BtxFx04TPRecv=ce100BtxFx04TPRecv, cfetf100LinkPassThrough=cfetf100LinkPassThrough, cpsvt100BiaIndex=cpsvt100BiaIndex, mcc16ComNetMask=mcc16ComNetMask, smacf100AgingTimer=smacf100AgingTimer, cmefg100ImcTxQosOctetsTbl=cmefg100ImcTxQosOctetsTbl, cpsMc1900Description=cpsMc1900Description, cemtf100Id=cemtf100Id, cgfeb100Id=cgfeb100Id, ccscf100ConnA=ccscf100ConnA, cgfeb100LinkPassThrough=cgfeb100LinkPassThrough, cpsmm100SysLocation=cpsmm100SysLocation, cpsmm100CanPrimary=cpsmm100CanPrimary, ceTbtFrl03Table=ceTbtFrl03Table, cpsmm200SlotIndex=cpsmm200SlotIndex, ceTxSx02Index=ceTxSx02Index, csdtf100RmtCopperLink=csdtf100RmtCopperLink, cpsmp110CacheClean=cpsmp110CacheClean, cdftf100SubDeviceIndex=cdftf100SubDeviceIndex, cpsCabinetTable=cpsCabinetTable, cfSmMm04SMSignalDetect=cfSmMm04SMSignalDetect, cpsmM100Id=cpsmM100Id, ceCxTbt04Power=ceCxTbt04Power, cmefg100VlanVidTbl=cmefg100VlanVidTbl, cpsld100Id=cpsld100Id, ccscf100CacheClean=ccscf100CacheClean, cpsCf01Table=cpsCf01Table, ce100BtxFrl03TPSignalDetect=ce100BtxFrl03TPSignalDetect, cettf100ConnB=cettf100ConnB, cpsmp110TempSensorCount=cpsmp110TempSensorCount, ceRTxFx01Id=ceRTxFx01Id, cgfeb100CacheClean=cgfeb100CacheClean, cpsvt100ConfigMode=cpsvt100ConfigMode, cpsmp110SlotIndex=cpsmp110SlotIndex, cmefg100RmtFiberAutoNegot=cmefg100RmtFiberAutoNegot, crs2f100ConnB=crs2f100ConnB, cmefg100BiaIndex=cmefg100BiaIndex, mcc16Index=mcc16Index, ce100BtxSx01FiberRecv=ce100BtxSx01FiberRecv, smacf100P100Mbps=smacf100P100Mbps, cfmff100ConnA=cfmff100ConnA, cgfeb100MonitorTap=cgfeb100MonitorTap, cgetf100BiaIndex=cgetf100BiaIndex, smacf100PPkts64Octets=smacf100PPkts64Octets, smacf100PRxMulticastPkts=smacf100PRxMulticastPkts, smacf100PTxPausePkts=smacf100PTxPausePkts, smacf100PPkts65to127Octets=smacf100PPkts65to127Octets, cmefg100LocOamAdminControl=cmefg100LocOamAdminControl, cmefg100RmtOamPeerConfigRevision=cmefg100RmtOamPeerConfigRevision, cpsSlotPwrEntry=cpsSlotPwrEntry, cmefg100ImcRxPkts64OctetsTbl=cmefg100ImcRxPkts64OctetsTbl, cePswFx03FiberLink=cePswFx03FiberLink, cpsmp110PSCount=cpsmp110PSCount, cePswSx01FiberLink=cePswSx01FiberLink, cgfeb100FiberFullDuplexStat=cgfeb100FiberFullDuplexStat, cpsmp110PSRoleTbl=cpsmp110PSRoleTbl, cgetf100ConnB=cgetf100ConnB, smacf100QosHqWeight=smacf100QosHqWeight, cfetf100FiberActivity=cfetf100FiberActivity, cbftf100Adv100HDXTbl=cbftf100Adv100HDXTbl, cgetf100Id=cgetf100Id, smacf100PRxJabbers=smacf100PRxJabbers, cfetf100AutoCross=cfetf100AutoCross, cmefg100RmtOamLastGasp=cmefg100RmtOamLastGasp, crmfe100RmtFarEndFault=crmfe100RmtFarEndFault, pSCabinetAdded=pSCabinetAdded, cemtf100OffHook=cemtf100OffHook, csdtf100RmtTAOSCopper=csdtf100RmtTAOSCopper, cpsmm100TntRIP=cpsmm100TntRIP, mcc16=mcc16, csdtf100CopperLongHaul=csdtf100CopperLongHaul, cgetf100FullDuplex=cgetf100FullDuplex, cmefg100LocOamRmtDteDisc=cmefg100LocOamRmtDteDisc, cePswFx03Table=cePswFx03Table, cmefg100LocOamOperStatus=cmefg100LocOamOperStatus, cmefg100RmtOamLinkFault=cmefg100RmtOamLinkFault, smacf100PFarEndFaultStat=smacf100PFarEndFaultStat, cmefg100LocOamLastGasp=cmefg100LocOamLastGasp, cmefg100RmtOamPeerMacAddress=cmefg100RmtOamPeerMacAddress, chstrCf01Table=chstrCf01Table, cgfeb100TPLpAdv1000HDX=cgfeb100TPLpAdv1000HDX, cmefg100ImcRxPkts65to127OctetsTbl=cmefg100ImcRxPkts65to127OctetsTbl, csetf100Groups=csetf100Groups, ccscf100SerialNumber=ccscf100SerialNumber, cfetf205Fault=cfetf205Fault, cpsmp110CurrentTbl=cpsmp110CurrentTbl, cmefg100VlanEditUntagTp=cmefg100VlanEditUntagTp, cpsmp110FanCount=cpsmp110FanCount, cmefg100Id=cmefg100Id, smacf100PAdv10HDX=smacf100PAdv10HDX, cbftf100MirrorInTbl=cbftf100MirrorInTbl, csdtf100CopperLineBuildout=csdtf100CopperLineBuildout, carCf01Table=carCf01Table, cdftf100Table=cdftf100Table, cmefg100ImcTxUnicastPktsTbl=cmefg100ImcTxUnicastPktsTbl, smacf100SNMPModuleInstalled=smacf100SNMPModuleInstalled, cpsvt100CfgMatch=cpsvt100CfgMatch, cgfeb100QosHqWeight=cgfeb100QosHqWeight, crmfe100Fault=crmfe100Fault, cbCf01Power=cbCf01Power, cmefg100LocOamLinkEvents=cmefg100LocOamLinkEvents, cgfeb100TPAdv10FDX=cgfeb100TPAdv10FDX, smacf100PAdvPause=smacf100PAdvPause, cpsvt100FirmwareRev=cpsvt100FirmwareRev, crmfe100NetworkMode=crmfe100NetworkMode, cpsCf01Entry=cpsCf01Entry, cmefg100RmtOamRmtDteDisc=cmefg100RmtOamRmtDteDisc, mcc16SlotTable=mcc16SlotTable, smacf100PEntry=smacf100PEntry, crs2f100CacheClean=crs2f100CacheClean, ce100BtxFx04Id=ce100BtxFx04Id, cpsmm100ICIF=cpsmm100ICIF, cmefg100VlanPriMapTbl=cmefg100VlanPriMapTbl, chassisSmacf100Id=chassisSmacf100Id, cmefg100LocTxFxBwaKb=cmefg100LocTxFxBwaKb, cmefg100ImcRxExcessSizeDiscTbl=cmefg100ImcRxExcessSizeDiscTbl, cetct100FirmwareRevision=cetct100FirmwareRevision, cfetf100FarEndFault=cfetf100FarEndFault, cmefg100LocOamUnidirectional=cmefg100LocOamUnidirectional, ceCxFrl04Index=ceCxFrl04Index)

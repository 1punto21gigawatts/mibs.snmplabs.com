#
# PySNMP MIB module XYLAN-PORT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-PORT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Integer32, Unsigned32, MibIdentifier, Bits, TimeTicks, Counter64, iso, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Gauge32, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Integer32", "Unsigned32", "MibIdentifier", "Bits", "TimeTicks", "Counter64", "iso", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Gauge32", "NotificationType", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xylanVportArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanVportArch")
virtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 3, 1))
logicalPort = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 3, 2))
physicalPort = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 3, 3))
mirrorPort = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 3, 4))
echannelPort = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 3, 5))
class XylanPortFuncCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("router", 3), ("bridge", 4), ("trunk", 5), ("atmtrunk", 6), ("atmLANE", 7), ("cip", 8), ("atmMUX", 9), ("vlmp80210", 10), ("frtrunking", 12), ("vlmpDBr", 13), ("vlmp8021q", 14), ("lsm", 15), ("phyeth", 203), ("phyx100eth", 204), ("phytr4m", 205), ("phytr16m", 206), ("phyfddi", 207), ("phycddi", 208), ("phyatm25", 209), ("phyatm50", 210), ("phyds1", 211), ("phyds3", 212), ("phyoc3", 213), ("phyoc12", 214), ("phyoc48", 215))

class XylanVportAdminStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("disable", 1), ("enable", 2), ("delete", 3), ("create", 4), ("modify", 5))

class XylanPortOperStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("portDown", 2), ("portUp", 3))

class XylanVportEncapsulationCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("switch", 1), ("mediaDefault", 2), ("ethIIllc", 3), ("tunnelOption1", 4), ("tunnelOption2", 5), ("llc", 6), ("snapllc", 7), ("ethII", 8), ("snap", 9))

class XylanVportTranslationCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("ethertype", 1), ("llc", 2), ("snap", 3), ("prop", 4), ("tunnel1", 5), ("tunnel2", 6))

class XylanPhyPortTypeCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 21))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("eth", 3), ("x100eth", 4), ("tr4m", 5), ("tr16m", 6), ("fddi", 7), ("cddi", 8), ("atm25", 9), ("atm50", 10), ("ds1", 11), ("ds3", 12), ("oc3", 13), ("oc12", 14), ("oc48", 15), ("wsm", 16), ("e1", 18), ("e3", 19), ("serial", 21))

class XylanPhyPortAdminStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disable", 1), ("enable", 2))

class XylanMirrorEnableCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disable", 1), ("enable", 2))

vportTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1), )
if mibBuilder.loadTexts: vportTable.setStatus('mandatory')
if mibBuilder.loadTexts: vportTable.setDescription('A list of Virtual Port instances.')
vportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1), ).setIndexNames((0, "XYLAN-PORT-MIB", "vportSlot"), (0, "XYLAN-PORT-MIB", "vportIF"), (0, "XYLAN-PORT-MIB", "vportFuncType"), (0, "XYLAN-PORT-MIB", "vportFuncTypeInstance"))
if mibBuilder.loadTexts: vportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vportEntry.setDescription('A Virtual Port entry.')
vportNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vportNumber.setDescription('A unique number identifies this Virtual Port instance within the physical OmniSwitch. This number is NOT meant for user consumption.')
vportSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vportSlot.setDescription('The physical slot number for this port instance (vport).')
vportIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportIF.setStatus('mandatory')
if mibBuilder.loadTexts: vportIF.setDescription('The on-board interface number.')
vportFuncType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 4), XylanPortFuncCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportFuncType.setStatus('mandatory')
if mibBuilder.loadTexts: vportFuncType.setDescription('The function for this vport. ie. local, remote, atm.')
vportFuncTypeInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportFuncTypeInstance.setStatus('mandatory')
if mibBuilder.loadTexts: vportFuncTypeInstance.setDescription("The specific instance of this slot/IF/type. For 'most' interface types this will always be 1. The exception is an ATM connected port.")
vportVlanNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportVlanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vportVlanNumber.setDescription('The VLAN that this virtual port belongs to. The default for row creation is 1.')
vportMACaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportMACaddress.setStatus('mandatory')
if mibBuilder.loadTexts: vportMACaddress.setDescription('The MAC address represented by this Virtual Port. This value is returned upon row creation and attachment.')
vportBridgeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("transparent", 3), ("sourcerouting", 4), ("srtransparent", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportBridgeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vportBridgeProtocol.setDescription('The type of bridge protocol supported for this service. The default rfor row creation is transparent(3).')
vportEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 9), XylanVportEncapsulationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: vportEncapsulation.setDescription('The frame encapsulation translation to be used for this particular port. The value indicates the frame format required for the output interface. The default for row creation is default(2) the meaning of which is dependent on the media type of the port')
vportBrdgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("autoSwitch", 3), ("forceBridge", 4), ("forceSwitch", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportBrdgMode.setStatus('mandatory')
if mibBuilder.loadTexts: vportBrdgMode.setDescription('If vportFuncType is either localBridge(1) or localOpSwitch(2) type, setting this field to autoSwitch(3), the default, will allow the port to switch between the localBridge(1) or localOpSwitch(2) mode. The forceBridge(4) mode will prevent the localBridge(1) mode to switch to localOpSwitch(2) mode even there is only one MAC address is detacted. The forceSwitch(5) mode prevents the localOpSwitch(2) mode to switch to localBridge(1) mode. The user would have to make sure no loop is formed in the network in this case. The default is autoSwitch(3).')
vportSwitchTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchTimer.setDescription('The time out period for a Bridged port to convert to a switch optimized mode in seconds if vportBrdgMode is set to autoSwitch(1). Setting it to zero will cause automactic switching between the two modes immediately. The default is 60 seconds.')
vportDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportDescription.setStatus('mandatory')
if mibBuilder.loadTexts: vportDescription.setDescription('A string to identify the instance of this port.')
vportAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 13), XylanVportAdminStatCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vportAdmStatus.setDescription('The administrative status of this port which the user can attach or detach during configuration. The attached port can also be switched to disable(1) or enable(2), or delete(3). create(4) and modify(5) are used ONLY for traps.')
vportOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 14), XylanPortOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vportOperStatus.setDescription('The operational status of this virtual port. This is called slot/if/type/instance???. Note that if the card is removed for this slot, the service will be marked as portDown(1). The chassis MIB will maintain the record of the card be absent....')
vportFrameIns = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportFrameIns.setStatus('mandatory')
if mibBuilder.loadTexts: vportFrameIns.setDescription('The number of frames received from this port.')
vportInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vportInOctets.setDescription('The total number of octets received from this port.')
vportInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vportInUcastPkts.setDescription('The total number of subnetwork-unicast packets received.')
vportInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vportInNUcastPkts.setDescription('The total number of non-unicast packets received.')
vportInBufDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportInBufDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: vportInBufDiscs.setDescription('The number of inbound frames discarded from this port due to receive queue overrun.')
vportInErrDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportInErrDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: vportInErrDiscs.setDescription('The number of inbound frames discarded from this port due to error.')
vportFrameOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportFrameOuts.setStatus('mandatory')
if mibBuilder.loadTexts: vportFrameOuts.setDescription('The number of frames transmitted from this port.')
vportOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vportOutOctets.setDescription('The total number of octets transmitted from this port.')
vportOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vportOutUcastPkts.setDescription('The total number of subnetwork-unicast packets transmitted.')
vportOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vportOutNUcastPkts.setDescription('The total number of non-unicast packets transmitted.')
vportOutBufDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOutBufDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: vportOutBufDiscs.setDescription('The number of outbound frames discarded from this port due to transmit queue overrun.')
vportOutErrDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportOutErrDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: vportOutErrDiscs.setDescription('The number of outbound frames discarded from this port due to error.')
vportFloodLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportFloodLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vportFloodLimit.setDescription('The amount of flooded bandwidth in byte / second that may be transmitted on this port.')
vportVLANMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportVLANMembership.setStatus('mandatory')
if mibBuilder.loadTexts: vportVLANMembership.setDescription('This object is a bit mask with each bit that is set indicating that the VLAN given by the bit position is active on this port.')
vportManualMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dynamic", 1), ("manual-override-forwarding", 2), ("manual-override-blocking", 3), ("mode-not-applicable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportManualMode.setStatus('mandatory')
if mibBuilder.loadTexts: vportManualMode.setDescription('This setting permits the user to manually set the spanning tree state of the given port. It is designed primarily for those virtual ports that can not utilize the IBM spanning tree algorithm. If set to the manual mode (ether manual_override_forwarding or manual_override_blockng), the IEEE or IBM spanning tree algorithm is disabled for the given port.')
vportMVLANMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportMVLANMembership.setStatus('mandatory')
if mibBuilder.loadTexts: vportMVLANMembership.setDescription('This object is a bit mask with each bit that is set indicating that the Multicast VLAN given by the bit position is active on this port.')
vportFloodLimitDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportFloodLimitDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: vportFloodLimitDiscs.setDescription('The number of outbound frames discarded from this port due to the flood limit being exceed.')
vportIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vportIfIndex.setDescription("The MIB-2 interface table 'ifIndex' assigned to this virtual port.")
phyPortTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1), )
if mibBuilder.loadTexts: phyPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortTable.setDescription('A list of Physical Port instances.')
phyPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1), ).setIndexNames((0, "XYLAN-PORT-MIB", "phyPortSlot"), (0, "XYLAN-PORT-MIB", "phyPortIF"))
if mibBuilder.loadTexts: phyPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortEntry.setDescription('A Physical Port entry.')
phyPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortSlot.setDescription('The physical slot number for this port.')
phyPortIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortIF.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortIF.setDescription('The on-board interface number.')
phyPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 3), XylanPhyPortTypeCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortMediaType.setDescription('The device type of this physical port')
phyPortDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyPortDescription.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortDescription.setDescription('A string to identify the instance of this port.')
phyPortAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 5), XylanPhyPortAdminStatCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyPortAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortAdmStatus.setDescription('The administrative status of this port. The user can enable or disable this physical port.')
phyPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 6), XylanPortOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOperStatus.setDescription('The operational status of this port.')
phyPortFrameIns = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortFrameIns.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortFrameIns.setDescription('The number of frames received from this port.')
phyPortInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortInOctets.setDescription('The total number of octets received from this port.')
phyPortInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortInUcastPkts.setDescription('The total number of subnetwork-unicast packets received.')
phyPortInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortInNUcastPkts.setDescription('The total number of non-unicast packets received.')
phyPortInBufDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortInBufDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortInBufDiscs.setDescription('The number of inbound frames discarded from this port due to receive queue overrun.')
phyPortInErrDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortInErrDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortInErrDiscs.setDescription('The number of inbound frames discarded from this port due to error.')
phyPortFrameOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortFrameOuts.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortFrameOuts.setDescription('The number of frames transmitted from this port.')
phyPortOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOutOctets.setDescription('The total number of octets transmitted from this port.')
phyPortOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOutUcastPkts.setDescription('The total number of subnetwork-unicast packets transmitted.')
phyPortOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOutNUcastPkts.setDescription('The total number of non-unicast packets transmitted.')
phyPortOutBufDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOutBufDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOutBufDiscs.setDescription('The number of outbound frames discarded from this port due to transmit queue overrun.')
phyPortOutErrDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortOutErrDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortOutErrDiscs.setDescription('The number of outbound frames discarded from this port due to error.')
phyPortToInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortToInterface.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortToInterface.setDescription("The interface number which instantiates the MIB-2 'ifTable' for this physical port. It is calculated as 'phyPortSlot' multipled by 100 plus 'phyPortIF' for this physical port.")
phyPortFddiAdmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("station", 2), ("concentrator", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyPortFddiAdmMode.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortFddiAdmMode.setDescription('The administrative mode of this FDDI port. The user can set this port to either station(2) of concentrator(3) mode. NOTE: this does not take effect until the SMT subsystem is restarted. Examine the phyPortFddiOpMode to see the current operational mode. The administrative mode will be invalid(1) for all but FDDI or CDDI boards.')
phyPortFddiOpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("station", 2), ("concentrator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyPortFddiOpMode.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortFddiOpMode.setDescription('The current station Operational Mode of this FDDI port. The Operational Mode will be invalid(1) for all but FDDI or CDDI boards.')
phyPortFddiMacFlushMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyPortFddiMacFlushMode.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortFddiMacFlushMode.setDescription('The current MAC address flush mode (only valid for FDDI ports of mode concentrator). This controls whether MAC addresses will be flushed if any PHY port disconnects are detected. The MAC address flush mode will be invalid(1) for all but FDDI or CDDI boards.')
mesmConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2), )
if mibBuilder.loadTexts: mesmConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mesmConfTable.setDescription('A list of MESM Physical Port instances.')
mesmConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1), ).setIndexNames((0, "XYLAN-PORT-MIB", "mesmPortSlot"), (0, "XYLAN-PORT-MIB", "mesmPortIF"))
if mibBuilder.loadTexts: mesmConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mesmConfEntry.setDescription('A MESM Physical Port entry.')
mesmPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mesmPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortSlot.setDescription('The physical slot number for this MESM port.')
mesmPortIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mesmPortIF.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortIF.setDescription('The on-board interface number for this MESM port.')
mesmPortAutoNegotiate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("non-appl", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mesmPortAutoNegotiate.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortAutoNegotiate.setDescription('The current autonegotiate mode of this MESM port. This object decides if port line speed and duplex mode are controlled by the user or negotiated automatically.')
mesmPortAutoSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed-100", 1), ("speed-10", 2), ("speed-auto", 3), ("unknown", 4), ("speed-1000", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mesmPortAutoSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortAutoSpeed.setDescription('The automatically detected port line speed of this MESM port.')
mesmPortAutoDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2), ("auto-duplex", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mesmPortAutoDuplexMode.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortAutoDuplexMode.setDescription('The automatically detected port duplex mode of this MESM port.')
mesmPortCfgSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed-100", 1), ("speed-10", 2), ("speed-auto", 3), ("unknown", 4), ("speed-1000", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mesmPortCfgSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortCfgSpeed.setDescription('The configured port line speed of this MESM port.')
mesmPortCfgDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2), ("auto-duplex", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mesmPortCfgDuplexMode.setStatus('mandatory')
if mibBuilder.loadTexts: mesmPortCfgDuplexMode.setDescription('The configured port duplex mode of this MESM port.')
phyPortPCause = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("flood-q-stalled", 1), ("excess-retries", 2), ("excess-runts", 3))))
if mibBuilder.loadTexts: phyPortPCause.setStatus('mandatory')
if mibBuilder.loadTexts: phyPortPCause.setDescription('The cause for a port partitioning event. This object is not intended to be accessed directly. It is defined for use in port partitioning traps.')
vportSwitchTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2), )
if mibBuilder.loadTexts: vportSwitchTable.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchTable.setDescription('A list of Virtual Port instances.')
vportSwitchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2), ).setIndexNames((0, "XYLAN-PORT-MIB", "vportSwitchSlot"), (0, "XYLAN-PORT-MIB", "vportSwitchIF"), (0, "XYLAN-PORT-MIB", "vportSwitchFuncType"), (0, "XYLAN-PORT-MIB", "vportSwitchFuncTypeInstance"))
if mibBuilder.loadTexts: vportSwitchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchEntry.setDescription('A Virtual Port Switch Options entry.')
vportSwitchSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchSlot.setDescription('The physical slot number for this port instance (vport).')
vportSwitchIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchIF.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchIF.setDescription('The on-board interface number.')
vportSwitchFuncType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 3), XylanPortFuncCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchFuncType.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchFuncType.setDescription('The function for this vport. ie. local, remote, atm.')
vportSwitchFuncTypeInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchFuncTypeInstance.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchFuncTypeInstance.setDescription("The specific instance of this slot/IF/type. For 'most' interface types this will always be 1. The exception is an ATM connected port.")
vportSwitchipEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 5), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipEthertype.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipEthertype.setDescription('A Virtual Port Switch translation option for IP Ethertype traffic.')
vportSwitchipSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 6), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipSnap.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipSnap.setDescription('A Virtual Port Switch translation option for IP SNAP traffic.')
vportSwitchipxEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 7), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipxEthertype.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipxEthertype.setDescription('A Virtual Port Switch translation option for IPX Ethertype traffic.')
vportSwitchipxProp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 8), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipxProp.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipxProp.setDescription('A Virtual Port Switch translation option for IPX 802.3 traffic.')
vportSwitchipxLlc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 9), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipxLlc.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipxLlc.setDescription('A Virtual Port Switch translation option for IPX 802.2 traffic.')
vportSwitchipxSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 2, 2, 10), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchipxSnap.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchipxSnap.setDescription('A Virtual Port Switch translation option for IPX SNAP traffic.')
vportSwitchDefaultTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3), )
if mibBuilder.loadTexts: vportSwitchDefaultTable.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultTable.setDescription('A list of Media instances.')
vportSwitchDefaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2), ).setIndexNames((0, "XYLAN-PORT-MIB", "vportSwitchDefaultIndex"))
if mibBuilder.loadTexts: vportSwitchDefaultEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultEntry.setDescription('A Virtual Port Switch Options entry.')
vportSwitchDefaultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ethernet", 1), ("fddi", 2), ("tokenring", 3), ("ethLanEmulation", 4), ("tokenLanEmulation", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultIndex.setDescription('The index selecting which media type default is to be configured/viewed.')
vportSwitchDefaultipEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 2), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipEthertype.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipEthertype.setDescription('A Virtual Port Switch translation option for IP Ethertype traffic.')
vportSwitchDefaultipSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 3), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipSnap.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipSnap.setDescription('A Virtual Port Switch translation option for IP SNAP traffic.')
vportSwitchDefaultipxEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 4), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipxEthertype.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipxEthertype.setDescription('A Virtual Port Switch translation option for IPX Ethertype traffic.')
vportSwitchDefaultipxProp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 5), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipxProp.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipxProp.setDescription('A Virtual Port Switch translation option for IPX 802.3 traffic.')
vportSwitchDefaultipxLlc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 6), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipxLlc.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipxLlc.setDescription('A Virtual Port Switch translation option for IPX LLC traffic.')
vportSwitchDefaultipxSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 1, 3, 2, 7), XylanVportTranslationCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vportSwitchDefaultipxSnap.setStatus('mandatory')
if mibBuilder.loadTexts: vportSwitchDefaultipxSnap.setDescription('A Virtual Port Switch translation option for IPX SNAP traffic.')
mirrorTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1), )
if mibBuilder.loadTexts: mirrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorTable.setDescription('A list of Virtual Port instances.')
mirrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1), ).setIndexNames((0, "XYLAN-PORT-MIB", "mirrorSlot"), (0, "XYLAN-PORT-MIB", "mirrorIF"), (0, "XYLAN-PORT-MIB", "mirrorFuncType"), (0, "XYLAN-PORT-MIB", "mirrorFuncTypeInstance"))
if mibBuilder.loadTexts: mirrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorEntry.setDescription('A Virtual Port entry.')
mirrorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorNumber.setDescription('A unique number identifies this Virtual Port instance within the physical OmniSwitch. This number is NOT meant for user consumption.')
mirrorSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorSlot.setDescription('The physical slot number for this port instance (mirror).')
mirrorIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorIF.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorIF.setDescription('The on-board interface number.')
mirrorFuncType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 4), XylanPortFuncCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorFuncType.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorFuncType.setDescription('The function for this Vport. ie. local, remote, atm.')
mirrorFuncTypeInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorFuncTypeInstance.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorFuncTypeInstance.setDescription("The specific instance of this slot/IF/type. For 'most' interface types this will always be 1. The exception is an ATM connected port.")
mirrorMirroringSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorMirroringSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorMirroringSlot.setDescription('The physical slot number of the mirroring port.')
mirrorMirroringIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorMirroringIF.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorMirroringIF.setDescription('The on-board interface number or the mirroring port.')
mirrorMirroringFuncType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 8), XylanPortFuncCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorMirroringFuncType.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorMirroringFuncType.setDescription('The function for this Vport. ie. local, remote, atm.')
mirrorMirroringFuncTypeInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorMirroringFuncTypeInstance.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorMirroringFuncTypeInstance.setDescription("The specific instance of this slot/IF/type. For 'most' interface types this will always be 1. The exception is an ATM connected port.")
mirrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 3, 4, 1, 1, 10), XylanMirrorEnableCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mirrorStatus.setDescription('Whether mirroring is enabled or disabled for this port. prior to enabling mirroring, or at the same time all other read write values in this table for the same row must be set to appropriate values, or defaults will be assumed.')
mibBuilder.exportSymbols("XYLAN-PORT-MIB", phyPortMediaType=phyPortMediaType, logicalPort=logicalPort, vportMVLANMembership=vportMVLANMembership, vportInUcastPkts=vportInUcastPkts, mirrorMirroringFuncTypeInstance=mirrorMirroringFuncTypeInstance, vportVLANMembership=vportVLANMembership, vportEncapsulation=vportEncapsulation, mirrorFuncTypeInstance=mirrorFuncTypeInstance, vportTable=vportTable, mesmConfTable=mesmConfTable, mesmPortIF=mesmPortIF, mirrorPort=mirrorPort, XylanPhyPortTypeCodes=XylanPhyPortTypeCodes, XylanPortOperStatCodes=XylanPortOperStatCodes, vportIF=vportIF, mesmPortCfgSpeed=mesmPortCfgSpeed, vportFloodLimit=vportFloodLimit, vportSwitchDefaultipSnap=vportSwitchDefaultipSnap, vportDescription=vportDescription, phyPortInOctets=phyPortInOctets, vportVlanNumber=vportVlanNumber, vportSwitchEntry=vportSwitchEntry, vportSwitchipSnap=vportSwitchipSnap, vportInOctets=vportInOctets, vportOutOctets=vportOutOctets, mirrorEntry=mirrorEntry, vportFuncTypeInstance=vportFuncTypeInstance, phyPortInUcastPkts=phyPortInUcastPkts, vportMACaddress=vportMACaddress, phyPortFddiMacFlushMode=phyPortFddiMacFlushMode, phyPortFrameOuts=phyPortFrameOuts, phyPortFddiAdmMode=phyPortFddiAdmMode, phyPortPCause=phyPortPCause, phyPortFrameIns=phyPortFrameIns, vportSwitchIF=vportSwitchIF, mirrorIF=mirrorIF, vportOperStatus=vportOperStatus, mesmPortCfgDuplexMode=mesmPortCfgDuplexMode, vportFrameOuts=vportFrameOuts, vportEntry=vportEntry, phyPortDescription=phyPortDescription, vportSwitchipxLlc=vportSwitchipxLlc, vportInNUcastPkts=vportInNUcastPkts, vportSwitchDefaultipxSnap=vportSwitchDefaultipxSnap, mirrorStatus=mirrorStatus, vportSwitchTable=vportSwitchTable, phyPortInBufDiscs=phyPortInBufDiscs, vportNumber=vportNumber, vportSwitchTimer=vportSwitchTimer, phyPortIF=phyPortIF, vportSlot=vportSlot, vportBrdgMode=vportBrdgMode, vportSwitchDefaultipEthertype=vportSwitchDefaultipEthertype, vportOutErrDiscs=vportOutErrDiscs, mirrorMirroringFuncType=mirrorMirroringFuncType, mesmPortAutoSpeed=mesmPortAutoSpeed, vportSwitchSlot=vportSwitchSlot, mirrorMirroringIF=mirrorMirroringIF, phyPortFddiOpMode=phyPortFddiOpMode, XylanPhyPortAdminStatCodes=XylanPhyPortAdminStatCodes, XylanMirrorEnableCodes=XylanMirrorEnableCodes, vportSwitchipEthertype=vportSwitchipEthertype, vportFrameIns=vportFrameIns, vportSwitchDefaultipxLlc=vportSwitchDefaultipxLlc, mirrorFuncType=mirrorFuncType, mirrorMirroringSlot=mirrorMirroringSlot, virtualPort=virtualPort, phyPortTable=phyPortTable, vportSwitchDefaultipxProp=vportSwitchDefaultipxProp, physicalPort=physicalPort, mirrorSlot=mirrorSlot, echannelPort=echannelPort, phyPortOutNUcastPkts=phyPortOutNUcastPkts, phyPortOperStatus=phyPortOperStatus, vportManualMode=vportManualMode, phyPortToInterface=phyPortToInterface, phyPortOutBufDiscs=phyPortOutBufDiscs, vportSwitchipxSnap=vportSwitchipxSnap, mirrorTable=mirrorTable, phyPortOutOctets=phyPortOutOctets, XylanVportTranslationCodes=XylanVportTranslationCodes, vportFloodLimitDiscs=vportFloodLimitDiscs, vportSwitchDefaultipxEthertype=vportSwitchDefaultipxEthertype, vportSwitchDefaultEntry=vportSwitchDefaultEntry, vportFuncType=vportFuncType, vportOutNUcastPkts=vportOutNUcastPkts, vportSwitchFuncTypeInstance=vportSwitchFuncTypeInstance, vportSwitchDefaultTable=vportSwitchDefaultTable, vportSwitchFuncType=vportSwitchFuncType, phyPortSlot=phyPortSlot, vportIfIndex=vportIfIndex, vportSwitchDefaultIndex=vportSwitchDefaultIndex, XylanPortFuncCodes=XylanPortFuncCodes, mesmPortSlot=mesmPortSlot, vportOutBufDiscs=vportOutBufDiscs, vportInErrDiscs=vportInErrDiscs, mirrorNumber=mirrorNumber, phyPortInErrDiscs=phyPortInErrDiscs, XylanVportAdminStatCodes=XylanVportAdminStatCodes, vportBridgeProtocol=vportBridgeProtocol, vportSwitchipxProp=vportSwitchipxProp, mesmPortAutoNegotiate=mesmPortAutoNegotiate, phyPortOutErrDiscs=phyPortOutErrDiscs, vportInBufDiscs=vportInBufDiscs, XylanVportEncapsulationCodes=XylanVportEncapsulationCodes, mesmConfEntry=mesmConfEntry, phyPortEntry=phyPortEntry, vportAdmStatus=vportAdmStatus, vportSwitchipxEthertype=vportSwitchipxEthertype, phyPortInNUcastPkts=phyPortInNUcastPkts, vportOutUcastPkts=vportOutUcastPkts, phyPortAdmStatus=phyPortAdmStatus, phyPortOutUcastPkts=phyPortOutUcastPkts, mesmPortAutoDuplexMode=mesmPortAutoDuplexMode)

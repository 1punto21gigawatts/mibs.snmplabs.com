#
# PySNMP MIB module HH3C-DOT11-CFG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-DOT11-CFG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:26:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
Hh3cDot11SSIDStringType, Hh3cDot11PreambleType, Hh3cDot11ChannelScopeType, Hh3cDot11CirMode, Hh3cDot11WorkMode, Hh3cDot11TxPwrLevelScopeType, Hh3cDot11RadioType, Hh3cDot11SSIDEncryptModeType, Hh3cDot11RadioElementIndex, Hh3cDot11SecIEStatusType, Hh3cDot11ObjectIDType, Hh3cDot11RadioScopeType, Hh3cDot11ServicePolicyIDType, hh3cDot11, Hh3cDot11AuthenType, Hh3cDot11TunnelSecSchemType, hh3cDot11APElementIndex = mibBuilder.importSymbols("HH3C-DOT11-REF-MIB", "Hh3cDot11SSIDStringType", "Hh3cDot11PreambleType", "Hh3cDot11ChannelScopeType", "Hh3cDot11CirMode", "Hh3cDot11WorkMode", "Hh3cDot11TxPwrLevelScopeType", "Hh3cDot11RadioType", "Hh3cDot11SSIDEncryptModeType", "Hh3cDot11RadioElementIndex", "Hh3cDot11SecIEStatusType", "Hh3cDot11ObjectIDType", "Hh3cDot11RadioScopeType", "Hh3cDot11ServicePolicyIDType", "hh3cDot11", "Hh3cDot11AuthenType", "Hh3cDot11TunnelSecSchemType", "hh3cDot11APElementIndex")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, MibIdentifier, ModuleIdentity, Counter32, IpAddress, Integer32, Counter64, NotificationType, iso, TimeTicks, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibIdentifier", "ModuleIdentity", "Counter32", "IpAddress", "Integer32", "Counter64", "NotificationType", "iso", "TimeTicks", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Bits")
RowStatus, DisplayString, MacAddress, TextualConvention, TruthValue, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "MacAddress", "TextualConvention", "TruthValue", "DateAndTime")
hh3cDot11CFG = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4))
hh3cDot11CFG.setRevisions(('2010-09-25 18:00', '2010-09-02 18:00', '2009-07-29 18:00', '2009-05-07 20:00', '2009-03-20 15:30', '2008-11-07 15:30', '2008-07-09 18:00', '2008-02-25 18:00', '2007-12-21 18:00', '2007-10-09 16:55', '2007-06-19 18:00', '2007-04-27 20:00', '2007-02-01 20:00', '2006-05-10 19:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cDot11CFG.setRevisionsDescriptions(('Modified to remove some issue.', 'Modified to add new node.', 'Modified to add new nodes and new table.', 'Modified to add new nodes and new table.', 'Modified to add new value for appointed node.', 'Modified to add new nodes and new table.', 'Modified to add new groups.', 'Modified to add new nodes.', 'Modified to add new nodes.', 'changed for new requirements', 'Modified to add new table.', 'Modified to fix some issue.', 'Modified to support fat AP.', 'The initial revision of this MIB module.',))
if mibBuilder.loadTexts: hh3cDot11CFG.setLastUpdated('201009251800Z')
if mibBuilder.loadTexts: hh3cDot11CFG.setOrganization('Marconi Corporation PLC.')
if mibBuilder.loadTexts: hh3cDot11CFG.setContactInfo('Data Networks Team 3000 Marconi Drive,Warrendale,Pennsylvania,15086. Http://www.marconi.com E-mail:support@marconi.com')
if mibBuilder.loadTexts: hh3cDot11CFG.setDescription('This MIB provides information about WLAN configuration. GLOSSARY IEEE 802.11 Standard to encourage interoperability among wireless networking equipment. Access point (AP) Transmitter/receiver (transceiver) device that commonly connects and transports data between a wireless network and a wired network. Access control (AC) To control and manage multi-APs, it will bridge wireless and wired network. Fat AP Applied in the home, SOHO and so on, and it could work independently without help from AC. Fit AP Applied in the enterprise environment, it will work under the control and management from AC. Control And Provisioning of Wireless Access Points Protocol The short name of protocol is CAPWAP. AC will control and manage AP by CAPWAP tunnel protocol defined by IETF. Also, a data tunnel will be set up between AC and AP. BSS IEEE 802.11 Basic Service Set (Radio Cell). The BSS of an AP comprises of the stations directly associating with the AP. Radio The chip set to receive and send wireless signal. Association The service used to establish access point or station mapping and enable station invocation of the distribution system services. (Wireless clients attempt to connect to access points.) Basic Rate A data rate that is mandatory for client devices to support in order for them to achieve successful association. MSDU MAC Service Data Unit, it is frame format defined by 802.11. TU It is 1,024 microseconds (ms), which is about 1 millisecond. AKM The authentication and key management method defined by 802.11i, and which includes 802.1x and pre-shared key.')
hh3cDot11GlobeConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1))
hh3cDot11PolicyConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2))
hh3cDot11APConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3))
hh3cDot11RadioIntfConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4))
hh3cDot11DataRateConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5))
hh3cDot11InterfaceConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6))
hh3cDot11ACBackupGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 7))
hh3cDot11RadioElementConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8))
hh3cDot11CfgNotifyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9))
hh3cDot11GlobalCountryCode = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11GlobalCountryCode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11GlobalCountryCode.setDescription('Represents the country code for wireless network.')
hh3cDot11StaKeepALiveTimerIntvl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 2), Unsigned32()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11StaKeepALiveTimerIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StaKeepALiveTimerIntvl.setDescription('Represents the interval of the keep alive requests sent between AP and STA. Default value 0 : The keep alive function is disabled.')
hh3cDot11StaIdleTimerIntvl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 3), Integer32()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11StaIdleTimerIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StaIdleTimerIntvl.setDescription('Represents the interval for which the link between AP and STA ( power-save or awake ) can be idle.')
hh3cDot11BroadcastProbeReply = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11BroadcastProbeReply.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11BroadcastProbeReply.setDescription("Represents enable the AP to reply broadcast probe or not. 'true' : The AP to reply broadcast probe is enabled. 'false': The AP to reply broadcast probe is disabled")
hh3cDot11APScanMode = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APScanMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APScanMode.setDescription('Represents the scanning mode for AP. The following values are supported: active(1), - AP will actively do scan. passive(2) - AP will passively do scan.')
hh3cDot11ACCtrlTunnelSecSupport = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 6), Hh3cDot11TunnelSecSchemType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11ACCtrlTunnelSecSupport.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ACCtrlTunnelSecSupport.setDescription('Represents what security schemes are supported for CAPWAP Control tunnel.')
hh3cDot11ACDataTunnelSecSupport = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 7), Hh3cDot11TunnelSecSchemType().clone('cleartxt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11ACDataTunnelSecSupport.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ACDataTunnelSecSupport.setDescription('Represents what security schemes are supported for CAPWAP data tunnel. The cleartxt is the default scheme.')
hh3cDot11ACAutoAPSupport = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11ACAutoAPSupport.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ACAutoAPSupport.setDescription("Represents enable the auto AP functionality or not. 'true' : The auto AP functionality is enabled. 'false': The auto AP functionality is disabled")
hh3cDot11AutoAPName = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11AutoAPName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11AutoAPName.setDescription('Represents the name of auto AP which need to be made persistent. When read the value from the node, NULL value be returned.')
hh3cDot11PersistentName = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11PersistentName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PersistentName.setDescription('Represents the new name of auto AP after being made persistent. When read the value from the node, NULL value be returned.')
hh3cDot11IntfTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 11), Integer32()).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11IntfTrapThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11IntfTrapThreshold.setDescription('Represents threshold of interference trap. If signal strength of the device exceeds this threshold, corresponding trap will be sent.')
hh3cDot11MonitorInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 15), ))).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11MonitorInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11MonitorInterval.setDescription('Represents the monitoring interval. Default value 0 : The monitoring functionality is changed to real-time mode.')
hh3cDot11SampleInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 300), ))).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SampleInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SampleInterval.setDescription('Represents the sampling interval. Default value 0 : The sampling functionality is disabled.')
hh3cDot11ChnlSwitChkInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(8, 180)).clone(8)).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11ChnlSwitChkInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ChnlSwitChkInterval.setDescription('Represents the checking interval of channel switch.')
hh3cDot11APUserUplimit = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APUserUplimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APUserUplimit.setDescription('Represents the upper limit of user which has access to this AP.')
hh3cDot11APL2IsolateEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APL2IsolateEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APL2IsolateEnable.setDescription("Represents enable the layer2 isolation or not. 'true' : The layer2 isolation functionality is enabled. 'false': The layer2 isolation functionality is disabled.")
hh3cDot11APBSSIDSupportNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11APBSSIDSupportNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APBSSIDSupportNum.setDescription('Represents the max number of BSSID supported by Current AP.')
hh3cDot11APLastUpdateStatTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 18), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11APLastUpdateStatTime.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APLastUpdateStatTime.setDescription('Represents date and time update statistic information lately.')
hh3cDot11APDoSProtectEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 19), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APDoSProtectEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APDoSProtectEnable.setDescription("Represents enable the DOS protection or not. 'true' : The DOS protection functionality is enabled. 'false': The DOS protection functionality is disabled.")
hh3cDot11MaxAPPerIf = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11MaxAPPerIf.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11MaxAPPerIf.setDescription('Represents max AP number that can be connected to AC interface.')
hh3cDot11SampleTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 21), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11SampleTimeStamp.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SampleTimeStamp.setDescription('Represents the start time of current sample period.')
hh3cDot11UplinkTrackId = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 22), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11UplinkTrackId.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11UplinkTrackId.setDescription('Represents the track id of AP. Default value 0 : The uplink track function for AP is disabled.')
hh3cDot11RtCollectSwitch = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 23), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RtCollectSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RtCollectSwitch.setDescription('This object is used to turn on/off real-time statistics collection between AC and AP. If the value is true, hh3cDot11RtCollectIntvl will take effect. Otherwise, hh3cDot11RglCollectIntvl will take effect.')
hh3cDot11RglCollectIntvl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 24), Integer32()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RglCollectIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RglCollectIntvl.setDescription('This object represents interval to regularly collect statistics from AC to AP.')
hh3cDot11RtCollectIntvl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 25), Integer32()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RtCollectIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RtCollectIntvl.setDescription('This object represents interval to collect real-time statistics from AC to AP.')
hh3cDot11AllAPCpuUsageThreshold = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('onepercent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11AllAPCpuUsageThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11AllAPCpuUsageThreshold.setDescription('The CPU usage threshold for all AP.')
hh3cDot11AllAPMemUsageThreshold = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('onepercent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11AllAPMemUsageThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11AllAPMemUsageThreshold.setDescription('The memory usage threshold for all AP.')
hh3cDot11AdjIntfTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 1, 28), Integer32()).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11AdjIntfTrapThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11AdjIntfTrapThreshold.setDescription('Represents threshold of adjacent interference trap. If signal strength of the device exceeds this threshold, corresponding trap will be sent.')
hh3cDot11RadioPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1), )
if mibBuilder.loadTexts: hh3cDot11RadioPolicyTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioPolicyTable.setDescription('The table defines the parameters for radio policy, as per radio policy of CLI. One radio policy could be assigned to the different radios (AP).')
hh3cDot11RadioPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1), ).setIndexNames((1, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioPolicyName"))
if mibBuilder.loadTexts: hh3cDot11RadioPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioPolicyEntry.setDescription('Each entry contains information of each radio policy.')
hh3cDot11RadioPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127)))
if mibBuilder.loadTexts: hh3cDot11RadioPolicyName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioPolicyName.setDescription('Represents the name of radio policy.')
hh3cDot11BeaconInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 2), Integer32().clone(100)).setUnits('TU').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11BeaconInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11BeaconInterval.setDescription('Represents the interval for Beacon management frame.')
hh3cDot11DtimInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 3), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11DtimInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11DtimInterval.setDescription('Represents the number of beacon intervals that shall elapse between transmission of Beacons frames containing a Traffic Indication Map (TIM) element whose DTIM Count field is 0. This value is transmitted in the Delivery TIM (DTIM) Period field of Beacon frames.')
hh3cDot11RtsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 4), Integer32().clone(2346)).setUnits('byte').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RtsThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RtsThreshold.setDescription('Represents the current minimum size,in octets,of the MAC protocol data unit (MPDU), below which a Request to send/Clear to send (RTS/CTS) handshake shall not be performed.')
hh3cDot11FragThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 5), Integer32().clone(2346)).setUnits('byte').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11FragThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11FragThreshold.setDescription('Represents the current maximum size, in octets, of the MPDU that may be delivered to the PHY. A MSDU shall be broken into fragments if its size exceeds the value of this attribute after adding MAC headers and trailers.')
hh3cDot11ShortRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 6), Integer32().clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11ShortRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ShortRetryThreshold.setDescription('Represents the maximum number of transmission attempts of a frame, the length of which is less than or equal to hh3cDot11RTSThreshold, that shall be made before a failure condition is indicated.')
hh3cDot11LongRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 7), Integer32().clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11LongRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11LongRetryThreshold.setDescription('Represents the maximum number of transmission attempts of a frame, the length of which is longer than hh3cDot11RTSThreshold, that shall be made before a failure condition is indicated.')
hh3cDot11MaxRxLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 8), Unsigned32().clone(2000)).setUnits('millisecond').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11MaxRxLifetime.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11MaxRxLifetime.setDescription('Represents the elapsed time. After the time specified by hh3cDot11MaxRxLifetime, the further attempts to reassemble the MSDU shall be terminated.')
hh3cDot11RdoPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RdoPolicyRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RdoPolicyRowStatus.setDescription('The status of this table entry.')
hh3cDot11RdoClientMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RdoClientMaxCount.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RdoClientMaxCount.setDescription('Represent the maximum number of stations supported by this radio policy.')
hh3cDot11BeaconIntervalMs = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 1, 1, 11), Integer32()).setUnits('ms').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11BeaconIntervalMs.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11BeaconIntervalMs.setDescription('Represents the interval for Beacon management frame.')
hh3cDot11ServicePolicyTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2), )
if mibBuilder.loadTexts: hh3cDot11ServicePolicyTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyTable.setDescription('The table defines the parameters for ESS, as per service policy of CLI. One service policy could be assigned to the different radios (AP).')
hh3cDot11ServicePolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11ServicePolicyID"))
if mibBuilder.loadTexts: hh3cDot11ServicePolicyEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyEntry.setDescription('Each entry contains information of each service policy.')
hh3cDot11ServicePolicyID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 1), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11ServicePolicyID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyID.setDescription('Represents the ID of each service policy.')
hh3cDot11SSIDName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 2), Hh3cDot11SSIDStringType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SSIDName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SSIDName.setDescription('Represents the ESS. As per CLI, the value of service policy name will be SSID.')
hh3cDot11SSIDHidden = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SSIDHidden.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SSIDHidden.setDescription('This attribute controls whether the SSID will be advertised in the beacon frame. If it is true, then SSID will not be advertised in the beacon frame.')
hh3cDot11AuthenMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 4), Hh3cDot11AuthenType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11AuthenMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11AuthenMode.setDescription('Represents the Authentication mode defined by 802.11.')
hh3cDot11SSIDEncryptionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 5), Hh3cDot11SSIDEncryptModeType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SSIDEncryptionMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SSIDEncryptionMode.setDescription('Represents the encryption mode for this ESS.')
hh3cDot11WlanInfBindingType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 6), OctetString().clone('WLAN-ESS')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanInfBindingType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanInfBindingType.setDescription('Represents the service policy will bind to what kind of data forwarding interface.')
hh3cDot11WlanInfBindingID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanInfBindingID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanInfBindingID.setDescription('Represents the interface ID of the interface that ESS will bind to. If the value is set to -1, the binding will be removed.')
hh3cDot11SrvPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SrvPolicyRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPolicyRowStatus.setDescription('The status of this table entry.')
hh3cDot11ClientMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11ClientMaxCount.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ClientMaxCount.setDescription('Represent the maximum number of stations supported by this service policy.')
hh3cDot11SPInCirMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 10), Hh3cDot11CirMode().clone('static')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPInCirMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPInCirMode.setDescription(' CIR(committed information rate) mode of inbound direction. This object is useful only when the corresponding CIR is nonzero. If value of this object is changed, corresponding CIR will be reset.')
hh3cDot11SPInCirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 11), Integer32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPInCirValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPInCirValue.setDescription('Represents the CIR of inbound direction of this service policy. If the value is 0, it means that no flow control is applied to the service policy, and the corresponding CIR mode is meaningless.')
hh3cDot11SPOutCirMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 12), Hh3cDot11CirMode().clone('static')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPOutCirMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPOutCirMode.setDescription(' CIR(committed information rate) mode of outbound direction. This object is useful only when the corresponding CIR is nonzero. If value of this object is changed, corresponding CIR will be reset.')
hh3cDot11SPOutCirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 13), Integer32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPOutCirValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPOutCirValue.setDescription('Represents the CIR of outbound direction of this service policy. If the value is 0, it means that no flow control is applied to the service policy, and the corresponding CIR mode is meaningless.')
hh3cDot11WlanInfPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 14), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanInfPVID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanInfPVID.setDescription('Represents the VLAN ID of SSID.')
hh3cDot11SPInCirStaticValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 15), Integer32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPInCirStaticValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPInCirStaticValue.setDescription('Represents the CIR of inbound direction for static CIR mode.')
hh3cDot11SPOutCirStaticValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 16), Integer32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPOutCirStaticValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPOutCirStaticValue.setDescription('Represents the CIR of outbound direction for static CIR mode.')
hh3cDot11SPIsolate = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 2, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SPIsolate.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPIsolate.setDescription('If it is true, then stations connected with the service policy are isolated.')
hh3cDot11ServicePolicyExtTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3), )
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtTable.setDescription('The table defines the parameters for ESS, as per service policy of CLI. When the value of hh3cDot11SSIDEncryptionMode equals to cipher(2), more configuration for a ESS will be put into the table.')
hh3cDot11ServicePolicyExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11ServicePolicyExtID"))
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtEntry.setDescription('Each entry contains information of each service policy under cipher(2) mode.')
hh3cDot11ServicePolicyExtID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 1), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServicePolicyExtID.setDescription('Represents the ID of each service policy.')
hh3cDot11SecIEStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 2), Hh3cDot11SecIEStatusType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SecIEStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecIEStatus.setDescription('To enable the security Information element in the beacon and probe response frames sent by AP.')
hh3cDot11SecurityCiphers = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SecurityCiphers.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecurityCiphers.setDescription('The WLAN system support the following cipher type for data frame encryption. wep40(2) tkip(4) aesccmp(16) wep104(32) wpisms4(64) wep128(128) For each service policy,it could support multiple cipher types at the same time.So the value of object could combine multiple value of cipher type above. When the value of node equals to zero, it means no configuration or undo operation.')
hh3cDot11CipherKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 4), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11CipherKeyIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CipherKeyIndex.setDescription('Represents the key index of cipher key for packet. When hh3cDot11SecurityCiphers value is wep40 or wep104, the configuration will take effective.')
hh3cDot11CipherKey = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 5), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11CipherKey.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CipherKey.setDescription('Represents the cipher key for packet. When hh3cDot11SecurityCiphers value is wep40 or wep104, the configuration will take effective.')
hh3cDot11SrvPolicyExtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtRowStatus.setDescription('The status of this table entry.')
hh3cDot11CipherKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("char", 1), ("hex", 2))).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11CipherKeyType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CipherKeyType.setDescription('Represents the cipher key type of hh3cDot11CipherKey.')
hh3cDot11RadioPolicyExtTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4), )
if mibBuilder.loadTexts: hh3cDot11RadioPolicyExtTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioPolicyExtTable.setDescription("The table defines the radio policy of each radio. It can't be modified if the radio policy is a default radio policy.")
hh3cDot11RadioPolicyExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RPAPSerialID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RPRadioID"))
if mibBuilder.loadTexts: hh3cDot11RadioPolicyExtEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioPolicyExtEntry.setDescription('Each entry contains information of each radio policy.')
hh3cDot11RPAPSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127)))
if mibBuilder.loadTexts: hh3cDot11RPAPSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPAPSerialID.setDescription('This object represents the Serial ID of AP.')
hh3cDot11RPRadioID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 2), Hh3cDot11RadioScopeType())
if mibBuilder.loadTexts: hh3cDot11RPRadioID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPRadioID.setDescription('This object represents each radio.')
hh3cDot11RPBeaconInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 3), Integer32().clone(100)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPBeaconInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPBeaconInterval.setDescription('This object represents the interval for Beacon management frame.')
hh3cDot11RPDtimInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 4), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPDtimInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPDtimInterval.setDescription('This object represents the number of beacon intervals that shall elapse between transmissions of Beacons frames containing a Traffic Indication Map (TIM) element whose DTIM count field is 0. This value is transmitted in the Delivery TIM (DTIM) Period field of Beacon frames.')
hh3cDot11RPRtsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 5), Integer32().clone(2346)).setUnits('byte').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPRtsThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPRtsThreshold.setDescription('This object represents the current minimum size, in octets, of the MAC protocol data unit (MPDU), below which a Request to send/Clear to send (RTS/CTS) handshake shall not be performed.')
hh3cDot11RPFragThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 6), Integer32().clone(2346)).setUnits('byte').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPFragThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPFragThreshold.setDescription('This object represents the current maximum size, in octets, of the MPDU that may be delivered to the PHY. A MSDU shall be broken into fragments if its size exceeds the value of this attribute after adding MAC headers and trailers.')
hh3cDot11RPShortRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 7), Integer32().clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPShortRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPShortRetryThreshold.setDescription('This object represents the maximum number of transmission attempts of a frame, the length of which is less than or equal to hh3cDot11RTSThreshold, that shall be made before a failure condition is indicated.')
hh3cDot11RPLongRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 8), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPLongRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPLongRetryThreshold.setDescription('This object represents the maximum number of transmission attempts of a frame, the length of which is longer than hh3cDot11RTSThreshold, and that shall be made before a failure condition is indicated.')
hh3cDot11RPClientMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RPClientMaxCount.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RPClientMaxCount.setDescription('This object represents the maximum number of stations supported by this radio policy.')
hh3cDot11SrvPortSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5), )
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityTable.setDescription('This table defines the WLAN security status for ESS, BSS and WLAN-Ethernet interface which binding the crypto service-template. Otherwise, when binding the clear service-template, hh3cPortSecurityTables should be used to configure port security.')
hh3cDot11SrvPortSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11SecurityServicePolicyID"))
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityEntry.setDescription('There is a row in this table for service policy.')
hh3cDot11SecurityServicePolicyID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1, 1), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11SecurityServicePolicyID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecurityServicePolicyID.setDescription('Represents the ID of each service policy.')
hh3cDot11SrvPortSecurityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noRestrictions", 1), ("userLoginSecureExt", 2), ("psk", 3), ("macAddressAndPsk", 4), ("userLoginSecureExtOrPsk", 5), ("wapi", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPortSecurityMode.setDescription("Determines the security modes of the WLAN port. noRestrictions(1) The default value,no any security mode is set. userLoginSecureExt(2) Access to the port is denied until the port client is authorized (by 802.1X). psk(3) Access to the port is denied until the port client is authorized (by 802.1X key negotiation). macAddressAndPsk(4) The MAC address is first authenticated and only if this succeeds does the psk then attempt user authentication. userLoginSecureExtOrPsk(5) This selects both the userLoginSecureExt and psk modes together such that either is allowed to authorized access. Which mode works for client depends on the client's choice. wapi(6) Access to the port is denied until the port client is authenticated (by WAPI). ")
hh3cDot11SrvSecurityKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("userLoginTxKeyTypeNone", 1), ("userLoginTxKeyTypeDot11Key", 2), ("userLoginTxKeyTypeRsaRC4Key", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SrvSecurityKeyType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvSecurityKeyType.setDescription('This indicates the key type in the 802.1X EAPOL_Key packet. userLoginTxKeyTypeNone(1) This means the key type is not set yet. userLoginTxKeyTypeDot11Key(2) This selects the 802.11 key type. userLoginTxKeyTypeRsaRC4Key(3) This selects the RC4 key for RSA RC4 session encryption.')
hh3cDot11SrvSecurityPskKeyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pskKeyModeNone", 1), ("pskKeyModePassPhrase", 2), ("pskKeyModeRawKey", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SrvSecurityPskKeyMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvSecurityPskKeyMode.setDescription("This is the password input mode. When input as pskKeyModePassPhrase, hh3cDot11SrvSecurityPskKeyString must be 8 to 63 characters; when input as pskKeyModeRawKey, hh3cDot11SrvSecurityPskKeyString must be 64 characters and each character must be '0'-'9', 'a'-'f' and 'A'-'F'.")
hh3cDot11SrvSecurityPskKeyString = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SrvSecurityPskKeyString.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvSecurityPskKeyString.setDescription('This is the password string used for psk authentication.')
hh3cDot11SrvPolicyExtendTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 6), )
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtendTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtendTable.setDescription('The table defines the parameters of each service policy.')
hh3cDot11SrvPolicyExtendEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 6, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11ServicePolicyID"))
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtendEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvPolicyExtendEntry.setDescription('Each entry contains information of each service policy.')
hh3cDot11SPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SPEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SPEnable.setDescription('Represents whether the service policy is enabled.')
hh3cDot11APTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1), )
if mibBuilder.loadTexts: hh3cDot11APTemplateTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APTemplateTable.setDescription('By AP template CLI, administrator will configure the parameters of AP by convenience. Before AP boot up and connect to AC by CAPWAP tunnel, administrator will create AP template for each AP. When AP connect to AC, AC will assign configuration to AP by hh3cDot11APSerialID information in AP template.')
hh3cDot11APTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APTemplateName"))
if mibBuilder.loadTexts: hh3cDot11APTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APTemplateEntry.setDescription('Each entry contains configuration information for each AP.')
hh3cDot11APTemplateName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127)))
if mibBuilder.loadTexts: hh3cDot11APTemplateName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APTemplateName.setDescription('Represents the name of AP template.')
hh3cDot11APSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 2), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSerialID.setDescription('Represents AP serial id.')
hh3cDot11TemplateAPModelAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 3), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11TemplateAPModelAlias.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11TemplateAPModelAlias.setDescription('Represents the alias of AP model name.')
hh3cDot11Description = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 4), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11Description.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11Description.setDescription('This attribute will give more information about AP. Administrator could suggest the location, owner or other information for each AP. If the value is set to NULL, the description will be removed.')
hh3cDot11APWorkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("monitor", 2), ("hybrid", 3))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APWorkMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APWorkMode.setDescription('Represents what work mode for AP. The following values are supported: normal(1), - AP will supply WLAN service. monitor(2) - AP will be a monitor to find attack. semiMonitor(3) - AP will supply WLAN service and Device detection is enabled.')
hh3cDot11APTemplateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APTemplateRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APTemplateRowStatus.setDescription('The status of this table entry.')
hh3cDot11APName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 7), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APName.setDescription('Represents the AP name.')
hh3cDot11StatisInterv = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 8), Integer32()).setUnits('second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11StatisInterv.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StatisInterv.setDescription('Represents the interval of radio statistic.')
hh3cDot11APBroadcastProbeReply = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 9), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APBroadcastProbeReply.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APBroadcastProbeReply.setDescription("Represents enable the AP to reply broadcast probe or not. 'true' : The AP to reply broadcast probe is enabled. 'false': The AP to reply broadcast probe is disabled")
hh3cDot11StaIdleTimerInterv = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 10), Integer32()).setUnits('second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11StaIdleTimerInterv.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StaIdleTimerInterv.setDescription('Represents the interval for which the link between AP and STA ( power-save or awake ) can be idle.')
hh3cDot11StaKeepAliveTimerInterv = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 11), Integer32()).setUnits('second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11StaKeepAliveTimerInterv.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StaKeepAliveTimerInterv.setDescription('Represents the interval of the keep alive requests sent between AP and STA.')
hh3cDot11APCir = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 12), Integer32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APCir.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APCir.setDescription('Represents the committed information rate between AP and AC.')
hh3cDot11APCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 13), Integer32()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APCbs.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APCbs.setDescription('Represents the committed burst size between AP and AC.')
hh3cDot11APPriorityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APPriorityLevel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APPriorityLevel.setDescription('This object represents the connection priority for the AP. If the connection priority is 7, the AC is considered as the primary AC for the AP.')
hh3cDot11APElementID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11APElementID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APElementID.setDescription('This object represents the AP element ID.')
hh3cDot11APDevDetectEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APDevDetectEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APDevDetectEnable.setDescription("Represents whether device detection is enabled or not. 'true' : Device detection is enabled. 'false': Device detection is disabled. If device detection is enabled, the AP will provide both device detection and WLAN data services. By default, the AP only provides WLAN data services. When an AP works in monitor mode, that is, the value of object hh3cDot11APWorkMode is monitor, device detection can not be enabled with object hh3cDot11APDevDetectEnable. Device detection in normal AP mode can be enabled or disabled only when all radios of the AP are disabled.")
hh3cDot11APGetIPMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dhcpAlloc", 1), ("static", 2))).clone('dhcpAlloc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APGetIPMethod.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APGetIPMethod.setDescription('This object represents the method how AP gets IP address.')
hh3cDot11StatisIntervMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("realtime", 2))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11StatisIntervMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11StatisIntervMode.setDescription('This object represents the mode of statics interval. normal(1) - statics interval value between 10s to 120s realtime(2) - statics interval value between 2s to 5s')
hh3cDot11RadioToConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2), )
if mibBuilder.loadTexts: hh3cDot11RadioToConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioToConfigTable.setDescription('Before AP connects to AC, administrator will configure radio parameter to each radio.')
hh3cDot11RadioToConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APTemplateNameCfg"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11CfgRadioID"))
if mibBuilder.loadTexts: hh3cDot11RadioToConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioToConfigEntry.setDescription('Each entry contains configuration information for each radio.')
hh3cDot11APTemplateNameCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127)))
if mibBuilder.loadTexts: hh3cDot11APTemplateNameCfg.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APTemplateNameCfg.setDescription('Represents the name of AP template.')
hh3cDot11CfgRadioID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 2), Hh3cDot11RadioScopeType())
if mibBuilder.loadTexts: hh3cDot11CfgRadioID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRadioID.setDescription('Represents each radio.')
hh3cDot11CfgRadioPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgRadioPolicyName.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRadioPolicyName.setDescription('Represents the name of radio policy.')
hh3cDot11CfgRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 4), Hh3cDot11RadioType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgRadioType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRadioType.setDescription('Represents the radio will work with which 802.11 radio type.')
hh3cDot11CfgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 5), Hh3cDot11ChannelScopeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgChannel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgChannel.setDescription('Represents the channel allocation of radio.')
hh3cDot11CfgMaxTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 6), Hh3cDot11TxPwrLevelScopeType()).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgMaxTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgMaxTxPowerLevel.setDescription('Represents the maximal transmit power scope for AP.')
hh3cDot11PreambleLen = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 7), Hh3cDot11PreambleType().clone('short')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11PreambleLen.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PreambleLen.setDescription('Represents whether use long or short preamble for 802.11 MAC frame. When hh3cDot11CfgRadioType is either dot11b or dot11g, then value for hh3cDot11PreambleLen will be valid. Othh3cise, the value for it will be invalid.')
hh3cDot11CfgRadioStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgRadioStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRadioStatus.setDescription('Represents the radio admin status whether is enabled or disabled.')
hh3cDot11CfgRdElementID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11CfgRdElementID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRdElementID.setDescription('Represents the element ID of this radio. It comprises two parts. The highest 24 bits are AP element ID and the lowest 8 bits are radio ID.')
hh3cDot11CfgWorkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 10), Hh3cDot11WorkMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgWorkMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgWorkMode.setDescription('Represents work mode of the radio.')
hh3cDot11CfgPwrAttValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgPwrAttValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgPwrAttValue.setDescription('Represents the value of power attenuation.')
hh3cDot11RadioTxArithmetic = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("quality", 1), ("bandwidth", 2))).clone('quality')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioTxArithmetic.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioTxArithmetic.setDescription('Represents the transmission arithmetic of the radio. The following values are supported: quality(1) - Consider the quality first during the transmission. bandwidth(2) - Consider the bandwidth first during the transmission.')
hh3cDot11CfgChannelLockStat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unlocked", 1), ("locked", 2))).clone('unlocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgChannelLockStat.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgChannelLockStat.setDescription('Represents locked status of channel on the radio.')
hh3cDot11CfgPowerLockStat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unlocked", 1), ("locked", 2))).clone('unlocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgPowerLockStat.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgPowerLockStat.setDescription('Represents locked status of power on the radio.')
hh3cDot11CfgLBRdGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 15), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgLBRdGroupId.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgLBRdGroupId.setDescription('Represents the load balance group ID allocated for the radio.')
hh3cDot11CfgRRMSDRdGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 2, 1, 16), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11CfgRRMSDRdGroupId.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgRRMSDRdGroupId.setDescription('Represents the RRM self-decisive group ID allocated for the radio.')
hh3cDot11APServiceSetTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 3), )
if mibBuilder.loadTexts: hh3cDot11APServiceSetTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceSetTable.setDescription('For each radio, it could configure multiple service policies. The table describes the relationship between radio and service policies.')
hh3cDot11APServiceSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 3, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APTemplateNameCfg"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11CfgRadioID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11CfgServicePolicyID"))
if mibBuilder.loadTexts: hh3cDot11APServiceSetEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceSetEntry.setDescription('Each entry contains service policy information for each specific radio of AP.')
hh3cDot11CfgServicePolicyID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 3, 1, 1), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11CfgServicePolicyID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgServicePolicyID.setDescription('Represents the ID of each service policy used by the AP.')
hh3cDot11SrvSetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11SrvSetRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SrvSetRowStatus.setDescription('The status of this table entry.')
hh3cDot11ServiceSetVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11ServiceSetVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ServiceSetVlanId.setDescription('Represents the Vlan ID of BSS which is generated when service policy is binded with the Radio.')
hh3cDot11APSTVlanTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 11), )
if mibBuilder.loadTexts: hh3cDot11APSTVlanTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSTVlanTable.setDescription('For each service policy, it could be bind to several VLANs. The table describes the relationship between VLAN and service policies.')
hh3cDot11APSTVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 11, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11SIDAPSerialID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11CfgRadioID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11CfgServicePolicyID"))
if mibBuilder.loadTexts: hh3cDot11APSTVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSTVlanEntry.setDescription('Each entry contains VLAN and service policy information for each specific radio of AP.')
hh3cDot11CfgSTVLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11CfgSTVLANID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgSTVLANID.setDescription('Represents the VLAN that current Service Policy have bind to.')
hh3cDot11CfgSTNASPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11CfgSTNASPortID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgSTNASPortID.setDescription('Represents the NAS Port ID of current Service Policy for each specific radio of AP.')
hh3cDot11CfgServiceSetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 11, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11CfgServiceSetRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgServiceSetRowStatus.setDescription('The status of this table entry.')
hh3cDot11APSysInfoSetTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 4), )
if mibBuilder.loadTexts: hh3cDot11APSysInfoSetTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSysInfoSetTable.setDescription('The table of the system information for each AP.')
hh3cDot11APSysInfoSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 4, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11SIDAPSerialID"))
if mibBuilder.loadTexts: hh3cDot11APSysInfoSetEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSysInfoSetEntry.setDescription('The system information configuration for each AP.')
hh3cDot11APSysNetID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APSysNetID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSysNetID.setDescription('Represents the system Net ID for AP.')
hh3cDot11APCpuUsageThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('onepercent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APCpuUsageThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APCpuUsageThreshold.setDescription('The CPU usage threshold for AP.')
hh3cDot11APMemUsageThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('onepercent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APMemUsageThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APMemUsageThreshold.setDescription('The memory usage threshold for AP.')
hh3cDot11APLimitTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 5), )
if mibBuilder.loadTexts: hh3cDot11APLimitTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APLimitTable.setDescription('For each connected APs, administrator could configure a series of limits. This table describes the limit information for AP(s).')
hh3cDot11APLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 5, 1), ).setIndexNames((0, "HH3C-DOT11-REF-MIB", "hh3cDot11APElementIndex"))
if mibBuilder.loadTexts: hh3cDot11APLimitEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APLimitEntry.setDescription('Each entry contains the limit information for each AP.')
hh3cDot11APSsidNumLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APSsidNumLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSsidNumLimit.setDescription('Represents the upper limit of service template binded with this AP. All radios of AP share this limit. Default value 0 : There is no upper limit of service template binded with this AP.')
hh3cDot11APUserCntLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APUserCntLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APUserCntLimit.setDescription('Represents the upper limit of user which has access to this AP. All BSSs binded with AP share this limit. Default value 0 : There is no upper limit of user which has access to this AP.')
hh3cDot11APUserThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APUserThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APUserThreshold.setDescription('Represents the threshold of user which has access to this AP. All BSSs binded with AP share this limit. If the user counter is overflow, the trap will be sent. Default value 0 : There is no threshold of user which has access to this AP.')
hh3cDot11APIfSetTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 6), )
if mibBuilder.loadTexts: hh3cDot11APIfSetTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APIfSetTable.setDescription('The table of the interface information for each AP.')
hh3cDot11APIfSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 6, 1), ).setIndexNames((0, "HH3C-DOT11-REF-MIB", "hh3cDot11APElementIndex"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APSetIfIndex"))
if mibBuilder.loadTexts: hh3cDot11APIfSetEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APIfSetEntry.setDescription('The interface information configuration for each AP.')
hh3cDot11APSetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11APSetIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSetIfIndex.setDescription('Represents the index for a interface.')
hh3cDot11APIfAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 6, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11APIfAlias.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APIfAlias.setDescription("This object is an 'alias' name for the interface as specified by a network manager for AP.")
hh3cDot11APServiceVlanTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7), )
if mibBuilder.loadTexts: hh3cDot11APServiceVlanTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanTable.setDescription('For all the radios on the AP, it could configure multiple service policies. The table describes the relationship between AP and service policies.')
hh3cDot11APServiceVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APServiceVlanSerialID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11APServiceVlanSPID"))
if mibBuilder.loadTexts: hh3cDot11APServiceVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanEntry.setDescription('Each entry contains service policy information for each AP.')
hh3cDot11APServiceVlanSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7, 1, 1), OctetString())
if mibBuilder.loadTexts: hh3cDot11APServiceVlanSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanSerialID.setDescription('This object represents AP serial id.')
hh3cDot11APServiceVlanSPID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7, 1, 2), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11APServiceVlanSPID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanSPID.setDescription('This object represents the ID of each service policy used by the AP.')
hh3cDot11APServiceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APServiceVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanId.setDescription('This object represents the VLAN ID of BSS which is generated when the service policy is bound to the radio.')
hh3cDot11APServiceVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11APServiceVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APServiceVlanRowStatus.setDescription('This object represents the status of this table entry.')
hh3cDot11RadioConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8), )
if mibBuilder.loadTexts: hh3cDot11RadioConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioConfigTable.setDescription('Before AP connects to AC, administrator will configure radio parameter to each radio.')
hh3cDot11RadioConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RCAPSerialID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RCRadioID"))
if mibBuilder.loadTexts: hh3cDot11RadioConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioConfigEntry.setDescription('Each entry contains configuration information for each radio.')
hh3cDot11RCAPSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127)))
if mibBuilder.loadTexts: hh3cDot11RCAPSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCAPSerialID.setDescription('This object represents the Serial ID of AP.')
hh3cDot11RCRadioID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 2), Hh3cDot11RadioScopeType())
if mibBuilder.loadTexts: hh3cDot11RCRadioID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCRadioID.setDescription('This object represents each radio.')
hh3cDot11RCRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 3), Hh3cDot11RadioType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCRadioType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCRadioType.setDescription('This object represents the radio will work with which 802.11 radio type.')
hh3cDot11RCChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 4), Hh3cDot11ChannelScopeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCChannel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCChannel.setDescription('This object represents the channel allocation of radio.')
hh3cDot11RCPreambleLen = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 5), Hh3cDot11PreambleType().clone('short')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCPreambleLen.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCPreambleLen.setDescription('This object represents whether use long or short preamble for 802.11 MAC frame. When hh3cDot11CfgRadioType is either dot11b or dot11g, then value for hh3cDot11PreambleLen will be valid. Otherwise, the value for it will be invalid.')
hh3cDot11RCPwrAttValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCPwrAttValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCPwrAttValue.setDescription('This object represents the value of power attenuation.')
hh3cDot11RCApPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 7), Hh3cDot11TxPwrLevelScopeType()).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCApPowerLevel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCApPowerLevel.setDescription('Represents the maximal transmit power scope for AP.')
hh3cDot11RCDynamicChlState = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCDynamicChlState.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCDynamicChlState.setDescription('Enable/Disable dynamic channel selection.')
hh3cDot11RCDynamicPowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCDynamicPowerState.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCDynamicPowerState.setDescription('Enable/Disable dynamic power selection for the band.')
hh3cDot11RCRadioStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 8, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RCRadioStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RCRadioStatus.setDescription('Represents the radio admin status whether is enabled or disabled.')
hh3cDot11RadioSSIDCfgTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9), )
if mibBuilder.loadTexts: hh3cDot11RadioSSIDCfgTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDCfgTable.setDescription('For each radio, it could configure multiple service policies. The table describes the relationship between radio and service policies.')
hh3cDot11RadioSSIDCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioSSIDSerialID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioSSIDRadioID"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioSSIDWLANID"))
if mibBuilder.loadTexts: hh3cDot11RadioSSIDCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDCfgEntry.setDescription('Each entry contains SSID configuration information for each radio.')
hh3cDot11RadioSSIDSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 1), Hh3cDot11ObjectIDType())
if mibBuilder.loadTexts: hh3cDot11RadioSSIDSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDSerialID.setDescription('This object represents the serial ID of AP.')
hh3cDot11RadioSSIDRadioID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 2), Hh3cDot11RadioScopeType())
if mibBuilder.loadTexts: hh3cDot11RadioSSIDRadioID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDRadioID.setDescription('This object represents each radio.')
hh3cDot11RadioSSIDWLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 3), Integer32())
if mibBuilder.loadTexts: hh3cDot11RadioSSIDWLANID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDWLANID.setDescription('This object represents the WLAN ID of the BSSID.')
hh3cDot11RadioSSIDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 4), Hh3cDot11ServicePolicyIDType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RadioSSIDIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDIndex.setDescription('This object represents the ID of each service policy used by the radio.')
hh3cDot11RadioBSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11RadioBSSID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioBSSID.setDescription('As MAC address format, it is used to identify BSS.')
hh3cDot11RadioSSIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 9, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RadioSSIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioSSIDRowStatus.setDescription('RowStatus.')
hh3cDot11APSerialIDTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 10), )
if mibBuilder.loadTexts: hh3cDot11APSerialIDTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSerialIDTable.setDescription('The table will provide the general information about APs.')
hh3cDot11APSerialIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 10, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11SIDAPSerialID"))
if mibBuilder.loadTexts: hh3cDot11APSerialIDEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11APSerialIDEntry.setDescription('Each entry contains the general information of an AP.')
hh3cDot11SIDAPSerialID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 10, 1, 1), OctetString())
if mibBuilder.loadTexts: hh3cDot11SIDAPSerialID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SIDAPSerialID.setDescription('Represents AP serial id.')
hh3cDot11SIDAPWorkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("monitor", 2), ("hybrid", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SIDAPWorkMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SIDAPWorkMode.setDescription('Represents what work mode for AP. The following values are supported: normal(1), - AP will supply WLAN service. monitor(2) - AP will be a monitor to find attack. hybrid(3) - AP will supply WLAN service and Device detection is enabled.')
hh3cDot11SIDAPGetIPMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dhcpAlloc", 1), ("static", 2))).clone('dhcpAlloc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SIDAPGetIPMethod.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SIDAPGetIPMethod.setDescription('This object represents the method how AP gets IP address.')
hh3cDot11RadioIntfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1), )
if mibBuilder.loadTexts: hh3cDot11RadioIntfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfConfigTable.setDescription('The table defines the parameters for radio in AP, as per radio.')
hh3cDot11RadioIntfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioIfIdx"))
if mibBuilder.loadTexts: hh3cDot11RadioIntfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfConfigEntry.setDescription('Each entry contains information of each radio in AP.')
hh3cDot11RadioIfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11RadioIfIdx.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIfIdx.setDescription('Represents the Radio IfIndex of radio in AP.')
hh3cDot11RadioCfgBeaconIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 2), Integer32().clone(100)).setUnits('TU').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgBeaconIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgBeaconIntvl.setDescription('Represents the interval for Beacon management frame.')
hh3cDot11RadioCfgDtimIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 3), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgDtimIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgDtimIntvl.setDescription('Represents the number of beacon intervals that shall elapse between transmission of Beacons frames containing a Traffic Indication Map (TIM) element whose DTIM Count field is 0. This value is transmitted in the Delivery TIM (DTIM) Period field of Beacon frames.')
hh3cDot11RadioCfgRtsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 4), Integer32().clone(2346)).setUnits('Byte').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgRtsThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgRtsThreshold.setDescription('Represents the current minimum size,in octets,of the MAC protocol data unit (MPDU), below which a Request to send/Clear to send (RTS/CTS) handshake shall not be performed.')
hh3cDot11RadioCfgFragThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 5), Integer32().clone(2346)).setUnits('Byte').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgFragThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgFragThreshold.setDescription('Represents the current maximum size, in octets, of the MPDU that may be delivered to the PHY. A MSDU shall be broken into fragments if its size exceeds the value of this attribute after adding MAC headers and trailers.')
hh3cDot11RadioCfgShtRetryThld = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 6), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgShtRetryThld.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgShtRetryThld.setDescription('Represents the maximum number of transmission attempts of a frame, the length of which is less than or equal to hh3cDot11RadioRTSThreshold, that shall be made before a failure condition is indicated.')
hh3cDot11RadioCfglongRtrThld = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 7), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfglongRtrThld.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfglongRtrThld.setDescription('Represents the maximum number of transmission attempts of a frame, the length of which is longer than hh3cDot11RadioRTSThreshold, that shall be made before a failure condition is indicated.')
hh3cDot11RadioCfgMaxRxLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 8), Unsigned32().clone(2000)).setUnits('millisecond').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgMaxRxLifetime.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgMaxRxLifetime.setDescription('Represents the elapsed time. After the time specified by hh3cDot11RadioCfgMaxRxLifetime, the further attempts to reassemble the MSDU shall be terminated.')
hh3cDot11RadioCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 9), Hh3cDot11RadioType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgType.setDescription('Represents the radio will work with which 802.11 radio type.')
hh3cDot11RadioCfgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 10), Hh3cDot11ChannelScopeType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgChannel.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgChannel.setDescription('Represents the channel allocation of radio.')
hh3cDot11RadioCfgMaxTxPwrLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 11), Hh3cDot11TxPwrLevelScopeType()).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgMaxTxPwrLvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgMaxTxPwrLvl.setDescription('Represents the maximal transmit power scope for AP.')
hh3cDot11RadioCfgPreambleLen = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 12), Hh3cDot11PreambleType().clone('short')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgPreambleLen.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgPreambleLen.setDescription('Represents whether use long or short preamble for 802.11 MAC frame.')
hh3cDot11RadioCfgWorkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 13), Hh3cDot11WorkMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgWorkMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgWorkMode.setDescription('Represents work mode of the radio.')
hh3cDot11RadioCfgOnly11gEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioCfgOnly11gEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioCfgOnly11gEnable.setDescription("Represents whether enable only 802.11g radio mode or not. 'true' : Only 802.11g radio mode is enabled. 'false': Only 802.11g radio mode is disabled.")
hh3cDot11RadioIntfBindTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 2), )
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindTable.setDescription('The table defines the binding information for each radio in AP. ')
hh3cDot11RadioIntfBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 2, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioIfIdx"), (0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioIntfBindSvcPlcyID"))
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindEntry.setDescription('Each entry contains the radio interface binding information in AP.')
hh3cDot11RadioIntfBindSvcPlcyID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 2, 1, 1), Hh3cDot11ServicePolicyIDType())
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindSvcPlcyID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindSvcPlcyID.setDescription('Represents the ID of each service policy.')
hh3cDot11RadioIntfBindIfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 2, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindIfIdx.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindIfIdx.setDescription('Represents the Ifindex of interface which is binded to the radio.')
hh3cDot11RadioIntfBindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 4, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioIntfBindRowStatus.setDescription('The status of this table entry.')
hh3cDot11DataRateConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1), )
if mibBuilder.loadTexts: hh3cDot11DataRateConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11DataRateConfigTable.setDescription('Table will provide data rate configuration for a specific radio type.')
hh3cDot11DataRateConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioTypeID"))
if mibBuilder.loadTexts: hh3cDot11DataRateConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11DataRateConfigEntry.setDescription('Each entry of the table will provide data rate configuration for a specific radio type.')
hh3cDot11RadioTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1, 1), Hh3cDot11RadioType())
if mibBuilder.loadTexts: hh3cDot11RadioTypeID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioTypeID.setDescription('Represents the radio type.')
hh3cDot11SupportedRateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SupportedRateSet.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SupportedRateSet.setDescription('Represents the supported rate set of a particular radio type.')
hh3cDot11MandatoryRateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11MandatoryRateSet.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11MandatoryRateSet.setDescription('Represents the mandatory rate set of a particular radio type.')
hh3cDot11DisabledRateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11DisabledRateSet.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11DisabledRateSet.setDescription('Represents the disabled rate set of a particular radio type.')
hh3cDot11SmartRateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SmartRateSet.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SmartRateSet.setDescription('Represents the rate set of a particular radio type.')
hh3cDot11WlanEssIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 1), )
if mibBuilder.loadTexts: hh3cDot11WlanEssIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEssIfTable.setDescription('This table is used to configure WLAN ESS interface.')
hh3cDot11WlanEssIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 1, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11WlanEssIfNumber"))
if mibBuilder.loadTexts: hh3cDot11WlanEssIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEssIfEntry.setDescription('Each entry contains the WLAN ESS interface configuration.')
hh3cDot11WlanEssIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11WlanEssIfNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEssIfNumber.setDescription('This node represents the WLAN ESS interface number.')
hh3cDot11WlanEssIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11WlanEssIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEssIfIndex.setDescription('This node represents the ifIndex of WLAN-ESS interface.')
hh3cDot11WlanEssRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanEssRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEssRowStatus.setDescription('This node represents the WLAN ESS interface row status.')
hh3cDot11WlanBssIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 2), )
if mibBuilder.loadTexts: hh3cDot11WlanBssIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanBssIfTable.setDescription('This table is used to configure WLAN BSS interface.')
hh3cDot11WlanBssIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 2, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11WlanBssIfNumber"))
if mibBuilder.loadTexts: hh3cDot11WlanBssIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanBssIfEntry.setDescription('Each entry contains the WLAN BSS interface configuration.')
hh3cDot11WlanBssIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11WlanBssIfNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanBssIfNumber.setDescription('This node represents the WLAN BSS interface number.')
hh3cDot11WlanBssIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11WlanBssIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanBssIfIndex.setDescription('This node represents the ifIndex of WLAN-BSS interface.')
hh3cDot11WlanBssRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanBssRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanBssRowStatus.setDescription('This node represents the WLAN BSS interface row status.')
hh3cDot11WLANEthernetIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 3), )
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfTable.setDescription('This table is used to configure WLAN Ethernet interface.')
hh3cDot11WLANEthernetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 3, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11WlanEthernetIfNumber"))
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfEntry.setDescription('Each entry contains the WLAN Ethernet interface configuration.')
hh3cDot11WlanEthernetIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11WlanEthernetIfNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEthernetIfNumber.setDescription('This node represents the WLAN Ethernet interface number.')
hh3cDot11WLANEthernetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WLANEthernetIfIndex.setDescription('This node represents the ifIndex of WLAN-Ethernet interface.')
hh3cDot11WlanEthernetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanEthernetRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanEthernetRowStatus.setDescription('This node represents the Wlan Ethernet interface row status.')
hh3cDot11PortSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4), )
if mibBuilder.loadTexts: hh3cDot11PortSecurityTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PortSecurityTable.setDescription('This table defines the WLAN security status for ESS, BSS, mesh and WLAN-Ethernet interface which binding the crypto service-template. Otherwise, when binding the clear service-template, hh3cPortSecurityTables should be used to configure port security.')
hh3cDot11PortSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDot11PortSecurityEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PortSecurityEntry.setDescription('There is a row in this table for each ESS, BSS and WLAN-Ethernet interface.It is indexed using the object ifIndex in RFC1213-MIB.')
hh3cDot11PortSecurityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noRestrictions", 1), ("userLoginSecureExt", 2), ("psk", 3), ("macAddressAndPsk", 4), ("userLoginSecureExtOrPsk", 5), ("wapi", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11PortSecurityMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PortSecurityMode.setDescription("Determines the security modes of the WLAN port. noRestrictions(1) The default value,no any security mode is set. userLoginSecureExt(2) Access to the port is denied until the port client is authorized (by 802.1X). psk(3) Access to the port is denied until the port client is authorized (by 802.1X key negotiation). macAddressAndPsk(4) The MAC address is first authenticated and only if this succeeds does the psk then attempt user authentication. userLoginSecureExtOrPsk(5) This selects both the userLoginSecureExt and psk modes together such that either is allowed to authorized access. Which mode works for client depends on the client's choice. wapi(6) Access to the port is denied until the port client is authenticated (by WAPI). ")
hh3cDot11SecurityUserLoginTxKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("userLoginTxKeyTypeNone", 1), ("userLoginTxKeyTypeDot11Key", 2), ("userLoginTxKeyTypeRsaRC4Key", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SecurityUserLoginTxKeyType.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecurityUserLoginTxKeyType.setDescription('This indicates the key type in the 802.1X EAPOL_Key packet. userLoginTxKeyTypeNone(1) This means the key type is not set yet. userLoginTxKeyTypeDot11Key(2) This selects the 802.11 key type. userLoginTxKeyTypeRsaRC4Key(3) This selects the RC4 key for RSA RC4 session encryption.')
hh3cDot11SecurityPskKeyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pskKeyModeNone", 1), ("pskKeyModePassPhrase", 2), ("pskKeyModeRawKey", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SecurityPskKeyMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecurityPskKeyMode.setDescription("This is the password input mode. When input as pskKeyModePassPhrase, hh3cDot11SecurePskKeyString must be 8 to 63 characters; when input as pskKeyModeRawKey, hh3cDot11SecurePskKeyString must be 64 characters and each character must be '0'-'9', 'a'-'f' and 'A'-'F'.")
hh3cDot11SecurityPskKeyString = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11SecurityPskKeyString.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SecurityPskKeyString.setDescription('This is the password string used for psk authentication.')
hh3cDot11WlanMeshIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 5), )
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfTable.setDescription('This table is used to configure WLAN mesh interface.')
hh3cDot11WlanMeshIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 5, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11WlanMeshIfNumber"))
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfEntry.setDescription('Each entry contains the WLAN mesh interface configuration.')
hh3cDot11WlanMeshIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfNumber.setDescription('This node represents the WLAN mesh interface number.')
hh3cDot11WlanMeshIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanMeshIfIndex.setDescription('This node represents the index of WLAN mesh interface.')
hh3cDot11WlanMeshRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 6, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDot11WlanMeshRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WlanMeshRowStatus.setDescription('This node represents the WLAN mesh interface row status.')
hh3cDot11BackupACAdrssIP = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 7, 1), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11BackupACAdrssIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11BackupACAdrssIP.setDescription('This object represents the backup AC IP address. If the backup AC IP address is not configured, the object value is 0.0.0.0.')
hh3cDot11BackupACAdrssIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 7, 2), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11BackupACAdrssIPv6.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11BackupACAdrssIPv6.setDescription('This object represents the backup AC IPv6 address. If the backup AC IPv6 address is not configured, the object value is 0::0.')
hh3cDot11nRadioCfgTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1), )
if mibBuilder.loadTexts: hh3cDot11nRadioCfgTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nRadioCfgTable.setDescription('This table is used to configure dot11n on the radio.')
hh3cDot11nRadioCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11nRadioCfgIndex"))
if mibBuilder.loadTexts: hh3cDot11nRadioCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nRadioCfgEntry.setDescription('This entry contains the dot11n configuration on the radio.')
hh3cDot11nRadioCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 1), Hh3cDot11RadioElementIndex())
if mibBuilder.loadTexts: hh3cDot11nRadioCfgIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nRadioCfgIndex.setDescription('Represents index of the radio.')
hh3cDot11nAMpduEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11nAMpduEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nAMpduEnable.setDescription('Enable the function of A-MPDU.')
hh3cDot11nAMsduEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11nAMsduEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nAMsduEnable.setDescription('Enable the function of A-MSDU.')
hh3cDot11nClientDot11nOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11nClientDot11nOnly.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nClientDot11nOnly.setDescription('Only permit clients of 11n mode.')
hh3cDot11nChanelBand = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode20", 1), ("mode40", 2))).clone('mode40')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11nChanelBand.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nChanelBand.setDescription('Specify the bandwidth mode.')
hh3cDot11nShortGiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11nShortGiEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11nShortGiEnable.setDescription('The function of Short GI.')
hh3cDot11RadioWDSTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2), )
if mibBuilder.loadTexts: hh3cDot11RadioWDSTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioWDSTable.setDescription('This table is used to configure WDS on the radio.')
hh3cDot11RadioWDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1), ).setIndexNames((0, "HH3C-DOT11-CFG-MIB", "hh3cDot11RadioWDSIndex"))
if mibBuilder.loadTexts: hh3cDot11RadioWDSEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioWDSEntry.setDescription('Each entry contains the WDS configuration on the radio.')
hh3cDot11RadioWDSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1, 1), Hh3cDot11RadioElementIndex())
if mibBuilder.loadTexts: hh3cDot11RadioWDSIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioWDSIndex.setDescription('Represents the element index of radio.')
hh3cDot11RadioWDSMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nowds", 1), ("wds", 2))).clone('nowds')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioWDSMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioWDSMode.setDescription('Represents enable the WDS mode or not. nowds: The WDS mode is disabled. wds : The WDS mode is enabled')
hh3cDot11RadioWDSNetWorkID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11RadioWDSNetWorkID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11RadioWDSNetWorkID.setDescription('Represents the mesh ID of WDS.')
hh3cDot11WDSSecPskKeyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pskKeyModeNone", 1), ("pskKeyModePassPhrase", 2), ("pskKeyModeRawKey", 3))).clone('pskKeyModeNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11WDSSecPskKeyMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WDSSecPskKeyMode.setDescription('Represents the PSK mode of WDS.')
hh3cDot11WDSSecPskKeyString = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 8, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDot11WDSSecPskKeyString.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11WDSSecPskKeyString.setDescription('Represents the PSK value of WDS.')
hh3cDot11CfgNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 0))
hh3cDot11CfgCipherChange = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 0, 1)).setObjects(("HH3C-DOT11-CFG-MIB", "hh3cDot11SSIDName"), ("HH3C-DOT11-CFG-MIB", "hh3cDot11SecurityCiphers"))
if mibBuilder.loadTexts: hh3cDot11CfgCipherChange.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgCipherChange.setDescription('This notification is sent when cipher type of corresponding service template is changed.')
hh3cDot11CfgPSKChange = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 0, 2)).setObjects(("HH3C-DOT11-CFG-MIB", "hh3cDot11SSIDName"))
if mibBuilder.loadTexts: hh3cDot11CfgPSKChange.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CfgPSKChange.setDescription('This notification is sent when pre-shared key of corresponding service template is changed.')
hh3cDot11SSIDWepIDConflictTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 0, 3)).setObjects(("HH3C-DOT11-CFG-MIB", "hh3cDot11PreConflictTemplateNum"), ("HH3C-DOT11-CFG-MIB", "hh3cDot11CurrConflictTemplateNum"), ("HH3C-DOT11-CFG-MIB", "hh3cDot11ConflictCipherIdx"), ("HH3C-DOT11-CFG-MIB", "hh3cDot11ConfigureAPID"), ("HH3C-DOT11-CFG-MIB", "hh3cDot11ConfigureRadioID"))
if mibBuilder.loadTexts: hh3cDot11SSIDWepIDConflictTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11SSIDWepIDConflictTrap.setDescription('This notification will be sent when the same wep ID is configured on two service policies.')
hh3cDot11CfgTrapVarObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1))
hh3cDot11PreConflictTemplateNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDot11PreConflictTemplateNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11PreConflictTemplateNum.setDescription('Represents previous service policy ID when radio bind service policy and current service policy conflict with previous service policy in cipher configuration.')
hh3cDot11CurrConflictTemplateNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDot11CurrConflictTemplateNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11CurrConflictTemplateNum.setDescription('Represents current service policy ID when radio bind service policy and current service policy conflict with previous service policy in cipher configuration.')
hh3cDot11ConflictCipherIdx = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDot11ConflictCipherIdx.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ConflictCipherIdx.setDescription('Represents wep ID that conflicted with.')
hh3cDot11ConfigureAPID = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1, 4), Hh3cDot11ObjectIDType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDot11ConfigureAPID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ConfigureAPID.setDescription('Represents which AP is configured.')
hh3cDot11ConfigureRadioID = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 75, 4, 9, 1, 5), Hh3cDot11RadioScopeType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDot11ConfigureRadioID.setStatus('current')
if mibBuilder.loadTexts: hh3cDot11ConfigureRadioID.setDescription('Represents which radio in AP is configured.')
mibBuilder.exportSymbols("HH3C-DOT11-CFG-MIB", hh3cDot11WlanMeshIfEntry=hh3cDot11WlanMeshIfEntry, hh3cDot11SSIDEncryptionMode=hh3cDot11SSIDEncryptionMode, hh3cDot11SPOutCirValue=hh3cDot11SPOutCirValue, hh3cDot11WLANEthernetIfTable=hh3cDot11WLANEthernetIfTable, hh3cDot11SPInCirMode=hh3cDot11SPInCirMode, hh3cDot11APUserUplimit=hh3cDot11APUserUplimit, hh3cDot11ServicePolicyExtTable=hh3cDot11ServicePolicyExtTable, hh3cDot11PortSecurityMode=hh3cDot11PortSecurityMode, hh3cDot11APDevDetectEnable=hh3cDot11APDevDetectEnable, hh3cDot11RadioCfgBeaconIntvl=hh3cDot11RadioCfgBeaconIntvl, hh3cDot11PortSecurityTable=hh3cDot11PortSecurityTable, hh3cDot11WlanEssIfTable=hh3cDot11WlanEssIfTable, hh3cDot11APL2IsolateEnable=hh3cDot11APL2IsolateEnable, hh3cDot11CfgServiceSetRowStatus=hh3cDot11CfgServiceSetRowStatus, hh3cDot11APServiceVlanId=hh3cDot11APServiceVlanId, hh3cDot11RCRadioType=hh3cDot11RCRadioType, hh3cDot11GlobalCountryCode=hh3cDot11GlobalCountryCode, hh3cDot11SrvPortSecurityMode=hh3cDot11SrvPortSecurityMode, hh3cDot11ServiceSetVlanId=hh3cDot11ServiceSetVlanId, hh3cDot11APSTVlanTable=hh3cDot11APSTVlanTable, hh3cDot11RadioIntfConfigEntry=hh3cDot11RadioIntfConfigEntry, hh3cDot11ConflictCipherIdx=hh3cDot11ConflictCipherIdx, hh3cDot11ServicePolicyTable=hh3cDot11ServicePolicyTable, hh3cDot11WlanInfPVID=hh3cDot11WlanInfPVID, hh3cDot11CfgNotifyGroup=hh3cDot11CfgNotifyGroup, hh3cDot11BeaconIntervalMs=hh3cDot11BeaconIntervalMs, hh3cDot11APCir=hh3cDot11APCir, hh3cDot11InterfaceConfigGroup=hh3cDot11InterfaceConfigGroup, hh3cDot11RCApPowerLevel=hh3cDot11RCApPowerLevel, hh3cDot11RadioSSIDCfgEntry=hh3cDot11RadioSSIDCfgEntry, hh3cDot11SIDAPSerialID=hh3cDot11SIDAPSerialID, hh3cDot11RadioCfgFragThreshold=hh3cDot11RadioCfgFragThreshold, hh3cDot11APScanMode=hh3cDot11APScanMode, hh3cDot11DtimInterval=hh3cDot11DtimInterval, hh3cDot11CfgNotifications=hh3cDot11CfgNotifications, hh3cDot11SSIDWepIDConflictTrap=hh3cDot11SSIDWepIDConflictTrap, hh3cDot11RadioBSSID=hh3cDot11RadioBSSID, hh3cDot11RPRadioID=hh3cDot11RPRadioID, hh3cDot11ACCtrlTunnelSecSupport=hh3cDot11ACCtrlTunnelSecSupport, hh3cDot11BeaconInterval=hh3cDot11BeaconInterval, hh3cDot11MaxRxLifetime=hh3cDot11MaxRxLifetime, hh3cDot11APBroadcastProbeReply=hh3cDot11APBroadcastProbeReply, hh3cDot11RCDynamicChlState=hh3cDot11RCDynamicChlState, hh3cDot11APSerialIDEntry=hh3cDot11APSerialIDEntry, hh3cDot11RdoPolicyRowStatus=hh3cDot11RdoPolicyRowStatus, hh3cDot11DataRateConfigEntry=hh3cDot11DataRateConfigEntry, hh3cDot11ShortRetryThreshold=hh3cDot11ShortRetryThreshold, hh3cDot11APServiceVlanRowStatus=hh3cDot11APServiceVlanRowStatus, hh3cDot11AdjIntfTrapThreshold=hh3cDot11AdjIntfTrapThreshold, hh3cDot11ConfigureAPID=hh3cDot11ConfigureAPID, hh3cDot11SPOutCirStaticValue=hh3cDot11SPOutCirStaticValue, hh3cDot11CfgRadioPolicyName=hh3cDot11CfgRadioPolicyName, hh3cDot11CfgRdElementID=hh3cDot11CfgRdElementID, hh3cDot11WlanEthernetRowStatus=hh3cDot11WlanEthernetRowStatus, hh3cDot11RadioTypeID=hh3cDot11RadioTypeID, hh3cDot11CfgRRMSDRdGroupId=hh3cDot11CfgRRMSDRdGroupId, hh3cDot11SSIDName=hh3cDot11SSIDName, hh3cDot11APServiceVlanEntry=hh3cDot11APServiceVlanEntry, hh3cDot11RadioCfgShtRetryThld=hh3cDot11RadioCfgShtRetryThld, hh3cDot11RPLongRetryThreshold=hh3cDot11RPLongRetryThreshold, hh3cDot11WDSSecPskKeyMode=hh3cDot11WDSSecPskKeyMode, hh3cDot11RadioTxArithmetic=hh3cDot11RadioTxArithmetic, PYSNMP_MODULE_ID=hh3cDot11CFG, hh3cDot11RadioConfigEntry=hh3cDot11RadioConfigEntry, hh3cDot11RCDynamicPowerState=hh3cDot11RCDynamicPowerState, hh3cDot11RadioCfgWorkMode=hh3cDot11RadioCfgWorkMode, hh3cDot11CfgPSKChange=hh3cDot11CfgPSKChange, hh3cDot11SrvPortSecurityTable=hh3cDot11SrvPortSecurityTable, hh3cDot11RtsThreshold=hh3cDot11RtsThreshold, hh3cDot11StaKeepALiveTimerIntvl=hh3cDot11StaKeepALiveTimerIntvl, hh3cDot11RadioIfIdx=hh3cDot11RadioIfIdx, hh3cDot11MonitorInterval=hh3cDot11MonitorInterval, hh3cDot11AuthenMode=hh3cDot11AuthenMode, hh3cDot11StaKeepAliveTimerInterv=hh3cDot11StaKeepAliveTimerInterv, hh3cDot11UplinkTrackId=hh3cDot11UplinkTrackId, hh3cDot11WLANEthernetIfEntry=hh3cDot11WLANEthernetIfEntry, hh3cDot11DisabledRateSet=hh3cDot11DisabledRateSet, hh3cDot11GlobeConfigGroup=hh3cDot11GlobeConfigGroup, hh3cDot11APBSSIDSupportNum=hh3cDot11APBSSIDSupportNum, hh3cDot11SPInCirStaticValue=hh3cDot11SPInCirStaticValue, hh3cDot11APWorkMode=hh3cDot11APWorkMode, hh3cDot11CfgRadioStatus=hh3cDot11CfgRadioStatus, hh3cDot11SPOutCirMode=hh3cDot11SPOutCirMode, hh3cDot11CfgMaxTxPowerLevel=hh3cDot11CfgMaxTxPowerLevel, hh3cDot11SPIsolate=hh3cDot11SPIsolate, hh3cDot11CipherKeyIndex=hh3cDot11CipherKeyIndex, hh3cDot11APSysInfoSetTable=hh3cDot11APSysInfoSetTable, hh3cDot11CfgLBRdGroupId=hh3cDot11CfgLBRdGroupId, hh3cDot11APUserCntLimit=hh3cDot11APUserCntLimit, hh3cDot11MaxAPPerIf=hh3cDot11MaxAPPerIf, hh3cDot11WlanEthernetIfNumber=hh3cDot11WlanEthernetIfNumber, hh3cDot11PreConflictTemplateNum=hh3cDot11PreConflictTemplateNum, hh3cDot11SPEnable=hh3cDot11SPEnable, hh3cDot11RPClientMaxCount=hh3cDot11RPClientMaxCount, hh3cDot11RPFragThreshold=hh3cDot11RPFragThreshold, hh3cDot11CfgRadioID=hh3cDot11CfgRadioID, hh3cDot11SrvPolicyExtendTable=hh3cDot11SrvPolicyExtendTable, hh3cDot11RadioPolicyExtTable=hh3cDot11RadioPolicyExtTable, hh3cDot11RadioToConfigTable=hh3cDot11RadioToConfigTable, hh3cDot11APIfSetTable=hh3cDot11APIfSetTable, hh3cDot11RadioCfgMaxRxLifetime=hh3cDot11RadioCfgMaxRxLifetime, hh3cDot11RadioWDSMode=hh3cDot11RadioWDSMode, hh3cDot11CfgSTNASPortID=hh3cDot11CfgSTNASPortID, hh3cDot11CfgServicePolicyID=hh3cDot11CfgServicePolicyID, hh3cDot11WLANEthernetIfIndex=hh3cDot11WLANEthernetIfIndex, hh3cDot11AutoAPName=hh3cDot11AutoAPName, hh3cDot11ServicePolicyEntry=hh3cDot11ServicePolicyEntry, hh3cDot11nRadioCfgTable=hh3cDot11nRadioCfgTable, hh3cDot11APElementID=hh3cDot11APElementID, hh3cDot11RPRtsThreshold=hh3cDot11RPRtsThreshold, hh3cDot11CfgTrapVarObjects=hh3cDot11CfgTrapVarObjects, hh3cDot11RadioIntfConfigGroup=hh3cDot11RadioIntfConfigGroup, hh3cDot11APTemplateTable=hh3cDot11APTemplateTable, hh3cDot11APUserThreshold=hh3cDot11APUserThreshold, hh3cDot11APSysNetID=hh3cDot11APSysNetID, hh3cDot11nRadioCfgIndex=hh3cDot11nRadioCfgIndex, hh3cDot11APSTVlanEntry=hh3cDot11APSTVlanEntry, hh3cDot11RtCollectSwitch=hh3cDot11RtCollectSwitch, hh3cDot11APMemUsageThreshold=hh3cDot11APMemUsageThreshold, hh3cDot11RCRadioID=hh3cDot11RCRadioID, hh3cDot11CfgChannel=hh3cDot11CfgChannel, hh3cDot11CfgPowerLockStat=hh3cDot11CfgPowerLockStat, hh3cDot11StatisIntervMode=hh3cDot11StatisIntervMode, hh3cDot11RadioSSIDCfgTable=hh3cDot11RadioSSIDCfgTable, hh3cDot11SrvPolicyExtRowStatus=hh3cDot11SrvPolicyExtRowStatus, hh3cDot11nAMsduEnable=hh3cDot11nAMsduEnable, hh3cDot11ChnlSwitChkInterval=hh3cDot11ChnlSwitChkInterval, hh3cDot11RtCollectIntvl=hh3cDot11RtCollectIntvl, hh3cDot11RCAPSerialID=hh3cDot11RCAPSerialID, hh3cDot11ACBackupGroup=hh3cDot11ACBackupGroup, hh3cDot11RPBeaconInterval=hh3cDot11RPBeaconInterval, hh3cDot11APServiceSetEntry=hh3cDot11APServiceSetEntry, hh3cDot11WlanBssIfNumber=hh3cDot11WlanBssIfNumber, hh3cDot11APLastUpdateStatTime=hh3cDot11APLastUpdateStatTime, hh3cDot11APCbs=hh3cDot11APCbs, hh3cDot11nClientDot11nOnly=hh3cDot11nClientDot11nOnly, hh3cDot11SPInCirValue=hh3cDot11SPInCirValue, hh3cDot11APGetIPMethod=hh3cDot11APGetIPMethod, hh3cDot11BackupACAdrssIPv6=hh3cDot11BackupACAdrssIPv6, hh3cDot11CFG=hh3cDot11CFG, hh3cDot11BroadcastProbeReply=hh3cDot11BroadcastProbeReply, hh3cDot11ACAutoAPSupport=hh3cDot11ACAutoAPSupport, hh3cDot11WlanMeshIfIndex=hh3cDot11WlanMeshIfIndex, hh3cDot11BackupACAdrssIP=hh3cDot11BackupACAdrssIP, hh3cDot11ServicePolicyID=hh3cDot11ServicePolicyID, hh3cDot11APConfigGroup=hh3cDot11APConfigGroup, hh3cDot11PreambleLen=hh3cDot11PreambleLen, hh3cDot11APSysInfoSetEntry=hh3cDot11APSysInfoSetEntry, hh3cDot11SecurityCiphers=hh3cDot11SecurityCiphers, hh3cDot11APTemplateNameCfg=hh3cDot11APTemplateNameCfg, hh3cDot11APIfSetEntry=hh3cDot11APIfSetEntry, hh3cDot11APServiceVlanSPID=hh3cDot11APServiceVlanSPID, hh3cDot11StatisInterv=hh3cDot11StatisInterv, hh3cDot11RadioSSIDIndex=hh3cDot11RadioSSIDIndex, hh3cDot11RadioIntfBindTable=hh3cDot11RadioIntfBindTable, hh3cDot11APServiceVlanTable=hh3cDot11APServiceVlanTable, hh3cDot11RdoClientMaxCount=hh3cDot11RdoClientMaxCount, hh3cDot11CfgCipherChange=hh3cDot11CfgCipherChange, hh3cDot11RCPwrAttValue=hh3cDot11RCPwrAttValue, hh3cDot11WlanBssIfEntry=hh3cDot11WlanBssIfEntry, hh3cDot11RadioWDSEntry=hh3cDot11RadioWDSEntry, hh3cDot11CurrConflictTemplateNum=hh3cDot11CurrConflictTemplateNum, hh3cDot11APTemplateName=hh3cDot11APTemplateName, hh3cDot11SupportedRateSet=hh3cDot11SupportedRateSet, hh3cDot11SrvSecurityKeyType=hh3cDot11SrvSecurityKeyType, hh3cDot11APTemplateRowStatus=hh3cDot11APTemplateRowStatus, hh3cDot11RadioPolicyName=hh3cDot11RadioPolicyName, hh3cDot11WlanInfBindingID=hh3cDot11WlanInfBindingID, hh3cDot11RadioIntfBindRowStatus=hh3cDot11RadioIntfBindRowStatus, hh3cDot11CfgChannelLockStat=hh3cDot11CfgChannelLockStat, hh3cDot11SrvPortSecurityEntry=hh3cDot11SrvPortSecurityEntry, hh3cDot11APName=hh3cDot11APName, hh3cDot11APPriorityLevel=hh3cDot11APPriorityLevel, hh3cDot11RadioSSIDSerialID=hh3cDot11RadioSSIDSerialID, hh3cDot11CipherKey=hh3cDot11CipherKey, hh3cDot11RadioElementConfigGroup=hh3cDot11RadioElementConfigGroup, hh3cDot11APIfAlias=hh3cDot11APIfAlias, hh3cDot11RadioCfgMaxTxPwrLvl=hh3cDot11RadioCfgMaxTxPwrLvl, hh3cDot11WlanBssIfTable=hh3cDot11WlanBssIfTable, hh3cDot11StaIdleTimerInterv=hh3cDot11StaIdleTimerInterv, hh3cDot11RadioCfgDtimIntvl=hh3cDot11RadioCfgDtimIntvl, hh3cDot11WlanBssIfIndex=hh3cDot11WlanBssIfIndex, hh3cDot11CfgPwrAttValue=hh3cDot11CfgPwrAttValue, hh3cDot11RadioIntfBindEntry=hh3cDot11RadioIntfBindEntry, hh3cDot11RadioPolicyExtEntry=hh3cDot11RadioPolicyExtEntry, hh3cDot11SmartRateSet=hh3cDot11SmartRateSet, hh3cDot11nRadioCfgEntry=hh3cDot11nRadioCfgEntry, hh3cDot11APSetIfIndex=hh3cDot11APSetIfIndex, hh3cDot11RadioSSIDWLANID=hh3cDot11RadioSSIDWLANID, hh3cDot11Description=hh3cDot11Description, hh3cDot11RadioIntfConfigTable=hh3cDot11RadioIntfConfigTable, hh3cDot11RadioIntfBindSvcPlcyID=hh3cDot11RadioIntfBindSvcPlcyID, hh3cDot11RadioIntfBindIfIdx=hh3cDot11RadioIntfBindIfIdx, hh3cDot11APSerialID=hh3cDot11APSerialID, hh3cDot11RadioCfgType=hh3cDot11RadioCfgType, hh3cDot11TemplateAPModelAlias=hh3cDot11TemplateAPModelAlias, hh3cDot11DataRateConfigGroup=hh3cDot11DataRateConfigGroup, hh3cDot11SIDAPWorkMode=hh3cDot11SIDAPWorkMode, hh3cDot11SecurityPskKeyMode=hh3cDot11SecurityPskKeyMode, hh3cDot11SampleInterval=hh3cDot11SampleInterval, hh3cDot11APCpuUsageThreshold=hh3cDot11APCpuUsageThreshold, hh3cDot11ClientMaxCount=hh3cDot11ClientMaxCount, hh3cDot11APServiceVlanSerialID=hh3cDot11APServiceVlanSerialID, hh3cDot11WlanEssIfIndex=hh3cDot11WlanEssIfIndex, hh3cDot11RadioCfglongRtrThld=hh3cDot11RadioCfglongRtrThld, hh3cDot11CipherKeyType=hh3cDot11CipherKeyType, hh3cDot11StaIdleTimerIntvl=hh3cDot11StaIdleTimerIntvl, hh3cDot11SSIDHidden=hh3cDot11SSIDHidden, hh3cDot11RadioToConfigEntry=hh3cDot11RadioToConfigEntry, hh3cDot11SrvSecurityPskKeyMode=hh3cDot11SrvSecurityPskKeyMode, hh3cDot11WlanBssRowStatus=hh3cDot11WlanBssRowStatus, hh3cDot11SrvPolicyExtendEntry=hh3cDot11SrvPolicyExtendEntry, hh3cDot11WlanEssRowStatus=hh3cDot11WlanEssRowStatus, hh3cDot11APDoSProtectEnable=hh3cDot11APDoSProtectEnable, hh3cDot11SecIEStatus=hh3cDot11SecIEStatus, hh3cDot11WlanInfBindingType=hh3cDot11WlanInfBindingType, hh3cDot11RPShortRetryThreshold=hh3cDot11RPShortRetryThreshold, hh3cDot11RadioConfigTable=hh3cDot11RadioConfigTable, hh3cDot11APLimitTable=hh3cDot11APLimitTable, hh3cDot11WlanMeshRowStatus=hh3cDot11WlanMeshRowStatus, hh3cDot11RadioWDSNetWorkID=hh3cDot11RadioWDSNetWorkID, hh3cDot11CfgRadioType=hh3cDot11CfgRadioType, hh3cDot11CfgSTVLANID=hh3cDot11CfgSTVLANID, hh3cDot11SecurityServicePolicyID=hh3cDot11SecurityServicePolicyID, hh3cDot11SrvPolicyRowStatus=hh3cDot11SrvPolicyRowStatus, hh3cDot11RadioCfgChannel=hh3cDot11RadioCfgChannel, hh3cDot11nAMpduEnable=hh3cDot11nAMpduEnable, hh3cDot11nShortGiEnable=hh3cDot11nShortGiEnable, hh3cDot11ConfigureRadioID=hh3cDot11ConfigureRadioID, hh3cDot11WlanEssIfNumber=hh3cDot11WlanEssIfNumber, hh3cDot11APServiceSetTable=hh3cDot11APServiceSetTable, hh3cDot11ACDataTunnelSecSupport=hh3cDot11ACDataTunnelSecSupport, hh3cDot11RadioPolicyEntry=hh3cDot11RadioPolicyEntry, hh3cDot11WlanMeshIfTable=hh3cDot11WlanMeshIfTable, hh3cDot11FragThreshold=hh3cDot11FragThreshold, hh3cDot11RCPreambleLen=hh3cDot11RCPreambleLen, hh3cDot11RadioCfgRtsThreshold=hh3cDot11RadioCfgRtsThreshold, hh3cDot11ServicePolicyExtID=hh3cDot11ServicePolicyExtID, hh3cDot11WlanEssIfEntry=hh3cDot11WlanEssIfEntry, hh3cDot11SecurityUserLoginTxKeyType=hh3cDot11SecurityUserLoginTxKeyType, hh3cDot11APSsidNumLimit=hh3cDot11APSsidNumLimit, hh3cDot11RCChannel=hh3cDot11RCChannel, hh3cDot11RadioCfgPreambleLen=hh3cDot11RadioCfgPreambleLen, hh3cDot11RadioWDSTable=hh3cDot11RadioWDSTable, hh3cDot11SIDAPGetIPMethod=hh3cDot11SIDAPGetIPMethod, hh3cDot11RadioPolicyTable=hh3cDot11RadioPolicyTable, hh3cDot11RPDtimInterval=hh3cDot11RPDtimInterval, hh3cDot11PortSecurityEntry=hh3cDot11PortSecurityEntry, hh3cDot11AllAPCpuUsageThreshold=hh3cDot11AllAPCpuUsageThreshold, hh3cDot11RCRadioStatus=hh3cDot11RCRadioStatus, hh3cDot11SecurityPskKeyString=hh3cDot11SecurityPskKeyString, hh3cDot11SrvSetRowStatus=hh3cDot11SrvSetRowStatus, hh3cDot11PolicyConfigGroup=hh3cDot11PolicyConfigGroup, hh3cDot11LongRetryThreshold=hh3cDot11LongRetryThreshold)
mibBuilder.exportSymbols("HH3C-DOT11-CFG-MIB", hh3cDot11MandatoryRateSet=hh3cDot11MandatoryRateSet, hh3cDot11PersistentName=hh3cDot11PersistentName, hh3cDot11RadioSSIDRowStatus=hh3cDot11RadioSSIDRowStatus, hh3cDot11WlanMeshIfNumber=hh3cDot11WlanMeshIfNumber, hh3cDot11RglCollectIntvl=hh3cDot11RglCollectIntvl, hh3cDot11nChanelBand=hh3cDot11nChanelBand, hh3cDot11RadioWDSIndex=hh3cDot11RadioWDSIndex, hh3cDot11RadioSSIDRadioID=hh3cDot11RadioSSIDRadioID, hh3cDot11APLimitEntry=hh3cDot11APLimitEntry, hh3cDot11WDSSecPskKeyString=hh3cDot11WDSSecPskKeyString, hh3cDot11RPAPSerialID=hh3cDot11RPAPSerialID, hh3cDot11APTemplateEntry=hh3cDot11APTemplateEntry, hh3cDot11SrvSecurityPskKeyString=hh3cDot11SrvSecurityPskKeyString, hh3cDot11DataRateConfigTable=hh3cDot11DataRateConfigTable, hh3cDot11AllAPMemUsageThreshold=hh3cDot11AllAPMemUsageThreshold, hh3cDot11IntfTrapThreshold=hh3cDot11IntfTrapThreshold, hh3cDot11APSerialIDTable=hh3cDot11APSerialIDTable, hh3cDot11SampleTimeStamp=hh3cDot11SampleTimeStamp, hh3cDot11RadioCfgOnly11gEnable=hh3cDot11RadioCfgOnly11gEnable, hh3cDot11ServicePolicyExtEntry=hh3cDot11ServicePolicyExtEntry, hh3cDot11CfgWorkMode=hh3cDot11CfgWorkMode)

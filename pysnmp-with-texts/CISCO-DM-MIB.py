#
# PySNMP MIB module CISCO-DM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-DM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:54:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
cffFcFeElementName, = mibBuilder.importSymbols("CISCO-FC-FE-MIB", "cffFcFeElementName")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
DomainIdOrZero, FcNameId, FcAddressId, FcNameIdOrZero, DomainId = mibBuilder.importSymbols("CISCO-ST-TC", "DomainIdOrZero", "FcNameId", "FcAddressId", "FcNameIdOrZero", "DomainId")
vsanIndex, notifyVsanIndex = mibBuilder.importSymbols("CISCO-VSAN-MIB", "vsanIndex", "notifyVsanIndex")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, MibIdentifier, Bits, ObjectIdentity, Integer32, IpAddress, Unsigned32, NotificationType, Counter64, Gauge32, iso, TimeTicks, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "MibIdentifier", "Bits", "ObjectIdentity", "Integer32", "IpAddress", "Unsigned32", "NotificationType", "Counter64", "Gauge32", "iso", "TimeTicks", "ModuleIdentity")
TruthValue, TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "RowStatus", "DisplayString")
ciscoDmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 302))
ciscoDmMIB.setRevisions(('2003-09-22 00:00', '2003-06-20 00:00', '2003-02-27 00:00', '2003-02-21 00:00', '2003-01-28 00:00', '2003-01-02 00:00', '2002-10-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoDmMIB.setRevisionsDescriptions(('Added a new table dmAllowedDomainIDListTable. Added a new compliance statement dmMIBCompliance2 which obseletes dmMIBCompliance1.', 'Changed the default values for dmEnable, dmFabricName and dmFcIdPersistencyNum.', 'Updated the copyright', 'Fixed a problem with dmFcIdPersistencyGroup being both mandatory and conditional.', 'Changed the SYNTAX of dmFcIdPersistencyNum to INTEGER from Unsigned32.', 'Added objects dmFcIdPersistency and dmFcIdPurge to dmTable. Added a new table dmFcIdPersistencyTable. Added objects dmLocalPrincipalSwitchSelctns.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoDmMIB.setLastUpdated('200309220000Z')
if mibBuilder.loadTexts: ciscoDmMIB.setOrganization('Cisco Systems Inc. ')
if mibBuilder.loadTexts: ciscoDmMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553 -NETS E-mail: cs-san@cisco.com')
if mibBuilder.loadTexts: ciscoDmMIB.setDescription("The MIB module for the domain management functionality defined by the Fibre Channel standards (FC-SW2). For the purposes of this MIB, 'Domain Manager' is the software functionality which executes in both the principal switch and other switches.")
ciscoDmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 1))
dmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 2))
dmConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1))
dmInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2))
dmNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 3))
class DomainPriority(TextualConvention, Unsigned32):
    description = 'Priority of the switch. The principal switch selection is influenced by the priority of the switch. Some values are of importance are: 1 : The highest priority in principal switch selection and is used by the user to establish which switch becomes the principal switch. 255 : Indicates that the switch is not capable of acting as a principal switch.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 255)

class DomainPriorityOrZero(TextualConvention, Integer32):
    description = "This is an extension of the DomainPriority. In addition to the DomainPriority range, this also includes 0 in its range of values. The value '0' means that the priority is not known. If the meaning is different from this, then it should mentioned in the description of the object using this textual convention."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class DomainInterfaceRole(TextualConvention, Integer32):
    description = 'Role of the Domain Manager interface. nonPrincipal (1) - non-principal interface principalUpstream (2) - upstream principal interface principalDownsteam (3) - downstream principal interface isolated (4) - isolated interface down (5) - down interface unknown (6) - unknown interface '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("nonPrincipal", 1), ("principalUpstream", 2), ("principalDownsteam", 3), ("isolated", 4), ("down", 5), ("unknown", 6))

class DmState(TextualConvention, Integer32):
    description = 'State of the Domain Manager. starting(1)- unconfigured(2) - principalSwitchSelection(3) - principal switch - selection in progress. domainIdDistribution(4) - domain ID distribution - in progress. buildFabricPhase(5) - BuildFabric in - progress. reconfigureFabricPhase(6) - ReconfigureFabric in - progress. stable(7) - stable. stableWithNoEports(8) - stable with No present. stableWithDomainConfigured(9) - stable with domain - configured. noDomains(10) - no domain - configured/assigned. disabled(11) - domain manager disabled. suspended(12) - corresponding VSAN is - suspended. unknown(13) - unknown. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("starting", 1), ("unconfigured", 2), ("principalSwitchSelection", 3), ("domainIdDistribution", 4), ("buildFabricPhase", 5), ("reconfigureFabricPhase", 6), ("stable", 7), ("stableWithNoEports", 8), ("stableWithDomainConfigured", 9), ("noDomains", 10), ("disabled", 11), ("suspended", 12), ("unknown", 13))

dmTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1), )
if mibBuilder.loadTexts: dmTable.setStatus('current')
if mibBuilder.loadTexts: dmTable.setDescription('This table contains Domain Manager related parameters which can be configured and monitored. There is one entry for each of the VSANs configured on this switch. An entry will be created whenever a VSAN is created on the switch. The entry will be removed when the corresponding VSAN is deleted.')
dmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"))
if mibBuilder.loadTexts: dmEntry.setStatus('current')
if mibBuilder.loadTexts: dmEntry.setDescription('An entry provides information on the domain manager for a VSAN.')
dmConfigDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 1), DomainIdOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmConfigDomainId.setStatus('current')
if mibBuilder.loadTexts: dmConfigDomainId.setDescription("The configured Domain ID of the local switch on this VSAN or zero if no Domain ID has been configured. The meaning of this object depends on dmConfigDomainIdType object. If dmConfigDomainIdType is 'preferred', then domain ID configured is called 'preferred Domain ID'. The valid values are between 0 and 239. In a situation where this domain could not be assigned, any other domain ID would be acceptable. The value '0' means any domain ID. If dmConfigDomainIdType is 'static', then domain ID is called 'static Domain ID' and valid values are between 1 and 239. In a situation where this domain was non-zero but could not be assigned, no other domain ID would be acceptable. If the Domain Manager is enabled on the VSAN, then a RDI (Request Domain ID) will be sent requesting this Domain ID. If no Domain ID can be granted in the case of 'preferred' or if the configured 'static' domain ID cannot be not granted then, it is an error condition. When this error occurs, the E_ports on that VSAN will be isolated and user will be informed via 'dmDomainIdNotAssigned' notification. If the domain manager is not enabled, then the static Domain ID is assumed to be granted, if it has been configured (to a valid number). If either of the domain IDs are not configured with a non-zero value on this VSAN and if the domain manager is not enabled, then - switch will isolate all of its E_ports on this VSAN. - The user will be informed via a notification 'dmDomainIdNotAssigned'.")
dmConfigDomainIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("preferred", 2))).clone('preferred')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmConfigDomainIdType.setStatus('current')
if mibBuilder.loadTexts: dmConfigDomainIdType.setDescription('Type of configured Domain ID.')
dmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmEnable.setStatus('current')
if mibBuilder.loadTexts: dmEnable.setDescription('Enables the Domain Manager on this VSAN. If enabled on an active VSAN, the switch will participate in principal switch selection. If disabled, the switch will participate in neither the principal switch selection nor domain allocation. Thus, Domain ID needs to be configured statically.')
dmAutoReconfigure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmAutoReconfigure.setStatus('current')
if mibBuilder.loadTexts: dmAutoReconfigure.setDescription("This object determines how the switch responds to certain error conditions. The condition that can cause these errors is merging of two disjoint fabrics that have overlapping Domain ID list. If value of this object is 'true', the switch will send a RCF (ReConfigureFabric) to rebuild the Fabric. If 'false' the switch will isolate the E_ports on which the errors happened.")
dmContiguousAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmContiguousAllocation.setStatus('current')
if mibBuilder.loadTexts: dmContiguousAllocation.setDescription("Determines how the switch behaves when elected as the principal switch. If true, switch won't accept non-contiguous domain IDs in RDIs and will try to replace all the Domain IDs in the list with contiguous domain IDs if a RDI for a contiguous Domain ID can not be fulfilled. If false, then the switch acts normally in granting the Domain IDs even if they are not contiguous.")
dmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 6), DomainPriority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmPriority.setStatus('current')
if mibBuilder.loadTexts: dmPriority.setDescription('Priority of the switch to be used in principal switch selection process.')
dmRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonDisruptive", 1), ("disruptive", 2), ("noOp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmRestart.setStatus('current')
if mibBuilder.loadTexts: dmRestart.setDescription("This object tells the Domain Manager to rebuild the Domain ID tree all over again. If this object is set to 'disruptive', then a RCF (ReConfigure Fabric) is generated in the VSAN in order for the fabric to recover from the errors. If this object is set to 'nonDisruptive', then a BF (Build Fabric) is generated in the VSAN. No action is taken if this object is set to 'noOp'. The value of the object when read is always 'noOp'.")
dmFabricName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 8), FcNameIdOrZero().clone(hexValue="20010005300028df")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmFabricName.setStatus('current')
if mibBuilder.loadTexts: dmFabricName.setDescription('The WWN that is used for fabric logins on this VSAN. This object is used only if the value of dmEnable is false. If the value of dmEnable is true, then principal switch WWN is used. It is automatically set to the default value when set to zero-length value.')
dmPrincipalSwitchWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 9), FcNameIdOrZero().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmPrincipalSwitchWwn.setStatus('current')
if mibBuilder.loadTexts: dmPrincipalSwitchWwn.setDescription('The WWN of the Principal Switch on this VSAN, or zero-length string if the identity of the principal switch is unknown.')
dmLocalSwitchWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 10), FcNameIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmLocalSwitchWwn.setStatus('current')
if mibBuilder.loadTexts: dmLocalSwitchWwn.setDescription('The WWN of the local Switch on this VSAN.')
dmAssignedAreaIdList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmAssignedAreaIdList.setStatus('current')
if mibBuilder.loadTexts: dmAssignedAreaIdList.setDescription("The list of Area IDs which have been assigned in this VSAN, formatted as an array of octets in ascending order. There could zero or more Area IDs assigned on this VSAN. Area ID is an 8-bit value. And therefore, each octet represents one Area ID. So, the list containing the area_IDs 23, 45, 235 and 56 would be formatted as the 4-octet string x'172d38eb'. Each of these area_IDs can be used as an index to the dmAreaTable to get the statistics on the area.")
dmFcIdsGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFcIdsGranted.setStatus('current')
if mibBuilder.loadTexts: dmFcIdsGranted.setDescription("The total number of FC IDs that are granted (for local use) by the Domain Manager on the local switch since the switch has been initialized. Note that all such FC IDs have the local switch's Domain ID.")
dmFcIdsRecovered = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFcIdsRecovered.setStatus('current')
if mibBuilder.loadTexts: dmFcIdsRecovered.setDescription('The total number of FC IDs that are recovered by the Domain Manager on the local switch since the switch has been initialized. A recovered FC ID is one that is explicitly returned after previously being granted for local use.')
dmFreeFcIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFreeFcIds.setStatus('current')
if mibBuilder.loadTexts: dmFreeFcIds.setDescription('The number of FC IDs that are unassigned on this VSAN.')
dmAssignedFcIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmAssignedFcIds.setStatus('current')
if mibBuilder.loadTexts: dmAssignedFcIds.setDescription('The number of FC IDs that are assigned on this VSAN.')
dmReservedFcIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmReservedFcIds.setStatus('current')
if mibBuilder.loadTexts: dmReservedFcIds.setDescription('The number of FC IDs that are reserved on this VSAN.')
dmRunningPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 17), DomainPriority()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmRunningPriority.setStatus('current')
if mibBuilder.loadTexts: dmRunningPriority.setDescription('The running priority of the local switch on this VSAN.')
dmPrincSwRunningPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 18), DomainPriority()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmPrincSwRunningPriority.setStatus('current')
if mibBuilder.loadTexts: dmPrincSwRunningPriority.setDescription('The running priority of the principal switch on this VSAN.')
dmState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 19), DmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmState.setStatus('current')
if mibBuilder.loadTexts: dmState.setDescription('The state of the Domain Manager on the local switch on this VSAN.')
dmPrincipalSwitchSelections = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmPrincipalSwitchSelections.setStatus('current')
if mibBuilder.loadTexts: dmPrincipalSwitchSelections.setDescription('The number of principal switch selections on this VSAN.')
dmBuildFabrics = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmBuildFabrics.setStatus('current')
if mibBuilder.loadTexts: dmBuildFabrics.setDescription("The number of 'BuildFabrics' (BFs) that have occurred on this VSAN.")
dmFabricReconfigures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFabricReconfigures.setStatus('current')
if mibBuilder.loadTexts: dmFabricReconfigures.setDescription("The number of 'ReconfigureFabrics' (RCFs) that have occurred on this VSAN.")
dmDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 23), DomainIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmDomainId.setStatus('current')
if mibBuilder.loadTexts: dmDomainId.setDescription('The Domain ID of the local switch on this VSAN or zero if no Domain ID has been assigned.')
dmLocalPrincipalSwitchSelctns = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmLocalPrincipalSwitchSelctns.setStatus('current')
if mibBuilder.loadTexts: dmLocalPrincipalSwitchSelctns.setDescription('The number of times the local switch became the principal switch on this VSAN.')
dmFcIdPersistency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmFcIdPersistency.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistency.setDescription("Indicates if the FC IDs assigned on this VSAN are persistent or not. If this object is set to 'true', then all the FC ID assigned on this VSAN are made persistent on this VSAN. If this object is set to 'false', then all the entries on VSAN in dmFcIdPersistencyTable are deleted. An entry (or entries) is (or are) automatically created in the dmFcIdPersistencyTable with dmFcIfPersistencyWwn equal to either WWN of the FC device (if the local port is a F_port) for which the FC ID was assigned or WWN of local port (if the local port is a FL_port) and dmFcIdPersistencyType equal to 'dynamic'. The FC ID persistency can be enabled on this VSAN only if all the following conditions are satisfied: - the VSAN is active. - if dmConfigDomainIdType is equal is 'static' and dmConfigDomainId is not equal to zero on this VSAN. - if the dmConfigDomainId is equal to dmDomainId on this VSAN. ")
dmFcIdPurge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmFcIdPurge.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPurge.setDescription("This object tells the Domain Manager to purge the FC IDs on this VSAN in the FC ID persistency database. If the value of this object is 'enable', then the FC IDs which are dynamic and not currently used are purged from the persistency database.")
dmIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 2), )
if mibBuilder.loadTexts: dmIfTable.setStatus('current')
if mibBuilder.loadTexts: dmIfTable.setDescription('This table contains interface configuration of the domain manager per VSAN. An entry in this table is automatically created when an E_port becomes non-isolated and there is a entry in dmTable for that VSAN. An entry is deleted automatically from this table if : a) the correponding interface becomes non-existent, or b) the correponding interface becomes a non-E_port and all the writable objects has default values. or c) the dmTable entry for the corresponding VSAN is deleted. Entries in this table can be created via dmIfRowStatus only as the means to specify non-default parameter values for an interface at a time when that interface is either down or is a non-E_port. So an entry in this table exists when one or both of these conditions holds: - one or more configuration parameters have non-default values for an interface which is either down or a non-E_port and corresponding VSAN has an entry in the dmTable, and/or - the interface is an E_port and it is up. This has a number of consequences: - an entry exists for a non-E_port or an E_port which is down whenever that interface has non-default parameters and the corresponding VSAN has an entry in the dmTable; - an entry cannot be created (via dmIfRowStatus) for an interface with default parameters; instead, the agent creates/deletes an entry for an interface with default parameters according to whether the E_port is up or down. - an entry can not be created via dmIfRowStatus unless non-default parameter values are (simultaneously) configured for an interface which is a non-E_port or a down interface, and the correspoding VSAN has an entry in the dmTable. - deleting an entry via RowStatus when either the interface is down and configured with non-default values or the interface is up, is equivalent to resetting its parameters to their default values. If the interface is down and was configured with default- values, then the entry would be deleted.')
dmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dmIfEntry.setStatus('current')
if mibBuilder.loadTexts: dmIfEntry.setDescription('An entry gives information on interface configuration on a particular VSAN.')
dmIfRcfReject = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 2, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmIfRcfReject.setStatus('current')
if mibBuilder.loadTexts: dmIfRcfReject.setDescription("This object determines if the incoming ReConfigure Fabric (RCF) messages on this interface on this vsan is accepted or not. If this object is 'true', then the incoming RCF is rejected. If 'false', incoming RCF is accepted. Note that this object does not apply to the outgoing RCFs generated by this interface.")
dmIfRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 2, 1, 2), DomainInterfaceRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmIfRole.setStatus('current')
if mibBuilder.loadTexts: dmIfRole.setDescription('The role of this interface.')
dmIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: dmIfRowStatus.setDescription('The status of this row. This object can be used to create an entry only if the corresponding interface exists. If the interface does not exists, a create will fail.')
dmAreaTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 1), )
if mibBuilder.loadTexts: dmAreaTable.setStatus('current')
if mibBuilder.loadTexts: dmAreaTable.setDescription('This table contains area statistics on this domain manager per VSAN. Each octet in the dmAssignedAreaList can be used to index this table to find information on each area.')
dmAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-DM-MIB", "dmAreaAreaId"))
if mibBuilder.loadTexts: dmAreaEntry.setStatus('current')
if mibBuilder.loadTexts: dmAreaEntry.setDescription(' An entry gives information on the Area ID and all Port IDs that were assigned for within an area for a particular VSAN.')
dmAreaAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: dmAreaAreaId.setStatus('current')
if mibBuilder.loadTexts: dmAreaAreaId.setDescription('The Area ID of this area.')
dmAreaAssignedPortIdList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmAreaAssignedPortIdList.setStatus('current')
if mibBuilder.loadTexts: dmAreaAssignedPortIdList.setDescription("The list of Port IDs which have been assigned in this Area and VSAN, formatted as an array of octets in ascending order. There could be zero or more Port IDs assigned on this Area and VSAN. Port ID is an 8-bit value. And therefore, each octet represents one Port ID. So, the list containing the Port IDs 23, 45, 235 and 56 would be formatted as the 4-octet string x'172d38eb'.")
dmDatabaseTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 2), )
if mibBuilder.loadTexts: dmDatabaseTable.setStatus('current')
if mibBuilder.loadTexts: dmDatabaseTable.setDescription('This table contains all information known by the local switch about all the domains which have been assigned in each of the VSANs.')
dmDatabaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-DM-MIB", "dmDatabaseDomainId"))
if mibBuilder.loadTexts: dmDatabaseEntry.setStatus('current')
if mibBuilder.loadTexts: dmDatabaseEntry.setDescription('An entry (conceptual row) in the dmDatabaseTable containing information about one Domain ID in one VSAN.')
dmDatabaseDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 2, 1, 1), DomainId())
if mibBuilder.loadTexts: dmDatabaseDomainId.setStatus('current')
if mibBuilder.loadTexts: dmDatabaseDomainId.setDescription('The Domain ID for which this row contains information.')
dmDatabaseSwitchWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 2, 1, 2), FcNameId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmDatabaseSwitchWwn.setStatus('current')
if mibBuilder.loadTexts: dmDatabaseSwitchWwn.setDescription('The WWN of the switch to which the corresponding value of dmDatabaseDomainId is currently assigned for the particular VSAN.')
dmMaxFcIdCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmMaxFcIdCacheSize.setStatus('current')
if mibBuilder.loadTexts: dmMaxFcIdCacheSize.setDescription('The maximum number of FC IDs that can be cached in the dmFcIdCacheTable.')
dmFcIdCacheTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 4), )
if mibBuilder.loadTexts: dmFcIdCacheTable.setStatus('current')
if mibBuilder.loadTexts: dmFcIdCacheTable.setDescription('This table contains all the FC IDs that have recently been released. So it lists all the FC IDs that have valid WWN to FC ID mappings and currently not assigned to any ports. These FC ID were assigned to ports and now, have been released. This cached FC ID contains only Area ID and Port ID information. The FC ID cache is kept to provide best effort re-assignment of same FC IDs. i.e, an Nx_port would get the same FC ID when it asks for a FC ID again, after releasing it.')
dmFcIdCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-DM-MIB", "dmFcIdCacheWwn"))
if mibBuilder.loadTexts: dmFcIdCacheEntry.setStatus('current')
if mibBuilder.loadTexts: dmFcIdCacheEntry.setDescription("An entry (conceptual row) in the dmFcIdCacheTable containing information about one FC ID that was released from a WWN, corresponding to a range of one or more ports. An entry is created when a FC ID is released by the last port in the range. An entry is deleted either when the number of rows in this table reaches 'dmMaxFcIdCacheSize' if it is the oldest entry (depending on the value of the object 'dmFcIdCacheReleasedTime') to make room for the a new entry or when the this FC ID is assinged to a port.")
dmFcIdCacheWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 4, 1, 1), FcNameId())
if mibBuilder.loadTexts: dmFcIdCacheWwn.setStatus('current')
if mibBuilder.loadTexts: dmFcIdCacheWwn.setDescription('The WWN of the port associated this entry.')
dmFcIdCacheAreaIdPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFcIdCacheAreaIdPortId.setStatus('current')
if mibBuilder.loadTexts: dmFcIdCacheAreaIdPortId.setDescription('The Area ID and Port ID of FC ID that was assigned and has since been released by this port on this VSAN. Note that this object is only 2 bytes and only contains the Area ID and Port ID.')
dmFcIdCachePortIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 2, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFcIdCachePortIds.setStatus('current')
if mibBuilder.loadTexts: dmFcIdCachePortIds.setDescription('Number of port IDs assigned and/or released starting from Port ID contained in the second byte of dmFcIdCacheAreaIdPortId for the Area ID contained in the first byte of object dmFcIdCacheAreaIdPortId.')
dmReConfFabricChangeNotifyEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmReConfFabricChangeNotifyEnable.setStatus('current')
if mibBuilder.loadTexts: dmReConfFabricChangeNotifyEnable.setDescription("Specifies whether or not the local switch should issue a dmFabricChangeNotify notification on sending or receiving ReConfigureFabric (RCF) on a VSAN. If the value of the object is 'true, then the notification is generated. If the value is 'false', notification is not generated.")
dmFcIdPersistencyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4), )
if mibBuilder.loadTexts: dmFcIdPersistencyTable.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyTable.setDescription("This table lists the FC IDs which are in the FC ID persistency database. The FC ID persistency is a feature which enables FC devices to get same FC IDs even if they disappear and appear back, if enabled. The FC ID persistency database contains information about the FC IDs which are assigned to FC devices either statically (configured) or dynamically. Entries are automatically created when a FC ID is assigned and dmFcIdPersistency is 'true' on this VSAN. The entries can also be created and deleted via the dmFcIdPersistencyRowStatus object. Entries are deleted when corresponding dmFcIdPersistencyType is 'dynamic' and dmFcIdPersistencyUsed is 'false' if the object dmFcIdPurge is set to 'enable'. An entry cannot be created if the dmFcIdPersistency is 'false'. If the dmDomainId is changed on a VSAN, then all the entries on that VSAN in this table are deleted. Also, if the dmConfigDomainId is not equal to dmDomainId on a VSAN, then all the entries in that VSAN are deleted. ")
dmFcIdPersistencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-DM-MIB", "dmFcIdPersistencyWwn"))
if mibBuilder.loadTexts: dmFcIdPersistencyEntry.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyEntry.setDescription('An entry provides information about a persistent FC ID.')
dmFcIdPersistencyWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 1), FcNameId())
if mibBuilder.loadTexts: dmFcIdPersistencyWwn.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyWwn.setDescription('This is either the port WWN of the FC device if the local port is a F_port or WWN of the local port if the local port is a FL_port. The local port is the port on the local device to which the FC device is attached.')
dmFcIdPersistencyFcId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 2), FcAddressId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmFcIdPersistencyFcId.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyFcId.setDescription("The FC ID assigned for this WWN on this VSAN. The third octet of this object must be '0x00' if value of dmFcIdPersistencyNum is 'area'. This object cannot be changed if either the value of dmFcIdPersistencyUsed is 'true' or if the new value being set is already assigned on this VSAN.")
dmFcIdPersistencyNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("area", 2))).clone('one')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmFcIdPersistencyNum.setReference('Refer to FC-SW-2 REV 5.4 Section 4.8 for information on FC addressing.')
if mibBuilder.loadTexts: dmFcIdPersistencyNum.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyNum.setDescription("The number of FC IDs starting from 'dmFcIdPersistencyFcId' which are assigned either statically or dynamically for this WWN on this VSAN. The value 'one' means just one FC ID is assigned. The value 'area' means all the FC IDs in the area that is specified in the second octet of dmFcIdPersistencyFcId are assigned. Typically, 256 FC IDs are assigned for an area. This object cannot be changed if the value of dmFcIdPersistencyUsed is 'true'.")
dmFcIdPersistencyUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmFcIdPersistencyUsed.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyUsed.setDescription('This object indicates if this FC ID is used or not.')
dmFcIdPersistencyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2))).clone('static')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmFcIdPersistencyType.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyType.setDescription('The type of persistency of this FC ID.')
dmFcIdPersistencyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dmFcIdPersistencyRowStatus.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyRowStatus.setDescription("Status of this row. An entry cannot be created until following object is instantiated : - dmFcIdPersistencyFcId - dmFcIdPersistencyNum Note that an entry cannot be deleted if the corresponding dmFcIdPersistencyUsed is 'true'.")
dmAllowedDomainIDListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 5), )
if mibBuilder.loadTexts: dmAllowedDomainIDListTable.setReference('For information on principal switch, refer to Fibre Channel SW-2 Rev 5.4 section 7.3 Principal switch selection.')
if mibBuilder.loadTexts: dmAllowedDomainIDListTable.setStatus('current')
if mibBuilder.loadTexts: dmAllowedDomainIDListTable.setDescription('This table contains list of allowed domain IDs in the local VSANs. So in a VSAN, domain IDs can be assigned only from the allowed list. All the domain IDs which are not allowed are reserved. Note that this is possible in a VSAN only if the local device is the principal switch in that VSAN.')
dmAllowedDomainIDListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-DM-MIB", "dmAllowedDomainIDListId"))
if mibBuilder.loadTexts: dmAllowedDomainIDListEntry.setStatus('current')
if mibBuilder.loadTexts: dmAllowedDomainIDListEntry.setDescription('An entry (conceptual row) in this table. Each entry represents an domain ID list allowed in a VSAN.')
dmAllowedDomainIDListId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dmAllowedDomainIDListId.setStatus('current')
if mibBuilder.loadTexts: dmAllowedDomainIDListId.setDescription('The identifier of the domain ID list.')
dmAllowedDomainIDList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmAllowedDomainIDList.setStatus('current')
if mibBuilder.loadTexts: dmAllowedDomainIDList.setDescription("This object provides the lists of domains that are allowed. Each octet within the value of the object specifies a set of domains. The first octet specifies domains 0 through 7. Similarly, the second octet specifies domain 8 through 15. Within each octet, the most significant bit represents the lowest numbered domain and least significant bit represents the highest numbered domain. Thus each domain, is represented by a single bit within the value of this object. A domain is allowed in this VSAN if the corresponding bit has a value of '1'. If this object has a value which is less than 32 bytes long, then the domains which are not represented are not considered to be in the list. If this object is a zero-length string, then no domains are allowed in this VSAN.")
dmAllowedDomainIDListUser = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 1, 5, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dmAllowedDomainIDListUser.setStatus('current')
if mibBuilder.loadTexts: dmAllowedDomainIDListUser.setDescription('The name of the entity using this domain ID list on this vsan.')
dmNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 3, 0))
dmDomainIdNotAssignedNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 3, 0, 1)).setObjects(("CISCO-VSAN-MIB", "notifyVsanIndex"), ("CISCO-FC-FE-MIB", "cffFcFeElementName"))
if mibBuilder.loadTexts: dmDomainIdNotAssignedNotify.setStatus('current')
if mibBuilder.loadTexts: dmDomainIdNotAssignedNotify.setDescription('If a Domain ID is not configured or assigned on a VSAN, then the switch may isolate E_ports on that VSAN. The conditions are : - If the Domain Manager is enabled on the local switch and its request for a configured static Domain ID is rejected or no other Domain ID is assigned, then the E_ports are isolated. - If the domain manager is not enabled and if a static Domain ID is not configured on the VSAN, then the switch will isolate all of its E_ports on the VSAN. This notification contains the vsanIndex of the VSAN on which the condition happened.')
dmNewPrincipalSwitchNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 3, 0, 2)).setObjects(("CISCO-VSAN-MIB", "notifyVsanIndex"), ("CISCO-FC-FE-MIB", "cffFcFeElementName"))
if mibBuilder.loadTexts: dmNewPrincipalSwitchNotify.setStatus('current')
if mibBuilder.loadTexts: dmNewPrincipalSwitchNotify.setDescription('This notification indicates that the sending switch has become the new Principal Switch on a VSAN. This notification is sent soon after its election as the new Principal Switch, i.e., upon expiration of a Principal Switch selection timer which is equal to twice Fabric Stability Timeout value (F_S_TOV). This notification contains the vsanIndex of the VSAN on which the switch became the Principal Switch and the WWN of the switch which became the Principal Switch.')
dmFabricChangeNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 302, 1, 3, 0, 3)).setObjects(("CISCO-VSAN-MIB", "notifyVsanIndex"))
if mibBuilder.loadTexts: dmFabricChangeNotify.setStatus('current')
if mibBuilder.loadTexts: dmFabricChangeNotify.setDescription("This notification is sent whenever a switch sends or receives a Build Fabric (BF) or a ReConfigure Fabric (RCF) message on a VSAN. A switch can receive or issue a BuildFabric (BF) or a ReConfigureFabric (RCF) message under following conditions: - A new link causes two disjoint fabrics in a VSAN to merge into one fabric. The sent/received message is BF if the Domain ID lists on the disjoint fabric does not overlap and it is RCF if they overlap. - An upsteam principal ISL which connects to Principal switch and other switches in a VSAN fails. BF is issued to see if there is an alternative path to the Principal Switch. If not paths exit, then an RCF is issued. - A switch asks for a different set of Domain IDs than the currently assigned list, the Principal switch would issue an RCF. The notification is not sent if a 'dmNewPrincipalSwitchNotify' notification is sent for the same transition. This notification contains the vsanIndex of the VSAN on which RCF was issued.")
dmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 1))
dmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2))
dmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 1, 1)).setObjects(("CISCO-DM-MIB", "dmGroup"), ("CISCO-DM-MIB", "dmDatabaseGroup"), ("CISCO-DM-MIB", "dmAreaGroup"), ("CISCO-DM-MIB", "dmCacheGroup"), ("CISCO-DM-MIB", "dmNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmMIBCompliance = dmMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: dmMIBCompliance.setDescription('The compliance statement for entities which implement the Domain Manager.')
dmMIBCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 1, 2)).setObjects(("CISCO-DM-MIB", "dmGroupRev1"), ("CISCO-DM-MIB", "dmDatabaseGroup"), ("CISCO-DM-MIB", "dmAreaGroup"), ("CISCO-DM-MIB", "dmCacheGroup"), ("CISCO-DM-MIB", "dmNotificationGroup"), ("CISCO-DM-MIB", "dmFcIdPersistencyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmMIBCompliance1 = dmMIBCompliance1.setStatus('deprecated')
if mibBuilder.loadTexts: dmMIBCompliance1.setDescription('The compliance statement for entities which implement the Domain Manager.')
dmMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 1, 3)).setObjects(("CISCO-DM-MIB", "dmGroupRev1"), ("CISCO-DM-MIB", "dmDatabaseGroup"), ("CISCO-DM-MIB", "dmAreaGroup"), ("CISCO-DM-MIB", "dmCacheGroup"), ("CISCO-DM-MIB", "dmNotificationGroup"), ("CISCO-DM-MIB", "dmFcIdPersistencyGroup"), ("CISCO-DM-MIB", "dmDomainIDAllowedGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmMIBCompliance2 = dmMIBCompliance2.setStatus('current')
if mibBuilder.loadTexts: dmMIBCompliance2.setDescription('The compliance statement for entities which implement the Domain Manager.')
dmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 1)).setObjects(("CISCO-DM-MIB", "dmConfigDomainId"), ("CISCO-DM-MIB", "dmConfigDomainIdType"), ("CISCO-DM-MIB", "dmEnable"), ("CISCO-DM-MIB", "dmAutoReconfigure"), ("CISCO-DM-MIB", "dmContiguousAllocation"), ("CISCO-DM-MIB", "dmPriority"), ("CISCO-DM-MIB", "dmRestart"), ("CISCO-DM-MIB", "dmFabricName"), ("CISCO-DM-MIB", "dmPrincipalSwitchWwn"), ("CISCO-DM-MIB", "dmLocalSwitchWwn"), ("CISCO-DM-MIB", "dmAssignedAreaIdList"), ("CISCO-DM-MIB", "dmFcIdsGranted"), ("CISCO-DM-MIB", "dmFcIdsRecovered"), ("CISCO-DM-MIB", "dmFreeFcIds"), ("CISCO-DM-MIB", "dmAssignedFcIds"), ("CISCO-DM-MIB", "dmReservedFcIds"), ("CISCO-DM-MIB", "dmRunningPriority"), ("CISCO-DM-MIB", "dmPrincSwRunningPriority"), ("CISCO-DM-MIB", "dmState"), ("CISCO-DM-MIB", "dmPrincipalSwitchSelections"), ("CISCO-DM-MIB", "dmBuildFabrics"), ("CISCO-DM-MIB", "dmFabricReconfigures"), ("CISCO-DM-MIB", "dmDomainId"), ("CISCO-DM-MIB", "dmReConfFabricChangeNotifyEnable"), ("CISCO-DM-MIB", "dmIfRcfReject"), ("CISCO-DM-MIB", "dmIfRole"), ("CISCO-DM-MIB", "dmIfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmGroup = dmGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dmGroup.setDescription('A collection of objects for displaying and configuring Domain Manager membership.')
dmDatabaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 2)).setObjects(("CISCO-DM-MIB", "dmDatabaseSwitchWwn"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmDatabaseGroup = dmDatabaseGroup.setStatus('current')
if mibBuilder.loadTexts: dmDatabaseGroup.setDescription('A collection of objects for displaying the Domain database information.')
dmAreaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 3)).setObjects(("CISCO-DM-MIB", "dmAreaAssignedPortIdList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmAreaGroup = dmAreaGroup.setStatus('current')
if mibBuilder.loadTexts: dmAreaGroup.setDescription('A collection of objects for displaying the Domain area information.')
dmCacheGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 4)).setObjects(("CISCO-DM-MIB", "dmMaxFcIdCacheSize"), ("CISCO-DM-MIB", "dmFcIdCacheAreaIdPortId"), ("CISCO-DM-MIB", "dmFcIdCachePortIds"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmCacheGroup = dmCacheGroup.setStatus('current')
if mibBuilder.loadTexts: dmCacheGroup.setDescription('A collection of objects for displaying the Domain area information.')
dmNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 5)).setObjects(("CISCO-DM-MIB", "dmDomainIdNotAssignedNotify"), ("CISCO-DM-MIB", "dmNewPrincipalSwitchNotify"), ("CISCO-DM-MIB", "dmFabricChangeNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmNotificationGroup = dmNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: dmNotificationGroup.setDescription('A collection of notifications for status monitoring and notification.')
dmGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 6)).setObjects(("CISCO-DM-MIB", "dmConfigDomainId"), ("CISCO-DM-MIB", "dmConfigDomainIdType"), ("CISCO-DM-MIB", "dmEnable"), ("CISCO-DM-MIB", "dmAutoReconfigure"), ("CISCO-DM-MIB", "dmContiguousAllocation"), ("CISCO-DM-MIB", "dmPriority"), ("CISCO-DM-MIB", "dmRestart"), ("CISCO-DM-MIB", "dmFabricName"), ("CISCO-DM-MIB", "dmPrincipalSwitchWwn"), ("CISCO-DM-MIB", "dmLocalSwitchWwn"), ("CISCO-DM-MIB", "dmAssignedAreaIdList"), ("CISCO-DM-MIB", "dmFcIdsGranted"), ("CISCO-DM-MIB", "dmFcIdsRecovered"), ("CISCO-DM-MIB", "dmFreeFcIds"), ("CISCO-DM-MIB", "dmAssignedFcIds"), ("CISCO-DM-MIB", "dmReservedFcIds"), ("CISCO-DM-MIB", "dmRunningPriority"), ("CISCO-DM-MIB", "dmPrincSwRunningPriority"), ("CISCO-DM-MIB", "dmState"), ("CISCO-DM-MIB", "dmPrincipalSwitchSelections"), ("CISCO-DM-MIB", "dmBuildFabrics"), ("CISCO-DM-MIB", "dmFabricReconfigures"), ("CISCO-DM-MIB", "dmDomainId"), ("CISCO-DM-MIB", "dmLocalPrincipalSwitchSelctns"), ("CISCO-DM-MIB", "dmReConfFabricChangeNotifyEnable"), ("CISCO-DM-MIB", "dmIfRcfReject"), ("CISCO-DM-MIB", "dmIfRole"), ("CISCO-DM-MIB", "dmIfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmGroupRev1 = dmGroupRev1.setStatus('current')
if mibBuilder.loadTexts: dmGroupRev1.setDescription('A collection of objects for displaying and configuring Domain Manager membership.')
dmFcIdPersistencyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 7)).setObjects(("CISCO-DM-MIB", "dmFcIdPersistency"), ("CISCO-DM-MIB", "dmFcIdPurge"), ("CISCO-DM-MIB", "dmFcIdPersistencyFcId"), ("CISCO-DM-MIB", "dmFcIdPersistencyNum"), ("CISCO-DM-MIB", "dmFcIdPersistencyUsed"), ("CISCO-DM-MIB", "dmFcIdPersistencyType"), ("CISCO-DM-MIB", "dmFcIdPersistencyRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmFcIdPersistencyGroup = dmFcIdPersistencyGroup.setStatus('current')
if mibBuilder.loadTexts: dmFcIdPersistencyGroup.setDescription('A collection of objects to support FC ID persistency.')
dmDomainIDAllowedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 302, 2, 2, 8)).setObjects(("CISCO-DM-MIB", "dmAllowedDomainIDList"), ("CISCO-DM-MIB", "dmAllowedDomainIDListUser"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dmDomainIDAllowedGroup = dmDomainIDAllowedGroup.setStatus('current')
if mibBuilder.loadTexts: dmDomainIDAllowedGroup.setDescription('A collection of objects to support domain ID list feature.')
mibBuilder.exportSymbols("CISCO-DM-MIB", dmFcIdCachePortIds=dmFcIdCachePortIds, dmReservedFcIds=dmReservedFcIds, dmMaxFcIdCacheSize=dmMaxFcIdCacheSize, dmIfRole=dmIfRole, dmAssignedAreaIdList=dmAssignedAreaIdList, dmFabricName=dmFabricName, dmNotificationGroup=dmNotificationGroup, dmConfigDomainId=dmConfigDomainId, PYSNMP_MODULE_ID=ciscoDmMIB, dmMIBConformance=dmMIBConformance, dmDatabaseDomainId=dmDatabaseDomainId, dmIfRowStatus=dmIfRowStatus, DomainInterfaceRole=DomainInterfaceRole, dmFcIdCacheWwn=dmFcIdCacheWwn, dmFcIdPersistencyTable=dmFcIdPersistencyTable, dmInfo=dmInfo, ciscoDmMIB=ciscoDmMIB, dmAllowedDomainIDListTable=dmAllowedDomainIDListTable, dmFcIdPersistencyEntry=dmFcIdPersistencyEntry, dmFcIdPersistencyUsed=dmFcIdPersistencyUsed, dmFcIdPersistencyFcId=dmFcIdPersistencyFcId, dmGroupRev1=dmGroupRev1, dmAreaGroup=dmAreaGroup, dmMIBCompliance2=dmMIBCompliance2, dmConfigDomainIdType=dmConfigDomainIdType, dmContiguousAllocation=dmContiguousAllocation, dmNotificationPrefix=dmNotificationPrefix, dmDomainIDAllowedGroup=dmDomainIDAllowedGroup, dmEntry=dmEntry, dmFcIdCacheTable=dmFcIdCacheTable, dmFcIdPersistencyWwn=dmFcIdPersistencyWwn, DomainPriority=DomainPriority, dmIfRcfReject=dmIfRcfReject, dmNewPrincipalSwitchNotify=dmNewPrincipalSwitchNotify, dmAreaAreaId=dmAreaAreaId, ciscoDmMIBObjects=ciscoDmMIBObjects, dmDomainId=dmDomainId, dmLocalSwitchWwn=dmLocalSwitchWwn, dmAllowedDomainIDList=dmAllowedDomainIDList, dmAreaTable=dmAreaTable, dmGroup=dmGroup, dmAssignedFcIds=dmAssignedFcIds, dmDatabaseTable=dmDatabaseTable, dmFabricReconfigures=dmFabricReconfigures, dmFcIdsGranted=dmFcIdsGranted, dmMIBCompliance1=dmMIBCompliance1, dmBuildFabrics=dmBuildFabrics, dmPrincSwRunningPriority=dmPrincSwRunningPriority, dmRestart=dmRestart, dmPrincipalSwitchWwn=dmPrincipalSwitchWwn, dmFcIdPurge=dmFcIdPurge, dmMIBGroups=dmMIBGroups, dmFabricChangeNotify=dmFabricChangeNotify, dmFcIdPersistencyType=dmFcIdPersistencyType, dmFcIdPersistencyRowStatus=dmFcIdPersistencyRowStatus, dmMIBCompliance=dmMIBCompliance, dmLocalPrincipalSwitchSelctns=dmLocalPrincipalSwitchSelctns, dmMIBCompliances=dmMIBCompliances, dmAllowedDomainIDListEntry=dmAllowedDomainIDListEntry, dmConfiguration=dmConfiguration, dmState=dmState, dmAutoReconfigure=dmAutoReconfigure, dmFcIdCacheAreaIdPortId=dmFcIdCacheAreaIdPortId, dmFcIdPersistencyNum=dmFcIdPersistencyNum, dmFcIdsRecovered=dmFcIdsRecovered, dmCacheGroup=dmCacheGroup, DomainPriorityOrZero=DomainPriorityOrZero, dmReConfFabricChangeNotifyEnable=dmReConfFabricChangeNotifyEnable, dmPrincipalSwitchSelections=dmPrincipalSwitchSelections, dmPriority=dmPriority, dmFcIdPersistency=dmFcIdPersistency, dmDatabaseEntry=dmDatabaseEntry, dmFcIdCacheEntry=dmFcIdCacheEntry, dmNotification=dmNotification, dmAllowedDomainIDListUser=dmAllowedDomainIDListUser, dmRunningPriority=dmRunningPriority, dmFreeFcIds=dmFreeFcIds, DmState=DmState, dmAllowedDomainIDListId=dmAllowedDomainIDListId, dmIfEntry=dmIfEntry, dmAreaAssignedPortIdList=dmAreaAssignedPortIdList, dmTable=dmTable, dmIfTable=dmIfTable, dmFcIdPersistencyGroup=dmFcIdPersistencyGroup, dmAreaEntry=dmAreaEntry, dmDatabaseSwitchWwn=dmDatabaseSwitchWwn, dmEnable=dmEnable, dmDomainIdNotAssignedNotify=dmDomainIdNotAssignedNotify, dmDatabaseGroup=dmDatabaseGroup)

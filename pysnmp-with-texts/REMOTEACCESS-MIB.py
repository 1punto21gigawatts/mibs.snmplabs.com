#
# PySNMP MIB module REMOTEACCESS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/REMOTEACCESS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:56:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
rmon, = mibBuilder.importSymbols("RMON-MIB", "rmon")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Counter32, TimeTicks, transmission, Unsigned32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ObjectIdentity, MibIdentifier, Integer32, Gauge32, iso, NotificationType, Counter64, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "TimeTicks", "transmission", "Unsigned32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ObjectIdentity", "MibIdentifier", "Integer32", "Gauge32", "iso", "NotificationType", "Counter64", "IpAddress", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class MacAddress(OctetString):
    pass

sonix = MibIdentifier((1, 3, 6, 1, 4, 1, 559))
sonixMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1))
registration = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2))
cscmInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 3))
regArpeggio = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10))
arpStandard = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 1))
arpFocus = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 2))
arpOffice = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 3))
arpPlus = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 4))
arpMultiLan = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 5))
arpLite = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 6))
arpPlusRPrimary = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 7))
arpPlusRBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 10, 8))
officeConnect = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13))
tftp = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 19))
officeConnectRemote510s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 1))
officeConnectRemote520s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 2))
officeConnectRemote530s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 3))
officeConnectRemote510u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 4))
officeConnectRemote520u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 5))
officeConnectRemote530u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 6))
officeConnectRemote531s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 7))
officeConnectRemote531u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 13, 8))
accessBuilder = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14))
accessBuilderRemoteUser400s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 1))
accessBuilderRemoteUser400u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 2))
accessBuilderInternet400s = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 3))
accessBuilderInternet400u = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 4))
accessBuilderRemoteOffice500 = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 5))
accessBuilderRemoteOffice600 = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 6))
accessBuilderRemoteOffice700 = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 7))
accessBuilder7000BriBridgeRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 8))
accessBuilder7000PriBridgeRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 14, 9))
serviceConnect2000 = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 15))
serviceConnect2000Base = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 15, 1))
serviceConnect2000BaseBri = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 15, 1, 1))
serviceConnect2000BasePri = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 2, 15, 1, 2))
remoteaccessMib = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1))
ports = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 2))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3))
traps = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 4))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 1))
isdnFailCause = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 2))
radius = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 3))
login = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 4))
mlink = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1))
filter = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2))
authorised = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3))
isdn = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4))
autocall = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1))
isdnbands = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2))
isdnnumbers = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3))
isdnports = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4))
isdnhistory = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5))
isdncla = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6))
isdnlists = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7))
isdnParams = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8))
bootp = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9))
ip = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25))
iprip = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26))
ipxrip = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11))
ipxrt = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12))
ipxsap = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13))
ipxsapt = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14))
ipxnear = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15))
pppext = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27))
firewall = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28))
users = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29))
ipnat = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32))
dhcpserver = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33))
dnsproxy = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35))
memoryusage = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36))
traptable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37), )
if mibBuilder.loadTexts: traptable.setStatus('mandatory')
if mibBuilder.loadTexts: traptable.setDescription('A table of trap addresses, ports and event-masks.')
ppp = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 23))
variant = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: variant.setStatus('mandatory')
if mibBuilder.loadTexts: variant.setDescription('Product variant.')
version = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: version.setStatus('mandatory')
if mibBuilder.loadTexts: version.setDescription('Product version number.')
unitname = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unitname.setStatus('mandatory')
if mibBuilder.loadTexts: unitname.setDescription('The name of the unit.')
save = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: save.setStatus('mandatory')
if mibBuilder.loadTexts: save.setDescription('Save current configuration to NVRAM.')
standard = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: standard.setStatus('mandatory')
if mibBuilder.loadTexts: standard.setDescription('Restore standard configuration, erasing NVRAM.')
saverequired = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: saverequired.setStatus('mandatory')
if mibBuilder.loadTexts: saverequired.setDescription('Have changes been made which need to be save to NVRAM.')
date = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: date.setStatus('mandatory')
if mibBuilder.loadTexts: date.setDescription('Real-time clock date. (Format dd/mm/yyyy).')
time = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: time.setStatus('mandatory')
if mibBuilder.loadTexts: time.setDescription('Real-time clock time. (Format hh:mm:ss).')
dayoftheweek = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("sunday", 1), ("monday", 2), ("tuesday", 3), ("wednesday", 4), ("thursday", 5), ("friday", 6), ("saturday", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dayoftheweek.setStatus('mandatory')
if mibBuilder.loadTexts: dayoftheweek.setDescription('Real-time clock day.')
managertimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managertimeout.setStatus('mandatory')
if mibBuilder.loadTexts: managertimeout.setDescription('The time after which the manager will timeout if there is no activity. Set this to 0 for no timeout.')
unitipad = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unitipad.setStatus('mandatory')
if mibBuilder.loadTexts: unitipad.setDescription('The Network port ip address of the unit.')
unitmacaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 12), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitmacaddress.setStatus('mandatory')
if mibBuilder.loadTexts: unitmacaddress.setDescription('The MAC address of the unit.')
defaultalert = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("beep", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultalert.setStatus('mandatory')
if mibBuilder.loadTexts: defaultalert.setDescription('Alert LED action.')
incallalert = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("beep", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: incallalert.setStatus('mandatory')
if mibBuilder.loadTexts: incallalert.setDescription('Incoming call Alert LED action.')
publiccommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: publiccommunity.setStatus('mandatory')
if mibBuilder.loadTexts: publiccommunity.setDescription('Community for reading MIB entries. This string will not be returned, but may be set.')
privatecommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: privatecommunity.setStatus('mandatory')
if mibBuilder.loadTexts: privatecommunity.setDescription('Community for reading and writing MIB entries. This string will not be returned, but may be set.')
trapaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapaddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapaddress.setDescription('The IP Address of the default management station to which all traps will be sent.')
trapport = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapport.setStatus('mandatory')
if mibBuilder.loadTexts: trapport.setDescription('The port on the default management station to which all traps will be sent.')
lcdManagerLock = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcdManagerLock.setStatus('mandatory')
if mibBuilder.loadTexts: lcdManagerLock.setDescription('Defines whether keypad operation is allowed.')
loopControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loopControl.setStatus('mandatory')
if mibBuilder.loadTexts: loopControl.setDescription('When enabled Loop Control allows a physical loop to exist without causing broadcast storms by preventing frames received on one WAN/ISDN port being retransmitted on other WAN/ISDN ports (useful when using multiple ISDN circuits).')
novelltimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: novelltimeout.setStatus('mandatory')
if mibBuilder.loadTexts: novelltimeout.setDescription('The time after which Novell session emulation will timeout if there is no activity. Set this to 0 for no timeout.')
timeSinceReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeSinceReboot.setStatus('mandatory')
if mibBuilder.loadTexts: timeSinceReboot.setDescription('Time since last reboot. (Format hh:mm:ss).')
passwdsTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 23), )
if mibBuilder.loadTexts: passwdsTable.setStatus('mandatory')
if mibBuilder.loadTexts: passwdsTable.setDescription('A table of manager passwords. In fact, only one entry in the table is allowed.')
passwdsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 23, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "passwdsOld"))
if mibBuilder.loadTexts: passwdsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: passwdsEntry.setDescription('A list of manager passwords.')
passwdsOld = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 23, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: passwdsOld.setStatus('mandatory')
if mibBuilder.loadTexts: passwdsOld.setDescription('The current manager password.')
passwdsNew = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 23, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: passwdsNew.setStatus('mandatory')
if mibBuilder.loadTexts: passwdsNew.setDescription('The new manager password. To change the password, a new table entry must be added, with both the old password and the new password in the same SET. The table will always appear empty.')
portsTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1), )
if mibBuilder.loadTexts: portsTable.setStatus('mandatory')
if mibBuilder.loadTexts: portsTable.setDescription('A table of configured physical ports.')
portsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portsIndex"))
if mibBuilder.loadTexts: portsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portsEntry.setDescription('A list of port configurations.')
portsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portsIndex.setDescription('The physical port index, in the range 1 to number-of-ports.')
portsName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsName.setStatus('mandatory')
if mibBuilder.loadTexts: portsName.setDescription('The port name.')
portsType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("none", 0), ("async", 2), ("hdlc", 3), ("ppp", 4), ("ethernet", 5), ("ta", 6), ("repeater", 7), ("voice", 8), ("slip", 9), ("slipMMIauto", 10), ("tpad", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsType.setStatus('mandatory')
if mibBuilder.loadTexts: portsType.setDescription('The configured type of the port.')
portsPhys = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("v35", 1), ("x21", 2), ("v24", 3), ("isdn", 4), ("aui", 5), ("tenBase2", 6), ("tenBaseT", 7), ("analogue", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsPhys.setStatus('mandatory')
if mibBuilder.loadTexts: portsPhys.setDescription('The connector type.')
portsTxutil = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsTxutil.setStatus('mandatory')
if mibBuilder.loadTexts: portsTxutil.setDescription('The percentage of the port transmit capacity being used multiplied by 1000.')
portsRxutil = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsRxutil.setStatus('mandatory')
if mibBuilder.loadTexts: portsRxutil.setDescription('The percentage of the port receive capacity being used multiplied by 1000.')
portsCompress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsCompress.setStatus('mandatory')
if mibBuilder.loadTexts: portsCompress.setDescription('For ports operating with LempelZiv compression, this is the compression ratio multiplied by 10.')
portsState = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsState.setStatus('mandatory')
if mibBuilder.loadTexts: portsState.setDescription('The operational state of the port.')
portsRxoctets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsRxoctets.setStatus('mandatory')
if mibBuilder.loadTexts: portsRxoctets.setDescription('The number of received octets on this port.')
portsTxoctets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsTxoctets.setStatus('mandatory')
if mibBuilder.loadTexts: portsTxoctets.setDescription('The number of transmitted octets on this port.')
portsRxpackets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsRxpackets.setStatus('mandatory')
if mibBuilder.loadTexts: portsRxpackets.setDescription('The number of received packets on this port.')
portsTxpackets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsTxpackets.setStatus('mandatory')
if mibBuilder.loadTexts: portsTxpackets.setDescription('The number of transmitted packets on this port.')
portsRxerrs = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsRxerrs.setStatus('mandatory')
if mibBuilder.loadTexts: portsRxerrs.setDescription('The number of receive errors on this port.')
portsTxerrs = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsTxerrs.setStatus('mandatory')
if mibBuilder.loadTexts: portsTxerrs.setDescription('The number of transmit errors on this port.')
portslanTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2), )
if mibBuilder.loadTexts: portslanTable.setStatus('mandatory')
if mibBuilder.loadTexts: portslanTable.setDescription('A table of configured lan ports.')
portslanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portslanIndex"))
if mibBuilder.loadTexts: portslanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portslanEntry.setDescription('A list of lan port configurations.')
portslanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portslanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portslanName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanName.setStatus('mandatory')
if mibBuilder.loadTexts: portslanName.setDescription('The name of the lan port.')
portslanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portslanPriority.setDescription('The spanning tree priority of this port.')
portslanLinespeed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanLinespeed.setStatus('mandatory')
if mibBuilder.loadTexts: portslanLinespeed.setDescription('The linespeed of this port. Normally this should be 10000000 bits/second')
portslanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIpAddress.setDescription('The IP Address assigned to this port when routing is enabled.')
portslanIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIpMask.setDescription('The IP Address Mask assigned to this port when routing is enabled.')
portslanIpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanIpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIpMetric.setDescription('The IP routing metric assigned to this port when routing is enabled.')
portslanIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIpxNetwork.setDescription('The IPX Network Address assigned to this port when routing is enabled.')
portslanIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portslanIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: portslanIpxType.setDescription('The frame type used for IPX RIP and SAP messages emanating from this port.')
portshdlcTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3), )
if mibBuilder.loadTexts: portshdlcTable.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcTable.setDescription('A table of configured hdlc ports.')
portshdlcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portshdlcIndex"))
if mibBuilder.loadTexts: portshdlcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcEntry.setDescription('A list of hdlc port configurations.')
portshdlcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portshdlcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portshdlcName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcName.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcName.setDescription('The name of the hdlc port.')
portshdlcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcPriority.setDescription('The spanning tree priority of this port.')
portshdlcLinespeed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcLinespeed.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcLinespeed.setDescription('The linespeed of this port. This is used to calculate percentage load and Spanning tree costs. ')
portshdlcCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("lzStandard", 1), ("lzWhite", 2), ("stac", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcCompression.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcCompression.setDescription('If enabled, data is compressed using the Lempel Ziv algorithm.')
portshdlcScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcScramble.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcScramble.setDescription('If enabled, data is scrambled.')
portshdlcBackupdemand = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("backup", 1), ("demand", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcBackupdemand.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcBackupdemand.setDescription('whether to use the dialup backup and/or demand.')
portshdlcDemandthresh = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcDemandthresh.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcDemandthresh.setDescription('Threshold at which dialup demand is invoked, if Backup/Demand is set to demand or both in fraction of capacity * 1000.')
portshdlcDemandperiod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcDemandperiod.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcDemandperiod.setDescription('Time over which demand must exceed the demand threshold before call will be established. Measured in seconds')
portshdlcIdlethresh = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIdlethresh.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIdlethresh.setDescription('Threshold at which once dialup demand is invoked, it will drop once load drops below fraction of capacity * 1000.')
portshdlcIdleperiod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIdleperiod.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIdleperiod.setDescription('Time over which demand must be less than the idle threshold before call will be dropped. Measured in seconds.')
portshdlcBackupalert = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("beep", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcBackupalert.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcBackupalert.setDescription('If enabled, the alert light will be lit whilst a backup call is made.')
portshdlcDemandpriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcDemandpriority.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcDemandpriority.setDescription('Priority of the demand call, since it may be bumped by a higher priority call.')
portshdlcBackuppriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcBackuppriority.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcBackuppriority.setDescription('Priority of the backup call, since it may be bumped by a higher priority call.')
portshdlcBackupnumber = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcBackupnumber.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcBackupnumber.setDescription('Telephone number(name of remote router) of the backup link.')
portshdlcBackupMac = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 16), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcBackupMac.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcBackupMac.setDescription('The MAC address of the backup bridge.')
portshdlcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIpAddress.setDescription('The IP Address assigned to this port when routing is enabled.')
portshdlcIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIpMask.setDescription('The IP Address Mask assigned to this port when routing is enabled.')
portshdlcIpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIpMetric.setDescription('The IP routing metric assigned to this port when routing is enabled.')
portshdlcIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIpxNetwork.setDescription('The IPX Network Address assigned to this port when routing is enabled.')
portshdlcIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portshdlcIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: portshdlcIpxType.setDescription('The frame type used for IPX RIP and SAP messages emanating from this port.')
portspppTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4), )
if mibBuilder.loadTexts: portspppTable.setStatus('mandatory')
if mibBuilder.loadTexts: portspppTable.setDescription('A table of configured ppp ports.')
portspppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portspppIndex"))
if mibBuilder.loadTexts: portspppEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portspppEntry.setDescription('A list of ppp port configurations.')
portspppIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portspppIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portspppName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppName.setStatus('mandatory')
if mibBuilder.loadTexts: portspppName.setDescription('The name of the ppp port.')
portspppPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portspppPriority.setDescription('The spanning tree priority of this port.')
portspppLinespeed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppLinespeed.setStatus('mandatory')
if mibBuilder.loadTexts: portspppLinespeed.setDescription('The linespeed of this port. This is used to calculate percentage load and Spanning tree costs. ')
portspppIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIpAddress.setDescription('The IP Address assigned to this port when routing is enabled.')
portspppIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIpMask.setDescription('The IP Address Mask assigned to this port when routing is enabled.')
portspppIpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIpMetric.setDescription('The IP routing metric assigned to this port when routing is enabled.')
portspppIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIpxNetwork.setDescription('The IPX Network Address assigned to this port when routing is enabled.')
portspppIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIpxType.setDescription('The frame type used for IPX RIP and SAP messages emanating from this port.')
portspppBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("bd1200", 1), ("bd2400", 2), ("bd4800", 3), ("bd9600", 4), ("bd19200", 5), ("bd38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppBaud.setStatus('mandatory')
if mibBuilder.loadTexts: portspppBaud.setDescription('The Baud Rate.')
portspppDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("data-7-bits", 7), ("data-8-bits", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: portspppDataBits.setDescription('The number of data bits.')
portspppStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data-1-bits", 1), ("data-2-bits", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: portspppStopBits.setDescription('The number of stop bits.')
portspppFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("rts", 1), ("xon", 2), ("halfxon", 3), ("rts-on-tx", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portspppFlowControl.setDescription('Flow Control.')
portspppTxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppTxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portspppTxParity.setDescription('Transmit Parity.')
portspppRxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppRxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portspppRxParity.setDescription('Receive Parity.')
portspppRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("any", 1), ("r3com", 2), ("cisco", 3), ("ascend", 4), ("spider", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: portspppRemoteUnit.setDescription('Remote Unit Type.')
portspppIPRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 4, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portspppIPRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portspppIPRemoteAddress.setDescription('Remote IP Address.')
portstaTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5), )
if mibBuilder.loadTexts: portstaTable.setStatus('mandatory')
if mibBuilder.loadTexts: portstaTable.setDescription('A table of configured ta ports.')
portstaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portstaIndex"))
if mibBuilder.loadTexts: portstaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portstaEntry.setDescription('A list of ta port configurations.')
portstaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portstaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portstaIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portstaName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaName.setStatus('mandatory')
if mibBuilder.loadTexts: portstaName.setDescription('The name of the ta port.')
portstaPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portstaPriority.setDescription('The spanning tree priority of this port.')
portstaLinespeed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaLinespeed.setStatus('mandatory')
if mibBuilder.loadTexts: portstaLinespeed.setDescription('The linespeed of this port. This is used to calculate percentage load and Spanning tree costs. ')
portstaCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("lzStandard", 1), ("lzWhite", 2), ("stac", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaCompression.setStatus('mandatory')
if mibBuilder.loadTexts: portstaCompression.setDescription('If enabled, data is compressed using the Lempel Ziv algorithm.')
portstaScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaScramble.setStatus('mandatory')
if mibBuilder.loadTexts: portstaScramble.setDescription('If enabled, data is scrambled.')
portstaDemand = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaDemand.setStatus('mandatory')
if mibBuilder.loadTexts: portstaDemand.setDescription('whether to use enable demand top-up.')
portstaDemandthresh = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaDemandthresh.setStatus('mandatory')
if mibBuilder.loadTexts: portstaDemandthresh.setDescription('Threshold at which dialup demand is invoked, if Backup/Demand is set to demand or both in fraction of capacity * 1000.')
portstaDemandperiod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaDemandperiod.setStatus('mandatory')
if mibBuilder.loadTexts: portstaDemandperiod.setDescription('Time over which demand must exceed the demand threshold before call will be established. Measured in seconds')
portstaIdlethresh = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaIdlethresh.setStatus('mandatory')
if mibBuilder.loadTexts: portstaIdlethresh.setDescription('Threshold at which once dialup demand is invoked, it will drop once load drops below fraction of capacity * 1000.')
portstaIdleperiod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaIdleperiod.setStatus('mandatory')
if mibBuilder.loadTexts: portstaIdleperiod.setDescription('Time over which demand must be less than the idle threshold before call will be dropped. Measured in seconds.')
portstaDemandpriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaDemandpriority.setStatus('mandatory')
if mibBuilder.loadTexts: portstaDemandpriority.setDescription('Priority of the demand call, since it may be bumped by a higher priority call.')
portstaDialtimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaDialtimeout.setStatus('mandatory')
if mibBuilder.loadTexts: portstaDialtimeout.setDescription('The time in seconds for which bridge will wait for an OK response from the external TA.')
portstaAtzstring = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaAtzstring.setStatus('mandatory')
if mibBuilder.loadTexts: portstaAtzstring.setDescription('Initialization string for the TA.')
portstaSpidstring = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 5, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstaSpidstring.setStatus('mandatory')
if mibBuilder.loadTexts: portstaSpidstring.setDescription('SPID string for the TA.')
portsslipTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6), )
if mibBuilder.loadTexts: portsslipTable.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipTable.setDescription('A table of configured slip ports.')
portsslipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portsslipIndex"))
if mibBuilder.loadTexts: portsslipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipEntry.setDescription('A list of slip port configurations.')
portsslipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsslipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portsslipName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipName.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipName.setDescription('The name of the slip port.')
portsslipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipPriority.setDescription('The spanning tree priority of this port.')
portsslipLinespeed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipLinespeed.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipLinespeed.setDescription('The linespeed of this port. This is used to calculate percentage load and Spanning tree costs. ')
portsslipIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipIpAddress.setDescription('The IP Address assigned to this port when routing is enabled.')
portsslipIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipIpMask.setDescription('The IP Address Mask assigned to this port when routing is enabled.')
portsslipIpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipIpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipIpMetric.setDescription('The IP routing metric assigned to this port when routing is enabled.')
portsslipBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("bd1200", 1), ("bd2400", 2), ("bd4800", 3), ("bd9600", 4), ("bd19200", 5), ("bd38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipBaud.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipBaud.setDescription('The Baud Rate.')
portsslipDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("data-7-bits", 7), ("data-8-bits", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsslipDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipDataBits.setDescription('The number of data bits.')
portsslipStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data-1-bits", 1), ("data-2-bits", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipStopBits.setDescription('The number of stop bits.')
portsslipFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5))).clone(namedValues=NamedValues(("rts", 1), ("rts-on-tx", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipFlowControl.setDescription('Flow Control.')
portsslipTxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsslipTxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipTxParity.setDescription('Transmit Parity.')
portsslipRxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsslipRxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipRxParity.setDescription('Receive Parity.')
portsslipMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipMTU.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipMTU.setDescription('Maximum Transmit Unit Length')
portsslipRIPPrivate = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipRIPPrivate.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipRIPPrivate.setDescription('Advertise IP Route')
portsslipIPRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 6, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsslipIPRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portsslipIPRemoteAddress.setDescription('Remote IP Address.')
portsasyncTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7), )
if mibBuilder.loadTexts: portsasyncTable.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncTable.setDescription('A table of configured asynchronous serial manager ports.')
portsasyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portsasyncIndex"))
if mibBuilder.loadTexts: portsasyncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncEntry.setDescription('A list of asynchronous serial manager port configurations.')
portsasyncIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsasyncIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portsasyncName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncName.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncName.setDescription('The name of the asynchronous serial manager port.')
portsasyncBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("bd1200", 1), ("bd2400", 2), ("bd4800", 3), ("bd9600", 4), ("bd19200", 5), ("bd38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncBaud.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncBaud.setDescription('The Baud Rate.')
portsasyncDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("data-7-bits", 7), ("data-8-bits", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncDataBits.setDescription('The number of data bits.')
portsasyncStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data-1-bits", 1), ("data-2-bits", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncStopBits.setDescription('The number of stop bits.')
portsasyncFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("rtscts", 1), ("xonxoff", 2), ("none", 5), ("both", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncFlowControl.setDescription('Flow Control.')
portsasyncTxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncTxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncTxParity.setDescription('Transmit Parity.')
portsasyncRxParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsasyncRxParity.setStatus('mandatory')
if mibBuilder.loadTexts: portsasyncRxParity.setDescription('Receive Parity.')
portsvoiceTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8), )
if mibBuilder.loadTexts: portsvoiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceTable.setDescription('A table of configured voice ports.')
portsvoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portsvoiceIndex"))
if mibBuilder.loadTexts: portsvoiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceEntry.setDescription('A list of voice port configurations.')
portsvoiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsvoiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portsvoiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsvoiceName.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceName.setDescription('The name of the voice port.')
portsvoiceCallsPermitted = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inout", 0), ("in", 1), ("out", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsvoiceCallsPermitted.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceCallsPermitted.setDescription('Controls whether incoming, outgoing or both types of voice call are permitted.')
portsvoiceEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("alaw", 0), ("ulaw", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsvoiceEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceEncoding.setDescription('The sound encoding mecanism used.')
portsvoiceDialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("overlap", 0), ("enbloc", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portsvoiceDialMode.setStatus('mandatory')
if mibBuilder.loadTexts: portsvoiceDialMode.setDescription('Controls whether each digit dialed is sent to the network immediately, or the whole number sent complete.')
portstpadTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9), )
if mibBuilder.loadTexts: portstpadTable.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadTable.setDescription('A table of configured tpad ports.')
portstpadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "portstpadIndex"))
if mibBuilder.loadTexts: portstpadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadEntry.setDescription('A list of tpad port configurations.')
portstpadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portstpadIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
portstpadName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadName.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadName.setDescription('The name of the tpad port.')
portstpadBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("bd1200", 1), ("bd2400", 2), ("bd4800", 3), ("bd9600", 4), ("bd19200", 5), ("bd38400", 6), ("bd57600", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadBaud.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadBaud.setDescription('The Baud Rate.')
portstpadDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("data-7-bits", 7), ("data-8-bits", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadDataBits.setDescription('The number of data bits.')
portstpadStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data-1-bits", 1), ("data-2-bits", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadStopBits.setDescription('The number of stop bits.')
portstpadParity = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("mark", 4), ("space", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadParity.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadParity.setDescription('Parity.')
portstpadTxFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("rtscts", 1), ("xonxoff", 2), ("none", 5), ("both", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadTxFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadTxFlowControl.setDescription('Transmit Flow Control.')
portstpadRxFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("rtscts", 1), ("xonxoff", 2), ("none", 5), ("both", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadRxFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadRxFlowControl.setDescription('Receive Flow Control.')
portstpadX25MinLCN = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadX25MinLCN.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadX25MinLCN.setDescription('X25 Minimum LCN')
portstpadX25MaxLCN = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 2, 9, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portstpadX25MaxLCN.setStatus('mandatory')
if mibBuilder.loadTexts: portstpadX25MaxLCN.setDescription('X25 Maximum LCN')
mlinkTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1), )
if mibBuilder.loadTexts: mlinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkTable.setDescription('A table of Multi-link links.')
mlinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "mlinkIndex"))
if mibBuilder.loadTexts: mlinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkEntry.setDescription('A MLINK ports.')
mlinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkIndex.setDescription('The index of this mlink link 1 to N.')
mlinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkName.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkName.setDescription('The name of the Bridge connected to by this link')
mlinkNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkNumberOfPorts.setDescription('Number of actual ports that make this mlink')
mlinkInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkInFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: mlinkInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
mlinkOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkOutFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: mlinkOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
mlinkInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkInDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: mlinkInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
mlinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkState.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: mlinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see dot1dStpPortEnable), this object will have a value of disabled(1).")
filterTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1), )
if mibBuilder.loadTexts: filterTable.setStatus('mandatory')
if mibBuilder.loadTexts: filterTable.setDescription('A table of filter address pairs.')
filterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "filterDest"), (0, "REMOTEACCESS-MIB", "filterSource"))
if mibBuilder.loadTexts: filterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filterEntry.setDescription('A list of information for each filter pair.')
filterDest = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDest.setStatus('mandatory')
if mibBuilder.loadTexts: filterDest.setDescription('The destination Mac Address for the filter pair.')
filterSource = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSource.setStatus('mandatory')
if mibBuilder.loadTexts: filterSource.setDescription('The source Mac Address for the filter pair.')
filterPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: filterPrimary.setDescription('This is the primary entry of the filter pair.')
filterType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("permanent", 1), ("learned", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterType.setStatus('mandatory')
if mibBuilder.loadTexts: filterType.setDescription('This is a permanent not a learned entry. Set this to delete to delete the entry and its partner.')
filterRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterRoute.setStatus('mandatory')
if mibBuilder.loadTexts: filterRoute.setDescription('The link down which the destination is to be found.')
filterPacketcount = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPacketcount.setStatus('mandatory')
if mibBuilder.loadTexts: filterPacketcount.setDescription('The number of packets received by this destination from this source; may be reset to 0.')
filterBytecount = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterBytecount.setStatus('mandatory')
if mibBuilder.loadTexts: filterBytecount.setDescription('The number of bytes received by this destination from this source; may be reset to 0.')
filtertypeTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2), )
if mibBuilder.loadTexts: filtertypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeTable.setDescription('A table filter types.')
filtertypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "filtertypeIndex"))
if mibBuilder.loadTexts: filtertypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeEntry.setDescription('A list of types to filter on.')
filtertypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filtertypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeIndex.setDescription('The index of the type filter entry.')
filtertypeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ieee", 0), ("ethernet", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filtertypeClass.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeClass.setDescription('The entry class, or set to delete to remove.')
filtertypeLsap = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filtertypeLsap.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeLsap.setDescription('For ieee, this is in the range 0..255, For ethernet, in the range 0..65535.')
filtertypeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("edit", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filtertypeMode.setStatus('mandatory')
if mibBuilder.loadTexts: filtertypeMode.setDescription('The Operation Required')
filterAgingtime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterAgingtime.setStatus('mandatory')
if mibBuilder.loadTexts: filterAgingtime.setDescription('For learned entries, this gives the time in seconds after which the learned entries are discarded.')
filterLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterLearning.setStatus('mandatory')
if mibBuilder.loadTexts: filterLearning.setDescription('If disabled, this stops the bridge from learning new entries.')
filterActiononmatch = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("reject", 0), ("forward", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterActiononmatch.setStatus('mandatory')
if mibBuilder.loadTexts: filterActiononmatch.setDescription('If packet matches an entry in the filter table, reject or forward the packet.')
filterFiltermcast = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterFiltermcast.setStatus('mandatory')
if mibBuilder.loadTexts: filterFiltermcast.setDescription('If disabled, pass through multicast addresses unfiltered.')
filterTypematching = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTypematching.setStatus('mandatory')
if mibBuilder.loadTexts: filterTypematching.setDescription('If enabled, then check whether the Type/Lsap of the packet is in the type table before forwarding.')
filterTypematchaction = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("reject", 0), ("forward", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTypematchaction.setStatus('mandatory')
if mibBuilder.loadTexts: filterTypematchaction.setDescription('If type matching enabled, then reject or forward packets whose Lsap/Type are in the table.')
filterLearnsourceonmcast = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterLearnsourceonmcast.setStatus('mandatory')
if mibBuilder.loadTexts: filterLearnsourceonmcast.setDescription('If enabled, then learn source location from multicast packets.')
filterFlushall = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterFlushall.setStatus('mandatory')
if mibBuilder.loadTexts: filterFlushall.setDescription('If true, then the bridge will retire all learned entries.')
filterLearnnovell = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterLearnnovell.setStatus('mandatory')
if mibBuilder.loadTexts: filterLearnnovell.setDescription('If true, then the bridge will learn Novell server addresses and enter them into the autocall table.')
filterLearnbridging = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterLearnbridging.setStatus('mandatory')
if mibBuilder.loadTexts: filterLearnbridging.setDescription('Enables or disables bridging.')
authorisedTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3, 1), )
if mibBuilder.loadTexts: authorisedTable.setStatus('mandatory')
if mibBuilder.loadTexts: authorisedTable.setDescription('A table of bridges allowed to join the network.')
authorisedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "authorisedIndex"))
if mibBuilder.loadTexts: authorisedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: authorisedEntry.setDescription('A list of authorised bridges.')
authorisedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authorisedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: authorisedIndex.setDescription('The MAC address of an authorised bridge.')
authorisedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authorisedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: authorisedAddress.setDescription('The Mac Address of the bridge authorised to use the network.')
authorisedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("edit", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authorisedMode.setStatus('mandatory')
if mibBuilder.loadTexts: authorisedMode.setDescription('The Operation Required')
autocallMacTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2), )
if mibBuilder.loadTexts: autocallMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of MAC addresses.')
autocallMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallMacIndex"))
if mibBuilder.loadTexts: autocallMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacEntry.setDescription('A list of calls.')
autocallMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacIndex.setDescription('Index')
autocallMacDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacDefault.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacDefault.setDescription('Default MAC Autocall')
autocallMacBumpable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacBumpable.setDescription('Make autocall bumpable')
autocallMacIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacIdle.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacIdle.setDescription('Number of seconds this call can be idle before call is dropped.')
autocallMacIdleThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacIdleThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacIdleThreshold.setDescription('Idle is defined by the line being less than a certain activity. Full load is 1000. ')
autocallMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 6), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacAddress.setDescription('The MAC address.')
autocallMacIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacIsdn.setDescription('The ISDN telephone number to call.')
autocallMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallMacMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallMacMode.setDescription('The Operation Required')
autocallIpTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3), )
if mibBuilder.loadTexts: autocallIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of IP addresses.')
autocallIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallIpIndex"))
if mibBuilder.loadTexts: autocallIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpEntry.setDescription('A list of calls.')
autocallIpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallIpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpIndex.setDescription('Index')
autocallIpBumpable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpBumpable.setDescription('Make autocall bumpable')
autocallIpIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpIdle.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpIdle.setDescription('Number of seconds this call can be idle before call is dropped.')
autocallIpIdleThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpIdleThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpIdleThreshold.setDescription('Idle is defined by the line being less than a certain activity. Full load is 1000. ')
autocallIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpAddress.setDescription('The IP address.')
autocallIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpMask.setDescription('The IP mask.')
autocallIpInverse = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpInverse.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpInverse.setDescription('Make inverse autocall')
autocallIpIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpIsdn.setDescription('The ISDN telephone number to call.')
autocallIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpMode.setDescription('The Operation Required')
autocallIpxSapTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4), )
if mibBuilder.loadTexts: autocallIpxSapTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of IPX SAP addresses.')
autocallIpxSapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallIpxSapIndex"))
if mibBuilder.loadTexts: autocallIpxSapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapEntry.setDescription('A list of calls.')
autocallIpxSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallIpxSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapIndex.setDescription('Index')
autocallIpxSapServer = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapServer.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapServer.setDescription('The SAP server name.')
autocallIpxSapNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapNetwork.setDescription('The SAP network number.')
autocallIpxSapNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapNode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapNode.setDescription('The SAP node number.')
autocallIpxSapSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapSocket.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapSocket.setDescription('The SAP socket number.')
autocallIpxSapService = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapService.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapService.setDescription('The SAP service type.')
autocallIpxSapHops = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapHops.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapHops.setDescription('Number of hops. ')
autocallIpxSapIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapIsdn.setDescription('The ISDN telephone number to call.')
autocallIpxSapFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("etherII", 1), ("ieee8022", 2), ("ieee8023", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapFrameType.setDescription('The frame type.')
autocallIpxSapDirectNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapDirectNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapDirectNetwork.setDescription('The Direct network number.')
autocallIpxSapRouterMac = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 11), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapRouterMac.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapRouterMac.setDescription('The Router Mac.')
autocallIpxSapNearest = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapNearest.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapNearest.setDescription('In bridging mode, generate nearest server response for this server.')
autocallIpxSapPpp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapPpp.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapPpp.setDescription('PPP Mode.')
autocallIpxSapIsdnType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("lapb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapIsdnType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapIsdnType.setDescription('The ISDN type.')
autocallIpxSapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxSapMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxSapMode.setDescription('The Operation Required')
autocallIpxTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5), )
if mibBuilder.loadTexts: autocallIpxTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of IPX addresses.')
autocallIpxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallIpxIndex"))
if mibBuilder.loadTexts: autocallIpxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxEntry.setDescription('A list of calls.')
autocallIpxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallIpxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxIndex.setDescription('Index')
autocallIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxNetwork.setDescription('The network number.')
autocallIpxNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxNode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxNode.setDescription('The node number.')
autocallIpxPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxPacketType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxPacketType.setDescription('Packet Type.')
autocallIpxTransportControl = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxTransportControl.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxTransportControl.setDescription('Transport Control. ')
autocallIpxIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxIsdn.setDescription('The ISDN telephone number to call.')
autocallIpxBumpable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxBumpable.setDescription('Make autocall bumpable')
autocallIpxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxIdle.setDescription('Number of seconds this call can be idle before call is dropped.')
autocallIpxIdleThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxIdleThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxIdleThreshold.setDescription('Idle is defined by the line being less than a certain activity. Full load is 1000. ')
autocallIpxDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxDefault.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxDefault.setDescription('Default IPX Autocall')
autocallIpxFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("etherII", 1), ("ieee8022", 2), ("ieee8023", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxFrameType.setDescription('The frame type.')
autocallIpxPpp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxPpp.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxPpp.setDescription('PPP Mode.')
autocallIpxIsdnType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("lapb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxIsdnType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxIsdnType.setDescription('The ISDN type.')
autocallIpxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxMode.setDescription('The Operation Required')
autocallIpxRipTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6), )
if mibBuilder.loadTexts: autocallIpxRipTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of IPX RIP addresses.')
autocallIpxRipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallIpxRipIndex"))
if mibBuilder.loadTexts: autocallIpxRipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipEntry.setDescription('A list of calls.')
autocallIpxRipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallIpxRipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipIndex.setDescription('Index')
autocallIpxRipNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipNetwork.setDescription('The network number.')
autocallIpxRipHops = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipHops.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipHops.setDescription('Number of Hops. ')
autocallIpxRipTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipTicks.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipTicks.setDescription('Number of Ticks.')
autocallIpxRipNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipNode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipNode.setDescription('The node number.')
autocallIpxRipIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipIsdn.setDescription('The ISDN telephone number to call.')
autocallIpxRipFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("etherII", 1), ("ieee8022", 2), ("ieee8023", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipFrameType.setDescription('The frame type.')
autocallIpxRipDirectNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipDirectNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipDirectNetwork.setDescription('The Direct network number.')
autocallIpxRipRouterMac = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 9), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipRouterMac.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipRouterMac.setDescription('The Router Mac.')
autocallIpxRipLinkTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipLinkTicks.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipLinkTicks.setDescription('Number of Link Ticks.')
autocallIpxRipPpp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipPpp.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipPpp.setDescription('PPP Mode.')
autocallIpxRipIsdnType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("lapb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipIsdnType.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipIsdnType.setDescription('The ISDN type.')
autocallIpxRipMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallIpxRipMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallIpxRipMode.setDescription('The Operation Required')
autocallDialTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7), )
if mibBuilder.loadTexts: autocallDialTable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialTable.setDescription('A table of telephone numbers which are automatically dialled upon receipt of an ISDN call with a matching CLI response.')
autocallDialEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "autocallDialIndex"))
if mibBuilder.loadTexts: autocallDialEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialEntry.setDescription('A list of calls.')
autocallDialIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: autocallDialIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialIndex.setDescription('Index')
autocallDialCli = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialCli.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialCli.setDescription('The ISDN telephone number to match.')
autocallDialIsdn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialIsdn.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialIsdn.setDescription('The ISDN telephone number to call.')
autocallDialBumpable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialBumpable.setDescription('Make autocall bumpable')
autocallDialIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialIdle.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialIdle.setDescription('Number of seconds this call can be idle before call is dropped.')
autocallDialIdleThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialIdleThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialIdleThreshold.setDescription('Idle is defined by the line being less than a certain activity. Full load is 1000. ')
autocallDialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autocallDialMode.setStatus('mandatory')
if mibBuilder.loadTexts: autocallDialMode.setDescription('The Operation Required')
isdnbandsTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1), )
if mibBuilder.loadTexts: isdnbandsTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsTable.setDescription('A table of isdn timebands and their properties.')
isdnbandsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnbandsIndex"))
if mibBuilder.loadTexts: isdnbandsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsEntry.setDescription('A list of isdn timebands.')
isdnbandsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsIndex.setDescription('The index of this ISDN band.')
isdnbandsName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsName.setDescription('The name of this ISDN band.')
isdnbandsStarttime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsStarttime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsStarttime.setDescription('The start time in seconds since midnight.')
isdnbandsEndtime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsEndtime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsEndtime.setDescription('The end time in seconds since midnight.')
isdnbandsDays = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsDays.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsDays.setDescription('Days of the week assigned to this timeband, separated by colons. Use abbreviations : monday - Mo tuesday - Tu wednesday - We thursday - Th friday - Fr saturday - Sa sunday - Su eg saturday and sunday is Sa:Su .')
isdnbandsAllowbackup = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsAllowbackup.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsAllowbackup.setDescription('Allow isdn calls to be made to back up bridge links during this time.')
isdnbandsAllowdemand = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsAllowdemand.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsAllowdemand.setDescription('Allow isdn calls to be made for demand bandwidth during this time.')
isdnbandsAllowautocall = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsAllowautocall.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsAllowautocall.setDescription('Allow isdn calls to be made for autocalls during this time.')
isdnbandsAllowlist = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsAllowlist.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsAllowlist.setDescription('Allow isdn calls to be made to ISDN numbers on the list for this timeband during this time.')
isdnbandsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("edit", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsMode.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsMode.setDescription('The Operation Required')
isdnbandsBridgeListTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 2), )
if mibBuilder.loadTexts: isdnbandsBridgeListTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsBridgeListTable.setDescription('A table of isdn timebands and their properties.')
isdnbandsBridgeListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnbandsBridgeListIndex"))
if mibBuilder.loadTexts: isdnbandsBridgeListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsBridgeListEntry.setDescription('A list of isdn timebands.')
isdnbandsBridgeListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsBridgeListIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsBridgeListIndex.setDescription('The index of this ISDN band.')
isdnbandsBridgeListBandName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsBridgeListBandName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsBridgeListBandName.setDescription('The name of this ISDN band.')
isdnbandsBridgeListBridgeName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 2, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnbandsBridgeListBridgeName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnbandsBridgeListBridgeName.setDescription('The name of this ISDN band.')
isdnnumbersTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1), )
if mibBuilder.loadTexts: isdnnumbersTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersTable.setDescription('A table of isdn numbers against names.')
isdnnumbersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnnumbersIndex"))
if mibBuilder.loadTexts: isdnnumbersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersEntry.setDescription('A list of isdn numbers.')
isdnnumbersIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIndex.setDescription('The index of this ISDN number.')
isdnnumbersName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersName.setDescription('The name of this ISDN number.')
isdnnumbersNumber1 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersNumber1.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersNumber1.setDescription('The ISDN number (1).')
isdnnumbersNumber2 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersNumber2.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersNumber2.setDescription('The ISDN number (2).')
isdnnumbersNumber3 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersNumber3.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersNumber3.setDescription('The ISDN number (3).')
isdnnumbersNumber4 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnnumbersNumber4.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersNumber4.setDescription('The ISDN number (4).')
isdnnumbersCall = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("request", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersCall.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersCall.setDescription('If set to request, then call will be immediately made to this destination. Cancel will cancel any calls to this destination.')
isdnnumbersTesttime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersTesttime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersTesttime.setDescription('The time at which a test-call will be made (in seconds since midnight).')
isdnnumbersDays = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersDays.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersDays.setDescription('Days of the week on which testcalls will be made, separated by colons. Use abbreviations : monday - Mo tuesday - Tu wednesday - We thursday - Th friday - Fr saturday - Sa sunday - Su eg saturday and sunday is Sa:Su .')
isdnnumbersLasttest = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnnumbersLasttest.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersLasttest.setDescription('The Day/Month of the last successful testcall.')
isdnnumbersIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIpAddress.setDescription('The IP Address assigned to this port when routing is enabled.')
isdnnumbersIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIpMask.setDescription('The IP Address Mask assigned to this port when routing is enabled.')
isdnnumbersIpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIpMetric.setDescription('The IP routing metric assigned to this port when routing is enabled.')
isdnnumbersIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIpxNetwork.setDescription('The IPX Network Address assigned to this port when routing is enabled.')
isdnnumbersIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersIpxType.setDescription('The frame type used for IPX RIP and SAP messages emanating from this port.')
isdnnumbersPpp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersPpp.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersPpp.setDescription('Enable/Disable the PPP protocol for this number.')
isdnnumbersRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersRemoteIpAddress.setDescription('The IP Address for the remote unit.')
isdnnumbersRemoteUnitType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("any", 1), ("n3com", 2), ("cisco", 3), ("ascend", 4), ("spider", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersRemoteUnitType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersRemoteUnitType.setDescription('The remote unit type.')
isdnnumbersHdlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("synchronous", 1), ("lapb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersHdlcType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersHdlcType.setDescription('The HDLC link type.')
isdnnumbersPppAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3), ("both", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnnumbersPppAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersPppAuthentication.setDescription('The PPP negotiation status.')
isdnnumbersMaxCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersMaxCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersMaxCircuits.setDescription('The max number of ISDN Circuits (1 or 2).')
isdnnumbersMPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("enabled-short", 3), ("enabled-bacp", 4), ("enabled-short-bacp", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersMPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersMPEnable.setDescription('PPP Multilink.')
isdnnumbersLearntED = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnnumbersLearntED.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersLearntED.setDescription('Learnt endpoint descriminator.')
isdnnumbersMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("edit", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersMode.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersMode.setDescription('The Operation Required')
isdnnumbersCallType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unrestricted", 0), ("restricted", 1), ("v110", 2), ("speech", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersCallType1.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersCallType1.setDescription('')
isdnnumbersCallType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unrestricted", 0), ("restricted", 1), ("v110", 2), ("speech", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersCallType2.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersCallType2.setDescription('')
isdnnumbersCallType3 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unrestricted", 0), ("restricted", 1), ("v110", 2), ("speech", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersCallType3.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersCallType3.setDescription('')
isdnnumbersCallType4 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unrestricted", 0), ("restricted", 1), ("v110", 2), ("speech", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnnumbersCallType4.setStatus('mandatory')
if mibBuilder.loadTexts: isdnnumbersCallType4.setDescription('')
isdnportsTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1), )
if mibBuilder.loadTexts: isdnportsTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsTable.setDescription('A table of isdn ports.')
isdnportsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnportsIndex"))
if mibBuilder.loadTexts: isdnportsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsEntry.setDescription('A table of isdn ports.')
isdnportsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsIndex.setDescription('The physical port index, in the range 1 to number-of-ports, as found in the ports table.')
isdnportsDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsDestination.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsDestination.setDescription('The destination number that this ISDN number is connected to.')
isdnportsState = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 0), ("calling", 1), ("ringing", 2), ("connected", 3), ("answering", 4), ("answered", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsState.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsState.setDescription('Current state of the port')
isdnportsConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsConnTime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsConnTime.setDescription('The connection time (in hundredths of a second).')
isdnportsBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsBackup.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsBackup.setDescription('If set to true, then the call is a backup call.')
isdnportsDemand = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsDemand.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsDemand.setDescription('If set to true, then the call is a demand call.')
isdnportsBumpable = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsBumpable.setDescription('If set to true, then the call is a bumpable call.')
isdnportsAlert = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("alert", 1), ("beep", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsAlert.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsAlert.setDescription('current Alert State')
isdnportsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsPriority.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsPriority.setDescription('current call priority')
isdnportsSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 4, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnportsSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: isdnportsSourceMac.setDescription('Source Mac of Bridge that requested the call')
isdnhistoryTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1), )
if mibBuilder.loadTexts: isdnhistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryTable.setDescription('A table of isdn ports.')
isdnhistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnhistoryIndex"))
if mibBuilder.loadTexts: isdnhistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryEntry.setDescription('A table of isdn ports.')
isdnhistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnhistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryIndex.setDescription('The index of this ISDN history 1 to N.')
isdnhistoryDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnhistoryDestination.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryDestination.setDescription('The destination ISDN number.')
isdnhistoryTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnhistoryTotalTime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryTotalTime.setDescription('Total Time of all calls to this destination (in hundredths of a second)')
isdnhistoryTotalCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnhistoryTotalCalls.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryTotalCalls.setDescription('The total number of calls to this destination')
isdnhistoryFailedCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnhistoryFailedCalls.setStatus('mandatory')
if mibBuilder.loadTexts: isdnhistoryFailedCalls.setDescription('The total number of failed calls to this destination')
isdnCliTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6, 1), )
if mibBuilder.loadTexts: isdnCliTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCliTable.setDescription('A table of ISDN Numbers for bridges allowed to join the network.')
isdnCliEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnCliIndex"))
if mibBuilder.loadTexts: isdnCliEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCliEntry.setDescription('A list of ISDN Numbers for authorised bridges.')
isdnCliIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCliIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCliIndex.setDescription('The number of the entry.')
isdnCliNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCliNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCliNumber.setDescription('The ISDN number of the bridge authorised to use the network.')
isdnCliMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("edit", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCliMode.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCliMode.setDescription('The Operation Required')
isdnlistsTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7, 1), )
if mibBuilder.loadTexts: isdnlistsTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnlistsTable.setDescription('A table of isdn timeband bridge lists.')
isdnlistsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "isdnlistsIndex"))
if mibBuilder.loadTexts: isdnlistsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnlistsEntry.setDescription('A list of isdn bridge lists.')
isdnlistsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnlistsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnlistsIndex.setDescription('The index of this bridge.')
isdnlistsBand = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnlistsBand.setStatus('mandatory')
if mibBuilder.loadTexts: isdnlistsBand.setDescription('The timeband for this list. Set null-length string here to delete an entry.')
isdnlistsName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnlistsName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnlistsName.setDescription('The name of this bridge.')
isdnParamsNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("etsi", 1), ("nationalIsdn1", 2), ("att5essCustom", 3), ("germany1tr6", 4), ("australia", 5), ("italy", 6), ("germanyD64S", 7), ("usa-dms100", 8), ("japan-ins64", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsNetworkType.setDescription('ISDN Network Type. The device must be rebooted for a change of of this object to take effect.')
isdnParamsSpid1 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSpid1.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSpid1.setDescription('Service Profile ID 1 (USA Network Types only).')
isdnParamsSpid2 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSpid2.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSpid2.setDescription('Service Profile ID 2 (USA Network Types only).')
isdnParamsSpid3 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSpid3.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSpid3.setDescription('Service Profile ID 1 (2nd TA - USA Network Types only).')
isdnParamsSpid4 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSpid4.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSpid4.setDescription('Service Profile ID 2 (2nd TA - USA Network Types only).')
isdnParamsDirectoryNumber1 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsDirectoryNumber1.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsDirectoryNumber1.setDescription('Directory Number 1 (USA Network Types only).')
isdnParamsDirectoryNumber2 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsDirectoryNumber2.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsDirectoryNumber2.setDescription('Directory Number 2 (USA Network Types only).')
isdnParamsDirectoryNumber3 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsDirectoryNumber3.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsDirectoryNumber3.setDescription('Directory Number 3 (2nd TA for USA Network Types only).')
isdnParamsDirectoryNumber4 = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsDirectoryNumber4.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsDirectoryNumber4.setDescription('Directory Number 4 (2nd TA for USA Network Types only).')
isdnParamsReportBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsReportBusy.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsReportBusy.setDescription('Send a positibe Busy reponse to an incoming call if no free port.')
isdnParamsIncomingDov = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("answer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsIncomingDov.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsIncomingDov.setDescription('Should an incoming voice call be answerred as a data call.')
isdnParamsMaxCallTime = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsMaxCallTime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsMaxCallTime.setDescription('Maximum Call time in seconds.')
isdnParamsMsn = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 13))
isdnParamsMsnLan = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 13, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsMsnLan.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsMsnLan.setDescription('Multiple Subscriber Number for LAN access.')
isdnParamsMsnVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 13, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsMsnVoice.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsMsnVoice.setDescription('Multiple Subscriber Number for Voice access.')
isdnParamsMsnCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 13, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsMsnCheck.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsMsnCheck.setDescription('Should the incoming MSN be checked before answerring an incoming call.')
isdnParamsMsnSend = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsMsnSend.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsMsnSend.setDescription('Should the MSN be sent in outgoing calls.')
isdnParamsSubAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14))
isdnParamsSubAddrLan = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSubAddrLan.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSubAddrLan.setDescription('Sub Address for LAN access.')
isdnParamsSubAddrVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSubAddrVoice.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSubAddrVoice.setDescription('Sub Address for Voice access.')
isdnParamsSubAddrCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSubAddrCheck.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSubAddrCheck.setDescription('Should the incoming Sub Address be checked before answerring an incoming call.')
isdnParamsSubAddrSend = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSubAddrSend.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSubAddrSend.setDescription('Should the Sub Address be sent in outgoing calls.')
isdnParamsSubAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nsap", 1), ("user", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsSubAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsSubAddrType.setDescription('What format should outgoing an Sub Address take.')
isdnParamsTokenValue = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsTokenValue.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsTokenValue.setDescription('ISDN time token value. When tokens are refilled, the isdnParamsTokenRemain variable is set to this value NOTE: -1 = disabled')
isdnParamsTokenRefill = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("manual", 1), ("auto", 2), ("refill", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnParamsTokenRefill.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsTokenRefill.setDescription("ISDN token Refill Mechanism type - 'disabled' No token mechanism. - 'manual' left for user to refill tokens manually. - 'auto' reset the tokens every day at 23:59.59 - 'refill' refills the tokens. NOTE: In order to set 'manuall and 'auto', isdnParamsTokenRemain must not be -1 (disabled)")
isdnParamsTokenRemain = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 8, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnParamsTokenRemain.setStatus('mandatory')
if mibBuilder.loadTexts: isdnParamsTokenRemain.setDescription('Displays the remaining number of ISDN tokens left for ISDN usage. NOTE: -1 = disabled')
bootpActive = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpActive.setStatus('mandatory')
if mibBuilder.loadTexts: bootpActive.setDescription('TRUE if BOOTP/DHCP broadcasts are to be bridged (when box is in bridge mode). TRUE if BOOTP/DHCP relay agent is to be active (when box is in router mode). If set, then DHCP Proxy and DHCP Server will be silent disabled.')
bootpBumpable = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpBumpable.setStatus('mandatory')
if mibBuilder.loadTexts: bootpBumpable.setDescription('(Bridge mode only) If we receive an autocall to another destination and no free channels, bump this call.')
bootpIdle = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIdle.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIdle.setDescription('(Bridge mode only) Number of seconds this call can be idle before call is dropped.')
bootpIdleThreshold = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIdleThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIdleThreshold.setDescription('(Bridge mode only) Idle is defined by the line being less than a certain activity. Full load is 1000. ')
bootpIsdnName = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIsdnName.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIsdnName.setDescription('(Bridge mode only) The name of the ISDN telephone number entry to be called.')
bootpAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bootpAddress.setDescription('(Router mode only) The IP Address of the BOOTP/DHCP server. Format: xxx.xxx.xxx.xxx .')
bootpDelaySecs = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpDelaySecs.setStatus('mandatory')
if mibBuilder.loadTexts: bootpDelaySecs.setDescription('(Bridge mode or Router Mode) The age in seconds of a BOOTP/DHCP message after which the bridge or relay starts doing anything. Zero means no delay.')
dhcpProxyActive = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpProxyActive.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpProxyActive.setDescription('TRUE if the DHCP proxy is enabled. If set, then DHCP Relay and DHCP Server will be silent disabled.')
referenceAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: referenceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: referenceAddress.setDescription('(Router mode only) The refernece IP Address (giaddr) for the pool. Format: xxx.xxx.xxx.xxx .')
minPoolSize = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 3, 4, 9, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: minPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: minPoolSize.setDescription('The minimum number of addresses in the pool.')
isdnFailDestination = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnFailDestination.setStatus('mandatory')
if mibBuilder.loadTexts: isdnFailDestination.setDescription('Containins the ISDN destination dialled to cause the call to fail')
q931FailCauseCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16, 17, 18, 19, 21, 22, 27, 38, 41, 42, 84, 86, 88, 145))).clone(namedValues=NamedValues(("unallocatedNumber", 1), ("normalCallClearing", 16), ("userBusy", 17), ("noUserResponding", 18), ("noAnswerFromUser", 19), ("callRejected", 21), ("numberChanged", 22), ("destinationOutOfOrder", 27), ("networkOutOfOrder", 38), ("temporaryFailure", 41), ("switchingEquipmentCongestion", 42), ("callIdentityInUse", 84), ("requestedCallIdentityCleared", 86), ("incompatibleDestination", 88), ("dlFailureLineBroken", 145)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q931FailCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: q931FailCauseCode.setDescription('Contains the cause of a failed Q931 ISDN call')
dass2FailCauseCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 30, 31, 32, 45, 46, 48))).clone(namedValues=NamedValues(("numberUnobtainable0", 0), ("numberIncomplete", 1), ("cleared2", 2), ("numberUnobtainable3", 3), ("numberUnobtainable4", 4), ("userHasChangedNumber", 5), ("networkBusy", 7), ("numberBusy", 8), ("lineOutOfService", 9), ("numberUnobtainable10", 10), ("accessBarred", 11), ("numberUnobtainable30", 30), ("noReply", 31), ("serviceTermination", 32), ("terminalUnavailable45", 45), ("terminalUnavailable46", 46), ("cleared48", 48)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dass2FailCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: dass2FailCauseCode.setDescription('Contains the cause of a failed DASS2 ISDN call')
briFailCauseCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briFailCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: briFailCauseCode.setDescription('Contains the cause of a failed DASS2 ISDN call')
radiusReplyCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("radauthreject", 0), ("radauthnoresponse", 1), ("radauthreadonly", 2), ("radauthreadwrite", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radiusReplyCode.setStatus('mandatory')
if mibBuilder.loadTexts: radiusReplyCode.setDescription('Contains the result of a call to RADIUS.')
radiusUsername = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radiusUsername.setStatus('mandatory')
if mibBuilder.loadTexts: radiusUsername.setDescription('This is the username authenticated by RADIUS.')
loginCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("authreject", 0), ("authok", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: loginCode.setStatus('mandatory')
if mibBuilder.loadTexts: loginCode.setDescription('Contains the result of a login after no RADIUS server can be found.')
cscmEventNumber = MibScalar((1, 3, 6, 1, 4, 1, 559, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 100, 101, 102, 103, 104, 105, 1000, 1001, 1016, 1017, 1018, 1019, 1021, 1022, 1027, 1038, 1041, 1042, 1084, 1086, 1088, 1145, 1200, 1201, 1202, 1203, 1204, 1205, 1207, 1208, 1209, 1210, 1211, 1230, 1231, 1232, 1245, 1246, 1248))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2), ("isdnConnection", 3), ("isdnDisconnection", 4), ("pollFailure", 100), ("pollSuccess", 101), ("dailyThresholdExceeded", 102), ("hourlyThresholdExceeded", 103), ("maxCallLengthExceeded", 104), ("testPollFailure", 105), ("q931failure1000", 1000), ("q931unallocatedNumber", 1001), ("q931normalCallClearing", 1016), ("q931userBusy", 1017), ("q931noUserResponding", 1018), ("q931noAnswerFromUser", 1019), ("q931callRejected", 1021), ("q931numberChanged", 1022), ("q931destinationOutOfOrder", 1027), ("q931networkOutOfOrder", 1038), ("q931temporaryFailure", 1041), ("q931switchingEquipmentCongestion", 1042), ("q931callIdentityInUse", 1084), ("q931requestedCallIdentityCleared", 1086), ("q931incompatibleDestination", 1088), ("q931dlFailureLineBroken", 1145), ("dass2numberUnobtainable0", 1200), ("dass2numberIncomplete", 1201), ("dass2cleared2", 1202), ("dass2numberUnobtainable3", 1203), ("dass2numberUnobtainable4", 1204), ("dass2userHasChangedNumber", 1205), ("dass2networkBusy", 1207), ("dass2numberBusy", 1208), ("dass2lineOutOfService", 1209), ("dass2numberUnobtainable10", 1210), ("dass2accessBarred", 1211), ("dass2numberUnobtainable30", 1230), ("dass2noReply", 1231), ("dass2serviceTermination", 1232), ("dass2terminalUnavailable45", 1245), ("dass2terminalUnavailable46", 1246), ("dass2cleared48", 1248)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cscmEventNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cscmEventNumber.setDescription('Contains the CSCM event number')
cscmOriginatingIP = MibScalar((1, 3, 6, 1, 4, 1, 559, 3, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cscmOriginatingIP.setStatus('mandatory')
if mibBuilder.loadTexts: cscmOriginatingIP.setDescription('This is the IP address of the unit that caused the trap to be generated by CSCM')
cscmTrapDetail = MibScalar((1, 3, 6, 1, 4, 1, 559, 3, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cscmTrapDetail.setStatus('mandatory')
if mibBuilder.loadTexts: cscmTrapDetail.setDescription('This is the IP address of the unit that caused the trap to be generated by CSCM')
alarmCode = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("failed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmCode.setStatus('mandatory')
if mibBuilder.loadTexts: alarmCode.setDescription('Error code for reported Alarm trap event.')
alarmText = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmText.setStatus('mandatory')
if mibBuilder.loadTexts: alarmText.setDescription('Explanatory text describing the event which caused the Alarm trap to be generated.')
ipInRipRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInRipRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipInRipRequests.setDescription('The number of IP RIP datagram requests received.')
ipInRipResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInRipResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipInRipResponses.setDescription('The number of IP RIP datagram responses received.')
ipInRipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInRipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipInRipErrors.setDescription('The number of IP RIP datagrams discarded due to some error other than insufficient resources.')
ipInRipDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInRipDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipInRipDiscards.setDescription('The number of IP RIP datagrams discarded due to insufficient resources.')
ipOutRipRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRipRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRipRequests.setDescription('The number of IP RIP datagram requests transmitted.')
ipOutRipResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRipResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRipResponses.setDescription('The number of IP RIP datagram responses transmitted.')
ipOutRipUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRipUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRipUpdates.setDescription('The number of IP RIP datagrams transmitted due to the detection of a network configuration change.')
ipOutRipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRipErrors.setDescription('The number of IP RIP datagrams discarded due to some error other than insufficient resources.')
ipOutRipDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutRipDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipOutRipDiscards.setDescription('The number of IP RIP datagrams discarded due to insufficient resources.')
ipRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 8, 9))).clone(namedValues=NamedValues(("rip", 1), ("rip2", 2), ("ripFixedMask", 8), ("ripExtended", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRoutingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipRoutingProtocol.setDescription('The IP routing protocol used.')
ipRipLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRipLearning.setStatus('mandatory')
if mibBuilder.loadTexts: ipRipLearning.setDescription('When enabled the RIP Table will be updated. This is only applicable to dial-up links.')
ipRoutingAdvertise = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("lan", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRoutingAdvertise.setStatus('mandatory')
if mibBuilder.loadTexts: ipRoutingAdvertise.setDescription('The interface that all rips are transmitted on.')
ipRouteTableCopy = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2), )
if mibBuilder.loadTexts: ipRouteTableCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteTableCopy.setDescription("This entity's IP Routing table.")
ipRouteEntryCopy = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipRouteDestCopy"))
if mibBuilder.loadTexts: ipRouteEntryCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteEntryCopy.setDescription('A route to a particular destination.')
ipRouteDestCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteDestCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteDestCopy.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered an unnumbered route. Unnumbered routes are differentiated by their Destination Route Name entries. Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
ipRouteIfIndexCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteIfIndexCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteIfIndexCopy.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ipRouteMetric1Copy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric1Copy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric1Copy.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric2Copy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric2Copy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric2Copy.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric3Copy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric3Copy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric3Copy.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric4Copy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric4Copy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric4Copy.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteNextHopCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteNextHopCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteNextHopCopy.setDescription("The IP address of the next hop of this route. (In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IP address on that interface.)")
ipRouteTypeCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteTypeCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteTypeCopy.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the IP architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively dissasociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
ipRouteProtoCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is-is", 9), ("es-is", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteProtoCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteProtoCopy.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
ipRouteAgeCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteAgeCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteAgeCopy.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipRouteMaskCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMaskCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMaskCopy.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipRouteMask by determining whether the value of the correspondent ipRouteDest field belong to a class-A, B, or C network, and then using one of: mask network 255.0.0.0 class-A 255.255.0.0 class-B 255.255.255.0 class-C If the value of the ipRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0. It should be noted that all IP routing subsystems implicitly use this mechanism.')
ipRouteMetric5Copy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric5Copy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteMetric5Copy.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteInfoCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoCopy.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteInfoCopy.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's ipRouteProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.")
ipRouteNextHopName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteNextHopName.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteNextHopName.setDescription('A unique name for the next hop for an unnumbered route. If the IP address of the next hop is 0.0.0.0 it is taken to be the default route if this string is NULL, or an unnumbered link to the named interface if not.')
ipRouteAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 25, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteAdvertise.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouteAdvertise.setDescription('Whether or not this route should be advertised')
ipxInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInReceives.setDescription('The number of IPX datagrams received on all interfaces including those received in error.')
ipxInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInDelivers.setDescription('The number of IPX datagrams delivered to this management entity.')
ipxInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInDiscards.setDescription('The number of IPX datagrams discarded due to insufficient resources.')
ipxInUnknownProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInUnknownProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInUnknownProtocols.setDescription('The number of IPX datagrams discardrd due to unknown or unsupported protocols.')
ipxInHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInHeaderErrors.setDescription('The number of IPX datagrams recieved and discarded due to errors detected in the IPX header.')
ipxForwardDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxForwardDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ipxForwardDatagrams.setDescription('The number of received IPX datagrams not addressed to the IPX Router, which the router will attempt to forward.')
ipxOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRequests.setDescription('The number of datagrams supplied to IPX by local user protocols.')
ipxOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutNoRoutes.setDescription('The number of datagrams discarded because no route could be found to transmit them to their destination.')
ipxOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutDiscards.setDescription('The number of IPX datagrams discarded because no resource could be found to allow transmission.')
ipxForwarding = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-forwarding", 1), ("forwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: ipxForwarding.setDescription('The indication as to whether this entity is acting as a Router.')
ipxInRipRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInRipRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInRipRequests.setDescription('The number of IPX RIP datagram requests received.')
ipxInRipResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInRipResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInRipResponses.setDescription('The number of IPX RIP datagram responses received.')
ipxInRipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInRipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInRipErrors.setDescription('The number of IPX RIP datagrams discarded due to some error other than insufficient resources.')
ipxInRipTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInRipTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInRipTimeouts.setDescription('The number of times IPX RIP datagrams have been expected but have not been received.')
ipxInRipDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInRipDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInRipDiscards.setDescription('The number of IPX RIP datagrams discarded due to insufficient resources.')
ipxOutRipRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRipRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRipRequests.setDescription('The number of IPX RIP datagram requests transmitted.')
ipxOutRipResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRipResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRipResponses.setDescription('The number of IPX RIP datagram responses transmitted.')
ipxOutRipUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRipUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRipUpdates.setDescription('The number of IPX RIP datagrams transmitted due to the detection of a network configuration change.')
ipxOutRipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRipErrors.setDescription('The number of IPX RIP datagrams discarded due to some error other than insufficient resources.')
ipxOutRipDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 11, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutRipDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutRipDiscards.setDescription('The number of IPX RIP datagrams discarded due to insufficient resources.')
ipxRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1), )
if mibBuilder.loadTexts: ipxRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRoutingTable.setDescription('The IPX Routing Table.')
ipxRoutingTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipxRouteTarget"))
if mibBuilder.loadTexts: ipxRoutingTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRoutingTableEntry.setDescription('Information about a routing table entry.')
ipxRouteTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRouteTarget.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteTarget.setDescription('The IPX network number of the destination network.')
ipxRouteHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteHopCount.setDescription('The number of hops necessary to reach the destination network. This count includes the additional count required to reach the destination network through this route.')
ipxRouteTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteTicks.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteTicks.setDescription('The delay in ticks to reach the destination network. This count includes the additional count required to reach the destination network through this route.')
ipxRouteNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteNextHopNetwork.setDescription('The IPX Network Address of the next route on the path to the target network.')
ipxRouteNextHopNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteNextHopNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteNextHopNode.setDescription('The IPX Node Address of the next router on the path to the target network.')
ipxRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("remote", 1), ("local", 2), ("alternate", 3), ("equal", 4), ("autocall", 5), ("permanent", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteType.setDescription('Identifies the source of the learnt entry: remote - from the WAN. local - from the LAN. alternate - identifies an entry specifying an alternate, but less desireable route to a known destintion. equal - identifies an entry specifying an alternative route to a known destination. autocall - from the ISDN Autocall table. permanent - identifies a permanent entry. The only valid set request is to make a route permanent.')
ipxRoutePort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRoutePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRoutePort.setDescription('The name of the logical port through which IPX datagrams will be forwarded towards the destination network.')
ipxRouteLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("hdlc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteLinkType.setDescription('The link protocol of the logical port through which IPX datagrams will be forwarded towards the destination network.')
ipxRouteIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteIpxType.setDescription('The frame type for IPX RIP messages.')
ipxRouteLinkTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteLinkTicks.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteLinkTicks.setDescription('The additional count required to reach the destination network through this route.')
ipxRouteMlink = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteMlink.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteMlink.setDescription('The MLINK through which datagrams will be forwarded towards the destination network.')
ipxRouteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 12, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouteMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouteMode.setDescription('The Operation Required')
ipxInSapRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInSapRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInSapRequests.setDescription('The number of IPX SAP datagram updates received.')
ipxInSapResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInSapResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInSapResponses.setDescription('The number of IPX SAP datagram queries received.')
ipxInSapNoServers = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInSapNoServers.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInSapNoServers.setDescription('The number of IPX datagrams received indicating that no Servers are available.')
ipxInSapErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInSapErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInSapErrors.setDescription('The number of IPX SAP datagrams discarded due to some error other than insufficient resources.')
ipxInSapDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInSapDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInSapDiscards.setDescription('The number of IPX SAP datagrams discarded due to insufficient resources.')
ipxOutSapRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutSapRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutSapRequests.setDescription('The number of IPX SAP datagram updates transmitted.')
ipxOutSapResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutSapResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutSapResponses.setDescription('The number of IPX SAP datagram replies transmitted.')
ipxOutSapErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutSapErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutSapErrors.setDescription('The number of IPX SAP datagrams discarded due to some error other than insufficient resources.')
ipxOutSapDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 13, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutSapDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutSapDiscards.setDescription('The number of IPX SAP datagrams discarded due to insufficient resources.')
ipxServicesTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1), )
if mibBuilder.loadTexts: ipxServicesTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServicesTable.setDescription('The IPX Services Table.')
ipxServicesTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipxServiceNode"), (0, "REMOTEACCESS-MIB", "ipxServiceSocket"))
if mibBuilder.loadTexts: ipxServicesTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServicesTableEntry.setDescription('Information about a services table entry.')
ipxServiceNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceNetwork.setDescription('The IPX network number portion of the IPX Address of this server.')
ipxServiceNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxServiceNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceNode.setDescription('The IPX node number portion of the IPX Address of this server.')
ipxServiceSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxServiceSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceSocket.setDescription('The IPX socket through which this server is advertising.')
ipxServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceName.setDescription('The name of this server.')
ipxServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceType.setDescription('The type of service offered by this server.')
ipxServiceHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceHopCount.setDescription('The number of hops necessary to reach this server. This count will include the additional count required to reach the server through this route.')
ipxServicePort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxServicePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServicePort.setDescription('The name of the logical port through which the server is reachable.')
ipxServiceNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceNextHopNetwork.setDescription('The IPX Network Address of the next route on the path to the target network.')
ipxServiceNextHopNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 9), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceNextHopNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceNextHopNode.setDescription('The IPX Node Address of the next router on the path to the target network.')
ipxServiceIpxType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee802dot2", 2), ("novell802dot3", 3), ("snap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceIpxType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceIpxType.setDescription('The frame type for IPX SAP messages.')
ipxServiceRTType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("remote", 1), ("local", 2), ("alternate", 3), ("equal", 4), ("autocall", 5), ("permanent", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceRTType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceRTType.setDescription('Identifies the source of the learnt entry: remote - from the WAN. local - from the LAN. alternate - identifies an entry specifying an alternate, but less desireable route to a known destintion. equal - identifies an entry specifying an alternative route to a known destination. autocall - from the ISDN Autocall table. permanent - identifies a permanent entry. The only valid set request is to make an entry permanent.')
ipxServiceLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("hdlc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceLinkType.setDescription('The link protocol of the logical port through which IPX datagrams will be forwarded towards the destination network.')
ipxServiceMlink = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceMlink.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceMlink.setDescription('The MLINK through which datagrams will be forwarded towards the destination network.')
ipxServiceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 14, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServiceMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServiceMode.setDescription('The Operation Required')
ipxNearest = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inclusive", 1), ("exclusive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNearest.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearest.setDescription('The indication as to whether the Nearest Servers list is inclusive or exclusive.')
ipxNearestTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 2), )
if mibBuilder.loadTexts: ipxNearestTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearestTable.setDescription('The IPX Nearest Table.')
ipxNearestTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipxNearestIndex"))
if mibBuilder.loadTexts: ipxNearestTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearestTableEntry.setDescription('Information about a services table entry.')
ipxNearestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNearestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearestIndex.setDescription('The index of this entry.')
ipxNearestServer = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNearestServer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearestServer.setDescription('The IPX servers in the IPX Nearest table.')
ipxNearestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 26, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNearestMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNearestMode.setDescription('The Operation Required')
pppExtLcpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1), )
if mibBuilder.loadTexts: pppExtLcpConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpConfigTable.setDescription('The PPP Extended LCP Table')
pppExtLcpConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppExtLcpConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpConfigTableEntry.setDescription('Information about a LCP extension table entry.')
pppExtLcpLocalProtocolCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalProtocolCompression.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalProtocolCompression.setDescription('LCP Protocol Compression')
pppExtLcpLocalAddressCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalAddressCompression.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalAddressCompression.setDescription('LCP Address Compression')
pppExtLcpRemoteMRU = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteMRU.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteMRU.setDescription('LCP Remote MRU')
pppExtLcpRemoteProtocolCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteProtocolCompression.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteProtocolCompression.setDescription('LCP Protocol Compression')
pppExtLcpRemoteAddressCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteAddressCompression.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteAddressCompression.setDescription('LCP Address Compression')
pppExtLcpMinimumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpMinimumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpMinimumRestartPeriod.setDescription('Minimum Restart Period')
pppExtLcpMaximumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpMaximumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpMaximumRestartPeriod.setDescription('Maximum Restart Period')
pppExtLcpMaximumTerminateRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpMaximumTerminateRequests.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpMaximumTerminateRequests.setDescription('Maximum Terminate Requests')
pppExtLcpMaximumConfigRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpMaximumConfigRequests.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpMaximumConfigRequests.setDescription('Maximum Configure Requests')
pppExtLcpMaximumConfigNaks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpMaximumConfigNaks.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpMaximumConfigNaks.setDescription('Maximum Configure Naks')
pppExtLcpLocalMRU = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalMRU.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalMRU.setDescription('LCP Local MRU')
pppExtLcpLocalMagic = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalMagic.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalMagic.setDescription('LCP Local Magic Number')
pppExtLcpRemoteMagic = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteMagic.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteMagic.setDescription('LCP Remote Magic Number')
pppExtLcpLocalMRUEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalMRUEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalMRUEnabled.setDescription('LCP Local MRU Enabled')
pppExtLcpRemoteMRUEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteMRUEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteMRUEnabled.setDescription('LCP Remote MRU Enabled')
pppExtLcpLocalACCM = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalACCM.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalACCM.setDescription('LCP Local Accm')
pppExtLcpRemoteACCM = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteACCM.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteACCM.setDescription('LCP Remote Accm')
pppExtLcpLocalACCMEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalACCMEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalACCMEnabled.setDescription('LCP Local Accm Enabled')
pppExtLcpRemoteACCMEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteACCMEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteACCMEnabled.setDescription('LCP Remote Accm Enabled')
pppExtLcpLocalPAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("incoming", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalPAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalPAPEnabled.setDescription('LCP Local PAP Enabled')
pppExtLcpRemotePAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemotePAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemotePAPEnabled.setDescription('LCP Remote PAP Enabled')
pppExtLcpLocalCHAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpLocalCHAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpLocalCHAPEnabled.setDescription('LCP Local CHAP Enabled')
pppExtLcpRemoteCHAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLcpRemoteCHAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLcpRemoteCHAPEnabled.setDescription('LCP Remote CHAP Enabled')
pppEchoConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 2), )
if mibBuilder.loadTexts: pppEchoConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppEchoConfigTable.setDescription('The PPP LCP Echo Table')
pppEchoConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppEchoConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppEchoConfigTableEntry.setDescription('Information about a LCP Echo table entry.')
pppEchoPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppEchoPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pppEchoPeriod.setDescription('LCP Echo Period')
pppEchoMaxNumberRetransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppEchoMaxNumberRetransmits.setStatus('mandatory')
if mibBuilder.loadTexts: pppEchoMaxNumberRetransmits.setDescription('Maximum number LCP Echos sent with reply before link is closed. Zero disables echos.')
pppIpcpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3), )
if mibBuilder.loadTexts: pppIpcpConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppIpcpConfigTable.setDescription('The PPP IPCP Config Table')
pppIpcpConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppIpcpConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppIpcpConfigTableEntry.setDescription('Information about a IPCP table entry.')
ipcpLocalIPAddressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpLocalIPAddressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpLocalIPAddressNegotiation.setDescription('IPCP Local IP Address Negotiation Mask')
ipcpRemoteIPAddressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpRemoteIPAddressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpRemoteIPAddressNegotiation.setDescription('IPCP Remote IP Address Negotiation Mask')
ipcpRemoteCompressionNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("van-jacobson", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpRemoteCompressionNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpRemoteCompressionNegotiation.setDescription('IPCP Remote Compression Protocol')
ipcpMinimumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpMinimumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpMinimumRestartPeriod.setDescription('Minimum Restart Period')
ipcpMaximumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpMaximumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpMaximumRestartPeriod.setDescription('Maximum Restart Period')
ipcpMaximumTerminateRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpMaximumTerminateRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpMaximumTerminateRequests.setDescription('Maximum Terminate Requests')
ipcpMaximumConfigRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpMaximumConfigRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpMaximumConfigRequests.setDescription('Maximum Configure Requests')
ipcpMaximumConfigNaks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpMaximumConfigNaks.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpMaximumConfigNaks.setDescription('Maximum Configure Naks')
ipcpLocalCompressionNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("van-jacobson", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpLocalCompressionNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpLocalCompressionNegotiation.setDescription('IPCP Local Compression Protocol')
ipcpRfc1172Negotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipcpRfc1172Negotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipcpRfc1172Negotiation.setDescription('IPCP RFC1172 Negotiation')
pppIpxcpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4), )
if mibBuilder.loadTexts: pppIpxcpConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppIpxcpConfigTable.setDescription('The PPP IPXCP Config Table')
pppIpxcpConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppIpxcpConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppIpxcpConfigTableEntry.setDescription('Information about a IPXCP table entry.')
ipxcpLocalNetworkNumberNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpLocalNetworkNumberNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpLocalNetworkNumberNegotiation.setDescription('IPXCP Local Network Number Negotiation Mask')
ipxcpLocalNodeNumberNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpLocalNodeNumberNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpLocalNodeNumberNegotiation.setDescription('IPXCP Local Node Number Negotiation Mask')
ipxcpLocalRoutingProtocolNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rip-sap", 2), ("any", 3), ("default", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpLocalRoutingProtocolNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpLocalRoutingProtocolNegotiation.setDescription('IPXCP Local Routing Protocol Negotiation Mask')
ipxcpLocalRouterNameNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpLocalRouterNameNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpLocalRouterNameNegotiation.setDescription('IPXCP Local Router Name Negotiation Mask')
ipxcpRemoteNetworkNumberNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpRemoteNetworkNumberNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpRemoteNetworkNumberNegotiation.setDescription('IPXCP Remote Network Number Negotiation Mask')
ipxcpRemoteNodeNumberNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpRemoteNodeNumberNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpRemoteNodeNumberNegotiation.setDescription('IPXCP Remote Node Number Negotiation Mask')
ipxcpRemoteRoutingProtocolNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rip-sap", 2), ("any", 3), ("default", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpRemoteRoutingProtocolNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpRemoteRoutingProtocolNegotiation.setDescription('IPXCP Remote Routing Protocol Negotiation Mask')
ipxcpRemoteRouterNameNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpRemoteRouterNameNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpRemoteRouterNameNegotiation.setDescription('IPXCP Remote Router Name Negotiation Mask')
ipxcpConfigCompleteNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpConfigCompleteNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpConfigCompleteNegotiation.setDescription('IPXCP Configure Complete Negotiation Mask')
ipxcpAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opened", 1), ("closed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpAdmin.setDescription('IPXCP Admin Status. Inject OPEN or CLOSE event into the IPXCP state machine.')
ipxcpMinimumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpMinimumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpMinimumRestartPeriod.setDescription('Minimum Restart Period')
ipxcpMaximumRestartPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpMaximumRestartPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpMaximumRestartPeriod.setDescription('Maximum Restart Period')
ipxcpMaximumTerminateRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpMaximumTerminateRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpMaximumTerminateRequests.setDescription('Maximum Terminate Requests')
ipxcpMaximumConfigRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpMaximumConfigRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpMaximumConfigRequests.setDescription('Maximum Configure Requests')
ipxcpMaximumConfigNaks = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpMaximumConfigNaks.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpMaximumConfigNaks.setDescription('Maximum Configure Naks')
ipxcpNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 4, 1, 16), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxcpNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxcpNodeNumber.setDescription('The MAC address of the local node.')
pppExtConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5), )
if mibBuilder.loadTexts: pppExtConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtConfigTable.setDescription('The PPP Ext Config Table')
pppExtConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppExtConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtConfigTableEntry.setDescription('Information about a PPP Ext table entry.')
pppExtLinkAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtLinkAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtLinkAuthentication.setDescription('Link Authentication.')
pppExtEnableIp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtEnableIp.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtEnableIp.setDescription('Pass IP frames over the link.')
pppExtEnableIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtEnableIpx.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtEnableIpx.setDescription('Pass IPX frames over the link.')
pppExtHdlcLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 27, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("synchronous", 1), ("lapb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppExtHdlcLayer.setStatus('mandatory')
if mibBuilder.loadTexts: pppExtHdlcLayer.setDescription('The HDLC link type.')
ipFirewallStatusTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 1), )
if mibBuilder.loadTexts: ipFirewallStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallStatusTable.setDescription('The IP Firewall Status Table')
ipFirewallStatusTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipFirewallStatusIndex"))
if mibBuilder.loadTexts: ipFirewallStatusTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallStatusTableEntry.setDescription('Information about an IP firewall status table entry.')
ipFirewallStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFirewallStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallStatusIndex.setDescription('Index')
ipFirewallFilteredPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFirewallFilteredPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallFilteredPackets.setDescription('The number of packets matching this entry')
ipFirewallConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2), )
if mibBuilder.loadTexts: ipFirewallConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallConfigTable.setDescription('The IP Firewall Table')
ipFirewallConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipFirewallConfigIndex"))
if mibBuilder.loadTexts: ipFirewallConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallConfigTableEntry.setDescription('Information about an IP firewall table entry.')
ipFirewallConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFirewallConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallConfigIndex.setDescription('Index')
ipFirewallSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallSourceAddress.setDescription('The IP Firewall Source Address')
ipFirewallSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallSourceMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallSourceMask.setDescription('The IP Firewall Source Mask')
ipFirewallLowerSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallLowerSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallLowerSourcePort.setDescription('The Source port or the lower number of a range of source ports.')
ipFirewallHigherSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallHigherSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallHigherSourcePort.setDescription('The upper number of a range of source ports.')
ipFirewallDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallDestinationAddress.setDescription('The IP Firewall Destination Address')
ipFirewallDestinationMask = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallDestinationMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallDestinationMask.setDescription('The IP Firewall Destination Mask')
ipFirewallLowerDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallLowerDestinationPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallLowerDestinationPort.setDescription('The Destination port or the lower number of a range of destination ports.')
ipFirewallHigherDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallHigherDestinationPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallHigherDestinationPort.setDescription('The upper number of a range of destination ports.')
ipFirewallRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallRouterName.setDescription('The Router name to which frames are forwarded.')
ipFirewallMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("insert", 2), ("append", 3), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallMode.setDescription('The Operation Required')
ipFirewallType = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("tcp", 3), ("udp", 4), ("icmp", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallType.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallType.setDescription('The type of filtering required')
ipFirewallAction = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallAction.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallAction.setDescription('Accept or Deny the frame')
ipFirewallBidir = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallBidir.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallBidir.setDescription('Apply to bidirectional traffic')
ipFirewallTcpsyn = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFirewallTcpsyn.setStatus('mandatory')
if mibBuilder.loadTexts: ipFirewallTcpsyn.setDescription('Enable TCP SYN')
ipxFirewallStatusTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 3), )
if mibBuilder.loadTexts: ipxFirewallStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallStatusTable.setDescription('The IPX Firewall Status Table')
ipxFirewallStatusTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 3, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipxFirewallStatusIndex"))
if mibBuilder.loadTexts: ipxFirewallStatusTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallStatusTableEntry.setDescription('Information about an IPX firewall status table entry.')
ipxFirewallStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxFirewallStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallStatusIndex.setDescription('Index')
ipxFirewallFilteredPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxFirewallFilteredPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallFilteredPackets.setDescription('The number of packets matching this entry')
ipxFirewallConfigTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4), )
if mibBuilder.loadTexts: ipxFirewallConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallConfigTable.setDescription('The IPX Firewall Table')
ipxFirewallConfigTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "ipxFirewallConfigIndex"))
if mibBuilder.loadTexts: ipxFirewallConfigTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallConfigTableEntry.setDescription('Information about an IPX firewall table entry.')
ipxFirewallConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxFirewallConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallConfigIndex.setDescription('Index')
ipxFirewallLowerSourceNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerSourceNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerSourceNetwork.setDescription('The IPX Firewall source network number or the lower number of a range of source networks.')
ipxFirewallHigherSourceNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherSourceNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherSourceNetwork.setDescription('The upper network number of a range of source networks.')
ipxFirewallLowerSourceNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerSourceNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerSourceNode.setDescription('The IPX Firewall source node number or the lower number of a range of source nodes.')
ipxFirewallHigherSourceNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherSourceNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherSourceNode.setDescription('The upper node number of a range of source nodes.')
ipxFirewallLowerSourceSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerSourceSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerSourceSocket.setDescription('The IPX Firewall source socket number or the lower number of a range of source sockets.')
ipxFirewallHigherSourceSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherSourceSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherSourceSocket.setDescription('The upper socket number of a range of source sockets.')
ipxFirewallLowerDestinationNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerDestinationNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerDestinationNetwork.setDescription('The IPX Firewall destination network number or the lower number of a range of destination networks.')
ipxFirewallHigherDestinationNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherDestinationNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherDestinationNetwork.setDescription('The upper network number of a range of destination networks.')
ipxFirewallLowerDestinationNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerDestinationNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerDestinationNode.setDescription('The IPX Firewall destination node number or the lower number of a range of destination nodes.')
ipxFirewallHigherDestinationNode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 11), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherDestinationNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherDestinationNode.setDescription('The upper node number of a range of destination nodes.')
ipxFirewallLowerDestinationSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallLowerDestinationSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallLowerDestinationSocket.setDescription('The IPX Firewall destination socket number or the lower number of a range of destination sockets.')
ipxFirewallHigherDestinationSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallHigherDestinationSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallHigherDestinationSocket.setDescription('The upper socket number of a range of destination sockets.')
ipxFirewallRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallRouterName.setDescription('The Router name to which frames are forwarded.')
ipxFirewallMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("insert", 2), ("append", 3), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallMode.setDescription('The Operation Required')
ipxFirewallAction = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallAction.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallAction.setDescription('Accept or Deny the frame')
ipxFirewallBidir = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 28, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxFirewallBidir.setStatus('mandatory')
if mibBuilder.loadTexts: ipxFirewallBidir.setDescription('Apply to bidirectional traffic')
ipNatTranslate = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatTranslate.setDescription('Network address translation.')
ipNatIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatIpAddress.setDescription('The IP address which the network should masquerade as.')
ipNatBogusNetwork = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatBogusNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatBogusNetwork.setDescription('The IP network whose addresses are to be translated.')
ipNatBogusNetmask = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatBogusNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatBogusNetmask.setDescription('The netmask of the IP network whose address are to be translated.')
ipNatTcpFinTimeout = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatTcpFinTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatTcpFinTimeout.setDescription('The timeout period in seconds for NAT sessions using TCP which have been closed, but for which no Finis packet has been received.')
ipNatTcpInactiveTimeout = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatTcpInactiveTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatTcpInactiveTimeout.setDescription('The timeout period in seconds for NAT sessions using TCP.')
ipNatUdpTimeout = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatUdpTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatUdpTimeout.setDescription('The maximum duration in seconds for a NAT session using UDP.')
ipNatMyself = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 32, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNatMyself.setStatus('mandatory')
if mibBuilder.loadTexts: ipNatMyself.setDescription("Translation packets to unit's management address?.")
usercfgTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1), )
if mibBuilder.loadTexts: usercfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgTable.setDescription('A table of users which are allowed to use this router.')
usercfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "usercfgIndex"))
if mibBuilder.loadTexts: usercfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgEntry.setDescription('A list of users.')
usercfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usercfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgIndex.setDescription('Index')
usercfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: usercfgName.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgName.setDescription('The user name.')
usercfgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: usercfgMac.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgMac.setDescription('The MAC address.')
usercfgAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: usercfgAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgAllowed.setDescription('Make user active')
usercfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 29, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: usercfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: usercfgMode.setDescription('The Operation Required')
srcEnabled = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srcEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: srcEnabled.setDescription('Flag to enabled or disabled Scaleable Router Clustering.')
srcPriority = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50, 128, 200))).clone(namedValues=NamedValues(("primary", 50), ("secondary", 128), ("slave", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: srcPriority.setDescription('Object used to manually set a device to be a Master or Slave device as part of Scaleable Router Clustering.')
dhcpAutoStatus = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoStatus.setDescription('If enabled, DHCP Server will allocate addresses. Also, if enabled, DHCP Proxy and DHCP Relay will silently be disabled.')
dhcpAutoName = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoName.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoName.setDescription('The stem of hostnames to be allocated.')
dhcpAutoDomain = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoDomain.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoDomain.setDescription('The domain-name of the hostnames to be allocated.')
dhcpAutoSeedStart = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoSeedStart.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoSeedStart.setDescription('Initial seed address used for automatically allocating IP addresses. Warning: if this is changed, the lease table gets cleared automatically!')
dhcpAutoSeedEnd = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoSeedEnd.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoSeedEnd.setDescription('Last seed address used for automatically allocating IP addresses.')
dhcpAutoMask = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoMask.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoMask.setDescription('Subnet mask supplied to clients when automatically allocating IP addresses.')
dhcpAutoRouter = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoRouter.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoRouter.setDescription('IP Addr of Default Router for client.')
dhcpWINSTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 8), )
if mibBuilder.loadTexts: dhcpWINSTable.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpWINSTable.setDescription('A table of WINS addresses supplied to clients.')
dhcpWINSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 8, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "dhcpWINSIndex"))
if mibBuilder.loadTexts: dhcpWINSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpWINSEntry.setDescription('A WINS Address.')
dhcpWINSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 8, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpWINSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpWINSIndex.setDescription('WINS Table Index.')
dhcpWINSAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpWINSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpWINSAddr.setDescription('IP Addr of a WINS server for client.')
dhcpDNSTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 9), )
if mibBuilder.loadTexts: dhcpDNSTable.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpDNSTable.setDescription('A table of DNS addresses supplied to clients.')
dhcpDNSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 9, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "dhcpDNSIndex"))
if mibBuilder.loadTexts: dhcpDNSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpDNSEntry.setDescription('A DNS Address.')
dhcpDNSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 9, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpDNSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpDNSIndex.setDescription('DNS Table Index.')
dhcpDNSAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 9, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpDNSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpDNSAddr.setDescription('IP Addr of a DNS server for client.')
dhcpAutoLease = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpAutoLease.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAutoLease.setDescription('Address lease lifetime (in seconds). Lower limit is 300 (i.e. 5 min), upper limit is 43200 (i.e. 12 hours).')
dhcpAstatTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11), )
if mibBuilder.loadTexts: dhcpAstatTable.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatTable.setDescription('A table of automatically allocated IP addresses.')
dhcpAstatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "dhcpAstatIpAddr"))
if mibBuilder.loadTexts: dhcpAstatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatEntry.setDescription('An automatically allocated IP address.')
dhcpAstatIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpAstatIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatIpAddr.setDescription('Automatically allocated IP Addr.')
dhcpAstatIf = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unused", 0), ("lan", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpAstatIf.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatIf.setDescription('Interface over which IP address was allocated.')
dhcpAstatHwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpAstatHwAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatHwAddr.setDescription('Hardware address of client to which IP address was allocated.')
dhcpAstatCID = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpAstatCID.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatCID.setDescription('Identifier of client to which IP address was allocated.')
dhcpAstatLife = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 33, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpAstatLife.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpAstatLife.setDescription('Remaining lifetime of lease. -1 if permanent.')
pppAuthTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34), )
if mibBuilder.loadTexts: pppAuthTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthTable.setDescription('The PPP Authentication Table.')
pppAuthTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "pppAuthIndex"))
if mibBuilder.loadTexts: pppAuthTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthTableEntry.setDescription('PPP authentication table entry.')
pppAuthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppAuthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthIndex.setDescription('Index into the PPP authentication table.')
pppAuthName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthName.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthName.setDescription('Name of the interface or ISDN number table entry.')
pppAuthClass = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthClass.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthClass.setDescription('The PPP authentication mechanism used.')
pppAuthLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 26))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthLocalId.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthLocalId.setDescription('PPP authentication local ID.')
pppAuthLocalPw = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthLocalPw.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthLocalPw.setDescription('PPP authentication local passwd. Always reads blank.')
pppAuthRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 26))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthRemoteId.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthRemoteId.setDescription('PPP authentication remote ID.')
pppAuthRemotePw = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthRemotePw.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthRemotePw.setDescription('PPP authentication remote passwd. Always reads blank.')
pppAuthRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthRetryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthRetryPeriod.setDescription('PPP authentication retry period in milliseconds.')
pppAuthRenegPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthRenegPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthRenegPeriod.setDescription('PPP authentication renogotiation period in seconds.')
pppAuthRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthRetryCount.setDescription('PPP authentication maxiumum number of retries.')
pppAuthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 34, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppAuthMode.setStatus('mandatory')
if mibBuilder.loadTexts: pppAuthMode.setDescription('The Operation Required')
primaryDNSAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryDNSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: primaryDNSAddress.setDescription('The primary Domain Name System (DNS) server address to be advertised to clients. This value will be ignored if DNS Proxy is enabled, as in this case the address of this unit will be advertised instead. A value of 0.0.0.0 causes no address to be advertised.')
secondaryDNSAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryDNSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: secondaryDNSAddress.setDescription('The secondary Domain Name System (DNS) server address to be advertised to clients. This value will be ignored if DNS Proxy is enabled, as in this case the address of this unit will be advertised instead.')
primaryNBNSAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryNBNSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: primaryNBNSAddress.setDescription('The primary Netbios Name Server (NBNS) address to be advertised to clients. A value of 0.0.0.0 causes no address to be advertised.')
secondaryNBNSAddress = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryNBNSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: secondaryNBNSAddress.setDescription('The secondary Netbios Name Server (NBNS) address to be advertised to clients.')
dnsProxyActive = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProxyActive.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProxyActive.setDescription('TRUE if the DNS proxy is enabled.')
dnsCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: dnsCacheSize.setDescription('Maximum number of entries which may be held in the DNS cache if DNS Proxy is enabled.')
dnsMaxServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsMaxServerTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: dnsMaxServerTimeout.setDescription('The maximum time in seconds for which DNS Proxy will wait for a response from a remote DNS server.')
dnsServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsServerRetries.setStatus('mandatory')
if mibBuilder.loadTexts: dnsServerRetries.setDescription('The maximum number of times that transmission of a query to remote DNS servers will be attempted.')
dnsDomainTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9), )
if mibBuilder.loadTexts: dnsDomainTable.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainTable.setDescription('The DNS Domain Table')
dnsDomainTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "dnsDomainTableIndex"))
if mibBuilder.loadTexts: dnsDomainTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainTableEntry.setDescription('Information about a DNS domain table entry.')
dnsDomainTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsDomainTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainTableIndex.setDescription('Index')
dnsDomainDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainDomainName.setDescription('The DNS Domain Name to which this table entry applies.')
dnsDomainProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainProfileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainProfileIndex.setDescription('The index of the DNS Profile table entry associated with this domain table entry. 0 indicates that there is no profile associated with this entry.')
dnsDomainRemoteServer = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainRemoteServer.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainRemoteServer.setDescription('The name of the route from which the addresses for remote DNS servers will be obtained. This field does not need to be set if there is a DNS Profile associated with this table entry.')
dnsDomainPrimaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainPrimaryDNS.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainPrimaryDNS.setDescription('The primary DNS server address for this domain. If this has the value 0.0.0.0 then the address is obtained from the remote server. This field does not need to be set if there is a DNS Profile associated with this table entry.')
dnsDomainSecondaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainSecondaryDNS.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainSecondaryDNS.setDescription('The secondary DNS server address for this domain. This field does not need to be set if there is a DNS Profile associated with this entry.')
dnsDomainMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("insert", 2), ("append", 3), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainMode.setStatus('mandatory')
if mibBuilder.loadTexts: dnsDomainMode.setDescription('The operation required')
dnsProfileTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10), )
if mibBuilder.loadTexts: dnsProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileTable.setDescription('A table of configuration profiles which describe the route to a remote DNS server. Each entry may be associated with one or more entries in the DNS domain table.')
dnsProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "dnsProfileIndex"))
if mibBuilder.loadTexts: dnsProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileEntry.setDescription('A list of configuration profiles for remote DNS servers.')
dnsProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsProfileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileIndex.setDescription('Index')
dnsProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProfileName.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileName.setDescription('The name of this DNS Profile.')
dnsProfileRemoteServer = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProfileRemoteServer.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileRemoteServer.setDescription('The name of the route from which the addresses for remote DNS servers will be obtained.')
dnsProfilePrimaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProfilePrimaryDNS.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfilePrimaryDNS.setDescription('The primary DNS server address associated with this profile. If this has the value 0.0.0.0 then the address is obtained from the remote server.')
dnsProfileSecondaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProfileSecondaryDNS.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileSecondaryDNS.setDescription('The secondary DNS server address associated with this profile.')
dnsProfileMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 35, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("add", 3), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsProfileMode.setStatus('mandatory')
if mibBuilder.loadTexts: dnsProfileMode.setDescription('The operation required')
memoryFree = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryFree.setStatus('mandatory')
if mibBuilder.loadTexts: memoryFree.setDescription('Total number of free bytes of memory')
memoryTotal = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryTotal.setStatus('mandatory')
if mibBuilder.loadTexts: memoryTotal.setDescription('Total number of bytes of memory.')
fragmentCount = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentCount.setStatus('mandatory')
if mibBuilder.loadTexts: fragmentCount.setDescription('Number of fragments of memory.')
fragmentLargest = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentLargest.setStatus('mandatory')
if mibBuilder.loadTexts: fragmentLargest.setDescription('Size of biggest fragment in bytes.')
pool1size = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pool1size.setStatus('mandatory')
if mibBuilder.loadTexts: pool1size.setDescription('Size of pool 1 in bytes.')
pool2size = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pool2size.setStatus('mandatory')
if mibBuilder.loadTexts: pool2size.setDescription('Size of pool 2 in bytes.')
pool3size = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pool3size.setStatus('mandatory')
if mibBuilder.loadTexts: pool3size.setDescription('Size of pool 3 in bytes.')
pool4size = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 36, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pool4size.setStatus('mandatory')
if mibBuilder.loadTexts: pool4size.setDescription('Size of pool 4 in bytes.')
traptableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "trapIndex"))
if mibBuilder.loadTexts: traptableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: traptableEntry.setDescription('Trap Details.')
trapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapIndex.setDescription('Trap-Table Index.')
trapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapAddr.setStatus('mandatory')
if mibBuilder.loadTexts: trapAddr.setDescription('IP Addr of a trap target.')
trapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapPort.setStatus('mandatory')
if mibBuilder.loadTexts: trapPort.setDescription('UDP Port on trap target.')
trapLogFull = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapLogFull.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogFull.setDescription('Send LogFull Trap?')
trapLogThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapLogThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogThreshold.setDescription('Send LogThreshold Trap?')
trapWarmStart = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapWarmStart.setStatus('mandatory')
if mibBuilder.loadTexts: trapWarmStart.setDescription('Send WarmStart Trap?')
trapLinkDown = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapLinkDown.setStatus('mandatory')
if mibBuilder.loadTexts: trapLinkDown.setDescription('Send LinkDown Trap?')
trapLinkUp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapLinkUp.setStatus('mandatory')
if mibBuilder.loadTexts: trapLinkUp.setDescription('Send LinkUp Trap?')
trapVoiceDown = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapVoiceDown.setStatus('mandatory')
if mibBuilder.loadTexts: trapVoiceDown.setDescription('Send VoiceDown Trap?')
trapVoiceUp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapVoiceUp.setStatus('mandatory')
if mibBuilder.loadTexts: trapVoiceUp.setDescription('Send VoiceUp Trap?')
trapISDNDown = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapISDNDown.setStatus('mandatory')
if mibBuilder.loadTexts: trapISDNDown.setDescription('Send ISDNDown Trap?')
trapISDNUp = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapISDNUp.setStatus('mandatory')
if mibBuilder.loadTexts: trapISDNUp.setDescription('Send ISDNUp Trap?')
trapAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: trapAlarm.setDescription('Send Alarm Trap?')
trapQ931Fail = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapQ931Fail.setStatus('mandatory')
if mibBuilder.loadTexts: trapQ931Fail.setDescription('Send Q931Fail Trap?')
trapDASS2Fail = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDASS2Fail.setStatus('mandatory')
if mibBuilder.loadTexts: trapDASS2Fail.setDescription('Send DASS2Fail Trap?')
trapBriFail = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapBriFail.setStatus('mandatory')
if mibBuilder.loadTexts: trapBriFail.setDescription('Send BriFail Trap?')
trapLoginAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 37, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapLoginAuth.setStatus('mandatory')
if mibBuilder.loadTexts: trapLoginAuth.setDescription('Send LoginAuth Trap?')
isdnTestCallEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,1)).setObjects(("REMOTEACCESS-MIB", "alarmCode"), ("REMOTEACCESS-MIB", "alarmText"))
if mibBuilder.loadTexts: isdnTestCallEvent.setDescription('The isdnTestCallEvent Trap is sent whenever an ISDN test autocall is made, and is unsuccessful.')
isdnLinkDownEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,2)).setObjects(("REMOTEACCESS-MIB", "portsIndex"), ("REMOTEACCESS-MIB", "portsName"), ("REMOTEACCESS-MIB", "isdnportsState"), ("REMOTEACCESS-MIB", "isdnportsConnTime"))
if mibBuilder.loadTexts: isdnLinkDownEvent.setDescription('The isdnLinkEvent is sent whenever an ISDN Link has been disconnected. This should be used in conjunction with the associated MIBII object.')
isdnLinkUpEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,3)).setObjects(("REMOTEACCESS-MIB", "portsIndex"), ("REMOTEACCESS-MIB", "portsName"), ("REMOTEACCESS-MIB", "isdnportsState"))
if mibBuilder.loadTexts: isdnLinkUpEvent.setDescription('The isdnLinkEvent is sent whenever an ISDN Link has been established and dataflow is granted. This should be used in conjunction with the associated MIBII object.')
q931FailCauseEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,6)).setObjects(("REMOTEACCESS-MIB", "portsIndex"), ("REMOTEACCESS-MIB", "isdnFailDestination"), ("REMOTEACCESS-MIB", "q931FailCauseCode"))
if mibBuilder.loadTexts: q931FailCauseEvent.setDescription('The q931FailCauseEvent is sent whenever a Q931 ISDN call is attempted but fails due to isdnFailCauseCode reason')
dass2FailCauseEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,7)).setObjects(("REMOTEACCESS-MIB", "portsIndex"), ("REMOTEACCESS-MIB", "isdnFailDestination"), ("REMOTEACCESS-MIB", "dass2FailCauseCode"))
if mibBuilder.loadTexts: dass2FailCauseEvent.setDescription('The dassFailCauseEvent is sent whenever a DASS2 ISDN call is attempted but fails due to isdnFailCauseCode reason')
briFailCauseEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,8)).setObjects(("REMOTEACCESS-MIB", "portsIndex"), ("REMOTEACCESS-MIB", "isdnFailDestination"), ("REMOTEACCESS-MIB", "briFailCauseCode"), ("REMOTEACCESS-MIB", "isdnParamsNetworkType"))
if mibBuilder.loadTexts: briFailCauseEvent.setDescription('The briFailCauseEvent is sent whenever a BRI ISDN call is attempted but fails due to isdnFailCauseCode reason')
radiusTrapEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,20)).setObjects(("REMOTEACCESS-MIB", "radiusReplyCode"), ("REMOTEACCESS-MIB", "radiusUsername"))
if mibBuilder.loadTexts: radiusTrapEvent.setDescription('The RadiusTrapEvent is sent whenever a user attempts to log into a unit and RADIUS authentication is enabled. The RadiusReply indicates level of authentication granted to the user (if any). The RadiusUsername shows the username entered at the login prompt.')
loginTrapEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,21)).setObjects(("REMOTEACCESS-MIB", "loginCode"))
if mibBuilder.loadTexts: loginTrapEvent.setDescription('The LoginTrapEvent is sent whenever a user attempts to log into a unit and RADIUS authentication fails. The boolean LoginCode indicates whether the user sucessfully logged in with the default password.')
cscmTrapEvent = NotificationType((1, 3, 6, 1, 4, 1, 559) + (0,100)).setObjects(("REMOTEACCESS-MIB", "cscmEventNumber"), ("REMOTEACCESS-MIB", "cscmOriginatingIP"), ("REMOTEACCESS-MIB", "cscmTrapDetail"))
if mibBuilder.loadTexts: cscmTrapEvent.setDescription('The cscmTrapEvent is sent by the CSCM management system whenever an event occurs for a unit on the system that has been setup with trap information and flagged to send it')
patTable = MibTable((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38), )
if mibBuilder.loadTexts: patTable.setStatus('mandatory')
if mibBuilder.loadTexts: patTable.setDescription('A table of Port Address Translation entries.')
patEntry = MibTableRow((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1), ).setIndexNames((0, "REMOTEACCESS-MIB", "patIndex"))
if mibBuilder.loadTexts: patEntry.setStatus('mandatory')
if mibBuilder.loadTexts: patEntry.setDescription('A list of PAT entries.')
patIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: patIndex.setStatus('mandatory')
if mibBuilder.loadTexts: patIndex.setDescription('Index')
patPort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: patPort.setStatus('mandatory')
if mibBuilder.loadTexts: patPort.setDescription('The port to listen on.')
patInternalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: patInternalIP.setStatus('mandatory')
if mibBuilder.loadTexts: patInternalIP.setDescription('The IP address to forward to.')
patInternalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: patInternalPort.setStatus('mandatory')
if mibBuilder.loadTexts: patInternalPort.setDescription('The port to forward to.')
patMode = MibTableColumn((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 38, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("delete", 1), ("edit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: patMode.setStatus('mandatory')
if mibBuilder.loadTexts: patMode.setDescription('The Operation Required')
tpadLanPort = MibScalar((1, 3, 6, 1, 4, 1, 559, 1, 2, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpadLanPort.setStatus('mandatory')
if mibBuilder.loadTexts: tpadLanPort.setDescription('The port number of the virtual LAN connection to the AT interface.')
tftpFile = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFile.setStatus('current')
if mibBuilder.loadTexts: tftpFile.setDescription('The file name to be LOADED from or STORED on the TFTP server, when a download is next requested via this MIB. This value is set to the zero length string when no file name has been specified.')
tftpServerIP = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpServerIP.setStatus('current')
if mibBuilder.loadTexts: tftpServerIP.setDescription("The IP address of the TFTP server that contains the image to LOAD or STORE when a LOAD or STORE is next requested via this MIB. This value is set to `0.0.0.0' when no IP address has been specified.")
tftpAction = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("idle", 1), ("load", 2), ("store", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpAction.setStatus('current')
if mibBuilder.loadTexts: tftpAction.setDescription('When this object is set to LOAD (2) or STORE (3), the device will discontinue its normal operation and begin loading or storing of the image specified by probeDownloadFile using the TFTP protocol. If LOAD(2) is specified, the new image is copied from the TFTP Server to the unit. If STORE(3)is specified the image is written to the TFTP Server.')
tftpStatus = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("success", 1), ("statusunknown", 2), ("generalerror", 3), ("noresponsefromserver", 4), ("checksumerror", 5), ("incompatibleimage", 6), ("tftpfilenotfound", 7), ("tftpaccessviolation", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpStatus.setStatus('current')
if mibBuilder.loadTexts: tftpStatus.setDescription('The status of the last download procedure, if any. This object will have a value of StatusUnknown(2) if no LOAD or STORE process has been performed.')
class EntryStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4))

mibBuilder.exportSymbols("REMOTEACCESS-MIB", portslanIpMetric=portslanIpMetric, ipxInDelivers=ipxInDelivers, isdnTestCallEvent=isdnTestCallEvent, ipInRipErrors=ipInRipErrors, pppAuthMode=pppAuthMode, portspppTable=portspppTable, tftpAction=tftpAction, authorisedTable=authorisedTable, portsslipLinespeed=portsslipLinespeed, isdnbandsMode=isdnbandsMode, portspppIndex=portspppIndex, dhcpAutoMask=dhcpAutoMask, dhcpAstatTable=dhcpAstatTable, isdnhistoryFailedCalls=isdnhistoryFailedCalls, passwdsEntry=passwdsEntry, portstpadX25MaxLCN=portstpadX25MaxLCN, isdnParamsSubAddrType=isdnParamsSubAddrType, portsasyncDataBits=portsasyncDataBits, filtertypeLsap=filtertypeLsap, isdnportsTable=isdnportsTable, mlinkInFrames=mlinkInFrames, portsslipMTU=portsslipMTU, portsvoiceIndex=portsvoiceIndex, ipxOutRipResponses=ipxOutRipResponses, isdnbandsBridgeListBandName=isdnbandsBridgeListBandName, ipxNearestMode=ipxNearestMode, dhcpAutoSeedStart=dhcpAutoSeedStart, passwdsOld=passwdsOld, portstaLinespeed=portstaLinespeed, isdnParamsSubAddrSend=isdnParamsSubAddrSend, autocallMacIndex=autocallMacIndex, pppExtLcpMaximumTerminateRequests=pppExtLcpMaximumTerminateRequests, usercfgEntry=usercfgEntry, ipxFirewallHigherSourceSocket=ipxFirewallHigherSourceSocket, isdnParamsIncomingDov=isdnParamsIncomingDov, ipNatTcpFinTimeout=ipNatTcpFinTimeout, ipxcpRemoteNodeNumberNegotiation=ipxcpRemoteNodeNumberNegotiation, dnsServerRetries=dnsServerRetries, portsTable=portsTable, trapPort=trapPort, portslanTable=portslanTable, ipxRouteTarget=ipxRouteTarget, ipxcpMinimumRestartPeriod=ipxcpMinimumRestartPeriod, arpMultiLan=arpMultiLan, isdnParamsTokenRefill=isdnParamsTokenRefill, isdnFailDestination=isdnFailDestination, ipxRouteHopCount=ipxRouteHopCount, autocallIpxRipIndex=autocallIpxRipIndex, authorisedMode=authorisedMode, isdnParamsMaxCallTime=isdnParamsMaxCallTime, ipxFirewallHigherSourceNode=ipxFirewallHigherSourceNode, incallalert=incallalert, isdnParamsDirectoryNumber2=isdnParamsDirectoryNumber2, isdnnumbersIpAddress=isdnnumbersIpAddress, ipxcpRemoteRoutingProtocolNegotiation=ipxcpRemoteRoutingProtocolNegotiation, trapLinkUp=trapLinkUp, ipxRouteNextHopNetwork=ipxRouteNextHopNetwork, portsasyncBaud=portsasyncBaud, portstaSpidstring=portstaSpidstring, officeConnectRemote510u=officeConnectRemote510u, filtertypeMode=filtertypeMode, arpPlusRPrimary=arpPlusRPrimary, portsslipPriority=portsslipPriority, autocallIpxIsdn=autocallIpxIsdn, usercfgMac=usercfgMac, pppIpcpConfigTableEntry=pppIpcpConfigTableEntry, ipxServiceRTType=ipxServiceRTType, pppIpcpConfigTable=pppIpcpConfigTable, isdnlists=isdnlists, portsasyncName=portsasyncName, isdnnumbersMode=isdnnumbersMode, autocallIpxSapFrameType=autocallIpxSapFrameType, ipxNearestTableEntry=ipxNearestTableEntry, serviceConnect2000BasePri=serviceConnect2000BasePri, portshdlcIndex=portshdlcIndex, bootpAddress=bootpAddress, portspppIpMask=portspppIpMask, ipxFirewallConfigTable=ipxFirewallConfigTable, filterLearning=filterLearning, trapLoginAuth=trapLoginAuth, ipFirewallLowerDestinationPort=ipFirewallLowerDestinationPort, bridge=bridge, portstpadParity=portstpadParity, isdnnumbersEntry=isdnnumbersEntry, ipxServiceNextHopNetwork=ipxServiceNextHopNetwork, portslanIpxNetwork=portslanIpxNetwork, ipcpRemoteIPAddressNegotiation=ipcpRemoteIPAddressNegotiation, pppExtLcpMaximumRestartPeriod=pppExtLcpMaximumRestartPeriod, ipxFirewallLowerDestinationNetwork=ipxFirewallLowerDestinationNetwork, isdnports=isdnports, isdnlistsName=isdnlistsName, arpOffice=arpOffice, pppAuthRetryPeriod=pppAuthRetryPeriod, dnsDomainTableIndex=dnsDomainTableIndex, mlinkTable=mlinkTable, portstaDemandthresh=portstaDemandthresh, patInternalIP=patInternalIP, portstaIndex=portstaIndex, ipxRoutingTable=ipxRoutingTable, portspppEntry=portspppEntry, portspppDataBits=portspppDataBits, autocallDialEntry=autocallDialEntry, isdnParamsDirectoryNumber3=isdnParamsDirectoryNumber3, bootpActive=bootpActive, bootp=bootp, ipxServiceLinkType=ipxServiceLinkType, privatecommunity=privatecommunity, dnsDomainProfileIndex=dnsDomainProfileIndex, ipx=ipx, portstaDemand=portstaDemand, mlinkNumberOfPorts=mlinkNumberOfPorts, autocallIpTable=autocallIpTable, pppExtEnableIp=pppExtEnableIp, autocallIpxSapTable=autocallIpxSapTable, autocallIpxRipIsdnType=autocallIpxRipIsdnType, alarmText=alarmText, accessBuilderRemoteOffice600=accessBuilderRemoteOffice600, isdnhistoryIndex=isdnhistoryIndex, portshdlcDemandthresh=portshdlcDemandthresh, usercfgName=usercfgName, portsvoiceDialMode=portsvoiceDialMode, loopControl=loopControl, pppAuthRemotePw=pppAuthRemotePw, ipRouteTableCopy=ipRouteTableCopy, autocallDialMode=autocallDialMode, ipxFirewallStatusTableEntry=ipxFirewallStatusTableEntry, ipxRouteTicks=ipxRouteTicks, dnsProfileSecondaryDNS=dnsProfileSecondaryDNS, ipxInHeaderErrors=ipxInHeaderErrors, autocallIpxRipHops=autocallIpxRipHops, MacAddress=MacAddress, bootpIsdnName=bootpIsdnName, ipxOutRipErrors=ipxOutRipErrors, pool1size=pool1size, trapIndex=trapIndex, ipRouteMetric2Copy=ipRouteMetric2Copy, pool4size=pool4size, ipRouteMetric3Copy=ipRouteMetric3Copy, portshdlcBackuppriority=portshdlcBackuppriority, ipNatTranslate=ipNatTranslate, portslanEntry=portslanEntry, unitname=unitname, dnsDomainPrimaryDNS=dnsDomainPrimaryDNS, portsslipIndex=portsslipIndex, pppExtLcpMaximumConfigNaks=pppExtLcpMaximumConfigNaks, authorisedAddress=authorisedAddress, isdnhistoryTotalCalls=isdnhistoryTotalCalls, pppExtLcpMinimumRestartPeriod=pppExtLcpMinimumRestartPeriod, pppEchoConfigTable=pppEchoConfigTable, tftp=tftp, cscmOriginatingIP=cscmOriginatingIP, pppExtLcpLocalACCMEnabled=pppExtLcpLocalACCMEnabled, isdnhistoryTotalTime=isdnhistoryTotalTime, ipRipLearning=ipRipLearning, isdnnumbersMaxCircuits=isdnnumbersMaxCircuits, ipcpLocalIPAddressNegotiation=ipcpLocalIPAddressNegotiation, bootpIdleThreshold=bootpIdleThreshold, arpStandard=arpStandard, dhcpAutoSeedEnd=dhcpAutoSeedEnd, autocallIpMask=autocallIpMask, autocallIpAddress=autocallIpAddress, EntryStatus=EntryStatus, arpPlus=arpPlus, standard=standard, portspppTxParity=portspppTxParity, ipxcpMaximumRestartPeriod=ipxcpMaximumRestartPeriod, ipFirewallFilteredPackets=ipFirewallFilteredPackets, tpadLanPort=tpadLanPort, ipxFirewallStatusTable=ipxFirewallStatusTable, isdnParamsMsnLan=isdnParamsMsnLan, isdnportsState=isdnportsState, ipFirewallConfigIndex=ipFirewallConfigIndex, ipRouteDestCopy=ipRouteDestCopy, filter=filter, accessBuilderRemoteOffice500=accessBuilderRemoteOffice500, isdnnumbersCallType2=isdnnumbersCallType2, pppExtLcpLocalMagic=pppExtLcpLocalMagic, ipxInSapResponses=ipxInSapResponses, passwdsNew=passwdsNew, alarms=alarms, autocallIpxEntry=autocallIpxEntry, mlinkOutFrames=mlinkOutFrames, isdnParamsSpid3=isdnParamsSpid3, filterFlushall=filterFlushall, ipxcpRemoteRouterNameNegotiation=ipxcpRemoteRouterNameNegotiation, ipxsapt=ipxsapt, isdnLinkDownEvent=isdnLinkDownEvent, ipxOutRipDiscards=ipxOutRipDiscards, dhcpDNSIndex=dhcpDNSIndex, isdnportsEntry=isdnportsEntry, dhcpAstatCID=dhcpAstatCID, q931FailCauseEvent=q931FailCauseEvent, portshdlcIpMetric=portshdlcIpMetric, accessBuilder7000PriBridgeRouter=accessBuilder7000PriBridgeRouter, serviceConnect2000=serviceConnect2000, ipxFirewallLowerSourceNetwork=ipxFirewallLowerSourceNetwork, filterLearnnovell=filterLearnnovell, officeConnectRemote531s=officeConnectRemote531s, filterDest=filterDest, managertimeout=managertimeout, ipxInDiscards=ipxInDiscards, autocallDialCli=autocallDialCli, portsvoiceName=portsvoiceName, autocallIpxIdleThreshold=autocallIpxIdleThreshold, usercfgAllowed=usercfgAllowed, radiusTrapEvent=radiusTrapEvent, pppExtLcpLocalPAPEnabled=pppExtLcpLocalPAPEnabled, memoryFree=memoryFree, ipcpMinimumRestartPeriod=ipcpMinimumRestartPeriod, trapISDNDown=trapISDNDown, portstpadIndex=portstpadIndex, isdnnumbersNumber2=isdnnumbersNumber2, portsslipIpMask=portsslipIpMask, autocallIpInverse=autocallIpInverse, officeConnectRemote530u=officeConnectRemote530u, autocallIpxPacketType=autocallIpxPacketType, cscmTrapDetail=cscmTrapDetail, trapDASS2Fail=trapDASS2Fail, mlinkInDiscards=mlinkInDiscards, isdncla=isdncla, ipxInRipDiscards=ipxInRipDiscards, isdnbandsAllowbackup=isdnbandsAllowbackup, portsTxutil=portsTxutil, portslanIpxType=portslanIpxType, portsasyncTable=portsasyncTable, lcdManagerLock=lcdManagerLock, portsasyncStopBits=portsasyncStopBits, filterPrimary=filterPrimary, pppExtLcpRemoteMRU=pppExtLcpRemoteMRU, isdnParamsTokenValue=isdnParamsTokenValue, pppExtLcpLocalMRU=pppExtLcpLocalMRU, ipxFirewallFilteredPackets=ipxFirewallFilteredPackets, pppAuthLocalPw=pppAuthLocalPw, ipRouteMetric4Copy=ipRouteMetric4Copy, ipFirewallHigherSourcePort=ipFirewallHigherSourcePort, trapQ931Fail=trapQ931Fail, pppExtLcpRemoteProtocolCompression=pppExtLcpRemoteProtocolCompression, portshdlcBackupnumber=portshdlcBackupnumber, portspppRxParity=portspppRxParity, portsTxoctets=portsTxoctets, autocallMacMode=autocallMacMode, ipNatTcpInactiveTimeout=ipNatTcpInactiveTimeout, isdnnumbersIndex=isdnnumbersIndex, dass2FailCauseCode=dass2FailCauseCode, portshdlcTable=portshdlcTable, portstpadRxFlowControl=portstpadRxFlowControl, filterLearnbridging=filterLearnbridging, ipNatMyself=ipNatMyself, dnsproxy=dnsproxy, portstaDemandperiod=portstaDemandperiod, mlinkName=mlinkName, isdnportsAlert=isdnportsAlert, ipxNearestIndex=ipxNearestIndex, trapBriFail=trapBriFail)
mibBuilder.exportSymbols("REMOTEACCESS-MIB", isdnCliTable=isdnCliTable, autocall=autocall, dnsDomainTableEntry=dnsDomainTableEntry, ipxsap=ipxsap, pppEchoConfigTableEntry=pppEchoConfigTableEntry, dhcpDNSTable=dhcpDNSTable, autocallDialIndex=autocallDialIndex, ipInRipDiscards=ipInRipDiscards, ipFirewallDestinationMask=ipFirewallDestinationMask, usercfgIndex=usercfgIndex, pppEchoMaxNumberRetransmits=pppEchoMaxNumberRetransmits, isdnbandsBridgeListEntry=isdnbandsBridgeListEntry, autocallIpxSapIsdn=autocallIpxSapIsdn, ipxcpLocalRoutingProtocolNegotiation=ipxcpLocalRoutingProtocolNegotiation, autocallIpxBumpable=autocallIpxBumpable, briFailCauseEvent=briFailCauseEvent, portsasyncEntry=portsasyncEntry, ipxFirewallRouterName=ipxFirewallRouterName, ipxcpMaximumTerminateRequests=ipxcpMaximumTerminateRequests, ipxFirewallHigherDestinationSocket=ipxFirewallHigherDestinationSocket, arpPlusRBasic=arpPlusRBasic, portspppIpxType=portspppIpxType, autocallIpxIndex=autocallIpxIndex, pppExtLcpRemoteMagic=pppExtLcpRemoteMagic, pppExtLcpLocalMRUEnabled=pppExtLcpLocalMRUEnabled, pool2size=pool2size, save=save, isdnbandsBridgeListIndex=isdnbandsBridgeListIndex, dnsProfilePrimaryDNS=dnsProfilePrimaryDNS, portstpadTable=portstpadTable, ipxcpMaximumConfigNaks=ipxcpMaximumConfigNaks, pppAuthIndex=pppAuthIndex, portshdlcIpAddress=portshdlcIpAddress, isdnbandsName=isdnbandsName, ipxOutSapErrors=ipxOutSapErrors, pppExtEnableIpx=pppExtEnableIpx, ipxRoutingTableEntry=ipxRoutingTableEntry, dhcpAstatHwAddr=dhcpAstatHwAddr, autocallIpxRipNetwork=autocallIpxRipNetwork, registration=registration, ipFirewallDestinationAddress=ipFirewallDestinationAddress, portspppRemoteUnit=portspppRemoteUnit, ipxServiceHopCount=ipxServiceHopCount, ipxNearestTable=ipxNearestTable, pppExtLcpRemoteAddressCompression=pppExtLcpRemoteAddressCompression, isdnnumbersIpMetric=isdnnumbersIpMetric, portshdlcIpxNetwork=portshdlcIpxNetwork, radius=radius, filterEntry=filterEntry, portshdlcIpMask=portshdlcIpMask, isdnlistsBand=isdnlistsBand, isdnParamsSubAddr=isdnParamsSubAddr, ipFirewallHigherDestinationPort=ipFirewallHigherDestinationPort, pppAuthName=pppAuthName, dnsProfileIndex=dnsProfileIndex, pppExtLcpLocalCHAPEnabled=pppExtLcpLocalCHAPEnabled, fragmentCount=fragmentCount, ipxcpConfigCompleteNegotiation=ipxcpConfigCompleteNegotiation, isdnParamsSpid2=isdnParamsSpid2, dhcpWINSEntry=dhcpWINSEntry, portshdlcBackupMac=portshdlcBackupMac, ipFirewallStatusTable=ipFirewallStatusTable, autocallIpxRipPpp=autocallIpxRipPpp, dhcpAutoName=dhcpAutoName, pppExtHdlcLayer=pppExtHdlcLayer, accessBuilderRemoteOffice700=accessBuilderRemoteOffice700, ipcpMaximumRestartPeriod=ipcpMaximumRestartPeriod, ipFirewallAction=ipFirewallAction, filterType=filterType, autocallIpxSapRouterMac=autocallIpxSapRouterMac, ipxInRipTimeouts=ipxInRipTimeouts, isdnParamsMsnVoice=isdnParamsMsnVoice, ipxcpLocalRouterNameNegotiation=ipxcpLocalRouterNameNegotiation, isdnhistory=isdnhistory, ipxFirewallLowerDestinationSocket=ipxFirewallLowerDestinationSocket, portslanIpAddress=portslanIpAddress, ipNatUdpTimeout=ipNatUdpTimeout, portsTxpackets=portsTxpackets, pppExtLcpLocalACCM=pppExtLcpLocalACCM, unitipad=unitipad, ipxFirewallHigherDestinationNode=ipxFirewallHigherDestinationNode, portslanLinespeed=portslanLinespeed, portsRxoctets=portsRxoctets, autocallIpxRipMode=autocallIpxRipMode, trapISDNUp=trapISDNUp, autocallIpMode=autocallIpMode, portsvoiceCallsPermitted=portsvoiceCallsPermitted, autocallIpxFrameType=autocallIpxFrameType, pppExtLcpMaximumConfigRequests=pppExtLcpMaximumConfigRequests, portsName=portsName, isdnnumbersCall=isdnnumbersCall, isdnportsBumpable=isdnportsBumpable, ipxcpAdmin=ipxcpAdmin, portstaName=portstaName, filterLearnsourceonmcast=filterLearnsourceonmcast, isdnbandsIndex=isdnbandsIndex, ipxOutRipRequests=ipxOutRipRequests, ipxFirewallAction=ipxFirewallAction, traptableEntry=traptableEntry, iprip=iprip, portsasyncTxParity=portsasyncTxParity, pppExtConfigTableEntry=pppExtConfigTableEntry, ipRouteProtoCopy=ipRouteProtoCopy, ipxServiceNetwork=ipxServiceNetwork, ipxrip=ipxrip, ipxRoutePort=ipxRoutePort, secondaryNBNSAddress=secondaryNBNSAddress, isdnFailCause=isdnFailCause, autocallIpIdle=autocallIpIdle, ipxOutSapResponses=ipxOutSapResponses, pppExtLcpLocalAddressCompression=pppExtLcpLocalAddressCompression, isdnportsIndex=isdnportsIndex, memoryTotal=memoryTotal, isdnCliNumber=isdnCliNumber, autocallMacTable=autocallMacTable, mlink=mlink, briFailCauseCode=briFailCauseCode, isdnlistsEntry=isdnlistsEntry, q931FailCauseCode=q931FailCauseCode, autocallIpxRipIsdn=autocallIpxRipIsdn, ipxOutRipUpdates=ipxOutRipUpdates, ipxServiceSocket=ipxServiceSocket, ipxrt=ipxrt, time=time, isdnParamsMsnCheck=isdnParamsMsnCheck, mlinkIndex=mlinkIndex, novelltimeout=novelltimeout, filtertypeEntry=filtertypeEntry, portsRxerrs=portsRxerrs, dnsProfileEntry=dnsProfileEntry, isdnlistsIndex=isdnlistsIndex, authorised=authorised, portshdlcBackupdemand=portshdlcBackupdemand, ipxOutRequests=ipxOutRequests, isdnnumbersCallType4=isdnnumbersCallType4, users=users, ipxOutNoRoutes=ipxOutNoRoutes, portshdlcBackupalert=portshdlcBackupalert, unitmacaddress=unitmacaddress, patTable=patTable, pppExtLcpRemoteACCMEnabled=pppExtLcpRemoteACCMEnabled, pppExtConfigTable=pppExtConfigTable, ipFirewallRouterName=ipFirewallRouterName, ipRoutingProtocol=ipRoutingProtocol, ipxInSapRequests=ipxInSapRequests, portsvoiceEntry=portsvoiceEntry, ipxInSapNoServers=ipxInSapNoServers, tftpServerIP=tftpServerIP, portstpadBaud=portstpadBaud, pppExtLcpRemotePAPEnabled=pppExtLcpRemotePAPEnabled, saverequired=saverequired, dass2FailCauseEvent=dass2FailCauseEvent, isdnnumbersNumber4=isdnnumbersNumber4, portspppBaud=portspppBaud, dnsCacheSize=dnsCacheSize, isdnnumbersLearntED=isdnnumbersLearntED, ipnat=ipnat, pppext=pppext, isdnnumbersDays=isdnnumbersDays, referenceAddress=referenceAddress, dhcpserver=dhcpserver, ipxRouteLinkTicks=ipxRouteLinkTicks, portstaScramble=portstaScramble, dhcpAstatEntry=dhcpAstatEntry, isdnhistoryDestination=isdnhistoryDestination, isdnnumbersCallType1=isdnnumbersCallType1, ipxRouteMode=ipxRouteMode, ipOutRipDiscards=ipOutRipDiscards, ipRouteEntryCopy=ipRouteEntryCopy, ipxnear=ipxnear, ipcpMaximumConfigRequests=ipcpMaximumConfigRequests, autocallMacIsdn=autocallMacIsdn, pppAuthClass=pppAuthClass, isdnnumbersIpxNetwork=isdnnumbersIpxNetwork, trapLogFull=trapLogFull, dhcpAutoDomain=dhcpAutoDomain, portspppIpMetric=portspppIpMetric, ipRouteNextHopName=ipRouteNextHopName, portsslipDataBits=portsslipDataBits, ipFirewallSourceMask=ipFirewallSourceMask, dnsDomainMode=dnsDomainMode, sonix=sonix, portsasyncRxParity=portsasyncRxParity, isdnbandsBridgeListTable=isdnbandsBridgeListTable, version=version, ipxRouteNextHopNode=ipxRouteNextHopNode, isdnbandsStarttime=isdnbandsStarttime, autocallIpxNetwork=autocallIpxNetwork, pppExtLcpConfigTableEntry=pppExtLcpConfigTableEntry, autocallDialBumpable=autocallDialBumpable, secondaryDNSAddress=secondaryDNSAddress, autocallIpxRipNode=autocallIpxRipNode, cscmInfo=cscmInfo, portshdlcIdlethresh=portshdlcIdlethresh, isdnbandsAllowautocall=isdnbandsAllowautocall, ipxcpLocalNodeNumberNegotiation=ipxcpLocalNodeNumberNegotiation, arpFocus=arpFocus, dnsProfileTable=dnsProfileTable, portsslipRIPPrivate=portsslipRIPPrivate, tftpFile=tftpFile, ipxForwarding=ipxForwarding, dnsDomainTable=dnsDomainTable, filterTypematching=filterTypematching, portsState=portsState, dhcpAstatIf=dhcpAstatIf, isdnnumbersCallType3=isdnnumbersCallType3, autocallIpBumpable=autocallIpBumpable, portstpadName=portstpadName, autocallIpxRipRouterMac=autocallIpxRipRouterMac, autocallDialIsdn=autocallDialIsdn, isdnParamsMsn=isdnParamsMsn, isdnParamsSubAddrCheck=isdnParamsSubAddrCheck, ipNatBogusNetwork=ipNatBogusNetwork, patEntry=patEntry, loginTrapEvent=loginTrapEvent, accessBuilderInternet400u=accessBuilderInternet400u, portstaIdleperiod=portstaIdleperiod, ipRouteNextHopCopy=ipRouteNextHopCopy, usercfgTable=usercfgTable, srcPriority=srcPriority, ipxFirewallConfigIndex=ipxFirewallConfigIndex, fragmentLargest=fragmentLargest, ipFirewallConfigTable=ipFirewallConfigTable, pool3size=pool3size, isdnnumbersRemoteUnitType=isdnnumbersRemoteUnitType, portsRxutil=portsRxutil, isdnnumbersTable=isdnnumbersTable, isdnLinkUpEvent=isdnLinkUpEvent, portsasyncIndex=portsasyncIndex, isdnnumbersRemoteIpAddress=isdnnumbersRemoteIpAddress, dhcpAutoStatus=dhcpAutoStatus, portspppPriority=portspppPriority, isdnnumbersIpxType=isdnnumbersIpxType, portstaEntry=portstaEntry, isdnbandsDays=isdnbandsDays, ipxNearestServer=ipxNearestServer, isdnnumbersNumber3=isdnnumbersNumber3, ipInRipResponses=ipInRipResponses, ipFirewallType=ipFirewallType, ipxInSapDiscards=ipxInSapDiscards, trapLogThreshold=trapLogThreshold, portstaTable=portstaTable, portshdlcEntry=portshdlcEntry, portshdlcDemandperiod=portshdlcDemandperiod, radiusReplyCode=radiusReplyCode, dhcpDNSEntry=dhcpDNSEntry, dhcpAstatIpAddr=dhcpAstatIpAddr, autocallMacDefault=autocallMacDefault, dhcpAstatLife=dhcpAstatLife, isdnbandsAllowdemand=isdnbandsAllowdemand, autocallIpxIsdnType=autocallIpxIsdnType, ipxRouteType=ipxRouteType, portshdlcDemandpriority=portshdlcDemandpriority, ipxRouteLinkType=ipxRouteLinkType)
mibBuilder.exportSymbols("REMOTEACCESS-MIB", ports=ports, portsIndex=portsIndex, portsslipStopBits=portsslipStopBits, ipxInRipResponses=ipxInRipResponses, ipxFirewallMode=ipxFirewallMode, isdnCliEntry=isdnCliEntry, isdnParams=isdnParams, isdnCliIndex=isdnCliIndex, portsasyncFlowControl=portsasyncFlowControl, portsvoiceEncoding=portsvoiceEncoding, pppAuthTable=pppAuthTable, ipcpRfc1172Negotiation=ipcpRfc1172Negotiation, pppAuthRemoteId=pppAuthRemoteId, dnsDomainDomainName=dnsDomainDomainName, filterTable=filterTable, autocallIpxPpp=autocallIpxPpp, usercfgMode=usercfgMode, loginCode=loginCode, ipRoutingAdvertise=ipRoutingAdvertise, ipcpLocalCompressionNegotiation=ipcpLocalCompressionNegotiation, dnsDomainSecondaryDNS=dnsDomainSecondaryDNS, filtertypeTable=filtertypeTable, dhcpAutoRouter=dhcpAutoRouter, portsPhys=portsPhys, dnsProfileName=dnsProfileName, trapVoiceUp=trapVoiceUp, portsslipIpMetric=portsslipIpMetric, portspppIpAddress=portspppIpAddress, portstpadX25MinLCN=portstpadX25MinLCN, ipxFirewallConfigTableEntry=ipxFirewallConfigTableEntry, autocallIpxSapSocket=autocallIpxSapSocket, ppp=ppp, portshdlcLinespeed=portshdlcLinespeed, portspppFlowControl=portspppFlowControl, memoryusage=memoryusage, autocallDialIdleThreshold=autocallDialIdleThreshold, portstpadDataBits=portstpadDataBits, pppAuthRenegPeriod=pppAuthRenegPeriod, ipNatIpAddress=ipNatIpAddress, ipxInRipRequests=ipxInRipRequests, portspppIPRemoteAddress=portspppIPRemoteAddress, isdnnumbersLasttest=isdnnumbersLasttest, ipxFirewallHigherSourceNetwork=ipxFirewallHigherSourceNetwork, autocallIpxRipEntry=autocallIpxRipEntry, ipxServiceType=ipxServiceType, autocallIpxSapMode=autocallIpxSapMode, ipxInReceives=ipxInReceives, timeSinceReboot=timeSinceReboot, autocallIpxRipFrameType=autocallIpxRipFrameType, ipRouteMetric5Copy=ipRouteMetric5Copy, accessBuilderRemoteUser400s=accessBuilderRemoteUser400s, isdnParamsSpid1=isdnParamsSpid1, autocallIpxRipTable=autocallIpxRipTable, arpLite=arpLite, accessBuilderRemoteUser400u=accessBuilderRemoteUser400u, ipxcpMaximumConfigRequests=ipxcpMaximumConfigRequests, patInternalPort=patInternalPort, autocallIpxSapHops=autocallIpxSapHops, filterRoute=filterRoute, officeConnectRemote531u=officeConnectRemote531u, regArpeggio=regArpeggio, ipxInUnknownProtocols=ipxInUnknownProtocols, ipxInSapErrors=ipxInSapErrors, isdn=isdn, portsslipFlowControl=portsslipFlowControl, portsslipIPRemoteAddress=portsslipIPRemoteAddress, autocallIpIdleThreshold=autocallIpIdleThreshold, trapAddr=trapAddr, ipRouteAdvertise=ipRouteAdvertise, ipxcpNodeNumber=ipxcpNodeNumber, isdnportsPriority=isdnportsPriority, autocallMacAddress=autocallMacAddress, ipRouteMetric1Copy=ipRouteMetric1Copy, isdnnumbersName=isdnnumbersName, isdnnumbers=isdnnumbers, ipOutRipRequests=ipOutRipRequests, primaryNBNSAddress=primaryNBNSAddress, autocallIpxSapNetwork=autocallIpxSapNetwork, portstaDialtimeout=portstaDialtimeout, traps=traps, ipxFirewallStatusIndex=ipxFirewallStatusIndex, ipFirewallStatusTableEntry=ipFirewallStatusTableEntry, alarmCode=alarmCode, dhcpDNSAddr=dhcpDNSAddr, isdnbandsEndtime=isdnbandsEndtime, bootpBumpable=bootpBumpable, portsslipTable=portsslipTable, ipNatBogusNetmask=ipNatBogusNetmask, isdnportsConnTime=isdnportsConnTime, filterAgingtime=filterAgingtime, portsslipTxParity=portsslipTxParity, filterPacketcount=filterPacketcount, dhcpWINSIndex=dhcpWINSIndex, isdnportsSourceMac=isdnportsSourceMac, ipcpMaximumConfigNaks=ipcpMaximumConfigNaks, officeConnectRemote530s=officeConnectRemote530s, variant=variant, autocallIpxSapServer=autocallIpxSapServer, autocallMacIdleThreshold=autocallMacIdleThreshold, ipxServicePort=ipxServicePort, pppAuthRetryCount=pppAuthRetryCount, ipOutRipResponses=ipOutRipResponses, ipxFirewallLowerDestinationNode=ipxFirewallLowerDestinationNode, ipRouteMaskCopy=ipRouteMaskCopy, accessBuilder=accessBuilder, accessBuilder7000BriBridgeRouter=accessBuilder7000BriBridgeRouter, isdnParamsSubAddrLan=isdnParamsSubAddrLan, isdnlistsTable=isdnlistsTable, cscmEventNumber=cscmEventNumber, isdnbandsTable=isdnbandsTable, autocallDialIdle=autocallDialIdle, isdnportsBackup=isdnportsBackup, dhcpWINSAddr=dhcpWINSAddr, patIndex=patIndex, portshdlcIpxType=portshdlcIpxType, portslanIndex=portslanIndex, trapLinkDown=trapLinkDown, trapWarmStart=trapWarmStart, authorisedEntry=authorisedEntry, autocallDialTable=autocallDialTable, isdnParamsMsnSend=isdnParamsMsnSend, ipxServiceName=ipxServiceName, ipxServiceMlink=ipxServiceMlink, autocallIpxTable=autocallIpxTable, portspppIpxNetwork=portspppIpxNetwork, ipxFirewallLowerSourceNode=ipxFirewallLowerSourceNode, isdnParamsDirectoryNumber1=isdnParamsDirectoryNumber1, ipxRouteMlink=ipxRouteMlink, ipxNearest=ipxNearest, isdnhistoryEntry=isdnhistoryEntry, srcEnabled=srcEnabled, sonixMibs=sonixMibs, isdnParamsTokenRemain=isdnParamsTokenRemain, pppExtLcpLocalProtocolCompression=pppExtLcpLocalProtocolCompression, traptable=traptable, portsRxpackets=portsRxpackets, trapport=trapport, ipxcpLocalNetworkNumberNegotiation=ipxcpLocalNetworkNumberNegotiation, filtertypeClass=filtertypeClass, authorisedIndex=authorisedIndex, pppEchoPeriod=pppEchoPeriod, dnsProfileRemoteServer=dnsProfileRemoteServer, autocallMacBumpable=autocallMacBumpable, ipOutRipErrors=ipOutRipErrors, isdnbandsEntry=isdnbandsEntry, filtertypeIndex=filtertypeIndex, isdnnumbersHdlcType=isdnnumbersHdlcType, primaryDNSAddress=primaryDNSAddress, portstaPriority=portstaPriority, ipxOutSapDiscards=ipxOutSapDiscards, portslanPriority=portslanPriority, officeConnect=officeConnect, autocallIpxRipLinkTicks=autocallIpxRipLinkTicks, mlinkState=mlinkState, ipFirewallStatusIndex=ipFirewallStatusIndex, tftpStatus=tftpStatus, filterTypematchaction=filterTypematchaction, patPort=patPort, isdnParamsDirectoryNumber4=isdnParamsDirectoryNumber4, isdnnumbersMPEnable=isdnnumbersMPEnable, ipxFirewallHigherDestinationNetwork=ipxFirewallHigherDestinationNetwork, portsslipEntry=portsslipEntry, portsTxerrs=portsTxerrs, dhcpProxyActive=dhcpProxyActive, ipcpRemoteCompressionNegotiation=ipcpRemoteCompressionNegotiation, ipRouteAgeCopy=ipRouteAgeCopy, trapaddress=trapaddress, ipxcpRemoteNetworkNumberNegotiation=ipxcpRemoteNetworkNumberNegotiation, portshdlcCompression=portshdlcCompression, autocallIpxSapIndex=autocallIpxSapIndex, dnsDomainRemoteServer=dnsDomainRemoteServer, isdnParamsSubAddrVoice=isdnParamsSubAddrVoice, portstpadStopBits=portstpadStopBits, ipxServiceIpxType=ipxServiceIpxType, portshdlcPriority=portshdlcPriority, pppAuthLocalId=pppAuthLocalId, portspppName=portspppName, ipFirewallSourceAddress=ipFirewallSourceAddress, ipFirewallBidir=ipFirewallBidir, defaultalert=defaultalert, pppExtLinkAuthentication=pppExtLinkAuthentication, trapVoiceDown=trapVoiceDown, firewall=firewall, isdnParamsSpid4=isdnParamsSpid4, ipxRouteIpxType=ipxRouteIpxType, portsslipName=portsslipName, isdnParamsNetworkType=isdnParamsNetworkType, ipxServiceNode=ipxServiceNode, autocallIpxSapNode=autocallIpxSapNode, autocallIpxIdle=autocallIpxIdle, autocallIpxTransportControl=autocallIpxTransportControl, pppIpxcpConfigTableEntry=pppIpxcpConfigTableEntry, autocallIpxSapDirectNetwork=autocallIpxSapDirectNetwork, isdnportsDemand=isdnportsDemand, autocallMacIdle=autocallMacIdle, radiusUsername=radiusUsername, portsslipRxParity=portsslipRxParity, autocallIpxDefault=autocallIpxDefault, dnsProfileMode=dnsProfileMode, autocallIpxSapNearest=autocallIpxSapNearest, autocallIpEntry=autocallIpEntry, remoteaccessMib=remoteaccessMib, portshdlcScramble=portshdlcScramble, dayoftheweek=dayoftheweek, autocallIpxSapEntry=autocallIpxSapEntry, isdnnumbersNumber1=isdnnumbersNumber1, officeConnectRemote520s=officeConnectRemote520s, autocallIpxSapPpp=autocallIpxSapPpp, ipOutRipUpdates=ipOutRipUpdates, portsType=portsType, ipxForwardDatagrams=ipxForwardDatagrams, isdnnumbersPppAuthentication=isdnnumbersPppAuthentication, officeConnectRemote510s=officeConnectRemote510s, dnsProxyActive=dnsProxyActive, ipxServicesTable=ipxServicesTable, autocallIpIndex=autocallIpIndex, isdnbands=isdnbands, portstaDemandpriority=portstaDemandpriority, dhcpWINSTable=dhcpWINSTable, date=date, autocallIpxNode=autocallIpxNode, isdnnumbersPpp=isdnnumbersPpp, portstaAtzstring=portstaAtzstring, mlinkEntry=mlinkEntry, portstaCompression=portstaCompression, portsslipIpAddress=portsslipIpAddress, patMode=patMode, ipxInRipErrors=ipxInRipErrors, ipRouteTypeCopy=ipRouteTypeCopy, filterActiononmatch=filterActiononmatch, ipRouteInfoCopy=ipRouteInfoCopy, isdnnumbersIpMask=isdnnumbersIpMask, pppAuthTableEntry=pppAuthTableEntry, accessBuilderInternet400s=accessBuilderInternet400s, ipFirewallTcpsyn=ipFirewallTcpsyn, ip=ip, portsvoiceTable=portsvoiceTable, ipxFirewallLowerSourceSocket=ipxFirewallLowerSourceSocket, autocallIpxSapService=autocallIpxSapService, portstpadTxFlowControl=portstpadTxFlowControl, ipFirewallConfigTableEntry=ipFirewallConfigTableEntry, system=system, portstpadEntry=portstpadEntry, minPoolSize=minPoolSize, ipxServicesTableEntry=ipxServicesTableEntry, ipxServiceNextHopNode=ipxServiceNextHopNode, autocallMacEntry=autocallMacEntry, autocallIpxRipTicks=autocallIpxRipTicks, bootpIdle=bootpIdle, dhcpAutoLease=dhcpAutoLease, autocallIpxSapIsdnType=autocallIpxSapIsdnType, ipcpMaximumTerminateRequests=ipcpMaximumTerminateRequests, filterSource=filterSource, ipxServiceMode=ipxServiceMode)
mibBuilder.exportSymbols("REMOTEACCESS-MIB", officeConnectRemote520u=officeConnectRemote520u, pppIpxcpConfigTable=pppIpxcpConfigTable, portslanName=portslanName, portshdlcName=portshdlcName, ipxOutSapRequests=ipxOutSapRequests, passwdsTable=passwdsTable, publiccommunity=publiccommunity, portspppLinespeed=portspppLinespeed, trapAlarm=trapAlarm, portsslipBaud=portsslipBaud, portslanIpMask=portslanIpMask, isdnParamsReportBusy=isdnParamsReportBusy, pppExtLcpRemoteMRUEnabled=pppExtLcpRemoteMRUEnabled, ipFirewallLowerSourcePort=ipFirewallLowerSourcePort, pppExtLcpRemoteCHAPEnabled=pppExtLcpRemoteCHAPEnabled, portsEntry=portsEntry, isdnbandsAllowlist=isdnbandsAllowlist, portstaIdlethresh=portstaIdlethresh, pppExtLcpConfigTable=pppExtLcpConfigTable, ipxOutDiscards=ipxOutDiscards, isdnnumbersTesttime=isdnnumbersTesttime, ipInRipRequests=ipInRipRequests, ipxFirewallBidir=ipxFirewallBidir, filterFiltermcast=filterFiltermcast, autocallIpxRipDirectNetwork=autocallIpxRipDirectNetwork, portsCompress=portsCompress, autocallIpIsdn=autocallIpIsdn, ipFirewallMode=ipFirewallMode, cscmTrapEvent=cscmTrapEvent, filterBytecount=filterBytecount, pppExtLcpRemoteACCM=pppExtLcpRemoteACCM, isdnbandsBridgeListBridgeName=isdnbandsBridgeListBridgeName, portshdlcIdleperiod=portshdlcIdleperiod, dnsMaxServerTimeout=dnsMaxServerTimeout, autocallIpxMode=autocallIpxMode, serviceConnect2000BaseBri=serviceConnect2000BaseBri, isdnhistoryTable=isdnhistoryTable, portspppStopBits=portspppStopBits, login=login, ipRouteIfIndexCopy=ipRouteIfIndexCopy, isdnCliMode=isdnCliMode, bootpDelaySecs=bootpDelaySecs, serviceConnect2000Base=serviceConnect2000Base, isdnportsDestination=isdnportsDestination)

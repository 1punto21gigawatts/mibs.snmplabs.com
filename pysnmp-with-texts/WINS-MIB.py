#
# PySNMP MIB module WINS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/WINS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:36:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
software, microsoft = mibBuilder.importSymbols("MSFT-MIB", "software", "microsoft")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter64, enterprises, TimeTicks, IpAddress, iso, Integer32, NotificationType, Unsigned32, MibIdentifier, Gauge32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter64", "enterprises", "TimeTicks", "IpAddress", "iso", "Integer32", "NotificationType", "Unsigned32", "MibIdentifier", "Gauge32", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wins = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2))
par = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2, 1))
pull = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2, 2))
push = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2, 3))
datafiles = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2, 4))
cmd = MibIdentifier((1, 3, 6, 1, 4, 1, 311, 1, 2, 5))
parWinsStartTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsStartTime.setDescription('Wins start time')
parLastPScvTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastPScvTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastPScvTime.setDescription('Most recent date and time at which planned scavenging took place. Planned scavenging happens at intervals specified in the registry. Scavenging involves changing owned non-refreshed entries to the released state. Further, replicas may be changed to tombstones, tombstones maye be deleted and revalidation of old replicas may take place')
parLastATScvTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastATScvTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastATScvTime.setDescription('Most recent data and time at which scavenging as a result of administrative action took place')
parLastTombScvTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastTombScvTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastTombScvTime.setDescription('Most recent data and time at which replica tombstone scavenging took place')
parLastVerifyScvTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastVerifyScvTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastVerifyScvTime.setDescription('Most recent data and time at which revalidation of old active replicas took place')
parLastPRplTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastPRplTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastPRplTime.setDescription('Most recent data and time at which planned replication took place. Planned replication happens at intervals specified in the registry')
parLastATRplTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastATRplTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastATRplTime.setDescription('Most recent data and time at which administrator triggered replication took place.')
parLastNTRplTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastNTRplTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastNTRplTime.setDescription('Most recent data and time at which network triggered replication took place. Network triggered replication happens as a result of an update notification message from a remote WINS')
parLastACTRplTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastACTRplTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastACTRplTime.setDescription('Most recent data and time at which address change triggered replication took place. Address change triggered replication happens when the address of an owned name changes due to a new registration')
parLastInitDbTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastInitDbTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastInitDbTime.setDescription('Most recent data and time at which the local database was populated statically from one or more data files')
parLastCounterResetTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parLastCounterResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: parLastCounterResetTime.setDescription('Most recent data and time at which the local counters were initialized to zero')
parWinsTotalNoOfReg = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfReg.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfReg.setDescription('This variable indicates the number of registrations received')
parWinsTotalNoOfQueries = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfQueries.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfQueries.setDescription('This variable indicates the number of queries received')
parWinsTotalNoOfRel = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfRel.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfRel.setDescription('This variable indicates the number of releases received')
parWinsTotalNoOfSuccRel = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfSuccRel.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfSuccRel.setDescription('This variable indicates the number of releases that succeeded')
parWinsTotalNoOfFailRel = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfFailRel.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfFailRel.setDescription('This variable indicates the number of releases that failed')
parWinsTotalNoOfSuccQueries = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfSuccQueries.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfSuccQueries.setDescription('This variable indicates the number of queries that succeeded')
parWinsTotalNoOfFailQueries = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parWinsTotalNoOfFailQueries.setStatus('mandatory')
if mibBuilder.loadTexts: parWinsTotalNoOfFailQueries.setDescription('This variable indicates the number of queries that failed')
parRefreshInterval = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parRefreshInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parRefreshInterval.setDescription('This variable indicates the refresh interval. Unit is in milliseconds')
parTombstoneInterval = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTombstoneInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parTombstoneInterval.setDescription('This variable indicates the tombstone interval, Unit is in milliseconds')
parTombstoneTimeout = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTombstoneTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: parTombstoneTimeout.setDescription('This variable indicates the tombstone timeout. Unit is in milliseconds')
parVerifyInterval = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parVerifyInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parVerifyInterval.setDescription('This variable indicates the verify interval Unit is in milliseconds.')
parVersCounterStartValLowWord = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 23), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parVersCounterStartValLowWord.setStatus('mandatory')
if mibBuilder.loadTexts: parVersCounterStartValLowWord.setDescription('This variable indicates the low word of the version counter that WINS should start with')
parVersCounterStartValHighWord = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 24), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parVersCounterStartValHighWord.setStatus('mandatory')
if mibBuilder.loadTexts: parVersCounterStartValHighWord.setDescription('This variable indicates the High word of the version counter that WINS should start with')
parRplOnlyWCnfPnrs = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parRplOnlyWCnfPnrs.setStatus('mandatory')
if mibBuilder.loadTexts: parRplOnlyWCnfPnrs.setDescription('This variable indicates whether or not replication should be done with non-configures pnrs. If not set to zero, replication will be done only with partners listed in the registry (except when an update notification comes in)')
parStaticDataInit = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parStaticDataInit.setStatus('mandatory')
if mibBuilder.loadTexts: parStaticDataInit.setDescription('This variable indicates whether Static data should be read in at initialization and reconfiguration time. Update of any mib variable in the parameters group constitutes reconfigurations ')
parLogFlag = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parLogFlag.setStatus('mandatory')
if mibBuilder.loadTexts: parLogFlag.setDescription('This variable indicates whether logging should be done. Default behaviour is to do logging')
parLogFileName = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 28), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parLogFileName.setStatus('mandatory')
if mibBuilder.loadTexts: parLogFileName.setDescription('This variable gives the path to the log file')
parBackupDirPath = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 29), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parBackupDirPath.setStatus('mandatory')
if mibBuilder.loadTexts: parBackupDirPath.setDescription('This variable gives the path to the backup dir')
parDoBackupOnTerm = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parDoBackupOnTerm.setStatus('mandatory')
if mibBuilder.loadTexts: parDoBackupOnTerm.setDescription('This variable specifies whether WINS should do backup on termination. Setting it 1 holds no meaning unless parBackupDirPath is set also')
parMigrateOn = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMigrateOn.setStatus('mandatory')
if mibBuilder.loadTexts: parMigrateOn.setDescription('This variable specifies whether static records in the wins database should be treated as dynamic records during conflicts with new dynamic registrations.')
dfDatafilesTable = MibTable((1, 3, 6, 1, 4, 1, 311, 1, 2, 4, 1), ).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dfDatafilesTable.setStatus('mandatory')
if mibBuilder.loadTexts: dfDatafilesTable.setDescription('A list of datafiles specified under the Datafiles key in the registry. These files are used for statically initialization of the WINS database')
dfDatafileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 311, 1, 2, 4, 1, 1), ).setMaxAccess("readwrite").setIndexNames((0, "WINS-MIB", "dfDatafileIndex"))
if mibBuilder.loadTexts: dfDatafileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dfDatafileEntry.setDescription('data file name')
dfDatafileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 4, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: dfDatafileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dfDatafileIndex.setDescription('Used for indexing entries in the datafiles table. It has no other use')
dfDatafileName = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dfDatafileName.setStatus('mandatory')
if mibBuilder.loadTexts: dfDatafileName.setDescription('Name of the datafile to use for static initialization')
pullInitTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: pullInitTime.setDescription("This variable indicates whether pull should be done at WINS invocation and at reconfiguration. If any pull group's mib variable is set, that constitutes reconfiguration")
pullCommRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullCommRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: pullCommRetryCount.setDescription('This variable gives the retry count in case of comm failure when doing pull replication. This is the max. number of retries that will be done at the interval specified for the Partner before WINS will stop for a certain number (canned) of replication time intervals before starting again.')
pullPnrTable = MibTable((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3), ).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullPnrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrTable.setDescription('A list of Partners with which pull replication needs to be done')
pPullPnrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1), ).setMaxAccess("readwrite").setIndexNames((0, "WINS-MIB", "pullPnrAdd"))
if mibBuilder.loadTexts: pPullPnrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pPullPnrEntry.setDescription('This is the row corresponding to a partner')
pullPnrAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullPnrAdd.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrAdd.setDescription('This is the address of the remote WINS partner')
pullPnrSpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullPnrSpTime.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrSpTime.setDescription('This variable gives the specific time at which pull replication should occur')
pullPnrTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullPnrTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrTimeInterval.setDescription('This variable gives the time interval for pull replication')
pullPnrMemberPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pullPnrMemberPrec.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrMemberPrec.setDescription('This is the precedence to be given to members of the special group pulled from the WINS. Note: the precedence of locally registered members of a special group is more than any replicas pulled in')
pullPnrNoOfSuccRpls = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pullPnrNoOfSuccRpls.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrNoOfSuccRpls.setDescription('The number of times replication was successful with the WINS after invocation or reset of counters')
pullPnrNoOfCommFails = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pullPnrNoOfCommFails.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrNoOfCommFails.setDescription('The number of times replication was unsuccessful with the WINS due to comm. failure (after invocation or reset of counters')
pullPnrVersNoLowWord = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pullPnrVersNoLowWord.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrVersNoLowWord.setDescription('The low word of the highest vers. no found in records owned by this WINS.')
pullPnrVersNoHighWord = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pullPnrVersNoHighWord.setStatus('mandatory')
if mibBuilder.loadTexts: pullPnrVersNoHighWord.setDescription('The high word of the highest vers. no found in records owned by this WINS.')
pushInitTime = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pushInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: pushInitTime.setDescription('This variable indicates whether a push (i.e. notification message) should be done at invocation.')
pushRplOnAddChg = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pushRplOnAddChg.setStatus('mandatory')
if mibBuilder.loadTexts: pushRplOnAddChg.setDescription('This variable indicates whether a notification message should be sent when address changes')
pushPnrTable = MibTable((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 3), ).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pushPnrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pushPnrTable.setDescription('A list of WINS Partners with which push replication is to be initiated')
pushPnrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 3, 1), ).setMaxAccess("readwrite").setIndexNames((0, "WINS-MIB", "pushPnrAdd"))
if mibBuilder.loadTexts: pushPnrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pushPnrEntry.setDescription('This is the row corresponding to the WINS pnr')
pushPnrAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pushPnrAdd.setStatus('mandatory')
if mibBuilder.loadTexts: pushPnrAdd.setDescription('Address of the WINS partner')
pushPnrUpdateCount = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pushPnrUpdateCount.setStatus('mandatory')
if mibBuilder.loadTexts: pushPnrUpdateCount.setDescription('This variable indicates the # of updates that should result in a push message')
cmdPullTrigger = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdPullTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: cmdPullTrigger.setDescription('This variable when set will cause the WINS to pull from the remote WINS identified by the IpAddress')
cmdPushTrigger = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdPushTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: cmdPushTrigger.setDescription('This variable when set will cause the WINS to push a notification message to the remote WINS identified by the IpAddress')
cmdDeleteWins = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdDeleteWins.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDeleteWins.setDescription('This variable when set will cause all information pertaining to a WINS (data records, context information to be deleted from the local WINS. Use this only when owner-address mapping table is getting to near capacity. NOTE: deletion of all information pertaining to the managed WINS is not permitted')
cmdDoScavenging = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdDoScavenging.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDoScavenging.setDescription('This variable when set will cause WINS to do scavenging.')
cmdDoStaticInit = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdDoStaticInit.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDoStaticInit.setDescription('When set WINS will do static initialization using the file specified as the value. If 0 is specified, WINS will do static initialization using the files specified in the registry (can be read-written using Datafile table')
cmdNoOfWrkThds = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdNoOfWrkThds.setStatus('mandatory')
if mibBuilder.loadTexts: cmdNoOfWrkThds.setDescription('Sets the number of worker threads in WINS')
cmdPriorityClass = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdPriorityClass.setStatus('mandatory')
if mibBuilder.loadTexts: cmdPriorityClass.setDescription('Set the priority class of WINS to normal or high')
cmdResetCounters = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: cmdResetCounters.setDescription('Reset the counters. Value is ignored')
cmdDeleteDbRecs = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdDeleteDbRecs.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDeleteDbRecs.setDescription('This variable when set will cause all date records pertaining to a WINS to be deleted from the local WINS. Note: Only data records are deleted.')
cmdDRPopulateTable = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdDRPopulateTable.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRPopulateTable.setDescription('This variable can set to retrieve records of a WINS whose Ip address is provided. When set the table is populated right-away')
cmdDRDataRecordsTable = MibTable((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11), ).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRDataRecordsTable.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRDataRecordsTable.setDescription('This is the table that stores the data records The records are sorted lexicographically by name Note: the table is cached (to save on overhead on WINS) To repopulate the table, set cmdDRDataRecordsTable mib var')
cmdDRRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1), ).setMaxAccess("readwrite").setIndexNames((0, "WINS-MIB", "cmdDRRecordName"))
if mibBuilder.loadTexts: cmdDRRecordEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordEntry.setDescription('data record owned by WINS whose address was specified when CmdDRRecordsTable was set')
cmdDRRecordName = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRRecordName.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordName.setDescription('Name in the record')
cmdDRRecordAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRRecordAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordAddress.setDescription("Address(es) of the record. If the record is a multihomed record or a special group, the addresses are returned sequentially in pairs. Each pair is comprised of the address of the owner wins followed by the address of the machine (multihomed)/member (special group). Note: Following snmp's convention, the records are always returned in network byte order")
cmdDRRecordType = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unique", 0), ("normalgroup", 1), ("specialgroup", 2), ("multihomed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRRecordType.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordType.setDescription('Type of the record')
cmdDRRecordPersistenceType = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dynamic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRRecordPersistenceType.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordPersistenceType.setDescription('Persistence type of the record')
cmdDRRecordState = MibTableColumn((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("active", 0), ("released", 1), ("tombstone", 2), ("deleted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdDRRecordState.setStatus('mandatory')
if mibBuilder.loadTexts: cmdDRRecordState.setDescription('State of the record.')
cmdWinsVersNoLowWord = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdWinsVersNoLowWord.setStatus('mandatory')
if mibBuilder.loadTexts: cmdWinsVersNoLowWord.setDescription('The low word of the version number counter of the WINS')
cmdWinsVersNoHighWord = MibScalar((1, 3, 6, 1, 4, 1, 311, 1, 2, 5, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdWinsVersNoHighWord.setStatus('mandatory')
if mibBuilder.loadTexts: cmdWinsVersNoHighWord.setDescription('The high word of the version number counter of the WINS')
mibBuilder.exportSymbols("WINS-MIB", parMigrateOn=parMigrateOn, cmdDeleteWins=cmdDeleteWins, dfDatafilesTable=dfDatafilesTable, push=push, pullPnrNoOfSuccRpls=pullPnrNoOfSuccRpls, parWinsTotalNoOfSuccQueries=parWinsTotalNoOfSuccQueries, cmdDRRecordType=cmdDRRecordType, parLastCounterResetTime=parLastCounterResetTime, pushPnrUpdateCount=pushPnrUpdateCount, dfDatafileIndex=dfDatafileIndex, pullPnrNoOfCommFails=pullPnrNoOfCommFails, cmdResetCounters=cmdResetCounters, parLogFileName=parLogFileName, cmdWinsVersNoHighWord=cmdWinsVersNoHighWord, cmdPriorityClass=cmdPriorityClass, cmdDRDataRecordsTable=cmdDRDataRecordsTable, cmdDRRecordState=cmdDRRecordState, pushInitTime=pushInitTime, cmd=cmd, parRplOnlyWCnfPnrs=parRplOnlyWCnfPnrs, cmdNoOfWrkThds=cmdNoOfWrkThds, parDoBackupOnTerm=parDoBackupOnTerm, parWinsTotalNoOfFailRel=parWinsTotalNoOfFailRel, pullPnrVersNoLowWord=pullPnrVersNoLowWord, pullPnrTimeInterval=pullPnrTimeInterval, cmdDRRecordEntry=cmdDRRecordEntry, parLastVerifyScvTime=parLastVerifyScvTime, cmdPullTrigger=cmdPullTrigger, pPullPnrEntry=pPullPnrEntry, pushPnrTable=pushPnrTable, parLastNTRplTime=parLastNTRplTime, pushRplOnAddChg=pushRplOnAddChg, parWinsTotalNoOfFailQueries=parWinsTotalNoOfFailQueries, pullCommRetryCount=pullCommRetryCount, cmdDoScavenging=cmdDoScavenging, parLogFlag=parLogFlag, parWinsTotalNoOfQueries=parWinsTotalNoOfQueries, pullPnrVersNoHighWord=pullPnrVersNoHighWord, pullPnrMemberPrec=pullPnrMemberPrec, parRefreshInterval=parRefreshInterval, datafiles=datafiles, parLastTombScvTime=parLastTombScvTime, parLastATRplTime=parLastATRplTime, pullInitTime=pullInitTime, parLastPScvTime=parLastPScvTime, parWinsTotalNoOfRel=parWinsTotalNoOfRel, parVersCounterStartValHighWord=parVersCounterStartValHighWord, parVerifyInterval=parVerifyInterval, parLastInitDbTime=parLastInitDbTime, pullPnrTable=pullPnrTable, pullPnrSpTime=pullPnrSpTime, parLastPRplTime=parLastPRplTime, dfDatafileEntry=dfDatafileEntry, pull=pull, wins=wins, pushPnrAdd=pushPnrAdd, parVersCounterStartValLowWord=parVersCounterStartValLowWord, cmdDRPopulateTable=cmdDRPopulateTable, parTombstoneTimeout=parTombstoneTimeout, parWinsTotalNoOfReg=parWinsTotalNoOfReg, pullPnrAdd=pullPnrAdd, parStaticDataInit=parStaticDataInit, parTombstoneInterval=parTombstoneInterval, cmdDRRecordPersistenceType=cmdDRRecordPersistenceType, parLastACTRplTime=parLastACTRplTime, parWinsTotalNoOfSuccRel=parWinsTotalNoOfSuccRel, cmdDRRecordAddress=cmdDRRecordAddress, cmdDRRecordName=cmdDRRecordName, cmdWinsVersNoLowWord=cmdWinsVersNoLowWord, parBackupDirPath=parBackupDirPath, cmdPushTrigger=cmdPushTrigger, pushPnrEntry=pushPnrEntry, parWinsStartTime=parWinsStartTime, cmdDeleteDbRecs=cmdDeleteDbRecs, dfDatafileName=dfDatafileName, cmdDoStaticInit=cmdDoStaticInit, parLastATScvTime=parLastATScvTime, par=par)

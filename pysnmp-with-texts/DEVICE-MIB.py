#
# PySNMP MIB module DEVICE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEVICE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:41:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
device, coriolisMibs = mibBuilder.importSymbols("CORIOLIS-MIB", "device", "coriolisMibs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter64, ObjectIdentity, Counter32, Bits, Integer32, NotificationType, iso, MibIdentifier, NotificationType, TimeTicks, Gauge32, Unsigned32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter64", "ObjectIdentity", "Counter32", "Bits", "Integer32", "NotificationType", "iso", "MibIdentifier", "NotificationType", "TimeTicks", "Gauge32", "Unsigned32", "IpAddress")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
deviceMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 5812, 1, 1))
if mibBuilder.loadTexts: deviceMIB.setLastUpdated('0007270000Z')
if mibBuilder.loadTexts: deviceMIB.setOrganization('Coriolis Networks')
if mibBuilder.loadTexts: deviceMIB.setContactInfo(' Shubhra Garg Postal: 330 Codman Hill Road, Boxboro MA, 01719. Tel: +1 978 264 1904 Fax: +1 978 264 1929 E-mail: shubhra@coriolisnet.com')
if mibBuilder.loadTexts: deviceMIB.setDescription('The MIB module for chassis level information for coriolis boxes')
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 5812, 1, 2))
systime = MibIdentifier((1, 3, 6, 1, 4, 1, 5812, 1, 3))
chassisAutoConfig = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisAutoConfig.setStatus('current')
if mibBuilder.loadTexts: chassisAutoConfig.setDescription('Configuration of the element - is it automatic?')
chassisIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisIpAddr.setStatus('current')
if mibBuilder.loadTexts: chassisIpAddr.setDescription('The ip address of the element.')
chassisId = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 21, 25))).clone(namedValues=NamedValues(("optiFlow5500", 1), ("optiFlow5000", 2), ("optiFlow3500", 3), ("optiFlow3000", 4), ("optiFlow3500thirteen", 5), ("optiFlow3000thirteen", 6), ("optiFlow1010", 21), ("optiFlow1020", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisId.setStatus('current')
if mibBuilder.loadTexts: chassisId.setDescription('The chassis identifier of the element')
chassisCharacter = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("gne", 1), ("ne", 2), ("sne", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisCharacter.setStatus('current')
if mibBuilder.loadTexts: chassisCharacter.setDescription('The character of the element that is saved in non volatile storage. This will take affect after next cold/warm start of the node.')
chassisElemReachStatus = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reachable", 1), ("unreachable", 2))))
if mibBuilder.loadTexts: chassisElemReachStatus.setStatus('current')
if mibBuilder.loadTexts: chassisElemReachStatus.setDescription('Whether GNE is reachable from this NE')
chassisNumElemReachable = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisNumElemReachable.setStatus('current')
if mibBuilder.loadTexts: chassisNumElemReachable.setDescription('Number of elements reachable from this element')
chassisCurrentCharacter = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("gne", 1), ("ne", 2), ("sne", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisCurrentCharacter.setStatus('current')
if mibBuilder.loadTexts: chassisCurrentCharacter.setDescription('The character of the element that is currently being active.')
chassisFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fail", 1), ("good", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: chassisFanStatus.setStatus('current')
if mibBuilder.loadTexts: chassisFanStatus.setDescription('Indicates the status of the Chassis Fan.')
chassisPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 5812, 1, 2, 10), )
if mibBuilder.loadTexts: chassisPowerSupplyTable.setStatus('current')
if mibBuilder.loadTexts: chassisPowerSupplyTable.setDescription('The table for chassis power supply.')
chassisPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5812, 1, 2, 10, 1), ).setIndexNames((0, "DEVICE-MIB", "chassisPowerSupplyNumber"))
if mibBuilder.loadTexts: chassisPowerSupplyEntry.setStatus('current')
if mibBuilder.loadTexts: chassisPowerSupplyEntry.setDescription('Entry containing information on power supply.')
chassisPowerSupplyNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 2, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: chassisPowerSupplyNumber.setStatus('current')
if mibBuilder.loadTexts: chassisPowerSupplyNumber.setDescription('The index for the chassis power supply table.')
chassisPowerSupplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("present", 1), ("absent", 2), ("tempHot", 3), ("tempNorm", 4), ("fault", 5), ("noFault", 6), ("fail", 7), ("noFail", 8)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: chassisPowerSupplyStatus.setStatus('current')
if mibBuilder.loadTexts: chassisPowerSupplyStatus.setDescription('Indicates the status of the Chassis power supply.')
chassisFWStatus = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("ok", 0), ("bad-host", 1), ("net-drv", 2), ("file-not-found", 3), ("task-not-found", 4), ("read-error", 5), ("unknown-image-type", 6), ("out-of-memory", 7), ("write-error", 8), ("busy", 9), ("spawn-failed", 10), ("in-progress", 11), ("state-error", 12), ("bad-ip-addr", 13), ("bad-msg", 14), ("unknown-msg", 15), ("retries-expired", 16), ("reg-ipc", 17), ("fault", 18), ("lock-failure", 19), ("locked", 20), ("invalid-image-header", 21), ("crc-mismatch", 22), ("not-a-gne", 23), ("signature-mismatch", 24), ("last-instance", 25), ("init-not-complete", 26), ("abort", 27), ("pending", 28)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: chassisFWStatus.setStatus('current')
if mibBuilder.loadTexts: chassisFWStatus.setDescription(' The statuses for chassis firmware update or rollback.')
ringFWStatus = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("ok", 0), ("bad-host", 1), ("net-drv", 2), ("file-not-found", 3), ("task-not-found", 4), ("read-error", 5), ("unknown-image-type", 6), ("out-of-memory", 7), ("write-error", 8), ("busy", 9), ("spawn-failed", 10), ("in-progress", 11), ("state-error", 12), ("bad-ip-addr", 13), ("bad-msg", 14), ("unknown-msg", 15), ("retries-expired", 16), ("reg-ipc", 17), ("fault", 18), ("lock-failure", 19), ("locked", 20), ("invalid-image-header", 21), ("crc-mismatch", 22), ("not-a-gne", 23), ("signature-mismatch", 24), ("last-instance", 25), ("init-not-complete", 26), ("abort", 27), ("pending", 28)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ringFWStatus.setStatus('current')
if mibBuilder.loadTexts: ringFWStatus.setDescription(' The statuses for ring firmware update or rollback ')
ftpServerIP = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 13), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ftpServerIP.setStatus('current')
if mibBuilder.loadTexts: ftpServerIP.setDescription('Where the firmware was located')
controlFilePath = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 14), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: controlFilePath.setStatus('current')
if mibBuilder.loadTexts: controlFilePath.setDescription('Path to the new control file')
versionString = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 15), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: versionString.setStatus('current')
if mibBuilder.loadTexts: versionString.setDescription('control file version string')
syslogUnknownEvent = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 16), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: syslogUnknownEvent.setStatus('current')
if mibBuilder.loadTexts: syslogUnknownEvent.setDescription("An unknown event occurs when the event Manager gets an event-type which it doesn't know about. This is an almost impossible event to occur..as all event-types are first defined and made known to the event-manager.")
syslogUnknownVersion = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 17), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: syslogUnknownVersion.setStatus('current')
if mibBuilder.loadTexts: syslogUnknownVersion.setDescription("For any given image, all events will have a constant version number. All events are preceded by a 'common_header' which will have a version. Again, if the event-manager doesn't recognize the version, it generates 'unknownVersion' event. But again, this is very unlikely to happen as for any given image, all events will have the same common_hdr version.")
chassisRoutingProt = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("rip", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisRoutingProt.setStatus('current')
if mibBuilder.loadTexts: chassisRoutingProt.setDescription(' This variable is used to dynamically initiate RIP or OSPF on the switch. Setting this variable to none causes RIP or OSPF to be shutdown if they have been enabled ')
chassisSubnetIp = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisSubnetIp.setStatus('current')
if mibBuilder.loadTexts: chassisSubnetIp.setDescription(' This object gives the subnet IP Address of the chassis.')
chassisSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisSubnetMask.setStatus('current')
if mibBuilder.loadTexts: chassisSubnetMask.setDescription(' This object provides the subnet mask of the chassis.')
chassisRingsOnMaster = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisRingsOnMaster.setStatus('current')
if mibBuilder.loadTexts: chassisRingsOnMaster.setDescription(' This object gives a comma separated list of ring IDs for which this SNE acts as a master. This object is valid only for an SNE.')
chassisCurrentRingsOnMaster = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisCurrentRingsOnMaster.setStatus('current')
if mibBuilder.loadTexts: chassisCurrentRingsOnMaster.setDescription(' This object gives the current list of ring IDs which this master (SNE) controls. If rings are added or taken-off, the system has to be rebooted to provide the correct list. This is valid only for an SNE.')
chassisFailoverPreserveRings = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 2, 23), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisFailoverPreserveRings.setStatus('current')
if mibBuilder.loadTexts: chassisFailoverPreserveRings.setDescription(' This object gives a comma separated list of ring IDs that are to be preserved across module failures. ')
systimeTimingMode = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tmExt", 1), ("tmLine", 2), ("tmFreerun", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeTimingMode.setStatus('current')
if mibBuilder.loadTexts: systimeTimingMode.setDescription('The type of timing used by the device. External (default for OptiFlow 5000) - Primary Clock Source is always BITS1. - Secondary Clock Source is always BITS2. Line (default for OptiFlow 3000/3500) - Primary Clock Source may be a switch module or an I/O module. - Secondary Clock Source may be a switch module, an I/O module or the internal oscillator. Freerun - Clock source is the internal oscillator (Primary Clock Source and Secondary Clock Source not used).')
systimePriBITSFraming = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("t1SF", 1), ("t1ESF4K", 2), ("t1T1DM", 3), ("t1T1DMAlt", 4), ("t1SLC96", 5), ("e1", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriBITSFraming.setStatus('current')
if mibBuilder.loadTexts: systimePriBITSFraming.setDescription(' This is the Primary BITS basic line framing. Default is T1-ESF-4K. t1SF - Super Frame framing method used on T1 circuits. SF consists of 12 frames of 192 bits each, with the 193rd bit providing error checking and other functions. SF is superseded by ESF, but is still widely used. Also called D4 framing. t1ESF4K - The default method. Extended Super Frame framing method used on T1 circuits that consists of 24 frames of 192 bits each, with the 193rd bit providing timing and other functions. ESF is an enhanced version of SF. t1T1DM - Data Mode. t1T1DMAlt - Data MOde A. t1SLC96 - Subscriber Lopp Carrier, 96 lines. e1 - Wide-area digital transmission scheme used predominantly in Europe that carries data at a arate of 2.048 Mbps.')
systimeSecBITSFraming = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("t1SF", 1), ("t1ESF4K", 2), ("t1T1DM", 3), ("t1T1DMAlt", 4), ("t1SLC96", 5), ("e1", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecBITSFraming.setStatus('current')
if mibBuilder.loadTexts: systimeSecBITSFraming.setDescription(' This is the Secondary BITS basic line framing. Default is T1-ESF-4K. t1SF - Super Frame framing method used on T1 circuits. SF consists of 12 frames of 192 bits each, with the 193rd bit providing error checking and other functions. SF is superseded by ESF, but is still widely used. Also called D4 framing. t1ESF4K - The default method. Extended Super Frame framing method used on T1 circuits that consists of 24 frames of 192 bits each, with the 193rd bit providing timing and other functions. ESF is an enhanced version of SF. t1T1DM - Data Mode. t1T1DMAlt - Data MOde A. t1SLC96 - Subscriber Lopp Carrier, 96 lines. e1 - Wide-area digital transmission scheme used predominantly in Europe that carries data at a arate of 2.048 Mbps.')
systimePriBITSCoding = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ami", 1), ("b8zs", 2), ("hdb3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriBITSCoding.setStatus('current')
if mibBuilder.loadTexts: systimePriBITSCoding.setDescription(' This is the primary BITS line coding. Default is B8ZS. Valid when timing_mode is EXT. AMI - Alternate Mask Inversion (valid when PrimaryBITSFraming = T1). B8ZS - Bianry 8 Zero Substitution (the default). Valid when PrimaryBITSFraming = T1). HDB3 - High Density Bipolar 3 (valid when PrimaryBITSFraming = E1).')
systimeSecBITSCoding = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ami", 1), ("b8zs", 2), ("hdb3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecBITSCoding.setStatus('current')
if mibBuilder.loadTexts: systimeSecBITSCoding.setDescription(' This is the seconday BITS line coding. Default is B8ZS. Valid when timing mode is EXT. AMI - Alternate Mask Inversion (valid when PrimaryBITSFraming = T1). B8ZS - Bianry 8 Zero Substitution (the default). Valid when PrimaryBITSFraming = T1). HDB3 - High Density Bipolar 3 (valid when PrimaryBITSFraming = E1).')
systimePriClkSrcId = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriClkSrcId.setStatus('current')
if mibBuilder.loadTexts: systimePriClkSrcId.setDescription(' This is the primary timing interface clock. bits1 - Valid when the timing mode is EXT. bits2 - Valid when the timing mode is EXT. iosc - Internal Oscillator (valid when the timing mode is LINE. ')
systimeSecClkSrcId = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecClkSrcId.setStatus('current')
if mibBuilder.loadTexts: systimeSecClkSrcId.setDescription(' This is the secondary timing interface clock bits1 - Valid when the timing mode is EXT. bits2 - Valid when the timing mode is EXT. iosc - Internal Oscillator (valid when the timing mode is LINE.')
systimeClkReference = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("crAuto", 1), ("crPri", 2), ("crSec", 3), ("crHoldover", 4), ("crStandby", 5), ("crStandbypri", 6), ("crStandbysec", 7), ("crFreerun", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeClkReference.setStatus('current')
if mibBuilder.loadTexts: systimeClkReference.setDescription('Automatic(default) - This automatically selects a Stratum 3 or better clock from the Primary Clock Source, Secondary Clock Source, Holdover Clock, Standby Clock or internal oscillator. Primary - This is the permanent selection of the Primary Clock Source if the Primary Clock Source is valid at the time of request. Secondary - This is the permanent selection of the Secondary Clock Source if the Secondary Clock Source is valid at the time of request. Standby - This is the permanent selection of the Standby Clock Source if the Standby Clock Source is valid at the time of request. Standby / Primary - This is the permanent selection of the Standby / Primary Clock Source if the Standby / Primary Clock Source is valid at the time of request. Standby / Secondary - This is the permanent selection of the Standby / Secondary Clock Source if the Standby / Secondary Clock Source is valid at the time of request. Freerun - This is the permanent selection of the internal oscillator.')
systimeClkRevertive = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeClkRevertive.setStatus('current')
if mibBuilder.loadTexts: systimeClkRevertive.setDescription(" Sets the method by which the device (equipment) returns to using the Primary Clock Source after the Primary Clock Source has failed. Options: Enable - enables attempting to return to the Primary Clock Source at any time. Disable - disables 'attempting at any time' and forces return to the Primary Clock Source as defined by pri_cs_use_limit and pri_cs_use_interval. This is the default setting. This setting avoids excessive switching between clock sources.")
systimeStandbyClkEnable = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeStandbyClkEnable.setStatus('current')
if mibBuilder.loadTexts: systimeStandbyClkEnable.setDescription(' This enables use of standby management module clock reference. It enables using the primary clock source, secondary clock source or holdover on the standby management module when those on the active management module are not acceptable. The default state is Enabled.')
systimePriCSNVTime = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriCSNVTime.setStatus('current')
if mibBuilder.loadTexts: systimePriCSNVTime.setDescription(' Primary Clock Source Normal Validation Time. This is the amount of time required to validate the primary clock source when not in the holdover state. Default is 3 seconds.')
systimeSecCSNVTime = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecCSNVTime.setStatus('current')
if mibBuilder.loadTexts: systimeSecCSNVTime.setDescription(' Secondary Clock Source Normal Validation Time. This is the amount of time required to validate the secondary clock source when not in the holdover state. Default is 3 seconds.')
systimePriCSHVTime = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriCSHVTime.setStatus('current')
if mibBuilder.loadTexts: systimePriCSHVTime.setDescription(' Primary Clock Source Holdover Validation Time. This is the amount of time required to validate the primary clock source when in the holdover state. Default is 10 seconds.')
systimeSecCSHVTime = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecCSHVTime.setStatus('current')
if mibBuilder.loadTexts: systimeSecCSHVTime.setDescription(' Secondary Clock Source Holdover Validation Time. This is the amount of time required to validate the secondary clock source when in the holdover state. Default is 10 seconds.')
systimePriCSUseLimit = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriCSUseLimit.setStatus('current')
if mibBuilder.loadTexts: systimePriCSUseLimit.setDescription(' This is the number of times the primary clock source may be used over the time interval primary clock source use interval (systimeSecCSUseInterval). It permits several attempts at using the primary clock source when prior attempts did not pass the Stratum 3 requirement. The default is 3 times.')
systimeSecCSUseLimit = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecCSUseLimit.setStatus('current')
if mibBuilder.loadTexts: systimeSecCSUseLimit.setDescription(' This is the number of times the secondary clock source may be used over the time interval Secondary clock source use interval (systimeSecCSUseInterval). It permits several attempts at using the secondary clock source when prior attempts did not pass the Stratum 3 requirement. The default is 3 times.')
systimeStandbyCSUseLimit = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeStandbyCSUseLimit.setStatus('current')
if mibBuilder.loadTexts: systimeStandbyCSUseLimit.setDescription(' This is the number of times the standby clock source may be used over the time interval standby clock source use interval (systimeStandbyCSUseInterval).It permits several attempts at using the standby clock source when prior attempts did not pass the Stratum 3 requirement. The default is 3 times.')
systimePriCSUseInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimePriCSUseInterval.setStatus('current')
if mibBuilder.loadTexts: systimePriCSUseInterval.setDescription(' This is the time interval used to reset the Primary Clock Source used count. Ranges from 1 to 96 hours. Default is 1 hour.')
systimeSecCSUseInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeSecCSUseInterval.setStatus('current')
if mibBuilder.loadTexts: systimeSecCSUseInterval.setDescription(' This is the time interval used to reset the Secondary Clock Source used count. Ranges from 1 to 96 hours. Default is 1 hour.')
systimeStandbyCSUseInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeStandbyCSUseInterval.setStatus('current')
if mibBuilder.loadTexts: systimeStandbyCSUseInterval.setDescription(' This is the time interval used to reset the Standby Clock Source used count. Ranges from 1 to 96 hours. Default is 1 hour.')
systimeCREventEnable = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systimeCREventEnable.setStatus('current')
if mibBuilder.loadTexts: systimeCREventEnable.setDescription(' This generates an alarm when the clock reference used changes from either the primary or the secondary. Default is Enable.')
systimeCRInUse = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("crAuto", 1), ("crPri", 2), ("crSec", 3), ("crHoldover", 4), ("crStandby", 5), ("crStandbypri", 6), ("crStandbysec", 7), ("crFreerun", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systimeCRInUse.setStatus('current')
if mibBuilder.loadTexts: systimeCRInUse.setDescription(' This indicates the current clock reference. Automatic(default) - This automatically selects a Stratum 3 or better clock from the Primary Clock Source, Secondary Clock Source, Holdover Clock, Standby Clock or internal oscillator. Primary - This is the permanent selection of the Primary Clock Source if the Primary Clock Source is valid at the time of request. Secondary - This is the permanent selection of the Secondary Clock Source if the Secondary Clock Source is valid at the time of request. Standby - This is the permanent selection of the Standby Clock Source if the Standby Clock Source is valid at the time of request. Standby / Primary - This is the permanent selection of the Standby / Primary Clock Source if the Standby / Primary Clock Source is valid at the time of request. Standby / Secondary - This is the permanent selection of the Standby / Secondary Clock Source if the Standby / Secondary Clock Source is valid at the time of request. Freerun - This is the permanent selection of the internal oscillator.')
systimeCRUsedCount = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 3, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systimeCRUsedCount.setStatus('current')
if mibBuilder.loadTexts: systimeCRUsedCount.setDescription(' This indicates the number of times this clock had been used.')
deviceNMSTable = MibTable((1, 3, 6, 1, 4, 1, 5812, 1, 4), )
if mibBuilder.loadTexts: deviceNMSTable.setStatus('current')
if mibBuilder.loadTexts: deviceNMSTable.setDescription('A table that contains information about the set of network management stations that are allowed to manage this device')
deviceNMSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1), ).setIndexNames((0, "DEVICE-MIB", "deviceNMSIndex"))
if mibBuilder.loadTexts: deviceNMSEntry.setStatus('current')
if mibBuilder.loadTexts: deviceNMSEntry.setDescription('A list of information for each NMS allowed to manage this device')
deviceNMSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: deviceNMSIndex.setStatus('current')
if mibBuilder.loadTexts: deviceNMSIndex.setDescription(' The index of the Network Management Station ')
deviceNMSIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceNMSIpAddress.setStatus('current')
if mibBuilder.loadTexts: deviceNMSIpAddress.setDescription(' The IP address of the Network Management Station')
deviceNMSAccessType = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accessTypeTrapEnabled", 1), ("accessTypeTrapDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceNMSAccessType.setStatus('current')
if mibBuilder.loadTexts: deviceNMSAccessType.setDescription(' This determines whether the NMS can receive traps or not')
deviceNMSMIBIITrapList = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceNMSMIBIITrapList.setStatus('current')
if mibBuilder.loadTexts: deviceNMSMIBIITrapList.setDescription(" The bitmask describing the MIB II traps that this NMS can receive. The MIBII traps are the following: 0 = coldStart 1 = warmStart 2 = linkDown 3 = linkUp 4 = authenticationFailure 5 = egpNeighborLoss This is a 1 byte bit-mask. If only the least significant bit is set, it means 'coldStart' traps are allowed to be received by the device. If the bit-mask is '00100101', it means that the device is enabled to receive the traps coldStart, linkDown and egpNeighborLoss.")
deviceNMSEnterpriseTrapList = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceNMSEnterpriseTrapList.setStatus('current')
if mibBuilder.loadTexts: deviceNMSEnterpriseTrapList.setDescription(' The bitmask describing the enterprise specific traps that this NMS can receive. These kinds of traps begin at the value 7 (values 0-6 are taken by the MIBII traps). The bit-mask is handled in the way this example shows for a specific trapType of (say) 55: specificTrapType/8 = 55/8 = 6. specificTrapType % 8 = 7. There are 20 bytes in this mask and the 7th bit in the 6th byte is set.')
deviceNMSTrapSevAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("trapSevClear", 1), ("trapSevInfo", 2), ("trapSevWarning", 3), ("trapSevMinor", 4), ("trapSevMajor", 5), ("trapSevCritical", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceNMSTrapSevAllowed.setStatus('current')
if mibBuilder.loadTexts: deviceNMSTrapSevAllowed.setDescription(' This determines the trap severities the NMS can receive')
sysMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 5812, 1, 5))
numBytesFree = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBytesFree.setStatus('current')
if mibBuilder.loadTexts: numBytesFree.setDescription(' The number of bytes free in the system memory ')
numBlocksFree = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBlocksFree.setStatus('current')
if mibBuilder.loadTexts: numBlocksFree.setDescription(' The number of blocks free in the system memory ')
avgBlockSizeFree = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avgBlockSizeFree.setStatus('current')
if mibBuilder.loadTexts: avgBlockSizeFree.setDescription(' The average block size that is free in the system memory ')
maxBlockSizeFree = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxBlockSizeFree.setStatus('current')
if mibBuilder.loadTexts: maxBlockSizeFree.setDescription(' The largest block size that is free in the memory ')
numBytesAlloc = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBytesAlloc.setStatus('current')
if mibBuilder.loadTexts: numBytesAlloc.setDescription(' The number of bytes of system memory that have been allocated by tasks and system services ')
numBlocksAlloc = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBlocksAlloc.setStatus('current')
if mibBuilder.loadTexts: numBlocksAlloc.setDescription(' The number of blocks of system memory that have been allocated in the system ')
avgBlockSizeAlloc = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avgBlockSizeAlloc.setStatus('current')
if mibBuilder.loadTexts: avgBlockSizeAlloc.setDescription(' The average memory block size that has been allocated in the system ')
memUtilization = MibScalar((1, 3, 6, 1, 4, 1, 5812, 1, 5, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memUtilization.setStatus('current')
if mibBuilder.loadTexts: memUtilization.setDescription(' This gives the memory utilization in terms of percentage ')
sysTask = MibIdentifier((1, 3, 6, 1, 4, 1, 5812, 1, 6))
taskTable = MibTable((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1), )
if mibBuilder.loadTexts: taskTable.setStatus('current')
if mibBuilder.loadTexts: taskTable.setDescription("Represents the target's task table. Each entry in this table represents a task")
taskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1), ).setIndexNames((0, "DEVICE-MIB", "taskId"))
if mibBuilder.loadTexts: taskEntry.setStatus('current')
if mibBuilder.loadTexts: taskEntry.setDescription(' Each entry contains information with regards to a task in the system ')
taskId = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskId.setStatus('current')
if mibBuilder.loadTexts: taskId.setDescription(' This is the task ID assigned by VxWorks to a task in the system. A taskId of zero specifies a new task.')
taskName = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskName.setStatus('current')
if mibBuilder.loadTexts: taskName.setDescription(' This is the name of the VxWorks task. This value can only be specified (set) at task creation.')
taskPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskPriority.setStatus('current')
if mibBuilder.loadTexts: taskPriority.setDescription('The priority of the VxWorks task. This value can be in the range from 0, the highest priority, to 255, the lowest priority.')
taskStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("task-ready", 1), ("task-suspended", 2), ("task-delay", 3), ("task-deleted", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskStatus.setStatus('current')
if mibBuilder.loadTexts: taskStatus.setDescription('This field specifies the current task status. It can be used to change the current task state. For example, to suspend a task, the value of taskStatus is changed to task-suspended, to delete a task the value is changed to task-deleted, etc...')
taskOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskOptions.setStatus('current')
if mibBuilder.loadTexts: taskOptions.setDescription("This value represents the sum of the following options: value option 1 VX_SUPERVISOR_MODE(read-only) 2 VX_UNBREAKABLE (break points ignored) 4 VX_DEALLOC_STACK (deallocate stack) 8 VX_FP_TASK (floating point support) 16 VX_STDIO (read-only) 128 VX_PRIVATE_ENV (private env. variables) 256 VX_NO_STACK_FILL (don't fill stack) All the options above can be set at task creation time. However, once the task is executing the only option that can be changed is VX_UNBREAKABLE. The option is toggled based on the current setting.")
taskMain = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskMain.setStatus('current')
if mibBuilder.loadTexts: taskMain.setDescription('This is the name of the entry function for the VxWorks task. This name can only be specified when a task is created (entry added in the table). The symbol must exist in the VxWorks target.')
taskStackPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackPtr.setStatus('current')
if mibBuilder.loadTexts: taskStackPtr.setDescription('This is the saved stack pointer for the task.')
taskStackBase = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackBase.setStatus('current')
if mibBuilder.loadTexts: taskStackBase.setDescription('This is the address of the bottom of the stack of the VxWorks task.')
taskStackPos = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackPos.setStatus('current')
if mibBuilder.loadTexts: taskStackPos.setDescription('This is the effective top of the stack in the current task state.')
taskStackEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackEnd.setStatus('current')
if mibBuilder.loadTexts: taskStackEnd.setDescription('This is the address of the top of the stack of the VxWorks task.')
taskStackSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taskStackSize.setStatus('current')
if mibBuilder.loadTexts: taskStackSize.setDescription('This is the actual size of the stack in bytes. The size of the stack can only be specified at task creation (adding an entry to the table).')
taskStackSizeUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackSizeUsage.setStatus('current')
if mibBuilder.loadTexts: taskStackSizeUsage.setDescription('The number of bytes currently in use by the task from the stack.')
taskStackMaxUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackMaxUsed.setStatus('current')
if mibBuilder.loadTexts: taskStackMaxUsed.setDescription('This is the maximum number of bytes that have been used by the task from the stack.')
taskStackFree = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskStackFree.setStatus('current')
if mibBuilder.loadTexts: taskStackFree.setDescription('This is the number of bytes that are free currently in the task stack.')
taskErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 1, 6, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: taskErrorStatus.setStatus('current')
if mibBuilder.loadTexts: taskErrorStatus.setDescription('This is the most recent error status for this task.')
emSysLogCorrupt = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,8))
if mibBuilder.loadTexts: emSysLogCorrupt.setDescription(' Event log entries got corrupted ')
emSysLogCapacity = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,9))
if mibBuilder.loadTexts: emSysLogCapacity.setDescription(' Event logs nearing capacity ')
emSysLogBackUpDelete = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,10))
if mibBuilder.loadTexts: emSysLogBackUpDelete.setDescription(' Event backup log file deleted ')
emSysLogEvIdWrap = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,11))
if mibBuilder.loadTexts: emSysLogEvIdWrap.setDescription(' Event Id wrapped')
emErrLogCorrupt = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,14))
if mibBuilder.loadTexts: emErrLogCorrupt.setDescription(' Corrupt error log file ')
emErrLogCapacity = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,15))
if mibBuilder.loadTexts: emErrLogCapacity.setDescription(' Error logs nearing capacity ')
emErrLogBackUpDelete = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,16))
if mibBuilder.loadTexts: emErrLogBackUpDelete.setDescription(' Backup error log deleted ')
emErrLogEvIdWrap = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,17))
if mibBuilder.loadTexts: emErrLogEvIdWrap.setDescription(' Error event id wrapped ')
emSysLogsCleared = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,18))
if mibBuilder.loadTexts: emSysLogsCleared.setDescription(' System logs cleared ')
emErrLogsCleared = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,19))
if mibBuilder.loadTexts: emErrLogsCleared.setDescription(' Error logs cleared ')
systimeClkReferenceChange = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,23)).setObjects(("DEVICE-MIB", "systimeClkReference"))
if mibBuilder.loadTexts: systimeClkReferenceChange.setDescription('Change in the systiming clk reference to primary, secondary, holdover or freerun')
powerSupplyStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,42)).setObjects(("DEVICE-MIB", "chassisPowerSupplyNumber"), ("DEVICE-MIB", "chassisPowerSupplyStatus"))
if mibBuilder.loadTexts: powerSupplyStatusChange.setDescription('Indicates the change in power supply status of the chassis.')
fanStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,43)).setObjects(("DEVICE-MIB", "chassisFanStatus"))
if mibBuilder.loadTexts: fanStatusChange.setDescription('Indicates the change in fan status of the chassis.')
chassisFWUpdate = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,54)).setObjects(("DEVICE-MIB", "chassisFWStatus"), ("DEVICE-MIB", "chassisIpAddr"), ("DEVICE-MIB", "ftpServerIP"), ("DEVICE-MIB", "controlFilePath"))
if mibBuilder.loadTexts: chassisFWUpdate.setDescription('Chassis FirmWare update event.')
chassisFWActivate = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,52)).setObjects(("DEVICE-MIB", "chassisFWStatus"), ("DEVICE-MIB", "chassisIpAddr"), ("DEVICE-MIB", "versionString"))
if mibBuilder.loadTexts: chassisFWActivate.setDescription('Chassis FirmWare activate event.')
ringFWUpdate = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,53)).setObjects(("DEVICE-MIB", "ringFWStatus"), ("DEVICE-MIB", "chassisIpAddr"), ("DEVICE-MIB", "ftpServerIP"), ("DEVICE-MIB", "controlFilePath"))
if mibBuilder.loadTexts: ringFWUpdate.setDescription('Ring FirmWare update event.')
ringFWActivate = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,51)).setObjects(("DEVICE-MIB", "ringFWStatus"), ("DEVICE-MIB", "chassisIpAddr"), ("DEVICE-MIB", "versionString"))
if mibBuilder.loadTexts: ringFWActivate.setDescription('Ring FirmWare activate event.')
sysLogUnknownEvent = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,57)).setObjects(("DEVICE-MIB", "syslogUnknownEvent"))
if mibBuilder.loadTexts: sysLogUnknownEvent.setDescription('Unknown Event.')
sysLogUnknownVersion = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,58)).setObjects(("DEVICE-MIB", "syslogUnknownVersion"))
if mibBuilder.loadTexts: sysLogUnknownVersion.setDescription('Unknown Version.')
mibBuilder.exportSymbols("DEVICE-MIB", systimePriCSHVTime=systimePriCSHVTime, systimeTimingMode=systimeTimingMode, maxBlockSizeFree=maxBlockSizeFree, taskStackMaxUsed=taskStackMaxUsed, numBlocksFree=numBlocksFree, chassisAutoConfig=chassisAutoConfig, deviceNMSIpAddress=deviceNMSIpAddress, chassisCharacter=chassisCharacter, deviceNMSMIBIITrapList=deviceNMSMIBIITrapList, chassisNumElemReachable=chassisNumElemReachable, deviceNMSTable=deviceNMSTable, emErrLogCapacity=emErrLogCapacity, chassisFWStatus=chassisFWStatus, emSysLogBackUpDelete=emSysLogBackUpDelete, systimeSecBITSCoding=systimeSecBITSCoding, deviceNMSIndex=deviceNMSIndex, avgBlockSizeAlloc=avgBlockSizeAlloc, avgBlockSizeFree=avgBlockSizeFree, taskStackPtr=taskStackPtr, numBytesFree=numBytesFree, taskMain=taskMain, deviceNMSEnterpriseTrapList=deviceNMSEnterpriseTrapList, systimePriCSNVTime=systimePriCSNVTime, emErrLogsCleared=emErrLogsCleared, chassisCurrentRingsOnMaster=chassisCurrentRingsOnMaster, taskStatus=taskStatus, systimeSecCSNVTime=systimeSecCSNVTime, ringFWStatus=ringFWStatus, ringFWActivate=ringFWActivate, versionString=versionString, systimeClkRevertive=systimeClkRevertive, ringFWUpdate=ringFWUpdate, taskStackSizeUsage=taskStackSizeUsage, deviceMIB=deviceMIB, emSysLogEvIdWrap=emSysLogEvIdWrap, syslogUnknownVersion=syslogUnknownVersion, fanStatusChange=fanStatusChange, chassisFanStatus=chassisFanStatus, systimeSecCSHVTime=systimeSecCSHVTime, systimePriBITSCoding=systimePriBITSCoding, emSysLogsCleared=emSysLogsCleared, sysLogUnknownEvent=sysLogUnknownEvent, chassisPowerSupplyNumber=chassisPowerSupplyNumber, taskEntry=taskEntry, PYSNMP_MODULE_ID=deviceMIB, systimeStandbyCSUseLimit=systimeStandbyCSUseLimit, systimePriCSUseInterval=systimePriCSUseInterval, chassis=chassis, sysLogUnknownVersion=sysLogUnknownVersion, systimeStandbyClkEnable=systimeStandbyClkEnable, taskStackSize=taskStackSize, taskTable=taskTable, systimeClkReferenceChange=systimeClkReferenceChange, chassisFailoverPreserveRings=chassisFailoverPreserveRings, chassisPowerSupplyTable=chassisPowerSupplyTable, systimePriCSUseLimit=systimePriCSUseLimit, chassisRingsOnMaster=chassisRingsOnMaster, sysMemory=sysMemory, taskStackBase=taskStackBase, emSysLogCapacity=emSysLogCapacity, chassisElemReachStatus=chassisElemReachStatus, systimeStandbyCSUseInterval=systimeStandbyCSUseInterval, memUtilization=memUtilization, chassisId=chassisId, systimeSecCSUseLimit=systimeSecCSUseLimit, systimeClkReference=systimeClkReference, chassisFWActivate=chassisFWActivate, chassisFWUpdate=chassisFWUpdate, taskName=taskName, systimeCRUsedCount=systimeCRUsedCount, taskStackPos=taskStackPos, ftpServerIP=ftpServerIP, chassisPowerSupplyStatus=chassisPowerSupplyStatus, deviceNMSTrapSevAllowed=deviceNMSTrapSevAllowed, taskStackEnd=taskStackEnd, systimeCREventEnable=systimeCREventEnable, emErrLogCorrupt=emErrLogCorrupt, systimePriClkSrcId=systimePriClkSrcId, chassisSubnetIp=chassisSubnetIp, chassisCurrentCharacter=chassisCurrentCharacter, emSysLogCorrupt=emSysLogCorrupt, systimeCRInUse=systimeCRInUse, systimeSecBITSFraming=systimeSecBITSFraming, systimeSecCSUseInterval=systimeSecCSUseInterval, emErrLogBackUpDelete=emErrLogBackUpDelete, taskErrorStatus=taskErrorStatus, taskPriority=taskPriority, systimeSecClkSrcId=systimeSecClkSrcId, chassisPowerSupplyEntry=chassisPowerSupplyEntry, chassisRoutingProt=chassisRoutingProt, sysTask=sysTask, syslogUnknownEvent=syslogUnknownEvent, powerSupplyStatusChange=powerSupplyStatusChange, taskOptions=taskOptions, taskStackFree=taskStackFree, systime=systime, systimePriBITSFraming=systimePriBITSFraming, numBytesAlloc=numBytesAlloc, deviceNMSEntry=deviceNMSEntry, taskId=taskId, chassisIpAddr=chassisIpAddr, controlFilePath=controlFilePath, chassisSubnetMask=chassisSubnetMask, emErrLogEvIdWrap=emErrLogEvIdWrap, numBlocksAlloc=numBlocksAlloc, deviceNMSAccessType=deviceNMSAccessType)

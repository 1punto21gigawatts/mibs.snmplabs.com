#
# PySNMP MIB module ZHONE-COM-BRIDGE-REC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHONE-COM-BRIDGE-REC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:46:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
AtmVpIdentifier, AtmVcIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier", "AtmVcIdentifier")
ifIndex, InterfaceIndex, ifPhysAddress, ifAlias = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex", "ifPhysAddress", "ifAlias")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, MibIdentifier, TimeTicks, ModuleIdentity, NotificationType, Integer32, Counter64, IpAddress, Unsigned32, iso, Counter32, Gauge32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "MibIdentifier", "TimeTicks", "ModuleIdentity", "NotificationType", "Integer32", "Counter64", "IpAddress", "Unsigned32", "iso", "Counter32", "Gauge32", "ObjectIdentity")
TextualConvention, DisplayString, PhysAddress, MacAddress, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress", "MacAddress", "TruthValue")
zhoneModules, zhone, zhoneBridge = mibBuilder.importSymbols("Zhone", "zhoneModules", "zhone", "zhoneBridge")
ZhoneRowStatus, ZhoneAdminString = mibBuilder.importSymbols("Zhone-TC", "ZhoneRowStatus", "ZhoneAdminString")
bridgeRecord = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 6, 77))
bridgeRecord.setRevisions(('2014-11-11 07:01', '2014-09-06 05:32', '2014-05-16 05:58', '2014-04-07 10:38', '2013-11-12 08:56', '2013-10-10 11:21', '2013-08-14 03:51', '2013-06-18 11:03', '2013-06-14 12:08', '2013-06-06 21:02', '2013-05-10 03:59', '2013-02-20 13:34', '2012-10-22 15:59', '2012-06-12 12:40', '2012-04-11 14:44', '2012-03-15 07:04', '2012-03-06 09:05', '2012-01-26 17:35', '2011-11-15 17:59', '2011-09-20 02:49', '2011-07-06 17:07', '2011-06-21 11:46', '2011-06-16 21:07', '2011-05-15 10:35', '2011-02-15 17:16', '2011-01-31 21:16', '2010-08-31 17:26', '2010-08-16 12:47', '2010-07-30 12:07', '2010-03-17 10:32', '2010-02-08 15:08', '2010-02-08 15:07', '2010-02-08 15:05', '2010-02-08 14:55', '2009-09-16 16:35', '2009-09-10 16:49', '2009-07-06 16:21', '2009-06-26 10:42', '2009-05-01 15:21', '2009-03-23 16:23', '2009-02-13 16:50', '2009-01-14 13:24', '2008-11-04 09:54', '2008-04-18 14:29', '2008-01-10 16:28', '2007-11-21 07:23', '2007-11-12 14:21', '2007-11-08 13:08', '2007-10-10 15:28', '2007-09-25 09:31', '2007-07-18 16:04', '2007-04-16 17:36', '2007-04-11 12:22', '2006-11-27 09:25', '2006-09-10 10:02', '2006-04-26 15:51', '2006-02-01 14:19', '2006-01-20 15:00', '2005-11-11 16:46', '2005-08-01 12:13', '2005-07-20 17:13', '2004-12-17 15:06', '2004-06-02 16:09', '2004-04-15 13:26', '2004-02-01 13:21', '2003-10-07 14:22', '2003-09-22 09:32', '2003-07-29 19:21', '2001-09-18 11:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bridgeRecord.setRevisionsDescriptions(('1. add more fields to bridgeStats 2. add mroe fields to bridgeCmd 3. clean up group errors 4. clean up IGMP STATS code generation', '1. Add BridgeInterfaceStatus table', 'Fix NetworkAddress compatibility issues with netsnmp', '1. add staticBridgePathTable 2. add bridgePathIfLookupTable 3. add bridgePathAddressLookupTable', '1. Add byte counters to bridgeStats 2. Add GPON object to bridge I/F record table', 'Add bytes option to bridgeIfOnDemandStatsEnabled', 'Modified the range for unicastAgingPeriod', 'Add IPOB bridge types', 'reorder bridge-type values to be compatible with ZMS', 'add bridgeType to Bridge Interface Record', 'Changed the start range of packetRuleGroupIndex to 0 to support default packet group', 'Added IGMP V3 stats.', 'Added secMvrAddr(15) as a new static-bridge address type.', 'Add bridgeIgmpTable.', 'Added staticBridgeIgmpDscp.', "changed some defaults for 'stp-params' due to support of MSTP.", 'Change default value of eapsConfigSnmpTrap to TRUE', 'Added 4 new Bridge Storm Detect counters to the BridgeStats table.', 'Added bridgeStormDetect(46) enum to packetRuleType and created new bridgestormDetection Trap.', 'Added eaps topology table.', 'Add bridgeState and bridgeIfUnblock', 'Add mac address string to bridge loop trap', 'Add bridgeLoopDetection Trap.', 'Added staticBridgeLoopPrevention in static bridge table', 'Added vlanParms(14) to staticBridgeAddressType.', 'Added a value clrIgmpStats to bridgeCmdOperation enum field', 'Changed bridgeIfMaxVideoStreams upper limit to 1024.', 'Add igmpCustomIPAddress to static bridge profile', 'Add Vlan and Xlan translation to bridge I/F', 'Added bridgeIgmpStats', 'Added eapsTrapPrefix (traps for EAPS)', 'Added eapsStatsTable (row of eapsStatsEntry for each domain).', 'Added EapsStatusTable (row of eapsStatusEntry for each domain state machine).', 'Added eapsConfigRowStatus to eapsConfigEntry', 'Added eapsProtectedVlanEntryIndex to the eapsProtectedVlanTable. Fixed a couple of typos. Swapped the Zhone markup comments for eapsProtectedVlanLowerRange and UpperRange because they were in reverse order. The swapping of the markup comments was completely cosmetic and did not change any functionality or behavior.', 'Add blockAsym(5) and blockAll(6) to flap control.', 'Changed INDEX for eapsConfigEntry to primaryPortLineGroup, secondaryPortLineGroup, controlVlan', "Added 'enable' field to eaps-domain-record Added QUICK_ACCESS keyword to 'domainName'", 'Added EAPS Group to MIB.', '1. Rename bridgeIfIngressStats to bridgeIfOnDemandStatsEnabled 2. Rename bridgeStatsRulesSupported to bridgeOnDemandStatsRulesSupported 3. Rename bridgeStatsIngressRemaing to bridgeOnDemandStatsRulesRemaining', 'Added bridgeIfIngressStats to bridgeInterfaceTable and bridgeStatsIngressSupported,bridgeStatsIngressRemaing to bridgeStatsTable', 'Add bridgeStatsTable', 'Added aclAllow/aclDeny to packetRuleType and updated description field.', 'Add packet-rule-type colorAwareRateLimitDiscard', 'Add staticBridgeAddressType values dhcpIpAddr and dhcpMacAddr', 'Fixed a comment.', 'Added stpBind, and mstpInstance', 'Added profile for STP.', 'Added dstMacSwapStatic and dstMacSwapDynamic to the packetRuleType enum values.', 'Added fast(4) to staticBridgeFlapControl.', 'Added new objects in bridgeInterfaceEntry record. Then new objects are bridgeIfTableBasedFilter and bridgeIfDhcpLearn.', 'Add bridgePPoETable.', 'Add fields floodUnknown and floodMulticast to bridge-interface record', 'Add isPPPoA to bridgeInterface and bridgeInsertPPPoEVendorTag(99) to bridgeConfigType.', 'Add fields to bridgeInterface and staticBridge entries. Add a bridgeConfigType.', 'added slanId to index for bridgeIfLookup, and bridgeaddressLookup.', 'V01.00.12 - Added slan to static-Bridge profile reqd for QinQ support.', 'V01.00.11 - Added support for QinQ', 'V01.00.10 - Add staticBridgeFlapControl.', 'V01.00.09 - Added bridgeIfLookupFlush to bridgeIfLookupTableEntry and bridgeAddressLookupFlush to bridgeAddressLookupTable.', 'V01.00.08 - Added bridgeIfVlanIdCOS, bridgeIfOutgoingCOSOption, bridgeIfOutgoingCOSValue to bridgeInterfaceTableEntry.', 'V01.00.07 - added two new address types to staticBridgeAddressTyoe.', 'V01.00.06 - Added bridgeIfCustomDHCP, bridgeIfConfigGroupIndex to bridgeInterfaceTableEntry. Added bridgeIfConfigGroupNextIndexTable Added bridgeConfigTable Removed bridgeForbidOui from staticBridgeAddressType members ', 'V01.00.05 - Added to staticBridgeAddressType members: bridgeForbidOui, dhcpAllowOui.', 'V01.00.04 - changed lower range of bridgeIfVci to 0 in order to accomate ethernet bridging.', 'V01.00.03 - Add index value to staticBridge. Add lowerIfIndex to BridgeIf.', 'V01.00.02 - Changed staticBridgeEntry INDEX.', 'V01.00.01 - modified for VLAN bridging.', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: bridgeRecord.setLastUpdated('201302200249Z')
if mibBuilder.loadTexts: bridgeRecord.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: bridgeRecord.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: bridgeRecord.setDescription('BRIDGE record MIB IP Software Minneapolis, MN ')
class PacketRuleGroupIndex(TextualConvention, Integer32):
    description = 'Description.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class EapsState(TextualConvention, Integer32):
    description = 'EAPS State Values (per RFC 3619bis). IDLE = 0x00 (EAPS Domain (Master/Transit) still not running) COMPLETE = 0x01 (Master in complete State) FAILED = 0x02 (Master in Failed State) LINKS-UP = 0x03 (Transit in links-up State. Both ring-ports are up) LINK-DOWN = 0x04 (Transit in Link-Down State. One or both ring-ports are down) PREFORWARDING = 0x05 (Transit in Preforwarding State) INIT = 0x06 (Master in Init State)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("idle", 0), ("complete", 1), ("failed", 2), ("links-up", 3), ("link-down", 4), ("preForwarding", 5), ("init", 6))

class BridgeState(TextualConvention, Integer32):
    description = "state as shown in 'bridge show'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))
    namedValues = NamedValues(("up", 1), ("down", 2), ("trouble", 3), ("notAvailable", 4), ("initializing", 5), ("adminDown", 6), ("adminStateTest", 7), ("adminStateNone", 8), ("ready", 9), ("discovering", 10), ("unknown", 11), ("blocked", 12), ("pending", 13), ("disabled", 14), ("learning", 15), ("forwarding", 16), ("blockedFlapping", 17), ("blockedPersistent", 18), ("blockedFlappingPersistent", 19))

class NetworkAddress(OctetString):
    pass

bridgeInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 4, 7, 1)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVci"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVpi"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStripAndInsert"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfCustomARP"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfFilterBroadcast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfLearnIp"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfLearnUnicast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMaxUnicast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfLearnMulticast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfForwardToUnicast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfForwardToMulticast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfForwardToDefault"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeLowerIfIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeAddressLookupStaticOrDynamic"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfLookupStaticOrDynamic"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfCustomDHCP"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeMulticastAging"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfLookupFlush"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfOutgoingCOSValue"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfOutgoingCOSOption"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanIdCOS"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeAddressLookupFlush"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeFlapControl"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagOutgoingCOSValue"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagCOS"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagOutgoingCOSOption"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagStripAndInsert"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagTPID"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleGroupMemberNextIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfEgressPacketRuleGroupIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfIngressPacketRuleGroupIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleGroupIndexNext"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue5"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue4"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue3"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigIsMasterNode"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlanPriority"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigMsgTxInterval"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigTimeout"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigMaxDroppedMessages"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSnmpTrap"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanLowerRange"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanUpperRange"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainEnable"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanEntryIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "genQueryRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "genQueryTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "specQueryRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "specQueryTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v2ReportsRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v2ReportsTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "leavesRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "leavesTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "unknownRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "errorRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "actChans"), ("ZHONE-COM-BRIDGE-REC-MIB", "actHosts"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeLoopPrevention"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3ReportsTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3ReportsRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3SpecQueryTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3SpecQueryRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3GenQueryTx"), ("ZHONE-COM-BRIDGE-REC-MIB", "v3GenQueryRx"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue2"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bridgeInterfaceGroup = bridgeInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: bridgeInterfaceGroup.setDescription('The bridge Interface Record object group. ')
bridgeInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2), )
if mibBuilder.loadTexts: bridgeInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: bridgeInterfaceTable.setDescription('This table contains information required for the management of bridge interfaces.')
bridgeInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgeInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeInterfaceEntry.setDescription('An entry exists for each bridge interface in the system. At a mininum the ifIndex must be present to create a row.')
bridgeIfVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 1), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfVpi.setStatus('current')
if mibBuilder.loadTexts: bridgeIfVpi.setDescription('If this bridge interface is on an ATM VC, the ATM VPI is specified here. If the bridge interface is not an ATM VC, this field is ignored. The VPI value for a VPL or VCL. The value VPI=0 is only allowed for a VCL. For ATM UNIs supporting VPCs the VPI value ranges from 0 to 255. The VPI value 0 is supported for ATM UNIs conforming to the ATM Forum UNI 4.0 Annex 8 (Virtual UNIs) specification. For ATM UNIs supporting VCCs the VPI value ranges from 0 to 255. For ATM NNIs the VPI value ranges from 0 to 4095. The maximum VPI value cannot exceed the value allowable by atmInterfaceMaxVpiBits defined in ATM-MIB.')
bridgeIfVci = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 2), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfVci.setStatus('current')
if mibBuilder.loadTexts: bridgeIfVci.setDescription('If this bridge interface is on an ATM VC, the ATM VCI is specified here. The range is 32...65535. The maximum VCI value cannot exceed the value allowable by atmInterfaceMaxVciBits defined in ATM-MIB. If the bridge interface is not an ATM VC, but for example an ethernet interface, this field should be set to 0.')
bridgeIfVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfVlanId.setStatus('current')
if mibBuilder.loadTexts: bridgeIfVlanId.setDescription('The Virtual LAN Id for VLAN Tag Insertion.')
bridgeIfStripAndInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStripAndInsert.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStripAndInsert.setDescription('If true, enable VLAN Tagging.')
bridgeIfCustomARP = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfCustomARP.setStatus('current')
if mibBuilder.loadTexts: bridgeIfCustomARP.setDescription('If true, send ARP requests selectively or by flood.')
bridgeIfFilterBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfFilterBroadcast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfFilterBroadcast.setDescription('If true, discard non-ARP broadcast packets.')
bridgeIfLearnIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfLearnIp.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLearnIp.setDescription('If true, snoop unicast packets to build ARP table. ')
bridgeIfLearnUnicast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfLearnUnicast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLearnUnicast.setDescription('If true, snoop unicast packets to build MAC paths.')
bridgeIfMaxUnicast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfMaxUnicast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfMaxUnicast.setDescription('Maximum number of unicast addresses for I/F.')
bridgeIfLearnMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfLearnMulticast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLearnMulticast.setDescription('If true, snoop multicast packets for IGMP joins/leaves.')
bridgeIfForwardToUnicast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfForwardToUnicast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfForwardToUnicast.setDescription('If true, attempt to forward via unicast MAC paths.')
bridgeIfForwardToMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfForwardToMulticast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfForwardToMulticast.setDescription('If true, attempt to forward via multicast MAC paths.')
bridgeIfForwardToDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfForwardToDefault.setStatus('current')
if mibBuilder.loadTexts: bridgeIfForwardToDefault.setDescription('If true, attempt to forward via VLAN default paths.')
bridgeLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 14), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeLowerIfIndex.setStatus('current')
if mibBuilder.loadTexts: bridgeLowerIfIndex.setDescription('An entry exists for each bridge interface in the system. Only Ifindex and lower if index is needed to create a row.')
bridgeIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 15), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: bridgeIfRowStatus.setDescription('This object is used to create and remove rows in the table. See bridgeInterfaceEntry description for minimum requirements.')
bridgeIfCustomDHCP = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfCustomDHCP.setStatus('current')
if mibBuilder.loadTexts: bridgeIfCustomDHCP.setDescription('If TRUE, forwards broadcast DHCPOFFER or DHCPACK packets even if bridgeFilterBroadcast is TRUE for that interface. ')
bridgeIfIngressPacketRuleGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 17), PacketRuleGroupIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfIngressPacketRuleGroupIndex.setStatus('current')
if mibBuilder.loadTexts: bridgeIfIngressPacketRuleGroupIndex.setDescription('Index used as partial address of a group of entries in the packetRuleTable, each of which prescribes a filtering condition for the ingress interface.')
bridgeIfVlanIdCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfVlanIdCOS.setStatus('current')
if mibBuilder.loadTexts: bridgeIfVlanIdCOS.setDescription('The Class-Of-Service (COS) value used for VLAN Tag Insertion.')
bridgeIfOutgoingCOSOption = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("outgoingCOSOptionDisable", 1), ("outgoingCOSOptionAll", 2))).clone('outgoingCOSOptionDisable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfOutgoingCOSOption.setStatus('current')
if mibBuilder.loadTexts: bridgeIfOutgoingCOSOption.setDescription('Determines COS setting on packets bridged out this interface. disable - COS setting is untouched. all - COS will be set to bridgeIfOutgoingCOSValue.')
bridgeIfOutgoingCOSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfOutgoingCOSValue.setStatus('current')
if mibBuilder.loadTexts: bridgeIfOutgoingCOSValue.setDescription('The COS value loaded into outgoing tagged packets. Applicable only if interface sends tagged packets and bridgeIfOutgoingCOSOption is outgoingCOSOption_all.')
bridgeIfStagTPID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(33024, 33024), ValueRangeConstraint(34984, 34984), ValueRangeConstraint(37120, 37120), ValueRangeConstraint(37376, 37376), )).clone(33024)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagTPID.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagTPID.setDescription('The value of the tag protocol identifier that is being used for QinQ packets. (0x8100 is default.)')
bridgeIfStagId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagId.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagId.setDescription('The s-tag value that we are expecting to put on packets that are Rxed on this interface.')
bridgeIfStagStripAndInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagStripAndInsert.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagStripAndInsert.setDescription('If true, enable S-tag tagging on this IF.')
bridgeIfStagOutgoingCOSOption = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sTagCOSDisable", 1), ("sTagCOSAll", 2))).clone('sTagCOSDisable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagOutgoingCOSOption.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagOutgoingCOSOption.setDescription('Determines s-tag COS settings on packets bridged out this interface: disable - s-tag COS setting just passed as Rxed. all - s-tag COS will be set with s_tagOutgoingCOSValue.')
bridgeIfStagCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagCOS.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagCOS.setDescription('The s-tag COS to be used when doing s-tag insertion.')
bridgeIfStagOutgoingCOSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfStagOutgoingCOSValue.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagOutgoingCOSValue.setDescription('The s-tag COS value loaded into outgoing tagged packets. Applicaple only if interface sends S-tagged packets and s_tagOutgoingCOSOption is All.')
bridgeIfMcastControlList = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 27), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfMcastControlList.setStatus('current')
if mibBuilder.loadTexts: bridgeIfMcastControlList.setDescription('List of mcast-control-ids this bridge-interface-record is associated with. It is an integer stored as string, and controls which channels a user can watch. Note: unlike for IP, an empty list here allows user to watch all channels.')
bridgeIfMaxVideoStreams = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfMaxVideoStreams.setStatus('current')
if mibBuilder.loadTexts: bridgeIfMaxVideoStreams.setDescription('Maximum number of multicast (video) streams that we will support.')
bridgeIfIsPPPoA = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 29), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfIsPPPoA.setStatus('current')
if mibBuilder.loadTexts: bridgeIfIsPPPoA.setDescription('If true, this interface accepts PPPoA packets and will bridge them out as PPPoE packets.')
bridgeIfFloodUnknown = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 30), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfFloodUnknown.setStatus('current')
if mibBuilder.loadTexts: bridgeIfFloodUnknown.setDescription('If true, flood frames with unknown unicast MAC address that would otherwise be discarded.')
bridgeIfFloodMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 31), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfFloodMulticast.setStatus('current')
if mibBuilder.loadTexts: bridgeIfFloodMulticast.setDescription('If true, flood all multicast traffic received on this bridge to all other ports on this vlan.')
bridgeIfEgressPacketRuleGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 32), PacketRuleGroupIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfEgressPacketRuleGroupIndex.setStatus('current')
if mibBuilder.loadTexts: bridgeIfEgressPacketRuleGroupIndex.setDescription('Index used as partial address of a group of entries in the packetRuleTable, each of which prescribes a filtering condition for the egress interface.')
bridgeIfTableBasedFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 33), Bits().clone(namedValues=NamedValues(("mac", 0), ("ip", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfTableBasedFilter.setStatus('current')
if mibBuilder.loadTexts: bridgeIfTableBasedFilter.setDescription('none : Dynamic IP Filtering on bridge based on DHCP, is disabled. BIT 1(mac) : MAC address based Filtering based on DHCP, is enabled. BIT 2(ip) : IP address based dynamic IP Filtering based on DHCP, is enabled. Defval is changed to correct the Zhone script errors. ')
bridgeIfDhcpLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 34), Bits().clone(namedValues=NamedValues(("mac", 0), ("ip", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfDhcpLearn.setStatus('current')
if mibBuilder.loadTexts: bridgeIfDhcpLearn.setDescription('none :IP address and Mac address are not learned from DHCP packets. BIT 1 (mac): MAC addresses are learned from DHCP packets. ip 2 (ip) : IP addresses are learned from DHCP packets. The Defval is changed to correct the Zhone script errors.')
bridgeIfOnDemandStatsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("bytes", 3))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfOnDemandStatsEnabled.setStatus('current')
if mibBuilder.loadTexts: bridgeIfOnDemandStatsEnabled.setDescription('If true, the on-demand stats collection for this bridge interface will be enabled and packets will be counted. If bytes, the on-demand stats collection for this bridge interface will be enabled and abd bytes will be counted.')
bridgeIfMvrVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfMvrVlan.setStatus('current')
if mibBuilder.loadTexts: bridgeIfMvrVlan.setDescription('The Multicast Vlan Registration (MVR) vlan ID. Multicast video packets with this vlan can be vlan translated out this bridge.')
bridgeIfVlanXlateFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfVlanXlateFrom.setStatus('current')
if mibBuilder.loadTexts: bridgeIfVlanXlateFrom.setDescription("If a packet's VLAN ID value matches this object's value then the packet's VLAN ID will be translated to the value of bridgeIfVlanId. A zero value disables translation.")
bridgeIfSlanXlateFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfSlanXlateFrom.setStatus('current')
if mibBuilder.loadTexts: bridgeIfSlanXlateFrom.setDescription("If a packet's SLAN ID value matches this object's value then the packet's SLAN ID will be translated to the value of bridgeIfStagId. A zero value disables translation.")
bridgeIfBridgeState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 39), BridgeState()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeIfBridgeState.setStatus('current')
if mibBuilder.loadTexts: bridgeIfBridgeState.setDescription('Values: up(1), UP down(2), DWN trouble(3), TRB notAvailable(4), NA initializing(5), INI adminDown(6), ADN adminStateTest(7), TST adminStateNone(8), N/S ready(9), RDY discovering(10), DSC unknown(11), ??? blocked(12), BLK pending(13), PND disabled(14), DIS learning(15), LRN forwarding(16), FWD blockedFlapping(17), BLF blockedPersistent(18), BLP blockedFlappingPersistenr(19), BFP ')
bridgeIfUnblock = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 40), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfUnblock.setStatus('current')
if mibBuilder.loadTexts: bridgeIfUnblock.setDescription('Set to TRUE to unblock a bridge that is blocked due to flapping. ')
bridgeType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("uplink", 1), ("downlink", 2), ("intralink", 4), ("tls", 6), ("rlink", 8), ("pppoa", 9), ("wire", 10), ("mvr", 11), ("user", 12), ("downlinkVideo", 13), ("downlinkData", 14), ("downlinkPPPoE", 15), ("downlinkP2P", 16), ("downlinkVoice", 17), ("downlinkUpstreamMcast", 18), ("ipobTls", 19), ("ipobUplink", 20), ("ipobDownlink", 21)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bridgeType.setStatus('current')
if mibBuilder.loadTexts: bridgeType.setDescription('bridge type')
bridgeIfGponGemPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 42), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfGponGemPortId.setStatus('current')
if mibBuilder.loadTexts: bridgeIfGponGemPortId.setDescription('GPON GEM Port ID used only to create a bridge on a GPON ONU.')
bridgeIfGponTrafficProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 43), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfGponTrafficProfile.setStatus('current')
if mibBuilder.loadTexts: bridgeIfGponTrafficProfile.setDescription('GPON Traffic Profile Index used only to create a bridge on a GPON ONU.')
bridgeIfIncomingCOSOption = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incomingCOSOptionDisable", 1), ("incomingCOSOptionAll", 2))).clone('incomingCOSOptionDisable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfIncomingCOSOption.setStatus('current')
if mibBuilder.loadTexts: bridgeIfIncomingCOSOption.setDescription('Determines COS settings on incoming packets bridged out this interface: disable - COS replcement feature is disabled all - COS will be set with vlanIDCOS.')
bridgeIfStagIncomingCOSOption = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stagIncomingCOSOptionDisable", 1), ("stagIncomingCOSOptionAll", 2))).clone('stagIncomingCOSOptionDisable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfStagIncomingCOSOption.setStatus('current')
if mibBuilder.loadTexts: bridgeIfStagIncomingCOSOption.setDescription('Determines s-tag COS settings on incoming packets bridged out this interface: disable - s-tag COS setting just passed as Rxed. all - s-tag COS will be set with s-tagIdCOS.')
staticBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3), )
if mibBuilder.loadTexts: staticBridgeTable.setStatus('current')
if mibBuilder.loadTexts: staticBridgeTable.setDescription('A collection of staticBridgeEntries.')
staticBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeMacOrIpAddress"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: staticBridgeEntry.setStatus('current')
if mibBuilder.loadTexts: staticBridgeEntry.setDescription('Static Bridge entries are created by the user in order to specify forwarding for a particular interface, vlanId, mac address or ip address, slanId (for QinQ). The INDEX value for staticBridgeEntry consists of following 5 values: ifIndex staticBridgeAddressType bridgeIfVlanId staticBridgeMacOrIpAddress bridgeIfStagId If staticBridgeAddressType is set to macAddr(1), then staticBridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to ipAddr(2), then staticBridgeMacOrIpAddress represents an IP Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to vlanIdAddr(3), then ifIndex and bridgeIfVlanId are used for the bridge path. If staticBridgeAddressType is set to globalAddr(4), then ifIndex is used for the bridge path.')
staticBridgeMacOrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: staticBridgeMacOrIpAddress.setStatus('current')
if mibBuilder.loadTexts: staticBridgeMacOrIpAddress.setDescription('If the staticBridgeAddressType is set to macAddr(1), then this field represents a MAC address. If the staticBridgeAddressType is set to ipAddr(2), then this field represents an IP address.')
staticBridgeAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 7, 8, 9, 10, 13, 14, 15, 720901))).clone(namedValues=NamedValues(("macAddr", 1), ("ipAddr", 2), ("vlanIdAddr", 3), ("globalAddr", 4), ("intralinkAddr", 7), ("globalIntralinkAddr", 8), ("dhcpIpAddr", 9), ("dhcpMacAddr", 10), ("mvrAddr", 13), ("vlanParms", 14), ("secMvrAddr", 15), ("dhcpAllowOui", 720901))))
if mibBuilder.loadTexts: staticBridgeAddressType.setStatus('current')
if mibBuilder.loadTexts: staticBridgeAddressType.setDescription('If staticBridgeAddressType is set to macAddr(1), then staticBridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to ipAddr(2), then staticBridgeMacOrIpAddress represents an IP Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to vlanIdAddr(3) or intralinkAddr(7), then ifIndex and bridgeIfVlanId are used for the bridge path. If staticBridgeAddressType is set to globalAddr(4), globalIntralinkAddr(8), or mvrAddr(13) then ifIndex is used for the bridge path. If staticBridgeAddressType is set to dhcpAllowOui( 720901) then the first 3 bytes of the MAC address contains the OUI that we will allow DHCP addresses to be granted to, global scope. If staticBridgeAddressType is set to dhcpIpAddr(9), or to dhcpMacAddr(10), then the other fields are populated as for address types ipAddr and macAddr respectively, with the difference that these are secure entries, learned by snooping DHCP. If staticBridgeAddressType is set to vlanParms(14), then the static bridge entry holds parameters for the given VLAN and SLAN ID (for example, flap mode, unicast aging period, etc) and is not associated with any specific bridge, but with all bridges with the same VLAN/SLAN ID. For this reason, the IfIndex of this entry must be zero. If staticBridgeAddressType is set to secMvrAddr(15), then the static bridge entry holds parameters for a Secondary MVR path. The VLAN ID of this entry is the Secondary VLAN ID.')
staticBridgeMulticastAging = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeMulticastAging.setStatus('current')
if mibBuilder.loadTexts: staticBridgeMulticastAging.setDescription('Multicast Aging period in tenths of seconds for the specified VLAN. After the specified aging period is met, the VLAN address is deleted from the routing table. A value of 0 indicates that aging is turned off. Maximum value is 2147483647 tenths of seconds, which equates to approximately 2485.51 days.')
staticBridgeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 4), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeRowStatus.setStatus('current')
if mibBuilder.loadTexts: staticBridgeRowStatus.setDescription('Used to create, modify or delete an entry in this table.')
staticBridgeFlapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("disable", 2), ("enable", 3), ("fast", 4))).clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeFlapControl.setStatus('current')
if mibBuilder.loadTexts: staticBridgeFlapControl.setDescription("This object enables or disable Flap Control in the Bridge Filter Table. The value 'disable(2)' turns Flap Control mode off. The values 'enable(3)' or 'fast(4) turn flap control mode on. 'Enable(3)' applies a hold time of 60 secs before allowing addr/IP to be moved to a new port, while 'fast(4)' applies a hold time of 0 secs. A value of 'default(1)' indicates 'Don't Care' and defaults to a disable or enable set by another entry. ")
staticBridgeUnicastAging = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(120, 2147483647), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeUnicastAging.setStatus('current')
if mibBuilder.loadTexts: staticBridgeUnicastAging.setDescription('Multicast Aging period in tenths of seconds for the specified VLAN. After the specified aging period is met, the VLAN address is deleted from the routing table. A value of 0 indicates that aging is turned off. Maximum value is 2147483647 tenths of seconds, which equates to approximately 2485.51 days.')
staticBridgeIgmpQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeIgmpQueryInterval.setStatus('current')
if mibBuilder.loadTexts: staticBridgeIgmpQueryInterval.setDescription('How often (in seconds) we as a bridge inject IGMP query values into the stream.')
staticBridgeFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 8), Bits().clone(namedValues=NamedValues(("igmpProcessJoinAndLeave", 0), ("igmpRespondToQuery", 1), ("igmpUseBridgeIpAddress", 2), ("forceIGMPv2Down", 3), ("forceIGMPv2Up", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeFlags.setStatus('current')
if mibBuilder.loadTexts: staticBridgeFlags.setDescription('none : IGMP Snooping with Proxy reporting is disabled. BIT 0(igmpProcessJoinAndLeave) : igmpProcessJoinandLeave is enabled for IGMP packets. BIT 1(igmpRespondToQuery) : igmpRespondToQuery is enabled for IGMP packets. BIT 2(igmpUseBridgeIpAddress) : igmpUseBridgeIpAddress is enabled for IGMP packets. BIT 3(forceIGMPv2Down) : forceIGMPv2Down is enabled for subscriber side BIT 4(forceIGMPv2Up) : forceIGMPv2Up is enabled for uplink/network side ')
staticBridgeIgmpCustomIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 9), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeIgmpCustomIpAddress.setStatus('current')
if mibBuilder.loadTexts: staticBridgeIgmpCustomIpAddress.setDescription('Allow the configuration of the source IP address for packets that we originate upstream when doing IGMP Porxy on a bridge. ')
staticBridgeLoopPrevention = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("blockAsym", 1), ("blockAll", 2), ("blockAsymAuto", 3), ("blockAllAuto", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticBridgeLoopPrevention.setStatus('current')
if mibBuilder.loadTexts: staticBridgeLoopPrevention.setDescription("This field does the following options,'BlockAsym(1)' blocks a learning bridge if flap is detected between it and an uplink bridge. 'BlockAll(2)' incorporates 'blockAsym(1)' but it also blocks a learning bridge if it flaps against another learning bridge.")
staticBridgeIgmpDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 3, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgeIgmpDscp.setStatus('current')
if mibBuilder.loadTexts: staticBridgeIgmpDscp.setDescription('This parameter indicates DSCP value for igmp traffic. Valid code values: <0-63> Differentiated services codepoint value af11 Mark packets with AF11 dscp (001010) af12 Mark packets with AF12 dscp (001100) af13 Mark packets with AF13 dscp (001110) af21 Mark packets with AF21 dscp (010010) af22 Mark packets with AF22 dscp (010100) af23 Mark packets with AF23 dscp (010110) af31 Mark packets with AF31 dscp (011010) af32 Mark packets with AF32 dscp (011100) af33 Mark packets with AF33 dscp (011110) af41 Mark packets with AF41 dscp (100010) af42 Mark packets with AF42 dscp (100100) af43 Mark packets with AF43 dscp (100110) cs1 Mark packets with CS1(precedence 1) dscp (001000) cs2 Mark packets with CS2(precedence 2) dscp (010000) cs3 Mark packets with CS3(precedence 3) dscp (011000) cs4 Mark packets with CS4(precedence 4) dscp (100000) cs5 Mark packets with CS5(precedence 5) dscp (101000) cs6 Mark packets with CS6(precedence 6) dscp (110000) cs7 Mark packets with CS7(precedence 7) dscp (111000) default Mark packets with default dscp (000000) ef Mark packets with EF dscp (101110)')
bridgeIfLookupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4), )
if mibBuilder.loadTexts: bridgeIfLookupTable.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLookupTable.setDescription('A collection of bridgeIfLookupTable entries.')
bridgeIfLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMacOrIpAddress"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: bridgeIfLookupEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLookupEntry.setDescription('Bridge IfLookup entries are created by the user or learned by the software in order to specify forwarding for a particular interface, vlanId/slanId, mac address or ip address. The INDEX value for bridgeIfLookupEntry consists of following 5 values: bridgeIfAddressType bridgeIfMacOrIpAddress bridgeIfVlanId ifIndex bridgeIfStagId If bridgeIfAddressType is set to unicast_mac(1), then bridgeIfMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId/Slanid and bridgeIfMacOrIpAddress are use for the bridge path. If bridgeIfAddressType is set to multicast_mac(2), then bridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId/SlanId and bridgeIfMacOrIpAddress are used for bridge path. If bridgeIfAddressType is set to ip_address(3), then ifIndex and bridgeIfVlanId/SlanId are used for the bridge path.')
bridgeIfAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unicastMac", 1), ("multicastMac", 2), ("ipAddress", 3), ("dhcpMac", 4), ("dhcpIp", 5), ("ipV6Address", 6), ("dhcpV6Mac", 7), ("dhcpV6Ip", 8))))
if mibBuilder.loadTexts: bridgeIfAddressType.setStatus('current')
if mibBuilder.loadTexts: bridgeIfAddressType.setDescription('If bridgeIfAddressType is set to unicast_mac(1), then bridgeIfMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and bridgeIfMacOrIpAddress are used for the bridge path. If bridgeIfAddressType is set to multicast_mac(2), then bridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and bridgeIfMacOrIpAddress are used for the bridge path. If bridgeIfAddressType is set to ip_address(3), then ifIndex and bridgeIfVlanId are used for the bridge path. If bridgeIfAddressType is set to dhcp_mac(4), or dhcp_ip(5), then the address is as desribed for types 1 and 3, respectively, and the address was learned by snooping DHCP packets. ipV6Address(6) is the same as ipAddress(3) except for IPv6 address format. dhcpV6Mac(7) is the same as dhacpMac(4) except for IPv6 address format. dhcpV7Ip(8) is the same as dhcpIp(5) except for IPv6 address format.')
bridgeIfMacOrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4, 1, 2), PhysAddress())
if mibBuilder.loadTexts: bridgeIfMacOrIpAddress.setStatus('current')
if mibBuilder.loadTexts: bridgeIfMacOrIpAddress.setDescription('If bridgeIfAddressType is set to FILTER_ENTRY_UNICAST_MAC(1) or to FILTER_ENTRY_MULTICAST_MAC(2), or to FILTER_ENTRY_DHCP_MAC(4), then bridgeIfMacOrIpAddress represents a MAC Address. If bridgeIfAddressType is set to FILTER_ENTRY_IP_ADDRESS(3), or to FILTER_ENTRY_DHCP_IP(5), then bridgeIfMacOrIpAddress represents an IP Address.')
bridgeIfLookupStaticOrDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("staticEntry", 1), ("dynamicEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeIfLookupStaticOrDynamic.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLookupStaticOrDynamic.setDescription('If bridgeIfLookupStaticOrDynamic is set to 1, then this table entry is static and persistent. If bridgeIfLookupStaticOrDynamic is set to 2, then this table entry is learned and is not persistent.')
bridgeIfLookupFlush = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 4, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIfLookupFlush.setStatus('current')
if mibBuilder.loadTexts: bridgeIfLookupFlush.setDescription("The object 'bridgeIfLookupFlush' allows a user to flush learned entries in the bridgeFilterTable when the ifIndex of the entry is not known. A combination of address type, MAC or IP address and vlan ID is used to determine the ifIndex of the entry to be removed. Setting the object to 'true' causes the flush action to occur. After the flush action is taken, the value of bridgeIfLookupFlush is immediately set back to 'false'.")
bridgeAddressLookupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 5), )
if mibBuilder.loadTexts: bridgeAddressLookupTable.setStatus('current')
if mibBuilder.loadTexts: bridgeAddressLookupTable.setDescription('A collection of bridgeAddressLookupTable entries.')
bridgeAddressLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMacOrIpAddress"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: bridgeAddressLookupEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeAddressLookupEntry.setDescription('BridgeAddressLookup entries are created by the user or learned by the software in order to specify forwarding for a particular interface, vlanId/slanId, mac address or ip address. The INDEX value for bridgeIfLookupEntry consists of following 5 values: ifIndex bridgeIfAddressType bridgeIfMacOrIpAddress bridgeIfVlanId bridgeIfStagId')
bridgeAddressLookupStaticOrDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("staticEntry", 1), ("dynamicEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeAddressLookupStaticOrDynamic.setStatus('current')
if mibBuilder.loadTexts: bridgeAddressLookupStaticOrDynamic.setDescription('If bridgeAddressLookupStaticOrDynamic is set to 1, then this table entry is static and persistent. If bridgeAddressLookupStaticOrDynamic is set to 2, then this table entry is learned and is not persistent.')
bridgeAddressLookupFlush = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 5, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeAddressLookupFlush.setStatus('current')
if mibBuilder.loadTexts: bridgeAddressLookupFlush.setDescription("The object 'bridgeIfAddressFlush' allows a user to flush learned entries in the bridgeFilterTable when the ifIndex of the entry is known. The ifIndex is used to determine which interface is to be removed. Setting the object to 'true' causes the flush action to occur. After the flush action is taken, the value of bridgeIfLookupFlush is immediately set back to 'false'.")
packetRuleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6))
packetRuleGroupIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 1), PacketRuleGroupIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetRuleGroupIndexNext.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupIndexNext.setDescription('A scalar representing the next available Group Index for Packet Rule Table Entries.')
packetRuleGroupNextIndexTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 2), )
if mibBuilder.loadTexts: packetRuleGroupNextIndexTable.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupNextIndexTable.setDescription('A collection of entries each representing the next available index for that group.')
packetRuleGroupNextIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 2, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "packetRuleGroupIndex"))
if mibBuilder.loadTexts: packetRuleGroupNextIndexEntry.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupNextIndexEntry.setDescription('A packetRuleGroupNextIndexEntry contains the next available index for that packetRuleGroup.')
packetRuleGroupMemberNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 2, 1, 1), PacketRuleGroupIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetRuleGroupMemberNextIndex.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupMemberNextIndex.setDescription('The next index available in a given packetRuleGroup for a new packetRuleEntry.')
packetRuleTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3), )
if mibBuilder.loadTexts: packetRuleTable.setStatus('current')
if mibBuilder.loadTexts: packetRuleTable.setDescription('A collection of packetRuleEntries.')
packetRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "packetRuleGroupIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "packetRuleGroupMemberIndex"))
if mibBuilder.loadTexts: packetRuleEntry.setStatus('current')
if mibBuilder.loadTexts: packetRuleEntry.setDescription('Packet Rule entries are created by the user in order to specify filtering or other packet manipulation for a particular interface.')
packetRuleGroupMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: packetRuleGroupMemberIndex.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupMemberIndex.setDescription('The index of a packetRuleEntry in a given packetRuleGroup.')
packetRuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(37, 38, 41, 42, 43, 44, 45, 46, 97, 98, 99, 100, 103, 104, 114, 120))).clone(namedValues=NamedValues(("dstMacSwapStatic", 37), ("dstMacSwapDynamic", 38), ("dscpToCos", 41), ("promoteFirstEncapsulationVlan", 42), ("filterFirstEncapsulationVlan", 43), ("promoteSecondEncapsulationVlan", 44), ("filterSecondEncapsulationVlan", 45), ("bridgeStormDetect", 46), ("bridgeInsertOption82", 97), ("dhcpRelay", 98), ("bridgeInsertPPPoEVendorTag", 99), ("rateLimitDiscard", 100), ("colorAwareRateLimitDiscard", 103), ("aclAllow", 104), ("bridgeForbidOui", 114), ("aclDeny", 120)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleType.setStatus('current')
if mibBuilder.loadTexts: packetRuleType.setDescription('A 32-bit value which determines a filter to be applied to packets on the interface matching the pattern specified in packetRuleValue. The size and offset of the pattern in the packet will depend on packetRuleType. Bits may be set in packetRuleType determining properties of the filtering to be applied: BRIDGE_FORBID = 0x10 BRIDGE_INPUT = 0x20 BRIDGE_TERMINATE = 0x40 When BRIDGE_FORBID is set, packets matching the pattern are dropped; when it is clear, matching packets are forwarded. When BRIDGE_INPUT is set, filtering is applied to packets received on the interface; when it is clear, filtering is applied to packets to be transmitted on the interface. When BRIDGE_TERMINATE is set, processing of a packet matching the pattern ends the scan of filtering specifications; when it is clear, processing continues. Values of packetRuleType include DST_MAC_SWAP_STATIC = 0x25 DST_MAC_SWAP_DYNAMIC = 0x28 BRIDGE_INSERT_OPTION82 = 0x61 BRIDGE_DHCP_RELAY = 0x62 BRIDGE_INSERT_PPPOE_VENDOR_TAG = 0x63 BRIDGE_FORBID_OUI = 0x72 RATE_LIMIT_DISCARD = 0x64 COLOR_AWARE_RATE_LIMIT_DISCARD = 0x67')
packetRuleValue = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue.setDescription("A variable-length field whose meaning depends on packetRuleType. If bridgeForbidOui, it specifies a bit pattern to be matched in a packet, stored as a string, but specified in the pattern 'nn:nn:nn...nn:nn', where 'nn' is a hex number specifying a byte of the pattern. E.g. a packetRuleValue of '00:02:02' specifies the OUI to be dropped. If dhcpRelay, it is ascii integer which specifies dhcp subnet group. If bridgeInsertOption82, this value is ignored. If bridgeInsertPPPoEVendorTag, it specifies an ASCII string of up to 48 bytes to be inserted into PPPoE discovery packets (PADI/PADR) which transit this node. String will be inserted as a Vendor-Specific tag. If rateLimitDiscard, this value represents a maximum rate (in kbps). If aclAllow/aclDeny, a text string of the form: all | [Keyword NamedValue | Value[/N]]* where Keyword identifies the field of interest, Value is context dependent on the field, NamedValue is an alias for a Value. N indicates the number of most significant bits of Value to test. If omitted it defaults to the max allowed for the field. ")
packetRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 4), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: packetRuleRowStatus.setDescription('This object is used to create and remove rows in the table.')
packetRuleValue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue2.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue2.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
packetRuleValue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue3.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue3.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
packetRuleValue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 7), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue4.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue4.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
packetRuleValue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 8), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue5.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue5.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
packetRuleGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 9), PacketRuleGroupIndex().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: packetRuleGroupIndex.setStatus('current')
if mibBuilder.loadTexts: packetRuleGroupIndex.setDescription('A scalar representing the Group Index for a set of Packet Rule Table Entries.')
packetRuleValue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 10), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue6.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue6.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
packetRuleValue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 6, 3, 1, 11), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: packetRuleValue7.setStatus('current')
if mibBuilder.loadTexts: packetRuleValue7.setDescription('A variable-length field whose meaning depends on packetRuleType. ')
bridgePPPoETable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7), )
if mibBuilder.loadTexts: bridgePPPoETable.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoETable.setDescription('For PPPoA-to-PPPoE tables, provide a lookup by ifIndex into the PPPoE tables. If the session has not been created for this PPPoA ifIndex, then there will be no table data.')
bridgePPPoEEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgePPPoEEntry.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoEEntry.setDescription('Description.')
bridgePPPoEBrasMac = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoEBrasMac.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoEBrasMac.setDescription('Destination mac address.')
bridgePPPoELocalHostMac = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoELocalHostMac.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoELocalHostMac.setDescription('Source mac address.')
bridgePPPoEEIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoEEIfIndex.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoEEIfIndex.setDescription("PPPoE port's ifIndex.")
bridgePPPoESessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoESessionID.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoESessionID.setDescription('PPPoE session ID.')
bridgePPPoESlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoESlanId.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoESlanId.setDescription('SLan ID of BRAS.')
bridgePPPoEVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoEVlanId.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoEVlanId.setDescription('VLAN ID of BRAS.')
bridgePPPoEEncapLLC = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vcmux", 1), ("llc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePPPoEEncapLLC.setStatus('current')
if mibBuilder.loadTexts: bridgePPPoEEncapLLC.setDescription('PPPoA encapsulation')
stpParam = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8))
stpParamName = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 1), ZhoneAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamName.setStatus('current')
if mibBuilder.loadTexts: stpParamName.setDescription('set this field if you are using MSTP, use the name of the bridge as a key.')
stpParamRevision = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamRevision.setStatus('current')
if mibBuilder.loadTexts: stpParamRevision.setDescription("This parameter is used if you are running MSTP only. Currently we don't support any revisions to MSTP, so revision 0 is default.")
stpParamBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4096, 61440)).clone(36864)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamBridgePriority.setStatus('current')
if mibBuilder.loadTexts: stpParamBridgePriority.setDescription('The priority ID that will be advertised for this bridge.')
stpParamForceVersion = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamForceVersion.setStatus('current')
if mibBuilder.loadTexts: stpParamForceVersion.setDescription('The protocol to initiate with. 3- MSTP, 2- RSTP, 0- STP.')
stpParamFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 20)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamFwdDelay.setStatus('current')
if mibBuilder.loadTexts: stpParamFwdDelay.setDescription('The delay used by STP bridges to transition Root and Designated Ports to Forwarding.')
stpParamHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamHelloTime.setStatus('current')
if mibBuilder.loadTexts: stpParamHelloTime.setDescription('The interval between periodic transmissions of Configuration Messages by Designated Ports. We only support a hello time of 2 currently. ')
stpParamMigrateTime = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamMigrateTime.setStatus('current')
if mibBuilder.loadTexts: stpParamMigrateTime.setDescription('The initial value of the mdelayWhile and edgeDelayWhile timers. We currently only support a value of 3 for this timer.')
stpParamTxHoldCount = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamTxHoldCount.setStatus('current')
if mibBuilder.loadTexts: stpParamTxHoldCount.setDescription('The transmit hold count is used by the Port Transmit state machine to limit transmission rate.')
stpParamMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 8, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 20)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpParamMaxAge.setStatus('current')
if mibBuilder.loadTexts: stpParamMaxAge.setDescription('The maximum age of the information transmitted by the bridge when it is the Root Bridge.')
stpBindTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 9), )
if mibBuilder.loadTexts: stpBindTable.setStatus('current')
if mibBuilder.loadTexts: stpBindTable.setDescription('The stpBind table is used to store the entries of stpBind which hold the relationship between the ifIndex on which STP is to run on, and the MSTP instance if any.')
stpBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "stpBindInstanceID"))
if mibBuilder.loadTexts: stpBindEntry.setStatus('current')
if mibBuilder.loadTexts: stpBindEntry.setDescription('stpBindEntry is used to specify the type of STP that is to run on an ifIndex. An InstanceID of 0 specifies RSTP. An InstanceId > 0 indicates MSTP.')
stpBindInstanceID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 9, 1, 1), Unsigned32())
if mibBuilder.loadTexts: stpBindInstanceID.setStatus('current')
if mibBuilder.loadTexts: stpBindInstanceID.setDescription('This is a hidden storage of the InstanceId of an entry.')
stpBindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 9, 1, 2), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stpBindRowStatus.setStatus('current')
if mibBuilder.loadTexts: stpBindRowStatus.setDescription('Description.')
stpBindPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 9, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stpBindPortPriority.setStatus('current')
if mibBuilder.loadTexts: stpBindPortPriority.setDescription('PortPriority is used to specify the STP priority of this port.')
mstpInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 10), )
if mibBuilder.loadTexts: mstpInstanceTable.setStatus('current')
if mibBuilder.loadTexts: mstpInstanceTable.setDescription('Description.')
mstpInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 10, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "stpBindInstanceID"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"))
if mibBuilder.loadTexts: mstpInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: mstpInstanceEntry.setDescription('Description.')
mstpInstanceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 10, 1, 1), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mstpInstanceRowStatus.setStatus('current')
if mibBuilder.loadTexts: mstpInstanceRowStatus.setDescription('Description.')
mstpInstanceName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 10, 1, 2), ZhoneAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mstpInstanceName.setStatus('current')
if mibBuilder.loadTexts: mstpInstanceName.setDescription('A name for this mstp instance and vlanId.')
bridgeStatsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11), )
if mibBuilder.loadTexts: bridgeStatsTable.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsTable.setDescription('The bridgeStatsTable is used to access the statistics of the entries in the bridge table.')
bridgeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsEntry.setDescription('Displays the bridge statistics table entries.')
bridgeStatsUcastRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsUcastRcvd.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsUcastRcvd.setDescription('Unicast packets received.')
bridgeStatsMcastRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsMcastRcvd.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsMcastRcvd.setDescription('Multicast packets received.')
bridgeStatsBcastRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBcastRcvd.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBcastRcvd.setDescription('Broadcast packets received.')
bridgeStatsUcastSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsUcastSent.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsUcastSent.setDescription('Unicast packets sent.')
bridgeStatsMcastSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsMcastSent.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsMcastSent.setDescription('Multicast packets sent.')
bridgeStatsBcastSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBcastSent.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBcastSent.setDescription('Broadcast packets sent.')
bridgeStatsErrorSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsErrorSent.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsErrorSent.setDescription('Error packets sent.')
bridgeOnDemandStatsRulesSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeOnDemandStatsRulesSupported.setStatus('current')
if mibBuilder.loadTexts: bridgeOnDemandStatsRulesSupported.setDescription('Get the number of supported Ingress Stats available for a line card.')
bridgeOnDemandStatsRulesRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeOnDemandStatsRulesRemaining.setStatus('current')
if mibBuilder.loadTexts: bridgeOnDemandStatsRulesRemaining.setDescription('Get the number of remaining Ingress Stats available for a line card')
bridgeStatsBSDUcastBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBSDUcastBlocked.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBSDUcastBlocked.setDescription('Number of unicast packets dropped due to Bridge Packet Storm Detection threshold exceeded.')
bridgeStatsBSDMcastBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBSDMcastBlocked.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBSDMcastBlocked.setDescription('Number of multicast packets dropped due to Bridge Packet Storm Detection threshold exceeded.')
bridgeStatsBSDBcastBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBSDBcastBlocked.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBSDBcastBlocked.setDescription('Number of broadcast packets dropped due to Bridge Packet Storm Detection threshold exceeded.')
bridgeStatsBSDAlarmCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBSDAlarmCount.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBSDAlarmCount.setDescription('This counter reflects the number of times this interface has transitioned to the alarm state due to the Bridge Packet Storm Detection threshold being exceeded for a pre-defined number of seconds. ')
bridgeStatsBytesRcvdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBytesRcvdCount.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBytesRcvdCount.setDescription('This is a count of the number of bytes received. On-demand stats must be enabled for byte counters otherwise this counter is zero. ')
bridgeStatsBytesSentCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsBytesSentCount.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsBytesSentCount.setDescription('This is a count of the number of bytes transmitted. On-demand stats must be enabled for byte counters otherwise this counter is zero. ')
bridgeStatsTicksLastCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsTicksLastCleared.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsTicksLastCleared.setDescription('Linecard tick value when bridge was last cleared.')
bridgeStatsTicksNow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsTicksNow.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsTicksNow.setDescription('Linecard current tick value.')
bridgeStatsTicksPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 11, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsTicksPerSecond.setStatus('current')
if mibBuilder.loadTexts: bridgeStatsTicksPerSecond.setDescription('Linecard current tick value.')
bridgeCmd = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12))
bridgeCmdOperation = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clrStats", 1), ("clrIgmpStats", 2), ("unblock", 3), ("flush", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdOperation.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdOperation.setDescription('Bridge command ID value.')
bridgeCmdFilterMask = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 2), Bits().clone(namedValues=NamedValues(("filterIfIndex", 0), ("filterVlan", 1), ("filterSlan", 2), ("filterSlot", 3), ("filterPort", 4), ("filterIpAddress", 5), ("filterMacAddress", 6), ("filterSecure", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdFilterMask.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdFilterMask.setDescription('Bridge command filters bit mask. If a bridge filter is enabled then the associated bridge filter value must be included in the SNMP packet. If the bridge filter mask is all zeros then no filters will be applied and the bridge command will apply to all bridges in the system.')
bridgeCmdIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 3), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdIfIndex.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdIfIndex.setDescription("Bridge command 'ifIndex' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdVlanId = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdVlanId.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdVlanId.setDescription("Bridge command 'VLAN' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdSlanId = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdSlanId.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdSlanId.setDescription("Bridge command 'SLAN' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdSlot = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdSlot.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdSlot.setDescription("Bridge command 'SLOT' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdPort = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdPort.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdPort.setDescription("Bridge command 'PORT' filter value. This is the ifIndex of the linegroup on which the bridge is stacked If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdIpAddress.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdIpAddress.setDescription("Bridge command 'IP Address' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
bridgeCmdMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 12, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeCmdMacAddress.setStatus('current')
if mibBuilder.loadTexts: bridgeCmdMacAddress.setDescription("Bridge command 'MAC Address' filter value. If this object is included in the SNMP packet then the associated filter must be enabled in the bridge filter mask (bridgeCmdFilterMask).")
eapsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13))
eapsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1), )
if mibBuilder.loadTexts: eapsConfigTable.setStatus('current')
if mibBuilder.loadTexts: eapsConfigTable.setDescription('This table contains information required for the management of EAPS domains.')
eapsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"))
if mibBuilder.loadTexts: eapsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: eapsConfigEntry.setDescription('An entry exists for each EAPS domain in the system. ')
eapsConfigPrimaryPortLineGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 1), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eapsConfigPrimaryPortLineGroup.setStatus('current')
if mibBuilder.loadTexts: eapsConfigPrimaryPortLineGroup.setDescription('This object contains the line group IfIndex of the Primary EAPS Port.')
eapsConfigSecondaryPortLineGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 2), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eapsConfigSecondaryPortLineGroup.setStatus('current')
if mibBuilder.loadTexts: eapsConfigSecondaryPortLineGroup.setDescription('This object contains the line group IfIndex of the Secondary EAPS Port.')
eapsConfigControlVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4090))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eapsConfigControlVlan.setStatus('current')
if mibBuilder.loadTexts: eapsConfigControlVlan.setDescription('This object contains the VLAN ID of the control VLAN for this domain record. This is the VLAN ID used in EAPS control messages.')
eapsConfigIsMasterNode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigIsMasterNode.setStatus('current')
if mibBuilder.loadTexts: eapsConfigIsMasterNode.setDescription('If this value is True, then this record describes a Master Node. Otherwise, it describes a Transit Node.')
eapsConfigControlVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(6)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigControlVlanPriority.setStatus('current')
if mibBuilder.loadTexts: eapsConfigControlVlanPriority.setDescription('This object contains the Priority of the Control Vlan.')
eapsConfigDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 6), ZhoneAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigDomainName.setStatus('current')
if mibBuilder.loadTexts: eapsConfigDomainName.setDescription('This object contains the user assigned ASCII representation of the Domain Name for this record. This name must be unique device wide. ')
eapsConfigMsgTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 7), Integer32().clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigMsgTxInterval.setStatus('current')
if mibBuilder.loadTexts: eapsConfigMsgTxInterval.setDescription('This object contains the interval, in seconds, that a node sends Health Messages on the ring.')
eapsConfigTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 8), Integer32().clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigTimeout.setStatus('current')
if mibBuilder.loadTexts: eapsConfigTimeout.setDescription('On a Master Node, this object contains the timeout, in seconds, which the Master Node will report a Ring Fault if it does not receive a Health Message on the ring. On a Transit Node, this is the pre-forwarding delay timeout (also in seconds). ')
eapsConfigMaxDroppedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 9), Integer32().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigMaxDroppedMessages.setStatus('current')
if mibBuilder.loadTexts: eapsConfigMaxDroppedMessages.setDescription('On a Master Node, this object contains the number of contigious Health messages that may be dropped before the node declared a Ring Fault. This object is not used for a Transit node. ')
eapsConfigSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 10), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigSnmpTrap.setStatus('current')
if mibBuilder.loadTexts: eapsConfigSnmpTrap.setDescription('If this object is set to True, then this node will send SNMP Traps on Ring State transition. ')
eapsConfigDomainEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigDomainEnable.setStatus('current')
if mibBuilder.loadTexts: eapsConfigDomainEnable.setDescription('If this value is TRUE, the EAPS state machine will transition through the initialization process to the Health state. It will begin passing Control Messages and allow Protected VLAN data through the EAPS Domain. If this value is FALSE, the EAPS state machine will transition through the reset process to the Inactivate state. It will stop passing Control Messages and prohibit Protected VLAN data from being passed through the EAPS Domain.')
eapsConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 1, 1, 12), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: eapsConfigRowStatus.setDescription('This object is used to create and remove rows in the table. See eapsConfigEntry description for minimum requirements.')
eapsProtectedVlanTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2), )
if mibBuilder.loadTexts: eapsProtectedVlanTable.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanTable.setDescription("This table contains information required for the management of a list of protected VLAN's in an EAPS domains.")
eapsProtectedVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanEntryIndex"))
if mibBuilder.loadTexts: eapsProtectedVlanEntry.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanEntry.setDescription('An entry for each VLAN ranges that is to be protected in the EAPS domain. ')
eapsProtectedVlanEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eapsProtectedVlanEntryIndex.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanEntryIndex.setDescription("This object is an index which indicates which entry in the Protected Vlan Table is being addressed. For example, a value of 5 would indicate that the 5th entry (row) of this table is being addressed. This entry, along with eapsConfigPrimaryLineGroup, eapsConfigSecondaryLineGroup, and eapsConfigControlVlan indices select which Protected Vlan Table entry for a given eaps-domain-record profile. The first three indices select the profile, this last index selects the N'th entry in that profile ")
eapsProtectedVlanLowerRange = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsProtectedVlanLowerRange.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanLowerRange.setDescription('The eapsProtectedVlanLowerRange and eapsProtectedVlanUpperRange objects work in conjunction with one another to set the range of the protected vlans. If eapsProtectedVlanLowerRange is 0, then this indicates end of list. If eapsProtectedVlanLowerRange is not 0, but eapsProtectedVlanUpperRange is 0, then this would be have the same effect as both object having the same value and protect a single vlan ID. If they are both different and non-zero, then it specifies an inclusive range. Note that eapsProtectedVlanLowerRange must be numerically lower than eapsProtectedVlanUpperRange. ')
eapsProtectedVlanUpperRange = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsProtectedVlanUpperRange.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanUpperRange.setDescription('The eapsProtectedVlanLowerRange and eapsProtectedVlanUpperRange objects work in conjunction with one another to set the range of the protected vlans. If eapsProtectedVlanLowerRange is 0, then this indicates end of list. If eapsProtectedVlanLowerRange is not 0, but eapsProtectedVlanUpperRange is 0, then this would be have the same effect as both object having the same value and protect a single vlan ID. If they are both different and non-zero, then it specifies an inclusive range. Note that eapsProtectedVlanLowerRange must be numerically lower than eapsProtectedVlanUpperRange. ')
eapsProtectedVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1, 4), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eapsProtectedVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanRowStatus.setDescription('This object is used to create and remove rows in the table. See eapsProtectedVlanEntry description for minimum requirements.')
eapsProtectedVlanDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 2, 1, 5), ZhoneAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsProtectedVlanDomainName.setStatus('current')
if mibBuilder.loadTexts: eapsProtectedVlanDomainName.setDescription('The domain name for the EAPS protected vlan entry.')
eapsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 3), )
if mibBuilder.loadTexts: eapsStatusTable.setStatus('current')
if mibBuilder.loadTexts: eapsStatusTable.setDescription('This table contains status of each EAPS domain state machine.')
eapsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 3, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"))
if mibBuilder.loadTexts: eapsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: eapsStatusEntry.setDescription("The entry contains status of the domain's state machine.")
eapsPrevState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 3, 1, 1), EapsState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsPrevState.setStatus('current')
if mibBuilder.loadTexts: eapsPrevState.setDescription('Previous state for the domain.')
eapsState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 3, 1, 2), EapsState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsState.setStatus('current')
if mibBuilder.loadTexts: eapsState.setDescription('Current state for the domain.')
eapsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 4), )
if mibBuilder.loadTexts: eapsStatsTable.setStatus('current')
if mibBuilder.loadTexts: eapsStatsTable.setDescription('EAPS statistics table.')
eapsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 4, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"))
if mibBuilder.loadTexts: eapsStatsEntry.setStatus('current')
if mibBuilder.loadTexts: eapsStatsEntry.setDescription('Displays the EAPS statistic table entries.')
eapsStatsTotCtrlMsgSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eapsStatsTotCtrlMsgSent.setStatus('current')
if mibBuilder.loadTexts: eapsStatsTotCtrlMsgSent.setDescription('Total EAPS control messages sent.')
eapsStatsTotCtrlMsgRecvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eapsStatsTotCtrlMsgRecvd.setStatus('current')
if mibBuilder.loadTexts: eapsStatsTotCtrlMsgRecvd.setDescription('Total EAPS control messages received.')
eapsTrapPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5))
if mibBuilder.loadTexts: eapsTrapPrefix.setStatus('current')
if mibBuilder.loadTexts: eapsTrapPrefix.setDescription('Place-holder object for EAPS traps, which must have a final digit of 0 in OID.')
eapsTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5, 0))
if mibBuilder.loadTexts: eapsTraps.setStatus('current')
if mibBuilder.loadTexts: eapsTraps.setDescription('Traps raised by EAPS state machine.')
eapsStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5, 0, 1)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"))
if mibBuilder.loadTexts: eapsStateChange.setStatus('current')
if mibBuilder.loadTexts: eapsStateChange.setDescription('State changed in the node for the EAPS domain.')
eapsFailTimerExpFlagSet = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5, 0, 2)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"))
if mibBuilder.loadTexts: eapsFailTimerExpFlagSet.setStatus('current')
if mibBuilder.loadTexts: eapsFailTimerExpFlagSet.setDescription("The eapsFailTimerExpFlagSet notification is generated when the EAPS domain's fail timer expires for the first time, while its state is not in Fail state.")
eapsFailTimerExpFlagClear = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5, 0, 3)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"))
if mibBuilder.loadTexts: eapsFailTimerExpFlagClear.setStatus('current')
if mibBuilder.loadTexts: eapsFailTimerExpFlagClear.setDescription('Description.')
eapsLinkDownRingComplete = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 5, 0, 4)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"))
if mibBuilder.loadTexts: eapsLinkDownRingComplete.setStatus('current')
if mibBuilder.loadTexts: eapsLinkDownRingComplete.setDescription('If a transit is in Link-Down state, and it receives a Health-Check-Pdu from the Master indicating the ring is Complete, it means there is some problem with the Transit switch that has issued this trap message.')
eapsTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6), )
if mibBuilder.loadTexts: eapsTopologyTable.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyTable.setDescription('EAPS topology table.')
eapsTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyRing"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyRowNumber"))
if mibBuilder.loadTexts: eapsTopologyEntry.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyEntry.setDescription('Displays the EAPS topology table entries.')
eapsTopologyRing = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1))))
if mibBuilder.loadTexts: eapsTopologyRing.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyRing.setDescription('This represents the link as primary or secondary.')
eapsTopologyRowNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47)))
if mibBuilder.loadTexts: eapsTopologyRowNumber.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyRowNumber.setDescription('This represents the node number in the ring.')
eapsTopologyDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 3), ZhoneAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyDomainName.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyDomainName.setDescription('This represents the domain name for this record.')
eapsTopologyMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyMacAddr.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyMacAddr.setDescription('macAddress of the element in the ring.')
eapsTopologyIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyIpAddr.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyIpAddr.setDescription('Ip addressed of the element in the ring.')
eapsTopologyType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("transit", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyType.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyType.setDescription('This represents whether the node is master or transit.')
eapsTopologyPrimaryLinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 7), ZhoneAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyPrimaryLinkName.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyPrimaryLinkName.setDescription('This represents the primary link name.')
eapsTopologyPrimaryLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 8), EapsState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologyPrimaryLinkState.setStatus('current')
if mibBuilder.loadTexts: eapsTopologyPrimaryLinkState.setDescription('This represents the primary link state.')
eapsTopologySecondaryLinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 9), ZhoneAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologySecondaryLinkName.setStatus('current')
if mibBuilder.loadTexts: eapsTopologySecondaryLinkName.setDescription('This represents the secondary link name.')
eapsTopologySecondaryLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 13, 6, 1, 10), EapsState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eapsTopologySecondaryLinkState.setStatus('current')
if mibBuilder.loadTexts: eapsTopologySecondaryLinkState.setDescription('This represents the secondary link state.')
bridgeIgmpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14), )
if mibBuilder.loadTexts: bridgeIgmpStatsTable.setStatus('current')
if mibBuilder.loadTexts: bridgeIgmpStatsTable.setDescription('The bridgeIgmpStatsTable is used to access the IGMP statistics for bridges.')
bridgeIgmpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgeIgmpStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeIgmpStatsEntry.setDescription('The bridgeIgmpStatsEntry holds IGMP stats for a bridge interface.')
genQueryRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genQueryRx.setStatus('current')
if mibBuilder.loadTexts: genQueryRx.setDescription('general IGMP queries received.')
genQueryTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genQueryTx.setStatus('current')
if mibBuilder.loadTexts: genQueryTx.setDescription('general IGMP queries transmitted.')
specQueryRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specQueryRx.setStatus('current')
if mibBuilder.loadTexts: specQueryRx.setDescription('Specific IGMP queries received.')
specQueryTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specQueryTx.setStatus('current')
if mibBuilder.loadTexts: specQueryTx.setDescription('Specific IGMP queries transmitted.')
v2ReportsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v2ReportsRx.setStatus('current')
if mibBuilder.loadTexts: v2ReportsRx.setDescription('Version 2 reports received (JOINs).')
v2ReportsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v2ReportsTx.setStatus('current')
if mibBuilder.loadTexts: v2ReportsTx.setDescription('Version 2 reports sent.')
leavesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: leavesRx.setStatus('current')
if mibBuilder.loadTexts: leavesRx.setDescription('IGMP leaves received.')
leavesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: leavesTx.setStatus('current')
if mibBuilder.loadTexts: leavesTx.setDescription('IGMP leaves transmitted.')
unknownRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: unknownRx.setStatus('current')
if mibBuilder.loadTexts: unknownRx.setDescription('Unknown IGMP packets received.')
errorRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorRx.setStatus('current')
if mibBuilder.loadTexts: errorRx.setDescription('IGMP packet is bad received.')
actChans = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actChans.setStatus('current')
if mibBuilder.loadTexts: actChans.setDescription('Number of active muticast channels.')
actHosts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actHosts.setStatus('current')
if mibBuilder.loadTexts: actHosts.setDescription('Number of active multicast hosts.')
v3GenQueryRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3GenQueryRx.setStatus('current')
if mibBuilder.loadTexts: v3GenQueryRx.setDescription('Number of IGMP V3 Queries received.')
v3GenQueryTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3GenQueryTx.setStatus('current')
if mibBuilder.loadTexts: v3GenQueryTx.setDescription('Number of IGMP V3 queries sent.')
v3SpecQueryRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3SpecQueryRx.setStatus('current')
if mibBuilder.loadTexts: v3SpecQueryRx.setDescription('Number of IGMP V3 specific queries received.')
v3SpecQueryTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3SpecQueryTx.setStatus('current')
if mibBuilder.loadTexts: v3SpecQueryTx.setDescription('Number of IGMP V3 specific queries sent.')
v3ReportsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3ReportsRx.setStatus('current')
if mibBuilder.loadTexts: v3ReportsRx.setDescription('Number of IGMP V3 reports received.')
v3ReportsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 14, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v3ReportsTx.setStatus('current')
if mibBuilder.loadTexts: v3ReportsTx.setDescription('Number of IGMP V3 reports sent.')
bridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 15))
bridgeTrapPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 7, 15, 1))
if mibBuilder.loadTexts: bridgeTrapPrefix.setStatus('current')
if mibBuilder.loadTexts: bridgeTrapPrefix.setDescription('Traps raised for bridge conditions.')
bridgeTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 7, 15, 1, 0))
if mibBuilder.loadTexts: bridgeTraps.setStatus('current')
if mibBuilder.loadTexts: bridgeTraps.setDescription("Bridge traps go under here - extra layer needed to ensure '0' in OID.")
bridgeLoopDetection = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 15, 1, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAlias"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeMacAddrString"))
if mibBuilder.loadTexts: bridgeLoopDetection.setStatus('current')
if mibBuilder.loadTexts: bridgeLoopDetection.setDescription('Trap when bridge is looping on flap.')
bridgeStormDetection = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 7, 15, 1, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAlias"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeMacAddrString"))
if mibBuilder.loadTexts: bridgeStormDetection.setStatus('current')
if mibBuilder.loadTexts: bridgeStormDetection.setDescription('Trap sent when a bridge packet storm is detected.')
bridgeTrapObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 7, 16))
bridgeMacAddrString = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 7, 16, 1), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bridgeMacAddrString.setStatus('current')
if mibBuilder.loadTexts: bridgeMacAddrString.setDescription('vlan/slan/macAddress for bridge')
bridgeIgmpTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17), )
if mibBuilder.loadTexts: bridgeIgmpTable.setStatus('current')
if mibBuilder.loadTexts: bridgeIgmpTable.setDescription('The bridgeIgmpTable is used to access the IGMP data for bridges for when IGMP is in proxy mode and the IGMP status must be obtained from the linecard.')
bridgeIgmpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "hostMac"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "mcastMac"))
if mibBuilder.loadTexts: bridgeIgmpEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeIgmpEntry.setDescription('BridgeIgmpEntry contains the igmp multicast data information for a bridge, indexed by ifIndex, hostMac, and mcastMac.')
slanId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slanId.setStatus('current')
if mibBuilder.loadTexts: slanId.setDescription('IGMP slan identifier. Maximum value 4090 as defined by MAX_VLAN_NUM.')
vlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4090))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanId.setStatus('current')
if mibBuilder.loadTexts: vlanId.setDescription('IGMP vlan identifier. Maximum value 4090 as defined my MAX_VLAN_NUM')
mcastMac = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastMac.setStatus('current')
if mibBuilder.loadTexts: mcastMac.setDescription('IGMP Multicast MAC addressed to bridge port.')
mcastIP = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastIP.setStatus('current')
if mibBuilder.loadTexts: mcastIP.setDescription('IGMP Multicast IP addressed to bridge port.')
hostMac = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostMac.setStatus('current')
if mibBuilder.loadTexts: hostMac.setDescription('MAC address of end device receiving multicast packets.')
lastJoinTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastJoinTimer.setStatus('current')
if mibBuilder.loadTexts: lastJoinTimer.setDescription('Count down timer before IGMP entry ages out.')
staticBridgePathTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18), )
if mibBuilder.loadTexts: staticBridgePathTable.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathTable.setDescription('A collection of staticBridgePathEntries. The StaticBridgePath OID has the following format: OID psn MAC entries IPv4 entries IPv6 entries ---------- ------------- -------------- -------------- tlist[0] ifIndex ifIndex ifIndex tlist[1] address type address type address type tlist[2] vlan vlan vlan tlist[3] macAddr[0] IPv4[0] IPv6[0] tlist[4] macAddr[1] IPv4[1] IPv6[1] tlist[5] macAddr[2] IPv4[2] IPv6[2] tlist[6] macAddr[3] IPv4[3] IPv6[3] tlist[7] macAddr[4] zero IPv6[4] tlist[8] macAddr[5] zero IPv6[5] tlist[9] zero zero IPv6[6] tlist[10] zero zero IPv6[7] tlist[11] zero zero IPv6[8] tlist[12] zero zero IPv6[9] tlist[13] zero zero IPv6[10] tlist[14] zero zero IPv6[11] tlist[15] zero zero IPv6[12] tlist[16] zero zero IPv6[13] tlist[17] zero zero IPv6[14] tlist[18] zero zero IPv6[15] tlist[19] slan slan slan ')
staticBridgePathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathMacOrIpAddress"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: staticBridgePathEntry.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathEntry.setDescription('Static Path Bridge entries are created by the user in order to specify forwarding for a particular interface, vlanId, mac address or ip address, slanId (for QinQ). The INDEX value for staticBridgePathEntry consists of following 5 values: ifIndex staticBridgePathAddressType bridgeIfVlanId staticBridgePathMacOrIpAddress bridgeIfStagId If staticBridgeAddressType is set to macAddr(1), then staticBridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to ipAddr(2), then staticBridgeMacOrIpAddress represents an IP Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeAddressType is set to vlanIdAddr(3), then ifIndex and bridgeIfVlanId are used for the bridge path. If staticBridgeAddressType is set to globalAddr(4), then ifIndex is used for the bridge path.')
staticBridgePathMacOrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 1), IpAddress())
if mibBuilder.loadTexts: staticBridgePathMacOrIpAddress.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathMacOrIpAddress.setDescription('If the staticBridgeAddressType is set to macAddr(1), then this field represents a MAC address. If the staticBridgeAddressType is set to ipAddr(2), then this field represents an IP address. The IP address can be four octets ( for IPv4 ) or sixteen octets ( for IPv6 ).')
staticBridgePathAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 7, 8, 9, 10, 13, 14, 15, 16, 17, 720901))).clone(namedValues=NamedValues(("macAddr", 1), ("ipAddr", 2), ("vlanIdAddr", 3), ("globalAddr", 4), ("intralinkAddr", 7), ("globalIntralinkAddr", 8), ("dhcpIpAddr", 9), ("dhcpMacAddr", 10), ("mvrAddr", 13), ("vlanParms", 14), ("secMvrAddr", 15), ("ipAddrV6", 16), ("dhcpIpAddrV6", 17), ("dhcpAllowOui", 720901))))
if mibBuilder.loadTexts: staticBridgePathAddressType.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathAddressType.setDescription('If staticBridgeIPv6AddressType is set to macAddr(1), then staticBridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeIPv6AddressType is set to ipAddr(2), then staticBridgeMacOrIpAddress represents an IP Address, and ifIndex, bridgeIfVlanId and staticBridgeMacOrIpAddress are used for the bridge path. If staticBridgeIPv6AddressType is set to vlanIdAddr(3) or intralinkAddr(7), then ifIndex and bridgeIfVlanId are used for the bridge path. If staticBridgeIPv6AddressType is set to globalAddr(4), globalIntralinkAddr(8), or mvrAddr(13) then ifIndex is used for the bridge path. If staticBridgeIPv6AddressType is set to dhcpAllowOui( 720901) then the first 3 bytes of the MAC address contains the OUI that we will allow DHCP addresses to be granted to, global scope. If staticBridgeIPv6AddressType is set to dhcpIpAddr(9), or to dhcpMacAddr(10), then the other fields are populated as for address types ipAddr and macAddr respectively, with the difference that these are secure entries, learned by snooping DHCP. If staticBridgeIPv6AddressType is set to vlanParms(14), then the static bridge entry holds parameters for the given VLAN and SLAN ID (for example, flap mode, unicast aging period, etc) and is not associated with any specific bridge, but with all bridges with the same VLAN/SLAN ID. For this reason, the IfIndex of this entry must be zero. If staticBridgeIPv6AddressType is set to secMvrAddr(15), then the static bridge entry holds parameters for a Secondary MVR path. The VLAN ID of this entry is the Secondary VLAN ID. If staticBridgeIPv6AddressType is set to ipAddrV6(16), then staticBridgeMacOrIpAddress represents an IPv6 Address, and ifIndex, bridgeIfVlanId and staticBridgeIPv6MacOrIpAddress are used for the bridge path. If staticBridgeIPv6AddressType is set to dhcpIpAddrV6(17), or to dhcpMacAddr(10), then the other fields are populated as for address types ipAddr and macAddr respectively, with the difference that these are secure entries, learned by snooping DHCP.')
staticBridgePathMulticastAging = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathMulticastAging.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathMulticastAging.setDescription('Multicast Aging period in tenths of seconds for the specified VLAN. After the specified aging period is met, the VLAN address is deleted from the routing table. A value of 0 indicates that aging is turned off. Maximum value is 2147483647 tenths of seconds, which equates to approximately 2485.51 days.')
staticBridgePathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 4), ZhoneRowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathRowStatus.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathRowStatus.setDescription('Used to create, modify or delete an entry in this table.')
staticBridgePathFlapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("disable", 2), ("enable", 3), ("fast", 4))).clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathFlapControl.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathFlapControl.setDescription("This object enables or disable Flap Control in the Bridge Filter Table. The value 'disable(2)' turns Flap Control mode off. The values 'enable(3)' or 'fast(4) turn flap control mode on. 'Enable(3)' applies a hold time of 60 secs before allowing addr/IP to be moved to a new port, while 'fast(4)' applies a hold time of 0 secs. A value of 'default(1)' indicates 'Don't Care' and defaults to a disable or enable set by another entry. ")
staticBridgePathUnicastAging = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(120, 2147483647), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathUnicastAging.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathUnicastAging.setDescription('Multicast Aging period in tenths of seconds for the specified VLAN. After the specified aging period is met, the VLAN address is deleted from the routing table. A value of 0 indicates that aging is turned off. Maximum value is 2147483647 tenths of seconds, which equates to approximately 2485.51 days.')
staticBridgePathIgmpQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathIgmpQueryInterval.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathIgmpQueryInterval.setDescription('How often (in seconds) we as a bridge inject IGMP query values into the stream.')
staticBridgePathFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 8), Bits().clone(namedValues=NamedValues(("igmpProcessJoinAndLeave", 0), ("igmpRespondToQuery", 1), ("igmpUseBridgeIpAddress", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathFlags.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathFlags.setDescription('none : IGMP Snooping with Proxy reporting is disabled. BIT 0(igmpProcessJoinAndLeave) : igmpProcessJoinandLeave is enabled for IGMP packets. BIT 1(igmpRespondToQuery) : igmpRespondToQuery is enabled for IGMP packets. BIT 2(igmpUseBridgeIpAddress) : igmpUseBridgeIpAddress is enabled for IGMP packets. ')
staticBridgePathIgmpCustomIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 9), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathIgmpCustomIpAddress.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathIgmpCustomIpAddress.setDescription('Allow the configuration of the source IP address for packets that we originate upstream when doing IGMP Porxy on a bridge. ')
staticBridgePathLoopPrevention = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("blockAsym", 1), ("blockAll", 2), ("blockAsymAuto", 3), ("blockAllAuto", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticBridgePathLoopPrevention.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathLoopPrevention.setDescription("This field does the following options,'BlockAsym(1)' blocks a learning bridge if flap is detected between it and an uplink bridge. 'BlockAll(2)' incorporates 'blockAsym(1)' but it also blocks a learning bridge if it flaps against another learning bridge.")
staticBridgePathIgmpDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 18, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: staticBridgePathIgmpDscp.setStatus('current')
if mibBuilder.loadTexts: staticBridgePathIgmpDscp.setDescription('This parameter indicates DSCP value for igmp traffic. Valid code values: <0-63> Differentiated services codepoint value af11 Mark packets with AF11 dscp (001010) af12 Mark packets with AF12 dscp (001100) af13 Mark packets with AF13 dscp (001110) af21 Mark packets with AF21 dscp (010010) af22 Mark packets with AF22 dscp (010100) af23 Mark packets with AF23 dscp (010110) af31 Mark packets with AF31 dscp (011010) af32 Mark packets with AF32 dscp (011100) af33 Mark packets with AF33 dscp (011110) af41 Mark packets with AF41 dscp (100010) af42 Mark packets with AF42 dscp (100100) af43 Mark packets with AF43 dscp (100110) cs1 Mark packets with CS1(precedence 1) dscp (001000) cs2 Mark packets with CS2(precedence 2) dscp (010000) cs3 Mark packets with CS3(precedence 3) dscp (011000) cs4 Mark packets with CS4(precedence 4) dscp (100000) cs5 Mark packets with CS5(precedence 5) dscp (101000) cs6 Mark packets with CS6(precedence 6) dscp (110000) cs7 Mark packets with CS7(precedence 7) dscp (111000) default Mark packets with default dscp (000000) ef Mark packets with EF dscp (101110)')
bridgePathIfLookupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19), )
if mibBuilder.loadTexts: bridgePathIfLookupTable.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfLookupTable.setDescription('A collection of bridgePathIfLookupTable entries. The bridgePathIfLookup OID has the following format: OID psn MAC entries IPv4 entries IPv6 entries ---------- ------------- -------------- -------------- tlist[0] address type address type address type tlist[1] macAddr[0] IPv4[0] IPv6[0] tlist[2] macAddr[1] IPv4[1] IPv6[1] tlist[3] macAddr[2] IPv4[2] IPv6[2] tlist[4] macAddr[3] IPv4[3] IPv6[3] tlist[5] macAddr[4] zero IPv6[4] tlist[6] macAddr[5] zero IPv6[5] tlist[7] zero zero IPv6[6] tlist[8] zero zero IPv6[7] tlist[9] zero zero IPv6[8] tlist[10] zero zero IPv6[9] tlist[11] zero zero IPv6[10] tlist[12] zero zero IPv6[11] tlist[13] zero zero IPv6[12] tlist[14] zero zero IPv6[13] tlist[15] zero zero IPv6[14] tlist[16] zero zero IPv6[15] tlist[17] vlan vlan vlan tlist[18] ifIndex ifIndex ifIndex tlist[19] slan slan slan ')
bridgePathIfLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19, 1), ).setIndexNames((0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgePathIfAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgePathIfMacOrIpAddress"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: bridgePathIfLookupEntry.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfLookupEntry.setDescription('Bridge IfLookup entries are created by the user or learned by the software in order to specify forwarding for a particular interface, vlanId/slanId, mac address or ip address. The INDEX value for bridgeIfLookupEntry consists of following 5 values: bridgeIfAddressType bridgeIfMacOrIpAddress bridgeIfVlanId ifIndex bridgeIfStagId If bridgeIfAddressType is set to unicast_mac(1), then bridgeIfMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId/Slanid and bridgeIfMacOrIpAddress are use for the bridge path. If bridgeIfAddressType is set to multicast_mac(2), then bridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId/SlanId and bridgeIfMacOrIpAddress are used for bridge path. If bridgeIfAddressType is set to ip_address(3), then ifIndex and bridgeIfVlanId/SlanId are used for the bridge path.')
bridgePathIfAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unicastMac", 1), ("multicastMac", 2), ("ipAddress", 3), ("dhcpMac", 4), ("dhcpIp", 5))))
if mibBuilder.loadTexts: bridgePathIfAddressType.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfAddressType.setDescription('If bridgeIfAddressType is set to unicast_mac(1), then bridgeIfMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and bridgeIfMacOrIpAddress are used for the bridge path. If bridgeIfAddressType is set to multicast_mac(2), then bridgeMacOrIpAddress represents a MAC Address, and ifIndex, bridgeIfVlanId and bridgeIfMacOrIpAddress are used for the bridge path. If bridgeIfAddressType is set to ip_address(3), then ifIndex and bridgeIfVlanId are used for the bridge path. If bridgeIfAddressType is set to dhcp_mac(4), or dhcp_ip(5), then the address is as desribed for types 1 and 3, respectively, and the address was learned by snooping DHCP packets.')
bridgePathIfMacOrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19, 1, 2), IpAddress())
if mibBuilder.loadTexts: bridgePathIfMacOrIpAddress.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfMacOrIpAddress.setDescription('If bridgeIfAddressType is set to FILTER_ENTRY_UNICAST_MAC(1) or to FILTER_ENTRY_MULTICAST_MAC(2), or to FILTER_ENTRY_DHCP_MAC(4), then bridgeIfMacOrIpAddress represents a MAC Address. If bridgeIfAddressType is set to FILTER_ENTRY_IP_ADDRESS(3), or to FILTER_ENTRY_DHCP_IP(5), then bridgeIfMacOrIpAddress represents an IP Address.')
bridgePathIfLookupStaticOrDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("staticEntry", 1), ("dynamicEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePathIfLookupStaticOrDynamic.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfLookupStaticOrDynamic.setDescription('If bridgeIfLookupStaticOrDynamic is set to 1, then this table entry is static and persistent. If bridgeIfLookupStaticOrDynamic is set to 2, then this table entry is learned and is not persistent.')
bridgePathIfLookupFlush = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 19, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgePathIfLookupFlush.setStatus('current')
if mibBuilder.loadTexts: bridgePathIfLookupFlush.setDescription("The object 'bridgeIfLookupFlush' allows a user to flush learned entries in the bridgeFilterTable when the ifIndex of the entry is not known. A combination of address type, MAC or IP address and vlan ID is used to determine the ifIndex of the entry to be removed. Setting the object to 'true' causes the flush action to occur. After the flush action is taken, the value of bridgeIfLookupFlush is immediately set back to 'false'.")
bridgePathAddressLookupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 20), )
if mibBuilder.loadTexts: bridgePathAddressLookupTable.setStatus('current')
if mibBuilder.loadTexts: bridgePathAddressLookupTable.setDescription('A collection of bridgePathAddressLookupTable entries. The bridgePathAddressLookup OID has the following format: OID psn MAC entries IPv4 entries IPv6 entries ---------- ------------- -------------- -------------- tlist[0] ifIndex ifIndex ifIndex tlist[1] address type address type address type tlist[2] macAddr[0] IPv4[0] IPv6[0] tlist[3] macAddr[1] IPv4[1] IPv6[1] tlist[4] macAddr[2] IPv4[2] IPv6[2] tlist[5] macAddr[3] IPv4[3] IPv6[3] tlist[6] macAddr[4] zero IPv6[4] tlist[7] macAddr[5] zero IPv6[5] tlist[8] zero zero IPv6[6] tlist[9] zero zero IPv6[7] tlist[10] zero zero IPv6[8] tlist[11] zero zero IPv6[9] tlist[12] zero zero IPv6[10] tlist[13] zero zero IPv6[11] tlist[14] zero zero IPv6[12] tlist[15] zero zero IPv6[13] tlist[16] zero zero IPv6[14] tlist[17] zero zero IPv6[15] tlist[18] vlan vlan vlan tlist[19] slan slan slan')
bridgePathAddressLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfAddressType"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgePathIfLookupStaticOrDynamic"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanId"), (0, "ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagId"))
if mibBuilder.loadTexts: bridgePathAddressLookupEntry.setStatus('current')
if mibBuilder.loadTexts: bridgePathAddressLookupEntry.setDescription('BridgePathAddressLookup entries are created by the user or learned by the software in order to specify forwarding for a particular interface, vlanId/slanId, mac address or ip address. The INDEX value for bridgePathLookupEntry consists of following 5 values: ifIndex bridgeIfAddressType bridgeIfMacOrIpAddress bridgeIfVlanId bridgeIfStagId')
bridgePathAddressLookupStaticOrDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("staticEntry", 1), ("dynamicEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePathAddressLookupStaticOrDynamic.setStatus('current')
if mibBuilder.loadTexts: bridgePathAddressLookupStaticOrDynamic.setDescription('If bridgePathAddressLookupStaticOrDynamic is set to 1, then this table entry is static and persistent. If bridgePathAddressLookupStaticOrDynamic is set to 2, then this table entry is learned and is not persistent.')
bridgePathAddressLookupFlush = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 20, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgePathAddressLookupFlush.setStatus('current')
if mibBuilder.loadTexts: bridgePathAddressLookupFlush.setDescription("The object 'bridgePathAddressFlush' allows a user to flush learned entries in the bridgeFilterTable when the ifIndex of the entry is known. The ifIndex is used to determine which interface is to be removed. Setting the object to 'true' causes the flush action to occur. After the flush action is taken, the value of bridgePathLookupFlush is immediately set back to 'false'.")
bridgeStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 7, 21), )
if mibBuilder.loadTexts: bridgeStatusTable.setStatus('current')
if mibBuilder.loadTexts: bridgeStatusTable.setDescription('This table contains runtime status for each bridge interface.')
bridgeStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 7, 21, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgeStatusEntry.setStatus('current')
if mibBuilder.loadTexts: bridgeStatusEntry.setDescription('Runtime status data for a single bridge.')
bridgeStatusState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 7, 21, 1, 1), BridgeState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatusState.setStatus('current')
if mibBuilder.loadTexts: bridgeStatusState.setDescription('Values: up(1), UP down(2), DWN trouble(3), TRB notAvailable(4), NA initializing(5), INI adminDown(6), ADN adminStateTest(7), TST adminStateNone(8), N/S ready(9), RDY discovering(10), DSC unknown(11), ??? blocked(12), BLK pending(13), PND disabled(14), DIS learning(15), LRN forwarding(16), FWD blockedFlapping(17), BLF blockedPersistent(18), BLP blockedFlappingPersistenr(19), BFP ')
zhoneCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 9))
zhoneGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 9, 1))
zhoneBridgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 23)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMcastControlList"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMaxVideoStreams"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfIsPPPoA"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfFloodUnknown"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfFloodMulticast"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfTableBasedFilter"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfDhcpLearn"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeUnicastAging"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeIgmpQueryInterval"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoEBrasMac"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoELocalHostMac"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoEEIfIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoESessionID"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoESlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoEVlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePPPoEEncapLLC"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamName"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamRevision"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamBridgePriority"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamForceVersion"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamFwdDelay"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamHelloTime"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamMigrateTime"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamTxHoldCount"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpParamMaxAge"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpBindRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "stpBindPortPriority"), ("ZHONE-COM-BRIDGE-REC-MIB", "mstpInstanceRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdOperation"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdFilterMask"), ("ZHONE-COM-BRIDGE-REC-MIB", "mstpInstanceName"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeFlags"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeIgmpCustomIpAddress"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfMvrVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfVlanXlateFrom"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfSlanXlateFrom"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeMacAddrString"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfGponTrafficProfile"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfGponGemPortId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeType"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathMulticastAging"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathFlapControl"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathUnicastAging"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathIgmpQueryInterval"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathFlags"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathIgmpCustomIpAddress"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathLoopPrevention"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgePathIgmpDscp"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePathIfLookupStaticOrDynamic"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePathIfLookupFlush"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfStagIncomingCOSOption"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfIncomingCOSOption"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfUnblock"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfOnDemandStatsEnabled"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeIfBridgeState"), ("ZHONE-COM-BRIDGE-REC-MIB", "staticBridgeIgmpDscp"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue6"), ("ZHONE-COM-BRIDGE-REC-MIB", "packetRuleValue7"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePathAddressLookupFlush"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgePathAddressLookupStaticOrDynamic"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatusState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeGroup = zhoneBridgeGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeGroup.setDescription('The list of zhone bridge objects.')
zhoneBridgeCmdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 76)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdOperation"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdFilterMask"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdIfIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdVlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdSlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdSlot"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdPort"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdIpAddress"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeCmdMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeCmdGroup = zhoneBridgeCmdGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeCmdGroup.setDescription('Bridge CMD objects')
zhoneBridgeEapsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 77)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanEntryIndex"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanLowerRange"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanUpperRange"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanRowStatus"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsProtectedVlanDomainName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsPrevState"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsState"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsStatsTotCtrlMsgSent"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsStatsTotCtrlMsgRecvd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeEapsGroup = zhoneBridgeEapsGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeEapsGroup.setDescription('EAPS objects')
zhoneBridgeEapsConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 78)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigPrimaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSecondaryPortLineGroup"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlan"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigIsMasterNode"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigControlVlanPriority"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigMsgTxInterval"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigTimeout"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigMaxDroppedMessages"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigSnmpTrap"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigDomainEnable"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsConfigRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeEapsConfigGroup = zhoneBridgeEapsConfigGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeEapsConfigGroup.setDescription('EAPS config objects')
zhoneBridgeEapsTopologyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 79)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyDomainName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyMacAddr"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyIpAddr"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyType"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyPrimaryLinkName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologyPrimaryLinkState"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologySecondaryLinkName"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsTopologySecondaryLinkState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeEapsTopologyGroup = zhoneBridgeEapsTopologyGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeEapsTopologyGroup.setDescription('EAPS Topology objects')
zhoneBridgeNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 80)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "eapsStateChange"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsFailTimerExpFlagSet"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsFailTimerExpFlagClear"), ("ZHONE-COM-BRIDGE-REC-MIB", "eapsLinkDownRingComplete"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeLoopDetection"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStormDetection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeNotificationGroup = zhoneBridgeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeNotificationGroup.setDescription('BRIDGE Notifications')
zhoneBridgeIgmpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 81)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "slanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "vlanId"), ("ZHONE-COM-BRIDGE-REC-MIB", "mcastMac"), ("ZHONE-COM-BRIDGE-REC-MIB", "mcastIP"), ("ZHONE-COM-BRIDGE-REC-MIB", "hostMac"), ("ZHONE-COM-BRIDGE-REC-MIB", "lastJoinTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeIgmpGroup = zhoneBridgeIgmpGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeIgmpGroup.setDescription('IGMP objects')
zhoneBridgeStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 9, 1, 82)).setObjects(("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsUcastRcvd"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsMcastRcvd"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBcastRcvd"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsUcastSent"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsMcastSent"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBcastSent"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsErrorSent"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeOnDemandStatsRulesSupported"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeOnDemandStatsRulesRemaining"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBSDUcastBlocked"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBSDMcastBlocked"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBSDBcastBlocked"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBSDAlarmCount"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBytesRcvdCount"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsBytesSentCount"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsTicksLastCleared"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsTicksNow"), ("ZHONE-COM-BRIDGE-REC-MIB", "bridgeStatsTicksPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhoneBridgeStatsGroup = zhoneBridgeStatsGroup.setStatus('current')
if mibBuilder.loadTexts: zhoneBridgeStatsGroup.setDescription('Bridge STATS objects')
mibBuilder.exportSymbols("ZHONE-COM-BRIDGE-REC-MIB", genQueryRx=genQueryRx, bridgeStatusState=bridgeStatusState, eapsConfigSecondaryPortLineGroup=eapsConfigSecondaryPortLineGroup, packetRuleGroupNextIndexEntry=packetRuleGroupNextIndexEntry, bridgePPPoEBrasMac=bridgePPPoEBrasMac, packetRuleGroupNextIndexTable=packetRuleGroupNextIndexTable, bridgeIfForwardToMulticast=bridgeIfForwardToMulticast, eapsGroup=eapsGroup, eapsTopologyType=eapsTopologyType, bridgeIfUnblock=bridgeIfUnblock, packetRuleRowStatus=packetRuleRowStatus, mstpInstanceTable=mstpInstanceTable, bridgePPPoESlanId=bridgePPPoESlanId, bridgeStatsTable=bridgeStatsTable, bridgeIfLookupFlush=bridgeIfLookupFlush, eapsConfigMsgTxInterval=eapsConfigMsgTxInterval, stpBindEntry=stpBindEntry, bridgeCmdIfIndex=bridgeCmdIfIndex, bridgeIfGponTrafficProfile=bridgeIfGponTrafficProfile, bridgePPPoEEntry=bridgePPPoEEntry, bridgePPPoEEIfIndex=bridgePPPoEEIfIndex, stpBindPortPriority=stpBindPortPriority, bridgeCmdVlanId=bridgeCmdVlanId, bridgeStatusTable=bridgeStatusTable, bridgeIfSlanXlateFrom=bridgeIfSlanXlateFrom, stpParamTxHoldCount=stpParamTxHoldCount, bridgeStatsBSDMcastBlocked=bridgeStatsBSDMcastBlocked, bridgeAddressLookupEntry=bridgeAddressLookupEntry, bridgeStatsEntry=bridgeStatsEntry, bridgeStatsBcastSent=bridgeStatsBcastSent, bridgeCmdSlanId=bridgeCmdSlanId, staticBridgePathFlags=staticBridgePathFlags, v3GenQueryTx=v3GenQueryTx, PYSNMP_MODULE_ID=bridgeRecord, mstpInstanceRowStatus=mstpInstanceRowStatus, bridgeStatsMcastSent=bridgeStatsMcastSent, eapsConfigDomainEnable=eapsConfigDomainEnable, eapsProtectedVlanEntryIndex=eapsProtectedVlanEntryIndex, zhoneBridgeEapsConfigGroup=zhoneBridgeEapsConfigGroup, eapsProtectedVlanRowStatus=eapsProtectedVlanRowStatus, staticBridgeIgmpCustomIpAddress=staticBridgeIgmpCustomIpAddress, bridgeIfLearnIp=bridgeIfLearnIp, bridgeIfVlanIdCOS=bridgeIfVlanIdCOS, eapsLinkDownRingComplete=eapsLinkDownRingComplete, stpParamHelloTime=stpParamHelloTime, bridgePathIfAddressType=bridgePathIfAddressType, bridgeRecord=bridgeRecord, bridgePathIfLookupEntry=bridgePathIfLookupEntry, stpParamBridgePriority=stpParamBridgePriority, bridgeLowerIfIndex=bridgeLowerIfIndex, staticBridgeAddressType=staticBridgeAddressType, stpParamMaxAge=stpParamMaxAge, bridgeAddressLookupFlush=bridgeAddressLookupFlush, eapsTopologyPrimaryLinkState=eapsTopologyPrimaryLinkState, staticBridgePathUnicastAging=staticBridgePathUnicastAging, leavesRx=leavesRx, bridgeCmd=bridgeCmd, eapsTopologySecondaryLinkName=eapsTopologySecondaryLinkName, packetRuleValue7=packetRuleValue7, bridgeCmdOperation=bridgeCmdOperation, bridgePathAddressLookupTable=bridgePathAddressLookupTable, eapsConfigControlVlan=eapsConfigControlVlan, bridgeIfLearnUnicast=bridgeIfLearnUnicast, bridgeIfTableBasedFilter=bridgeIfTableBasedFilter, specQueryRx=specQueryRx, staticBridgeEntry=staticBridgeEntry, eapsTopologyPrimaryLinkName=eapsTopologyPrimaryLinkName, eapsProtectedVlanTable=eapsProtectedVlanTable, bridgeAddressLookupStaticOrDynamic=bridgeAddressLookupStaticOrDynamic, staticBridgePathTable=staticBridgePathTable, bridgeIfMaxVideoStreams=bridgeIfMaxVideoStreams, lastJoinTimer=lastJoinTimer, bridgeIfStagStripAndInsert=bridgeIfStagStripAndInsert, packetRuleValue4=packetRuleValue4, bridgeStatsBSDBcastBlocked=bridgeStatsBSDBcastBlocked, eapsConfigSnmpTrap=eapsConfigSnmpTrap, eapsTrapPrefix=eapsTrapPrefix, eapsConfigDomainName=eapsConfigDomainName, bridgeType=bridgeType, bridgeIgmpStatsEntry=bridgeIgmpStatsEntry, eapsConfigIsMasterNode=eapsConfigIsMasterNode, genQueryTx=genQueryTx, staticBridgePathIgmpQueryInterval=staticBridgePathIgmpQueryInterval, bridgeTrapObjects=bridgeTrapObjects, PacketRuleGroupIndex=PacketRuleGroupIndex, bridgeIfLookupTable=bridgeIfLookupTable, bridgeCmdFilterMask=bridgeCmdFilterMask, staticBridgeTable=staticBridgeTable, bridgeCmdSlot=bridgeCmdSlot, eapsStatusEntry=eapsStatusEntry, staticBridgeFlags=staticBridgeFlags, eapsConfigEntry=eapsConfigEntry, bridgeIfFloodUnknown=bridgeIfFloodUnknown, EapsState=EapsState, v2ReportsRx=v2ReportsRx, bridgeIfLearnMulticast=bridgeIfLearnMulticast, mstpInstanceName=mstpInstanceName, bridgeStatsTicksNow=bridgeStatsTicksNow, v3GenQueryRx=v3GenQueryRx, packetRuleGroupIndex=packetRuleGroupIndex, bridgeStatsUcastRcvd=bridgeStatsUcastRcvd, zhoneBridgeStatsGroup=zhoneBridgeStatsGroup, bridgeIfCustomARP=bridgeIfCustomARP, specQueryTx=specQueryTx, bridgeIfVlanId=bridgeIfVlanId, bridgeIfLookupEntry=bridgeIfLookupEntry, stpBindInstanceID=stpBindInstanceID, zhoneCompliances=zhoneCompliances, eapsProtectedVlanEntry=eapsProtectedVlanEntry, bridgeIfMcastControlList=bridgeIfMcastControlList, v3SpecQueryRx=v3SpecQueryRx, packetRuleTable=packetRuleTable, bridgeStatsBcastRcvd=bridgeStatsBcastRcvd, bridgeIfStagOutgoingCOSOption=bridgeIfStagOutgoingCOSOption, bridgeIfStagTPID=bridgeIfStagTPID, eapsTopologyMacAddr=eapsTopologyMacAddr, packetRuleGroupIndexNext=packetRuleGroupIndexNext, eapsConfigPrimaryPortLineGroup=eapsConfigPrimaryPortLineGroup, bridgeIfMaxUnicast=bridgeIfMaxUnicast, bridgePathAddressLookupFlush=bridgePathAddressLookupFlush, staticBridgeMacOrIpAddress=staticBridgeMacOrIpAddress, mstpInstanceEntry=mstpInstanceEntry, bridgeMacAddrString=bridgeMacAddrString, staticBridgeFlapControl=staticBridgeFlapControl, mcastIP=mcastIP, bridgeIfVci=bridgeIfVci, staticBridgeRowStatus=staticBridgeRowStatus, bridgeIfVpi=bridgeIfVpi, bridgeStormDetection=bridgeStormDetection, bridgePathIfLookupStaticOrDynamic=bridgePathIfLookupStaticOrDynamic, staticBridgeIgmpQueryInterval=staticBridgeIgmpQueryInterval, mcastMac=mcastMac, bridgeIfStagCOS=bridgeIfStagCOS, packetRuleValue3=packetRuleValue3, bridgeCmdPort=bridgeCmdPort, eapsStatsTotCtrlMsgSent=eapsStatsTotCtrlMsgSent, bridgePathAddressLookupStaticOrDynamic=bridgePathAddressLookupStaticOrDynamic, bridgeIfMvrVlan=bridgeIfMvrVlan, zhoneBridgeEapsGroup=zhoneBridgeEapsGroup, eapsConfigTable=eapsConfigTable, zhoneBridgeGroup=zhoneBridgeGroup, bridgeStatsMcastRcvd=bridgeStatsMcastRcvd, bridgeStatusEntry=bridgeStatusEntry, staticBridgeIgmpDscp=staticBridgeIgmpDscp, bridgeIfStagId=bridgeIfStagId, eapsTopologySecondaryLinkState=eapsTopologySecondaryLinkState, v2ReportsTx=v2ReportsTx, stpBindRowStatus=stpBindRowStatus, bridgeIgmpTable=bridgeIgmpTable, bridgePathIfLookupFlush=bridgePathIfLookupFlush, eapsFailTimerExpFlagSet=eapsFailTimerExpFlagSet, packetRuleValue2=packetRuleValue2, eapsConfigTimeout=eapsConfigTimeout, eapsTopologyTable=eapsTopologyTable, bridgeStatsBytesSentCount=bridgeStatsBytesSentCount, NetworkAddress=NetworkAddress, staticBridgeMulticastAging=staticBridgeMulticastAging, bridgeIfOutgoingCOSValue=bridgeIfOutgoingCOSValue, stpParamFwdDelay=stpParamFwdDelay, bridgeInterfaceTable=bridgeInterfaceTable, eapsStatusTable=eapsStatusTable, eapsTopologyDomainName=eapsTopologyDomainName, eapsProtectedVlanUpperRange=eapsProtectedVlanUpperRange, zhoneBridgeNotificationGroup=zhoneBridgeNotificationGroup, bridgeGroup=bridgeGroup, bridgeStatsBSDUcastBlocked=bridgeStatsBSDUcastBlocked, bridgeIfRowStatus=bridgeIfRowStatus, bridgePPPoETable=bridgePPPoETable, v3ReportsTx=v3ReportsTx, zhoneBridgeEapsTopologyGroup=zhoneBridgeEapsTopologyGroup, bridgeCmdMacAddress=bridgeCmdMacAddress, staticBridgePathIgmpCustomIpAddress=staticBridgePathIgmpCustomIpAddress, zhoneBridgeCmdGroup=zhoneBridgeCmdGroup, eapsConfigRowStatus=eapsConfigRowStatus, eapsStateChange=eapsStateChange, leavesTx=leavesTx, bridgePPPoEEncapLLC=bridgePPPoEEncapLLC, eapsState=eapsState, bridgeInterfaceGroup=bridgeInterfaceGroup, actChans=actChans, bridgePPPoEVlanId=bridgePPPoEVlanId, bridgeStatsErrorSent=bridgeStatsErrorSent, bridgeIgmpStatsTable=bridgeIgmpStatsTable, packetRuleValue6=packetRuleValue6, staticBridgePathAddressType=staticBridgePathAddressType, stpBindTable=stpBindTable, eapsTopologyIpAddr=eapsTopologyIpAddr, stpParamMigrateTime=stpParamMigrateTime, eapsStatsTable=eapsStatsTable, bridgePathIfMacOrIpAddress=bridgePathIfMacOrIpAddress, stpParamForceVersion=stpParamForceVersion, bridgeIfOnDemandStatsEnabled=bridgeIfOnDemandStatsEnabled, bridgeIfFilterBroadcast=bridgeIfFilterBroadcast, bridgeOnDemandStatsRulesRemaining=bridgeOnDemandStatsRulesRemaining, v3SpecQueryTx=v3SpecQueryTx, bridgeCmdIpAddress=bridgeCmdIpAddress, slanId=slanId, staticBridgeUnicastAging=staticBridgeUnicastAging, packetRuleValue5=packetRuleValue5, staticBridgePathFlapControl=staticBridgePathFlapControl, bridgeIfForwardToDefault=bridgeIfForwardToDefault, bridgeIfAddressType=bridgeIfAddressType, bridgeIfFloodMulticast=bridgeIfFloodMulticast, bridgeIfMacOrIpAddress=bridgeIfMacOrIpAddress, packetRuleEntry=packetRuleEntry, bridgeStatsBSDAlarmCount=bridgeStatsBSDAlarmCount, bridgeTraps=bridgeTraps, stpParam=stpParam, packetRuleGroup=packetRuleGroup, zhoneGroups=zhoneGroups, bridgeIfForwardToUnicast=bridgeIfForwardToUnicast, vlanId=vlanId, BridgeState=BridgeState, eapsStatsEntry=eapsStatsEntry, eapsProtectedVlanLowerRange=eapsProtectedVlanLowerRange, bridgeIfStagOutgoingCOSValue=bridgeIfStagOutgoingCOSValue, bridgeStatsBytesRcvdCount=bridgeStatsBytesRcvdCount, bridgeOnDemandStatsRulesSupported=bridgeOnDemandStatsRulesSupported, bridgeIfStagIncomingCOSOption=bridgeIfStagIncomingCOSOption, eapsStatsTotCtrlMsgRecvd=eapsStatsTotCtrlMsgRecvd, eapsTopologyRing=eapsTopologyRing, unknownRx=unknownRx, bridgeIgmpEntry=bridgeIgmpEntry, eapsProtectedVlanDomainName=eapsProtectedVlanDomainName, staticBridgePathMulticastAging=staticBridgePathMulticastAging, eapsTraps=eapsTraps, eapsConfigMaxDroppedMessages=eapsConfigMaxDroppedMessages, packetRuleType=packetRuleType, bridgePathIfLookupTable=bridgePathIfLookupTable, bridgeIfStripAndInsert=bridgeIfStripAndInsert, zhoneBridgeIgmpGroup=zhoneBridgeIgmpGroup, eapsPrevState=eapsPrevState, bridgeIfDhcpLearn=bridgeIfDhcpLearn, bridgeAddressLookupTable=bridgeAddressLookupTable, stpParamName=stpParamName, stpParamRevision=stpParamRevision, bridgeStatsTicksLastCleared=bridgeStatsTicksLastCleared, eapsConfigControlVlanPriority=eapsConfigControlVlanPriority, staticBridgePathIgmpDscp=staticBridgePathIgmpDscp, bridgeIfOutgoingCOSOption=bridgeIfOutgoingCOSOption, staticBridgeLoopPrevention=staticBridgeLoopPrevention, packetRuleGroupMemberIndex=packetRuleGroupMemberIndex, actHosts=actHosts, bridgeIfLookupStaticOrDynamic=bridgeIfLookupStaticOrDynamic, packetRuleGroupMemberNextIndex=packetRuleGroupMemberNextIndex, bridgeIfIsPPPoA=bridgeIfIsPPPoA, bridgeIfCustomDHCP=bridgeIfCustomDHCP, bridgeInterfaceEntry=bridgeInterfaceEntry, errorRx=errorRx, bridgeLoopDetection=bridgeLoopDetection, bridgeIfIngressPacketRuleGroupIndex=bridgeIfIngressPacketRuleGroupIndex, bridgePPPoELocalHostMac=bridgePPPoELocalHostMac, bridgePathAddressLookupEntry=bridgePathAddressLookupEntry, bridgeTrapPrefix=bridgeTrapPrefix)
mibBuilder.exportSymbols("ZHONE-COM-BRIDGE-REC-MIB", bridgeIfBridgeState=bridgeIfBridgeState, bridgePPPoESessionID=bridgePPPoESessionID, bridgeStatsTicksPerSecond=bridgeStatsTicksPerSecond, staticBridgePathRowStatus=staticBridgePathRowStatus, bridgeIfEgressPacketRuleGroupIndex=bridgeIfEgressPacketRuleGroupIndex, staticBridgePathEntry=staticBridgePathEntry, staticBridgePathMacOrIpAddress=staticBridgePathMacOrIpAddress, packetRuleValue=packetRuleValue, eapsTopologyRowNumber=eapsTopologyRowNumber, hostMac=hostMac, v3ReportsRx=v3ReportsRx, bridgeStatsUcastSent=bridgeStatsUcastSent, bridgeIfIncomingCOSOption=bridgeIfIncomingCOSOption, bridgeIfVlanXlateFrom=bridgeIfVlanXlateFrom, staticBridgePathLoopPrevention=staticBridgePathLoopPrevention, bridgeIfGponGemPortId=bridgeIfGponGemPortId, eapsTopologyEntry=eapsTopologyEntry, eapsFailTimerExpFlagClear=eapsFailTimerExpFlagClear)

#
# PySNMP MIB module LINKSWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LINKSWITCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:07:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
a3Com, = mibBuilder.importSymbols("A3Com-products-MIB", "a3Com")
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Counter32, Counter64, ModuleIdentity, ObjectIdentity, Integer32, Unsigned32, Gauge32, iso, IpAddress, Bits, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Counter32", "Counter64", "ModuleIdentity", "ObjectIdentity", "Integer32", "Unsigned32", "Gauge32", "iso", "IpAddress", "Bits", "TimeTicks")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
linkSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 17))
lsSRFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsSRFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsSRFilterEnable.setDescription('When false, the Address Filter forwards Source Routed frames, that is, frames with a 1 in the MSB of the Source Address. When true, the Address Filter does not forward Source Routed frames. Default value is false. DURABLE.')
lsSegmentFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsSegmentFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsSegmentFilterEnable.setDescription('Controls action taken with Eth frames with source and destination stations on the same segment (i.e. port). When true, the Address Filter will not forward intra-segment frames. When false, all frames received are forwarded. Default is true. DURABLE.')
lsMcastFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsMcastFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsMcastFilterEnable.setDescription('When false, all frames with a Multicast Destination Address that does not match any Address Filter entry are forwarded to all ports. Those with a match are forwarded to port. When true, only frames with a Multicast Destination Address with a match in the Address Filter are forwarded to port. Default is false. DURABLE.')
lsLoopDetectAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("shutport", 1), ("shuteths", 2), ("shutunit", 3), ("no-action", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsLoopDetectAction.setStatus('mandatory')
if mibBuilder.loadTexts: lsLoopDetectAction.setDescription('If a station appears to be on two ports, Address Filter thrashing will occur. Detection of this situation is possible, and this object controls the action to be taken when the situation is detected. Default is shutport. no-action means that no action will be taken, but this means Ethernet and FDDI networks will be flooded. NOTE: control of traps indicating the condition is not affected. DURABLE.')
lsAddressAgingTimer = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 5), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsAddressAgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: lsAddressAgingTimer.setDescription("A count of the seconds that will elapse before the Address Filter contents are 'aged' to remove entries which are not active. Default is 1800, or 30 minutes. Write 0 to stop aging process from occuring. DURABLE.")
lsIPEchoAgingHelp = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsIPEchoAgingHelp.setStatus('mandatory')
if mibBuilder.loadTexts: lsIPEchoAgingHelp.setDescription('If true, an IP echo frame will be broadcast on the subnet, which will cause otherwise quiecient stations to become active. The rate is half of lsAddressAgingTimer. DURABLE.')
lsProdVerSW = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsProdVerSW.setStatus('mandatory')
if mibBuilder.loadTexts: lsProdVerSW.setDescription('This describes the version of the software currently running. Returns a string in the form X.YZ, where X represents the major version, Y represents the minor version or revision, and Z represents the development level of the revision.')
lsProdVerHW = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsProdVerHW.setStatus('mandatory')
if mibBuilder.loadTexts: lsProdVerHW.setDescription('This describes the version of the hardware currently running. Returns a string in the form X.YZ, where X represents the major version, Y represents the minor version or revision, and Z represents the development level of the revision.')
lsLEDstate = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(80, 80)).setFixedLength(80)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLEDstate.setStatus('mandatory')
if mibBuilder.loadTexts: lsLEDstate.setDescription('A binary structure which describes the current state of all of the LEDs of an LinkSwitch. Actual layout available on request.')
lsTestResult = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: lsTestResult.setDescription('When a test is initiated via lsAction, the result of the test is stored in this variable when the test has completed or failed. The value varies by test, is set to one (other) at the start of the test.')
lsAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("age-addr-table", 2), ("clear-addr-table", 3), ("disconnect-FDDI", 4), ("connect-FDDI", 5), ("disconnect-Eth", 6), ("connect-Eth", 7), ("test-fddipath", 8), ("test-ethports", 9), ("test-lsfunc", 10), ("test-addr-filter", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsAction.setStatus('mandatory')
if mibBuilder.loadTexts: lsAction.setDescription('Value when read will be other. Writing a value to this object will result in the associated action taking place. Note that it is possible to disconnect the management station from the LinkSwitch by issuing the disconnect-FDDI or disconnect-Eth actions, depending of course where the management station is connected to the LinkSwitch. For those actions which are tests, the result is in lsTestResult. If the action is disconnect-FDDI, the FDDI ring will function internally for inter-segment frames.')
lsEportNumber = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportNumber.setDescription('A count of the Ethernet Ports supported by this system.')
lsEportTable = MibTable((1, 3, 6, 1, 4, 1, 43, 17, 13), )
if mibBuilder.loadTexts: lsEportTable.setStatus('mandatory')
lsEportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 17, 13, 1), ).setIndexNames((0, "LINKSWITCH-MIB", "lsEportIndex"))
if mibBuilder.loadTexts: lsEportEntry.setStatus('mandatory')
lsEportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportIndex.setDescription('The index of this table entry.')
lsEportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportEnable.setDescription('When false, port is in reset state, so no port (Ethernet) traffic will go through. When enabled, functionality is further controlled by lsEportActivate and ifOperStatus. Default is true. DURABLE.')
lsEportActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportActivate.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportActivate.setDescription('When true, port is shutdown but not reset, so counters will maintain values at time of deactivation. Further functionality controlled by ifOperStatus. Default is true.')
lsEportLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("inactive", 3), ("ready", 4), ("active", 5), ("shutdown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportLinkState.setDescription('Reports status of Link, as affected by lsEportEnable, lsEportActive, lsEportForwarding, and ifOperStatus.')
lsEportName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportName.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportName.setDescription('Abstract name for port. DURABLE.')
lsEportSQETestEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportSQETestEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportSQETestEnable.setDescription('When true, SQE test (heartbeat) will occur after each frame transmitted by Ethernet MAC. Need not be disabled for those ports which are connected to a repeater because Eth ports have a MAC. Default is true. DURABLE.')
lsEportLongPktsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportLongPktsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportLongPktsEnable.setDescription('When true, frames with lengths longer than Ethernet maximum will be allowed to go from FDDI to Ethernet and Ethernet to FDDI. Default is false. DURABLE.')
lsEportMCastFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportMCastFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportMCastFilterEnable.setDescription('When true, filtering will occur based on the values of lsEportMCastRate and lsEportMCastBurstLimit. If false, there is no port-level filtering performed on multicasts. Default is false. DURABLE.')
lsEportMCastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportMCastRate.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportMCastRate.setDescription('The rate in frames/second that multicasts will not be allowed to exceed, when lsEportBcastFilterEnable is true. Must also set lsEportMCastBurstLimit to non-zero value. DURABLE.')
lsEportMCastBurstLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportMCastBurstLimit.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportMCastBurstLimit.setDescription("This specifies the maximum number of multicasts that can be forwarded from FDDI to Ethernet port in a 'burst' before the lsEportBCastRate limit causes frames to be discarded Must also set lsEportMCastBurstLimit to non-zero value. If this to zero, all multicasts are discarded. DURABLE.")
lsEportStationsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportStationsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportStationsNumber.setDescription('A count of stations whose Physical Address has been detected in the Source Address field of a frame which was transmitted by a station connected to this port.')
lsEportSecsSinceLastClear = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportSecsSinceLastClear.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportSecsSinceLastClear.setDescription('A count of seconds since last cleared counters for this port. Use lsEportAction to clear the counters.')
lsEportTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportTestResult.setDescription('When a test is initiated via lsEportAction, the result of the test is stored in this variable when the test has completed or failed. The value varies by test, is set to one (other) at the start of the test.')
lsEportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("test-loopback", 2), ("test-addrfilter", 3), ("zero-counters", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsEportAction.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportAction.setDescription('Value when read will be other. Writing a value to this object will result in the associated action taking place. For those actions which are tests, the result is in lsEportTestResult.')
lsEportFtoEByteCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportFtoEByteCts.setReference('ieee8023IfTable.ieee8023OctetsTxOk')
if mibBuilder.loadTexts: lsEportFtoEByteCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportFtoEByteCts.setDescription("A count of bytes that were forwarded from the FDDI MAC to the Ethernet through the Address Filter. The count per frame includes the packet's bytes as received by the FDDI MAC (FCS removed), plus a number of overhead bytes used internally.")
lsEportEtoFByteCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportEtoFByteCts.setReference('ieee8023IfTable.ieee8023OctetsRxOk')
if mibBuilder.loadTexts: lsEportEtoFByteCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportEtoFByteCts.setDescription('A count of bytes that were forwarded from the Ethernet MAC to the Address Filter. The count per packet includes the byte count indicated by the Ethernet MAC (without FCS), plus a number of overhead bytes used internally.')
lsEportFtoEPacketCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportFtoEPacketCts.setReference('ieee8023IfTable.ieee8023FrmsTxOk')
if mibBuilder.loadTexts: lsEportFtoEPacketCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportFtoEPacketCts.setDescription('A count of frames that were forwarded from the FDDI MAC to the Ethernet MAC through the Address Filter. The count is the number of frames that the Ethernet MAC was able to transmit.')
lsEportEtoFPacketCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportEtoFPacketCts.setReference('ieee8023IfTable.ieee8023FrmsRxOk')
if mibBuilder.loadTexts: lsEportEtoFPacketCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportEtoFPacketCts.setDescription('A count of frames that were forwarded trom the Ethernet MAC to the Address Filter. The count is the number of frames received without error by the Ethernet MAC. Packets may be not-forwarded by the Address Filter and some may encounter error conditions, so it is necessary to subtract the value of lslEportEtoFDropPktCts for the true number of frames.')
lsEportFtoEDropPktCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportFtoEDropPktCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportFtoEDropPktCts.setDescription('A count of frames that were dropped as they went from the FDDI to the Ethernet through the Address Filter. Frames may be dropped due to resource constraints.')
lsEportEtoFDropPktCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportEtoFDropPktCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportEtoFDropPktCts.setDescription('A count of frames that were dropped before reaching the FDDI MAC. Include in this value are frames encountering resource constraints, as well as frames which did not need to be forwarded onto the FDDI (i.e., local intra-segment traffic).')
lsEportFtoEBusErrorCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportFtoEBusErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportFtoEBusErrorCts.setDescription('A count of frames that encountered a Parity or FIFO Error as they went from FDDI to the Ethernet.')
lsEportEtoFBusErrorCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportEtoFBusErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportEtoFBusErrorCts.setDescription('A count of frames that encountered a Parity or FIFO Error as they went from Ethernet to the FDDI.')
lsEportXMCastCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXMCastCts.setReference('ieee8023IfTable.ieee8023McastFrmsTxOk')
if mibBuilder.loadTexts: lsEportXMCastCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXMCastCts.setDescription('A count of frames transmitted to a multicast address. Does not include frames sent to the broadcast address.')
lsEportXBCastCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXBCastCts.setReference('ieee8023IfTable.ieee8023McastFrmsTxOk')
if mibBuilder.loadTexts: lsEportXBCastCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXBCastCts.setDescription('A count of frames transmitted to a broadcast address. Does not include frames sent to the multicast address.')
lsEportXDirectedCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXDirectedCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXDirectedCts.setDescription('A count of frames transmitted that were not addressed to either the multicast or the broadcast address.')
lsEportXDeferredCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXDeferredCts.setReference('ieee8023IfTable.ieee8023DefTx')
if mibBuilder.loadTexts: lsEportXDeferredCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXDeferredCts.setDescription('A count of frames for which the first transmission attempt is delayed because the medium is busy. The count does not include frames involved in collisions.')
lsEportXLateCollCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXLateCollCts.setReference('ieee8023IfTable.ieee8023LateColls')
if mibBuilder.loadTexts: lsEportXLateCollCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXLateCollCts.setDescription('A count of times that a collision is detected later 512 bit-times into the transmission of a packet. A late collision is also considered as a generic collision for purposes of other collision-related counters.')
lsEportXCollAbortCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXCollAbortCts.setReference('ieee8023IfTable.ieee8023ExcessColls')
if mibBuilder.loadTexts: lsEportXCollAbortCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXCollAbortCts.setDescription('A count of frames for which transmission fails due to excessive collisions.')
lsEportXCSErrCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXCSErrCts.setReference('ieee8023IfTable.ieee8023CsErrors')
if mibBuilder.loadTexts: lsEportXCSErrCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXCSErrCts.setDescription('A count of times that the carrier sense condition was lost or never asserted when attempting to transmit a frame.')
lsEportXExcessDeferCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXExcessDeferCts.setReference('ieee8023IfTable.ieee8023ExcessDef')
if mibBuilder.loadTexts: lsEportXExcessDeferCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXExcessDeferCts.setDescription('A count of times that the deferral time was excessive.')
lsEportXUnderrunCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXUnderrunCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXUnderrunCts.setDescription('A count of times that an underrun occured.')
lsEportXSQETestFailCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportXSQETestFailCts.setReference('ieee8023IfTable.ieee8023SqeTestErrors')
if mibBuilder.loadTexts: lsEportXSQETestFailCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportXSQETestFailCts.setDescription('A count of times that the SQE TEST ERROR message is generated by the PLS sublayer for a particular interface. The SQE TEST ERROR message is defined in section 7.2.2.2.4 of ANSI/IEEE 802.3-1985 and its generation is described in section 7.2.4.6 of the same document.')
lsEportRMCastCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRMCastCts.setReference('ieee8023IfTable.ieee8023McastFrmsRxOk')
if mibBuilder.loadTexts: lsEportRMCastCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRMCastCts.setDescription('A count of frames received with a multicast address. Does not include frames received with a broadcast address.')
lsEportRBCastCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRBCastCts.setReference('ieee8023IfTable.ieee8023McastFrmsRxOk')
if mibBuilder.loadTexts: lsEportRBCastCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRBCastCts.setDescription('A count of frames received with a broadcast address. Does not include frames received with a multicast address.')
lsEportRDirectedCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRDirectedCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRDirectedCts.setDescription('A count of frames received that were not addressed to either the multicast or the broadcast address.')
lsEportRAlignmentCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRAlignmentCts.setReference('ieee8023IfTable.ieee8023AlignErrors')
if mibBuilder.loadTexts: lsEportRAlignmentCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRAlignmentCts.setDescription("A count of frames received on a particular interface that are not an integral number of octets in length and do not pass the FCS check. The count represented by an instance of this object is incremented when the 'alignment error' status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions obtain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC.")
lsEportRTooLongCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRTooLongCts.setReference('ieee8023IfTable.ieee8023OorLengthFields')
if mibBuilder.loadTexts: lsEportRTooLongCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRTooLongCts.setDescription('A count of frames which were received and also exceeded the maximum frame size.')
lsEportRFCSErrorCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportRFCSErrorCts.setReference('ieee8023IfTable.ieee8023FcsErrors')
if mibBuilder.loadTexts: lsEportRFCSErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportRFCSErrorCts.setDescription('A count of frames received on a particular interface that are an integral number of octets in length but do not pass the FCS check. The count represented by an instance of this object is incremented when the frameCheckError status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions obtain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC.')
lsEportROverrunCts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 13, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEportROverrunCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsEportROverrunCts.setDescription('The number of frames which could not be stored by the Ethernet MAC due to internal resource constraints.')
lsStationsNumber = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsStationsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsStationsNumber.setDescription('A count of stations whose Physical Address has been detected in the Source Address field of a frame which was transmitted by a station connected to an Ethernet port. Equals the total of all of the per-port stations counts.')
lsStationsTable = MibTable((1, 3, 6, 1, 4, 1, 43, 17, 15), )
if mibBuilder.loadTexts: lsStationsTable.setStatus('mandatory')
lsStationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 17, 15, 1), ).setIndexNames((0, "LINKSWITCH-MIB", "lsStationsPortIndex"), (0, "LINKSWITCH-MIB", "lsStationsAddrIndex"))
if mibBuilder.loadTexts: lsStationsEntry.setStatus('mandatory')
lsStationsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsStationsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsStationsPortIndex.setDescription('The lsEportIndex of the port to which the addresses apply.')
lsStationsAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsStationsAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsStationsAddrIndex.setDescription('The index of this address within a row of the table lsStationsTable, where the row is selected by the value of lsStationsPortIndex.')
lsStationsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 17, 15, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsStationsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lsStationsAddress.setDescription('A Physical Address which has been seen as a Source Address on this port since the last time the Address Filter was aged.')
lsBusCts = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(192, 192)).setFixedLength(192)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusCts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusCts.setDescription('A binary structure which contains the FtoE and EtoF counters for all ls ports. Actual layout available on request.')
lsPortAMediaPresent = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("notpresent", 2), ("fiberpresent", 3), ("fiberscpresent", 4), ("utppresent", 5), ("stppresent", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortAMediaPresent.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortAMediaPresent.setDescription('Reports presence and type of FDDI Port A Media. For FMS LinkSwitch, only Fiber and UTP are supported.')
lsPortBMediaPresent = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("notpresent", 2), ("fiberpresent", 3), ("fiberscpresent", 4), ("utppresent", 5), ("stppresent", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortBMediaPresent.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortBMediaPresent.setDescription('Reports presence and type of FDDI Port B Media. For FMS LinkSwitch, only Fiber and UTP are supported.')
lsFMSBackupPSSense = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notpresent", 2), ("goodstatus", 3), ("badstatus", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsFMSBackupPSSense.setStatus('mandatory')
if mibBuilder.loadTexts: lsFMSBackupPSSense.setDescription('Reports the presence and status of the backup power supply on FMS LinkSwitch Only.')
lsfddiPATHRingLatency = MibScalar((1, 3, 6, 1, 4, 1, 43, 17, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsfddiPATHRingLatency.setStatus('mandatory')
if mibBuilder.loadTexts: lsfddiPATHRingLatency.setDescription('Reports the measurement (in 80 nanosecond ticks) of total accumulated latency of the ring associated with the current path.')
mibBuilder.exportSymbols("LINKSWITCH-MIB", linkSwitch=linkSwitch, lsEportRDirectedCts=lsEportRDirectedCts, lsEportMCastRate=lsEportMCastRate, lsEportSecsSinceLastClear=lsEportSecsSinceLastClear, lsStationsPortIndex=lsStationsPortIndex, lsEportEntry=lsEportEntry, lsBusCts=lsBusCts, lsPortBMediaPresent=lsPortBMediaPresent, lsEportXLateCollCts=lsEportXLateCollCts, lsEportRBCastCts=lsEportRBCastCts, lsEportEtoFPacketCts=lsEportEtoFPacketCts, lsStationsEntry=lsStationsEntry, lsStationsNumber=lsStationsNumber, lsEportStationsNumber=lsEportStationsNumber, lsEportRTooLongCts=lsEportRTooLongCts, lsEportXExcessDeferCts=lsEportXExcessDeferCts, lsfddiPATHRingLatency=lsfddiPATHRingLatency, lsEportFtoEBusErrorCts=lsEportFtoEBusErrorCts, lsEportROverrunCts=lsEportROverrunCts, lsEportName=lsEportName, lsProdVerHW=lsProdVerHW, lsEportEtoFByteCts=lsEportEtoFByteCts, lsPortAMediaPresent=lsPortAMediaPresent, lsEportAction=lsEportAction, lsAddressAgingTimer=lsAddressAgingTimer, lsEportEtoFBusErrorCts=lsEportEtoFBusErrorCts, lsEportEtoFDropPktCts=lsEportEtoFDropPktCts, lsIPEchoAgingHelp=lsIPEchoAgingHelp, lsEportXDirectedCts=lsEportXDirectedCts, lsEportXCSErrCts=lsEportXCSErrCts, lsEportActivate=lsEportActivate, lsEportXUnderrunCts=lsEportXUnderrunCts, lsEportEnable=lsEportEnable, lsLEDstate=lsLEDstate, lsEportRFCSErrorCts=lsEportRFCSErrorCts, lsEportXMCastCts=lsEportXMCastCts, lsEportXCollAbortCts=lsEportXCollAbortCts, lsEportFtoEPacketCts=lsEportFtoEPacketCts, lsAction=lsAction, lsEportIndex=lsEportIndex, lsStationsAddrIndex=lsStationsAddrIndex, lsSegmentFilterEnable=lsSegmentFilterEnable, lsEportMCastBurstLimit=lsEportMCastBurstLimit, lsEportRAlignmentCts=lsEportRAlignmentCts, lsEportXDeferredCts=lsEportXDeferredCts, lsTestResult=lsTestResult, lsEportRMCastCts=lsEportRMCastCts, lsEportMCastFilterEnable=lsEportMCastFilterEnable, lsSRFilterEnable=lsSRFilterEnable, lsMcastFilterEnable=lsMcastFilterEnable, lsEportFtoEDropPktCts=lsEportFtoEDropPktCts, lsStationsTable=lsStationsTable, lsEportTestResult=lsEportTestResult, lsProdVerSW=lsProdVerSW, lsLoopDetectAction=lsLoopDetectAction, lsEportLongPktsEnable=lsEportLongPktsEnable, lsEportFtoEByteCts=lsEportFtoEByteCts, lsEportNumber=lsEportNumber, lsStationsAddress=lsStationsAddress, lsFMSBackupPSSense=lsFMSBackupPSSense, lsEportSQETestEnable=lsEportSQETestEnable, lsEportXSQETestFailCts=lsEportXSQETestFailCts, lsEportLinkState=lsEportLinkState, lsEportXBCastCts=lsEportXBCastCts, lsEportTable=lsEportTable)

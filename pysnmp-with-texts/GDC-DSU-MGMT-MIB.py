#
# PySNMP MIB module GDC-DSU-MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDC-DSU-MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Bits, Unsigned32, Counter64, ModuleIdentity, Integer32, Gauge32, iso, NotificationType, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, IpAddress, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Bits", "Unsigned32", "Counter64", "ModuleIdentity", "Integer32", "Gauge32", "iso", "NotificationType", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "IpAddress", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
dsu = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8))
t1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 5))
gdcDsuSystemMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 8, 5, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuSystemMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuSystemMIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
gdcDsuDS0AllocationSchemeTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 5, 1), )
if mibBuilder.loadTexts: gdcDsuDS0AllocationSchemeTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuDS0AllocationSchemeTable.setDescription('The GDC DSU DS0 Allocation Scheme table. Information in an entry of this table defines the DS0 allocation scheme (alternate or consecutive) of the represented DSU.')
gdcDsuDS0AllocationSchemeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 5, 1, 1), ).setIndexNames((0, "GDC-DSU-MGMT-MIB", "gdcDsuDS0AllocationIndex"))
if mibBuilder.loadTexts: gdcDsuDS0AllocationSchemeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuDS0AllocationSchemeEntry.setDescription('The GDC DSU DS0 Allocation scheme table entry.')
gdcDsuDS0AllocationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuDS0AllocationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuDS0AllocationIndex.setDescription('The index value which uniquely identifies the DSU to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-identifier for this SC instance is the DSU.')
gdcDsuDS0AllocationScheme = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("consecutive", 2), ("alternate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuDS0AllocationScheme.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuDS0AllocationScheme.setDescription('Identifies the DSU DS0 allocation scheme. The value of other(1) indicates that an allocation scheme is used which is defined elsewhere. The value consecutive(2) indicates that bundles of DS0s are allocated to channels consecutively from the starting DS0. The value of alternate(3) indicates that bundles of DS0s are allocated to channels alternatly, or every other DS0 from the starting DS0. The unused DS0s are forced to marks. The value of other(1) can never be set by management operation. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
gdcDsuChannelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 5, 2), )
if mibBuilder.loadTexts: gdcDsuChannelConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelConfigTable.setDescription('The GDC DSU Channel Configuration table. Information in the entries of this table define the configuration of DSU channels. There are entries in this table for each channel of the associated DSU.')
gdcDsuChannelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1), ).setIndexNames((0, "GDC-DSU-MGMT-MIB", "gdcDsuChannelConfigIndex"))
if mibBuilder.loadTexts: gdcDsuChannelConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelConfigEntry.setDescription('The GDC DSU Channel Configuration table entry.')
gdcDsuChannelConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelConfigIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-indentifier for this SCinstance is the channel.')
gdcDsuChannelBaseRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nx56k", 1), ("nx64k", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelBaseRate.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelBaseRate.setDescription('Indicates the DS0 base rate: either 56K or 64K bits per second. This is used in conjunction with the number of DS0s to determine the bandwidth of the channel. Note that base rate of 64K defines the DS0 as clear channel in which all 8 bits of the DS0 are used. A base rate of 56K defines the DS0 as non-clear in which bits 1-7 are used for channel data and the 8th bit is either unused and forced to marks or used to pass signaling information.')
gdcDsuChannelStartingDS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelStartingDS0.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelStartingDS0.setDescription('Indicates the starting DS0 number for the bundle of DS0s used for the channel. DS0 bundles are allocated starting at the DS0 defined by this integer. When this integer is set to 0, the channel is disabled and no DS0s are allocated to the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
gdcDsuChannelNumberOfDS0s = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelNumberOfDS0s.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelNumberOfDS0s.setDescription('Indicates the number of DS0s for the bundle allocated to the channel. The number of DS0s, in conjunction with the DS0 base rate, also determines the bandwidth of the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
gdcDsuChannelSplitTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelSplitTiming.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelSplitTiming.setDescription("Indicates whether or not to use split timing. The value disabled(1) indicates that channel's transmit timing is provided by the DSU. The value enabled(2) indicates that the channel's transmit timing is provided by the customer business equipment (ext Tx Clk). Split timing refers to the activation of elastic storage to allow the channel interface to receive data using the customer business equipment's timing source (ext Tx Clk) and transmit that same data to the network using the networks timing source.")
gdcDsuChannelChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("v35", 3), ("eia530", 4), ("dra", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelChannelType.setDescription('The channel interface type. The value other(1) indicates the channel interface is a type defined elsewhere. The value none(2) indicates that there is no channel interface for the index. The value v35(3) indicates the channel interface is standard V.35 and the value eia530(4) indicates the channel interface is standard EIA 530. The value dra(5) indicates the channel is is standard RS232 and is using the data rate adapter (DRA) to run at subrate speeds (below 56K bits per second).')
gdcDsuChannelTransmitClockInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTransmitClockInvert.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTransmitClockInvert.setDescription("Transmit clock invert. The value disabled(1) indicates that the channel's transmit clock is normal, or not inverted, while the value enabled(2) indicates that the channel's transmit clock is inverted.")
gdcDsuChannelReceiveClockInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelReceiveClockInvert.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelReceiveClockInvert.setDescription("Receive clock invert. The value disabled(1) indicates that the channel's receive clock is normal, or not inverted, while the value enabled(2) indicates that the channel's receive clock is inverted.")
gdcDsuChannelTransmitDataInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTransmitDataInvert.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTransmitDataInvert.setDescription("Invert the transmit data. The value disabled(1) indicates that the channel's transmit data is normal, or not inverted, while the value enabled(2) indicates that the channel's transmit data is inverted.")
gdcDsuChannelReceiveDataInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelReceiveDataInvert.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelReceiveDataInvert.setDescription("Invert the receive data. The value disabled(1) indicates that the channel's receive data is normal, or not inverted, while the value enabled(2) indicates that the channel's receive data is inverted.")
gdcDsuChannelLocalDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelLocalDCD.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelLocalDCD.setDescription("Controls the operation of Data Carrier Detect (DCD) signal. The value followsSignal(1) indicates that the channel's DCD follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DCD is forced on.")
gdcDsuChannelLocalDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelLocalDSR.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelLocalDSR.setDescription("Controls the operation of the Data Set Ready (DSR) signal. The value followsSignal(1) indicates that the channel's DSR follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DSR is forced on.")
gdcDsuChannelReceiveControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dcd", 1), ("dsr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelReceiveControl.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelReceiveControl.setDescription('Identifies which signal is used for receive flow control. The two values are Data Carrier Detect, dcd(1), and Data Set Ready, dsr(2).')
gdcDsuChannelTransmitControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rts", 1), ("dtr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTransmitControl.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTransmitControl.setDescription('Identifies which signal is used for transmit flow control. The two values are Request To Send, rts(1), and Data Terminal Ready, dtr(2).')
gdcDsuChannelRTSCTScontrol = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ctsDelay10ms", 2), ("ctsOn", 3), ("ctsDelayStandard", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelRTSCTScontrol.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelRTSCTScontrol.setDescription("Controls the function of the channel's Request To Send (RTS) and Clear To Send signals used for flow control. The value of ctsOn(2) indicates that CTS is forced on at all times. The value of ctsDelay10ms(3) indicates that CTS is to respond to RTS after a 10ms delay. The value of ctsDelayStandard(4) indicates that CTS is to respond to RTS after the standard delay of 40 bits times. The value other(1) identifies another RTS/CTS control. This value can never be set by management request. For 56Kbps applications using CMI flow control, this object must be set for ctsDelayStandard(4).")
gdcDsuChannelEIAtestLeads = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelEIAtestLeads.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelEIAtestLeads.setDescription("Controls the channel's EIA test leads. The EIA test leads allow customer business equipment to initiate diagnostic tests through the assertion of the EIA test leads RDL, LL, and ST. When this object is enabled(1), then the assertion of these leads is recognized and acted upon by the DSU. When this object is disabled(2), then the assertion of these leads is ignored by the DSU.")
gdcDsuChannelDccMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("normal", 2), ("special", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelDccMode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDccMode.setDescription("The type of inband Diagnostics Communication Channel (DCC) in use. The value none(1) indicates no DCC is being used for the given channel. The value normal(2) indicates the channel's inband DCC is used. For Nx56k applications using B8ZS line coding, normal(2) indicates that the DCC embedded in the secondary channel (bit 8) of the channel's DS0 bundle. For Nx56k applications using AMI line coding or for Nx65K applications, normal(2) indicates that the DCC is imbedded in the secondary channel (bit 8) of and additional DS0 appended to the channel's DS0 bundle. The value special(3) indicates the channel's inband DCC is used. For Nx56k applications using B8ZS line coding, special(2) indicates that the DCC is imbedded in the secondary channel (bit 8) of and additional DS0 appended to the channel's DS0 bundle. For Nx56k applications using AMI line coding, normal(2) indicates that the DCC is embedded in the secondary channel (bit 8) of the channel's DS0 bundle. The value special(3) is not valid for Nx64K applications.")
gdcDsuChannelInbandLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelInbandLoop.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelInbandLoop.setDescription('In-band loopcode enable/disable. The value disabled(1) indicates the channel does not enter an RDL loop when an inband RDL code is detected. The value enable(2) indicates the channel does enter an RDL loop when an inband RDL code is detected.')
gdcDsuChannelInbandLoopCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("pn127", 2), ("gdcProprietary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelInbandLoopCode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelInbandLoopCode.setDescription('In-band RDL code to send and/or receive by the channel. The value pn127(2) indicates that the in-band code sent/received is in accordance with CCITT V.54 PN-127 scrambled codes. The value of gdcProprietary(3) indicates that the in-band code sent/received is the GDC defined code. The value other(1) identifies another loopcode defined elsewhere. This value can never be set by management operation.')
gdcDsuChannelInbandLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelInbandLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelInbandLoopdown.setDescription("The time limit in seconds before terminating a channel's RDL. The value 0 indicates that the loopdown time is disabled and the loopback will only terminate by the in-band loopdown code. All other values indicate the time in seconds before terminating the RDL in the event the loopdown code is never received. Note that certain products may only support discrete time lengths. Setting the value to any unsupported time length results in a badValue error.")
gdcDsuChannelTransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTransmitClockSource.setDescription("This object operates in conjunction with gdcDsx1TransmitClockSource in gdcdsx1.mib. If gdcDsx1TransmitClockSource is channel(4), then this object defines whether or not the channel's customer business equipment is providing timing with ext Tx Clk to the network's transmit interface. The value disabled(1) indicates the channel's customer business equipment is not providing timing for the transmit network interface. The value enabled(1) indicates the channel's customer business equipment is providing timing for the transmit network interface.")
gdcDsuChannelFallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("channel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelFallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelFallbackClockSource.setDescription("This object operates in conjunction with gdcDsx1FallbackClockSource in gdcdsx1.mib. If gdcDsx1FallbackClockSource is channel(4), then this object defines whether or not the channel's customer business equipment is providing fallback timing with ext Tx Clk to the network's transmit interface. The value disabled(1) indicates the channel's customer business equipment is not providing fallback timing for the transmit network interface. The value enabled(1) indicates the channel's customer business equipment is providing fallnback timing for the transmit network interface.")
gdcDsuChannelControlModeIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelControlModeIdle.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelControlModeIdle.setDescription('Control Mode Idle (CMI) enable/disable. When the channel application is Nx56k and RTS/CTS delay is standard, then this object defines the the use of CMI to provide flow control. The value disabled(1) indicates the channel using CMI to pass control flow information. The value enabled(w) indicates the channel is using the DDS secondary channel CMI format to pass flow control information.')
gdcDsuChannelSignalStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 5, 3), )
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusTable.setDescription('The GDC DSU Channel Signal Status table. Information in the entries of this table define the status of DSU channel interface leads. There are entries in this table for each channel of the associated DSU.')
gdcDsuChannelSignalStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1), ).setIndexNames((0, "GDC-DSU-MGMT-MIB", "gdcDsuChannelSignalStatusIndex"))
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusEntry.setDescription('The GDC DSU Channel Signal Status table entry.')
gdcDsuChannelSignalStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelSignalStatusIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-indentifier for this SCinstance is the channel.')
gdcDsuChannelCTSstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("transitions", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelCTSstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelCTSstatus.setDescription("The state of the channel's Clear To Send (CTS) signal. The value transitions(3) indicates that the signal is alternating between the states off(1) and on(2).")
gdcDsuChannelRTSstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("transitions", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelRTSstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelRTSstatus.setDescription("The state of the channel's Request To Send (RTS) signal. The value transitions(3) indicates that the signal is alternating between the states off(1) and on(2).")
gdcDsuChannelDTRstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelDTRstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDTRstatus.setDescription("The state of the channel's Data Terminal Ready (DTR) signal.")
gdcDsuChannelDSRstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelDSRstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDSRstatus.setDescription("The state of the channel's Data Set Ready (DSR) signal.")
gdcDsuChannelDCDstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("transitions", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelDCDstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDCDstatus.setDescription("The state of the channel's Data Carrier Detect (DCD) signal. The value transitions(3) indicates that the signal is alternating between the states off(1) and on(2).")
gdcDsuChannelRXCstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("transitions", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelRXCstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelRXCstatus.setDescription("The state of the channel's receive clock (RXC) signal. The value transitions(2) indicates that the signal is alternating between states off(1) and on(2).")
gdcDsuChannelTXCstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("transitions", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelTXCstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTXCstatus.setDescription("The state of the channel's Transmit Clock (TXC) signal. The value transitions(2) indicates that the signal is alternating between states off(1) and on(2).")
gdcDsuChannelRXDstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("transitions", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelRXDstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelRXDstatus.setDescription("The state of the channel's Receive Data (RXD) signal. The value transitions(2) indicates that the signal is alternating between states off(1) and on(2).")
gdcDsuChannelTXDstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("transitions", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelTXDstatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTXDstatus.setDescription("The state of the channel's Transmit Data (TXD) signal. The value transitions(2) indicates that the signal is is alternating between states off(1) and on(2).")
gdcDsuChannelDiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 5, 4), )
if mibBuilder.loadTexts: gdcDsuChannelDiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagTable.setDescription('The GDC DSU Channel Diagnostics table. The information in this table support diagnostic testing, both active testing via patterns, and passive testing via loopback on the DSU channels. There are entries in this table for each channel of the associated DSU.')
gdcDsuChannelDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1), ).setIndexNames((0, "GDC-DSU-MGMT-MIB", "gdcDsuChannelDiagIndex"))
if mibBuilder.loadTexts: gdcDsuChannelDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagEntry.setDescription('The GDC DSU Channel Diagnostics entry.')
gdcDsuChannelDiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelDiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SC instance which defines the slot, line, drop, and sub-identifier, which in this case is the channel.')
gdcDsuChannelDiagSendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("sendNoCode", 1), ("sendQRSpattern", 2), ("send511Pattern", 3), ("send3in24Pattern", 4), ("sendProgPattern", 5), ("send2047Pattern", 6), ("send511PatternWithLL", 7), ("send511PatternWithRDL", 8), ("send2047PatternWithLL", 9), ("send2047PatternWithRDL", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelDiagSendCode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagSendCode.setDescription('Initiates and terminates self test pattern generation and detection (active diagnostic tests) on the DSU channel. When this object is set to other than sendNoCode(1), an active diagnostic test is initiated, using the test pattern supplied . When this object is set to sendNoCode(1), the active diagnostic test is terminated. When read, value sendNoCode(1) indicates there are no active diagnostic tests currently running on the channel. The value sendQRSpattern(2) indicates that a QRS test is running on the channel. The value send511Pattern(3) indicates that a 511 test is running on the channel. The value send3in24Pattern(4) indicates that a 3:24 test is running on the channel. The value send2047Pattern(5) indicates that a 2047 test is running on the channel. The value sendProgPattern(6) indicates that a user programmable pattern test is running on the channel. The value sendProgPattern(6) and the object gdcDsuChannelProgPattern work together. GdcDsuChannelProgPattern defines the 16 bit user programmable pattern for the programmable pattern test. The values send511PatternWithLL(7), send511PatternWithRDL(8), send2047PatternWithLL(9), send2047PatternWithRDL(10) indicate that the given pattern test is running in conjunction with a local loop (LL) or remote digital loop (RDL). gdcDsuChannelLoopbackConfig is updated to indicate this as well. When one of these tests are running, and this variable is set to sendNoCode(1), both the pattern and the loopback are terminated. However, if gdcDsuChannelLoopbackConfig is set to noLoop(1), only the loopback portion is terminated. This object, gdcDsuChannelTestResults, and gdcDsuChannelTestStatus work together as follows: When this object is set to initiate an active diagnostic test, gdcDsuTestResults is initialized to 0 and gdcDsuChannelTestStatus is initialized to testRunning(1). When the test is terminated, the value of gdcDsuChannelTestStatus reflects testComplete(3). gdcDsuChannelTestResults contains the count of bit errors detected during the test. ')
gdcDsuChannelDiagProgPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelDiagProgPattern.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagProgPattern.setDescription('The 16 bit user programmable test pattern. This object works with gdcDsuChannelSendCode. When gdcDsuChannelSendCodeis set to sendProgPattern(6), this object is used as the 16 bit user programmable test pattern.')
gdcDsuChannelLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noLoop", 1), ("localLoop", 2), ("digitalLoop", 3), ("rdl", 4), ("rdlReset", 5), ("otherLoop", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelLoopbackConfig.setDescription('The loopback configuration for the DSU channel to be used for both active and passive diagnostic tests.')
gdcDsuChannelTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLimit", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("testTime30Secs", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTestDuration.setDescription('The length of the diagnostic test, in time. The value 0 signifies that the test should run indefinitely until explicitly terminated.')
gdcDsuChannelDiagTimingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("currentSource", 1), ("loopTiming", 2), ("localTiming", 3), ("station", 4), ("composite", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelDiagTimingSource.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelDiagTimingSource.setDescription('The timing source to be used for diagnostic tests. For tests that do not disrupt the transmit timing source as defined in gdcDsx1TransmitClockSource the value currentSource(1) should be used. The remaining timing sources are for use when the diagnostic test disrupts the transmit timing source. The choice of the diagnostic timing source is dependant upon the type of test involved and the network topology.')
gdcDsuChannelTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("notInTest", 1), ("testInProgress", 2), ("testCompleted", 4), ("testCompletedNotInTest", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsuChannelTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTestStatus.setDescription('The current execution status of the diagnostic test. The value testRunning(1) indicates that a diagnostic test is running. The value testComplete(2) indicates that no diagnostic test is running and that the results are available in gdcDsuChannelTestExceptions and gdcDsuChannelTestResults. The value testBeingConfigured(3) indicates that no diagnostic test is running and that the configuration of a new diagnostic test has been initiated and as such the results may be invalid. This object works with the gdcDsuChannelSendCode object. Whenever a test is initiated by gdcDsuChannelSendCode, then the value of this object is set to testRunning(1). This object also works with the gdcDsuChannelLoopbackConfig, gdcDsuChannelProgPattern, gdcDsuChannelRemoteLoopback, and gdcDsuChannelTestDuration objects. Whenever these variables are set, then the value of this object is set to testBeingConfigured(3).')
gdcDsuChannelTestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelTestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTestExceptions.setDescription('Indicates any exceptions that may have occurred that would affect the interpretation of the test results provided in gdcDsuChannelTestResults. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 1 A timed test was preempted so the result cannot be viewed in relation to the test duration 2 The results overflowed so the result cannot be viewed as an absolute value 4 The test was performed while synchronization could not be performed so the result may not be accurate.')
gdcDsuChannelTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 5, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsuChannelTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsuChannelTestResults.setDescription('The results of the last diagnostic test, in bit errors. This can be the current test running or the last completed test. Note that the interpretation of these results may be affected by the value of gdcDsx1TestExceptions.')
mibBuilder.exportSymbols("GDC-DSU-MGMT-MIB", gdcDsuChannelTXDstatus=gdcDsuChannelTXDstatus, gdcDsuChannelDSRstatus=gdcDsuChannelDSRstatus, gdcDsuChannelSplitTiming=gdcDsuChannelSplitTiming, gdcDsuChannelDiagIndex=gdcDsuChannelDiagIndex, gdcDsuChannelSignalStatusEntry=gdcDsuChannelSignalStatusEntry, gdcDsuSystemMIBversion=gdcDsuSystemMIBversion, gdcDsuChannelTestDuration=gdcDsuChannelTestDuration, dsu=dsu, gdcDsuChannelEIAtestLeads=gdcDsuChannelEIAtestLeads, gdcDsuChannelDCDstatus=gdcDsuChannelDCDstatus, gdcDsuChannelTransmitControl=gdcDsuChannelTransmitControl, gdcDsuChannelConfigTable=gdcDsuChannelConfigTable, gdcDsuChannelConfigEntry=gdcDsuChannelConfigEntry, gdcDsuChannelInbandLoopdown=gdcDsuChannelInbandLoopdown, gdcDsuChannelSignalStatusTable=gdcDsuChannelSignalStatusTable, gdcDsuChannelReceiveClockInvert=gdcDsuChannelReceiveClockInvert, gdcDsuChannelInbandLoop=gdcDsuChannelInbandLoop, gdcDsuChannelInbandLoopCode=gdcDsuChannelInbandLoopCode, gdcDsuChannelSignalStatusIndex=gdcDsuChannelSignalStatusIndex, gdcDsuChannelBaseRate=gdcDsuChannelBaseRate, gdcDsuChannelRXCstatus=gdcDsuChannelRXCstatus, gdcDsuChannelDiagProgPattern=gdcDsuChannelDiagProgPattern, gdcDsuChannelTestExceptions=gdcDsuChannelTestExceptions, gdcDsuChannelReceiveControl=gdcDsuChannelReceiveControl, gdcDsuChannelConfigIndex=gdcDsuChannelConfigIndex, gdc=gdc, gdcDsuChannelDiagSendCode=gdcDsuChannelDiagSendCode, gdcDsuChannelNumberOfDS0s=gdcDsuChannelNumberOfDS0s, gdcDsuChannelLocalDCD=gdcDsuChannelLocalDCD, gdcDsuChannelTransmitClockSource=gdcDsuChannelTransmitClockSource, gdcDsuChannelTransmitDataInvert=gdcDsuChannelTransmitDataInvert, gdcDsuChannelRTSstatus=gdcDsuChannelRTSstatus, gdcDsuChannelTransmitClockInvert=gdcDsuChannelTransmitClockInvert, gdcDsuChannelLoopbackConfig=gdcDsuChannelLoopbackConfig, gdcDsuChannelDiagTimingSource=gdcDsuChannelDiagTimingSource, gdcDsuChannelRTSCTScontrol=gdcDsuChannelRTSCTScontrol, gdcDsuChannelTestResults=gdcDsuChannelTestResults, gdcDsuChannelRXDstatus=gdcDsuChannelRXDstatus, gdcDsuChannelDTRstatus=gdcDsuChannelDTRstatus, t1=t1, gdcDsuChannelDiagEntry=gdcDsuChannelDiagEntry, gdcDsuChannelReceiveDataInvert=gdcDsuChannelReceiveDataInvert, gdcDsuDS0AllocationSchemeTable=gdcDsuDS0AllocationSchemeTable, gdcDsuChannelFallbackClockSource=gdcDsuChannelFallbackClockSource, gdcDsuChannelTXCstatus=gdcDsuChannelTXCstatus, gdcDsuChannelCTSstatus=gdcDsuChannelCTSstatus, gdcDsuChannelDiagTable=gdcDsuChannelDiagTable, gdcDsuChannelLocalDSR=gdcDsuChannelLocalDSR, gdcDsuDS0AllocationIndex=gdcDsuDS0AllocationIndex, gdcDsuChannelTestStatus=gdcDsuChannelTestStatus, gdcDsuDS0AllocationSchemeEntry=gdcDsuDS0AllocationSchemeEntry, gdcDsuChannelDccMode=gdcDsuChannelDccMode, gdcDsuChannelControlModeIdle=gdcDsuChannelControlModeIdle, gdcDsuChannelStartingDS0=gdcDsuChannelStartingDS0, gdcDsuDS0AllocationScheme=gdcDsuDS0AllocationScheme, gdcDsuChannelChannelType=gdcDsuChannelChannelType)

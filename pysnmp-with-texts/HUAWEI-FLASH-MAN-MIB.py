#
# PySNMP MIB module HUAWEI-FLASH-MAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HUAWEI-FLASH-MAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:43:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
huaweiUtility, = mibBuilder.importSymbols("HUAWEI-MIB", "huaweiUtility")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ObjectIdentity, TimeTicks, IpAddress, MibIdentifier, Unsigned32, Integer32, Counter64, Bits, NotificationType, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, iso, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "TimeTicks", "IpAddress", "MibIdentifier", "Unsigned32", "Integer32", "Counter64", "Bits", "NotificationType", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "iso", "Gauge32")
TextualConvention, DisplayString, RowStatus, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TimeStamp", "TruthValue")
hwFlash = ModuleIdentity((1, 3, 6, 1, 4, 1, 2011, 6, 9))
hwFlash.setRevisions(('2015-02-10 00:01', '2015-01-26 00:01', '2014-12-15 00:01', '2013-07-09 00:01', '2002-07-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hwFlash.setRevisionsDescriptions(('The HUAWEI-FLASH-MIB contains objects to manage the device flash cards and flash card operations. There are no constraints on this MIB. ', 'The HUAWEI-FLASH-MIB contains objects to manage the device flash cards and flash card operations. There are no constraints on this MIB. ', 'The HUAWEI-FLASH-MIB contains objects to manage the device flash cards and flash card operations. There are no constraints on this MIB. ', 'The HUAWEI-FLASH-MIB contains objects to manage the device flash cards and flash card operations. There are no constraints on this MIB. ', 'The initial revision of this MIB module .',))
if mibBuilder.loadTexts: hwFlash.setLastUpdated('201502100001Z')
if mibBuilder.loadTexts: hwFlash.setOrganization('Huawei Technologies Co.,Ltd.')
if mibBuilder.loadTexts: hwFlash.setContactInfo("Huawei Industrial Base Bantian, Longgang Shenzhen 518129 People's Republic of China Website: http://www.huawei.com Email: support@huawei.com ")
if mibBuilder.loadTexts: hwFlash.setDescription('The HUAWEI-FLASH-MIB contains objects to manage the device flash cards and flash card operations. There are no constraints on this MIB. ')
class HwFlashPartitionStatus(TextualConvention, Integer32):
    description = "If the flash partition is not programmable, the value will be 'readOnly(1)'; If the current image is running from this partition, the value will be 'runFromFlash(2)'; If the flash partition is programmable, the value will be 'readWrite(3) '. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("readOnly", 1), ("runFromFlash", 2), ("readWrite", 3))

class HwFlashPartitionUpgradeMode(TextualConvention, Integer32):
    description = 'Flash partition upgrade method, ie., method by which new files can be downloaded into the partition. FLH stands for Flash Load Helper, a feature provided on run-from-Flash systems for upgrading Flash. This feature uses the bootstrap code in ROMs to help in automatic download. This object should be retrieved if the partition status is runFromFlash(2). If the partition status is readOnly(1), the upgrade method would depend on the reason for the readOnly status. For eg., it may simply be a matter of installing the programming jumper, or it may require execution of a later version of software that supports the Flash chips. unknown(1) - the current system image does not know how Flash can be programmed. A possible method would be to reload the ROM image and perform the upgrade manually. rxbootFLH(2) - the Flash Load Helper is available to download files to Flash. A copy-to-flash command can be used and this system image will automatically reload the Rxboot image in ROM and direct it to carry out the download request. direct(3) - will be done directly by this image. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("rxbootFLH", 2), ("direct", 3))

class HwFlashOperationStatus(TextualConvention, Integer32):
    description = 'The status of the specified operation can be one of the follows. opInProgress(1) : the operation is in process. opSuccess(2) : the operation has been completed successfully. opInvalid(3) : the command is invalid or command-protocol-device combination is unsupported by the system. opInvalidProtocol(4) :invalid protocol is specified opInvalidSourceName(5) :invalid source file name is specified. opInvalidDestName(6) :invalid target name is specified. opInvalidServerAddress(7) :invalid server address is specified opDeviceBusy(8) :the device is in use and locked by another process opDeviceOpenError(9) :invalid device name is specified. opDeviceError(10) : device read, write or erase error opDeviceNotProgrammable(11) :device is read-only but a write or erase operation was specified opDeviceFull(12) : device is filled to capacity opFileOpenError(13) :invalid file name; file not found in partition opFileTransferError(14) :file transfer was unsuccessful opFileChecksumError(15) :file checksum in Flash is invalid opNoMemory(16) :system is running in low on memory opAuthFail(17) :authentication failure opUnknownFailure(18) :failure which is unknown opAbort(19) : transfer operation has been abort opInvalidSourceAddress(20) : transfer operation has been abort opInvalidSourceInterface(21) : transfer operation has been abort opCurrentVersionFileConfilt(22) : conflict between target file and system file'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))
    namedValues = NamedValues(("opInProgress", 1), ("opSuccess", 2), ("opInvalid", 3), ("opInvalidProtocol", 4), ("opInvalidSourceName", 5), ("opInvalidDestName", 6), ("opInvalidServerAddress", 7), ("opDeviceBusy", 8), ("opDeviceOpenError", 9), ("opDeviceError", 10), ("opDeviceNotProgrammable", 11), ("opDeviceFull", 12), ("opFileOpenError", 13), ("opFileTransferError", 14), ("opFileChecksumError", 15), ("opNoMemory", 16), ("opAuthFail", 17), ("opUnknownFailure", 18), ("opAbort", 19), ("opInvalidSourceAddress", 20), ("opInvalidSourceInterface", 21), ("opCurrentVersionFileConfilt", 22))

huaweiFlashManMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1))
huaweiFlashDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1))
hwFlhSupportNum = MibScalar((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhSupportNum.setStatus('current')
if mibBuilder.loadTexts: hwFlhSupportNum.setDescription('Specifies the total number of flash which the system supported. The MIB should not be loaded if there is no flash on the device, therefore the value of the object is at least 1.')
hwFlashTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2), )
if mibBuilder.loadTexts: hwFlashTable.setStatus('current')
if mibBuilder.loadTexts: hwFlashTable.setDescription('This table gives the properties of all the flashes on the device . ')
hwFlashEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhIndex"))
if mibBuilder.loadTexts: hwFlashEntry.setStatus('current')
if mibBuilder.loadTexts: hwFlashEntry.setDescription(' The entries of hwFlashTable.')
hwFlhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhIndex.setStatus('current')
if mibBuilder.loadTexts: hwFlhIndex.setDescription('The index of hwFlashTable. It has the minimum value of 1, and maximum value of the same as the value of hwFlhSupportNum.')
hwFlhSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 2), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhSize.setStatus('current')
if mibBuilder.loadTexts: hwFlhSize.setDescription('Specifies the total size of the Flash device indexed by hwFlhIndex. The value will be zero if the flash is removed for a removable device.')
hwFlhPos = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPos.setStatus('current')
if mibBuilder.loadTexts: hwFlhPos.setDescription('The position of the flash device on the system.This object is an index of entPhysicalTable in ENTITY-MIB . If the value of this object is 0, the main processor is indicated.')
hwFlhName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhName.setStatus('current')
if mibBuilder.loadTexts: hwFlhName.setDescription('The flash device name used to refer to the device within the system. ')
hwFlhChipNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipNum.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipNum.setDescription('The chip numbers in the flash device. ')
hwFlhDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhDescr.setStatus('current')
if mibBuilder.loadTexts: hwFlhDescr.setDescription('Description of the purpose of the flash device on the system. ')
hwFlhInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhInitTime.setStatus('current')
if mibBuilder.loadTexts: hwFlhInitTime.setDescription("The system time at which device was initialized. For fixed devices, this will be the system's boot up time. For removable devices, it will be the time at which the device was inserted. It may be a later time if device was inserted later. If a device can be partitioned and repartitioned, it will be the time of repartitioning.")
hwFlhRemovable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhRemovable.setStatus('current')
if mibBuilder.loadTexts: hwFlhRemovable.setDescription('The object indicates whether the flash indexed can be removed or not. The true(1) value indicates the flash device CAN be removed .The false(2) value indicates the flash device CANNOT be removed .')
hwFlhPartitionBool = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwFlhPartitionBool.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartitionBool.setDescription('The object indicates whether the flash indexed can be partitioned or not. The true(1) value indicates the flash device CAN be partitioned. The false(2) value indicates the flash device CANNOT be partitioned.The actual partition state depends on the value of hwFlhDevicePartions.')
hwFlhMinPartitionSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 12), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhMinPartitionSize.setStatus('current')
if mibBuilder.loadTexts: hwFlhMinPartitionSize.setDescription('Minimum partition size the device supported. If hwFlhDevicePartitionBool is false, the value of this object is the same as hwFlhDeviceSize. ')
hwFlhMaxPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhMaxPartitions.setStatus('current')
if mibBuilder.loadTexts: hwFlhMaxPartitions.setDescription('The maximum count of partitions which the system supports for this Flash device.If hwFlhPartitionBool is false, the object value is 1.')
hwFlhPartitionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartitionNum.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartitionNum.setDescription('The actual number of partitions supported by the system for this Flash device.If hwFlhPartitionBool is false, the object value is 1.')
hwFlashChips = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3))
hwFlhChipTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1), )
if mibBuilder.loadTexts: hwFlhChipTable.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipTable.setDescription('Table of Flash device chip properties for each initialized Flash device. This table is meant primarily for aiding error diagnosis. ')
hwFlhChipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhIndex"), (0, "HUAWEI-FLASH-MAN-MIB", "hwFlhChipSerialNo"))
if mibBuilder.loadTexts: hwFlhChipEntry.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipEntry.setDescription('The entry of hwFlhChipTable')
hwFlhChipSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: hwFlhChipSerialNo.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipSerialNo.setDescription('Index of hwFlhChipTable.')
hwFlhChipID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipID.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipID.setDescription('The manufacturer and device code for a chip. The device code is in the lower byte.And The manufacturer code is in the Upper byte. Unknown chip code is presented as 00:00. ')
hwFlhChipDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipDescr.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipDescr.setDescription(" The description of the flash chip. e.g. 'Intel 27F008SA' ")
hwFlhChipWriteTimesLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipWriteTimesLimit.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipWriteTimesLimit.setDescription('The maximum number of write retries done at any single location before declaring a write failure. ')
hwFlhChipWriteTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipWriteTimes.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipWriteTimes.setDescription('This object will provide a cumulative count (since last system boot up or initialization) of the number of write retries that were done in the chip. If no writes have been done to Flash, the count will be zero. Typically, a maximum of 25 retries are done on a single location before flagging a write error. A management station is expected to get this object for each chip in a partition after a write failure in that partition. To keep a track of retries for a given write operation, the management station would have to retrieve the values for the concerned chips before and after any write operation. It is a cumulative count of write retries that were done in the chip. ')
hwFlhChipEraseTimesLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipEraseTimesLimit.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipEraseTimesLimit.setDescription('The maximum number of erase retries done within an erase sector before declaring an erase failure. ')
hwFlhChipEraseTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhChipEraseTimes.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipEraseTimes.setDescription('This object will provide a cumulative count (since last system boot up or initialization) of the number of erase retries that were done in the chip. Typically, a maximum of 2000 retries are done in a single erase zone (which may be a full chip or a portion, depending on the chip technology) before flagging an erase error. A management station is expected to get this object for each chip in a partition after an erase failure in that partition. To keep a track of retries for a given erase operation, the management station would have to retrieve the values for the concerned chips before and after any erase operation. Note that erase may be done through an independent command, or through a copy-to-flash command. ')
hwFlashPartitions = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4))
hwFlhPartitionTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1), )
if mibBuilder.loadTexts: hwFlhPartitionTable.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartitionTable.setDescription('Table of flash device partition properties for each initialized flash partition. Whenever there is no explicit partitioning done, a single partition spanning the entire device will be assumed to exist. There will therefore always be at least one partition on a device. ')
hwFlhPartitionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhIndex"), (0, "HUAWEI-FLASH-MAN-MIB", "hwFlhPartIndex"))
if mibBuilder.loadTexts: hwFlhPartitionEntry.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartitionEntry.setDescription('An entry in the table of flash partition properties for each initialized flash partition. Each entry will be indexed by a device number and a partition number within the device. ')
hwFlhPartIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: hwFlhPartIndex.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartIndex.setDescription('The one of indexes which specifies a partition in system. It is the sequence number of partitions. ')
hwFlhPartFirstChip = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartFirstChip.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartFirstChip.setDescription(" The first chip's sequence number in the partition, by which a chip can be indexed in chip table. ")
hwFlhPartLastChip = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartLastChip.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartLastChip.setDescription(" The last chip's sequence number in the partition, by which a chip can be indexed in chip table. ")
hwFlhPartSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 4), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartSpace.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartSpace.setDescription(' The total space of the flash partition. The following should be satisfied: hwFlhPartSpace = n*hwFlhMinPartitionSize ')
hwFlhPartSpaceFree = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 5), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartSpaceFree.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartSpaceFree.setDescription("The Flash partition's free space. ")
hwFlhPartFileNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartFileNum.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartFileNum.setDescription('The number of all the file in the flash partition.')
hwFlhPartChecksumMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("simpleChecksum", 1), ("undefined", 2), ("simpleCRC", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartChecksumMethod.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartChecksumMethod.setDescription(' The Checksum algorithm identifier checksum method which the file system uses. ')
hwFlhPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 8), HwFlashPartitionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartStatus.setDescription("The flash partition status. If device is not programmable the value of it will be 'readOnly(1)'; If the current image is running from this partition, the value of it will be 'runFromFlash(2)'; If device is programmable the value of it will be 'readWrite(3) '. ")
hwFlhPartUpgradeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 9), HwFlashPartitionUpgradeMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartUpgradeMode.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartUpgradeMode.setDescription('The upgrade method of Flash partition, ie., method by which new files can be downloaded into the partition. FLH stands for Flash Load Helper, a feature provided on run-from-Flash systems for upgrading Flash. This feature uses the bootstrap code in ROMs to help in automatic download. This object should be retrieved if the partition status is runFromFlash(2). If the partition status is readOnly(1), the upgrade method would depend on the reason for the readOnly status. For eg., it may simply be a matter of installing the programming jumper, or it may require execution of a later version of software that supports the Flash chips. unknown(1) - the current system image does not know how Flash can be programmed. A possible method would be to reload the ROM image and perform the upgrade manually. rxbootFLH(2) - the Flash Load Helper is available to download files to Flash. A copy-to-flash command can be used and this system image will automatically reload the Rxboot image in ROM and direct it to carry out the download request. direct(3) - will be done directly by this image.')
hwFlhPartName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartName.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartName.setDescription(' The name of flash partition. It was referred by the system.')
hwFlhPartRequireErase = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartRequireErase.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartRequireErase.setDescription('Indicates whether the partition of flash needed to be erased or not before write operation on it.')
hwFlhPartFileNameLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhPartFileNameLen.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartFileNameLen.setDescription(' The maximum length of file name in the system. ')
hwFlhFiles = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2))
huaweiFlhFileTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1), )
if mibBuilder.loadTexts: huaweiFlhFileTable.setStatus('current')
if mibBuilder.loadTexts: huaweiFlhFileTable.setDescription('Table of information for files in a Flash partition. ')
huaweiFlhFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhIndex"), (0, "HUAWEI-FLASH-MAN-MIB", "hwFlhPartIndex"), (0, "HUAWEI-FLASH-MAN-MIB", "hwFlhFileIndex"))
if mibBuilder.loadTexts: huaweiFlhFileEntry.setStatus('current')
if mibBuilder.loadTexts: huaweiFlhFileEntry.setDescription('An entry in the table of Flash file properties for each initialized Flash partition. Each entry represents a file and gives details about the file. An entry is indexed using the device number, partition number within the device, and file number within the partition. ')
hwFlhFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hwFlhFileIndex.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileIndex.setDescription('The index of the table .')
hwFlhFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhFileName.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileName.setDescription(' A valid file name supported by the file system. ')
hwFlhFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhFileSize.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileSize.setDescription("The file size in bytes, which doesn't include the file header of filesystem. The minimum value of it will be 1. ")
hwFlhFileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("deleted", 1), ("invalidChecksum", 2), ("valid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhFileStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileStatus.setDescription('The status maybe follows: deleted(1):The file is in recycle. checksumWrong(2):The checksum of file is invalid; valid(3):A valid file. ')
hwFlhFileChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhFileChecksum.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileChecksum.setDescription(' The file checksum located in the header of file. ')
hwFlhFileTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 1, 4, 2, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhFileTime.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileTime.setDescription(' The file checksum located in the header of file. ')
huaweiFlashOperate = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2))
huaweiFlhOpTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1), )
if mibBuilder.loadTexts: huaweiFlhOpTable.setStatus('current')
if mibBuilder.loadTexts: huaweiFlhOpTable.setDescription('A table of Flash copy operation entries. Each entry represents a Flash copy operation (to or from Flash) that has been initiated. ')
huaweiFlhOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhOperIndex"))
if mibBuilder.loadTexts: huaweiFlhOpEntry.setStatus('current')
if mibBuilder.loadTexts: huaweiFlhOpEntry.setDescription('A Flash copy operation entry. Each entry consists of a command, a source, and optional parameters such as protocol to be used, a destination, a server address, etc. A management station wishing to create an entry should first generate a pseudo-random serial number to be used as the index to this sparse table. The station should then create the associated instance of the row status object. It must also, either in the same or in successive PDUs, create the associated instance of the command and parameter objects. It should also modify the default values for any of the parameter objects if the defaults are not appropriate. Once the appropriate instances of all the command objects have been created, either by an explicit SNMP set request or by default, the row status should be set to active to initiate the operation. Note that this entire procedure may be initiated via a single set request which specifies a row status of createAndGo as well as specifies valid values for the non-defaulted parameter objects. Once an operation has been activated, it cannot be stopped. Once the operation completes, the management station should retrieve the value of the status object (and time if desired), and delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 5 minutes of completing. ')
hwFlhOperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hwFlhOperIndex.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperIndex.setDescription(' Specifies the index of an entry. It is a random value when creating an entry.')
hwFlhOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("net2FlashWithErase", 1), ("net2FlashWithoutErase", 2), ("flash2Net", 3), ("delete", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperType.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperType.setDescription('Specifies the operation to be executed. net2FlashWithErase Copy a file to flash; erase flash before copy. Use the FTP protocol or SFTP protocol. net2FlashWithoutErase Same with net2FlashWithErase. flash2Net Copy a file from flash using the FTP protocol or SFTP protocol. delete delete file or directory by source file name. ')
hwFlhOperProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ftp", 1), ("sftp", 2), ("tftp", 3))).clone('ftp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperProtocol.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperProtocol.setDescription('Specifies the protocol used to transfer file. The default value of it is ftp. When hwFlhOperProtocol is specified as SFTP, only password authentication-type is valid. ')
hwFlhOperServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperServerAddress.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperServerAddress.setDescription(' The address of remote host acting as server for any operation. ')
hwFlhOperServerUser = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperServerUser.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperServerUser.setDescription(' When use ftp or sftp to transfer files, the user name must be specified by this node. ')
hwFlhOperPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperPassword.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperPassword.setDescription('Remote user password for copy via ftp protocol. Optional. This object will be ignored for protocols other than ftp and sftp. ')
hwFlhOperSourceFile = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperSourceFile.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperSourceFile.setDescription('Specifies the Source file name to be transferred . It may be located on flash or remote server. It may include the file path if it is applicable. It must be specified. ')
hwFlhOperDestinationFile = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperDestinationFile.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperDestinationFile.setDescription('Specifies the destination file name to be transferred . It may be located on flash or remote server. It may include the file path if it is applicable. If it is not specified , the destination file name is the same as source file name for application.')
hwFlhOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 9), HwFlashOperationStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperStatus.setDescription('The status of operation. The status of the specified operation can be one of the follows. opInProgress(1) : the operation is in process. opSuccess(2) : the operation has been completed successfully. opInvalid(3) : the command is invalid or command-protocol-device combination is unsupported by the system. opInvalidProtocol(4) :invalid protocol is specified opInvalidSourceName(5) :invalid source file name is specified. opInvalidDestName(6) :invalid target name is specified. opInvalidServerAddress(7) :invalid server address is specified opDeviceBusy(8) :the device is in use and locked by another process opDeviceOpenError(9) :invalid device name is specified. opDeviceError(10) : device read, write or erase error opDeviceNotProgrammable(11) :device is read-only but a write or erase operation was specified opDeviceFull(12) : device is filled to capacity opFileOpenError(13) :invalid file name; file not found in partition opFileTransferError(14) :file transfer was unsuccessfull opFileChecksumError(15) :file checksum in Flash si invalid opNoMemory(16) :system is running in low on memory opAuthFail(17) :authentication failure opUnknownFailure(18) :failure which is unknown opAbort(19) : transfer operation has been aborted opInvalidSourceAddress(20) : invalid source IP is specified. opInvalidSourceInterface(21) : invalid source interface is specified. opCurrentVersionFileConfilt(22) : conflict between target file and system file')
hwFlhOperEndNotification = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperEndNotification.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperEndNotification.setDescription(" If the value of it is specified 'true',a notification will be generated at the end of the operation. Otherwise no notification will be generated. ")
hwFlhOperProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhOperProgress.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperProgress.setDescription('The progress described as the time taken for the operation. ')
hwFlhOperRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperRowStatus.setDescription('The status of this table entry. When the status is active : (1) In the situation that the specified transfer operation by ftp/tftp is in progress, the transfer operation will be aborted if the status is set to notInService. (2) In any other situations, the specified operation will not be aborted even if the status is set to notInService. ')
hwFlhOperServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperServerPort.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperServerPort.setDescription('This object specifies the SFTP/FTP server port that is used for file transfer only if the value of hwFlhOperProtocol is sftp/ftp. The default SFTP server port is 22 if no port is specified. The default FTP server port is 21 if no port is specified. If the value of hwFlhOperProtocol is not sftp/ftp, this object is ignored by the implementation. ')
hwFlhOperSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 14), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperSourceAddress.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperSourceAddress.setDescription('The source IP address. When hwFlhOperType is specified as net2FlashWithErase, net2FlashWithoutErase or flash2Net, the source IP address of the client may be specified or not. Default is 0.0.0.0 . If the source type is set to both of IP address and interface, the former has the priority.')
hwFlhOperSourceInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 47))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperSourceInterface.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperSourceInterface.setDescription('The name of the source interface.When hwFlhOperType is specified as net2FlashWithErase,net2FlashWithoutErase or flash2Net,the source interface of the FTP/TFTP client may be specified or not. If the source type is set to both of IP address and interface,the former has the priority.')
hwFlhOperMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperMemSize.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperMemSize.setDescription('This object specifies the reserved space (in KBs) guaranteed by a host. The value 0 indicates that no space need be reserved. The default value is 0. This object is optional when hwFlhOperType is specified as net2FlashWithErase or net2FlashWithoutErase in the Set operation. This object is unavailable when hwFlhOperType is specified as flash2Net or delete in the Set operation. ')
hwFlhOperVpnInstanceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperVpnInstanceName.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperVpnInstanceName.setDescription('The vpn instance name of the file server.')
hwFlhOperTotalFileLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperTotalFileLength.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperTotalFileLength.setDescription('The total length of the file, in bytes.')
hwFlhOperTransferProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhOperTransferProgress.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperTransferProgress.setDescription('The transfer progress of the file.')
hwFlhOperErrorReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFlhOperErrorReason.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperErrorReason.setDescription('The failure reason of operation.')
hwFlhOperServerIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhOperServerIpv6Address.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperServerIpv6Address.setDescription('The address of remote host acting as Ipv6 server for any operation.')
hwFlhSyncTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2), )
if mibBuilder.loadTexts: hwFlhSyncTable.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncTable.setDescription('A table of Flash synchronize operate include copy/delete etc.')
hwFlhSyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwFlhSyncIndex"))
if mibBuilder.loadTexts: hwFlhSyncEntry.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncEntry.setDescription('A Flash synchronize operation entry. Each entry consists of a synchronize command, such as copy,delete etc.')
hwFlhSyncIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hwFlhSyncIndex.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncIndex.setDescription('Specifies the index of an entry. It is a random value when creating an entry.')
hwFlhSyncType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("net2FlashCopy", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncType.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncType.setDescription('Synchronize operation type to be executed. net2FlashCopy Net operate copy a file from one board to another;')
hwFlhSyncRange = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("designate", 1), ("all", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncRange.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncRange.setDescription('Synchronize operation range to be executed. designate Net designate a object to be handled as synchronize destination; all Net make all chassis and all board as handled object;')
hwFlhSyncSourcePath = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncSourcePath.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncSourcePath.setDescription('The source board path to be transferred. It must be specified.')
hwFlhSyncSourceFile = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncSourceFile.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncSourceFile.setDescription('The source file name to be transferred . It is located on the flash of the mainboard of a chassis. It is combine with the hwFlhSyncSourcePath to specify the absolute file name. It must be specified.')
hwFlhSyncDestinationPath = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncDestinationPath.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncDestinationPath.setDescription('The destination board path to be transferred. It must be specified.')
hwFlhSyncDestinationFile = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncDestinationFile.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncDestinationFile.setDescription('The destination file name to be transferred . It is combine with the hwFlhSyncDestinationPath to specify the absolute file name. It must be specified.')
hwFlhSyncRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 2, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwFlhSyncRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncRowStatus.setDescription('The row status of this table entry.')
huaweiFlashNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 3))
hwFlhOperNotification = NotificationType((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 3, 1)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhOperStatus"))
if mibBuilder.loadTexts: hwFlhOperNotification.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperNotification.setDescription('A hwFlhOperNotification is sent only when hwFlhOperEndNotification is true.')
hwFlhSyncSuccessNotification = NotificationType((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 3, 2)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncSourceFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncDestinationFile"))
if mibBuilder.loadTexts: hwFlhSyncSuccessNotification.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncSuccessNotification.setDescription('A hwFlhSyncSuccessNotification is sent when the file copy operation successful.')
hwFlhSyncFailNotification = NotificationType((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 3, 3)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncSourceFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncDestinationFile"))
if mibBuilder.loadTexts: hwFlhSyncFailNotification.setStatus('current')
if mibBuilder.loadTexts: hwFlhSyncFailNotification.setDescription('A hwFlhSyncFailNotification is sent when the file copy operation failed.')
huaweiStorageDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4))
hwStorageTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2), )
if mibBuilder.loadTexts: hwStorageTable.setStatus('current')
if mibBuilder.loadTexts: hwStorageTable.setDescription('This table gives the properties of all the storage devices on the device . ')
hwStorageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1), ).setIndexNames((0, "HUAWEI-FLASH-MAN-MIB", "hwStorageIndex"))
if mibBuilder.loadTexts: hwStorageEntry.setStatus('current')
if mibBuilder.loadTexts: hwStorageEntry.setDescription(' The entries of hwStorageTable.')
hwStorageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: hwStorageIndex.setStatus('current')
if mibBuilder.loadTexts: hwStorageIndex.setDescription('The index of hwStorageTable. It has the minimum value of 1. ')
hwStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flash", 1), ("hardDisk", 2), ("cfCard", 3), ("usbDisk", 4), ("sdCard", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwStorageType.setStatus('current')
if mibBuilder.loadTexts: hwStorageType.setDescription('The type of all the storage devices on the device ')
hwStorageSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 3), Integer32()).setUnits('kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwStorageSpace.setStatus('current')
if mibBuilder.loadTexts: hwStorageSpace.setDescription('Specifies the total size of the storage devices indexed by hwStorageTable.')
hwStorageSpaceFree = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 4), Integer32()).setUnits('kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hwStorageSpaceFree.setStatus('current')
if mibBuilder.loadTexts: hwStorageSpaceFree.setDescription('The free space of the storage devices. ')
hwStorageName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwStorageName.setStatus('current')
if mibBuilder.loadTexts: hwStorageName.setDescription('The storage devices name used to refer to the device within the system. ')
hwStorageDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 6, 9, 1, 4, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwStorageDescr.setStatus('current')
if mibBuilder.loadTexts: hwStorageDescr.setDescription('Description of the purpose of the storage devices on the system. ')
huaweiFlashMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2))
hwFlhMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 1))
hwFlhMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 1, 1)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhGroup"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipGroup"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartitionGroup"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhFileGroup"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperationGroup"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhMIBCompliance = hwFlhMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: hwFlhMIBCompliance.setDescription(' The compliance statement for entities that support the huawei Flash MIB. ')
huaweiFlashMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2))
hwFlhGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 1)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhSupportNum"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSize"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPos"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhName"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipNum"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhDescr"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhInitTime"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhRemovable"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartitionBool"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhMinPartitionSize"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhMaxPartitions"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartitionNum"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhGroup = hwFlhGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhGroup.setDescription('A collection of objects on Flash device level information. ')
hwFlhChipGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 3)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhChipID"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipDescr"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipWriteTimesLimit"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipWriteTimes"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipEraseTimesLimit"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhChipEraseTimes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhChipGroup = hwFlhChipGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhChipGroup.setDescription('A collection of objects on chip level information. ')
hwFlhPartitionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 4)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhPartFirstChip"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartLastChip"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartSpace"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartSpaceFree"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartFileNum"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartChecksumMethod"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartStatus"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartUpgradeMode"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartName"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartRequireErase"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhPartFileNameLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhPartitionGroup = hwFlhPartitionGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhPartitionGroup.setDescription('A collection of objects providing on partition level information. ')
hwFlhFileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 5)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhFileName"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhFileSize"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhFileStatus"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhFileChecksum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhFileGroup = hwFlhFileGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhFileGroup.setDescription('A collection of objects on file level information. ')
hwFlhOperationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 6)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhOperType"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperProtocol"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperServerAddress"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperServerUser"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperPassword"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperSourceFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperDestinationFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperStatus"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperEndNotification"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperProgress"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperRowStatus"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperServerPort"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperSourceAddress"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperSourceInterface"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperMemSize"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncType"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncRange"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncSourcePath"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncSourceFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncDestinationPath"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncDestinationFile"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncRowStatus"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhOperServerIpv6Address"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhOperationGroup = hwFlhOperationGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhOperationGroup.setDescription('A collection of objects of flash operations. ')
hwFlhNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 7)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwFlhOperNotification"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncSuccessNotification"), ("HUAWEI-FLASH-MAN-MIB", "hwFlhSyncFailNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwFlhNotificationGroup = hwFlhNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hwFlhNotificationGroup.setDescription('The collection of notifications in the module')
hwStorageGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 6, 9, 2, 2, 8)).setObjects(("HUAWEI-FLASH-MAN-MIB", "hwStorageType"), ("HUAWEI-FLASH-MAN-MIB", "hwStorageSpace"), ("HUAWEI-FLASH-MAN-MIB", "hwStorageSpaceFree"), ("HUAWEI-FLASH-MAN-MIB", "hwStorageName"), ("HUAWEI-FLASH-MAN-MIB", "hwStorageDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwStorageGroup = hwStorageGroup.setStatus('current')
if mibBuilder.loadTexts: hwStorageGroup.setDescription('Description.')
mibBuilder.exportSymbols("HUAWEI-FLASH-MAN-MIB", hwFlhFileGroup=hwFlhFileGroup, hwFlhOperTotalFileLength=hwFlhOperTotalFileLength, hwFlhInitTime=hwFlhInitTime, hwFlhSyncDestinationFile=hwFlhSyncDestinationFile, hwFlhSyncTable=hwFlhSyncTable, hwFlhOperStatus=hwFlhOperStatus, hwFlhSyncRowStatus=hwFlhSyncRowStatus, hwFlhChipGroup=hwFlhChipGroup, hwFlhOperProtocol=hwFlhOperProtocol, hwFlhDescr=hwFlhDescr, hwStorageIndex=hwStorageIndex, hwFlhFileSize=hwFlhFileSize, hwStorageSpaceFree=hwStorageSpaceFree, hwFlhChipTable=hwFlhChipTable, PYSNMP_MODULE_ID=hwFlash, hwFlhSize=hwFlhSize, hwFlhPartitionEntry=hwFlhPartitionEntry, hwFlhFileChecksum=hwFlhFileChecksum, hwFlhPartFileNameLen=hwFlhPartFileNameLen, hwStorageTable=hwStorageTable, huaweiFlhOpTable=huaweiFlhOpTable, hwFlhOperErrorReason=hwFlhOperErrorReason, hwFlhOperServerIpv6Address=hwFlhOperServerIpv6Address, hwFlash=hwFlash, hwFlhPartIndex=hwFlhPartIndex, hwFlhSyncFailNotification=hwFlhSyncFailNotification, hwFlhOperDestinationFile=hwFlhOperDestinationFile, hwFlhPartitionGroup=hwFlhPartitionGroup, hwFlhSyncEntry=hwFlhSyncEntry, hwFlhChipWriteTimes=hwFlhChipWriteTimes, hwFlashEntry=hwFlashEntry, hwFlhOperVpnInstanceName=hwFlhOperVpnInstanceName, hwFlhOperSourceFile=hwFlhOperSourceFile, hwFlhChipNum=hwFlhChipNum, hwFlhOperSourceInterface=hwFlhOperSourceInterface, hwFlhSyncDestinationPath=hwFlhSyncDestinationPath, hwFlashPartitions=hwFlashPartitions, hwFlhOperProgress=hwFlhOperProgress, huaweiStorageDevice=huaweiStorageDevice, huaweiFlashDevice=huaweiFlashDevice, hwFlhRemovable=hwFlhRemovable, hwFlhPartitionNum=hwFlhPartitionNum, HwFlashOperationStatus=HwFlashOperationStatus, hwFlhOperMemSize=hwFlhOperMemSize, hwFlhPartFirstChip=hwFlhPartFirstChip, hwFlhChipEraseTimes=hwFlhChipEraseTimes, hwFlhSyncType=hwFlhSyncType, hwFlhPartName=hwFlhPartName, hwFlhOperNotification=hwFlhOperNotification, hwStorageSpace=hwStorageSpace, hwFlhFileStatus=hwFlhFileStatus, hwStorageEntry=hwStorageEntry, huaweiFlashNotification=huaweiFlashNotification, hwFlhPartRequireErase=hwFlhPartRequireErase, hwStorageType=hwStorageType, hwFlhGroup=hwFlhGroup, hwFlhPartUpgradeMode=hwFlhPartUpgradeMode, huaweiFlhFileTable=huaweiFlhFileTable, hwFlhOperationGroup=hwFlhOperationGroup, hwFlashChips=hwFlashChips, hwFlhOperIndex=hwFlhOperIndex, huaweiFlhOpEntry=huaweiFlhOpEntry, hwFlhChipSerialNo=hwFlhChipSerialNo, hwFlhSyncSourceFile=hwFlhSyncSourceFile, hwFlhFileIndex=hwFlhFileIndex, hwFlhOperServerUser=hwFlhOperServerUser, hwFlhOperServerPort=hwFlhOperServerPort, hwFlhSyncRange=hwFlhSyncRange, hwFlhMaxPartitions=hwFlhMaxPartitions, hwFlhOperServerAddress=hwFlhOperServerAddress, hwFlhFileName=hwFlhFileName, hwFlhPartitionTable=hwFlhPartitionTable, hwFlhNotificationGroup=hwFlhNotificationGroup, hwStorageName=hwStorageName, hwFlhPos=hwFlhPos, hwStorageGroup=hwStorageGroup, hwFlhMIBCompliances=hwFlhMIBCompliances, huaweiFlashMIBConformance=huaweiFlashMIBConformance, hwFlhSupportNum=hwFlhSupportNum, HwFlashPartitionUpgradeMode=HwFlashPartitionUpgradeMode, hwFlhPartStatus=hwFlhPartStatus, hwFlhOperEndNotification=hwFlhOperEndNotification, hwFlhChipDescr=hwFlhChipDescr, hwFlhMinPartitionSize=hwFlhMinPartitionSize, hwFlhChipWriteTimesLimit=hwFlhChipWriteTimesLimit, hwFlhOperType=hwFlhOperType, hwFlhOperRowStatus=hwFlhOperRowStatus, hwFlhPartSpaceFree=hwFlhPartSpaceFree, huaweiFlashOperate=huaweiFlashOperate, hwFlhSyncSourcePath=hwFlhSyncSourcePath, hwFlhFileTime=hwFlhFileTime, hwFlhPartitionBool=hwFlhPartitionBool, hwFlhOperPassword=hwFlhOperPassword, hwStorageDescr=hwStorageDescr, hwFlashTable=hwFlashTable, huaweiFlhFileEntry=huaweiFlhFileEntry, hwFlhOperTransferProgress=hwFlhOperTransferProgress, hwFlhPartChecksumMethod=hwFlhPartChecksumMethod, huaweiFlashMIBGroups=huaweiFlashMIBGroups, HwFlashPartitionStatus=HwFlashPartitionStatus, hwFlhIndex=hwFlhIndex, hwFlhPartFileNum=hwFlhPartFileNum, hwFlhChipEntry=hwFlhChipEntry, hwFlhPartLastChip=hwFlhPartLastChip, hwFlhPartSpace=hwFlhPartSpace, hwFlhChipID=hwFlhChipID, hwFlhSyncIndex=hwFlhSyncIndex, hwFlhSyncSuccessNotification=hwFlhSyncSuccessNotification, hwFlhChipEraseTimesLimit=hwFlhChipEraseTimesLimit, hwFlhFiles=hwFlhFiles, hwFlhOperSourceAddress=hwFlhOperSourceAddress, hwFlhName=hwFlhName, hwFlhMIBCompliance=hwFlhMIBCompliance, huaweiFlashManMIBObjects=huaweiFlashManMIBObjects)

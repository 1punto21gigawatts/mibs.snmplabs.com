#
# PySNMP MIB module SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:09:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, NotificationType, Counter64, Counter32, MibIdentifier, Gauge32, Integer32, ObjectIdentity, Bits, TimeTicks, ModuleIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "NotificationType", "Counter64", "Counter32", "MibIdentifier", "Gauge32", "Integer32", "ObjectIdentity", "Bits", "TimeTicks", "ModuleIdentity", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sonomaATM, = mibBuilder.importSymbols("SONOMASYSTEMS-SONOMA-MIB", "sonomaATM")
sonomaGenericATMGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1))
atmGenericPhysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1))
atmGenericVclGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2))
atmGenericLpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3))
atmCesGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4))
atmAsiPhysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5))
atmAsmPhysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6))
atmGenPhysTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1), )
if mibBuilder.loadTexts: atmGenPhysTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysTable.setDescription("A table of physical layer status and parameter information for the UNI's physical interface")
atmGenPhysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenPhysIndex"))
if mibBuilder.loadTexts: atmGenPhysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysEntry.setDescription('A entry in the table, containing information about the physical layer of a UNI interface')
atmGenPhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysIndex.setDescription('The physical interface instance.')
atmGenPhysAal5Mtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysAal5Mtu.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysAal5Mtu.setDescription('The AAL5 MTU capacity for the physical interface, assigned by PM.')
atmGenPhysAal5CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysAal5CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysAal5CrcErrors.setDescription('The total number of AAL5 CPCS PDUs received with CRC-32 errors at the interface associated with an AAL5 entity.')
atmGenPhysAal5OverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysAal5OverSizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysAal5OverSizedSDUs.setDescription('The total number of AAL5 CPCS PDUs discarded at the interface associated with an AAL5 entity because the AAL5 SDUs were too large.')
atmGenPhysAal5DiscardPDU = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysAal5DiscardPDU.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysAal5DiscardPDU.setDescription('The total number of AAL5 CPCS PDUs discarded at the interface associated with an AAL5 entity because no receive free buffers were available. Only available with TCOP atm card.')
atmGenPhysHECErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysHECErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysHECErrors.setDescription('The total number ATM cells dropped out to HEC errors. Only available with TCOP atm card.')
atmGenPhysUnknownProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysUnknownProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysUnknownProtocols.setDescription('The total number cells received with an unknown header. Only available with TCOP atm card.')
atmGenPhysCellsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysCellsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysCellsReceived.setDescription('The total number ATM cells received with no errors. Only available with TCOP atm card.')
atmGenPhysCellsTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysCellsTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysCellsTransmitted.setDescription('The total number ATM cells actually transmitted. Only available with TCOP atm card.')
atmGenPhysRxBufStarvation = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysRxBufStarvation.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysRxBufStarvation.setDescription('The total number of occurrences when no Rx free buffer is available at the interface associated with an AAL5 entity.')
atmGenPhysRxFreeze = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysRxFreeze.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysRxFreeze.setDescription('The total number of occurrences when Rx completion ring overflows at the interface associated with an AAL5 entity.')
atmGenPhysTxFreeze = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenPhysTxFreeze.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenPhysTxFreeze.setDescription('The total number of occurrences when Tx completion ring overflows at the interface associated with an AAL5 entity.')
atmGenRateTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2), )
if mibBuilder.loadTexts: atmGenRateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateTable.setDescription('A table of ATM layer configuration for the ATM-DS3/E3/OC3c interface. Only used by earlier version of software.')
atmGenRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenRatePhysIndex"))
if mibBuilder.loadTexts: atmGenRateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateEntry.setDescription('A entry in the table, containing information about the rate queues on this physical interface.')
atmGenRatePhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenRatePhysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRatePhysIndex.setDescription('The ATM interface index, for this table the value of this object corresponds to the physical port instance.')
atmGenRateQueOne = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueOne.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueOne.setDescription('The value of this object can be set to any value in the range 0 to 30720 for E3, the range 0 to 36864 for DS3, and the range 0 to 135150 for OC3. The combination of all the values of all the rate queue objects must equal 30720 for E3, 36864 for DS3, and 135150 for OC3. Thus, if this object has a value of 36864 for DS3, then the values of the rest of the objects cannot be set to anything other than 0. The value of any rate queue object is rounded down to the nearest multiple of 10.')
atmGenRateQueTwo = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueTwo.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueTwo.setDescription('The ATM layer rate queue number two bandwidth.')
atmGenRateQueThree = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueThree.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueThree.setDescription('The ATM layer rate queue number three bandwidth.')
atmGenRateQueFour = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueFour.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueFour.setDescription('The ATM layer rate queue number four bandwidth.')
atmGenRateQueFive = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueFive.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueFive.setDescription('The ATM layer rate queue number five bandwidth.')
atmGenRateQueSix = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueSix.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueSix.setDescription('The ATM layer rate queue number six bandwidth.')
atmGenRateQueSeven = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueSeven.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueSeven.setDescription('The ATM layer rate queue number seven bandwidth.')
atmGenRateQueEight = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueEight.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueEight.setDescription('The ATM layer rate queue number eight bandwidth.')
atmGenRateQTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 3), )
if mibBuilder.loadTexts: atmGenRateQTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQTable.setDescription('A table of ATM layer configuration for the ATM-DS3/E3/OC3c interface. Not used with TCOP atm card.')
atmGenRateQEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 3, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenRateQPhysIndex"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenRateQNumber"))
if mibBuilder.loadTexts: atmGenRateQEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQEntry.setDescription('A entry in the table, containing information about the rate queues on this physical interface.')
atmGenRateQPhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenRateQPhysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQPhysIndex.setDescription('The ATM interface index, for this table the value of this object corresponds to the physical port instance.')
atmGenRateQNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQNumber.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQNumber.setDescription('The ATM layer rate queue number.')
atmGenRateQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 135150))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenRateQueue.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenRateQueue.setDescription('The value of this object can be set to any value in the range 0 to 30720 for E3, the range 0 to 36864 for DS3, and the range 0 to 135150 for OC3. The combination of all the values of all the rate queue objects must equal 30720 for E3, 36864 for DS3, and 135150 for OC3. Thus, if this object has a value of 36864 for DS3, then the values of the rest of the objects cannot be set to anything other than 0. The value of any rate queue object is rounded down to the nearest multiple of 10.')
atmGenVclTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1), )
if mibBuilder.loadTexts: atmGenVclTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTable.setDescription('The Virtual Channel Link (VCL) table. A bi-directional VCL is modeled as one entry in this table.')
atmGenVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclIfIndex"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclVpi"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclVci"))
if mibBuilder.loadTexts: atmGenVclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclEntry.setDescription('An entry in the VCL table. This entry is used to model a bi-directional VCL.')
atmGenVclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclIfIndex.setDescription('The physical interface instance.')
atmGenVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclVpi.setDescription('The VPI value of the VCL, 0 - 255.')
atmGenVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclVci.setDescription('The VCI value of the VCL. Minimum value of 32 when VPI is 0 and minimum value of 1 for all other VPI. Maximum value of 1023 for 1561 adapter and maximum value of 4095 for 1575 tcop adapter.')
atmGenVclRateQ = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclRateQ.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclRateQ.setDescription('The Rate Queue used by this virtual circuit.')
atmGenVclAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("create", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclAction.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclAction.setDescription("This object is used to create or delete a row in this table. A set request to add a row to this table need only contain this object's value in the PDU. The row created will be defined by the instance passed with the object identifier. Thus, to add the following entry: Logical Port 257, VP 1, VC 36, send a set request with a var bind containing atmGenVclAction.257.1.36 as the object identifier component and 5 as the value of the value component.")
atmGenVclTmTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2), )
if mibBuilder.loadTexts: atmGenVclTmTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmTable.setDescription('The Virtual Channel Link (VCL) table. A bi-directional VCL is modeled as one entry in this table.')
atmGenVclTmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclTmIfIndex"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclTmVpi"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclTmVci"))
if mibBuilder.loadTexts: atmGenVclTmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmEntry.setDescription('An entry in the VCL table. This entry is used to model a bi-directional VCL.')
atmGenVclTmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclTmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmIfIndex.setDescription('The physical interface instance.')
atmGenVclTmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclTmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmVpi.setDescription('The VPI value of the VCL, 0 - 255.')
atmGenVclTmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclTmVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmVci.setDescription('The VCI value of the VCL. Minimum value of 32 when VPI is 0 and minimum value of 1 for all other VPI. Maximum value of 1023 for 1561 adapter and maximum value of 4095 for 1575 tcop adapter.')
atmGenVclTmPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclTmPCR.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmPCR.setDescription('Specify Peak Cell Rate.')
atmGenVclTmSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclTmSCR.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmSCR.setDescription('Specify Sustainable Cell Rate.')
atmGenVclTmMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclTmMBS.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmMBS.setDescription('Specify Maximum Burst Size.')
atmGenVclTmAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("create", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenVclTmAction.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclTmAction.setDescription("This object is used to create or delete a row in this table. A set request to add a row to this table need only contain this object's value in the PDU. The row created will be defined by the instance passed with the object identifier. Thus, to add the following entry: Logical Port 257, VP 1, VC 36, send a set request with a var bind containing atmGenVclAction.257.1.36 as the object identifier component and 5 as the value of the value if you want to create AAL5 VC. ")
atmGenVclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3), )
if mibBuilder.loadTexts: atmGenVclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsTable.setDescription('The Virtual Channel Link (VCL) table. A bi-directional VCL is modeled as one entry in this table.')
atmGenVclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclStatsIfIndex"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclStatsVpi"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenVclStatsVci"))
if mibBuilder.loadTexts: atmGenVclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsEntry.setDescription('An entry in the VCL table.')
atmGenVclStatsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsIfIndex.setDescription('The physical interface instance.')
atmGenVclStatsVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsVpi.setDescription('The VPI value of the VCL, 0 - 255.')
atmGenVclStatsVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(35, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsVci.setDescription('The VCI value of the VCL, 35 - 1023.')
atmGenVclStatsCellsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsCellsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsCellsReceived.setDescription('The total number of cells received by this virtual circuit.')
atmGenVclStatsCellsTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsCellsTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsCellsTransmitted.setDescription('The total number of cells transmitted by this virtual circuit.')
atmGenVclStatsOamAisRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamAisRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamAisRcvCells.setDescription('The total number of AIS OAM cells received by this virtual circuit.')
atmGenVclStatsOamAisXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamAisXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamAisXmtCells.setDescription('The total number of AIS OAM cells transmitted by this virtual circuit.')
atmGenVclStatsOamRdiRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamRdiRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamRdiRcvCells.setDescription('The total number of RDI OAM cells received by this virtual circuit.')
atmGenVclStatsOamRdiXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamRdiXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamRdiXmtCells.setDescription('The total number of RDI OAM cells transmitted by this virtual circuit.')
atmGenVclStatsOamLoopbackRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamLoopbackRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamLoopbackRcvCells.setDescription('The total number of Loopback OAM cells received by this virtual circuit.')
atmGenVclStatsOamLoopbackXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenVclStatsOamLoopbackXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenVclStatsOamLoopbackXmtCells.setDescription('The total number of Loopback OAM cells transmitted by this virtual circuit.')
atmGenLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1), )
if mibBuilder.loadTexts: atmGenLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLogicalPortTable.setDescription("A table of physical layer status and parameter information for the UNI's physical interface")
atmGenLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmGenLpIfIndex"))
if mibBuilder.loadTexts: atmGenLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLogicalPortEntry.setDescription('A entry in the table, containing information about the physical layer of a UNI interface')
atmGenLpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(257, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenLpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpIfIndex.setDescription('The logical port index.')
atmGenLpPhysIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenLpPhysIf.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpPhysIf.setDescription('The physical interface associated with this logical port.')
atmGenLpLoopTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpLoopTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpLoopTime.setDescription('The time (in hundredths of a second) to drop a receive frame.')
atmGenLpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("ethernet", 7), ("ethernetII", 8), ("ethernet8023", 9), ("tokenRing", 10), ("fddi", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenLpProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpProtocol.setDescription("Network layer for the VC's attached to this LP")
atmGenLpAal5EncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rfc1483-vc", 1), ("rfc1483-llc", 2))).clone('rfc1483-llc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpAal5EncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpAal5EncapsType.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The type of data encapsulation used over the AAL5 SSCS layer. The definitions reference RFC 1483 Multiprotocol Encapsulation over ATM AAL5 and to the ATM Forum LAN Emulation specification.')
atmGenLpAal5Mtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpAal5Mtu.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpAal5Mtu.setDescription('The PDU size for the AAL5 CPCS layer that can be processed by the AAL5 entity, 64 - 16K.')
atmGenLpAal5RateQ = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenLpAal5RateQ.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpAal5RateQ.setDescription('The rate queue used by this virtual circuit.')
atmGenLpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenLpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpAdminStatus.setDescription('The logical port status, just for reference. The Port Manager has control of the status.')
atmGenLpLoopThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 9), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpLoopThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpLoopThreshold.setDescription('The number of frames receives before a snmp trap will be sent.')
atmGenLpLoopTrapTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 10), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpLoopTrapTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpLoopTrapTime.setDescription('The time (in seconds) between checks to send out snmp trap.')
atmGenLpOamGeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 3, 1, 1, 11), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenLpOamGeneration.setStatus('mandatory')
if mibBuilder.loadTexts: atmGenLpOamGeneration.setDescription('Enable or Disable the generation of OAM cells.')
cesConfTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1), )
if mibBuilder.loadTexts: cesConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesConfTable.setDescription('The CES configuration table used to manage interworking between CBR interfaces or channels and ATM Virtual Channel Links (VCLs). The reverse mapping is shown in the cesMappingTable.')
cesConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAtmPhysPort"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAtmVpi"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAtmVci"))
if mibBuilder.loadTexts: cesConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesConfEntry.setDescription('An entry in the CES configuration table. There is one entry in the table per ATM Port/VPI/VCI.')
cesAtmPhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAtmPhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: cesAtmPhysPort.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM Port interface mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The distinguished value zero indicates that no ATM interface has been specified.")
cesAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAtmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: cesAtmVpi.setDescription('The value of this object is equal to the VPI used by the ATM VCL mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The value is not relevant if no ATM interface has been specified (i.e., cesAtmIndex is set to zero).')
cesAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAtmVci.setStatus('mandatory')
if mibBuilder.loadTexts: cesAtmVci.setDescription('The value of this object is equal to the VCI used by the ATM VCL mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The distinguished value zero indicates that no ATM VCL has been specified.')
cesCbrService = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unstructured", 1), ("structured", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCbrService.setStatus('mandatory')
if mibBuilder.loadTexts: cesCbrService.setDescription('Define if DSx/Ex service is structured or unstructured. A structured(2) interface is some nx64kbKbps. An unstructured (1) interface is 1.544Mbps, 2.048Mbps, 6.312Mbps, 44.736 Mbps, or 34.368 Mbps. unstructured(1) passes all bits through the ATM network. strucutured(2) passes data bits through the ATM network, and may also pass signalling bits At this time, only unstructured mode is defined for the 44.736 Mbps and 34.368 Mbps services.')
cesCbrClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("synchronous", 1), ("srts-master", 2), ("adaptive", 3), ("srts-slave", 4))).clone('synchronous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCbrClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: cesCbrClockMode.setDescription('Define if DSx/Ex service clocking mode. This maps into transmit clock source of CBR interface. For structured modes this value, if present, must be set to synchronous(1).')
cesCas = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("without", 1), ("with", 2))).clone('without')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCas.setStatus('mandatory')
if mibBuilder.loadTexts: cesCas.setDescription('This parameter selects which AAL1 Format should be used: Without does not carry CAS bits, and uses a single 125 usec frame. With carris CAS bits in a multiframe structure for E1, DS1 SF, or DS1 ESF. This applies to structured interfaces only. Default is without (1). For unstructured interfaces this value, if present, must be set to the default of without (1).')
cesPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: cesPartialFill.setDescription('If partial cell fill is used, the number of user octets per cell must be set with this parameter. Setting this parameter to zero disables partial cell fill, and causes all cells to be completely filled before they are sent.')
cesBufMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesBufMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufMaxSize.setDescription('Define maximum size in 10 microsecond increments of the reassembly buffer. Some implementations may want allow the maximum buffer size to be programmed to a size less than the physical limit to reduce the maximum delay through a circuit.')
cesCdvRxT = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCdvRxT.setStatus('mandatory')
if mibBuilder.loadTexts: cesCdvRxT.setDescription('The maximum cell arrival jitter in 10 usec increments that the reassembly process will tolerate in the cell stream without producing errors on the CBR service interface.')
cesCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535)).clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setDescription('The time in milliseconds for the cell loss integration period. If a cells are continuously lost for this period of time, cesCellLossStatus is set to loss (2). The default definition is 2500.')
cesConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("pvc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnType.setStatus('mandatory')
if mibBuilder.loadTexts: cesConnType.setDescription("The type of ATM connectivity between associated CES IWF's. Valid values are: other - none of the types specified below pvc - supporting connectivity is a permanent virtual connection activeSvc - attempt calls whenever none established passiveSvc - accept calls Only pvc is supported in this release.")
cesDynBw = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesDynBw.setStatus('mandatory')
if mibBuilder.loadTexts: cesDynBw.setDescription('The Sonoma Dynamic Bandwidth feature may be enabled or disabled.')
cesSigType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("fxo-loop", 2), ("fxs-loop", 3), ("fxo-ground", 4), ("fxs-ground", 5), ("e-and-m", 6), ("r2", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesSigType.setStatus('mandatory')
if mibBuilder.loadTexts: cesSigType.setDescription('This is the A/B signalling type for dynamic bandwidth Idle detection.')
cesConfAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("attach", 5), ("remove", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConfAction.setStatus('mandatory')
if mibBuilder.loadTexts: cesConfAction.setDescription('The value of this object indicates whether the entry, is to be attached or removed from the CES Configuration Table. A value of attach has the effect of adding an entry to this table. A value of remove has the effect of removing an entry from the table.')
cesStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3), )
if mibBuilder.loadTexts: cesStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesStatsTable.setDescription('The CES AAL1 statistical data table.')
cesStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesStatsAtmPhyPort"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesStatsAtmVpi"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesStatsAtmVci"))
if mibBuilder.loadTexts: cesStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesStatsEntry.setDescription('An entry in the CES AAL1 Stats table. There is one entry in this table corresponding to each entry in the cesConfTable.')
cesStatsAtmPhyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesStatsAtmPhyPort.setStatus('mandatory')
if mibBuilder.loadTexts: cesStatsAtmPhyPort.setDescription('The physical interface instance.')
cesStatsAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesStatsAtmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: cesStatsAtmVpi.setDescription('The VPI value of the VCL, 0 - 255.')
cesStatsAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(35, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesStatsAtmVci.setStatus('mandatory')
if mibBuilder.loadTexts: cesStatsAtmVci.setDescription('The VCI value of the VCL, 35 - 1023.')
cesReassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesReassCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesReassCells.setDescription('This count gives the number of cells played out to the CES Service Interface. It excludes cells that were discarded for any reason, including cells that were not used due to being declared misinserted, or discarded while the reassembler was waiting to achieve synchronization.')
cesHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cesHdrErrors.setDescription('The count of the number of AAL1 header errors detected, including those corrected. Header errors include correctable and uncorrectable CRC, plus bad parity.')
cesPointerReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPointerReframes.setStatus('mandatory')
if mibBuilder.loadTexts: cesPointerReframes.setDescription('This records the count of the number of events in which the AAL1 reassembler found that an SDT pointer is not where it is expected, and the pointer must be reacquired. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
cesPointerParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPointerParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cesPointerParityErrors.setDescription('This records the count of the number of events in which the AAL1 reassembler detects a parity check failure at the point where a structured data pointer is expected. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
cesAal1SeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAal1SeqErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cesAal1SeqErrors.setDescription("Number of times that the sequence number of an incoming AAL1 Type 1 SAR-PDU causes a transition from the 'sync' state to the 'out of sequence' state, as defined by ITU-T I.363.1.")
cesLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesLostCells.setDescription('Number of lost cells, as detected by the AAL1 sequence number processing, for example. This records the count of the number of cells detected as lost in the network prior to the destination CES IWF AAL1 layer processing.')
cesMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMisinsertedCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesMisinsertedCells.setDescription('Number of AAL1 sequence violations which the AAL Convergence sublayer interprets as a misinserted cell, as defined by ITU-T I.363.1.')
cesBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesBufUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufUnderflows.setDescription('Number of buffer underflows. This records the count of the number of times the CES reassembly buffer underflows. In the case of a continuous underflow caused by a loss of ATM cell flow, a single buffer underflow should be counted. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer), then either buffer underflow will cause this count to be incremented.')
cesBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufOverflows.setDescription('Number of buffer overflows. This records the count of the number of times the CES reassembly buffer overflows. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer, then either buffer overflow will cause this count to be incremented ')
cesCellLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoss", 1), ("loss", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCellLossStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cesCellLossStatus.setDescription('When cells are continuously lost for the number of milliseconds specified by cesCellLossIntegrationPeriod, the value is set to loss (2). When cells are no longer lost, the value is set to noLoss (1).')
cesAttachmentTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4), )
if mibBuilder.loadTexts: cesAttachmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentTable.setDescription('This table is used to attach a bundle to a physical port and DS0 channel.')
cesAttachmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAttachmentPhysPort"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAttachmentBundle"), (0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "cesAttachmentChan"))
if mibBuilder.loadTexts: cesAttachmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentEntry.setDescription('This is an entry in the attach bundle to physical port and DS0 channel table. An entry in this table indicates if the bundle is attached to the physical port and what DS0 channel on the physical port the bundle is attached to, if applicable. To set an entry in this table, ALL the objects in the entry must be present in a single SET PDU.')
cesAttachmentPhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAttachmentPhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentPhysPort.setDescription('The physical port number of the port to which the bundle is being attached.')
cesAttachmentBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 1536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAttachmentBundle.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentBundle.setDescription('The bundle number. The range of settable values for this object is 1025 to 1536.')
cesAttachmentChan = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesAttachmentChan.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentChan.setDescription('The value of this object indicates the DS0 channel to which the bundle, identified by cesAttachmentBundle, is attached or is to be attached.')
cesAttachmentAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("attach", 5), ("remove", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesAttachmentAction.setStatus('mandatory')
if mibBuilder.loadTexts: cesAttachmentAction.setDescription('The value of this object indicates whether the bundle, is to be attached or removed from the physical port and DS0 channel. A value of attach has the effect of adding an entry to this table, and either to create the bundle, or to attach it to another physical port. A value of remove has the effect of removing an entry from the table and if the DS0 channel is the last one attached to the bundle then the remove action has the effect of deleting the bundle also.')
atmAsiConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1))
atmAsiStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2))
atmAsiConfPhyTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1), )
if mibBuilder.loadTexts: atmAsiConfPhyTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfPhyTable.setDescription('A table of physical layer configuration for the ASI interface')
atmAsiConfPhyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmAsiConfPhysIndex"))
if mibBuilder.loadTexts: atmAsiConfPhyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfPhyEntry.setDescription('A entry in the table, containing information about the physical layer of an ASI interface')
atmAsiConfPhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiConfPhysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfPhysIndex.setDescription('The physical interface index.')
atmAsiConfLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("esf", 2), ("d4", 3), ("e1", 4), ("e1-crc", 5), ("e1-cas", 6), ("e1-crc-cas", 7))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfLineType.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfLineType.setDescription('Configure the line type.')
atmAsiConfLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("b8zs", 2), ("hdb3", 3), ("zbtsi", 4), ("ami", 5))).clone('b8zs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfLineCoding.setDescription('Configure the line coding.')
atmAsiConfTxClkSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("line", 2), ("through", 3))).clone('line')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfTxClkSelect.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfTxClkSelect.setDescription('This parameter configures the source of the Tx clock.')
atmAsiConfSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("robbed-bit", 2), ("bit-oriented", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfSignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfSignalMode.setDescription('This parameter configures the signal mode.')
atmAsiConfLIUType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t1-long", 1), ("itu-120", 2), ("itu-75", 3), ("dsx1-short", 4))).clone('dsx1-short')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfLIUType.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfLIUType.setDescription('This parameter configures the Line Interface Unit type.')
atmAsiConfLBOType = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 8, 9, 10, 11))).clone(namedValues=NamedValues(("short-133", 1), ("short-266", 2), ("short-399", 3), ("short-533", 4), ("short-655", 5), ("long-0", 8), ("long-75", 9), ("long-150", 10), ("long-225", 11))).clone('short-133')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfLBOType.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfLBOType.setDescription('This parameter configures the Line Build Out.')
atmAsiConfIdlePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(127)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfIdlePattern.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfIdlePattern.setDescription('This parameter configures the idle pattern for trunk conditioning.')
atmAsiConfLoopbackMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("internal", 2), ("external", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfLoopbackMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfLoopbackMode.setDescription('This parameter configures the loopback mode.')
atmAsiConfStopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("immediate", 1), ("on-idle", 2))).clone('immediate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfStopMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfStopMode.setDescription('This parameter configures the mode used for stop commands.')
atmAsiConfRecoveredClkSource = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("fourth-port", 1), ("third-port", 2), ("second-port", 3), ("first-port", 4), ("phy-port", 5))).clone('fourth-port')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiConfRecoveredClkSource.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiConfRecoveredClkSource.setDescription('This parameter configures the source of the recovered clock used for through timing.')
atmAsiDebugAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiDebugAddr.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiDebugAddr.setDescription('PCI Phy address for DS1 port register.')
atmAsiDebugReadValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiDebugReadValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiDebugReadValue.setDescription('Value read from DS1 port register.')
atmAsiDebugWriteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiDebugWriteValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiDebugWriteValue.setDescription('Value written to DS1 port register.')
atmAsiDebugRead = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("read", 1), ("write", 2))).clone('read')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiDebugRead.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiDebugRead.setDescription('Read or Write of DS1 port register (TRUE = READ).')
atmAsiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1), )
if mibBuilder.loadTexts: atmAsiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsTable.setDescription('A table of physical layer statistics information for the ASI interface')
atmAsiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmAsiStatsPhysIndex"))
if mibBuilder.loadTexts: atmAsiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsEntry.setDescription('A entry in the table, containing information about the physical layer of an ASI interface')
atmAsiStatsPhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsPhysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsPhysIndex.setDescription('The physical interface index.')
atmAsiStatsNoSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsNoSignals.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsNoSignals.setDescription('No signal error counter.')
atmAsiStatsAISDetects = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsAISDetects.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsAISDetects.setDescription('AIS Detect counter.')
atmAsiStatsYelAlarmCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsYelAlarmCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsYelAlarmCount.setDescription('A count of the number of Yellow Alarms.')
atmAsiStatsLCVErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsLCVErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsLCVErrors.setDescription('LCV (Line Code Violation) error counter.')
atmAsiStatsPCVErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsPCVErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsPCVErrors.setDescription('PCV (Path Code Violation) error counter.')
atmAsiStatsMOSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsMOSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsMOSErrors.setDescription('Multiframe out of sync error counter.')
atmAsiStatsSyncLossCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsSyncLossCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsSyncLossCount.setDescription('Sync Loss counter.')
atmAsiStatsHECErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsHECErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsHECErrors.setDescription('HEC error counter.')
atmAsiStatsSignalLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsSignalLoss.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsSignalLoss.setDescription('Signal loss indication.')
atmAsiStatsAISDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsAISDetect.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsAISDetect.setDescription('AIS indication.')
atmAsiStatsYellowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsYellowAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsYellowAlarm.setDescription('Yellow Alarm indication.')
atmAsiStatsSyncLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsSyncLoss.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsSyncLoss.setDescription('Loss of sync indication.')
atmAsiStatsTxClockLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsiStatsTxClockLoss.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsTxClockLoss.setDescription('Loss of transmit clock indication.')
atmAsiStatsClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 5, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsiStatsClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsiStatsClearCounters.setDescription('Clear all counters in this group ONLY.')
atmAsmPhyConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1))
atmAsmPhyConfTable = MibTable((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1, 1), )
if mibBuilder.loadTexts: atmAsmPhyConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsmPhyConfTable.setDescription('A table of physical layer configuration for the ASM interfaces.')
atmAsmPhyConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1, 1, 1), ).setIndexNames((0, "SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", "atmAsmPhyConfIndex"))
if mibBuilder.loadTexts: atmAsmPhyConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsmPhyConfEntry.setDescription('A entry in the table, containing information about the physical layer of an ASM interfaces.')
atmAsmPhyConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsmPhyConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsmPhyConfIndex.setDescription('The physical interface index.')
atmAsmPhyConfAdminLineUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("ces-udt", 1), ("ces-sdt", 2), ("uni", 4), ("ima", 5))).clone('uni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmAsmPhyConfAdminLineUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsmPhyConfAdminLineUsage.setDescription("The desired physical port's line usage. For some port types, the desired line usage will become effective after the system is rebooted.")
atmAsmPhyConfOperLineUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 2926, 25, 7, 1, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("ces-udt", 1), ("ces-sdt", 2), ("uni", 4), ("ima", 5))).clone('uni')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAsmPhyConfOperLineUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmAsmPhyConfOperLineUsage.setDescription("The physical port's current line usage.")
mibBuilder.exportSymbols("SONOMASYSTEMS-SONOMA-ATM-GENERIC-MIB", atmAsiStatsSignalLoss=atmAsiStatsSignalLoss, atmGenPhysUnknownProtocols=atmGenPhysUnknownProtocols, atmAsiStatsYellowAlarm=atmAsiStatsYellowAlarm, atmGenVclTmVpi=atmGenVclTmVpi, atmGenVclStatsVci=atmGenVclStatsVci, atmGenLogicalPortEntry=atmGenLogicalPortEntry, atmGenLpAal5Mtu=atmGenLpAal5Mtu, atmGenLpProtocol=atmGenLpProtocol, atmGenVclTmAction=atmGenVclTmAction, cesStatsAtmVpi=cesStatsAtmVpi, atmAsiConfStopMode=atmAsiConfStopMode, atmGenRateQEntry=atmGenRateQEntry, atmGenVclTable=atmGenVclTable, atmGenVclStatsEntry=atmGenVclStatsEntry, atmGenRateQueThree=atmGenRateQueThree, atmGenVclStatsTable=atmGenVclStatsTable, atmGenVclTmVci=atmGenVclTmVci, atmAsiConfGroup=atmAsiConfGroup, atmGenVclTmEntry=atmGenVclTmEntry, atmGenLpIfIndex=atmGenLpIfIndex, cesStatsAtmPhyPort=cesStatsAtmPhyPort, atmAsmPhyConfEntry=atmAsmPhyConfEntry, sonomaGenericATMGroup=sonomaGenericATMGroup, atmGenVclIfIndex=atmGenVclIfIndex, atmGenVclStatsCellsReceived=atmGenVclStatsCellsReceived, cesMisinsertedCells=cesMisinsertedCells, cesAttachmentTable=cesAttachmentTable, atmGenVclStatsOamLoopbackXmtCells=atmGenVclStatsOamLoopbackXmtCells, atmGenRateQPhysIndex=atmGenRateQPhysIndex, atmAsmPhysGroup=atmAsmPhysGroup, cesLostCells=cesLostCells, atmAsiStatsAISDetects=atmAsiStatsAISDetects, atmAsmPhyConfTable=atmAsmPhyConfTable, atmAsiConfPhyEntry=atmAsiConfPhyEntry, atmGenPhysAal5CrcErrors=atmGenPhysAal5CrcErrors, atmGenRateQueTwo=atmGenRateQueTwo, atmGenVclRateQ=atmGenVclRateQ, cesCbrService=cesCbrService, atmGenPhysAal5DiscardPDU=atmGenPhysAal5DiscardPDU, atmAsmPhyConfAdminLineUsage=atmAsmPhyConfAdminLineUsage, atmGenRateQueSeven=atmGenRateQueSeven, atmAsiConfIdlePattern=atmAsiConfIdlePattern, atmAsmPhyConfIndex=atmAsmPhyConfIndex, cesCbrClockMode=cesCbrClockMode, cesReassCells=cesReassCells, atmAsiConfTxClkSelect=atmAsiConfTxClkSelect, atmGenVclStatsVpi=atmGenVclStatsVpi, atmGenLpPhysIf=atmGenLpPhysIf, cesCellLossStatus=cesCellLossStatus, atmAsiConfLineType=atmAsiConfLineType, atmGenVclStatsOamLoopbackRcvCells=atmGenVclStatsOamLoopbackRcvCells, cesPointerReframes=cesPointerReframes, cesAttachmentAction=cesAttachmentAction, atmAsiStatsEntry=atmAsiStatsEntry, atmAsiStatsYelAlarmCount=atmAsiStatsYelAlarmCount, atmAsmPhyConfOperLineUsage=atmAsmPhyConfOperLineUsage, atmAsiStatsTxClockLoss=atmAsiStatsTxClockLoss, atmAsiDebugWriteValue=atmAsiDebugWriteValue, atmGenPhysRxBufStarvation=atmGenPhysRxBufStarvation, atmGenRateQueEight=atmGenRateQueEight, cesAttachmentPhysPort=cesAttachmentPhysPort, atmGenPhysCellsReceived=atmGenPhysCellsReceived, atmGenRateQueue=atmGenRateQueue, cesHdrErrors=cesHdrErrors, cesConfEntry=cesConfEntry, atmAsiStatsGroup=atmAsiStatsGroup, atmAsiConfPhysIndex=atmAsiConfPhysIndex, atmGenLpOamGeneration=atmGenLpOamGeneration, atmAsiStatsMOSErrors=atmAsiStatsMOSErrors, atmGenRateTable=atmGenRateTable, atmAsiConfLineCoding=atmAsiConfLineCoding, atmAsiDebugReadValue=atmAsiDebugReadValue, atmAsiConfRecoveredClkSource=atmAsiConfRecoveredClkSource, cesBufUnderflows=cesBufUnderflows, atmGenRateQueFive=atmGenRateQueFive, atmAsiStatsAISDetect=atmAsiStatsAISDetect, cesCdvRxT=cesCdvRxT, atmAsiPhysGroup=atmAsiPhysGroup, atmGenLpLoopTrapTime=atmGenLpLoopTrapTime, atmGenLogicalPortTable=atmGenLogicalPortTable, atmGenPhysRxFreeze=atmGenPhysRxFreeze, cesAtmVpi=cesAtmVpi, cesBufMaxSize=cesBufMaxSize, cesStatsEntry=cesStatsEntry, atmGenPhysAal5Mtu=atmGenPhysAal5Mtu, atmAsiDebugAddr=atmAsiDebugAddr, atmGenPhysTable=atmGenPhysTable, atmGenPhysTxFreeze=atmGenPhysTxFreeze, atmGenVclEntry=atmGenVclEntry, atmAsiStatsNoSignals=atmAsiStatsNoSignals, atmGenVclTmTable=atmGenVclTmTable, cesConfAction=cesConfAction, atmAsiStatsPhysIndex=atmAsiStatsPhysIndex, atmGenRateQueSix=atmGenRateQueSix, atmGenericVclGroup=atmGenericVclGroup, atmAsiStatsHECErrors=atmAsiStatsHECErrors, cesAal1SeqErrors=cesAal1SeqErrors, atmGenVclStatsCellsTransmitted=atmGenVclStatsCellsTransmitted, cesAttachmentEntry=cesAttachmentEntry, atmGenRateEntry=atmGenRateEntry, atmGenVclVpi=atmGenVclVpi, atmGenLpAdminStatus=atmGenLpAdminStatus, atmGenericPhysGroup=atmGenericPhysGroup, cesConfTable=cesConfTable, cesCas=cesCas, cesAttachmentChan=cesAttachmentChan, atmGenRateQNumber=atmGenRateQNumber, cesBufOverflows=cesBufOverflows, atmAsmPhyConfGroup=atmAsmPhyConfGroup, atmAsiStatsClearCounters=atmAsiStatsClearCounters, atmAsiConfSignalMode=atmAsiConfSignalMode, cesStatsAtmVci=cesStatsAtmVci, atmGenRateQTable=atmGenRateQTable, atmGenVclVci=atmGenVclVci, atmCesGroup=atmCesGroup, atmGenericLpGroup=atmGenericLpGroup, cesConnType=cesConnType, atmGenVclTmMBS=atmGenVclTmMBS, atmAsiConfLIUType=atmAsiConfLIUType, atmGenLpLoopTime=atmGenLpLoopTime, atmAsiStatsLCVErrors=atmAsiStatsLCVErrors, atmAsiStatsTable=atmAsiStatsTable, atmGenVclAction=atmGenVclAction, atmAsiDebugRead=atmAsiDebugRead, cesAttachmentBundle=cesAttachmentBundle, cesCellLossIntegrationPeriod=cesCellLossIntegrationPeriod, atmGenRatePhysIndex=atmGenRatePhysIndex, cesPartialFill=cesPartialFill, atmGenPhysHECErrors=atmGenPhysHECErrors, atmGenVclTmPCR=atmGenVclTmPCR, atmAsiConfPhyTable=atmAsiConfPhyTable, atmGenVclStatsOamRdiXmtCells=atmGenVclStatsOamRdiXmtCells, atmGenRateQueFour=atmGenRateQueFour, atmGenPhysCellsTransmitted=atmGenPhysCellsTransmitted, cesAtmVci=cesAtmVci, cesStatsTable=cesStatsTable, atmAsiStatsSyncLossCount=atmAsiStatsSyncLossCount, cesSigType=cesSigType, atmAsiStatsSyncLoss=atmAsiStatsSyncLoss, atmGenLpLoopThreshold=atmGenLpLoopThreshold, atmGenVclStatsIfIndex=atmGenVclStatsIfIndex, atmGenVclStatsOamRdiRcvCells=atmGenVclStatsOamRdiRcvCells, atmGenVclStatsOamAisRcvCells=atmGenVclStatsOamAisRcvCells, atmGenLpAal5EncapsType=atmGenLpAal5EncapsType, atmAsiConfLBOType=atmAsiConfLBOType, atmGenPhysEntry=atmGenPhysEntry, atmGenPhysAal5OverSizedSDUs=atmGenPhysAal5OverSizedSDUs, atmGenRateQueOne=atmGenRateQueOne, cesPointerParityErrors=cesPointerParityErrors, atmAsiStatsPCVErrors=atmAsiStatsPCVErrors, cesAtmPhysPort=cesAtmPhysPort, atmGenLpAal5RateQ=atmGenLpAal5RateQ, atmAsiConfLoopbackMode=atmAsiConfLoopbackMode, atmGenVclStatsOamAisXmtCells=atmGenVclStatsOamAisXmtCells, cesDynBw=cesDynBw, atmGenPhysIndex=atmGenPhysIndex, atmGenVclTmSCR=atmGenVclTmSCR, atmGenVclTmIfIndex=atmGenVclTmIfIndex)

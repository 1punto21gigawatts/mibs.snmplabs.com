#
# PySNMP MIB module ATM-REROUTING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM-REROUTING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
atmVclVpi, atmVclVci, atmVplVpi = mibBuilder.importSymbols("ATM-MIB", "atmVclVpi", "atmVclVci", "atmVplVpi")
AtmAddr, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Gauge32, Counter64, IpAddress, Integer32, MibIdentifier, Unsigned32, NotificationType, enterprises, ObjectIdentity, TimeTicks, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Gauge32", "Counter64", "IpAddress", "Integer32", "MibIdentifier", "Unsigned32", "NotificationType", "enterprises", "ObjectIdentity", "TimeTicks", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter32")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
atmfreroutingMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1))
atmfreroutingMIB.setRevisions(('2001-04-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atmfreroutingMIB.setRevisionsDescriptions(('Initial version of the MIB module for managing the ATM Forum Domain-based rerouting for active point-to-point calls v1.0',))
if mibBuilder.loadTexts: atmfreroutingMIB.setLastUpdated('200104260000Z')
if mibBuilder.loadTexts: atmfreroutingMIB.setOrganization('The ATM Forum')
if mibBuilder.loadTexts: atmfreroutingMIB.setContactInfo('The ATM Forum Worldwide Headquarters 1000 Executive Parkway, Suite 220, St. Louis, MO 63141-6372 Tel: +1 314-205-0200 Fax: +1 314-576-7960 Email: info@atmforum.com')
if mibBuilder.loadTexts: atmfreroutingMIB.setDescription('The MIB module for managing the ATM Forum Domain-based rerouting for active point-to-point calls v1.0')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfSignalling = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9))
atmfRerouting = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3))
reroutingMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1))
class NetworkReroutingCapabilities(TextualConvention, Bits):
    reference = 'ATM Forum Domain-based rerouting 1.0'
    description = 'Indicates the network rerouting services available on a switching system.'
    status = 'current'
    namedValues = NamedValues(("dbrHardRerouting", 0), ("dbrAsymmetricSoftRerouting", 1), ("dbrSymmetricSoftRerouting", 2))

class HardReroutingServicesClass(TextualConvention, Integer32):
    reference = 'Domain-based rerouting 1.0'
    description = 'Indicates the service of the hard rerouting services class which is requested/activated for a call.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("dbrInterDomainHardRerouting", 2), ("dbrIntraDomainHardRerouting", 3))

class SoftReroutingServicesClass(TextualConvention, Integer32):
    reference = 'Domain-based rerouting 1.0'
    description = 'Indicates the service of the soft rerouting services class which is requested/activated for a call.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("dbrIntraDomainAsymmetricSoftRerouting", 2), ("dbrIntraDomainSymmetricSoftRerouting", 3))

class ReroutingNodeRole(TextualConvention, Integer32):
    reference = 'Domain-based rerouting 1.0'
    description = 'Describes whether the node is the source node or the destination node for a call.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("other", 1), ("sourceNode", 2), ("destinationNode", 3))

class ReroutingState(TextualConvention, Integer32):
    reference = 'Domain-based rerouting 1.0'
    description = 'Indicates the type of the rerouting operation in progress. The following mapping is done between the rerouting states of the FSM and the values of this object: FSM state ReroutingState --------- -------------- null -> idle reroutingIdle -> idle hardRerouteTriggered -> hardReroute hardRerouteProceeding -> hardReroute hardRerouteIndicated -> hardReroute hardRerouteInitiated -> hardReroute softRerouteTriggered -> softReroute softRerouteProceeding -> softReroute softRerouteInitiated -> softReroute awaitingSwitchover -> softReroute '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("idle", 1), ("hardReroute", 2), ("softReroute", 3))

class ExtendedReroutingState(TextualConvention, Integer32):
    reference = 'Domain-based rerouting 1.0'
    description = 'Describes the different states of the rerouting finite state machine. The states varies depending on the rerouting services activated for a call and on the role of the edge switch for the call (source vs destination node)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("null", 1), ("reroutingIdle", 2), ("hardRerouteTriggered", 3), ("hardRerouteProceeding", 4), ("hardRerouteIndicated", 5), ("hardRerouteInitiated", 6), ("softRerouteTriggered", 7), ("softRerouteProceeding", 8), ("softRerouteInitiated", 9), ("awaitingSwitchover", 10))

reroutingBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 1))
reroutingVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version1point0", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVersion.setReference('Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVersion.setStatus('current')
if mibBuilder.loadTexts: reroutingVersion.setDescription('The version of the ATM Forum rerouting specification that the software in this switching system is capable of executing.')
reroutingCapabilitiesSupported = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 1, 2), Bits().clone(namedValues=NamedValues(("dbrHardRerouting", 0), ("dbrAsymmetricSoftRerouting", 1), ("dbrSymmetricSoftRerouting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingCapabilitiesSupported.setReference('Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingCapabilitiesSupported.setStatus('current')
if mibBuilder.loadTexts: reroutingCapabilitiesSupported.setDescription('Indicates the rerouting mechanisms supported on this switching system')
reroutingHardReroutingTime = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reroutingHardReroutingTime.setReference('Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingHardReroutingTime.setStatus('current')
if mibBuilder.loadTexts: reroutingHardReroutingTime.setDescription('The timeout value in milliseconds for a hard rerouting operation to be completed. The hard rerouting timer is set to this value when a hard rerouting operation is triggered. A value of zero indicates that there is no timeout')
reroutingFilterTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2), )
if mibBuilder.loadTexts: reroutingFilterTable.setReference('Domain-based rerouting v1.0')
if mibBuilder.loadTexts: reroutingFilterTable.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterTable.setDescription('The table is used to configure the rerouting services of a call during the initial call establishment. The configuration includes: - the availability of rerouting services, - the request for inter and intra-domain rerouting services. - the applicability of the configuration to svc, spvc, svp, spvp. The configuration of rerouting services is based on a filter. Incoming setups and outgoing setups on inter-domain interfaces (e.g. UNI, AINI, inter-domain PNNI) are matched against the filters contained in this table. The configuration of the rerouting services contained in a row of this table apply if the setup message matches the filtering criteria contained in the row. If the setup message matches several filters of this table, the resulting configuration of the rerouting services is implementation dependent. An entry in this table configures the rerouting services for SVCs, SVPs, soft PVCs, and soft PVPs. The configuration Applies to point-to-point calls only.')
reroutingFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1), ).setIndexNames((0, "ATM-REROUTING-MIB", "reroutingFilterIndex"))
if mibBuilder.loadTexts: reroutingFilterEntry.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterEntry.setDescription('Each entry in this table defines a filter to match against incoming/outgoing setups on inter-domain interfaces. Each entry also contains the configuration of the rerouting services for a call matching the filter. Matching is performed on incoming setup indications and Outgoing setup requests of svcs and svps when the switching system is the edge switch for the call. The matching is done on the inter-domain interface. A setup message is matching a filter entry, if all the attributes contained in the filter match the setup message. The matching criteria is contained in the description of each object. The entry is also used to configure the rerouting services for soft pvcs or soft pvps whose terminating legs are located on an interface of this switch. A new entry can be created by specifying an atmTraceFilterIndex value that is currently not being used and also using an appropriate value (createAndGo or createAndWait) for the reroutingFilterRowStatus object. The reroutingFilterIndex is used as the instance ID to Uniquely identify a filter configured on this switching system.')
reroutingFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: reroutingFilterIndex.setReference('Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterIndex.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterIndex.setDescription('An arbitrary integer uniquely identifying a filter in this table.')
reroutingFilterIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("in", 1), ("out", 2), ("both", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterIfDirection.setReference('Domain-based rerouting v1.0')
if mibBuilder.loadTexts: reroutingFilterIfDirection.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterIfDirection.setDescription("The combination of this object and the corresponding instance of reroutingFilterInterface is one selection criteria for this filter entry. If the value of this object is different from 'none', the object restricts the scope of the filter to calls which enter, exit or both enter and exit the ATM device through the port represented by reroutingFilterInterface. Calls initiated or terminated at this port (e.g. Soft PVCs) are also scoped. When this object has the value 'none', it indicates that the scope of the filter is not restricted by the port.")
reroutingFilterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterInterface.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterInterface.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterInterface.setDescription("The combination of this object and the corresponding instance of reroutingIfDirection is one selection criteria for this filter entry. This object restricts the scope of the filter to calls which enter, exit or both enter and exit the ATM device through the port represented by this object. Calls initiated or terminated at this port (e.g. Soft PVCs) are also scoped. When reroutingFilterCallDirection has the value 'none', the value contained in this object is ignored and the scope of the filter is not restricted by the port.")
reroutingFilterConnKind = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 4), Bits().clone(namedValues=NamedValues(("other", 0), ("svcAndSpvcNotInitiator", 1), ("spvcInitiator", 2), ("svpAndSpvpNotInitiator", 3), ("spvpInitiator", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterConnKind.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterConnKind.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterConnKind.setDescription("Indicates if the configuration defined in this entry applies to: - 'svcAndSpvcNotInitiator' to switched virtual channels only. - 'spvcInitiator' to soft permanent virtual channels, when initiated or terminated on this switching system. - 'svpAndSpvpNotInitiator' to switched virtual paths only. - 'spvpInitiator' to soft permanent virtual paths, when initiated or terminated on this switching system.")
reroutingFilterServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 5), Bits().clone(namedValues=NamedValues(("cbr", 0), ("rtVbr", 1), ("nrtVbr", 2), ("abr", 3), ("ubr", 4), ("gfr", 5), ("other", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterServiceCategory.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterServiceCategory.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterServiceCategory.setDescription('This object restricts the scope of the filter to calls belonging to service categories represented by this object.')
reroutingFilterCallingPartyPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 6), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterCallingPartyPrefix.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterCallingPartyPrefix.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterCallingPartyPrefix.setDescription('The combination of this object and the corresponding instance of reroutingFilterCallingPartyLength is one selection criteria for this record. To match this selection criteria, a call setup must have a Calling Party Address which has an initial part (of length reroutingFilterCalledPartyLength bits) equal in value to reroutingFilterCallingParty. When the default value for the object is retained then the call will match this filtering criteria for any calling address in the call, or if the calling party number is not present in the call. The value must be padded with zeros from reroutingFilterCallingPartyLength to the full length of the address (8 octets for E.164 numbers and 20 octets for AESAs).')
reroutingFilterCallingPartyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160)).clone(152)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterCallingPartyLength.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterCallingPartyLength.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterCallingPartyLength.setDescription('This object specifies the number of bits in reroutingFilterCallingParty that shall be used when matching against the calling party of a new call setup.')
reroutingFilterCalledPartyPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 8), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterCalledPartyPrefix.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterCalledPartyPrefix.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterCalledPartyPrefix.setDescription('The combination of this object and the corresponding instance of reroutingFilterCalledPartyLength is one selection criteria for this record. To match this selection criteria, a connection segment setup must have a called party address which has an initial part (of length reroutingFilterCalledPartyLength bits) equal in value to reroutingFilterCalledParty. When the default value for the object is retained then the call will match this filtering criteria for any called address in the all. The value must be padded with zeros from reroutingFilterCalledPartyLength to the full length of the address (8 octets for E.164 numbers and 20 octets for AESAs).')
reroutingFilterCalledPartyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160)).clone(152)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterCalledPartyLength.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterCalledPartyLength.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterCalledPartyLength.setDescription('This object specifies the number of bits in reroutingFilterCalledParty that shall be used when matching against the called party of a new call setup.')
reroutingFilterNetworkServicesAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 10), NetworkReroutingCapabilities()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterNetworkServicesAvailable.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterNetworkServicesAvailable.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterNetworkServicesAvailable.setDescription('Indicates what network rerouting services are locally available for a call when it matches this filter. If a rerouting service is not available, the negotiation protocol of rerouting services ensures that the service cannot be activated for the call within this rerouting domain. This object can be used to filter and disable the services requested by a user. The determination of the values indicated in the Rerouting Service IE is described in sections 6.2.1 and 6.3.2.')
reroutingFilterHardReroutingServiceRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 11), HardReroutingServicesClass().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterHardReroutingServiceRequest.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterHardReroutingServiceRequest.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterHardReroutingServiceRequest.setDescription("Indicates which hard rerouting service is requested by the network on behalf of the user when a setup matches this address filter. 'none' means that no hard rerouting service is requested for the call. 'dbrInterDomainHardRerouting' means that the Domain-based hard rerouting service is requested end to end for the call. In addition the intra-domain hard rerouting service is requested for the call. Conditions for the request the inter-domain hard rerouting service are described in sections 6.2.1 and 6.3.2. 'dbrIntraDomainHardRerouting' means that the Domain-based hard rerouting service is requested for the call within this rerouting domain only. This value can be set if the switch is connected directly to the ATM end system, or if it is connected to another switch with an inter-domain interface (e.g. AINI, UNI, inter-domain PNNI) The service specified in this object is only requested for the call if the service is available for this interface. (see object reroutingFilterNetworkServicesAvailable). The determination of the activation of the service depends on the service availability at the other edge nodes. The procedures are described in sections 6.2.1 and 6.3.2.")
reroutingFilterSoftReroutingServiceRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 12), SoftReroutingServicesClass().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterSoftReroutingServiceRequest.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingFilterSoftReroutingServiceRequest.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterSoftReroutingServiceRequest.setDescription("Indicates which soft rerouting service is requested by the network on behalf of the user when a setup matches this address filter. 'none' means that no soft rerouting service is requested for the call. 'dbrIntraDomainAsymmetricSoftRerouting' means that the Domain-based asymmetric soft rerouting service is requested for the call within this rerouting domain only. This value can be set if the switch is connected directly to the ATM end system, or if it is connected to another switch with an inter-domain interface (e.g. AINI, UNI, inter-domain PNNI) 'dbrIntraDomainSymmetricSoftRerouting' means that the Domain-based symmetric soft rerouting service is requested for the call within this rerouting domain only. This value can be set if the switch is connected directly to the ATM end system, or if it is connected to another switch with an inter-domain interface (e.g. AINI, UNI, inter-domain PNNI) The service specified in this object is only requested for the call if the service is available for this interface. (see object reroutingFilterInterNetworkServicesAvailable) The determination of the activation of the service depends on the service availability at the other edge nodes. The procedures are described in sections 6.2.1 and 6.3.2.")
reroutingFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: reroutingFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterRowStatus.setDescription('To create, delete, activate and de-activate a filter for the configuration of the rerouting services.')
reroutingVpTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3), )
if mibBuilder.loadTexts: reroutingVpTable.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpTable.setStatus('current')
if mibBuilder.loadTexts: reroutingVpTable.setDescription('The table used to describe the rerouting attributes of a Pt-to-Pt svp or spvp. The entire reroutingVpTable is read-only reflecting the fact that reroutable connections are created through the ATM signalling protocol rather than configured.')
reroutingVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: reroutingVpEntry.setStatus('current')
if mibBuilder.loadTexts: reroutingVpEntry.setDescription('Each entry in this table contains the rerouting attributes of a SVP or Soft PVP connection. The content of this table reflects only the rerouting values associated with VPCs. This table is similar to the atmVclTable specified in ATM-MIB (RFC 2515). Entries are included for Vpls for which this is the source interface or the destination interface in the rerouting domain. Entries may be included for Vpls at the endpoints of the connection (see the reroutingVpHardReroutingServiceActivated object). This entry serves to identify the VPL on the interface.')
reroutingVpNodeRole = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 1), ReroutingNodeRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpNodeRole.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpNodeRole.setStatus('current')
if mibBuilder.loadTexts: reroutingVpNodeRole.setDescription('Indicates if the switch is the source node or the destination node for the call.')
reroutingVpRemoteNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpRemoteNodeAddress.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpRemoteNodeAddress.setStatus('current')
if mibBuilder.loadTexts: reroutingVpRemoteNodeAddress.setDescription('Contains the ATM address of the remote edge node')
reroutingVpHardReroutingServiceActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 3), HardReroutingServicesClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpHardReroutingServiceActivated.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpHardReroutingServiceActivated.setStatus('current')
if mibBuilder.loadTexts: reroutingVpHardReroutingServiceActivated.setDescription("Indicates which hard rerouting service is activated for this call. 'none' means that no hard rerouting service is activated for the call. On a switch, 'dbrInterDomainHardRerouting' means that the Domain-based hard rerouting service has been requested end to end for the call, and that it is activated within this rerouting domain. On an end system, 'dbrInterDomainHardRerouting' means the hard rerouting service has been requested end to end for the call, and that at least one rerouting domain along the path has activated it. 'dbrIntraDomainHardRerouting' means that the Domain-based hard rerouting service is activated for the call within this rerouting domain only.")
reroutingVpSoftReroutingServiceActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 4), SoftReroutingServicesClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpSoftReroutingServiceActivated.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpSoftReroutingServiceActivated.setStatus('current')
if mibBuilder.loadTexts: reroutingVpSoftReroutingServiceActivated.setDescription("Indicates which soft rerouting service is activated for this call. 'none' means that no soft rerouting service is activated for the call. 'dbrIntraDomainAsymmetricSoftRerouting' means that the Domain-based asymmetric soft rerouting service is activated for the call within this rerouting domain only. 'dbrIntraDomainSymmetricSoftRerouting' means that the Domain-based symmetric soft rerouting service is activated for the call within this rerouting domain only.")
reroutingVpReroutingState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 5), ReroutingState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpReroutingState.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpReroutingState.setStatus('current')
if mibBuilder.loadTexts: reroutingVpReroutingState.setDescription("Indicates if a rerouting operation is in progress and what type of rerouting operation is in progress. 'idle' indicates that no rerouting operation is in progress. 'hardRerouting' indicates that a hard rerouting operation is in progress. 'softRerouting' indicates that a soft rerouting operation is in progress.")
reroutingVpReroutingOperationSuccessCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpReroutingOperationSuccessCounter.setStatus('current')
if mibBuilder.loadTexts: reroutingVpReroutingOperationSuccessCounter.setDescription('Indicates the number of rerouting operations initiated by this node that succeeded on this call. The establishment of the initial call is not counted')
reroutingVpReroutingOperationFailuresCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpReroutingOperationFailuresCounter.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpReroutingOperationFailuresCounter.setStatus('current')
if mibBuilder.loadTexts: reroutingVpReroutingOperationFailuresCounter.setDescription('Indicates the number of rerouting operations initiated by this node that failed on this call.')
reroutingVpLocalIncarnationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpLocalIncarnationNumber.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpLocalIncarnationNumber.setStatus('current')
if mibBuilder.loadTexts: reroutingVpLocalIncarnationNumber.setDescription('Indicates the current local incarnation number associated with the call. The value contained in this object is the incarnation number of the last reroute setup that was sent by this node for this call. The value zero indicates that no reroute setup has been sent for this call. This object is not instantiated if this node is the destination node of the call and symmetric soft rerouting is not activated for the call')
reroutingVpRemoteIncarnationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpRemoteIncarnationNumber.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVpRemoteIncarnationNumber.setStatus('current')
if mibBuilder.loadTexts: reroutingVpRemoteIncarnationNumber.setDescription('Indicates the current remote incarnation number associated with the call. The value contained in this object is the incarnation number of the last reroute setup that was received by this node for this call. The value zero indicates that no reroute setup has been received for this call. This object is not instantiated if this node is the source node of the call and symmetric soft rerouting is not activated for the call')
reroutingVpExtendedReroutingState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 3, 1, 10), ExtendedReroutingState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVpExtendedReroutingState.setReference('ATM Forum Domain-based rerouting 1.0 sections 6.2.3, 6.3.3')
if mibBuilder.loadTexts: reroutingVpExtendedReroutingState.setStatus('current')
if mibBuilder.loadTexts: reroutingVpExtendedReroutingState.setDescription('Indicates the current rerouting state of the call, as defined in the rerouting Finite State Machine.')
reroutingVcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4), )
if mibBuilder.loadTexts: reroutingVcTable.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcTable.setStatus('current')
if mibBuilder.loadTexts: reroutingVcTable.setDescription('The table used to describe the rerouting related attributes of a Pt-to-Pt svc or spvc. The entire reroutingVcTable is read-only reflecting the fact that reroutable connections are created through the ATM signalling protocol rather than configured.')
reroutingVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: reroutingVcEntry.setStatus('current')
if mibBuilder.loadTexts: reroutingVcEntry.setDescription('Each entry in this table contains the rerouting attributes of a SVC or Soft PVC connection. The content of this table reflects only the rerouting values associated with VCCs. This table is similar to the atmVclTable specified in ATM-MIB (RFC 2515). Entries are included for Vcls for which this is the source interface or the destination interface in the rerouting domain. Entries may be included for Vcls at the endpoints of the connection (see the reroutingVcHardReroutingServiceActivated object). This entry serves to identify the VCL on the interface.')
reroutingVcNodeRole = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 1), ReroutingNodeRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcNodeRole.setStatus('current')
if mibBuilder.loadTexts: reroutingVcNodeRole.setDescription('Indicates if the switch is the source node or the destination node for the call.')
reroutingVcRemoteNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcRemoteNodeAddress.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcRemoteNodeAddress.setStatus('current')
if mibBuilder.loadTexts: reroutingVcRemoteNodeAddress.setDescription('Contains the ATM address of the remote edge node')
reroutingVcHardReroutingServiceActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 3), HardReroutingServicesClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcHardReroutingServiceActivated.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcHardReroutingServiceActivated.setStatus('current')
if mibBuilder.loadTexts: reroutingVcHardReroutingServiceActivated.setDescription("Indicates which hard rerouting service is activated for this call. 'none' means that no hard rerouting service is activated for the call. On a switch, 'dbrInterDomainHardRerouting' means that the Domain-based hard rerouting service has been requested end to end for the call, and that it is activated within this rerouting domain. On an end system, 'dbrInterDomainHardRerouting' means the hard rerouting service has been requested end to end for the call, and that at least one rerouting domain along the path has activated it. 'dbrIntraDomainHardRerouting' means that the Domain-based hard rerouting service is activated for the call within this rerouting domain only.")
reroutingVcSoftReroutingServiceActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 4), SoftReroutingServicesClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcSoftReroutingServiceActivated.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcSoftReroutingServiceActivated.setStatus('current')
if mibBuilder.loadTexts: reroutingVcSoftReroutingServiceActivated.setDescription("Indicates which soft rerouting service is activated for this call. 'none' means that no soft rerouting service is activated for the call. 'dbrIntraDomainAsymmetricSoftRerouting' means that the Domain-based asymmetric soft rerouting service is activated for the call within this rerouting domain only. 'dbrIntraDomainSymmetricSoftRerouting' means that the Domain-based symmetric soft rerouting service is activated for the call within this rerouting domain only.")
reroutingVcReroutingState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 5), ReroutingState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcReroutingState.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcReroutingState.setStatus('current')
if mibBuilder.loadTexts: reroutingVcReroutingState.setDescription("Indicates if a rerouting operation is in progress and what type of rerouting operation is in progress. 'idle' indicates that no rerouting operation is in progress. 'hardRerouting' indicates that a hard rerouting operation is in progress. 'softRerouting' indicates that a soft rerouting operation is in progress.")
reroutingVcReroutingOperationSuccessCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcReroutingOperationSuccessCounter.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcReroutingOperationSuccessCounter.setStatus('current')
if mibBuilder.loadTexts: reroutingVcReroutingOperationSuccessCounter.setDescription('Indicates the number of rerouting operations initiated by this node that succeeded on this call. The establishment of the initial call is not counted')
reroutingVcReroutingOperationFailuresCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcReroutingOperationFailuresCounter.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcReroutingOperationFailuresCounter.setStatus('current')
if mibBuilder.loadTexts: reroutingVcReroutingOperationFailuresCounter.setDescription('Indicates the number of rerouting operations initiated by this node that failed on this call.')
reroutingVcLocalIncarnationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcLocalIncarnationNumber.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcLocalIncarnationNumber.setStatus('current')
if mibBuilder.loadTexts: reroutingVcLocalIncarnationNumber.setDescription('Indicates the current local incarnation number associated with the call. The value contained in this object is the incarnation number of the last reroute setup that was sent by this node for this call. The value zero indicates that no reroute setup has been sent for this call. This object is not instantiated if this node is the destination node of the call and symmetric soft rerouting is not activated for the call')
reroutingVcRemoteIncarnationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcRemoteIncarnationNumber.setReference('ATM Forum Domain-based rerouting 1.0')
if mibBuilder.loadTexts: reroutingVcRemoteIncarnationNumber.setStatus('current')
if mibBuilder.loadTexts: reroutingVcRemoteIncarnationNumber.setDescription('Indicates the current remote incarnation number associated with the call. The value contained in this object is the incarnation number of the last reroute setup that was received by this node for this call. The value zero indicates that no reroute setup has been received for this call. This object is not instantiated if this node is the source node of the call and symmetric soft rerouting is not activated for the call')
reroutingVcExtendedReroutingState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 1, 4, 1, 10), ExtendedReroutingState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reroutingVcExtendedReroutingState.setReference('ATM Forum Domain-based rerouting 1.0 sections 6.2.3, 6.3.3')
if mibBuilder.loadTexts: reroutingVcExtendedReroutingState.setStatus('current')
if mibBuilder.loadTexts: reroutingVcExtendedReroutingState.setDescription('Indicates the current rerouting state of the call, as defined in the rerouting Finite State Machine.')
reroutingMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2))
reroutingMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 1))
reroutingMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2))
reroutingMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 1, 1)).setObjects(("ATM-REROUTING-MIB", "reroutingBaseSwMinGroup"), ("ATM-REROUTING-MIB", "reroutingFilterSwMinGroup"), ("ATM-REROUTING-MIB", "reroutingVcSwMinGroup"), ("ATM-REROUTING-MIB", "reroutingBaseEsMinGroup"), ("ATM-REROUTING-MIB", "reroutingFilterEsMinGroup"), ("ATM-REROUTING-MIB", "reroutingVcEsMinGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingMIBCompliance = reroutingMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: reroutingMIBCompliance.setDescription('The compliance statement for entities which implement the ATM rerouting MIB. Groups of required rerouting objects for configuring and monitoring the domain-based rerouting feature in a switching system are identified by the suffix SwMinGroup. Groups of optional rerouting objects for switching systems are identified by the suffix SwOptGroup. Groups of required rerouting objects for configuring and monitoring the domain-based rerouting feature at an end system are identified by the suffix EsMinGroup. Groups of optional rerouting objects for end systems are identified by the suffix EsOptGroup.')
reroutingBaseSwMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 1)).setObjects(("ATM-REROUTING-MIB", "reroutingVersion"), ("ATM-REROUTING-MIB", "reroutingCapabilitiesSupported"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingBaseSwMinGroup = reroutingBaseSwMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingBaseSwMinGroup.setDescription('A collection of mandatory rerouting objects which describe the rerouting services supported in a switching system.')
reroutingFilterSwMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 2)).setObjects(("ATM-REROUTING-MIB", "reroutingFilterIfDirection"), ("ATM-REROUTING-MIB", "reroutingFilterInterface"), ("ATM-REROUTING-MIB", "reroutingFilterNetworkServicesAvailable"), ("ATM-REROUTING-MIB", "reroutingFilterHardReroutingServiceRequest"), ("ATM-REROUTING-MIB", "reroutingFilterSoftReroutingServiceRequest"), ("ATM-REROUTING-MIB", "reroutingFilterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingFilterSwMinGroup = reroutingFilterSwMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterSwMinGroup.setDescription('A collection of mandatory objects used for the configuration of rerouting services in a switching system when using filters.')
reroutingVcSwMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 3)).setObjects(("ATM-REROUTING-MIB", "reroutingVcNodeRole"), ("ATM-REROUTING-MIB", "reroutingVcRemoteNodeAddress"), ("ATM-REROUTING-MIB", "reroutingVcHardReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVcSoftReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVcReroutingState"), ("ATM-REROUTING-MIB", "reroutingVcReroutingOperationSuccessCounter"), ("ATM-REROUTING-MIB", "reroutingVcReroutingOperationFailuresCounter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingVcSwMinGroup = reroutingVcSwMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingVcSwMinGroup.setDescription('A collection of mandatory per Vc rerouting objects describing the state of the rerouting services associated to a call in a switching system.')
reroutingBaseSwOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 4)).setObjects(("ATM-REROUTING-MIB", "reroutingHardReroutingTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingBaseSwOptionalGroup = reroutingBaseSwOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingBaseSwOptionalGroup.setDescription('A collection of optional rerouting object which describe the timer configuration when hard rerouting service is supported in a switching system.')
reroutingFilterSwOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 5)).setObjects(("ATM-REROUTING-MIB", "reroutingFilterConnKind"), ("ATM-REROUTING-MIB", "reroutingFilterServiceCategory"), ("ATM-REROUTING-MIB", "reroutingFilterCallingPartyPrefix"), ("ATM-REROUTING-MIB", "reroutingFilterCallingPartyLength"), ("ATM-REROUTING-MIB", "reroutingFilterCalledPartyPrefix"), ("ATM-REROUTING-MIB", "reroutingFilterCalledPartyLength"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingFilterSwOptionalGroup = reroutingFilterSwOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterSwOptionalGroup.setDescription('A collection of optional objects used for the configuration of rerouting services in a switching system when using filters.')
reroutingVpSwOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 6)).setObjects(("ATM-REROUTING-MIB", "reroutingVpNodeRole"), ("ATM-REROUTING-MIB", "reroutingVpRemoteNodeAddress"), ("ATM-REROUTING-MIB", "reroutingVpHardReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVpSoftReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVpReroutingState"), ("ATM-REROUTING-MIB", "reroutingVpReroutingOperationSuccessCounter"), ("ATM-REROUTING-MIB", "reroutingVpReroutingOperationFailuresCounter"), ("ATM-REROUTING-MIB", "reroutingVpLocalIncarnationNumber"), ("ATM-REROUTING-MIB", "reroutingVpRemoteIncarnationNumber"), ("ATM-REROUTING-MIB", "reroutingVpExtendedReroutingState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingVpSwOptionalGroup = reroutingVpSwOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingVpSwOptionalGroup.setDescription('A collection of optional per Vp rerouting objects describing the state of the rerouting services associated to a call in a switching system.')
reroutingVcSwOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 7)).setObjects(("ATM-REROUTING-MIB", "reroutingVcLocalIncarnationNumber"), ("ATM-REROUTING-MIB", "reroutingVcRemoteIncarnationNumber"), ("ATM-REROUTING-MIB", "reroutingVcExtendedReroutingState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingVcSwOptionalGroup = reroutingVcSwOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingVcSwOptionalGroup.setDescription('A collection of optional per Vc rerouting objects describing the state of the rerouting services associated to a call in a switching system.')
reroutingBaseEsMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 8)).setObjects(("ATM-REROUTING-MIB", "reroutingVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingBaseEsMinGroup = reroutingBaseEsMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingBaseEsMinGroup.setDescription('A collection of mandatory rerouting objects which describe the rerouting services supported in an end system.')
reroutingFilterEsMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 9)).setObjects(("ATM-REROUTING-MIB", "reroutingFilterIfDirection"), ("ATM-REROUTING-MIB", "reroutingFilterInterface"), ("ATM-REROUTING-MIB", "reroutingFilterHardReroutingServiceRequest"), ("ATM-REROUTING-MIB", "reroutingFilterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingFilterEsMinGroup = reroutingFilterEsMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterEsMinGroup.setDescription('A collection of mandatory objects used for the request of rerouting services in this end system device when using filters.')
reroutingVcEsMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 10)).setObjects(("ATM-REROUTING-MIB", "reroutingVcHardReroutingServiceActivated"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingVcEsMinGroup = reroutingVcEsMinGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingVcEsMinGroup.setDescription('A collection of mandatory rerouting objects describing the rerouting services associated to a call in an end system device.')
reroutingFilterEsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 11)).setObjects(("ATM-REROUTING-MIB", "reroutingFilterConnKind"), ("ATM-REROUTING-MIB", "reroutingFilterServiceCategory"), ("ATM-REROUTING-MIB", "reroutingFilterCallingPartyPrefix"), ("ATM-REROUTING-MIB", "reroutingFilterCallingPartyLength"), ("ATM-REROUTING-MIB", "reroutingFilterCalledPartyPrefix"), ("ATM-REROUTING-MIB", "reroutingFilterCalledPartyLength"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingFilterEsOptionalGroup = reroutingFilterEsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingFilterEsOptionalGroup.setDescription('A collection of optional objects used for the configuration of rerouting services in this end system device when using filters.')
reroutingVpEsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 3, 1, 2, 2, 12)).setObjects(("ATM-REROUTING-MIB", "reroutingVpHardReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVpSoftReroutingServiceActivated"), ("ATM-REROUTING-MIB", "reroutingVcSoftReroutingServiceActivated"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reroutingVpEsOptionalGroup = reroutingVpEsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: reroutingVpEsOptionalGroup.setDescription('A collection of optional rerouting objects describing the rerouting services associated to a call in an end system device.')
mibBuilder.exportSymbols("ATM-REROUTING-MIB", NetworkReroutingCapabilities=NetworkReroutingCapabilities, reroutingVpLocalIncarnationNumber=reroutingVpLocalIncarnationNumber, reroutingFilterCallingPartyLength=reroutingFilterCallingPartyLength, reroutingVpRemoteNodeAddress=reroutingVpRemoteNodeAddress, reroutingFilterNetworkServicesAvailable=reroutingFilterNetworkServicesAvailable, reroutingHardReroutingTime=reroutingHardReroutingTime, reroutingMIBGroups=reroutingMIBGroups, reroutingFilterSwOptionalGroup=reroutingFilterSwOptionalGroup, reroutingVcEsMinGroup=reroutingVcEsMinGroup, reroutingVcNodeRole=reroutingVcNodeRole, atmfSignalling=atmfSignalling, reroutingFilterEsOptionalGroup=reroutingFilterEsOptionalGroup, reroutingFilterInterface=reroutingFilterInterface, reroutingVpRemoteIncarnationNumber=reroutingVpRemoteIncarnationNumber, reroutingFilterIfDirection=reroutingFilterIfDirection, reroutingFilterIndex=reroutingFilterIndex, SoftReroutingServicesClass=SoftReroutingServicesClass, reroutingFilterCallingPartyPrefix=reroutingFilterCallingPartyPrefix, reroutingVcSoftReroutingServiceActivated=reroutingVcSoftReroutingServiceActivated, reroutingVpReroutingOperationSuccessCounter=reroutingVpReroutingOperationSuccessCounter, PYSNMP_MODULE_ID=atmfreroutingMIB, ReroutingState=ReroutingState, reroutingFilterEntry=reroutingFilterEntry, reroutingBaseSwMinGroup=reroutingBaseSwMinGroup, atmfreroutingMIB=atmfreroutingMIB, reroutingVcRemoteNodeAddress=reroutingVcRemoteNodeAddress, reroutingMIBCompliances=reroutingMIBCompliances, reroutingFilterRowStatus=reroutingFilterRowStatus, reroutingVpEsOptionalGroup=reroutingVpEsOptionalGroup, reroutingFilterTable=reroutingFilterTable, reroutingVpNodeRole=reroutingVpNodeRole, reroutingVcReroutingOperationSuccessCounter=reroutingVcReroutingOperationSuccessCounter, reroutingVcSwOptionalGroup=reroutingVcSwOptionalGroup, reroutingVpSoftReroutingServiceActivated=reroutingVpSoftReroutingServiceActivated, reroutingVpTable=reroutingVpTable, reroutingVcTable=reroutingVcTable, reroutingVersion=reroutingVersion, reroutingVcExtendedReroutingState=reroutingVcExtendedReroutingState, reroutingCapabilitiesSupported=reroutingCapabilitiesSupported, reroutingVpEntry=reroutingVpEntry, reroutingVpHardReroutingServiceActivated=reroutingVpHardReroutingServiceActivated, reroutingFilterCalledPartyPrefix=reroutingFilterCalledPartyPrefix, reroutingVpReroutingState=reroutingVpReroutingState, reroutingFilterConnKind=reroutingFilterConnKind, reroutingVcEntry=reroutingVcEntry, reroutingVcRemoteIncarnationNumber=reroutingVcRemoteIncarnationNumber, reroutingVcHardReroutingServiceActivated=reroutingVcHardReroutingServiceActivated, atmForum=atmForum, reroutingVpSwOptionalGroup=reroutingVpSwOptionalGroup, reroutingFilterServiceCategory=reroutingFilterServiceCategory, reroutingBaseGroup=reroutingBaseGroup, reroutingBaseEsMinGroup=reroutingBaseEsMinGroup, ExtendedReroutingState=ExtendedReroutingState, reroutingFilterSoftReroutingServiceRequest=reroutingFilterSoftReroutingServiceRequest, reroutingBaseSwOptionalGroup=reroutingBaseSwOptionalGroup, reroutingVcReroutingState=reroutingVcReroutingState, reroutingMIBConformance=reroutingMIBConformance, reroutingVpExtendedReroutingState=reroutingVpExtendedReroutingState, reroutingVpReroutingOperationFailuresCounter=reroutingVpReroutingOperationFailuresCounter, reroutingFilterEsMinGroup=reroutingFilterEsMinGroup, HardReroutingServicesClass=HardReroutingServicesClass, reroutingFilterCalledPartyLength=reroutingFilterCalledPartyLength, reroutingFilterHardReroutingServiceRequest=reroutingFilterHardReroutingServiceRequest, reroutingVcLocalIncarnationNumber=reroutingVcLocalIncarnationNumber, reroutingFilterSwMinGroup=reroutingFilterSwMinGroup, atmForumNetworkManagement=atmForumNetworkManagement, reroutingMIBCompliance=reroutingMIBCompliance, reroutingVcSwMinGroup=reroutingVcSwMinGroup, ReroutingNodeRole=ReroutingNodeRole, reroutingMIBObjects=reroutingMIBObjects, reroutingVcReroutingOperationFailuresCounter=reroutingVcReroutingOperationFailuresCounter, atmfRerouting=atmfRerouting)

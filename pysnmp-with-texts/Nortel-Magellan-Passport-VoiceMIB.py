#
# PySNMP MIB module Nortel-Magellan-Passport-VoiceMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-VoiceMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
Unsigned32, Counter32, StorageType, Gauge32, RowStatus, PassportCounter64, InterfaceIndex, DisplayString, Integer32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Unsigned32", "Counter32", "StorageType", "Gauge32", "RowStatus", "PassportCounter64", "InterfaceIndex", "DisplayString", "Integer32")
EnterpriseDateAndTime, FixedPoint1, NonReplicated, HexString, AsciiString, Link = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "EnterpriseDateAndTime", "FixedPoint1", "NonReplicated", "HexString", "AsciiString", "Link")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, Unsigned32, Counter32, Counter64, NotificationType, Bits, Gauge32, IpAddress, TimeTicks, ModuleIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Counter32", "Counter64", "NotificationType", "Bits", "Gauge32", "IpAddress", "TimeTicks", "ModuleIdentity", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
voiceMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49))
vs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80))
vsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1), )
if mibBuilder.loadTexts: vsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsRowStatusTable.setDescription('This entry controls the addition and deletion of vs components.')
vsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsRowStatusEntry.setDescription('A single entry in the table represents a single vs component.')
vsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vs components. These components can be added and deleted.')
vsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsStorageType.setDescription('This variable represents the storage type value for the vs tables.')
vsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: vsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsIndex.setDescription('This variable represents the index for the vs tables.')
vsCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 10), )
if mibBuilder.loadTexts: vsCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
vsCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsCidDataEntry.setDescription('An entry in the vsCidDataTable.')
vsCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: vsCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
vsIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 11), )
if mibBuilder.loadTexts: vsIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
vsIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsIfEntryEntry.setDescription('An entry in the vsIfEntryTable.')
vsIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
vsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
vsOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 12), )
if mibBuilder.loadTexts: vsOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vsOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsOperStatusEntry.setDescription('An entry in the vsOperStatusTable.')
vsSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13), )
if mibBuilder.loadTexts: vsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
vsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsStateEntry.setDescription('An entry in the vsStateTable.')
vsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
vsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
vsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
vsAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
vsProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
vsControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
vsAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
vsStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
vsUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
vsOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 15), )
if mibBuilder.loadTexts: vsOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsOperationalTable.setDescription('This group contains operational attributes related to a Vs.')
vsOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"))
if mibBuilder.loadTexts: vsOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsOperationalEntry.setDescription('An entry in the vsOperationalTable.')
vsServiceFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 15, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsServiceFailureReason.setStatus('mandatory')
if mibBuilder.loadTexts: vsServiceFailureReason.setDescription("This attribute indicates the result of end to end negotiation with the remote end across the subnet. If serviceFailureReason is undetermined, this Vs has not performed end to end negotiation with the remote end, and may or may not be up. serviceFailureReason is undetermined if this Vs just became enabled, if there is not enough available bandwidth to perform negotiation or if the remote end cannot perform negotiation with this Vs. If serviceFailureReason is none, end to end negotiation passed. If serviceFailureReason is mismatchedService, end to end negotiation failed because the remote end service is not a Vs. If serviceFailureReason is mismatchedVoiceEncoding, end to end negotiation failed because the local Vs Framer voiceEncoding does not match the remote Vs Framer voiceEncoding. If serviceFailureReason is mismatchedVoiceRates, end to end negotiation failed because the local provisioned ingress voice rates are not compatible with the remote end's egress capabilities or the remote provisioned ingress voice rates are not compatible with the local egress capabilities. If serviceFailureReason is mismatchedModemFaxEncoding, end to end negotiation failed because the local Vs Framer modemFaxEncoding does not match the remote Vs Framer modemFaxEncoding. If serviceFailureReason is mismatchedModemFaxRates, end to end negotiation failed because the local provisioned ingress modem and fax rates are not compatible with the remote end's egress capabilities or the remote provisioned ingress modem and fax rates are not compatible with the local egress capabilities. If serviceFailureReason is mismatchedCasSignalling, end to end negotiation failed because the local Vs Framer casSignalling does not match the remote Vs Framer casSignalling. If serviceFailureReason is mismatchedSignalBits, end to end negotiation failed because the local Vs Framer signalBits does not match the remote Vs Framer signalBits. serviceFailureReason is mismatchedSignalBits only if the local Vs Framer casSignalling is transparent. If serviceFailureReason is compDecodeFailed, end to end negotiation failed because the information received from the remote end was not recognized as valid data. Description of bits: none(0) undetermined(1) logicalConnection(2) mismatchedService(3) notused4(4) notused5(5) mismatchedVoiceEncoding(6) mismatchedVoiceRates(7) mismatchedModemFaxEncoding(8) mismatchedModemFaxRates(9) mismatchedCasSignalling(10) mismatchedSignalBits(11) mismatchedSilenceSuppression(12) mismatchedFaxIdleSuppression(13) compDecodeFailed(14)")
vsFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2))
vsFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1), )
if mibBuilder.loadTexts: vsFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerRowStatusTable.setDescription('This entry controls the addition and deletion of vsFramer components.')
vsFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerRowStatusEntry.setDescription('A single entry in the table represents a single vsFramer component.')
vsFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsFramer components. These components cannot be added nor deleted.')
vsFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerStorageType.setDescription('This variable represents the storage type value for the vsFramer tables.')
vsFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIndex.setDescription('This variable represents the index for the vsFramer tables.')
vsFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 10), )
if mibBuilder.loadTexts: vsFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
vsFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerProvEntry.setDescription('An entry in the vsFramerProvTable.')
vsFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
vsFramerCoderTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12), )
if mibBuilder.loadTexts: vsFramerCoderTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerCoderTable.setDescription('This group contains attributes which specify how audio data on a channel is encoded and decoded.')
vsFramerCoderEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerCoderEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerCoderEntry.setDescription('An entry in the vsFramerCoderTable.')
vsFramerMaxVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerMaxVoiceBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMaxVoiceBitRate.setDescription('This attribute specifies the maximum desired ingress bit rate used during voice traffic when voiceEncoding is g711G726. The negotiated maximum ingress voice rate is available in negotiatedIgRates. maxVoiceG711G726Rate can be set to 16 only if this Voice Service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card.')
vsFramerMinVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerMinVoiceBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMinVoiceBitRate.setDescription('This attribute specifies the minimum desired ingress bit rate used during voice traffic when voiceEncoding is g711G726. The negotiated minimum ingress voice rate is available in negotiatedIgRates. minVoiceG711G726Rate defaults to 24 if the voiceCompressor or vtds feature is present. Otherwise, minVoiceG711G726Rate defaults to 64.')
vsFramerMaxModemBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerMaxModemBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMaxModemBitRate.setDescription('This attribute specifies the maximum desired ingress rate used during modemFax and/or fax traffic. Voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. ModemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. Fax traffic is all traffic after a fax preamble but before speech or call release. If modemFaxEncoding is g711G726, maxModemFaxG711G726Rate specifies the maximum rate used during modemFax traffic and fax traffic. If modemFaxEncoding is faxRelayG711G726, maxModemFaxG711G726Rate specifies the maximum rate used during modemFax traffic only. If modemFaxEncoding is faxRelayOnly or useVoiceEncoding, maxModemFaxG711G726Rate is ignored. The negotiated maximum ingress modemFax and fax rates are available in negotiatedIgRates. maxModemFaxG711G726Rate can be set to 16 or 24 only if this voice service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card.')
vsFramerMinModemBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerMinModemBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMinModemBitRate.setDescription('This attribute specifies the minimum desired ingress rate used during modemFax and/or fax traffic. Voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. ModemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. Fax traffic is all traffic after a fax preamble but before speech or call release. If modemFaxEncoding is g711G726, minModemFaxG711G726Rate specifies the minimum desired rate used during modemFax traffic and fax traffic. If modemFaxEncoding is faxRelayG711G726, minModemFaxG711G726Rate specifies the minimum desired rate used during modemFax traffic only. If modemFaxEncoding is faxRelayOnly or useVoiceEncoding, minModemFaxG711G726Rate is ignored. The negotiated minimum ingress modemFax and fax rates are available in negotiatedIgRates. minModemFaxG711G726Rate defaults to 32 if the voiceCompressor or vtds feature is present. Otherwise, minModemFaxG711G726Rate defaults to 64.')
vsFramerAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("minus6", 0), ("minus4", 1), ("minus2", 2), ("n0", 3), ("n2", 4), ("n4", 5), ("n6", 6), ("minus12", 7), ("minus11", 8), ("minus10", 9), ("minus9", 10), ("minus8", 11), ("minus7", 12), ("minus5", 13), ("minus3", 14), ("minus1", 15), ("n1", 16), ("n3", 17), ("n5", 18), ("n7", 19), ("n8", 20), ("n9", 21), ("n10", 22), ("n11", 23), ("n12", 24))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerAudioGain.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerAudioGain.setDescription('This attribute has been migrated to egressAudioGain.')
vsFramerSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4), ("casIdleCode", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSilenceSuppression.setDescription('This attribute specifies when ingress silence suppression is desired during voice traffic. If silenceSuppression is off, silence suppression is never desired. If silenceSuppression is on, silence suppression is always desired. If silenceSuppression is congested, silence suppression is desired only when the network is congested. If silenceSuppression is slow, silence suppression is desired only after 20 seconds without audio. If silenceSuppression is slowAndCongested, both the slow and congested options are desired. If silenceSuppression is casIdleCode, the silence suppression is only desired when the idleCode is active for 20 to 40 seconds. casSignalling must be set to interpret if silenceSuppression is set to casIdleCode. silenceSuppression can be set to casIdleCode only if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card. The negotiated ingress silence suppression is available in negotiatedIgSilenceSuppression. If the silenceSuppressor or vtds feature is present, silenceSuppression defaults to on. Otherwise, silenceSuppression defaults to off.')
vsFramerEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEchoCancellation.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEchoCancellation.setDescription('This attribute specifies whether echo cancellation is performed on this VoiceService. If echoCancellation is on, the internal echo canceller is enabled and echo cancellation is performed. If echoCancellation is off, the internal echo canceller is placed in transparent bypass mode and echo cancellation is never performed. If the echoCancellor or vtds feature is present, echoCancellation defaults to on. Otherwise echoCancellation defaults to off.')
vsFramerALawConversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerALawConversion.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerALawConversion.setDescription('This attribute specifies whether mu-law to A-law PCM conversion is performed. aLawConversion only needs to be set to on when this voice service is running on a DS1V or 1pDS1V FP and the VoiceService at the remote end of the connection is running on an E1V or 1pE1V FP using a software release prior to 5.0. If the remote end software release is 5.0 or later, end to end negotiation determines the compander law to use at each end of the connection. In this case, the value of aLawConversion is ignored.')
vsFramerVoiceEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g711G726", 0), ("g728at16", 1), ("g729at8", 2))).clone('g711G726')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerVoiceEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVoiceEncoding.setDescription('This attribute specifies how ingress voice traffic is encoded. If voiceEncoding is g711G726, ingress voice traffic is encoded using either pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726. The actual encoding and rates performed depends on congestion in the network and the minimum and maximum negotiated ingress voice rates in negotiatedIgRates. If voiceEncoding is g728at16, ingress voice traffic is encoded using the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728. If voiceEncoding is g728at16, the bit rate of all voice traffic is fixed at 16 kbit/s. minVoiceG711G726Rate and maxVoiceG711G726Rate do not apply if voiceEncoding is g728at16. If voiceEncoding is g729at8, ingress voice traffic is encoded using the Conjugated Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) algorithm defined by ITU-T G.729. If voiceEncoding is g729at8, the bit rate of all voice traffic is fixed at 8 kbit/s. minVoiceG711G726Rate and maxVoiceG711G726Rate do not apply if voiceEncoding is g729at8. The current ingress encoding and encoding rate are available in currentEncoding and currentRate. voiceEncoding cannot be set to g728at16 or g729at8 if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card. Also, voiceEncoding can only be set to g728at16 or g729at8 if the corresponding feature exists in the featureList of the Sw Lpt. The negotiated ingress voice encoding is available in negotiatedIgEncoding. voiceEncoding must have the same value at both ends of a VoiceService. If voiceEncoding does not have the same value at both ends of a VoiceService, the VoiceService will be out of service. In this case, serviceFailureReason is mismatchedVoiceEncoding.')
vsFramerFaxEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711G726", 0), ("faxRelayOnly", 1), ("faxRelayG711G726", 2), ("useVoiceEncoding", 3))).clone('g711G726')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerFaxEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFaxEncoding.setDescription("This attribute specifies how ingress modemFax and fax traffic are encoded. Voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. ModemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. Fax traffic is all traffic after a fax preamble but before speech or call release. If modemFaxEncoding is useVoiceEncoding, all ingress traffic is treated like voice traffic and encoded according to voiceEncoding. If voiceEncoding is g728at16 or g729at8, modem and fax calls are not supported. If modemFaxEncoding is g711G726, ingress modemFax traffic and fax traffic are both encoded using pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726. The actual encoding and rates performed depends on congestion in the network and the minimum and maximum ingress modemFax rates in negotiatedIgRates. If modemFaxEncoding is faxRelayG711G726, ingress modemFax traffic is encoding using G.711 or G.726, exactly as it is if modemFaxEncoding is g711G726. Until a fax preamble is detected, the rate may fluctuate between the minimum and maximum modemFax rates in negotiatedIgRates due to network congestion, exactly as it does if modemFaxEncoding is g711G726. If a fax preamble is detected, all subsequent traffic during a call is demodulated and sent through the network as cells at the base rate of the sending machine. Supported demodulation methods are V.29 (up to 9.6 kbit/s) and V.27 (up to 4.8 kbit/s). The modulation and demodulation of fax traffic is called 'fax relay'. If modemFaxEncoding is faxRelayOnly, 'fax relay' is entered immediately upon 2100 Hz tone detection and modemFax traffic is treated like fax traffic. If modemFaxEncoding is faxRelayOnly, modem calls are not supported. The negotiated ingress modemFax and fax encodings are available in negotiatedIgEncoding. modemFaxEncoding cannot be set to faxRelayG711G726 or faxRelayOnly if this voice service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card. The faxRelay feature is required to set modemFaxEncoding to faxRelayG711G726 or faxRelayOnly. modemFaxEncoding must have the same value at both ends of a VoiceService. If modemFaxEncoding does not have the same value at both ends of a VoiceService, the VoiceService will be out of service. In this case, serviceFailureReason is mismatchedModemFaxEncoding.")
vsFramerTandemPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerTandemPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerTandemPassThrough.setDescription('This attribute specifies whether tandem pass through is desired. If tandemPassThrough is enabled, tandem pass through is used if possible. If tandemPassThrough is disabled, tandem pass through is not used under any circumstances. The negotiated tandem pass through is available in negotiatedTandemPassThrough. The actual state of tandem pass through is available in tptStatus. tandemPassThrough can be set to enabled only if the tandemPassThrough feature exists in the featureList of the Sw Lpt.')
vsFramerInsertedOutputDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 5, 15, 22, 30, 35, 40, 45, 50, 75, 100, 125, 150))).clone(namedValues=NamedValues(("default", 0), ("n5", 5), ("n15", 15), ("n22", 22), ("n30", 30), ("n35", 35), ("n40", 40), ("n45", 45), ("n50", 50), ("n75", 75), ("n100", 100), ("n125", 125), ("n150", 150))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerInsertedOutputDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerInsertedOutputDelay.setDescription('This attribute specifies the amount of added output delay used to compensate for cross network delay variations. It applies to voice, modem and fax traffic. It is required to add output delay so that the statistical variation in the transit time of cells crossing the network does not cause gaps in speech. Backbone networks where high priority traffic consumes a high percentage of trunk bandwidth will require a higher insertedOutputDelay to compensate for the greater cell delay variation (CDV). insertedOutputDelay must be default if this voice service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card. On all other cards, insertedOutputDelay can be set to any value. On these cards, default is equivalent to 22.')
vsFramerEgressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEgressAudioGain.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerEgressAudioGain.setDescription('This attribute has been migrated to ingressAudioGain.')
vsFramerFaxIdleSuppressionG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerFaxIdleSuppressionG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFaxIdleSuppressionG711G726.setDescription('This attribute specifies whether ingress fax idle suppression is desired during G.711 and G.726 fax traffic. It applies only if modemFaxEncoding is g711G726 or faxRelayG711G726. The negotiated ingress G.711/G.726 fax idle suppression is available in negotiatedIgFisG711G726. If the silenceSuppressor or vtds feature is present, faxIdleSuppressionG711G726 defaults to on. Otherwise, faxIdleSuppressionG711G726 defaults to off.')
vsFramerEndOfCallPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("standard", 0), ("n01", 1), ("n02", 2), ("n03", 3), ("n04", 4), ("n05", 5), ("n06", 6), ("n07", 7), ("n08", 8), ("n09", 9), ("n0a", 10), ("n0b", 11), ("n0c", 12), ("n0d", 13), ("n0e", 14), ("n0f", 15), ("n10", 16), ("n11", 17), ("n12", 18), ("n13", 19), ("n14", 20), ("n15", 21), ("n16", 22), ("n17", 23), ("n18", 24), ("n19", 25), ("n1a", 26), ("n1b", 27), ("n1c", 28), ("n1d", 29), ("n1e", 30), ("n1f", 31), ("n20", 32), ("n21", 33), ("n22", 34), ("n23", 35), ("n24", 36), ("n25", 37), ("n26", 38), ("n27", 39), ("n28", 40), ("n29", 41), ("n2a", 42), ("n2b", 43), ("n2c", 44), ("n2d", 45), ("n2e", 46), ("n2f", 47), ("n30", 48), ("n31", 49), ("n32", 50), ("n33", 51), ("n34", 52), ("n35", 53), ("n36", 54), ("n37", 55), ("n38", 56), ("n39", 57), ("n3a", 58), ("n3b", 59), ("n3c", 60), ("n3d", 61), ("n3e", 62), ("n3f", 63), ("n40", 64), ("n41", 65), ("n42", 66), ("n43", 67), ("n44", 68), ("n45", 69), ("n46", 70), ("n47", 71), ("n48", 72), ("n49", 73), ("n4a", 74), ("n4b", 75), ("n4c", 76), ("n4d", 77), ("n4e", 78), ("n4f", 79), ("n50", 80), ("n51", 81), ("n52", 82), ("n53", 83), ("n54", 84), ("n55", 85), ("n56", 86), ("n57", 87), ("n58", 88), ("n59", 89), ("n5a", 90), ("n5b", 91), ("n5c", 92), ("n5d", 93), ("n5e", 94), ("n5f", 95), ("n60", 96), ("n61", 97), ("n62", 98), ("n63", 99), ("n64", 100), ("n65", 101), ("n66", 102), ("n67", 103), ("n68", 104), ("n69", 105), ("n6a", 106), ("n6b", 107), ("n6c", 108), ("n6d", 109), ("n6e", 110), ("n6f", 111), ("n70", 112), ("n71", 113), ("n72", 114), ("n73", 115), ("n74", 116), ("n75", 117), ("n76", 118), ("n77", 119), ("n78", 120), ("n79", 121), ("n7a", 122), ("n7b", 123), ("n7c", 124), ("n7d", 125), ("n7e", 126), ("n7f", 127), ("n80", 128), ("n81", 129), ("n82", 130), ("n83", 131), ("n84", 132), ("n85", 133), ("n86", 134), ("n87", 135), ("n88", 136), ("n89", 137), ("n8a", 138), ("n8b", 139), ("n8c", 140), ("n8d", 141), ("n8e", 142), ("n8f", 143), ("n90", 144), ("n91", 145), ("n92", 146), ("n93", 147), ("n94", 148), ("n95", 149), ("n96", 150), ("n97", 151), ("n98", 152), ("n99", 153), ("n9a", 154), ("n9b", 155), ("n9c", 156), ("n9d", 157), ("n9e", 158), ("n9f", 159), ("a0", 160), ("a1", 161), ("a2", 162), ("a3", 163), ("a4", 164), ("a5", 165), ("a6", 166), ("a7", 167), ("a8", 168), ("a9", 169), ("aa", 170), ("ab", 171), ("ac", 172), ("ad", 173), ("ae", 174), ("af", 175), ("b0", 176), ("b1", 177), ("b2", 178), ("b3", 179), ("b4", 180), ("b5", 181), ("b6", 182), ("b7", 183), ("b8", 184), ("b9", 185), ("ba", 186), ("bb", 187), ("bc", 188), ("bd", 189), ("be", 190), ("bf", 191), ("c0", 192), ("c1", 193), ("c2", 194), ("c3", 195), ("c4", 196), ("c5", 197), ("c6", 198), ("c7", 199), ("c8", 200), ("c9", 201), ("ca", 202), ("cb", 203), ("cc", 204), ("cd", 205), ("ce", 206), ("cf", 207), ("d0", 208), ("d1", 209), ("d2", 210), ("d3", 211), ("d4", 212), ("d5", 213), ("d6", 214), ("d7", 215), ("d8", 216), ("d9", 217), ("da", 218), ("db", 219), ("dc", 220), ("dd", 221), ("de", 222), ("df", 223), ("e0", 224), ("e1", 225), ("e2", 226), ("e3", 227), ("e4", 228), ("e5", 229), ("e6", 230), ("e7", 231), ("e8", 232), ("e9", 233), ("ea", 234), ("eb", 235), ("ec", 236), ("ed", 237), ("ee", 238), ("ef", 239), ("f0", 240), ("f1", 241), ("f2", 242), ("f3", 243), ("f4", 244), ("f5", 245), ("f6", 246), ("f7", 247), ("f8", 248), ("f9", 249), ("fa", 250), ("fb", 251), ("fc", 252), ("fd", 253), ("fe", 254)) + NamedValues(("ff", 255))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEndOfCallPattern.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEndOfCallPattern.setDescription('This attribute specifies the pattern that indicates the end of a CCS call. The pattern is specified as a hexadecimal byte. If this pattern is detected for one second, the echo canceler is reset and will prepare itself to start a new call. When there is no call, this pattern replaces the PCM data that would normally be sent to the link. endOfCallPattern is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V and J2MV card. To determine the correct setting of endOfCallPattern, view the operational attribute recentIngressLineSamples while no calls are up. If endOfCallPattern is standard, the actual pattern used depends on the card this voice service is running on. If this voice service is running on a 1pDs1Mvp, 1pDS1Mvpe, 1pTTC2mMvp or 1pTTC2mMvpe card, the actual pattern used is 7f. If this voice service is running on a 1pE1Mvp or 1pE1Mvpe card, the actual pattern used is 54. The default value for endOfCallPattern is standard.')
vsFramerIngressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerIngressAudioGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIngressAudioGain.setDescription('This attribute specifies the gain in dB that is applied to data coming from outside the network before it is transferred across the network. It applies to voice, modem and fax traffic. For example, ingress gain is applied to audio data coming from a PBX. If ingressAudioGain is negative, a loss is applied. If this voice service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card, ingressAudioGain must be set to 0. If this voice service is running on any other cardtype, ingressAudioGain can be set to any integral value from -12 to +12. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in the network to ensure that the signal level from any point in the network to any other point is correct.')
vsFramerEgressGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("minus6", 0), ("minus4", 1), ("minus2", 2), ("n0", 3), ("n2", 4), ("n4", 5), ("n6", 6), ("minus12", 7), ("minus11", 8), ("minus10", 9), ("minus9", 10), ("minus8", 11), ("minus7", 12), ("minus5", 13), ("minus3", 14), ("minus1", 15), ("n1", 16), ("n3", 17), ("n5", 18), ("n7", 19), ("n8", 20), ("n9", 21), ("n10", 22), ("n11", 23), ("n12", 24))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEgressGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEgressGain.setDescription('This attribute specifies the gain in dB that is applied to data before it leaves the network. It applies to voice, modem and fax traffic. For example, egress gain is applied to audio data going to a PBX. If egressAudioGain is negative, a loss is applied. If this voice service is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card, egressAudioGain can be set to -6, -4, -2, 0, 2, 4 or 6. If this voice service is running on any other cardType, egressAudioGain can be set to any integral value from -12 to +12. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in the network to ensure that the signal level from any point in the network to any other point is correct.')
vsFramerComfortNoiseCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-78, -78), ValueRangeConstraint(-65, -65), ValueRangeConstraint(-60, -60), ValueRangeConstraint(-54, -54), ValueRangeConstraint(-52, -52), ValueRangeConstraint(-50, -50), ValueRangeConstraint(-48, -48), ValueRangeConstraint(-46, -46), ValueRangeConstraint(-44, -44), ValueRangeConstraint(-42, -42), ValueRangeConstraint(-40, -40), )).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerComfortNoiseCap.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerComfortNoiseCap.setDescription('This attribute specifies the maximum level at which comfort noise is generated. The comfort noise is limited by comfortNoiseCap before egressAudioGain is applied. The default value of -40 dBm0 equates to the maximum level of comfort noise available and effectively disables the comfortNoiseCap.')
vsFramerEchoTailDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 21), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), )).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEchoTailDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEchoTailDelay.setDescription('This attribute specifies the maximum echo canceller tail delay coverage. It should be selected higher than the summation of the round trip delay of echo and hybrid response time. A 32 msec setting is good for a radius of 2700 km, assuming that the signal is going through 4 exchanges and the hybrid response time is 6 msec. A 64 msec setting offers even greater coverage (more distance or more switches), with comparable convergence time. The recommended setting is 64 msec. This attribute is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V, J2MV, 1pE1Mvp, 1pDS1Mvp, or 1pTTC2mMvp cards.')
vsFramerEchoReturnLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 3), ValueRangeConstraint(6, 6), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEchoReturnLoss.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEchoReturnLoss.setDescription('This attribute specifies the echo return loss parameter of the echo canceller. 0 db is the normal value for most line conditions. If the line quality is poor, in terms of echo, selecting a higher value may allow the echo canceller to perform better. A side effect is that the voice level is attenuated by the same amount, which may not always be acceptable. This attribute is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V, J2MV, 1pE1Mvp, 1pDS1Mvp, or 1pTTC2mMvp card.')
vsFramerDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerDtmfRegeneration.setDescription('This attribute specifies the DTMF regeneration parameter used during negotiation with the remote end across the subnet. If dtmfRegeneration is on, it is desired that DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is desired to be generated before being sent to the link. If dtmfRegeneration is off, DTMF tones are transported transparently. DTMF regeneration is not supported on 1pDS1V, 1pE1V, and J2MV cards. dtmfRegeneration must be off if this VoiceService is running on one of these cards. The negotiated DTMF regeneration is available in negotiatedDtmfRegeneration.')
vsFramerSpeechHangoverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 500)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerSpeechHangoverTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSpeechHangoverTime.setDescription('This attribute specifies the time after the end of speech before silence suppression starts. It applies only to voice traffic. It is not used unless negotiatedIgSilenceSuppression is on, congested or slowAndCongested. Higher values of speechHangoverTime reduce undesirable clipping but increase bandwidth usage. speechHangoverTime is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V or J2MV card.')
vsFramerFaxHangoverTimeG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerFaxHangoverTimeG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFaxHangoverTimeG711G726.setDescription('This attribute specifies the time after the end of fax traffic before ingress G.711/G.726 fax idle suppression starts. It applies only if modemFaxEncoding is g711G726 or faxRelayG711G726 and negotiatedIgFisG711G726 is on. faxHangoverTimeG711G726 is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V and J2MV card.')
vsFramerModemFaxSpeechDiscrim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerModemFaxSpeechDiscrim.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerModemFaxSpeechDiscrim.setDescription('This attribute specifies whether this VoiceService differentiates modemFax traffic and speech. If modemFaxSpeechDiscrim is on and a false 2100 Hz tone is detected, this VoiceService reverts to speech mode when speech is detected. modemFaxSpeechDiscrim is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V and J2MV card.')
vsFramerV17EncodedAsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerV17EncodedAsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerV17EncodedAsG711G726.setDescription('This attribute specifies the desired negotiation between this VoiceService and V.17 fax machines when modemFaxEncoding is faxRelayG711G726. This attribute is not used unless modemFaxEncoding is faxRelayG711G726. The actual negotiation between this VoiceService and V.17 fax machines is available in negotiatedV17AsG711G726. If v17EncodedAsG711G726 is no, it is desired that V.17 fax machines be instructed to use V.29 so that V.29 fax traffic sent by fax machines can be demodulated and encoded using fax relay. If v17EncodedAsG711G726 is yes, it is desired that V.17 fax machines be permitted to use V.17 so that V.17 fax traffic sent by fax machines can be encoded using G.711 or G.726. The actual encoding performed depends on network congestion and the negotiated ingress modemFax rates, available in negotiatedIgRates.')
vsFramerEcanBypassMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g164", 0), ("g165", 1), ("never", 2))).clone('g165')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerEcanBypassMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerEcanBypassMode.setDescription('This attribute specifies when version 2 internal echo cancellers are placed in bypass mode on this VoiceService. This attribute only applies if echoCancellation is on. If ecanBypassMode is g165, the internal echo canceller is placed in bypass mode as per ITU-T G.165. If ecanBypassMode is g164, the internal echo canceller is placed in bypass mode as per ITU-T G.164. If ecanBypassMode is never, the internal echo canceller is never placed in bypass mode. This mode should only be used for debugging. This attribute does not apply to 1pE1V, 1pDS1V, J2MV, 1pE1Mvp, 1pDS1Mvp, or 1pTTC2mMvp cards.')
vsFramerMaxFaxRelayRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 12, 1, 41), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(24, 24), ValueRangeConstraint(48, 48), ValueRangeConstraint(72, 72), ValueRangeConstraint(96, 96), ValueRangeConstraint(120, 120), ValueRangeConstraint(144, 144), )).clone(144)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerMaxFaxRelayRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMaxFaxRelayRate.setDescription('This attribute specifies the maximum desired fax relay rate. This attribute only applies if modemFaxEncoding is faxRelayOnly or faxRelayG711G726. The maximum fax relay rate is negotiated and depends on the setting of maxFaxRelayRate and the fax relay capabilities on the origination side and destination side. If the negotiated fax encoding in negotiatedIgEncoding is relay, the negotiated maximum fax relay rate is available in the fax row of negotiatedIgRates.')
vsFramerSignalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13), )
if mibBuilder.loadTexts: vsFramerSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSignalTable.setDescription('This group contains attributes which define the means for transporting channel associated signalling through the network.')
vsFramerSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSignalEntry.setDescription('An entry in the vsFramerSignalTable.')
vsFramerTransmitBusyYellow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerTransmitBusyYellow.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerTransmitBusyYellow.setDescription("When this attribute is set to yes and the DS1 or E1 line is set to Channel Associated Signaling (CAS) mode, a 'busy-out' signaling condition is transmitted onto the voice timeslot associated with this Framer when its path across the network is down. The busy-out code transmitted is given by the seizeCode attribute. If transmitBusyYellow is set to yes on a CAS-based interface, seizeCode must be set. When transmitBusyYellow is set to yes and the DS1 or E1 line is set to Common Channel Signaling (CCS) mode, a yellow alarm condition is transmitted onto the DS1/E1 line when the path across the network associated with this Framer is down. Note that in CCS mode, a yellow alarm condition is transmitted when the path is down for any of the Framers with this attribute set to yes.")
vsFramerTransportSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerTransportSignalling.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerTransportSignalling.setDescription('This attribute, in combination with interpretSignalling, has been migrated to casSignalling.')
vsFramerInterpretSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerInterpretSignalling.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerInterpretSignalling.setDescription('This attribute, in combination with transportSignalling, has been migrated to casSignalling.')
vsFramerInvertBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerInvertBits.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerInvertBits.setDescription('This attribute specifies whether the ABCD bits are inverted before being output onto the link.')
vsFramerSignalBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("a", 0), ("aB", 1), ("aBCD", 2))).clone('a')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerSignalBits.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSignalBits.setDescription('This attribute identifies the combination of ABCD bits used for channel associated signalling. If casSignalling is transparent, signalBits must have the same value at both ends of a Vs. If casSignalling is transparent and signalBits does not have the same value at both ends of a Vs, the Vs will be out of service. In this case, Vs serviceFailureReason is mismatchedSignalBits.')
vsFramerTransmitCasYellow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerTransmitCasYellow.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerTransmitCasYellow.setDescription('When the associated DS1 or E1 line is operating in CCS mode, this attribute is not applicable, and must be set to no. Normally, all the VoiceService Framers associated with the same DS1 or E1 line should have the same value for this attribute. When the value is yes on all VoiceService Framers, a yellow alarm will be asserted on the port whenever loss of subnet connectivity occurs for all these VoiceServices. This will prevent the external equipment from using this port for call attempts. If this attribute is set to no for all VoiceService Framers associated with a DS1 or E1 line, a yellow alarm will never be asserted on the line for subnet connectivity reasons, agreeing with DS1/E1 port standards. If some VoiceService Framers associated with the same DS1 or E1 line have this value set to yes, and some no, a yellow alarm will be asserted on the line only if there are subnet connectivity problems for all the VoiceService Framers with the attribute transmitCasYellow set to yes. The VoiceService Framers with this attribute set to no will have no effect on whether a yellow alarm should be asserted on the line.')
vsFramerCasSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("transparent", 1), ("interpret", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerCasSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerCasSignalling.setDescription('This attribute specifies how channel associated signalling information is transported through the network. none specifies that channel associated signalling information is not transported through the network. transparent specifies signalling information is transported transparently through the network. transparent can be used when both sides are using equivalent signalling tables. interpret specifies signalling information is interpreted for idle and seize codes. interpret can be used when both sides are not using equivalent signalling tables but only require two unique codes (seize and idle) for signalling. Using a value of interpret requires correct idleCode and seizeCode attributes. interpret mode must be used if silenceSuppression is set to casIdleCode.')
vsFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 14), )
if mibBuilder.loadTexts: vsFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vsFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerStateEntry.setDescription('An entry in the vsFramerStateTable.')
vsFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vsFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vsFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vsFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15), )
if mibBuilder.loadTexts: vsFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
vsFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerStatsEntry.setDescription('An entry in the vsFramerStatsTable.')
vsFramerTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerTotalCells.setDescription('This attribute counts total cells received from the interface. Each cell contains 44 bytes of data from the DS0 channel. Since a DS0 provides data at 64 kbit/s, each cell contains 5.5 ms of audio data. This data flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
vsFramerAudioCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerAudioCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerAudioCells.setDescription('This attribute counts total cells containing audio data received from the interface. Audio data includes cells containing voice as well as modem audio but not silence. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
vsFramerSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerSilenceCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSilenceCells.setDescription('This attribute counts total cells containing silence (speech or modem/fax) data received from the interface which was not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the operation of the silence suppression feature (refer to the silenceSuppression attribute) or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
vsFramerModemCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerModemCells.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerModemCells.setDescription('This attribute is migrated into modemFaxCells.')
vsFramerCurrentEncodingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerCurrentEncodingRate.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerCurrentEncodingRate.setDescription('This attribute has been migrated to currentRate in Operational group.')
vsFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerLrcErrors.setDescription('This attribute counts the number of frames with LRC errors that are received from the network.')
vsFramerFrmLostInNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFrmLostInNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmLostInNetwork.setDescription('This attribute counts the number of frames which the service knows it did not receive from the network although they were sent in to the network from the remote end.')
vsFramerFrmUnderRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFrmUnderRuns.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmUnderRuns.setDescription('This attribute counts the number of times that a frame was needed but was not available because it had been delayed too long in the network. This error may occur repeatedly if the interface clocks at the two access points to the network are operating at different rates.')
vsFramerFrmDumped = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFrmDumped.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmDumped.setDescription('This attribute counts the number of frames which have been dumped because the output queue grew too large. This can occur if the clock rate on the incoming interface is faster than the clock rate on the outgoing interface and there are no silence periods to absorb the difference or when a compression rate change occurs. This count wraps to zero after reaching its maximum value.')
vsFramerModemSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerModemSilenceCells.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerModemSilenceCells.setDescription('This attribute is migrated into faxIdleCells.')
vsFramerTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("rejected", 1), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerTptStatus.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerTptStatus.setDescription('This attribute has been migrated to tptStatus in Operational group.')
vsFramerCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerCurrentEncoding.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerCurrentEncoding.setDescription('This attribute has been migrated to currentEncoding in Operational group.')
vsFramerRecentIngressLineSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 29), HexString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerRecentIngressLineSamples.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerRecentIngressLineSamples.setDescription('This attribute has been migrated to recentIngressLineSamples in Operational group.')
vsFramerSentMinVoiceG711G726Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerSentMinVoiceG711G726Rate.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerSentMinVoiceG711G726Rate.setDescription('This attribute has been migrated to negotiatedIgRates.')
vsFramerSentMinModemFaxG711G726Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerSentMinModemFaxG711G726Rate.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerSentMinModemFaxG711G726Rate.setDescription('This attribute has been migrated to negotiatedIgRates.')
vsFramerSentFaxIdleSuppressionG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerSentFaxIdleSuppressionG711G726.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerSentFaxIdleSuppressionG711G726.setDescription('This attribute has been migrated to negotiatedIgFisG711G726.')
vsFramerSentSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4), ("casIdleCode", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerSentSilenceSuppression.setStatus('obsolete')
if mibBuilder.loadTexts: vsFramerSentSilenceSuppression.setDescription('This attribute has been migrated to negotiatedIgSilenceSuppression.')
vsFramerFaxRelayCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFaxRelayCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFaxRelayCells.setDescription('This attribute counts total fax relay cells sent to the network.')
vsFramerModemFaxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerModemFaxCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerModemFaxCells.setDescription('This attribute counts total cells containing modem or fax data received from the interface. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
vsFramerFaxIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 15, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFaxIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFaxIdleCells.setDescription('This attribute counts total cells containing silent modem or fax data received from the interface which was not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the silence Suppression feature (refer to the silenceSuppression attribute) or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
vsFramerNegTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16), )
if mibBuilder.loadTexts: vsFramerNegTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegTable.setDescription('This group contains attributes indicating the results of end to end negotiation.')
vsFramerNegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerNegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegEntry.setDescription('An entry in the vsFramerNegTable.')
vsFramerNegotiatedIgSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4), ("casIdleCode", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNegotiatedIgSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegotiatedIgSilenceSuppression.setDescription('This attribute indicates the result of negotiating ingress silence suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in silenceSuppression. negotiatedIgSilenceSuppression can be different on either side of a VoiceService. If negotiatedIgSilenceSuppression is off, ingress silence suppression is never performed. If negotiatedIgSilenceSuppression is on, ingress silence suppression is always performed. If negotiatedIgSilenceSuppression is congested, ingress silence suppression is performed only when the network is congested. If negotiatedIgSilenceSuppression is slow, ingress silence suppression begins after 20 seconds without any speech or audio being detected. If negotiatedIgSilenceSuppression is slowAndCongested, both the slow and congested options are applied. If negotiatedIgSilenceSuppression is casIdleCode, ingress silence suppression is only performed when the idleCode is active for 20 to 40 seconds. Both transportSignalling and interpretSignalling must be set to yes if silenceSuppression is set to casIdleCode.')
vsFramerNegotiatedIgFisG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNegotiatedIgFisG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegotiatedIgFisG711G726.setDescription('This attribute indicates the result of negotiating ingress G.711/G.726 fax idle suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in faxIdleSuppressionG711G726. The value of negotiatedIgFisG711G726 can be different on either side of the connection.')
vsFramerNegotiatedDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNegotiatedDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegotiatedDtmfRegeneration.setDescription('This attribute indicates the result of negotiating DTMF regeneration with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in dtmfRegeneration. If negotiatedDtmfRegeneration is on, DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is generated before being sent to the link. If negotiatedDtmfRegeneration is off, DTMF tones are transported transparently.')
vsFramerNegotiatedV17AsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNegotiatedV17AsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegotiatedV17AsG711G726.setDescription('This attribute indicates how this VoiceService negotiates with V.17 fax machines, as determined by negotiation with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in v17EncodedAsG711G726. This attribute is irrelevant unless modemFaxEncoding is faxRelayG711G726. If negotiatedV17AsG711G726 is no, V.17 fax machines are instructed to use V.29, and V.29 fax traffic sent by fax machines is demodulated and encoded using fax relay. If negotiatedV17AsG711G726 is yes, V.17 fax machines are permitted to use V.17 and V.17 fax traffic sent by fax machines is encoded using G.711 or G.726, at the rates given in negotiatedIgRates.')
vsFramerNegotiatedTandemPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNegotiatedTandemPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNegotiatedTandemPassThrough.setDescription('This attribute indicates the result of negotiating tandem pass through with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in tandemPassThrough.')
vsFramerOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17), )
if mibBuilder.loadTexts: vsFramerOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOperTable.setDescription('This group contains the operational data for a Vs Framer.')
vsFramerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"))
if mibBuilder.loadTexts: vsFramerOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOperEntry.setDescription('An entry in the vsFramerOperTable.')
vsFramerOpCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerOpCurrentEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOpCurrentEncoding.setDescription('This attribute indicates the encoding currently being performed. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is being performed. g726 indicates that adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 is being performed. g728 indicates that the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728 is being performed. g729 indicates that the Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) algorithm defined by ITU-T G.729 is being performed. v27 indicates that the algorithm defined by ITU-T V.27 is being performed. v29 indicates that the algorithm defined by ITU-T V.29 is being performed.')
vsFramerCurrentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerCurrentRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerCurrentRate.setDescription('This attribute indicates the current encoding rate for frames being sent to the network.')
vsFramerOpTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerOpTptStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOpTptStatus.setDescription('This attribute indicates the current status of the tandem pass through algorithm. If tptStatus is operating, the tandem pass through algorithm is cutting through a voice switch. If tptStatus is monitoring, negotiatedTandemPassThrough is enabled, but the tandem pass through algorithm is not cutting through a voice switch. If tptStatus is disabled, negotiatedTandemPassThrough is disabled.')
vsFramerOpRecentIngressLineSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 17, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerOpRecentIngressLineSamples.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerOpRecentIngressLineSamples.setDescription("This attribute indicates two recent ingress line samples, represented as four hex digits. The first two hex digits give one sample. The last two hex digits give the other sample. If no call is up on this voice service's channel, each sample indicates the idle pattern sent by the adjoining PBX. Therefore, the two samples should be the same if no call is up on this voice service's channel. These samples should also be consistent each time recentIngressLineSamples is displayed, as long as no call is up on this voice service's channel. It indicates a fault on the PBX if the samples are not consistent when no call is up on this voice service's channel. If no call is up on this VoiceService's channel and the two samples are the same, each sample gives the correct setting of the provisionable attribute endOfCallPattern. Note that endOfCallPattern is not used if this VoiceService is running on a DS1V, E1V, 1pDS1V, 1pE1V and J2MV card. On these cards, recentIngressLineSamples is always 0000.")
vsFramerIdleCodeTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 204), )
if mibBuilder.loadTexts: vsFramerIdleCodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIdleCodeTable.setDescription('This attribute specifies the ABCD idle line signalling code. This attribute must be set correctly when casSignalling is interpret.')
vsFramerIdleCodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 204, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIdleCodeIndex"))
if mibBuilder.loadTexts: vsFramerIdleCodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIdleCodeEntry.setDescription('An entry in the vsFramerIdleCodeTable.')
vsFramerIdleCodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 204, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3))))
if mibBuilder.loadTexts: vsFramerIdleCodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIdleCodeIndex.setDescription('This variable represents the vsFramerIdleCodeTable specific index for the vsFramerIdleCodeTable.')
vsFramerIdleCodeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 204, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerIdleCodeValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerIdleCodeValue.setDescription('This variable represents an individual value for the vsFramerIdleCodeTable.')
vsFramerSeizeCodeTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 205), )
if mibBuilder.loadTexts: vsFramerSeizeCodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSeizeCodeTable.setDescription('This attribute specifies the ABCD seized line signalling code. This attribute must be set correctly when casSignalling is interpret.')
vsFramerSeizeCodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 205, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerSeizeCodeIndex"))
if mibBuilder.loadTexts: vsFramerSeizeCodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSeizeCodeEntry.setDescription('An entry in the vsFramerSeizeCodeTable.')
vsFramerSeizeCodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 205, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3))))
if mibBuilder.loadTexts: vsFramerSeizeCodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSeizeCodeIndex.setDescription('This variable represents the vsFramerSeizeCodeTable specific index for the vsFramerSeizeCodeTable.')
vsFramerSeizeCodeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 205, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsFramerSeizeCodeValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerSeizeCodeValue.setDescription('This variable represents an individual value for the vsFramerSeizeCodeTable.')
vsFramerFrmToNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 206), )
if mibBuilder.loadTexts: vsFramerFrmToNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmToNetworkTable.setDescription('This attribute counts the number of frames sent to the network at each encoding rate. Fax relay cells are not included.')
vsFramerFrmToNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 206, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerFrmToNetworkIndex"))
if mibBuilder.loadTexts: vsFramerFrmToNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmToNetworkEntry.setDescription('An entry in the vsFramerFrmToNetworkTable.')
vsFramerFrmToNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 206, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n64KbitS", 0), ("n32KbitS", 1), ("n24KbitS", 2), ("n16KbitS", 3), ("n8KbitS", 4))))
if mibBuilder.loadTexts: vsFramerFrmToNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmToNetworkIndex.setDescription('This variable represents the vsFramerFrmToNetworkTable specific index for the vsFramerFrmToNetworkTable.')
vsFramerFrmToNetworkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 206, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerFrmToNetworkValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerFrmToNetworkValue.setDescription('This variable represents an individual value for the vsFramerFrmToNetworkTable.')
vsFramerNEncodingTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 438), )
if mibBuilder.loadTexts: vsFramerNEncodingTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNEncodingTable.setDescription('This attribute indicates the results of negotiating ingress audio call encodings for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in voiceEncoding and modemFaxEncoding. voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. modemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. fax traffic is all traffic after a fax preamble but before speech or call release. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is the negotiated encoding. g726 indicates that Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 is the negotiated encoding. g711G726 indicates that pulse code modulation (PCM) defined by ITU-T G.711 and Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 are both negotiated encodings. If negotiatedIgEncoding is g711G726, the actual encoding performed can be either G.711 or G.726, depending on network congestion. g728 indicates that Low Delay Coded Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.728 is the negotiated encoding. g729 indicates that Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.729 is the negotiated encoding. v29V27Relay indicates that fax relay is performed using ITU-T V.27 or ITU-T V.29. v17V29V27Relay indicates that fax relay using ITU-T V.17, ITU-T V.27, or ITU-T V.29 is the negotiated encoding. If all negotiated encodings are none, the negotiation of audio call encodings is not complete.')
vsFramerNEncodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 438, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerNEncodingIndex"))
if mibBuilder.loadTexts: vsFramerNEncodingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNEncodingEntry.setDescription('An entry in the vsFramerNEncodingTable.')
vsFramerNEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 438, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: vsFramerNEncodingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNEncodingIndex.setDescription('This variable represents the vsFramerNEncodingTable specific index for the vsFramerNEncodingTable.')
vsFramerNEncodingValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 438, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 31, 64, 68, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g726", 4), ("g711", 5), ("g711G726", 31), ("v29V27Relay", 64), ("v17V29V27Relay", 68), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNEncodingValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNEncodingValue.setDescription('This variable represents an individual value for the vsFramerNEncodingTable.')
vsFramerNRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 439), )
if mibBuilder.loadTexts: vsFramerNRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNRatesTable.setDescription('This attribute indicates the results of negotiating ingress minimum and maximum rates for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in maxVoiceG711G726Rate, minVoiceG711G726Rate, maxModemFaxG711G726Rate and minModemFaxG711G726Rate. negotiatedIgRates can be different on either side of a VoiceService.')
vsFramerNRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 439, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerNRatesTrafficIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerNRatesRateIndex"))
if mibBuilder.loadTexts: vsFramerNRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNRatesEntry.setDescription('An entry in the vsFramerNRatesTable.')
vsFramerNRatesTrafficIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 439, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: vsFramerNRatesTrafficIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNRatesTrafficIndex.setDescription('This variable represents the next to last index for the vsFramerNRatesTable.')
vsFramerNRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 439, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: vsFramerNRatesRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNRatesRateIndex.setDescription('This variable represents the final index for the vsFramerNRatesTable.')
vsFramerNRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 439, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 66, 67, 68, 69, 70))).clone(namedValues=NamedValues(("n00", 0), ("n03", 1), ("n12", 2), ("n24", 3), ("n48", 4), ("n72", 5), ("n96", 6), ("n120", 7), ("n144", 8), ("n80", 66), ("n160", 67), ("n240", 68), ("n320", 69), ("n640", 70)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerNRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerNRatesValue.setDescription('This variable represents an individual value for the vsFramerNRatesTable.')
vsFramerVfpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5))
vsFramerVfpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1), )
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of vsFramerVfpDebug components.')
vsFramerVfpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerVfpDebugIndex"))
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatusEntry.setDescription('A single entry in the table represents a single vsFramerVfpDebug component.')
vsFramerVfpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsFramerVfpDebug components. These components cannot be added nor deleted.')
vsFramerVfpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerVfpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsFramerVfpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerVfpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugStorageType.setDescription('This variable represents the storage type value for the vsFramerVfpDebug tables.')
vsFramerVfpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsFramerVfpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerVfpDebugIndex.setDescription('This variable represents the index for the vsFramerVfpDebug tables.')
vsFramerMvpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6))
vsFramerMvpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1), )
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of vsFramerMvpDebug components.')
vsFramerMvpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerMvpDebugIndex"))
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatusEntry.setDescription('A single entry in the table represents a single vsFramerMvpDebug component.')
vsFramerMvpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsFramerMvpDebug components. These components cannot be added nor deleted.')
vsFramerMvpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerMvpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsFramerMvpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerMvpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugStorageType.setDescription('This variable represents the storage type value for the vsFramerMvpDebug tables.')
vsFramerMvpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsFramerMvpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerMvpDebugIndex.setDescription('This variable represents the index for the vsFramerMvpDebug tables.')
vsFramerPcmCapture = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7))
vsFramerPcmCaptureRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1), )
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatusTable.setDescription('This entry controls the addition and deletion of vsFramerPcmCapture components.')
vsFramerPcmCaptureRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsFramerPcmCaptureIndex"))
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatusEntry.setDescription('A single entry in the table represents a single vsFramerPcmCapture component.')
vsFramerPcmCaptureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsFramerPcmCapture components. These components cannot be added nor deleted.')
vsFramerPcmCaptureComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerPcmCaptureComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsFramerPcmCaptureStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsFramerPcmCaptureStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureStorageType.setDescription('This variable represents the storage type value for the vsFramerPcmCapture tables.')
vsFramerPcmCaptureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 2, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsFramerPcmCaptureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsFramerPcmCaptureIndex.setDescription('This variable represents the index for the vsFramerPcmCapture tables.')
vsPlc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3))
vsPlcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1), )
if mibBuilder.loadTexts: vsPlcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRowStatusTable.setDescription('This entry controls the addition and deletion of vsPlc components.')
vsPlcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsPlcIndex"))
if mibBuilder.loadTexts: vsPlcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRowStatusEntry.setDescription('A single entry in the table represents a single vsPlc component.')
vsPlcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsPlcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsPlc components. These components cannot be added nor deleted.')
vsPlcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsPlcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsPlcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsPlcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcStorageType.setDescription('This variable represents the storage type value for the vsPlc tables.')
vsPlcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsPlcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcIndex.setDescription('This variable represents the index for the vsPlc tables.')
vsPlcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10), )
if mibBuilder.loadTexts: vsPlcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcProvTable.setDescription('This group contains all provisionable attributes for a permanent logical connection. Note that all of the attributes are valid and provisionable on both ends of a connection. However with the exception of remoteName, all operational attributes are derived from the originating end provisioning, which may be either end unless remoteName is not provisioned on one end.')
vsPlcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsPlcIndex"))
if mibBuilder.loadTexts: vsPlcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcProvEntry.setDescription('An entry in the vsPlcProvTable.')
vsPlcRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRemoteName.setDescription("This attribute is the PLC's remote end point's address in the format of a Passport component name The syntax of a component is: 'em/node type/instance'. End points are identified using a node name and a service name. As an example, the end point component name for the third voice service on node MoonBase is: 'EM/MoonBase VS/3'. If the remoteName is provisioned it must match the remote name of the other end or the connection will not be established even if the remote end is provisioned correctly. If no remoteName is provisioned then this LC will accept connections from any other remote LC and it will not originate calls. Connections establish faster and are unique if both ends are provisioned with the remoteName. These strings are case insensitive but the complete component name must be input.")
vsPlcSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcSetupPriority.setDescription("This attribute gives the priority at which a path is established. Zero is the highest priority and four is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this attribute, indicates the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
vsPlcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcHoldingPriority.setDescription("This attribute gives the priority that a path holds once it is established. Zero is the highest priority and four is the lowest. A path's holdingPriority determines its likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
vsPlcRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000)).clone(32000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRequiredTxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second) reserved by a path on each of the trunks of its route.This attribute represents the bandwidth for traffic outgoing to the remote end point. This value should be chosen to achieve the amount of statistical bandwidth sharing that is desired by the network administration. This reservation is not enforced and is used to determine how many paths can be supported on a trunk. Both ends should be provisioned with the correct values allowing for the fact that transmit at this end represents receive at the remote end. Note that when the values do not correspond, the originating end of the connection determines the value.')
vsPlcRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000)).clone(32000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRequiredRxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second) reserved by a path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. This value should be chosen to achieve the amount of statistical bandwidth sharing that is desired by the network administration. This reservation is not enforced and is used to determine how many paths can be supported on a trunk. Both ends should be provisioned with the correct values allowing for the fact that transmit at this end represents receive at the remote end. Note that when the values do not correspond, the originating end of the connection determines the value.')
vsPlcRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7))).clone('voice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRequiredTrafficType.setDescription('This attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1, then only trunks that include trafficType1 in supportedTrafficType will be candidates for this connection.')
vsPlcPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcPermittedTrunkTypes.setDescription("This attribute lists up to eight(8) types of trunk that can be used on the route. The terrestrial and satellite trunk types have been defined, leaving six(6) remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
vsPlcRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRequiredSecurity.setDescription('This attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1, then only trunks that include trafficType1 in supportedTrafficType will be candidates for this connection.')
vsPlcRequiredCustomerParm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcRequiredCustomerParm.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcRequiredCustomerParm.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route. Its value, a number from zero to seven, is chosen by network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
vsPlcPathAttributeToMinimize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cost", 0), ("delay", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcPathAttributeToMinimize.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcPathAttributeToMinimize.setDescription('This attribute indicates whether a route is selected on the basis of minimizing the cost or the delay. Each trunk has a cost and a delay metric associated with it. The cost of a selected route is the sum of the trunk cost metrics for all trunks included in the route. The delay of a selected route is the sum of the trunk delay metric for all trunks included in the route.')
vsPlcMaximumAcceptableCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcMaximumAcceptableCost.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMaximumAcceptableCost.setDescription('This attribute indicates an upper bound on the cost metric of a route, which is the sum of the cost metrics of all trunks on the route. The cost metric is the trunkCost attribute of the Trunk component. If for any trunk the trunkCost is larger than the maximumAcceptableCost, then that trunk is not considered during the route selection. While a shortest route is being selected, the route cost is being compared with the maximumAcceptableCost attribute, and this is done for any minimization criterion. No route is selected if the cost metric of the shortest route is larger than the maximumAcceptableCost.')
vsPlcMaximumAcceptableDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcMaximumAcceptableDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMaximumAcceptableDelay.setDescription("This attribute indicates an upper bound on the delay of a route, which is the sum of the delay of all trunks on the route. It should be provisioned with a reasonable maximum acceptable delay for the end to end one way delay of a 512-byte packet. Remember, that the trunk during its staging measures a measuredRoundTripDelay. This delay is divided by two and truncated to an integer number of milliseconds to provide a one way delay which is used to populate the delay in this trunk object in the topological database. The value includes emission, propagation, and queuing delays. A 512-byte packet is used to perform the measurement. If for any trunk the half of the trunk's measuredRoundTripDelay is larger than the maximumAcceptableDelay, then that trunk is not considered during the route selection. While a shortest route is being selected, the route delay is being compared with the maximumAcceptableDelay attribute, and this is done for any minimization criterion. No route is selected if the delay metric of the shortest route is larger than the maximumAcceptableDelay.")
vsPlcEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. EmissionPriority of Zero(0) indicates the highest emission priority, while two (2) indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
vsPlcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
vsPlcPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcPathType.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcPathType.setDescription('This attribute specifies if the path for this PLC is determined automatically or by static provisioning. The default (normal) is to automatically choose a route with Route Selection. Normal pathTypes require less provisioning and can dynamically handle path failures. The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
vsPlcPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1))).clone('reRoutePath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcPathFailureAction.setDescription('This attribute is used to specify whether the application can tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is chosen, the application is informed as soon as possible about a failure by disconnection. If the attribute is set to reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends.')
vsPlcBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1))).clone('bumpWhenNecessary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcBumpPreference.setDescription('This attribute controls when bumping occurs in the route selection process. A connection with higher (numerically less) setupPriority may bump a connection with lower (numerically higher) holdingPriority in order to acquire its bandwidth and be established. By default, bumping occurs only when it is necessary. That is, a connection will bump another connection only if there is no other way for the connection to be established. A connection may be set to always bump in order to find the best route it may have.')
vsPlcOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
vsPlcMpathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 207), )
if mibBuilder.loadTexts: vsPlcMpathTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMpathTable.setDescription("This attribute is optional and specifies the sequence of trunks to be used as the route for the path, thus bypassing PORS' automatic route selection. If the path fails the validation, no other path can be selected1. This attribute should only be used in special cases since the route selection algorithm is able to find and maintain the best routes. A related path attribute, the pathType, determines if this route will be used as a manual or forced path type. As an example, the trunk component name for the third trunk on node MoonBase is 'EM/MoonBase Trk/3'. Note that only the first end of the trunk that the packet would encounter is provisioned. These strings are case insensitive but the complete component name must be input. Note 1: the trunk designation must be a 3-letter form, e.g., 'trk'. Note 2: only the outbound trunks component names are used to provision the manualPath. Note 3: It is recommended to have two independent routes specified for a manual path by specifying a different manualPath (non-symmetric) for each end. In this case, there is no way to select which route will be used (first up wins) but if one path is torn down due to a failure then the other manualPath may be used to reroute the path.")
vsPlcMpathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 207, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsPlcIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsPlcMpathIndex"))
if mibBuilder.loadTexts: vsPlcMpathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMpathEntry.setDescription('An entry in the vsPlcMpathTable.')
vsPlcMpathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 207, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)))
if mibBuilder.loadTexts: vsPlcMpathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMpathIndex.setDescription('This variable represents the vsPlcMpathTable specific index for the vsPlcMpathTable.')
vsPlcMpathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 3, 207, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsPlcMpathValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsPlcMpathValue.setDescription('This variable represents an individual value for the vsPlcMpathTable.')
vsLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4))
vsLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1), )
if mibBuilder.loadTexts: vsLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRowStatusTable.setDescription('This entry controls the addition and deletion of vsLCo components.')
vsLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsLCoIndex"))
if mibBuilder.loadTexts: vsLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRowStatusEntry.setDescription('A single entry in the table represents a single vsLCo component.')
vsLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of vsLCo components. These components cannot be added nor deleted.')
vsLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vsLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoStorageType.setDescription('This variable represents the storage type value for the vsLCo tables.')
vsLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vsLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoIndex.setDescription('This variable represents the index for the vsLCo tables.')
vsLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10), )
if mibBuilder.loadTexts: vsLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathDataTable.setDescription('This group contains all operational attributes for the path oriented LCo.')
vsLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsLCoIndex"))
if mibBuilder.loadTexts: vsLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathDataEntry.setDescription('An entry in the vsLCoPathDataTable.')
vsLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates a connection that has no remote end provisioned or the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
vsLCoOverrideRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsLCoOverrideRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoOverrideRemoteName.setDescription("If set and the current PLC remoteName is blank this remoteName will override the blank PLC remoteName. Usually you would set this attribute and then lock/unlock the service component which will result in this new overrideRemoteName being used as if it had been provisioned into the PLC remoteName. The advantage of this attribute is that the connection's remoteName can be changed immediately without having to 'activate prov' but the disadvantage is that the overrideRemoteName is not permanent and if the card or switch is reset the override will be lost.")
vsLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
vsLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
vsLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
vsLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 Millisecond when the LCo is originated and terminated on the same module.')
vsLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
vsLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
vsLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
vsLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
vsLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
vsLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
vsLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
vsLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
vsLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
vsLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
vsLCoPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPathType.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathType.setDescription('This attribute indicates whether the path for this PLC was determined automatically or by static provisioning. Normal pathTypes are selected automatically by Route Selector.The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
vsLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
vsLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully connected. It is set to zero the first time the path is up. If a path fails anytime after connecting this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount above. This attribute stops counting at its maximum value.')
vsLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory. Perhaps two reasons for no route require some explanation. The reason unknownRemoteNodeName is issued when the remote node name is not in the topological database. The reason plcAttributesNotMet is issued when there is no network connectivity at a level specified by the PLC attributes. This reason is also issued when there is no physical connectivity between two end nodes.")
vsLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may give an indication to the reason that the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown this is typical of a path provisioned with no remoteName that has not been up. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PA's at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LC's). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing check remoteName. farEndBusy - The far end has been reached but it is busy. Check remoteName and remote end provisioning. callLoopedBack - This LCo is provisioned to call itself. Re- provision since this is invalid. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. remoteNameMismatch - The remote end has alarmed and rejected this setup due to remoteName provisioning. serviceTypeMismatch - The remote Service Type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active this just indicates why the path changed. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on TRUNK PA ATM component. Map mode was required by the application (CES/FrAtm etc.) but was not available on the TRUNK PA ATM component through which the call was routed or the far end CES/FrAtm component did not specify the same mode.")
vsLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends')
vsLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose setupPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
vsLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
vsLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
vsLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11), )
if mibBuilder.loadTexts: vsLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoStatsTable.setDescription('This group contains the operational statistics attributes for the path oriented LCo.')
vsLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsLCoIndex"))
if mibBuilder.loadTexts: vsLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoStatsEntry.setDescription('An entry in the vsLCoStatsTable.')
vsLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
vsLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
vsLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network.')
vsLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network.')
vsLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 264), )
if mibBuilder.loadTexts: vsLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathTable.setDescription('This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
vsLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 264, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VoiceMIB", "vsIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsLCoIndex"), (0, "Nortel-Magellan-Passport-VoiceMIB", "vsLCoPathValue"))
if mibBuilder.loadTexts: vsLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathEntry.setDescription('An entry in the vsLCoPathTable.')
vsLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 80, 4, 264, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: vsLCoPathValue.setDescription('This variable represents both the value and the index for the vsLCoPathTable.')
voiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 1))
voiceGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 1, 5))
voiceGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 1, 5, 2))
voiceGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 1, 5, 2, 2))
voiceCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 3))
voiceCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 3, 5))
voiceCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 3, 5, 2))
voiceCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 49, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-VoiceMIB", vsSnmpOperStatus=vsSnmpOperStatus, vsLCoRowStatus=vsLCoRowStatus, voiceGroupBE=voiceGroupBE, vsFramerVfpDebugIndex=vsFramerVfpDebugIndex, vsFramerInterfaceName=vsFramerInterfaceName, vsIfIndex=vsIfIndex, vsFramerStateEntry=vsFramerStateEntry, vsPlcPermittedTrunkTypes=vsPlcPermittedTrunkTypes, vsLCoState=vsLCoState, vsLCoRequiredRxBandwidth=vsLCoRequiredRxBandwidth, vsFramer=vsFramer, vsPlcProvTable=vsPlcProvTable, voiceCapabilitiesBE=voiceCapabilitiesBE, vsFramerPcmCaptureRowStatus=vsFramerPcmCaptureRowStatus, vsIfEntryTable=vsIfEntryTable, vsFramerNRatesEntry=vsFramerNRatesEntry, voiceGroupBE01A=voiceGroupBE01A, vsFramerModemFaxSpeechDiscrim=vsFramerModemFaxSpeechDiscrim, vsPlcOptimization=vsPlcOptimization, vsFramerUsageState=vsFramerUsageState, vsFramerVoiceEncoding=vsFramerVoiceEncoding, vsFramerMvpDebugRowStatus=vsFramerMvpDebugRowStatus, vsFramerRowStatus=vsFramerRowStatus, vsUnknownStatus=vsUnknownStatus, vsPlcMpathValue=vsPlcMpathValue, vsFramerStateTable=vsFramerStateTable, vsLCoDiscardPriority=vsLCoDiscardPriority, vsLCoPathUpDateTime=vsLCoPathUpDateTime, vsFramerNegotiatedIgFisG711G726=vsFramerNegotiatedIgFisG711G726, vsLCoReasonForNoRoute=vsLCoReasonForNoRoute, vsFramerInterpretSignalling=vsFramerInterpretSignalling, vsFramerCurrentRate=vsFramerCurrentRate, vsPlcProvEntry=vsPlcProvEntry, vsRowStatusEntry=vsRowStatusEntry, vsFramerNRatesTable=vsFramerNRatesTable, vsFramerPcmCaptureComponentName=vsFramerPcmCaptureComponentName, vsFramerFrmToNetworkValue=vsFramerFrmToNetworkValue, vsLCoComponentName=vsLCoComponentName, vsLCoPathFailureCount=vsLCoPathFailureCount, vsLCoPathTable=vsLCoPathTable, vsLCoRoundTripDelay=vsLCoRoundTripDelay, vsFramerNEncodingTable=vsFramerNEncodingTable, vsLCoStatsTable=vsLCoStatsTable, vsFramerSignalTable=vsFramerSignalTable, vsFramerVfpDebugRowStatusEntry=vsFramerVfpDebugRowStatusEntry, vsFramerCoderEntry=vsFramerCoderEntry, vsPlcRequiredTxBandwidth=vsPlcRequiredTxBandwidth, vsFramerInsertedOutputDelay=vsFramerInsertedOutputDelay, vsFramerOperTable=vsFramerOperTable, vsFramerMvpDebug=vsFramerMvpDebug, vsPlcMaximumAcceptableCost=vsPlcMaximumAcceptableCost, vsFramerComfortNoiseCap=vsFramerComfortNoiseCap, vsOperStatusTable=vsOperStatusTable, vsPlcRowStatus=vsPlcRowStatus, vsFramerRowStatusTable=vsFramerRowStatusTable, vsFramerFrmLostInNetwork=vsFramerFrmLostInNetwork, vsFramerSeizeCodeValue=vsFramerSeizeCodeValue, vsFramerMvpDebugRowStatusTable=vsFramerMvpDebugRowStatusTable, vsRowStatusTable=vsRowStatusTable, vsLCoDelayMetric=vsLCoDelayMetric, vsFramerIdleCodeEntry=vsFramerIdleCodeEntry, vsFramerCoderTable=vsFramerCoderTable, voiceMIB=voiceMIB, vsIfAdminStatus=vsIfAdminStatus, vsServiceFailureReason=vsServiceFailureReason, vsFramerStorageType=vsFramerStorageType, vsFramerVfpDebugRowStatus=vsFramerVfpDebugRowStatus, vsLCoRowStatusTable=vsLCoRowStatusTable, vsRowStatus=vsRowStatus, vsFramerDtmfRegeneration=vsFramerDtmfRegeneration, vsFramerAdminState=vsFramerAdminState, vsFramerCurrentEncoding=vsFramerCurrentEncoding, vsProceduralStatus=vsProceduralStatus, vsFramerStatsTable=vsFramerStatsTable, vsLCoOverrideRemoteName=vsLCoOverrideRemoteName, vsStandbyStatus=vsStandbyStatus, vsFramerRowStatusEntry=vsFramerRowStatusEntry, vsFramerNegotiatedV17AsG711G726=vsFramerNegotiatedV17AsG711G726, vsFramerNEncodingValue=vsFramerNEncodingValue, vsFramerFaxEncoding=vsFramerFaxEncoding, vsFramerStatsEntry=vsFramerStatsEntry, vsFramerPcmCapture=vsFramerPcmCapture, vsLCoEmissionPriority=vsLCoEmissionPriority, vsFramerEndOfCallPattern=vsFramerEndOfCallPattern, vsFramerMvpDebugComponentName=vsFramerMvpDebugComponentName, vsPlcBumpPreference=vsPlcBumpPreference, vsLCoPathDataEntry=vsLCoPathDataEntry, vsFramerOperEntry=vsFramerOperEntry, voiceCapabilitiesBE01A=voiceCapabilitiesBE01A, vsFramerProvTable=vsFramerProvTable, vsFramerMaxModemBitRate=vsFramerMaxModemBitRate, voiceCapabilities=voiceCapabilities, vsOperStatusEntry=vsOperStatusEntry, vsFramerEgressAudioGain=vsFramerEgressAudioGain, vsFramerIdleCodeValue=vsFramerIdleCodeValue, vsStorageType=vsStorageType, vsPlcRemoteName=vsPlcRemoteName, vsFramerSeizeCodeEntry=vsFramerSeizeCodeEntry, vsStateEntry=vsStateEntry, vsFramerTptStatus=vsFramerTptStatus, vsFramerNegTable=vsFramerNegTable, vsFramerFrmToNetworkIndex=vsFramerFrmToNetworkIndex, vsPlcHoldingPriority=vsPlcHoldingPriority, vsPlcPathType=vsPlcPathType, vsLCoStatsEntry=vsLCoStatsEntry, voiceCapabilitiesBE01=voiceCapabilitiesBE01, vsOperationalTable=vsOperationalTable, vsFramerSeizeCodeIndex=vsFramerSeizeCodeIndex, vsLCoRequiredTxBandwidth=vsLCoRequiredTxBandwidth, vsFramerNegEntry=vsFramerNegEntry, vsFramerNRatesValue=vsFramerNRatesValue, vsLCoEnd=vsLCoEnd, vsFramerIdleCodeTable=vsFramerIdleCodeTable, vsCidDataTable=vsCidDataTable, vsFramerFaxRelayCells=vsFramerFaxRelayCells, vsFramerEchoReturnLoss=vsFramerEchoReturnLoss, vsLCoPathType=vsLCoPathType, vsLCoPktsFromNetwork=vsLCoPktsFromNetwork, vsFramerSentMinVoiceG711G726Rate=vsFramerSentMinVoiceG711G726Rate, voiceGroup=voiceGroup, vsFramerMvpDebugIndex=vsFramerMvpDebugIndex, vsLCoStorageType=vsLCoStorageType, vsFramerIdleCodeIndex=vsFramerIdleCodeIndex, vsFramerModemCells=vsFramerModemCells, vsFramerCasSignalling=vsFramerCasSignalling, vsAvailabilityStatus=vsAvailabilityStatus, vsFramerOpRecentIngressLineSamples=vsFramerOpRecentIngressLineSamples, vsPlcIndex=vsPlcIndex, vsFramerNEncodingEntry=vsFramerNEncodingEntry, vsUsageState=vsUsageState, vsFramerPcmCaptureStorageType=vsFramerPcmCaptureStorageType, vsFramerNegotiatedIgSilenceSuppression=vsFramerNegotiatedIgSilenceSuppression, vsPlcRequiredSecurity=vsPlcRequiredSecurity, vsPlcRequiredCustomerParm=vsPlcRequiredCustomerParm, vsPlc=vsPlc, vsFramerSilenceCells=vsFramerSilenceCells, vsFramerSeizeCodeTable=vsFramerSeizeCodeTable, vsFramerSignalBits=vsFramerSignalBits, vsLCoOptimization=vsLCoOptimization, vsComponentName=vsComponentName, vsFramerMaxFaxRelayRate=vsFramerMaxFaxRelayRate, vsFramerAudioCells=vsFramerAudioCells, vsFramerVfpDebugStorageType=vsFramerVfpDebugStorageType, vsLCoBumpPreference=vsLCoBumpPreference, vsFramerEchoTailDelay=vsFramerEchoTailDelay, vsFramerEgressGain=vsFramerEgressGain, vsFramerTransmitBusyYellow=vsFramerTransmitBusyYellow, vsLCoRetryCount=vsLCoRetryCount, vsIfEntryEntry=vsIfEntryEntry, vsFramerAudioGain=vsFramerAudioGain, vsPlcSetupPriority=vsPlcSetupPriority, vsStateTable=vsStateTable, vsFramerMaxVoiceBitRate=vsFramerMaxVoiceBitRate, vsOperationalState=vsOperationalState, vsFramerOperationalState=vsFramerOperationalState, vsIndex=vsIndex, vsLCoLastTearDownReason=vsLCoLastTearDownReason, vsOperationalEntry=vsOperationalEntry, vsPlcMaximumAcceptableDelay=vsPlcMaximumAcceptableDelay, vsPlcEmissionPriority=vsPlcEmissionPriority, vsFramerSpeechHangoverTime=vsFramerSpeechHangoverTime, vsFramerLrcErrors=vsFramerLrcErrors, vsFramerTransmitCasYellow=vsFramerTransmitCasYellow, vsFramerMinVoiceBitRate=vsFramerMinVoiceBitRate, vsFramerNegotiatedTandemPassThrough=vsFramerNegotiatedTandemPassThrough, vsPlcComponentName=vsPlcComponentName, vsFramerMinModemBitRate=vsFramerMinModemBitRate, vsFramerModemFaxCells=vsFramerModemFaxCells, vsLCoPathValue=vsLCoPathValue, vsLCoPermittedTrunkTypes=vsLCoPermittedTrunkTypes, vsFramerTandemPassThrough=vsFramerTandemPassThrough, vsFramerEcanBypassMode=vsFramerEcanBypassMode, vsFramerNRatesTrafficIndex=vsFramerNRatesTrafficIndex, vsFramerSentFaxIdleSuppressionG711G726=vsFramerSentFaxIdleSuppressionG711G726, vsLCo=vsLCo, vsLCoRequiredCustomerParameter=vsLCoRequiredCustomerParameter, vsFramerNEncodingIndex=vsFramerNEncodingIndex, vsFramerTotalCells=vsFramerTotalCells, vsFramerALawConversion=vsFramerALawConversion, voiceGroupBE01=voiceGroupBE01, vsAdminState=vsAdminState, vsFramerFrmDumped=vsFramerFrmDumped, vsFramerComponentName=vsFramerComponentName, vsFramerNRatesRateIndex=vsFramerNRatesRateIndex, vsFramerPcmCaptureIndex=vsFramerPcmCaptureIndex, vsFramerNegotiatedDtmfRegeneration=vsFramerNegotiatedDtmfRegeneration, vsLCoIndex=vsLCoIndex, vsLCoBytesToNetwork=vsLCoBytesToNetwork, vsFramerOpTptStatus=vsFramerOpTptStatus, vsPlcRequiredTrafficType=vsPlcRequiredTrafficType, vsFramerRecentIngressLineSamples=vsFramerRecentIngressLineSamples, vsLCoRowStatusEntry=vsLCoRowStatusEntry, vsLCoHoldingPriority=vsLCoHoldingPriority, vsPlcPathFailureAction=vsPlcPathFailureAction, vsFramerIngressAudioGain=vsFramerIngressAudioGain, vsFramerTransportSignalling=vsFramerTransportSignalling, vsCidDataEntry=vsCidDataEntry, vsCustomerIdentifier=vsCustomerIdentifier, vsFramerIndex=vsFramerIndex, vsFramerProvEntry=vsFramerProvEntry, vsPlcMpathIndex=vsPlcMpathIndex, vsFramerMvpDebugStorageType=vsFramerMvpDebugStorageType, vsLCoCostMetric=vsLCoCostMetric, vsFramerSignalEntry=vsFramerSignalEntry, vsFramerFaxIdleCells=vsFramerFaxIdleCells, vsFramerVfpDebugRowStatusTable=vsFramerVfpDebugRowStatusTable, vsFramerPcmCaptureRowStatusTable=vsFramerPcmCaptureRowStatusTable, vsFramerPcmCaptureRowStatusEntry=vsFramerPcmCaptureRowStatusEntry, vsFramerSentMinModemFaxG711G726Rate=vsFramerSentMinModemFaxG711G726Rate, vsLCoRequiredSecurity=vsLCoRequiredSecurity, vsFramerOpCurrentEncoding=vsFramerOpCurrentEncoding, vsPlcRequiredRxBandwidth=vsPlcRequiredRxBandwidth, vsFramerFrmUnderRuns=vsFramerFrmUnderRuns, vsPlcRowStatusEntry=vsPlcRowStatusEntry, vsPlcMpathEntry=vsPlcMpathEntry, vsPlcRowStatusTable=vsPlcRowStatusTable, vsFramerFrmToNetworkTable=vsFramerFrmToNetworkTable, vsPlcMpathTable=vsPlcMpathTable, vsLCoSetupPriority=vsLCoSetupPriority, vsControlStatus=vsControlStatus, vsFramerSilenceSuppression=vsFramerSilenceSuppression, vsFramerCurrentEncodingRate=vsFramerCurrentEncodingRate, vsFramerEchoCancellation=vsFramerEchoCancellation, vsFramerModemSilenceCells=vsFramerModemSilenceCells, vsPlcStorageType=vsPlcStorageType, vsLCoBytesFromNetwork=vsLCoBytesFromNetwork, vsFramerVfpDebugComponentName=vsFramerVfpDebugComponentName, vsFramerFaxHangoverTimeG711G726=vsFramerFaxHangoverTimeG711G726, vsPlcPathAttributeToMinimize=vsPlcPathAttributeToMinimize, vsLCoRequiredTrafficType=vsLCoRequiredTrafficType, vsLCoPathFailureAction=vsLCoPathFailureAction, vsFramerMvpDebugRowStatusEntry=vsFramerMvpDebugRowStatusEntry, vsPlcDiscardPriority=vsPlcDiscardPriority, vs=vs, vsLCoPathDataTable=vsLCoPathDataTable, vsLCoPathEntry=vsLCoPathEntry, vsFramerV17EncodedAsG711G726=vsFramerV17EncodedAsG711G726, vsAlarmStatus=vsAlarmStatus, vsFramerFaxIdleSuppressionG711G726=vsFramerFaxIdleSuppressionG711G726, vsFramerInvertBits=vsFramerInvertBits, vsFramerFrmToNetworkEntry=vsFramerFrmToNetworkEntry, vsFramerVfpDebug=vsFramerVfpDebug, vsLCoPktsToNetwork=vsLCoPktsToNetwork, vsFramerSentSilenceSuppression=vsFramerSentSilenceSuppression)

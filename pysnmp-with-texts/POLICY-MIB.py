#
# PySNMP MIB module POLICY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/POLICY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:09:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
lannet, = mibBuilder.importSymbols("GEN-MIB", "lannet")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Counter32, ModuleIdentity, MibIdentifier, Integer32, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, iso, Gauge32, IpAddress, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "ModuleIdentity", "MibIdentifier", "Integer32", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "iso", "Gauge32", "IpAddress", "TimeTicks", "ObjectIdentity")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

ipPolicyMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 36))
ipPolicyListTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 1), )
if mibBuilder.loadTexts: ipPolicyListTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListTable.setDescription('This table is used to add/delete/monitor policy lists. This table maintains a list of policy lists in the system. Each POLICY list is made up of a group of policy rules. The policy rules are stored in the ipPolicyRuleTable. Number of lists in a device (both in run-time and in NVRAM) is not part of the syntax of this mib. This is a device issue that should be agreed between the device and the managment applications and should be specified in the device and/or managment Spec. RNR for example needs 3 lists : 1 for validation + 2 for activation')
ipPolicyListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 1, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyListSlot"), (0, "POLICY-MIB", "ipPolicyListID"))
if mibBuilder.loadTexts: ipPolicyListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListEntry.setDescription('The information concerning one of the IP policy lists')
ipPolicyListSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListSlot.setDescription('The slot-id (AKA module-id / box number) to which this list relates')
ipPolicyListID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListID.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListID.setDescription('The ID of the list. Lists 100-149 are for a local policy manager use (for example CLI or Routing Manager). Lists 150-199 are for a remote policy manager use (for example RNR).')
ipPolicyListName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyListName.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListName.setDescription('Name of this list. Default name is: list #N ')
ipPolicyListValidityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("partiallyValid", 2), ("invalid", 3), ("validationInProgress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListValidityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListValidityStatus.setDescription('Validity status of this list: valid - For all rules in the list: ipPolicyRuleApplicabilityStatus = applicable partiallyValid - in One or more rules in the list ipPolicyRuleApplicabilityPrecedence < 9999 (not mandatory) and ipPolicyRuleApplicabilityStatus != applicable In all other rules (if any) : ipPolicyRuleApplicabilityStatus=applicable invalid - In One or more rules in the list ipPolicyRuleApplicabilityPrecedence=9999 (mandatory) and ipPolicyRuleApplicabilityStatus != applicable validationInProgress - The current validity of the list is currently computed. Managment station should poll the device until one of the definitive values is returned.')
ipPolicyListChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListChecksum.setStatus('obsolete')
if mibBuilder.loadTexts: ipPolicyListChecksum.setDescription('Checksum of all the configurable (read/write) mib items that are part of this list or part of any rule that belongs to this list. Addition/deletion/modification of a rule in this list shall result in a checksum change. This field can be used by the management application to discover this list has changed (instead of polling all the rules of the list).')
ipPolicyListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListRowStatus.setDescription('Used for creation/deletion of a list and for monitoring list status. Use CreateAndWait (5) to create a list. Destroy (6) to destroy a list. The active list can NOT be destroyed. Destroying a list automatically removes all the rules in this list. active (1) is returned when a list is the active list NotInService is returned when the list is not the active list')
ipPolicyListDefaultOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("forwardPriority0", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("forward", 9), ("deny", 10), ("denyAndNotify", 11), ("layer2Switching", 12))).clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyListDefaultOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListDefaultOperation.setDescription('The operation that should be applied to a packet in case the packet does not match any of the user specified rules. Some of the values are Access Control operations and some are priority operations.')
ipPolicyListCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyListCookie.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListCookie.setDescription('A cookie to be associated with this list. This mib item can be used by the management application as a unique ID of the list. Note: The Agent is not aware of the contents of this cookie. Its only purpose is to help the managment application. Changing this cookie resets ipPolicyListTrackChanges to notChanged state. A value of 0 means Cookie not available.')
ipPolicyListTrackChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListTrackChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListTrackChanges.setDescription('Counts the number of changes made to the configuration of the list including changes to the rules that are part of the list. This counters is set to 0 when the list is being created. It is also set to 0 when ipPolicyListCookie is changed. This mib item together with the ipPolicyListCookie can be used by the management application to determine if this policy list was changed, and if two instances of this list on different devices are the same.')
ipPolicyListOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyListOwner.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListOwner.setDescription('The entity that configured this list')
ipPolicyListErrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyListErrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyListErrMsg.setDescription('Free text describing the reason why the list is not valid. When the list is valid returns NULL string. The values returned for this MIB are not affected by the list status (active/inactive).')
ipPolicyRuleTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 2), )
if mibBuilder.loadTexts: ipPolicyRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleTable.setDescription('This table is used to add/delete/modify/monitor individual policy rules in a policy list.')
ipPolicyRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 2, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyRuleSlot"), (0, "POLICY-MIB", "ipPolicyRuleListID"), (0, "POLICY-MIB", "ipPolicyRuleID"))
if mibBuilder.loadTexts: ipPolicyRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleEntry.setDescription('Controls all the conditional fields and its parameters for a policy rule.')
ipPolicyRuleSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleSlot.setDescription('The slot-id (AKA module-id / box number) to which this rule relates')
ipPolicyRuleListID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleListID.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleListID.setDescription('The ID of the list this rule is part of. Lists 150-199 are for RNR use.')
ipPolicyRuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleID.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleID.setDescription('Number of rule within its list. Each list may contain many rule. Lists work in a First Match manner. A rule with a lower ID would be preferred over a rule with a higher ID.')
ipPolicyRuleSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleSrcAddr.setDescription("The IP address of the source station. A value of 255.255.255.255 in ipPolicyRuleSrcAddrWild indicates this is a DON'T CARE field.")
ipPolicyRuleSrcAddrWild = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 5), IpAddress().clone(hexValue="FFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleSrcAddrWild.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleSrcAddrWild.setDescription('This field specifies the wildcard of the source IP address. Note that a the mask for a single host is 0.0.0.0 and the mask for all hosts is 255.255.255.255. This field can has any combination of bits set allowing all kind of rules. For example ipPolicyRuleSrcAddr=192.168.0.254, ipPolicyRuleSrcAddrWild=0.0.255.0 matches all packets with source ip address 192.168.*.254')
ipPolicyRuleDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleDstAddr.setDescription("The IP address of the destination station. A value of 255.255.255.255 in ipPolicyRuleDstAddrWild indicates this is a DON'T CARE field.")
ipPolicyRuleDstAddrWild = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 7), IpAddress().clone(hexValue="FFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleDstAddrWild.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleDstAddrWild.setDescription('This field specifies the wildcard of the destination IP address. Note that a the mask for a single host is 0.0.0.0 and the mask for all hosts is 255.255.255.255. This field can has any combination of bits set allowing all kind of rules. For example ipPolicyRuleDstAddr=192.168.0.254, ipPolicyRuleDstAddrWild=0.0.255.0 matches all packets with destination ip address 192.168.*.254')
ipPolicyRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleProtocol.setDescription("The IP protocol to which this rule relates. Use 256 to specify IP (i.e. don't care)")
ipPolicyRuleL4SrcPortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleL4SrcPortMin.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleL4SrcPortMin.setDescription('The minimal source port number. This fields is applicable only when ipPolicyRuleProtocol is TCP(6) UDP(17). In all other cases its values is not used.')
ipPolicyRuleL4SrcPortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleL4SrcPortMax.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleL4SrcPortMax.setDescription('The maximal source port number. This fields is applicable only when ipPolicyRuleProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyRuleL4DestPortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleL4DestPortMin.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleL4DestPortMin.setDescription('The minimal destination port number. This fields is applicable only when ipPolicyRuleProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyRuleL4DestPortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleL4DestPortMax.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleL4DestPortMax.setDescription('The maximal destination port number. This fields is applicable only when ipPolicyRuleProtocol is TCP(6) or UDP(17). In all other cases its value is not used.')
ipPolicyRuleEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("dontCare", 2))).clone('dontCare')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleEstablished.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleEstablished.setDescription('This field indicates the value of the established bit in the TCP header. If protocol is not TCP this values is not used.')
ipPolicyRuleOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("forwardPriority0", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("forward", 9), ("deny", 10), ("denyAndNotify", 11), ("layer2Switching", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleOperation.setDescription('The operation that should be applied to a packet in case the packet matches the rule. Some of the values are Access Control operations and some are priority operations.')
ipPolicyRuleApplicabilityPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999)).clone(9999)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityPrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityPrecedence.setDescription('This field indicates how important is it to enforce this rule. The higher the number the more important it is to enforce this rule. The value 9999 has a special meaning of Mandatory which means this rule MUST be enforced. Note: Access control rules are probably Mandatory rule where as QoS rules might be configured by the user as optional rules in some cases. Device may choose to support only a subset of these values. P333R supports two values: 9999 - Mandatory rule 0 - Optional rule.')
ipPolicyRuleApplicabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("applicable", 1), ("partiallyApplicable", 2), ("notApplicable", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityStatus.setDescription('Used to monitor if a rule is currently applicable (for the active list) or would be applicable (if the list becomes active). The values returned for this MIB are not affected by the list status active/inactive) applicable - This rule is/would be applicable partiallyApplicable - This rule is/would be applicable for some packets/sessions but might not be applicable for other packets/sessions notApplicable - This rule is NOT/would NOT be applicable unknown - Status is temporary unknown. This may be because the list validation is inProgress. Querying this item triggeres list validation if not already triggered.')
ipPolicyRuleApplicabilityType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("quasiStatic", 2), ("dynamic", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityType.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleApplicabilityType.setDescription('Used to monitor the ApplicabilityStatus of the rule in the context of this list. The values returned for this MIB are not affected by the list status (active/inactive) static - The applicabilityStatus of this rule is guaranteed regardless of the ApplicabilityPrecedence of this rule or of other rules in the list. quasiStatic - The applicability status of this rule is guaranteed if no configuration changes are made, BUT changes of ApplicabilityPrecedence of this rule or other rules in this list may change the applicabilityStatus of this rule. dynamic - The applicabilityStatus of this rule can change depending on network conditions (i.e. localization) or other conditions such as (but not limited to) changes of ApplicabilityPrecedence of this rule or other rules in this list. unknown - Status is temporary unknown. This may be because the list validation is inProgress. Querying this item triggeres list validation if not already triggered. The values returned for this MIB are not affected by the list status (active/inactive)')
ipPolicyRuleErrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyRuleErrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleErrMsg.setDescription('Free text describing the reason why the rule is not Applicable. When rule is Applicable returns NULL string. The values returned for this MIB are not affected by the list status (active/inactive)')
ipPolicyRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 19), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleStatus.setDescription('Used to configure and monitor one rule. Use CreateAndWait (4) to create a rule. Destroy (6) to destroy a rule active (1) is returned when a rule is complete and is configured into device HW NotReady (3) is returned when not all mandatory fields in the rule have been configured or the rule is not valid. Not In Service (2) is returned when the rule is not active because the list is not active or device lacks resources to support the rule')
ipPolicyRuleDSCPOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyRuleDSCPOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyRuleDSCPOperation.setDescription('The New DSCP value that should be applied to packets that meatch this rule. A value of 64 means no change.')
ipPolicyControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 3), )
if mibBuilder.loadTexts: ipPolicyControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlTable.setDescription('This table activates & monitors the policy application')
ipPolicyControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 3, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyControlSlot"))
if mibBuilder.loadTexts: ipPolicyControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlEntry.setDescription('Each entry relates to one slot (AKA module / box) in the stack')
ipPolicyControlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyControlSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlSlot.setDescription('The slot-id (AKA module-id / box number) to which this control entry relates')
ipPolicyControlActiveGeneralList = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyControlActiveGeneralList.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlActiveGeneralList.setDescription('The ipPolicyListID of the Active general policy List on this slot. A value of Zero means there is no active list. If the new list can not be activated the old list continues to be active')
ipPolicyControlAllowedPolicyManagers = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2))).clone('remote')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyControlAllowedPolicyManagers.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlAllowedPolicyManagers.setDescription('Specify if who is allowed to configure policy on the device. local - a local policy manager is allowed to configure (using CLI or SNMP) remote - A remote policy manger is allowed to configure (using CLI or SNMP) The distinction between local & remote managers is done according to the List ID. Local & Remote managers use different ranges. When changing the value of this item, device may choose from resources or other reasons to automatically remove all or some of the lists that were configured bt the previous type of manager.')
ipPolicyControlCurrentChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyControlCurrentChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlCurrentChecksum.setDescription('Checksum of the entire CURRENT Policy Database including (but not limited to) the following : o ipPolicyControlActiveGeneralList o ipPolicyControlAllowedPolicyManagers o ipPolicyListCookie & ipPolicyListTrackChanges of the active list (if exists) o ipPolicyDiffServControlChecksum o routeGroupRouterMode additional configuration fields that are important enough to cause re-configuration by RNR. Any change in any of the above policy parmeters shall result in a change in the value of this field. Polling of this value shall reveal any change of policy configuration without the need for polling of the entire policy database.')
ipPolicyControlMinimalPolicyManagmentVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyControlMinimalPolicyManagmentVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlMinimalPolicyManagmentVersion.setDescription("The minimal policy management version that this device inter operates with as verified by actual testing. For example: The P330R/340/130 shall return 1.1 (if testing succeeds). The special value 'none' means that the device does not know of any RNR version with which it works (because there was no RNR release with which testing actually succeeded).")
ipPolicyControlMaximalPolicyManagmentVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyControlMaximalPolicyManagmentVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyControlMaximalPolicyManagmentVersion.setDescription("The maximal policy management version that this device inter operates with as verified by actual testing. For example: The P330R/340/130 shall return 1.1 (if testing succeeds). P360 for example may return 2.0 because it shall support features that are only supported in RNR 2.0. The special value 'none' means that the device does not know of any RNR version with which it works (because there was no RNR release with which testing actually succeeded).")
ipPolicyDiffServTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 4), )
if mibBuilder.loadTexts: ipPolicyDiffServTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServTable.setDescription('This table is used to configure the policy that is associated with differntiated services. For each DSCP value the table contain the operation that should applied to packets that match this DSCP value. Note that in this version of this mib, allowed policies are restricted to prioirty levels and access control. Note: The ietf notion of PHB (per-hop forwarding behaviors) is not yet supported')
ipPolicyDiffServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 4, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyDiffServSlot"), (0, "POLICY-MIB", "ipPolicyDiffServDSCP"))
if mibBuilder.loadTexts: ipPolicyDiffServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServEntry.setDescription('The information concerning one of the IP policy lists')
ipPolicyDiffServSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServSlot.setDescription('The slot-id (AKA module-id / box number) to which diff-serv table relates')
ipPolicyDiffServDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServDSCP.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServDSCP.setDescription('The DSCP value to which this entry relates.')
ipPolicyDiffServOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("forwardPriority0", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("forwardNoChange", 9), ("deny", 10), ("denyAndNotify", 11))).clone('forwardNoChange')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyDiffServOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServOperation.setDescription('The operation that should be applied to a packet with the specified DSCP value. Some of the values are Access Control operations and some are priority operations.')
ipPolicyDiffServName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyDiffServName.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServName.setDescription('Name of this DSCP entry. This fields is used only for documentation purposes. Default name is: DSCP #N ')
ipPolicyDiffServAggIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyDiffServAggIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ipPolicyDiffServAggIndex.setDescription('Index of the aggregated group this DSCP entry belongs too. Management station may use this mib item to classify the DSCP entries to groups with the same behaviour. The defval for this mib item is device specific.')
ipPolicyDiffServApplicabilityPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999)).clone(9999)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityPrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityPrecedence.setDescription('This field indicates how important is it to enforce this entry. The higher the number the more important it is to enforce this entry. The value 9999 has a special meaning of Mandatory which means this entry MUST be enforced. Device may choose to support only a subset of these values..')
ipPolicyDiffServApplicabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("applicable", 1), ("partiallyApplicable", 2), ("notApplicable", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityStatus.setDescription('Used to monitor if a DSCP entry is currently applicable or would be applicable (if the table becomes active). The values returned for this MIB are not affected by the table status active/inactive) applicable - This entry is/would be applicable partiallyApplicable - This entry is/would be applicable for some packets/sessions but might not be applicable for other packets/sessions notApplicable - This entry is NOT/would NOT be applicable unknown - Status is temporary unknown. This may be because the table validation is inProgress. Querying this item triggeres table validation if not already triggered.')
ipPolicyDiffServApplicabilityType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("quasiStatic", 2), ("dynamic", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityType.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServApplicabilityType.setDescription('Used to monitor the ApplicabilityStatus of the entry in the context of this table. The values returned for this MIB are not affected by the table status (active/inactive). static - The applicabilityStatus of this entry is guaranteed regardless of the ApplicabilityPrecedence of this entry or of other entries in the list. quasiStatic - The applicability status of this entry is guaranteed if no configuration changes are made, BUT changes of ApplicabilityPrecedence of this entry or other entries in this table may change the applicabilityStatus of this entry. dynamic - The applicabilityStatus of this entry can change depending on network conditions (i.e. localization) or other conditions such as (but not limited to) changes of ApplicabilityPrecedence of this entry or other entries in this table. unknown - Status is temporary unknown. This may be because the table validation is inProgress. Querying this item triggeres table validation if not already triggered. The values returned for this MIB are not affected by the table status (active/inactive)')
ipPolicyDiffServErrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServErrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServErrMsg.setDescription('Free text describing the reason why the entry is not Applicable. When entry is Applicable returns NULL string. The values returned for this MIB are not affected by the list status (active/inactive)')
ipPolicyQueryTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 5), )
if mibBuilder.loadTexts: ipPolicyQueryTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryTable.setDescription('This table is used to query the policy application for different types of information. The first use is to query about the operation that would be applied to a given packet. This table can be used by a managment application to supply the user an interactive dialugue for looking ahead at the outcomes of the policy defined')
ipPolicyQueryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 5, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyQuerySlot"))
if mibBuilder.loadTexts: ipPolicyQueryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryEntry.setDescription('Each entry relates to one slot (AKA module / box) in the stack')
ipPolicyQuerySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyQuerySlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQuerySlot.setDescription('The slot-id (AKA module-id / box number) to which this rule relates')
ipPolicyQueryListID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryListID.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryListID.setDescription('The ID of the list used to check the simulated packet. ')
ipPolicyQuerySrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQuerySrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQuerySrcAddr.setDescription('The IP address of the source station in the packet')
ipPolicyQueryDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryDstAddr.setDescription('The IP address of the destination station in the packet')
ipPolicyQueryProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryProtocol.setDescription("The IP protocol in the packet. Use 256 to specify IP (i.e. don't care)")
ipPolicyQueryL4SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryL4SrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryL4SrcPort.setDescription('The source port of the packet. This fields is applicable only when ipPolicyQueryProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyQueryL4DestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryL4DestPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryL4DestPort.setDescription('The destination port of the packet. This fields is applicable only when ipPolicyRuleProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyQueryEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryEstablished.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryEstablished.setDescription('The value of the TCP Establish bit in simulated packet. This fields is applicable only when ipPolicyQueryProtocol is TCP(6)')
ipPolicyQueryDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryDSCP.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryDSCP.setDescription('The DSCP value in the simulated packet. The value 64 is used to specify DONT CARE. In this case the result maybe forwardNoChange If a specifc value is specified the result would be the exact prioirty associated with the packet after consulting the DSCP table.')
ipPolicyQueryOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 99))).clone(namedValues=NamedValues(("forwardPriority0", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("forwardNoChange", 9), ("deny", 10), ("denyAndNotify", 11), ("layer2Switching", 12), ("notEnoughInfo", 13), ("error", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyQueryOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryOperation.setDescription('The operation that would be applied to the simulated packet. Some of the values are Access Control operations and some are priority operations.')
ipPolicyQueryRuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyQueryRuleID.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryRuleID.setDescription('ID of the rule of the list that resulted in the ipPolicyQueryOperation for the query. A value of 0 means that ipPolicyQueryOperation is a result of the ipPolicyListDefaultOperation')
ipPolicyQueryDSCPOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryDSCPOperation.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryDSCPOperation.setDescription('The New DSCP value that of the simulated packet A value of 64 means the DSCP field will not be changed.')
ipPolicyQueryPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 99))).clone(namedValues=NamedValues(("forwardPriority0", 1), ("forwardPriority1", 2), ("forwardPriority2", 3), ("forwardPriority3", 4), ("forwardPriority4", 5), ("forwardPriority5", 6), ("forwardPriority6", 7), ("forwardPriority7", 8), ("dontCare", 99))).clone('dontCare')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyQueryPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyQueryPriority.setDescription('The 802.1p priority in the simulated packet. When the priority is dontCare, the result maybe forwardNoChange.')
ipPolicyDiffServControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 6), )
if mibBuilder.loadTexts: ipPolicyDiffServControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlTable.setDescription('This table activates & monitors the Diff Serv application')
ipPolicyDiffServControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 6, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyDiffServControlSlot"))
if mibBuilder.loadTexts: ipPolicyDiffServControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlEntry.setDescription('Each entry relates to one slot (AKA module / box) in the stack')
ipPolicyDiffServControlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServControlSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlSlot.setDescription('The slot-id (AKA module-id / box number) to which this control entry relates')
ipPolicyDiffServControlChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServControlChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlChecksum.setDescription('Checksum of all the configurable (read/write) DiffServ mib items including the Diff Serv table. This field can be used by the management application to discover that Diff Serv configuration has changed (instead of polling all the Diff Serv mib items).')
ipPolicyDiffServControlTrustedFields = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cos", 1), ("dscp", 2), ("cos-dscp", 3), ("untrust", 4))).clone('dscp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPolicyDiffServControlTrustedFields.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlTrustedFields.setDescription('Specify which fields in the incoming packet might be trausted when the policy decision should be based in the incoming packet itself. Policy decision depend on the active policy list. In cases that there is no active policy list or that the result of the active policy list is Permit, then the outgoing packet prioirty may be based on the incoming packet instead of an the user specification. Trusting COS (802.1p) means that the outgoing packet prioirty (802.1p) should equal the incoming packet prioirty. Trusting DSCP means that the outgoing packet prioirty (802.1p) should be taken from ipPolicyDiffServTable using the incoming packet DSCP value. Trusting COS + DSCP means that both fields should be used. The behavior of the device when both COS + DSCP should be trusted is outside the scope of the current version of the MIB. (Note: P333R uses the max between incoming COS & DSCP-to-COS mapping) Some devices might support only a subset of the values.')
ipPolicyDiffServControlValidityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServControlValidityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlValidityStatus.setDescription('Validity status of the DSCP table: valid - All the entries in the DSCP table can be executed invalid - One or more of the entries in the DSCP table can NOT be EXECUTED.')
ipPolicyDiffServControlErrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyDiffServControlErrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyDiffServControlErrMsg.setDescription('Free text describing the reason why the table is not valid. When the table is valid returns NULL string. The values returned for this MIB are not affected by the table status (active/inactive).')
ipPolicyAccessControlViolationTable = MibTable((1, 3, 6, 1, 4, 1, 81, 36, 7), )
if mibBuilder.loadTexts: ipPolicyAccessControlViolationTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationTable.setDescription('This table contains infomations raerding the last packet (per module) for which ipPolicyAccessControlViolationTrap was sent.')
ipPolicyAccessControlViolationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 36, 7, 1), ).setIndexNames((0, "POLICY-MIB", "ipPolicyAccessControlViolationSlot"))
if mibBuilder.loadTexts: ipPolicyAccessControlViolationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationEntry.setDescription('An entry conatins the information regarding the last packet for which ipPolicyAccessControlViolationTrap was sent by the specific module.')
ipPolicyAccessControlViolationSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationSlot.setDescription('The slot-id (AKA module-id / box number) for which the trap was vsent')
ipPolicyAccessControlViolationSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationSrcAddr.setDescription('The IP address of the source station in the packet')
ipPolicyAccessControlViolationDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationDstAddr.setDescription('The IP address of the destination station in the packet')
ipPolicyAccessControlViolationProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationProtocol.setDescription("The IP protocol in the packet. Use 256 to specify IP (i.e. don't care)")
ipPolicyAccessControlViolationL4SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationL4SrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationL4SrcPort.setDescription('The source port of the packet. This fields is applicable only when ipPolicyAccessControlViolationProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyAccessControlViolationL4DstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationL4DstPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationL4DstPort.setDescription('The destination port of the packet. This fields is applicable only when ipPolicyAccessControlViolationProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
ipPolicyAccessControlViolationEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 36, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("dontCare", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPolicyAccessControlViolationEstablished.setStatus('mandatory')
if mibBuilder.loadTexts: ipPolicyAccessControlViolationEstablished.setDescription('This field indicates the value of the established bit in the TCP header of the packet. This fields is applicable only when \\ ipPolicyAccessControlViolationProtocol is TCP(6) or UDP(17). In all other cases its values is not used.')
mibBuilder.exportSymbols("POLICY-MIB", RowStatus=RowStatus, ipPolicyQueryDSCPOperation=ipPolicyQueryDSCPOperation, ipPolicyQueryListID=ipPolicyQueryListID, ipPolicyQuerySrcAddr=ipPolicyQuerySrcAddr, ipPolicyListCookie=ipPolicyListCookie, ipPolicyControlCurrentChecksum=ipPolicyControlCurrentChecksum, ipPolicyRuleApplicabilityStatus=ipPolicyRuleApplicabilityStatus, ipPolicyControlEntry=ipPolicyControlEntry, ipPolicyAccessControlViolationL4SrcPort=ipPolicyAccessControlViolationL4SrcPort, ipPolicyDiffServAggIndex=ipPolicyDiffServAggIndex, ipPolicyDiffServApplicabilityPrecedence=ipPolicyDiffServApplicabilityPrecedence, ipPolicyRuleListID=ipPolicyRuleListID, ipPolicyListTable=ipPolicyListTable, ipPolicyQueryRuleID=ipPolicyQueryRuleID, ipPolicyDiffServControlEntry=ipPolicyDiffServControlEntry, ipPolicyQueryL4SrcPort=ipPolicyQueryL4SrcPort, ipPolicyListSlot=ipPolicyListSlot, ipPolicyRuleTable=ipPolicyRuleTable, ipPolicyRuleDstAddrWild=ipPolicyRuleDstAddrWild, ipPolicyListValidityStatus=ipPolicyListValidityStatus, ipPolicyRuleSlot=ipPolicyRuleSlot, ipPolicyControlSlot=ipPolicyControlSlot, ipPolicyAccessControlViolationEstablished=ipPolicyAccessControlViolationEstablished, ipPolicyRuleID=ipPolicyRuleID, ipPolicyDiffServControlErrMsg=ipPolicyDiffServControlErrMsg, ipPolicyControlAllowedPolicyManagers=ipPolicyControlAllowedPolicyManagers, ipPolicyAccessControlViolationProtocol=ipPolicyAccessControlViolationProtocol, ipPolicyRuleSrcAddrWild=ipPolicyRuleSrcAddrWild, ipPolicyQueryEstablished=ipPolicyQueryEstablished, ipPolicyRuleL4SrcPortMin=ipPolicyRuleL4SrcPortMin, ipPolicyDiffServSlot=ipPolicyDiffServSlot, ipPolicyDiffServControlTrustedFields=ipPolicyDiffServControlTrustedFields, ipPolicyRuleApplicabilityType=ipPolicyRuleApplicabilityType, ipPolicyRuleApplicabilityPrecedence=ipPolicyRuleApplicabilityPrecedence, ipPolicyMgmt=ipPolicyMgmt, ipPolicyControlActiveGeneralList=ipPolicyControlActiveGeneralList, ipPolicyDiffServControlValidityStatus=ipPolicyDiffServControlValidityStatus, ipPolicyDiffServName=ipPolicyDiffServName, ipPolicyListErrMsg=ipPolicyListErrMsg, ipPolicyRuleL4DestPortMax=ipPolicyRuleL4DestPortMax, ipPolicyListRowStatus=ipPolicyListRowStatus, ipPolicyDiffServApplicabilityStatus=ipPolicyDiffServApplicabilityStatus, ipPolicyRuleErrMsg=ipPolicyRuleErrMsg, ipPolicyListID=ipPolicyListID, ipPolicyDiffServControlChecksum=ipPolicyDiffServControlChecksum, ipPolicyRuleDSCPOperation=ipPolicyRuleDSCPOperation, ipPolicyAccessControlViolationSrcAddr=ipPolicyAccessControlViolationSrcAddr, ipPolicyAccessControlViolationTable=ipPolicyAccessControlViolationTable, ipPolicyDiffServControlTable=ipPolicyDiffServControlTable, ipPolicyQueryPriority=ipPolicyQueryPriority, ipPolicyQueryEntry=ipPolicyQueryEntry, ipPolicyAccessControlViolationEntry=ipPolicyAccessControlViolationEntry, ipPolicyListDefaultOperation=ipPolicyListDefaultOperation, ipPolicyListChecksum=ipPolicyListChecksum, ipPolicyQueryOperation=ipPolicyQueryOperation, ipPolicyQueryDSCP=ipPolicyQueryDSCP, ipPolicyRuleOperation=ipPolicyRuleOperation, ipPolicyQueryProtocol=ipPolicyQueryProtocol, ipPolicyQueryL4DestPort=ipPolicyQueryL4DestPort, ipPolicyRuleStatus=ipPolicyRuleStatus, ipPolicyAccessControlViolationL4DstPort=ipPolicyAccessControlViolationL4DstPort, ipPolicyRuleProtocol=ipPolicyRuleProtocol, ipPolicyRuleDstAddr=ipPolicyRuleDstAddr, ipPolicyDiffServErrMsg=ipPolicyDiffServErrMsg, ipPolicyDiffServControlSlot=ipPolicyDiffServControlSlot, ipPolicyListTrackChanges=ipPolicyListTrackChanges, ipPolicyControlMinimalPolicyManagmentVersion=ipPolicyControlMinimalPolicyManagmentVersion, ipPolicyDiffServEntry=ipPolicyDiffServEntry, ipPolicyDiffServTable=ipPolicyDiffServTable, ipPolicyDiffServDSCP=ipPolicyDiffServDSCP, ipPolicyRuleSrcAddr=ipPolicyRuleSrcAddr, ipPolicyAccessControlViolationSlot=ipPolicyAccessControlViolationSlot, ipPolicyQuerySlot=ipPolicyQuerySlot, ipPolicyQueryTable=ipPolicyQueryTable, ipPolicyRuleL4DestPortMin=ipPolicyRuleL4DestPortMin, ipPolicyQueryDstAddr=ipPolicyQueryDstAddr, ipPolicyListEntry=ipPolicyListEntry, ipPolicyRuleL4SrcPortMax=ipPolicyRuleL4SrcPortMax, ipPolicyControlTable=ipPolicyControlTable, ipPolicyDiffServOperation=ipPolicyDiffServOperation, ipPolicyRuleEntry=ipPolicyRuleEntry, ipPolicyListOwner=ipPolicyListOwner, ipPolicyDiffServApplicabilityType=ipPolicyDiffServApplicabilityType, ipPolicyControlMaximalPolicyManagmentVersion=ipPolicyControlMaximalPolicyManagmentVersion, ipPolicyAccessControlViolationDstAddr=ipPolicyAccessControlViolationDstAddr, ipPolicyListName=ipPolicyListName, ipPolicyRuleEstablished=ipPolicyRuleEstablished)

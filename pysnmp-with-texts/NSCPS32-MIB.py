#
# PySNMP MIB module NSCPS32-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NSCPS32-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
nscProducts, nsc = mibBuilder.importSymbols("NSC-MIB", "nscProducts", "nsc")
Party, = mibBuilder.importSymbols("RFC1353-MIB", "Party")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
experimental, Integer32, enterprises, Gauge32, Counter64, ModuleIdentity, TimeTicks, NotificationType, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, Bits, IpAddress, iso = mibBuilder.importSymbols("SNMPv2-SMI", "experimental", "Integer32", "enterprises", "Gauge32", "Counter64", "ModuleIdentity", "TimeTicks", "NotificationType", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "Bits", "IpAddress", "iso")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
nscHippiSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4))
ps32General = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1))
ps32SwitchDescr = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchDescr.setDescription('A description of the NSC HIPPI switch.')
ps32SwitchVersion = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchVersion.setDescription("A textual description of the version/revision level for the switch's software.")
ps32SwitchDate = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32SwitchDate.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchDate.setDescription('The current date as kept in the real time clock in the NVRAM chip on the switch board.')
ps32SwitchTime = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32SwitchTime.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchTime.setDescription('The current date as kept in the real time clock in the NVRAM chip on the switch board.')
ps32SwitchAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3), ("reset", 4), ("programload", 5), ("test", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32SwitchAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchAdminStatus.setDescription('Provides the administratively desired state of the NSC Hippi Switch. The switch is activated by writing a value of enable(2). The switch may be de-activated by writing a value of disable(3). The switch is available for subsequent activation. Writing a value of reset(4) specifies the switch should initiate a reset sequence. Writing a value of programload(5) specifies the switch should initiate a program load sequence. Writing a value of test(6) specifies the switch should initiate a testing sequence.')
ps32SwitchOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("testing", 3), ("operational", 4), ("resetInProgress", 5), ("warning", 6), ("nonFatalError", 7), ("fatalError", 8), ("loading", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchOperStatus.setDescription('Provides operational status of the switch. The following are possible definitions of the values. The exact definition of the values is implementation specific. A value of other(1) implies some undetermined state, possibly as a result of setting ps32SwitchAdminStatus to a value of disable(3). A value of invalid(2) could have the possible meaning that the agent has no direct control of the switch. A value of testing(3) may be a diagnostic state. A value of operational(4) implies that the switch is running with no errors or warnings. State resetInProgress(5) implies equivalent of setting ps32SwitchAdminStatus to reset(4). The states of warning(6), nonFatalError(7), fatalError(8) reflect conditions detected during operation. The switch may or may not be still functional. State loading(10) is a result of asserting programload(5) in ps32SwitchAdminStatus.')
ps32SwitchPhysicalChanges = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchPhysicalChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchPhysicalChanges.setDescription('The number of physical changes that have occurred in the chassis since the agent was warm/cold started. This includes additions and removal of modules and entities. Other uses are implementation specific.')
ps32SwitchDiagnosticReg = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchDiagnosticReg.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchDiagnosticReg.setDescription('The register on the NSC Hippi Switch Control Board that contains many items of information on the configuration and performance of the switch.')
ps32SwitchMiscellanReg = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchMiscellanReg.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchMiscellanReg.setDescription('The register on the NSC Hippi Switch Control Board that contains many items of miscellaneous data with respect to the switch.')
ps32SwitchDipSwitchReg = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SwitchDipSwitchReg.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SwitchDipSwitchReg.setDescription('The register on the NSC Hippi Switch Control Board that contains the dip switch settings and other sensory information.')
ps32PowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2))
ps32NumPowerSupplies = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32NumPowerSupplies.setStatus('mandatory')
if mibBuilder.loadTexts: ps32NumPowerSupplies.setDescription('Number of power supplies installed in this chassis.')
ps32PowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2), )
if mibBuilder.loadTexts: ps32PowerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyTable.setDescription('A list of power supply entries, one for each power supply in the NSC Hippi Switch.')
ps32PowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32PowerSupplyIndex"))
if mibBuilder.loadTexts: ps32PowerSupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyEntry.setDescription('Values for a power supply.')
ps32PowerSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyIndex.setDescription('An index value that uniquely identifies a power supply installed in the NSC Hippi Switch.')
ps32PowerSupplyDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyDescr.setDescription("A textual description of the power supply, including the vendor's name and version.")
ps32PowerSupplyAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PowerSupplyAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyAdminStatus.setDescription('Desired status of the power supply.')
ps32PowerSupplyOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("disabled", 3), ("bad", 4), ("warning", 5), ("standby", 6), ("engaged", 7), ("redundant", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyOperStatus.setDescription('Actual status of the power supply: - unknown(1) - status not known. - empty(2) - no power supply installed in slot - disabled(3) - unable to supply power - control register has requested this supply be disabled. - bad(4) - unable to supply power due to failure - warning(5) - supplying power but an output or sensor is bad or warning - standby(6) - believed usable but not supplying power - engaged(7) - supplying power - redundant(8) - supplying power but not needed It is an implementation specific matter whether the agent keeps entries with status unknown(1) or empty(2) in the table.')
ps32PowerSupplyHealthText = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyHealthText.setDescription("A textual description of the power supply's operational status. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent-specific.")
ps32PowerSupplyWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyWarnings.setDescription('The number of times ps32PowerSupplyOperStatus has gone to warning(5).')
ps32PowerSupplyFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerSupplyFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerSupplyFailures.setDescription('The number of times ps32PowerSupplyOperStatus has gone to bad(4).')
ps32NumPowerOutputs = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32NumPowerOutputs.setStatus('mandatory')
if mibBuilder.loadTexts: ps32NumPowerOutputs.setDescription('Number of power supply outputs (total) in the switch.')
ps32PowerOutputTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4), )
if mibBuilder.loadTexts: ps32PowerOutputTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputTable.setDescription('A list of power supply output entries, one for each output of each power supply in the chassis.')
ps32PowerOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32PowerSupplyIndex"), (0, "NSCPS32-MIB", "ps32PowerOutputIndex"))
if mibBuilder.loadTexts: ps32PowerOutputEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputEntry.setDescription('Values for a power supply output.')
ps32PowerOutputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputIndex.setDescription('An index value that uniquely identifies an output for the power supply.')
ps32PowerOutputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("bad", 2), ("warning", 3), ("good", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputStatus.setDescription('Actual status of the power supply: - unknown(1) status not known - bad(2) unable to supply power due to failure - warning(3) supplying power but marginally - good(4) supplying power It is an implementation specific matter whether the agent keeps entries with status unknown(1) in the table. If unknown(1), offered values and counters are meaningless.')
ps32PowerOutputNominalVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputNominalVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputNominalVoltage.setDescription('In hundredths of a volt, the voltage the output is supposed to supply, such as -5, +5, +12, -15, etc.')
ps32PowerOutputOfferedVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputOfferedVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputOfferedVoltage.setDescription('In hundredths of a volt, the voltage actually supplied by the power output.')
ps32PowerOutputWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputWarnings.setDescription('The number of times ps32PowerOutputStatus has gone to warning(3).')
ps32PowerOutputFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PowerOutputFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PowerOutputFailures.setDescription('The number of times ps32PowerOutputStatus has gone to bad(2).')
ps32Environ = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3))
ps32NumEnvironmentSensors = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32NumEnvironmentSensors.setStatus('mandatory')
if mibBuilder.loadTexts: ps32NumEnvironmentSensors.setDescription('Number of environment sensors in this chassis.')
ps32EnvironTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2), )
if mibBuilder.loadTexts: ps32EnvironTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironTable.setDescription('A list of environmental entries, one for each environmental sensor in the chassis.')
ps32EnvironEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32EnvironIndex"))
if mibBuilder.loadTexts: ps32EnvironEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironEntry.setDescription('Values for an environmental sensor.')
ps32EnvironIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironIndex.setDescription('Index added to get draft past the MIB compiler. This needs to be fixed by the working group.')
ps32EnvironSensor = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("logicovertemp", 2), ("fanfailure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironSensor.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironSensor.setDescription('The identification of an environmental sensor. Other AutonomousType values may be defined elsewhere, in association with specific protocols. However, this document assigns those of known interest as of this writing.')
ps32EnvironStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("bad", 2), ("warning", 3), ("good", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironStatus.setDescription('Actual status indicated by the sensor. It is an implementation specific matter whether the agent keeps entries with status unknown(1) in the table. If unknown(1), counters are meaningless.')
ps32EnvironWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironWarnings.setDescription('The number of times ps32EnvironStatus has gone to warning(3).')
ps32EnvironFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironFailures.setDescription('The number of times ps32EnvironStatus has gone to bad(2).')
ps32EnvironDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironDescriptor.setDescription('A textual description of the environment sensor.')
ps32EnvironHealthText = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 3, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32EnvironHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: ps32EnvironHealthText.setDescription('A textual description of the current status of the environment entity monitored by this sensor.')
ps32Slot = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4))
ps32NumSlots = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32NumSlots.setStatus('mandatory')
if mibBuilder.loadTexts: ps32NumSlots.setDescription('Number of slots in this chassis.')
ps32SlotTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2), )
if mibBuilder.loadTexts: ps32SlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotTable.setDescription('A densely populated table that can be used to access individual slots in a HIPPI switch.')
ps32SlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32SlotNumber"))
if mibBuilder.loadTexts: ps32SlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotEntry.setDescription('An individual hippi switch slot entry consisting of all information required to monitor the status of a given slot in the Hippi Switch.')
ps32SlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotNumber.setDescription('The slot number in the switch. Slot numbers are officially designated as 0 through 18 in the switch but each slot number is incremented in order to comply with SNMP standards.')
ps32SlotPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SlotPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotPartNumber.setDescription('The part number of the board residing in the slot.')
ps32SlotBoardID = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SlotBoardID.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotBoardID.setDescription('The identifier of the board residing in the slot.')
ps32SlotBoardText = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SlotBoardText.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotBoardText.setDescription('A textual description of the board residing in the slot.')
ps32SlotLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 4, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32SlotLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: ps32SlotLastChange.setDescription("The value of MIB-II's sysUpTime (in the agent supporting this chassis MIB) at which a module was last inserted or removed from this slot. If no module has been inserted or removed from this slot since the last time the network management system was last re-initialized, then this object has a zero value.")
ps32Port = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5))
ps32MaximumPorts = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32MaximumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ps32MaximumPorts.setDescription('Maximum number of ports in this chassis.')
ps32InstalledPorts = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32InstalledPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ps32InstalledPorts.setDescription('Number of ports actually installed in this chassis.')
ps32PortTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3), )
if mibBuilder.loadTexts: ps32PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortTable.setDescription('A densely populated table that can be used to access individual ports in a HIPPI switch.')
ps32PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32PortNumber"))
if mibBuilder.loadTexts: ps32PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortEntry.setDescription('An individual hippi switch port entry. A switch port contains input and output hippi device pointers.')
ps32PortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortNumber.setDescription('The number of the hippi port.')
ps32PortBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortBoard.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortBoard.setDescription('The object identifier points to the PS32SlotEntry for the board to allow users to locate information about the board this port is located on.')
ps32PortInput = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortInput.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortInput.setDescription('The object identifier points to the hippiEntry for the HIPPI input device associated with this port.')
ps32PortOutput = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortOutput.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortOutput.setDescription('The object identifier points to the hippiEntry for the HIPPI output device associated with this port.')
ps32PortForce = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortForce.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortForce.setDescription('This object displays the forced pathway that is associated with this port. If none is assigned then the object has the value of -1. Only one output port is allowed for any particular input port.')
ps32PortCounterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortCounterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortCounterStatus.setDescription('This object consists of a bit for each counter that may have been overrun.')
ps32PortOverrunCount = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortOverrunCount.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortOverrunCount.setDescription('This object counts the overruns detected for this HIPPI port.')
ps32PortSwitchRejectCount = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortSwitchRejectCount.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortSwitchRejectCount.setDescription('This object consists of a bit for each counter that may have been overrun.')
ps32PortCamponDelayCount = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortCamponDelayCount.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortCamponDelayCount.setDescription('This object counts the rejected connect attempts using the Campon option.')
ps32PortCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortCurrentStatus.setDescription('This object consists of the status register at the instant of the last successful connection.')
ps32PortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3), ("reset", 4), ("test", 5), ("clrerrors", 6), ("clrpaths", 7), ("clrstats", 8), ("clrall", 9), ("rstrpath", 10), ("savecfg", 11), ("savepath", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortAdminStatus.setDescription("This object allows various commands to be issued from the client and acted upon by the agent. The only commands supported currently are listed below. 1: unknown...not a supported command. 2: enable activate the port requested. 3: disable deactivate the port requested. 4: reset reset the port requested. 5: test run BIST upon the requested port. 6: clrerrors clear current port errors. 7: clrpaths clear the pathways assigned. 8: clrstats clear the port's statistics. 9: clrall clear errors, stats, and paths. 10: rstrpath restore all pathways for this port. 11: savepath save all pathways for this port. 12: savecfg save the configuration. These commands completely fulfill the actions that a client is allowed to demand from a port.")
ps32PortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 5, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("notinstalled", 2), ("disabled", 3), ("operational", 4), ("connected", 5), ("intest", 6), ("inerror", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PortOperStatus.setDescription('This object displays the actual status of the port as determined by current registers and other indi- cators. 1: unknown not a supported status. 2: notinstalled Port is not in the switch. 3: disabled Port is deactivated. 4: operational Port is running normally. 5: connected Port has source interconnect. 6: intest Port is in BIST operation. 7: inerror Port is in an error condition. These statuses completely indicate the possible conditions that a port may be experiencing.')
ps32Pathway = MibIdentifier((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6))
ps32MaximumPathways = MibScalar((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32MaximumPathways.setStatus('mandatory')
if mibBuilder.loadTexts: ps32MaximumPathways.setDescription('Maximum number of pathways for a single port.')
ps32PathwayTable = MibTable((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2), )
if mibBuilder.loadTexts: ps32PathwayTable.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayTable.setDescription('A sparsely populated table that can be used to determine pathway information for a given port.')
ps32PathwayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2, 1), ).setIndexNames((0, "NSCPS32-MIB", "ps32PathwayPortNumber"), (0, "NSCPS32-MIB", "ps32PathwayHDA"))
if mibBuilder.loadTexts: ps32PathwayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayEntry.setDescription('An individual hippi switch pathway entry.')
ps32PathwayPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PathwayPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayPortNumber.setDescription('Index into the pathway entry table.')
ps32PathwayHDA = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2, 1, 2), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ps32PathwayHDA.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayHDA.setDescription('The downline HIPPI Destination Address to which the HIPPI connection is routed. This address is a 3 character hexadecimal address, packed into two octets.')
ps32PathwayDest = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PathwayDest.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayDest.setDescription('This is a list of output port numbers that can supply a path or a portion of the path to the specified HDA. The number of output ports and the number of ports that can be defined are switch specific. ie: the PS32 can accept up to four output ports with values of 0 to 31. The port list contains decimal numbers and are separated by spaces. Specifying a new string replaces any previous definitions including a NULL string removing all definitions.')
ps32PathwayClear = MibTableColumn((1, 3, 6, 1, 4, 1, 10, 2, 1, 4, 6, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ps32PathwayClear.setStatus('mandatory')
if mibBuilder.loadTexts: ps32PathwayClear.setDescription('A command to clear the requested pathway entry. The value is not used. Any access of this function causes the pathway indicated by the indices to be cleared.')
mibBuilder.exportSymbols("NSCPS32-MIB", ps32EnvironFailures=ps32EnvironFailures, ps32PortOverrunCount=ps32PortOverrunCount, ps32PowerOutputStatus=ps32PowerOutputStatus, ps32NumSlots=ps32NumSlots, ps32PortSwitchRejectCount=ps32PortSwitchRejectCount, ps32PowerSupply=ps32PowerSupply, ps32PortBoard=ps32PortBoard, ps32PowerSupplyFailures=ps32PowerSupplyFailures, ps32EnvironEntry=ps32EnvironEntry, ps32SlotBoardID=ps32SlotBoardID, ps32EnvironWarnings=ps32EnvironWarnings, ps32PortOperStatus=ps32PortOperStatus, ps32PowerSupplyAdminStatus=ps32PowerSupplyAdminStatus, ps32PowerSupplyHealthText=ps32PowerSupplyHealthText, ps32PowerOutputOfferedVoltage=ps32PowerOutputOfferedVoltage, ps32PortAdminStatus=ps32PortAdminStatus, ps32PortForce=ps32PortForce, ps32MaximumPorts=ps32MaximumPorts, ps32PowerOutputEntry=ps32PowerOutputEntry, ps32EnvironTable=ps32EnvironTable, ps32PortOutput=ps32PortOutput, ps32NumEnvironmentSensors=ps32NumEnvironmentSensors, ps32PathwayTable=ps32PathwayTable, ps32SwitchDipSwitchReg=ps32SwitchDipSwitchReg, ps32EnvironSensor=ps32EnvironSensor, ps32General=ps32General, ps32PathwayPortNumber=ps32PathwayPortNumber, ps32Slot=ps32Slot, ps32InstalledPorts=ps32InstalledPorts, ps32SlotBoardText=ps32SlotBoardText, ps32PortInput=ps32PortInput, ps32SwitchDate=ps32SwitchDate, ps32PathwayHDA=ps32PathwayHDA, ps32PowerSupplyDescr=ps32PowerSupplyDescr, ps32SwitchMiscellanReg=ps32SwitchMiscellanReg, ps32EnvironDescriptor=ps32EnvironDescriptor, ps32PathwayClear=ps32PathwayClear, ps32PowerSupplyWarnings=ps32PowerSupplyWarnings, ps32Pathway=ps32Pathway, ps32SlotNumber=ps32SlotNumber, ps32EnvironIndex=ps32EnvironIndex, ps32SlotTable=ps32SlotTable, ps32SlotEntry=ps32SlotEntry, ps32EnvironHealthText=ps32EnvironHealthText, ps32PortCurrentStatus=ps32PortCurrentStatus, ps32PortCamponDelayCount=ps32PortCamponDelayCount, ps32Port=ps32Port, ps32SwitchDescr=ps32SwitchDescr, ps32PowerOutputFailures=ps32PowerOutputFailures, ps32Environ=ps32Environ, ps32PortEntry=ps32PortEntry, ps32PortTable=ps32PortTable, ps32SlotLastChange=ps32SlotLastChange, ps32MaximumPathways=ps32MaximumPathways, ps32EnvironStatus=ps32EnvironStatus, ps32PortCounterStatus=ps32PortCounterStatus, ps32PowerOutputTable=ps32PowerOutputTable, ps32PowerSupplyEntry=ps32PowerSupplyEntry, ps32PowerSupplyIndex=ps32PowerSupplyIndex, ps32SlotPartNumber=ps32SlotPartNumber, ps32PowerOutputIndex=ps32PowerOutputIndex, ps32PowerSupplyOperStatus=ps32PowerSupplyOperStatus, ps32SwitchOperStatus=ps32SwitchOperStatus, ps32SwitchAdminStatus=ps32SwitchAdminStatus, ps32PowerSupplyTable=ps32PowerSupplyTable, ps32PowerOutputWarnings=ps32PowerOutputWarnings, ps32SwitchVersion=ps32SwitchVersion, ps32NumPowerSupplies=ps32NumPowerSupplies, ps32PortNumber=ps32PortNumber, ps32PowerOutputNominalVoltage=ps32PowerOutputNominalVoltage, ps32PathwayEntry=ps32PathwayEntry, ps32PathwayDest=ps32PathwayDest, ps32SwitchPhysicalChanges=ps32SwitchPhysicalChanges, ps32SwitchTime=ps32SwitchTime, ps32SwitchDiagnosticReg=ps32SwitchDiagnosticReg, nscHippiSwitch=nscHippiSwitch, ps32NumPowerOutputs=ps32NumPowerOutputs)

#
# PySNMP MIB module UDPLITE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/UDPLITE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:28:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
InetAddress, InetAddressType, InetPortNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, ObjectIdentity, IpAddress, Bits, Gauge32, MibIdentifier, Counter32, Counter64, Unsigned32, mib_2, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "ObjectIdentity", "IpAddress", "Bits", "Gauge32", "MibIdentifier", "Counter32", "Counter64", "Unsigned32", "mib-2", "iso", "ModuleIdentity")
TextualConvention, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "DisplayString")
udpliteMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 170))
udpliteMIB.setRevisions(('2007-12-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: udpliteMIB.setRevisionsDescriptions(('Initial SMIv2 revision, based on the format of the UDP MIB module (RFC 4113) and published as RFC 5097.',))
if mibBuilder.loadTexts: udpliteMIB.setLastUpdated('200712180000Z')
if mibBuilder.loadTexts: udpliteMIB.setOrganization('IETF TSV Working Group (TSVWG)')
if mibBuilder.loadTexts: udpliteMIB.setContactInfo('IETF TSV Working Group http://www.ietf.org/html.charters/tsvwg-charter.html Mailing List: tsvwg@ietf.org Gerrit Renker, Godred Fairhurst Electronics Research Group School of Engineering, University of Aberdeen Fraser Noble Building, Aberdeen AB24 3UE, UK')
if mibBuilder.loadTexts: udpliteMIB.setDescription('The MIB module for managing UDP-Lite implementations. Copyright (C) The IETF Trust (2008). This version of this MIB module is part of RFC 5097; see the RFC itself for full legal notices.')
udplite = MibIdentifier((1, 3, 6, 1, 2, 1, 170, 1))
udpliteInDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteInDatagrams.setStatus('current')
if mibBuilder.loadTexts: udpliteInDatagrams.setDescription('The total number of UDP-Lite datagrams that were delivered to UDP-Lite users. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteInPartialCov = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteInPartialCov.setStatus('current')
if mibBuilder.loadTexts: udpliteInPartialCov.setDescription('The total number of UDP-Lite datagrams that were delivered to UDP-Lite users (applications) and whose checksum coverage was strictly less than the datagram length. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteNoPorts = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteNoPorts.setStatus('current')
if mibBuilder.loadTexts: udpliteNoPorts.setDescription('The total number of received UDP-Lite datagrams for which there was no listener at the destination port. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteInErrors = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteInErrors.setStatus('current')
if mibBuilder.loadTexts: udpliteInErrors.setDescription('The number of received UDP-Lite datagrams that could not be delivered for reasons other than the lack of an application at the destination port. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteInBadChecksum = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteInBadChecksum.setReference('RFC 3828, section 3.1')
if mibBuilder.loadTexts: udpliteInBadChecksum.setStatus('current')
if mibBuilder.loadTexts: udpliteInBadChecksum.setDescription('The number of received UDP-Lite datagrams whose checksum could not be validated. This includes illegal checksum coverage values, as their use would lead to incorrect checksums. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteOutDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteOutDatagrams.setStatus('current')
if mibBuilder.loadTexts: udpliteOutDatagrams.setDescription('The total number of UDP-Lite datagrams sent from this entity. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteOutPartialCov = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteOutPartialCov.setStatus('current')
if mibBuilder.loadTexts: udpliteOutPartialCov.setDescription('The total number of udpliteOutDatagrams whose checksum coverage was strictly less than the datagram length. Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteEndpointTable = MibTable((1, 3, 6, 1, 2, 1, 170, 1, 8), )
if mibBuilder.loadTexts: udpliteEndpointTable.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointTable.setDescription("A table containing information about this entity's UDP-Lite endpoints on which a local application is currently accepting or sending datagrams. The address type in this table represents the address type used for the communication, irrespective of the higher-layer abstraction. For example, an application using IPv6 'sockets' to communicate via IPv4 between ::ffff:10.0.0.1 and ::ffff:10.0.0.2 would use InetAddressType ipv4(1). Like the udpTable in RFC 4113, this table also allows the representation of an application that completely specifies both local and remote addresses and ports. A listening application is represented in three possible ways: 1) An application that is willing to accept both IPv4 and IPv6 datagrams is represented by a udpliteEndpointLocalAddressType of unknown(0) and a udpliteEndpointLocalAddress of ''h (a zero-length octet-string). 2) An application that is willing to accept only IPv4 or only IPv6 datagrams is represented by a udpliteEndpointLocalAddressType of the appropriate address type and a udpliteEndpointLocalAddress of '0.0.0.0' or '::' respectively. 3) An application that is listening for datagrams only for a specific IP address but from any remote system is represented by a udpliteEndpointLocalAddressType of the appropriate address type, with udpliteEndpointLocalAddress specifying the local address. In all cases where the remote address is a wildcard, the udpliteEndpointRemoteAddressType is unknown(0), the udpliteEndpointRemoteAddress is ''h (a zero-length octet-string), and the udpliteEndpointRemotePort is 0. If the operating system is demultiplexing UDP-Lite packets by remote address/port, or if the application has 'connected' the socket specifying a default remote address/port, the udpliteEndpointRemote* values should be used to reflect this.")
udpliteEndpointEntry = MibTableRow((1, 3, 6, 1, 2, 1, 170, 1, 8, 1), ).setIndexNames((0, "UDPLITE-MIB", "udpliteEndpointLocalAddressType"), (0, "UDPLITE-MIB", "udpliteEndpointLocalAddress"), (0, "UDPLITE-MIB", "udpliteEndpointLocalPort"), (0, "UDPLITE-MIB", "udpliteEndpointRemoteAddressType"), (0, "UDPLITE-MIB", "udpliteEndpointRemoteAddress"), (0, "UDPLITE-MIB", "udpliteEndpointRemotePort"), (0, "UDPLITE-MIB", "udpliteEndpointInstance"))
if mibBuilder.loadTexts: udpliteEndpointEntry.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointEntry.setDescription('Information about a particular current UDP-Lite endpoint. Implementers need to pay attention to the sizes of udpliteEndpointLocalAddress/RemoteAddress, as Object Identifiers (OIDs) of column instances in this table must have no more than 128 sub-identifiers in order to remain accessible with SNMPv1, SNMPv2c, and SNMPv3.')
udpliteEndpointLocalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 1), InetAddressType())
if mibBuilder.loadTexts: udpliteEndpointLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointLocalAddressType.setDescription('The address type of udpliteEndpointLocalAddress. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
udpliteEndpointLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 2), InetAddress())
if mibBuilder.loadTexts: udpliteEndpointLocalAddress.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointLocalAddress.setDescription("The local IP address for this UDP-Lite endpoint. The value of this object can be represented in three possible ways, depending on the characteristics of the listening application: 1. For an application that is willing to accept both IPv4 and IPv6 datagrams, the value of this object must be ''h (a zero-length octet-string), with the value of the corresponding instance of the EndpointLocalAddressType object being unknown(0). 2. For an application that is willing to accept only IPv4 or only IPv6 datagrams, the value of this object must be '0.0.0.0' or '::', respectively, while the corresponding instance of the EndpointLocalAddressType object represents the appropriate address type. 3. For an application that is listening for data destined only to a specific IP address, the value of this object is the specific IP address for which this node is receiving packets, with the corresponding instance of the EndpointLocalAddressType object representing the appropriate address type. As this object is used in the index for the udpliteEndpointTable, implementors should be careful not to create entries that would result in OIDs with more than 128 sub-identifiers; this is because of SNMP and SMI limitations.")
udpliteEndpointLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 3), InetPortNumber())
if mibBuilder.loadTexts: udpliteEndpointLocalPort.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointLocalPort.setDescription('The local port number for this UDP-Lite endpoint.')
udpliteEndpointRemoteAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 4), InetAddressType())
if mibBuilder.loadTexts: udpliteEndpointRemoteAddressType.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointRemoteAddressType.setDescription('The address type of udpliteEndpointRemoteAddress. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all remote IP addresses are accepted. Also, note that some combinations of udpliteEndpointLocalAdressType and udpliteEndpointRemoteAddressType are not supported. In particular, if the value of this object is not unknown(0), it is expected to always refer to the same IP version as udpliteEndpointLocalAddressType.')
udpliteEndpointRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 5), InetAddress())
if mibBuilder.loadTexts: udpliteEndpointRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointRemoteAddress.setDescription("The remote IP address for this UDP-Lite endpoint. If datagrams from any remote system are to be accepted, this value is ''h (a zero-length octet-string). Otherwise, it has the type described by udpliteEndpointRemoteAddressType and is the address of the remote system from which datagrams are to be accepted (or to which all datagrams will be sent). As this object is used in the index for the udpliteEndpointTable, implementors should be careful not to create entries that would result in OIDs with more than 128 sub-identifiers; this is because of SNMP and SMI limitations.")
udpliteEndpointRemotePort = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 6), InetPortNumber())
if mibBuilder.loadTexts: udpliteEndpointRemotePort.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointRemotePort.setDescription('The remote port number for this UDP-Lite endpoint. If datagrams from any remote system are to be accepted, this value is zero.')
udpliteEndpointInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: udpliteEndpointInstance.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointInstance.setDescription("The instance of this tuple. This object is used to distinguish among multiple processes 'connected' to the same UDP-Lite endpoint. For example, on a system implementing the BSD sockets interface, this would be used to support the SO_REUSEADDR and SO_REUSEPORT socket options.")
udpliteEndpointProcess = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteEndpointProcess.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointProcess.setDescription("A unique value corresponding to a piece of software running on this endpoint. If this endpoint is associated with more than one piece of software, the agent should choose one of these. As long as the representative piece of software is running and still associated with the endpoint, subsequent reads will consistently return the same value. The implementation may use any algorithm satisfying these constraints (e.g., choosing the entity with the oldest start time). This identifier is platform-specific. Wherever possible, it should use the system's native, unique identification number as the value. If the SYSAPPL-MIB module is available, the value should be the same as sysApplElmtRunIndex. If not available, an alternative should be used (e.g., the hrSWRunIndex of the HOST-RESOURCES-MIB module). If it is not possible to uniquely identify the pieces of software associated with this endpoint, then the value zero should be used. (Note that zero is otherwise a valid value for sysApplElmtRunIndex.)")
udpliteEndpointMinCoverage = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteEndpointMinCoverage.setReference('RFC 3828, section 3.1')
if mibBuilder.loadTexts: udpliteEndpointMinCoverage.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointMinCoverage.setDescription('The minimum checksum coverage expected by this endpoint. A value of 0 indicates that only fully covered datagrams are accepted.')
udpliteEndpointViolCoverage = MibTableColumn((1, 3, 6, 1, 2, 1, 170, 1, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteEndpointViolCoverage.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointViolCoverage.setDescription('The number of datagrams received by this endpoint whose checksum coverage violated the minimum coverage threshold set for this connection (i.e., all valid datagrams whose checksum coverage was strictly smaller than the minimum, as defined in RFC 3828). Discontinuities in the value of this counter can occur at re-initialisation of the management system, and at other times as indicated by the value of udpliteStatsDiscontinuityTime.')
udpliteStatsDiscontinuityTime = MibScalar((1, 3, 6, 1, 2, 1, 170, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpliteStatsDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: udpliteStatsDiscontinuityTime.setDescription('The value of sysUpTime at the most recent occasion at which one or more of the UDP-Lite counters suffered a discontinuity. A value of zero indicates no such discontinuity has occurred since the last re-initialisation of the local management subsystem.')
udpliteMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 170, 2))
udpliteMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 170, 2, 1)).setObjects(("UDPLITE-MIB", "udpliteBaseGroup"), ("UDPLITE-MIB", "udplitePartialCsumGroup"), ("UDPLITE-MIB", "udpliteEndpointGroup"), ("UDPLITE-MIB", "udpliteAppGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    udpliteMIBCompliance = udpliteMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: udpliteMIBCompliance.setDescription('The compliance statement for systems that implement UDP-Lite. There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which we have the following compliance requirements, expressed in OBJECT clause form in this description clause: -- OBJECT udpliteEndpointLocalAddressType -- SYNTAX InetAddressType { unknown(0), ipv4(1), -- ipv6(2), ipv4z(3), -- ipv6z(4) } -- DESCRIPTION -- Support for dns(16) is not required. -- OBJECT udpliteEndpointLocalAddress -- SYNTAX InetAddress (SIZE(0|4|8|16|20)) -- DESCRIPTION -- Support is only required for zero-length -- octet-strings, and for scoped and unscoped -- IPv4 and IPv6 addresses. -- OBJECT udpliteEndpointRemoteAddressType -- SYNTAX InetAddressType { unknown(0), ipv4(1), -- ipv6(2), ipv4z(3), -- ipv6z(4) } -- DESCRIPTION -- Support for dns(16) is not required. -- OBJECT udpliteEndpointRemoteAddress -- SYNTAX InetAddress (SIZE(0|4|8|16|20)) -- DESCRIPTION -- Support is only required for zero-length -- octet-strings, and for scoped and unscoped -- IPv4 and IPv6 addresses. ')
udpliteMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 170, 2, 2))
udpliteBaseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 170, 2, 2, 1)).setObjects(("UDPLITE-MIB", "udpliteInDatagrams"), ("UDPLITE-MIB", "udpliteNoPorts"), ("UDPLITE-MIB", "udpliteInErrors"), ("UDPLITE-MIB", "udpliteOutDatagrams"), ("UDPLITE-MIB", "udpliteStatsDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    udpliteBaseGroup = udpliteBaseGroup.setStatus('current')
if mibBuilder.loadTexts: udpliteBaseGroup.setDescription('The group of objects providing for counters of basic UDP-like statistics.')
udplitePartialCsumGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 170, 2, 2, 2)).setObjects(("UDPLITE-MIB", "udpliteInPartialCov"), ("UDPLITE-MIB", "udpliteInBadChecksum"), ("UDPLITE-MIB", "udpliteOutPartialCov"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    udplitePartialCsumGroup = udplitePartialCsumGroup.setStatus('current')
if mibBuilder.loadTexts: udplitePartialCsumGroup.setDescription('The group of objects providing for counters of transport layer statistics exclusive to UDP-Lite.')
udpliteEndpointGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 170, 2, 2, 3)).setObjects(("UDPLITE-MIB", "udpliteEndpointProcess"), ("UDPLITE-MIB", "udpliteEndpointMinCoverage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    udpliteEndpointGroup = udpliteEndpointGroup.setStatus('current')
if mibBuilder.loadTexts: udpliteEndpointGroup.setDescription("The group of objects providing for the IP version independent management of UDP-Lite 'endpoints'.")
udpliteAppGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 170, 2, 2, 4)).setObjects(("UDPLITE-MIB", "udpliteEndpointViolCoverage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    udpliteAppGroup = udpliteAppGroup.setStatus('current')
if mibBuilder.loadTexts: udpliteAppGroup.setDescription("The group of objects that provide application-level information for the configuration management of UDP-Lite 'endpoints'.")
mibBuilder.exportSymbols("UDPLITE-MIB", udpliteMIBConformance=udpliteMIBConformance, udpliteEndpointTable=udpliteEndpointTable, udpliteInBadChecksum=udpliteInBadChecksum, udpliteEndpointRemotePort=udpliteEndpointRemotePort, udpliteMIBCompliance=udpliteMIBCompliance, udpliteInDatagrams=udpliteInDatagrams, udpliteEndpointLocalPort=udpliteEndpointLocalPort, udpliteBaseGroup=udpliteBaseGroup, udpliteEndpointRemoteAddress=udpliteEndpointRemoteAddress, udpliteInPartialCov=udpliteInPartialCov, udpliteEndpointRemoteAddressType=udpliteEndpointRemoteAddressType, udplite=udplite, udpliteEndpointInstance=udpliteEndpointInstance, udpliteEndpointMinCoverage=udpliteEndpointMinCoverage, udpliteEndpointEntry=udpliteEndpointEntry, udpliteInErrors=udpliteInErrors, udpliteOutDatagrams=udpliteOutDatagrams, udpliteEndpointGroup=udpliteEndpointGroup, udpliteEndpointLocalAddressType=udpliteEndpointLocalAddressType, PYSNMP_MODULE_ID=udpliteMIB, udpliteMIBGroups=udpliteMIBGroups, udplitePartialCsumGroup=udplitePartialCsumGroup, udpliteOutPartialCov=udpliteOutPartialCov, udpliteEndpointLocalAddress=udpliteEndpointLocalAddress, udpliteEndpointViolCoverage=udpliteEndpointViolCoverage, udpliteNoPorts=udpliteNoPorts, udpliteAppGroup=udpliteAppGroup, udpliteMIB=udpliteMIB, udpliteStatsDiscontinuityTime=udpliteStatsDiscontinuityTime, udpliteEndpointProcess=udpliteEndpointProcess)

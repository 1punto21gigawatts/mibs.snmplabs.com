#
# PySNMP MIB module Wellfleet-INT-SERV-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-INT-SERV-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:40:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, Unsigned32, Bits, Integer32, TimeTicks, IpAddress, MibIdentifier, Counter32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, NotificationType, Gauge32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "Bits", "Integer32", "TimeTicks", "IpAddress", "MibIdentifier", "Counter32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "NotificationType", "Gauge32", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfIntegratedServicesGroup, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfIntegratedServicesGroup")
wfReservationsResourcesGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2))
wfTxLineRscGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1))
wfReservationsFlowspecGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3))
wfIntSrvIfFlowGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4))
wfTxLineRscTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1), )
if mibBuilder.loadTexts: wfTxLineRscTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscTable.setDescription('This table contains information about line resources and guaranteed service traffic on a per-line basis for outbound traffic.')
wfTxLineRscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1), ).setIndexNames((0, "Wellfleet-INT-SERV-MIB", "wfTxLineRscLineNumber"))
if mibBuilder.loadTexts: wfTxLineRscEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscEntry.setDescription('')
wfTxLineRscKillReservations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("keep", 1), ("kill", 2))).clone('keep')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscKillReservations.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscKillReservations.setDescription('Kill all reservations on this line.')
wfTxLineRscLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscLineNumber.setDescription('Line number')
wfTxLineRscReservableBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscReservableBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscReservableBandwidth.setDescription('amount of reservable bandwidth left on this line (bits per second)')
wfTxLineRscReservedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscReservedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscReservedBandwidth.setDescription('amount of reserved bandwidth on this line (bits per second)')
wfTxLineRscGuaranteedFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedFlows.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedFlows.setDescription('number of guaranteed-service flows')
wfTxLineRscGuaranteedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPackets.setDescription('Number of guaranteed-service packets that have exited this line')
wfTxLineRscGuaranteedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedBytes.setDescription('Number of guaranteed-service bytes that have exited this line')
wfTxLineRscGuaranteedPolicedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPolicedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPolicedPackets.setDescription('Number of guaranteed-service packets that were policed (dropped)')
wfTxLineRscGuaranteedPolicedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPolicedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedPolicedBytes.setDescription('Number of guaranteed-service bytes that were policed (dropped)')
wfTxLineRscGuaranteedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedBandwidth.setDescription('Guaranteed service bandwidth measured over the last bandwidth interval')
wfTxLineRscGuaranteedAvgBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedAvgBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedAvgBandwidth.setDescription('Guaranteed service average bandwidth')
wfTxLineRscGuaranteedMaxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedMaxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedMaxBandwidth.setDescription('Guaranteed service maximum bandwidth')
wfTxLineRscGuaranteedAvgPacketDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedAvgPacketDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedAvgPacketDelay.setDescription('Guaranteed service average packet delay')
wfTxLineRscGuaranteedMaxPacketDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscGuaranteedMaxPacketDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscGuaranteedMaxPacketDelay.setDescription('Guaranteed service maximum packet delay')
wfTxLineRscUnreservedPolicedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscUnreservedPolicedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscUnreservedPolicedPackets.setDescription('Number of unreserved packets that were policed (dropped). If priority queueing is also enabled, this statistic is not maintained. See wfCctOptsEntry.')
wfTxLineRscUnreservedPolicedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscUnreservedPolicedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscUnreservedPolicedBytes.setDescription('Number of unreserved bytes that were policed (dropped). If priority queueing is also enabled, this statistic is not maintained. See wfCctOptsEntry.')
wfTxLineRscCfgTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3), )
if mibBuilder.loadTexts: wfTxLineRscCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgTable.setDescription('This table contains resource reservation configuration information on a per-line basis for outbound traffic.')
wfTxLineRscCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1), ).setIndexNames((0, "Wellfleet-INT-SERV-MIB", "wfTxLineRscCfgLineNumber"))
if mibBuilder.loadTexts: wfTxLineRscCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgEntry.setDescription('')
wfTxLineRscCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgDelete.setDescription('Creation and deletion flag for this record')
wfTxLineRscCfgLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTxLineRscCfgLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgLineNumber.setDescription('Line number')
wfTxLineRscCfgEstBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgEstBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgEstBandwidth.setDescription('Estimated usable bandwidth by this router in bits per second.')
wfTxLineRscCfgResvBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgResvBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgResvBandwidth.setDescription('Reservable bandwidth on this line.')
wfTxLineRscCfgResvTrafficAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("priority", 2))).clone('priority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgResvTrafficAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgResvTrafficAlgorithm.setDescription('reserved-traffic queueing algorithm: none - schedule as best-effort priority - schedule ahead of best-effort')
wfTxLineRscCfgResvPolicingAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("lbucket", 2))).clone('lbucket')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgResvPolicingAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgResvPolicingAlgorithm.setDescription('reserved-traffic policing algorithm: none - no policing lbucket - leaky bucket policing')
wfTxLineRscCfgBandwidthInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10))).clone(namedValues=NamedValues(("default", 10))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgBandwidthInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgBandwidthInterval.setDescription('Interval over which bandwidth is measured, in seconds. Default is ten seconds.')
wfTxLineRscCfgInflateReservations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgInflateReservations.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgInflateReservations.setDescription('Any reservation made on this line will be inflated by this percentage.')
wfTxLineRscCfgUnreservedPolicingAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("qlimit", 1), ("lbucket", 2))).clone('qlimit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgUnreservedPolicingAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgUnreservedPolicingAlgorithm.setDescription('Policing algorithm for unreserved traffic. qlimit (1) limits the number of buffers (packets) of unreserved traffic that will be queued up. lbucket (2) applies a leaky bucket algorithm based on the bandwidth that is not guaranteed. The leaky bucket algorithm does not allow the unreserved traffic to take advantage of unused reserved bandwidth.')
wfTxLineRscCfgUnreservedQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("default", 20))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgUnreservedQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgUnreservedQueueLength.setDescription('If the unreserved policing algorithm is qlimit, this is the maximum number of best-effort packets that will be held for transmission. This parameter affects the amount best-effort traffic will be clipped when congestion occurs. Overriden by priority queueing limits, if configured.')
wfTxLineRscCfgMultiLineSelectAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("first", 1), ("round", 2))).clone('first')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgMultiLineSelectAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgMultiLineSelectAlgorithm.setDescription('This algorithm influences how the circuit resource manager will select which line will be used for a new resource request. first (1) does a first-fit. round (2) does a round-robin. If first-fit is selected and the ThresholdBandwidth parameter is non-zero, a first-fit algorithm is done until a line reaches its threshold. The algorithm then moves to the the next line. Once all lines are at their threshold, the algorithm is simply first-fit. All lines for a circuit should select the same algorithm. If any one specifies first-fit, first-fit will be used.')
wfTxLineRscCfgMultiLineThresholdBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgMultiLineThresholdBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgMultiLineThresholdBandwidth.setDescription('If the multi-line selection algorithm is threshold, this is the threshold value for this line. It must be less than the reservable bandwidth value.')
wfTxLineRscCfgResvLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgResvLatency.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgResvLatency.setDescription('The maximum latency acceptable for a reserved flow packet. This parameter limits the amount of unreserved data that the link scheduler can put onto the driver transmit ring. When the data on the transmit ring reaches a size where additional unreserved data would take longer than the value of this parameter to clock out, no more data will be enqueued. Reduce this parameter to obtain better delay characteristics for reserved flows, but note that this will result in somewhat reduced overall throughput. Units are milliseconds.')
wfTxLineRscCfgLargestBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgLargestBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgLargestBandwidth.setDescription('The maximum bandwidth that a single flow can reserve on this line. [ 0 (zero) implies no maximum.]')
wfTxLineRscCfgLargestBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 2, 1, 3, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTxLineRscCfgLargestBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: wfTxLineRscCfgLargestBuffer.setDescription('The maximum buffer space that a single flow can reserve on this line. [ 0 (zero) implies no maximum.]')
wfFlowspecSt2V3Table = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1), )
if mibBuilder.loadTexts: wfFlowspecSt2V3Table.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Table.setDescription('This is the ST-2 version 3 flowspec. The FlowSpec is used to convey stream service requirements end-to-end. We expect that other versions of FlowSpec will be needed in the future, which may or may not be subsets or supersets of the version described here. PBytes will allow new constraints to be added to the end without having to simultaneously update all implementations in the field. Implementations are expected to be able to process in a graceful manner a Version 4 (or higher) structure that has more elements than shown here.')
wfFlowspecSt2V3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1), ).setIndexNames((0, "Wellfleet-INT-SERV-MIB", "wfFlowspecSt2V3Index"))
if mibBuilder.loadTexts: wfFlowspecSt2V3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Entry.setDescription('')
wfFlowspecSt2V3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3Index.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Index.setDescription('flowspec index')
wfFlowspecSt2V3Version = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3Version.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Version.setDescription('Version identifies the version of the FlowSpec. Version 3 is defined here.')
wfFlowspecSt2V3DutyFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3DutyFactor.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3DutyFactor.setDescription('DutyFactor is the estimated proportion of the time that the requested bandwidth will actually be in use. Zero is taken to represent 256 and signify a duty factor of 1. Other values are to be divided by 256 to yield the duty factor.')
wfFlowspecSt2V3ErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3ErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3ErrorRate.setDescription('ErrorRate expresses the error rate as the negative exponent of 10 in the error rate. One (1) represents a bit error rate of 0.1 and 10 represents 0.0000000001.')
wfFlowspecSt2V3Precedence = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3Precedence.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Precedence.setDescription('Precedence is the precedence of the connection being established. Zero represents the lowest precedence. Note that non-zero values of this parameter should be subject to authentication and authorization checks, which are not specified here. In general, the distinction between precedence and priority is that precedence specifies streams that are permitted to take previously committed resources from another stream, while priority identifies those PDUs that a stream is most willing to have dropped when the stream exceeds its guaranteed limits.')
wfFlowspecSt2V3Reliability = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3Reliability.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Reliability.setDescription('Reliability is modified by each intervening ST agent as a measure of the probability that a given offered data packet will be forwarded and not dropped. Zero is taken to represent 256 and signify a probability of 1. Other values are to be divided by 256 to yield the probability.')
wfFlowspecSt2V3Tradeoffs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3Tradeoffs.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3Tradeoffs.setDescription("Tradeoffs is incompletely defined at this time. Bits currently specified are as follows: The most significant bit in the field, bit 0 in the Figure 24, when one (1) means that each ST agent must 'implement' all constraints in the FlowSpec even if they are not shown in the figure, e.g., when the FlowSpec has been extended. When zero (0), unknown constraints may be ignored. The second most significant bit in the field, bit 1, when one (1) means that one or more constraints are unknown and have been ignored. When zero (0), all constraints are known and have been processed. The third most significant bit in the field, bit 2, is used for RevChrg; see Section 3.6.5 (page 46). Other bits are currently unspecified, and should be set to zero (0) by the origin ST agent and not changed by other agents unless those agents know their meaning.")
wfFlowspecSt2V3RecoveryTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3RecoveryTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3RecoveryTimeout.setDescription('RecoveryTimeout specifies the nominal number of milliseconds that the application is willing to wait for a failed system component to be detected and any corrective action to be taken.')
wfFlowspecSt2V3LimitOnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnCost.setDescription('LimitOnCost specifies the maximum cost that the origin is willing to expend. A value of zero indicates that the application is not willing to incur any direct charges for the resources used by the stream. The meaning of non-zero values is left for further study.')
wfFlowspecSt2V3LimitOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnDelay.setDescription('LimitOnDelay specifies the maximum end-to-end delay, in milliseconds, that can be tolerated by the origin.')
wfFlowspecSt2V3LimitOnPDUBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnPDUBytes.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnPDUBytes.setDescription('LimitOnPDUBytes is the smallest packet size, in terms of ST-user data bytes, that can be tolerated by the origin.')
wfFlowspecSt2V3LimitOnPDURate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnPDURate.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3LimitOnPDURate.setDescription('LimitOnPDURate is the lowest packet rate that can be tolerated by the origin, expressed as tenths of a packet per second.')
wfFlowspecSt2V3MinBytesXRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3MinBytesXRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3MinBytesXRate.setDescription('MinBytesXRate is the minimum bandwidth that can be tolerated by the origin, expressed as a product of bytes and tenths of a packet per second.')
wfFlowspecSt2V3AccdMeanDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3AccdMeanDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3AccdMeanDelay.setDescription('AccdMeanDelay is modified by each intervening ST agent. This provides a means of reporting the total expected delay, in milliseconds, for a data packet. Note that it is implicitly assumed that the requested mean delay is zero and there is no limit on the mean delay, so there are no parameters to specify these explicitly.')
wfFlowspecSt2V3AccdDelayVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3AccdDelayVariance.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3AccdDelayVariance.setDescription('AccdDelayVariance is also modified by each intervening ST agent as a measure, in milliseconds squared, of the packet dispersion. This quantity can be used by the target or origin in determining whether the resulting stream has an adequate quality of service to support the application. Note that it is implicitly assumed that the requested delay variance is zero and there is no limit on the delay variance, so there are no parameters to specify these explicitly.')
wfFlowspecSt2V3DesPDUBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3DesPDUBytes.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3DesPDUBytes.setDescription("DesPDUBytes is the desired PDU size in bytes. This is not necessarily the same as the minimum necessary PDU size. This value may be made smaller by intervening ST agents so long as it is not made smaller than LimitOnPDUBytes. The *PDUBytes limits measure the size of the PDUs of next-higher protocol layer, i.e., the user information contained in a data packet. An ST agent must account for both the ST Header (including possible IP encapsulation) and any local network headers and trailers when comparing a network's MTU with *PDUBytes. In an ACCEPT message, the value of this field will be no larger than the MTU of the path to the specified target.")
wfFlowspecSt2V3DesPDURate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 3, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFlowspecSt2V3DesPDURate.setStatus('mandatory')
if mibBuilder.loadTexts: wfFlowspecSt2V3DesPDURate.setDescription('DesPDURate is the requested PDU rate, expressed as tenths of a packet per second. This value may be made smaller by intervening ST agents so long as it is not made smaller than LimitOnPDURate.')
wfIntSrvIfFlowTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1), )
if mibBuilder.loadTexts: wfIntSrvIfFlowTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowTable.setDescription("Information describing the reserved flows us- ing the system's interfaces.")
wfIntSrvIfFlowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1), ).setIndexNames((0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowDestination"), (0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowDestinationProtocol"), (0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowDestinationPort"), (0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowSource"), (0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowSourcePort"), (0, "Wellfleet-INT-SERV-MIB", "wfIntSrvIfFlowCct"))
if mibBuilder.loadTexts: wfIntSrvIfFlowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowEntry.setDescription('Information describing the use of a given in- terface by a given flow.')
wfIntSrvIfFlowDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowDestination.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowDestination.setDescription('The IP Address used as a destination address for all senders in this flow.')
wfIntSrvIfFlowDestinationProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowDestinationProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowDestinationProtocol.setDescription('The value of the IP Protocol field in this flow, typically UDP or TCP.')
wfIntSrvIfFlowDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowDestinationPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowDestinationPort.setDescription('The UDP or TCP port number used as a destina- tion port for all senders in this flow. A value of zero indicates that the IP protocol in use, specified by wfIntSrvIfFlowDestinationProtocol, does not use ports.')
wfIntSrvIfFlowSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowSource.setDescription('The IP Address used as a source address by this sender in this flow. If zero, all senders are included in the flow.')
wfIntSrvIfFlowSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowSourcePort.setDescription('The UDP or TCP port number used as a source port by this sender in this flow. A value of zero indicates that the IP protocol in use, specified by wfIntSrvIfFlowDestinationProtocol, does not use ports, or (when wfIntSrvIfFlowDestinationPort is non-zero) that data from all senders is in- cluded in this class of flows.')
wfIntSrvIfFlowRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowRate.setDescription("The Average Bit Rate of the sender's data stream, in Kilobits. The rate may be arbi- trarily fast during a short interval such as the duration of a video frame. However, over any two such intervals it will not average fas- ter than the average rate as transmitted by the sender.")
wfIntSrvIfFlowWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowWeight.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowWeight.setDescription('The weight used to prioritize the traffic. Note that the interpretation of this object is implementation-specific, as implementations vary in their use of weighting procedures.')
wfIntSrvIfFlowQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowQueue.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowQueue.setDescription('The number of the queue used by this traffic. Note that the interpretation of this object is implementation-specific, as implementations vary in their use of queue identifiers.')
wfIntSrvIfFlowMin = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowMin.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowMin.setDescription('The minimum message size for this flow. The policing algorithm will treat smaller messages as though they are this size.')
wfIntSrvIfFlowCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 16, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIntSrvIfFlowCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfIntSrvIfFlowCct.setDescription('The circuit number of this IntSrv interface')
mibBuilder.exportSymbols("Wellfleet-INT-SERV-MIB", wfFlowspecSt2V3Precedence=wfFlowspecSt2V3Precedence, wfTxLineRscCfgResvPolicingAlgorithm=wfTxLineRscCfgResvPolicingAlgorithm, wfTxLineRscEntry=wfTxLineRscEntry, wfFlowspecSt2V3Tradeoffs=wfFlowspecSt2V3Tradeoffs, wfIntSrvIfFlowDestinationProtocol=wfIntSrvIfFlowDestinationProtocol, wfFlowspecSt2V3DutyFactor=wfFlowspecSt2V3DutyFactor, wfTxLineRscCfgEstBandwidth=wfTxLineRscCfgEstBandwidth, wfTxLineRscCfgLargestBandwidth=wfTxLineRscCfgLargestBandwidth, wfIntSrvIfFlowMin=wfIntSrvIfFlowMin, wfTxLineRscCfgInflateReservations=wfTxLineRscCfgInflateReservations, wfTxLineRscGuaranteedAvgPacketDelay=wfTxLineRscGuaranteedAvgPacketDelay, wfIntSrvIfFlowSourcePort=wfIntSrvIfFlowSourcePort, wfTxLineRscCfgBandwidthInterval=wfTxLineRscCfgBandwidthInterval, wfFlowspecSt2V3Entry=wfFlowspecSt2V3Entry, wfIntSrvIfFlowEntry=wfIntSrvIfFlowEntry, wfTxLineRscGuaranteedPolicedPackets=wfTxLineRscGuaranteedPolicedPackets, wfFlowspecSt2V3LimitOnDelay=wfFlowspecSt2V3LimitOnDelay, wfIntSrvIfFlowQueue=wfIntSrvIfFlowQueue, wfTxLineRscCfgUnreservedQueueLength=wfTxLineRscCfgUnreservedQueueLength, wfTxLineRscCfgTable=wfTxLineRscCfgTable, wfFlowspecSt2V3MinBytesXRate=wfFlowspecSt2V3MinBytesXRate, wfFlowspecSt2V3RecoveryTimeout=wfFlowspecSt2V3RecoveryTimeout, wfFlowspecSt2V3LimitOnCost=wfFlowspecSt2V3LimitOnCost, wfFlowspecSt2V3Reliability=wfFlowspecSt2V3Reliability, wfTxLineRscCfgLineNumber=wfTxLineRscCfgLineNumber, wfTxLineRscGuaranteedBandwidth=wfTxLineRscGuaranteedBandwidth, wfTxLineRscCfgDelete=wfTxLineRscCfgDelete, wfFlowspecSt2V3Table=wfFlowspecSt2V3Table, wfTxLineRscCfgEntry=wfTxLineRscCfgEntry, wfTxLineRscLineNumber=wfTxLineRscLineNumber, wfIntSrvIfFlowWeight=wfIntSrvIfFlowWeight, wfTxLineRscGuaranteedMaxPacketDelay=wfTxLineRscGuaranteedMaxPacketDelay, wfFlowspecSt2V3AccdDelayVariance=wfFlowspecSt2V3AccdDelayVariance, wfTxLineRscCfgMultiLineSelectAlgorithm=wfTxLineRscCfgMultiLineSelectAlgorithm, wfTxLineRscGuaranteedAvgBandwidth=wfTxLineRscGuaranteedAvgBandwidth, wfTxLineRscCfgMultiLineThresholdBandwidth=wfTxLineRscCfgMultiLineThresholdBandwidth, wfTxLineRscGuaranteedPolicedBytes=wfTxLineRscGuaranteedPolicedBytes, wfTxLineRscCfgResvLatency=wfTxLineRscCfgResvLatency, wfIntSrvIfFlowTable=wfIntSrvIfFlowTable, wfTxLineRscUnreservedPolicedPackets=wfTxLineRscUnreservedPolicedPackets, wfIntSrvIfFlowRate=wfIntSrvIfFlowRate, wfTxLineRscKillReservations=wfTxLineRscKillReservations, wfFlowspecSt2V3LimitOnPDUBytes=wfFlowspecSt2V3LimitOnPDUBytes, wfReservationsResourcesGroup=wfReservationsResourcesGroup, wfTxLineRscCfgLargestBuffer=wfTxLineRscCfgLargestBuffer, wfTxLineRscCfgResvBandwidth=wfTxLineRscCfgResvBandwidth, wfFlowspecSt2V3DesPDURate=wfFlowspecSt2V3DesPDURate, wfTxLineRscGuaranteedMaxBandwidth=wfTxLineRscGuaranteedMaxBandwidth, wfTxLineRscGuaranteedFlows=wfTxLineRscGuaranteedFlows, wfFlowspecSt2V3AccdMeanDelay=wfFlowspecSt2V3AccdMeanDelay, wfIntSrvIfFlowDestinationPort=wfIntSrvIfFlowDestinationPort, wfTxLineRscCfgUnreservedPolicingAlgorithm=wfTxLineRscCfgUnreservedPolicingAlgorithm, wfTxLineRscGuaranteedPackets=wfTxLineRscGuaranteedPackets, wfTxLineRscUnreservedPolicedBytes=wfTxLineRscUnreservedPolicedBytes, wfIntSrvIfFlowDestination=wfIntSrvIfFlowDestination, wfTxLineRscGroup=wfTxLineRscGroup, wfTxLineRscTable=wfTxLineRscTable, wfFlowspecSt2V3LimitOnPDURate=wfFlowspecSt2V3LimitOnPDURate, wfTxLineRscCfgResvTrafficAlgorithm=wfTxLineRscCfgResvTrafficAlgorithm, wfReservationsFlowspecGroup=wfReservationsFlowspecGroup, wfFlowspecSt2V3ErrorRate=wfFlowspecSt2V3ErrorRate, wfFlowspecSt2V3Version=wfFlowspecSt2V3Version, wfIntSrvIfFlowSource=wfIntSrvIfFlowSource, wfTxLineRscReservableBandwidth=wfTxLineRscReservableBandwidth, wfIntSrvIfFlowCct=wfIntSrvIfFlowCct, wfIntSrvIfFlowGroup=wfIntSrvIfFlowGroup, wfTxLineRscGuaranteedBytes=wfTxLineRscGuaranteedBytes, wfTxLineRscReservedBandwidth=wfTxLineRscReservedBandwidth, wfFlowspecSt2V3Index=wfFlowspecSt2V3Index, wfFlowspecSt2V3DesPDUBytes=wfFlowspecSt2V3DesPDUBytes)

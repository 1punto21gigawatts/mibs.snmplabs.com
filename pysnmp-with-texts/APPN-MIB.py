#
# PySNMP MIB module APPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:24:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
IANAifType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAifType")
snanauMIB, = mibBuilder.importSymbols("SNA-NAU-MIB", "snanauMIB")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Unsigned32, TimeTicks, Gauge32, NotificationType, MibIdentifier, Counter64, Bits, ModuleIdentity, IpAddress, Counter32, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Unsigned32", "TimeTicks", "Gauge32", "NotificationType", "MibIdentifier", "Counter64", "Bits", "ModuleIdentity", "IpAddress", "Counter32", "ObjectIdentity", "iso")
VariablePointer, RowPointer, TextualConvention, DisplayString, TimeStamp, TruthValue, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "VariablePointer", "RowPointer", "TextualConvention", "DisplayString", "TimeStamp", "TruthValue", "DateAndTime")
appnMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 34, 4))
appnMIB.setRevisions(('1998-07-15 18:00', '1998-05-26 18:00', '1997-07-31 18:00', '1997-03-31 18:00', '1997-03-20 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: appnMIB.setRevisionsDescriptions(("Minor editorial fixes; new value 'none(5)' added to the enumeration for the appnLocalTgBranchLinkType object.", 'Post-RFC 2155 conformance definitions added, appnNodeLsCounterType and appnNodeBrNn objects added, appnNodeMibVersion object deprecated.', 'Branch network node (Branch Extender) objects added.', 'MLTG objects added.', 'RFC 2155 (Proposed Standard)',))
if mibBuilder.loadTexts: appnMIB.setLastUpdated('9807151800Z')
if mibBuilder.loadTexts: appnMIB.setOrganization('IETF SNA NAU MIB WG / AIW APPN MIBs SIG')
if mibBuilder.loadTexts: appnMIB.setContactInfo(' Bob Clouston Cisco Systems 7025 Kit Creek Road P.O. Box 14987 Research Triangle Park, NC 27709, USA Tel: 1 919 472 2333 E-mail: clouston@cisco.com Bob Moore IBM Corporation 4205 S. Miami Boulevard BRQA/501 P.O. Box 12195 Research Triangle Park, NC 27709, USA Tel: 1 919 254 4436 E-mail: remoore@us.ibm.com ')
if mibBuilder.loadTexts: appnMIB.setDescription('This is the MIB module for objects used to manage network devices with APPN capabilities.')
class SnaNodeIdentification(TextualConvention, OctetString):
    description = "An SNA Node Identification consists of two parts, which together comprise four bytes of hexadecimal data. In SNA the Node Identification is transported in bytes 2-5 of the XID. The block number is the first three digits of the Node Identification. These 3 hexadecimal digits identify the product. The ID number is the last 5 digits of the Node Identification. These 5 hexadecimal digits are administratively defined and combined with the 3-digit block number form the 8-digit Node Identification. A unique value is required for connections to SNA subarea. In some implementations, the value 'bbb00000' (where 'bbb' represents a 3-digit block number) is returned to mean that the ID number is not unique on this node. An SNA Node Identification is represented as eight ASCII-encoded hexadecimal digits, using the characters '0' - '9' and 'A' - 'F'."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class SnaControlPointName(TextualConvention, OctetString):
    description = "A fully qualified SNA control point name, consisting of a 1 to 8 character network identifier (NetId), a period ('.'), and a 1 to 8 character control point name (CpName). The NetId and CpName are constructed from the uppercase letters 'A' - 'Z' and the numerics '0' - '9', all encoded in ASCII, with the restriction that the first character of each must be a letter. Trailing blanks are not allowed. Earlier versions of SNA permitted three additional characters in NetIds and CpNames: '#', '@', and '$'. While this use of these characters has been retired, a Management Station should still accept them for backward compatibility."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 17)

class SnaClassOfServiceName(TextualConvention, OctetString):
    description = "An SNA class-of-service (COS) name, ranging from 1 to 8 ASCII characters. COS names take one of two forms: - a user-defined COS name is constructed from the uppercase letters 'A' - 'Z' and the numerics '0' - '9', with the restriction that the first character of the name must be a letter. - an SNA-defined user-session COS name begins with the character '#', which is followed by up to seven additional characters from the set of uppercase letters and numerics. Trailing blanks are not allowed in either form of COS name. A zero-length string indicates that a COS name is not available."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

class SnaModeName(TextualConvention, OctetString):
    description = "An SNA mode name, ranging from 1 to 8 ASCII characters. Mode names take one of two forms: - a user-defined mode name is constructed from the uppercase letters 'A' - 'Z' and the numerics '0' - '9', with the restriction that the first character of the name must be a letter. - an SNA-defined user-session mode name begins with the character '#', which is followed by up to seven additional characters from the set of uppercase letters and numerics. Trailing blanks are not allowed in either form of mode name, with the single exception of the all-blank mode name, where a string consisting of 8 blanks is returned. A zero-length string indicates that a mode name is not available."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

class SnaSenseData(TextualConvention, OctetString):
    description = "To facilitate their display by a Management Station, sense data objects in the MIB are represented as OCTET STRINGS containing eight ASCII characters. Eight '0' characters indicates that no sense data identifying an SNA error condition is available. An SNA sense data is represented as eight hexadecimal digits, using the characters '0' - '9' and 'A' - 'F'."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class DisplayableDlcAddress(TextualConvention, OctetString):
    description = "DLC address of a port or link station, represented as an OCTET STRING containing 0 to 64 ASCII characters. A Management Station should use a value of this type only for display. The 'real' DLC address, i.e., the sequence of bytes that flow in the DLC header, is often available in a DLC-specific MIB. The zero-length string indicates that the DLC address in question is not known to the agent."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class AppnNodeCounter(TextualConvention, Counter32):
    description = 'An object providing global statistics for the entire APPN node. A Management Station can detect discontinuities in this counter by monitoring the appnNodeCounterDisconTime object.'
    status = 'current'

class AppnPortCounter(TextualConvention, Counter32):
    description = 'An object providing statistics for an APPN port. A Management Station can detect discontinuities in this counter by monitoring the appnPortCounterDisconTime object.'
    status = 'current'

class AppnLinkStationCounter(TextualConvention, Counter32):
    description = 'An object providing statistics for an APPN link station. A Management Station can detect discontinuities in this counter by monitoring the appnLsCounterDisconTime object.'
    status = 'current'

class AppnTopologyEntryTimeLeft(TextualConvention, Integer32):
    description = 'Number of days before deletion of this entry from the topology database. Range is 0-15. A value of 0 indicates that the entry is either in the process of being deleted, or is being marked for deletion at the next garbage collection cycle.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 15)

class AppnTgDlcData(TextualConvention, OctetString):
    description = 'DLC-specific data related to a connection network transmission group. For other TGs, a zero-length string is returned. Examples of the type of data returned by an object with this syntax include the following: Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Switch - dial digits This MIB does not specify formats for these or any other types of DLC-specific data. Formats may, however, be specified in documents related to a particular DLC. The contents of an object with this syntax correspond to the contents of the DLC-specific subfields of cv46, documented in (6).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class AppnTgEffectiveCapacity(TextualConvention, OctetString):
    description = 'A value representing the effective capacity of a transmission group. This is an administratively assigned value derived from the link bandwidth and maximum load factor. It is encoded in the same way as byte 7 of cv47, and represents a floating-point number in units of 300 bits per second.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 1)
    fixedLength = 1

class AppnTgSecurity(TextualConvention, Integer32):
    description = "A value representing the level of security on a transmission group. A class of service definition includes an indication of the acceptable TG security value(s) for that class of service. The following seven values are defined: nonsecure(1) - (X'01'): none of the values listed below; for example, satellite-connected or located in a nonsecure country publicSwitchedNetwork(32) - (X'20'): public switched network; secure in the sense that there is no predetermined route that traffic will take undergroundCable(64) - (X'40'): underground cable; located in a secure country (as determined by the network administrator) secureConduit(96) - (X'60'): secure conduit, not guarded; for example, pressurized pipe guardedConduit(128) - (X'80'): guarded conduit; protected against physical tapping encrypted(160) - (X'A0'): link-level encryption is provided guardedRadiation(192) - (X'C0'): guarded conduit containing the transmission medium; protected against physical and radiation tapping"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))
    namedValues = NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))

class AppnTgDelay(TextualConvention, OctetString):
    description = "Relative amount of time that it takes for a signal to travel the length of a logical link. This time is represented in microseconds, using the same encoding scheme used in cv47 in a topology update. Some of the more common values, along with their encoded hex values, are: minimum(0), X'00' negligible(384), X'4C' terrestrial(9216), X'71' packet(147456), X'91' long(294912), X'99' maximum(2013265920) X'FF' "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 1)
    fixedLength = 1

appnObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1))
appnNode = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1))
appnGeneralInfoAndCaps = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1))
appnNnUniqueInfoAndCaps = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2))
appnEnUniqueCaps = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 3))
appnPortInformation = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4))
appnLinkStationInformation = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5))
appnVrnInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6))
appnNodeCpName = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 1), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeCpName.setStatus('current')
if mibBuilder.loadTexts: appnNodeCpName.setDescription('Administratively assigned network name for this node.')
appnNodeId = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 3), SnaNodeIdentification()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeId.setStatus('current')
if mibBuilder.loadTexts: appnNodeId.setDescription("This node's Node Identification, which it sends in bytes 2-5 of XID.")
appnNodeType = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("networkNode", 1), ("endNode", 2), ("t21len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeType.setStatus('current')
if mibBuilder.loadTexts: appnNodeType.setDescription('Type of APPN node: networkNode(1) - APPN network node endNode(2) - APPN end node t21len(4) - LEN end node Note: A branch network node SHALL return endNode(2) as the value of this object. A management application can distinguish between a branch network node and an actual end node by retrieving the appnNodeBrNn object.')
appnNodeUpTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 5), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeUpTime.setStatus('current')
if mibBuilder.loadTexts: appnNodeUpTime.setDescription('Amount of time (in hundredths of a second) since the APPN node was last reinitialized.')
appnNodeParallelTg = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeParallelTg.setStatus('current')
if mibBuilder.loadTexts: appnNodeParallelTg.setDescription('Indicates whether this node supports parallel TGs.')
appnNodeAdaptiveBindPacing = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeAdaptiveBindPacing.setStatus('current')
if mibBuilder.loadTexts: appnNodeAdaptiveBindPacing.setDescription('Indicates whether this node supports adaptive bind pacing for dependent LUs.')
appnNodeHprSupport = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noHprSupport", 1), ("hprBaseOnly", 2), ("rtpTower", 3), ("controlFlowsOverRtpTower", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprSupport.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprSupport.setDescription("Indicates this node's level of support for high-performance routing (HPR): noHprSupport(1) - no HPR support hprBaseOnly(2) - HPR base (option set 1400) supported rtpTower(3) - HPR base and RTP tower (option set 1401) supported controlFlowsOverRtpTower(4) - HPR base, RTP tower, and control flows over RTP (option set 1402) supported This object corresponds to cv4580, byte 9, bits 3-4.")
appnNodeMaxSessPerRtpConn = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeMaxSessPerRtpConn.setStatus('current')
if mibBuilder.loadTexts: appnNodeMaxSessPerRtpConn.setDescription('This object represents a configuration parameter indicating the maximum number of sessions that the APPN node is to put on any HPR connection. The value is zero if not applicable.')
appnNodeHprIntRteSetups = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 10), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprIntRteSetups.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprIntRteSetups.setDescription('The total number of HPR route setups received for routes passing through this node since the node was last reinitialized.')
appnNodeHprIntRteRejects = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 11), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprIntRteRejects.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprIntRteRejects.setDescription('The number of HPR route setups rejected by this node for routes passing through it since the node was last reinitialized.')
appnNodeHprOrgRteSetups = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 12), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprOrgRteSetups.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprOrgRteSetups.setDescription('The total number of HPR route setups sent for routes originating in this node since the node was last reinitialized.')
appnNodeHprOrgRteRejects = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 13), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprOrgRteRejects.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprOrgRteRejects.setDescription('The number of HPR route setups rejected by other nodes for routes originating in this node since the node was last reinitialized.')
appnNodeHprEndRteSetups = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 14), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprEndRteSetups.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprEndRteSetups.setDescription('The total number of HPR route setups received for routes ending in this node since the node was last reinitialized.')
appnNodeHprEndRteRejects = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 15), AppnNodeCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeHprEndRteRejects.setStatus('current')
if mibBuilder.loadTexts: appnNodeHprEndRteRejects.setDescription('The number of HPR route setups rejected by this node for routes ending in it since the node was last reinitialized.')
appnNodeCounterDisconTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeCounterDisconTime.setStatus('current')
if mibBuilder.loadTexts: appnNodeCounterDisconTime.setDescription('The value of the sysUpTime object the last time the APPN node was reinitialized.')
appnNodeLsCounterType = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("noAnr", 2), ("anrForLocalNces", 3), ("allAnr", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeLsCounterType.setStatus('current')
if mibBuilder.loadTexts: appnNodeLsCounterType.setDescription('Indicates which ANR traffic, if any, the node includes in the counts returned by the APPN link station counters appnLsInXidBytes, appnLsInMsgBytes, appnLsInXidFrames, appnLsInMsgFrames, appnLsOutXidBytes, appnLsOutMsgBytes, appnLsOutXidFrames, and appnLsOutMsgFrames. These counters are always incremented for ISR traffic. The following values are defined: other(1) - the node does something different from all the options listed below noAnr(2) - the node does not include any ANR traffic in these counts anrForLocalNces(3) - the node includes in these counts ANR traffic for RTP connections that terminate in this node, but not ANR traffic for RTP connections that pass through this node without terminating in it allAnr(4) - the node includes all ANR traffic in these counts.')
appnNodeBrNn = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeBrNn.setStatus('current')
if mibBuilder.loadTexts: appnNodeBrNn.setDescription('Indicates whether this node is currently configured as a branch network node. Note: throughout the remainder of this MIB module, branch network node is treated as a third node type, parallel to network node and end node. This is not how branch network nodes are treated in the base APPN architecture, but it increases clarity to do it here.')
appnNodeNnCentralDirectory = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnCentralDirectory.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnCentralDirectory.setDescription('Indicates whether this node supports central directory services. This object corresponds to cv4580, byte 8, bit 1.')
appnNodeNnTreeCache = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noCache", 1), ("cacheNoIncrUpdate", 2), ("cacheWithIncrUpdate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnTreeCache.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnTreeCache.setDescription("Indicates this node's level of support for caching of route trees. Three levels are specified: noCache(1) - caching of route trees is not supported cacheNoIncrUpdate(2) - caching of route trees is supported, but without incremental updates cacheWithIncrUpdate(3) - caching of route trees with incremental updates is supported")
appnNodeNnRouteAddResist = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnRouteAddResist.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnRouteAddResist.setDescription('Route addition resistance. This administratively assigned value indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing. This object corresponds to cv4580, byte 6.')
appnNodeNnIsr = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnIsr.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnIsr.setDescription('Indicates whether the node supports intermediate session routing. This object corresponds to cv4580, byte 8, bit 2.')
appnNodeNnFrsn = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnFrsn.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnFrsn.setDescription('The last flow-reduction sequence number (FRSN) sent by this node in a topology update to an adjacent network node.')
appnNodeNnPeriBorderSup = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnPeriBorderSup.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnPeriBorderSup.setDescription('Indicates whether this node has peripheral border node support. This object corresponds to cv4580, byte 9, bit 0.')
appnNodeNnInterchangeSup = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnInterchangeSup.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnInterchangeSup.setDescription('Indicates whether this node has interchange node support. This object corresponds to cv4580, byte 9, bit 1.')
appnNodeNnExteBorderSup = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnExteBorderSup.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnExteBorderSup.setDescription('Indicates whether this node has extended border node support. This object corresponds to cv4580, byte 9, bit 2.')
appnNodeNnSafeStoreFreq = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setUnits('TDUs').setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnNodeNnSafeStoreFreq.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnSafeStoreFreq.setDescription('The topology safe store frequency. If this number is not zero, then the topology database is saved each time the total number of topology database updates (TDUs) received by this node increases by this number. A value of zero indicates that the topology database is not being saved.')
appnNodeNnRsn = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnRsn.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnRsn.setDescription('Resource sequence number for this node, which it assigns and controls. This object corresponds to the numeric value in cv4580, bytes 2-5.')
appnNodeNnCongested = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnCongested.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnCongested.setDescription('Indicates whether this node is congested. Other network nodes stop routing traffic to this node while this flag is on. This object corresponds to cv4580, byte 7, bit 0.')
appnNodeNnIsrDepleted = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnIsrDepleted.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnIsrDepleted.setDescription('Indicate whether intermediated session routing resources are depleted. Other network nodes stop routing traffic through this node while this flag is on. This object corresponds to cv4580, byte 7, bit 1.')
appnNodeNnQuiescing = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnQuiescing.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnQuiescing.setDescription('Indicates whether the node is quiescing. This object corresponds to cv4580, byte 7, bit 5.')
appnNodeNnGateway = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 2, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeNnGateway.setStatus('current')
if mibBuilder.loadTexts: appnNodeNnGateway.setDescription('Indicates whether the node has gateway services support. This object corresponds to cv4580, byte 8, bit 0.')
appnNodeEnModeCosMap = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 3, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeEnModeCosMap.setStatus('current')
if mibBuilder.loadTexts: appnNodeEnModeCosMap.setDescription('Indicates whether this end node supports mode name to COS name mapping.')
appnNodeEnNnServer = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 3, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeEnNnServer.setStatus('current')
if mibBuilder.loadTexts: appnNodeEnNnServer.setDescription('The fully qualified name of the current NN server for this end node. An NN server is identified using the format specified in the SnaControlPointName textual convention. The value is a zero-length string when there is no active NN server. A branch network node shall also implement this object.')
appnNodeEnLuSearch = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 3, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeEnLuSearch.setStatus('current')
if mibBuilder.loadTexts: appnNodeEnLuSearch.setDescription('Indicates whether the node is to be searched for LUs as part of a network broadcast search. A branch network node shall also implement this object.')
appnPortTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1), )
if mibBuilder.loadTexts: appnPortTable.setStatus('current')
if mibBuilder.loadTexts: appnPortTable.setDescription("The Port table describes the configuration and current status of the ports used by APPN. When it is known to the APPN component, an OBJECT IDENTIFIER pointing to additional information related to the port is included. This may, but need not, be a RowPointer to an ifTable entry for a DLC interface immediately 'below' the port.")
appnPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1), ).setIndexNames((0, "APPN-MIB", "appnPortName"))
if mibBuilder.loadTexts: appnPortEntry.setStatus('current')
if mibBuilder.loadTexts: appnPortEntry.setDescription('The port name is used as the index to this table.')
appnPortName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10)))
if mibBuilder.loadTexts: appnPortName.setStatus('current')
if mibBuilder.loadTexts: appnPortName.setDescription('Administratively assigned name for this APPN port.')
appnPortCommand = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deactivate", 1), ("activate", 2), ("recycle", 3), ("ready", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnPortCommand.setStatus('current')
if mibBuilder.loadTexts: appnPortCommand.setDescription('Object by which a Management Station can activate, deactivate, or recycle (i.e., cause to be deactivated and then immediately activated) a port, by setting the value to activate(1), deactivate(2), or recycle(3), respectively. The value ready(4) is returned on GET operations until a SET has been processed; after that the value received on the most recent SET is returned.')
appnPortOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortOperState.setStatus('current')
if mibBuilder.loadTexts: appnPortOperState.setDescription('Indicates the current state of this port: inactive(1) - port is inactive pendactive(2) - port is pending active active(3) - port is active pendinact(4) - port is pending inactive')
appnPortDlcType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 4), IANAifType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDlcType.setStatus('current')
if mibBuilder.loadTexts: appnPortDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
appnPortPortType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("leased", 1), ("switched", 2), ("sharedAccessFacilities", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortPortType.setStatus('current')
if mibBuilder.loadTexts: appnPortPortType.setDescription('Identifies the type of line used by this port: leased(1) - leased line switched(2) - switched line sharedAccessFacilities(3) - shared access facility, such as a LAN.')
appnPortSIMRIM = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortSIMRIM.setStatus('current')
if mibBuilder.loadTexts: appnPortSIMRIM.setDescription('Indicates whether Set Initialization Mode (SIM) and Receive Initialization Mode (RIM) are supported for this port.')
appnPortLsRole = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("negotiable", 3), ("abm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortLsRole.setStatus('current')
if mibBuilder.loadTexts: appnPortLsRole.setDescription("Initial role for link stations activated through this port. The values map to the following settings in the initial XID, where 'ABM' indicates asynchronous balanced mode and 'NRM' indicated normal response mode: primary(1): ABM support = 0 ( = NRM) role = 01 ( = primary) secondary(2): ABM support = 0 ( = NRM) role = 00 ( = secondary) negotiable(3): ABM support = 0 ( = NRM) role = 11 ( = negotiable) abm(4): ABM support = 1 ( = ABM) role = 11 ( = negotiable)")
appnPortNegotLs = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortNegotLs.setStatus('current')
if mibBuilder.loadTexts: appnPortNegotLs.setDescription('Indicates whether the node supports negotiable link stations for this port.')
appnPortDynamicLinkSupport = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDynamicLinkSupport.setStatus('current')
if mibBuilder.loadTexts: appnPortDynamicLinkSupport.setDescription('Indicates whether this node allows call-in on this port from nodes not defined locally.')
appnPortMaxRcvBtuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(99, 32767))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortMaxRcvBtuSize.setStatus('current')
if mibBuilder.loadTexts: appnPortMaxRcvBtuSize.setDescription('Maximum Basic Transmission Unit (BTU) size that a link station on this port can receive. This object corresponds to bytes 21-22 of XID3.')
appnPortMaxIframeWindow = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 11), Gauge32()).setUnits('I-frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortMaxIframeWindow.setStatus('current')
if mibBuilder.loadTexts: appnPortMaxIframeWindow.setDescription('Maximum number of I-frames that can be received by the XID sender before an acknowledgement is received.')
appnPortDefLsGoodXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 12), AppnPortCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDefLsGoodXids.setStatus('current')
if mibBuilder.loadTexts: appnPortDefLsGoodXids.setDescription('The total number of successful XID exchanges that have occurred on all defined link stations on this port since the last time this port was started.')
appnPortDefLsBadXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 13), AppnPortCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDefLsBadXids.setStatus('current')
if mibBuilder.loadTexts: appnPortDefLsBadXids.setDescription('The total number of unsuccessful XID exchanges that have occurred on all defined link stations on this port since the last time this port was started.')
appnPortDynLsGoodXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 14), AppnPortCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDynLsGoodXids.setStatus('current')
if mibBuilder.loadTexts: appnPortDynLsGoodXids.setDescription('The total number of successful XID exchanges that have occurred on all dynamic link stations on this port since the last time this port was started.')
appnPortDynLsBadXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 15), AppnPortCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDynLsBadXids.setStatus('current')
if mibBuilder.loadTexts: appnPortDynLsBadXids.setDescription('The total number of unsuccessful XID exchanges that have occurred on all dynamic link stations on this port since the last time this port was started.')
appnPortSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 16), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortSpecific.setStatus('current')
if mibBuilder.loadTexts: appnPortSpecific.setDescription('Identifies the object, e.g., one in a DLC-specific MIB, that can provide additional information related to this port. If the agent is unable to identify such an object, the value 0.0 is returned.')
appnPortDlcLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 17), DisplayableDlcAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDlcLocalAddr.setStatus('current')
if mibBuilder.loadTexts: appnPortDlcLocalAddr.setDescription('Local DLC address of this port.')
appnPortCounterDisconTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 4, 1, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortCounterDisconTime.setStatus('current')
if mibBuilder.loadTexts: appnPortCounterDisconTime.setDescription('The value of the sysUpTime object the last time the port was started.')
appnLsTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1), )
if mibBuilder.loadTexts: appnLsTable.setStatus('current')
if mibBuilder.loadTexts: appnLsTable.setDescription('This table contains detailed information about the link station configuration and its current status.')
appnLsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1), ).setIndexNames((0, "APPN-MIB", "appnLsName"))
if mibBuilder.loadTexts: appnLsEntry.setStatus('current')
if mibBuilder.loadTexts: appnLsEntry.setDescription('This table is indexed by the link station name.')
appnLsName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10)))
if mibBuilder.loadTexts: appnLsName.setStatus('current')
if mibBuilder.loadTexts: appnLsName.setDescription('Administratively assigned name for the link station. The name can be from one to ten characters.')
appnLsCommand = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deactivate", 1), ("activate", 2), ("recycle", 3), ("ready", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLsCommand.setStatus('current')
if mibBuilder.loadTexts: appnLsCommand.setDescription('Object by which a Management Station can activate, deactivate, or recycle (i.e., cause to be deactivated and then immediately reactivated) a link station, by setting the value to activate(1), deactivate(2), or recycle(3), respectively. The value ready(4) is returned on GET operations until a SET has been processed; after that the value received on the most recent SET is returned.')
appnLsOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("inactive", 1), ("sentConnectOut", 2), ("pendXidExch", 3), ("sendActAs", 4), ("sendSetMode", 5), ("otherPendingActive", 6), ("active", 7), ("sentDeactAsOrd", 8), ("sentDiscOrd", 9), ("sentDiscImmed", 10), ("otherPendingInact", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOperState.setStatus('current')
if mibBuilder.loadTexts: appnLsOperState.setDescription("State of this link station. The comments map these more granular states to the 'traditional' four states for SNA resources. Values (2) through (5) represent the normal progression of states when a link station is being activated. Value (6) represents some other state of a link station in the process of being activated. Values (8) through (10) represent different ways a link station can be deactivated. Value (11) represents some other state of a link station in the process of being deactivated.")
appnLsPortName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsPortName.setStatus('current')
if mibBuilder.loadTexts: appnLsPortName.setDescription('Administratively assigned name for the port associated with this link station. The name can be from one to ten characters.')
appnLsDlcType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 5), IANAifType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsDlcType.setStatus('current')
if mibBuilder.loadTexts: appnLsDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
appnLsDynamic = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsDynamic.setStatus('current')
if mibBuilder.loadTexts: appnLsDynamic.setDescription('Identifies whether this is a dynamic link station. Dynamic link stations are created when links that have not been locally defined are established by adjacent nodes.')
appnLsAdjCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 7), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsAdjCpName.setStatus('current')
if mibBuilder.loadTexts: appnLsAdjCpName.setDescription("Fully qualified name of the adjacent node for this link station. An adjacent node is identified using the format specified in the SnaControlPointName textual convention. The value of this object is determined as follows: 1. If the adjacent node's name was received on XID, it is returned. 2. If the adjacent node's name was not received on XID, but a locally-defined value is available, it is returned. 3. Otherwise a string of length 0 is returned, indicating that no name is known for the adjacent node.")
appnLsAdjNodeType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 255))).clone(namedValues=NamedValues(("networkNode", 1), ("endNode", 2), ("t21len", 4), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsAdjNodeType.setStatus('current')
if mibBuilder.loadTexts: appnLsAdjNodeType.setDescription('Node type of the adjacent node on this link: networkNode(1) - APPN network node endNode(2) - APPN end node t21len(4) - LEN end node unknown(255) - the agent does not know the node type of the adjacent node ')
appnLsTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsTgNum.setStatus('current')
if mibBuilder.loadTexts: appnLsTgNum.setDescription('Number associated with the TG to this link station, with a range from 0 to 256. A value of 256 indicates that the TG number has not been negotiated and is unknown at this time.')
appnLsLimResource = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsLimResource.setStatus('current')
if mibBuilder.loadTexts: appnLsLimResource.setDescription('Indicates whether the link station is a limited resource. A link station that is a limited resource is deactivated when it is no longer in use.')
appnLsActOnDemand = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsActOnDemand.setStatus('current')
if mibBuilder.loadTexts: appnLsActOnDemand.setDescription('Indicates whether the link station is activatable on demand. Such a link station is reported in the topology as active regardless of its actual state, so that it can be considered in route calculations. If the link station is inactive and is chosen for a route, it will be activated at that time.')
appnLsMigration = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMigration.setStatus('current')
if mibBuilder.loadTexts: appnLsMigration.setDescription("Indicates whether this link station will be used for connections to down-level or migration partners. In general, migration nodes do not append their CP names on XID3. Such nodes: (1) will not support parallel TGs, (2) should be sent an ACTIVATE PHYSICAL UNIT (ACTPU), provided that the partner supports ACTPUs, and (3) should not be sent segmented BINDs. However, if this node receives an XID3 with an appended CP name, then the partner node will not be treated as a migration node. In the case of DYNAMIC TGs this object should be set to 'no'.")
appnLsPartnerNodeId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 13), SnaNodeIdentification()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsPartnerNodeId.setStatus('current')
if mibBuilder.loadTexts: appnLsPartnerNodeId.setDescription("The partner's Node Identification, from bytes 2-5 of the XID received from the partner. If this value is not available, then the characters '00000000' are returned.")
appnLsCpCpSessionSupport = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCpCpSessionSupport.setStatus('current')
if mibBuilder.loadTexts: appnLsCpCpSessionSupport.setDescription("Indicates whether CP-CP sessions are supported by this link station. For a dynamic link, this object represents the default ('Admin') value.")
appnLsMaxSendBtuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(99, 32767))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMaxSendBtuSize.setStatus('current')
if mibBuilder.loadTexts: appnLsMaxSendBtuSize.setDescription("Numeric value between 99 and 32767 inclusive indicating the maximum number of bytes in a Basic Transmission Unit (BTU) sent on this link. When the link state (returned by the appnLsOperState object) is inactive or pending active, the value configured at this node is returned. When the link state is active, the value that was negotiated for it is returned. This negotiated value is the smaller of the value configured at this node and the partner's maximum receive BTU length, received in XID.")
appnLsInXidBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 16), AppnLinkStationCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInXidBytes.setStatus('current')
if mibBuilder.loadTexts: appnLsInXidBytes.setDescription('Number of XID bytes received. All of the bytes in the SNA basic transmission unit (BTU), i.e., all of the bytes in the DLC XID Information Field, are counted.')
appnLsInMsgBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 17), AppnLinkStationCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInMsgBytes.setStatus('current')
if mibBuilder.loadTexts: appnLsInMsgBytes.setDescription('Number of message (I-frame) bytes received. All of the bytes in the SNA basic transmission unit (BTU), including the transmission header (TH), are counted.')
appnLsInXidFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 18), AppnLinkStationCounter()).setUnits('XID frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInXidFrames.setStatus('current')
if mibBuilder.loadTexts: appnLsInXidFrames.setDescription('Number of XID frames received.')
appnLsInMsgFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 19), AppnLinkStationCounter()).setUnits('I-frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInMsgFrames.setStatus('current')
if mibBuilder.loadTexts: appnLsInMsgFrames.setDescription('Number of message (I-frame) frames received.')
appnLsOutXidBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 20), AppnLinkStationCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutXidBytes.setStatus('current')
if mibBuilder.loadTexts: appnLsOutXidBytes.setDescription('Number of XID bytes sent. All of the bytes in the SNA basic transmission unit (BTU), i.e., all of the bytes in the DLC XID Information Field, are counted.')
appnLsOutMsgBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 21), AppnLinkStationCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutMsgBytes.setStatus('current')
if mibBuilder.loadTexts: appnLsOutMsgBytes.setDescription('Number of message (I-frame) bytes sent. All of the bytes in the SNA basic transmission unit (BTU), including the transmission header (TH), are counted.')
appnLsOutXidFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 22), AppnLinkStationCounter()).setUnits('XID frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutXidFrames.setStatus('current')
if mibBuilder.loadTexts: appnLsOutXidFrames.setDescription('Number of XID frames sent.')
appnLsOutMsgFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 23), AppnLinkStationCounter()).setUnits('I-frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutMsgFrames.setStatus('current')
if mibBuilder.loadTexts: appnLsOutMsgFrames.setDescription('Number of message (I-frame) frames sent.')
appnLsEchoRsps = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 24), AppnLinkStationCounter()).setUnits('echo responses').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsEchoRsps.setStatus('current')
if mibBuilder.loadTexts: appnLsEchoRsps.setDescription('Number of echo responses returned from adjacent link station. A response should be returned for each test frame sent by this node. Test frames are sent to adjacent nodes periodically to verify connectivity and to measure the actual round trip time, that is, the time interval from when the test frame is sent until when the response is received.')
appnLsCurrentDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 25), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCurrentDelay.setStatus('current')
if mibBuilder.loadTexts: appnLsCurrentDelay.setDescription('The time that it took for the last test signal to be sent and returned from this link station to the adjacent link station. This time is represented in milliseconds.')
appnLsMaxDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 26), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMaxDelay.setStatus('current')
if mibBuilder.loadTexts: appnLsMaxDelay.setDescription('The longest time it took for a test signal to be sent and returned from this link station to the adjacent link station. This time is represented in milliseconds . The value 0 is returned if no test signal has been sent and returned.')
appnLsMinDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 27), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMinDelay.setStatus('current')
if mibBuilder.loadTexts: appnLsMinDelay.setDescription('The shortest time it took for a test signal to be sent and returned from this link station to the adjacent link station. This time is represented in milliseconds. The value 0 is returned if no test signal has been sent and returned.')
appnLsMaxDelayTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 28), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMaxDelayTime.setStatus('current')
if mibBuilder.loadTexts: appnLsMaxDelayTime.setDescription('The time when the longest delay occurred. This time can be used to identify when this high water mark occurred in relation to other events in the APPN node, for example, the time at which an APPC session was either terminated or failed to be established. This latter time is available in the appcHistSessTime object in the APPC MIB. The value 00000000 is returned if no test signal has been sent and returned.')
appnLsGoodXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 29), AppnLinkStationCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsGoodXids.setStatus('current')
if mibBuilder.loadTexts: appnLsGoodXids.setDescription('The total number of successful XID exchanges that have occurred on this link station since the time it was started.')
appnLsBadXids = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 30), AppnLinkStationCounter()).setUnits('XID exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsBadXids.setStatus('current')
if mibBuilder.loadTexts: appnLsBadXids.setDescription('The total number of unsuccessful XID exchanges that have occurred on this link station since the time it was started.')
appnLsSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 31), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsSpecific.setStatus('current')
if mibBuilder.loadTexts: appnLsSpecific.setDescription('Identifies the object, e.g., one in a DLC-specific MIB, that can provide additional information related to this link station. If the agent is unable to identify such an object, the value 0.0 is returned.')
appnLsActiveTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 32), Unsigned32()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsActiveTime.setStatus('current')
if mibBuilder.loadTexts: appnLsActiveTime.setDescription('The cumulative amount of time since the node was last reinitialized, measured in hundredths of a second, that this link station has been in the active state. A zero value indicates that the link station has never been active since the node was last reinitialized.')
appnLsCurrentStateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 33), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCurrentStateTime.setStatus('current')
if mibBuilder.loadTexts: appnLsCurrentStateTime.setDescription('The amount of time, measured in hundredths of a second, that the link station has been in its current state.')
appnLsHprSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noHprSupport", 1), ("hprBaseOnly", 2), ("rtpTower", 3), ("controlFlowsOverRtpTower", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsHprSup.setStatus('current')
if mibBuilder.loadTexts: appnLsHprSup.setDescription('Indicates the level of high performance routing (HPR) support over this link: noHprSupport(1) - no HPR support hprBaseOnly(2) - HPR base (option set 1400) supported rtpTower(3) - HPR base and RTP tower (option set 1401) supported controlFlowsOverRtpTower(4) - HPR base, RTP tower, and control flows over RTP (option set 1402) supported If the link is not active, the defined value is returned.')
appnLsErrRecoSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 35), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsErrRecoSup.setStatus('current')
if mibBuilder.loadTexts: appnLsErrRecoSup.setDescription('Indicates whether the link station is supporting HPR link-level error recovery.')
appnLsForAnrLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsForAnrLabel.setStatus('current')
if mibBuilder.loadTexts: appnLsForAnrLabel.setDescription('The forward Automatic Network Routing (ANR) label for this link station. If the link does not support HPR or the value is unknown, a zero-length string is returned.')
appnLsRevAnrLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsRevAnrLabel.setStatus('current')
if mibBuilder.loadTexts: appnLsRevAnrLabel.setDescription('The reverse Automatic Network Routing (ANR) label for this link station. If the link does not support HPR or the value is unknown, a zero-length string is returned.')
appnLsCpCpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCpCpNceId.setStatus('current')
if mibBuilder.loadTexts: appnLsCpCpNceId.setDescription('The network connection endpoint identifier (NCE ID) for CP-CP sessions if this node supports the HPR transport tower, a zero-length string if the value is unknown or not meaningful for this node.')
appnLsRouteNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 39), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsRouteNceId.setStatus('current')
if mibBuilder.loadTexts: appnLsRouteNceId.setDescription('The network connection endpoint identifier (NCE ID) for Route Setup if this node supports the HPR transport tower, a zero- length string if the value is unknown or not meaningful for this node.')
appnLsBfNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsBfNceId.setStatus('current')
if mibBuilder.loadTexts: appnLsBfNceId.setDescription('The network connection endpoint identifier (NCE ID) for the APPN/HPR boundary function if this node supports the HPR transport tower, a zero-length string if the value is unknown or not meaningful for this node.')
appnLsLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 41), DisplayableDlcAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsLocalAddr.setStatus('current')
if mibBuilder.loadTexts: appnLsLocalAddr.setDescription('Local address of this link station.')
appnLsRemoteAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 42), DisplayableDlcAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: appnLsRemoteAddr.setDescription('Address of the remote link station on this link.')
appnLsRemoteLsName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsRemoteLsName.setStatus('current')
if mibBuilder.loadTexts: appnLsRemoteLsName.setDescription('Remote link station discovered from the XID exchange. The name can be from one to ten characters. A zero-length string indicates that the value is not known.')
appnLsCounterDisconTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 44), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCounterDisconTime.setStatus('current')
if mibBuilder.loadTexts: appnLsCounterDisconTime.setDescription('The value of the sysUpTime object the last time the link station was started.')
appnLsMltgMember = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 1, 1, 45), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMltgMember.setStatus('current')
if mibBuilder.loadTexts: appnLsMltgMember.setDescription("Indicates whether the link is a member of a multi-link TG. If the link's TG has been brought up as a multi-link TG, then the link is reported as a member of a multi-link TG, even if it is currently the only active link in the TG.")
appnLsStatusTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2), )
if mibBuilder.loadTexts: appnLsStatusTable.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusTable.setDescription('This table contains information related to exceptional and potentially exceptional conditions that occurred during the activation, XID exchange, and termination of a connection. No entries are created when these activities proceed normally. It is an implementation option when entries are removed from this table.')
appnLsStatusEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1), ).setIndexNames((0, "APPN-MIB", "appnLsStatusIndex"))
if mibBuilder.loadTexts: appnLsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusEntry.setDescription('This table is indexed by the LsStatusIndex, which is an integer that is continuously updated until it eventually wraps.')
appnLsStatusIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: appnLsStatusIndex.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusIndex.setDescription('Table index. The value of the index begins at zero and is incremented up to a maximum value of 2**31-1 (2,147,483,647) before wrapping.')
appnLsStatusTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusTime.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusTime.setDescription('Time when the exception condition occurred. This time can be used to identify when this event occurred in relation to other events in the APPN node, for example, the time at which an APPC session was either terminated or failed to be established. This latter time is available in the appcHistSessTime object in the APPC MIB.')
appnLsStatusLsName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusLsName.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusLsName.setDescription('Administratively assigned name for the link station experiencing the condition.')
appnLsStatusCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusCpName.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusCpName.setDescription("Fully qualified name of the adjacent node for this link station. An adjacent node is identified using the format specified in the SnaControlPointName textual convention. The value of this object is determined as follows: 1. If the adjacent node's name was received on XID, it is returned. 2. If the adjacent node's name was not received on XID, but a locally-defined value is available, it is returned. 3. Otherwise a string of length 0 is returned, indicating that no name is known for the adjacent node.")
appnLsStatusPartnerId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 5), SnaNodeIdentification()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusPartnerId.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusPartnerId.setDescription("The partner's Node Identification, from bytes 2-5 of the XID received from the partner. If this value is not available, then the characters '00000000' are returned.")
appnLsStatusTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusTgNum.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusTgNum.setDescription('Number associated with the TG to this link station, with a range from 0 to 256. A value of 256 indicates that the TG number was unknown at the time of the failure.')
appnLsStatusGeneralSense = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 7), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusGeneralSense.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusGeneralSense.setDescription('The error sense data associated with the start sequence of activation of a link up to the beginning of the XID sequence. This is the sense data that came from Configuration Services whenever the link did not activate or when it went inactive.')
appnLsStatusRetry = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusRetry.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusRetry.setDescription('Indicates whether the node will retry the start request to activate the link.')
appnLsStatusEndSense = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 9), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusEndSense.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusEndSense.setDescription('The sense data associated with the termination of the link connection to adjacent node. This is the sense data that came from the DLC layer.')
appnLsStatusXidLocalSense = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 10), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusXidLocalSense.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusXidLocalSense.setDescription('The sense data associated with the rejection of the XID. This is the sense data that came from the local node (this node) when it built the XID Negotiation Error control vector (cv22) to send to the remote node.')
appnLsStatusXidRemoteSense = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 11), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusXidRemoteSense.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusXidRemoteSense.setDescription('The sense data the adjacent node returned to this node indicating the reason the XID was rejected. This is the sense data that came from the remote node in the XID Negotiation Error control vector (cv22) it sent to the local node (this node).')
appnLsStatusXidByteInError = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusXidByteInError.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusXidByteInError.setDescription("This object identifies the actual byte in the XID that caused the error. The value 65536 indicates that the object has no meaning. For values in the range 0-65535, this object corresponds to bytes 2-3 of the XID Negotiation (X'22') control vector.")
appnLsStatusXidBitInError = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusXidBitInError.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusXidBitInError.setDescription("This object identifies the actual bit in error (0 through 7) within the errored byte of the XID. The value 8 indicates that this object has no meaning. For values in the range 0-7, this object corresponds to byte 4 of the XID Negotiation (X'22') control vector.")
appnLsStatusDlcType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 14), IANAifType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusDlcType.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
appnLsStatusLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 15), DisplayableDlcAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusLocalAddr.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusLocalAddr.setDescription('Local address of this link station.')
appnLsStatusRemoteAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 5, 2, 1, 16), DisplayableDlcAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStatusRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: appnLsStatusRemoteAddr.setDescription('Address of the remote link station on this link.')
appnVrnTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6, 1), )
if mibBuilder.loadTexts: appnVrnTable.setStatus('current')
if mibBuilder.loadTexts: appnVrnTable.setDescription('This table relates a virtual routing node to an APPN port.')
appnVrnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6, 1, 1), ).setIndexNames((0, "APPN-MIB", "appnVrnName"), (0, "APPN-MIB", "appnVrnTgNum"), (0, "APPN-MIB", "appnVrnPortName"))
if mibBuilder.loadTexts: appnVrnEntry.setStatus('current')
if mibBuilder.loadTexts: appnVrnEntry.setDescription('This table is indexed by the virtual routing node name, TG number, and port name. There will be a matching entry in the appnLocalTgTable to represent status and characteristics of the TG representing each virtual routing node definition.')
appnVrnName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6, 1, 1, 1), SnaControlPointName())
if mibBuilder.loadTexts: appnVrnName.setStatus('current')
if mibBuilder.loadTexts: appnVrnName.setDescription('Administratively assigned name of the virtual routing node. This is a fully qualified name, and matches the appnLocalTgDest name in the appnLocalTgTable.')
appnVrnTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnVrnTgNum.setStatus('current')
if mibBuilder.loadTexts: appnVrnTgNum.setDescription('Number associated with the transmission group representing this virtual routing node definition.')
appnVrnPortName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnVrnPortName.setStatus('current')
if mibBuilder.loadTexts: appnVrnPortName.setDescription('The name of the port this virtual routing node definition is defined to.')
appnNn = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 2))
appnNnTopo = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1))
appnNnTopology = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2))
appnNnTopoMaxNodes = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1, 1), Gauge32()).setUnits('node entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTopoMaxNodes.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoMaxNodes.setDescription('Maximum number of node entries allowed in the APPN topology database. It is an implementation choice whether to count only network-node entries, or to count all node entries. If the number of node entries exceeds this value, APPN will issue an Alert and the node can no longer participate as a network node. The value 0 indicates that the local node has no defined limit, and the number of node entries is bounded only by memory.')
appnNnTopoCurNumNodes = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1, 2), Gauge32()).setUnits('node entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTopoCurNumNodes.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoCurNumNodes.setDescription("Current number of node entries in this node's topology database. It is an implementation choice whether to count only network-node entries, or to count all node entries, but an implementation must make the same choice here that it makes for the appnNnTopoMaxNodes object. If this value exceeds the maximum number of nodes allowed (appnNnTopoMaxNodes, if that field in not 0), APPN Alert CPDB002 is issued.")
appnNnTopoNodePurges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1, 3), AppnNodeCounter()).setUnits('node entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTopoNodePurges.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoNodePurges.setDescription("Total number of topology node records purged from this node's topology database since the node was last reinitialized.")
appnNnTopoTgPurges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1, 4), AppnNodeCounter()).setUnits('TG entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTopoTgPurges.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoTgPurges.setDescription("Total number of topology TG records purged from this node's topology database since the node was last reinitialized.")
appnNnTopoTotalTduWars = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 1, 5), AppnNodeCounter()).setUnits('TDU wars').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTopoTotalTduWars.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoTotalTduWars.setDescription('Number of TDU wars detected by this node since its last initialization.')
appnNnTopologyFRTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3), )
if mibBuilder.loadTexts: appnNnTopologyFRTable.setStatus('current')
if mibBuilder.loadTexts: appnNnTopologyFRTable.setDescription('Portion of the APPN topology database that describes all of the APPN network nodes and virtual routing nodes known to this node.')
appnNnTopologyFREntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1), ).setIndexNames((0, "APPN-MIB", "appnNnNodeFRFrsn"), (0, "APPN-MIB", "appnNnNodeFRName"))
if mibBuilder.loadTexts: appnNnTopologyFREntry.setStatus('current')
if mibBuilder.loadTexts: appnNnTopologyFREntry.setDescription('The FRSN and the fully qualified node name are used to index this table.')
appnNnNodeFRFrsn = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: appnNnNodeFRFrsn.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last relative time this resource was updated at the agent node.')
appnNnNodeFRName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 2), SnaControlPointName())
if mibBuilder.loadTexts: appnNnNodeFRName.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRName.setDescription('Administratively assigned network name that is locally defined at each network node.')
appnNnNodeFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 3), AppnTopologyEntryTimeLeft()).setUnits('days').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFREntryTimeLeft.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFREntryTimeLeft.setDescription('Number of days before deletion of this network node entry.')
appnNnNodeFRType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("networkNode", 1), ("virtualRoutingNode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRType.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRType.setDescription('Type of APPN node.')
appnNnNodeFRRsn = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRRsn.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRRsn.setDescription('Resource sequence number, which is assigned and controlled by the network node that owns this resource. An odd number indicates that information about the resource is inconsistent. This object corresponds to the numeric value in cv4580, bytes 2-5.')
appnNnNodeFRRouteAddResist = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRRouteAddResist.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRRouteAddResist.setDescription('Route addition resistance. This administratively assigned value indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing. This object corresponds to cv4580, byte 6.')
appnNnNodeFRCongested = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRCongested.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRCongested.setDescription('Indicates whether this node is congested. This node is not be included in route selection by other nodes when this congestion exists. This object corresponds to cv4580, byte 7, bit 0.')
appnNnNodeFRIsrDepleted = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRIsrDepleted.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRIsrDepleted.setDescription('Indicates whether intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted. This object corresponds to cv4580, byte 7, bit 1.')
appnNnNodeFRQuiescing = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRQuiescing.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRQuiescing.setDescription('Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing. This object corresponds to cv4580, byte 7, bit 5.')
appnNnNodeFRGateway = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRGateway.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRGateway.setDescription('Indicates whether the node provide gateway services. This object corresponds to cv4580, byte 8, bit 0.')
appnNnNodeFRCentralDirectory = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRCentralDirectory.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRCentralDirectory.setDescription('Indicates whether the node supports central directory services. This object corresponds to cv4580, byte 8, bit 1.')
appnNnNodeFRIsr = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRIsr.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRIsr.setDescription('Indicates whether the node supports intermediate session routing (ISR). This object corresponds to cv4580, byte 8, bit 2.')
appnNnNodeFRGarbageCollect = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRGarbageCollect.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRGarbageCollect.setDescription('Indicates whether the node has been marked for garbage collection (deletion from the topology database) upon the next garbage collection cycle. This object corresponds to cv4580, byte 7, bit 3.')
appnNnNodeFRHprSupport = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noHprSupport", 1), ("hprBaseOnly", 2), ("rtpTower", 3), ("controlFlowsOverRtpTower", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRHprSupport.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRHprSupport.setDescription("Indicates the node's level of support for high-performance routing (HPR): noHprSupport(1) - no HPR support hprBaseOnly(2) - HPR base (option set 1400) supported rtpTower(3) - HPR base and RTP tower (option set 1401) supported controlFlowsOverRtpTower(4) - HPR base, RTP tower, and control flows over RTP (option set 1402) supported This object corresponds to cv4580, byte 9, bits 3-4.")
appnNnNodeFRPeriBorderSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRPeriBorderSup.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRPeriBorderSup.setDescription('Indicates whether this node has peripheral border node support. This object corresponds to cv4580, byte 9, bit 0.')
appnNnNodeFRInterchangeSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRInterchangeSup.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRInterchangeSup.setDescription('Indicates whether this node has interchange node support. This object corresponds to cv4580, byte 9, bit 1.')
appnNnNodeFRExteBorderSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRExteBorderSup.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRExteBorderSup.setDescription('Indicates whether this node has extended border node support. This object corresponds to cv4580, byte 9, bit 2.')
appnNnNodeFRBranchAwareness = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 3, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeFRBranchAwareness.setStatus('current')
if mibBuilder.loadTexts: appnNnNodeFRBranchAwareness.setDescription('Indicates whether this node supports branch awareness. This object corresponds to cv4580, byte 8, bit 4.')
appnNnTgTopologyFRTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4), )
if mibBuilder.loadTexts: appnNnTgTopologyFRTable.setStatus('current')
if mibBuilder.loadTexts: appnNnTgTopologyFRTable.setDescription('Portion of the APPN topology database that describes all of the APPN transmissions groups between nodes in the database.')
appnNnTgTopologyFREntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1), ).setIndexNames((0, "APPN-MIB", "appnNnTgFRFrsn"), (0, "APPN-MIB", "appnNnTgFROwner"), (0, "APPN-MIB", "appnNnTgFRDest"), (0, "APPN-MIB", "appnNnTgFRNum"))
if mibBuilder.loadTexts: appnNnTgTopologyFREntry.setStatus('current')
if mibBuilder.loadTexts: appnNnTgTopologyFREntry.setDescription('This table is indexed by four columns: FRSN, TG owner fully qualified node name, TG destination fully qualified node name, and TG number.')
appnNnTgFRFrsn = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: appnNnTgFRFrsn.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
appnNnTgFROwner = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 2), SnaControlPointName())
if mibBuilder.loadTexts: appnNnTgFROwner.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFROwner.setDescription('Administratively assigned name for the originating node for this TG. This is the same name specified in the node table.')
appnNnTgFRDest = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 3), SnaControlPointName())
if mibBuilder.loadTexts: appnNnTgFRDest.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRDest.setDescription('Administratively assigned fully qualified network name for the destination node for this TG.')
appnNnTgFRNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnNnTgFRNum.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRNum.setDescription('Number associated with this transmission group. Range is 0-255.')
appnNnTgFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 5), AppnTopologyEntryTimeLeft()).setUnits('days').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFREntryTimeLeft.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFREntryTimeLeft.setDescription('Number of days before deletion of this network node TG entry if it is not operational or has an odd (inconsistent) RSN.')
appnNnTgFRDestVirtual = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRDestVirtual.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRDestVirtual.setDescription('Indicates whether the destination node is a virtual routing node.')
appnNnTgFRDlcData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 7), AppnTgDlcData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRDlcData.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRDlcData.setDescription('DLC-specific data related to a link connection network.')
appnNnTgFRRsn = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRRsn.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRRsn.setDescription("Current owning node's resource sequence number for this resource. An odd number indicates that information about the resource is inconsistent. This object corresponds to the numeric value in cv47, bytes 2-5")
appnNnTgFROperational = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFROperational.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFROperational.setDescription('Indicates whether the transmission group is operational. This object corresponds to cv47, byte 6, bit 0.')
appnNnTgFRQuiescing = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRQuiescing.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRQuiescing.setDescription("Indicates whether the transmission group is quiescing. If the TG owner is either an extended border node or a branch-aware network node (indicated, respectively, by the appnNnNodeFRExteBorderSup and appnNnNodeFRBranchAwareness objects in the corresponding appnNnTopologyFREntry), then this indicator is artificially set to TRUE in the APPN topology database, to remove the TG from other nodes' route calculations. A management application can determine whether the TG is actually quiescing by examining its appnLocalTgQuiescing object at the TG owner. This object corresponds to cv47, byte 6, bit 2.")
appnNnTgFRCpCpSession = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("supportedUnknownStatus", 1), ("supportedActive", 2), ("notSupported", 3), ("supportedNotActive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRCpCpSession.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRCpCpSession.setDescription("Indicates whether CP-CP sessions are supported on this TG, and whether the TG owner's contention-winner session is active on this TG. Some nodes in the network are not able to differentiate support and status of CP-CP sessions, and thus may report the 'supportedUnknownStatus' value. This object corresponds to cv47, byte 6, bits 3-4.")
appnNnTgFREffCap = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 12), AppnTgEffectiveCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFREffCap.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFREffCap.setDescription('Effective capacity for this TG.')
appnNnTgFRConnCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRConnCost.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRConnCost.setDescription('Cost per connect time. This is an administratively assigned value representing the relative cost per unit of time to use this TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This object corresponds to cv47, byte 13.')
appnNnTgFRByteCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRByteCost.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRByteCost.setDescription('Cost per byte transmitted. This is an administratively assigned value representing the relative cost of transmitting a byte over this TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This object corresponds to cv47, byte 14.')
appnNnTgFRSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 15), AppnTgSecurity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRSecurity.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRSecurity.setDescription('Administratively assigned security level of this TG. This object corresponds to cv47, byte 16.')
appnNnTgFRDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 16), AppnTgDelay()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRDelay.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRDelay.setDescription('Administratively assigned delay associated with this TG. This object corresponds to cv47, byte 17.')
appnNnTgFRUsr1 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRUsr1.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRUsr1.setDescription('First user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG. This object corresponds to cv47, byte 19.')
appnNnTgFRUsr2 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRUsr2.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRUsr2.setDescription('Second user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG. This object corresponds to cv47, byte 20.')
appnNnTgFRUsr3 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRUsr3.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRUsr3.setDescription('Third user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG. This object corresponds to cv47, byte 21.')
appnNnTgFRGarbageCollect = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRGarbageCollect.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRGarbageCollect.setDescription('Indicates whether the TG has been marked for garbage collection (deletion from the topology database) upon the next garbage collection cycle. This object corresponds to cv47, byte 6, bit 1.')
appnNnTgFRSubareaNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRSubareaNum.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRSubareaNum.setDescription('The subarea number associated with this TG. This object corresponds to cv4680, bytes m+2 through m+5.')
appnNnTgFRHprSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRHprSup.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRHprSup.setDescription('Indicates whether high performance routing (HPR) is supported over this TG. This object corresponds to cv4680, byte m+1, bit 2.')
appnNnTgFRDestHprTrans = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRDestHprTrans.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRDestHprTrans.setDescription('Indicates whether the destination node supports high performance routing (HPR) transport tower. This object corresponds to cv4680, byte m+1, bit 7.')
appnNnTgFRTypeIndicator = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("appnOrBfTg", 2), ("interchangeTg", 3), ("virtualRouteTg", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRTypeIndicator.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRTypeIndicator.setDescription('Indicates the type of the TG. This object corresponds to cv4680, byte m+1, bits 3-4.')
appnNnTgFRIntersubnet = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 25), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRIntersubnet.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRIntersubnet.setDescription('Indicates whether the transmission group is an intersubnet TG, which defines a border between subnetworks. This object corresponds to cv4680, byte m+1, bit 5.')
appnNnTgFRMltgLinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 26), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRMltgLinkType.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRMltgLinkType.setDescription('This object indicates whether the transmission group is a multi-link TG. A TG that has been brought up as a multi-link TG is reported as one, even if it currently has only one link active. This object corresponds to cv47, byte 6, bit 5.')
appnNnTgFRBranchTg = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 2, 2, 4, 1, 27), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFRBranchTg.setStatus('current')
if mibBuilder.loadTexts: appnNnTgFRBranchTg.setDescription('Indicates whether the transmission group is a branch TG (equivalently, whether the destination of the transmission group is a branch network node). This object corresponds to cv4680, byte m+1, bit 1.')
appnLocalTopology = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 3))
appnLocalTgTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1), )
if mibBuilder.loadTexts: appnLocalTgTable.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgTable.setDescription('TG Table describes all of the TGs owned by this node. The TG destination can be a virtual node, network node, LEN node, or end node.')
appnLocalTgEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1), ).setIndexNames((0, "APPN-MIB", "appnLocalTgDest"), (0, "APPN-MIB", "appnLocalTgNum"))
if mibBuilder.loadTexts: appnLocalTgEntry.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgEntry.setDescription('This table is indexed by the destination CpName and the TG number.')
appnLocalTgDest = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 1), SnaControlPointName())
if mibBuilder.loadTexts: appnLocalTgDest.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgDest.setDescription('Administratively assigned name of the destination node for this TG. This is the fully qualified name of a network node, end node, LEN node, or virtual routing node.')
appnLocalTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnLocalTgNum.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgNum.setDescription('Number associated with this transmission group.')
appnLocalTgDestVirtual = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgDestVirtual.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgDestVirtual.setDescription('Indicates whether the destination node for this TG is a virtual routing node.')
appnLocalTgDlcData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 4), AppnTgDlcData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgDlcData.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgDlcData.setDescription('DLC-specific data related to a link connection network.')
appnLocalTgPortName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgPortName.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgPortName.setDescription('Administratively assigned name for the local port associated with this TG. A zero-length string indicates that this value is unknown.')
appnLocalTgQuiescing = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgQuiescing.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgQuiescing.setDescription('Indicates whether the transmission group is quiescing.')
appnLocalTgOperational = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgOperational.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgOperational.setDescription('Indicates whether the transmission group is operational.')
appnLocalTgCpCpSession = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("supportedUnknownStatus", 1), ("supportedActive", 2), ("notSupported", 3), ("supportedNotActive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgCpCpSession.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgCpCpSession.setDescription("Indicates whether CP-CP sessions are supported on this TG, and whether the TG owner's contention-winner session is active on this TG. Some nodes in the network are not able to differentiate support and status of CP-CP sessions, and thus may report the 'supportedUnknownStatus' value.")
appnLocalTgEffCap = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 9), AppnTgEffectiveCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgEffCap.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgEffCap.setDescription('Effective capacity for this TG.')
appnLocalTgConnCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgConnCost.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
appnLocalTgByteCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgByteCost.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255.')
appnLocalTgSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 12), AppnTgSecurity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgSecurity.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgSecurity.setDescription('Administratively assigned security level of this TG.')
appnLocalTgDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 13), AppnTgDelay()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgDelay.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgDelay.setDescription('Administratively assigned delay associated with this TG.')
appnLocalTgUsr1 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgUsr1.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgUsr1.setDescription('First user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalTgUsr2 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgUsr2.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgUsr2.setDescription('Second user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalTgUsr3 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgUsr3.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgUsr3.setDescription('Third user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalTgHprSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noHprSupport", 1), ("hprBaseOnly", 2), ("rtpTower", 3), ("controlFlowsOverRtpTower", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgHprSup.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgHprSup.setDescription('Indicates the level of high performance routing (HPR) support over this TG : noHprSupport(1) - no HPR support hprBaseOnly(2) - HPR base (option set 1400) supported rtpTower(3) - HPR base and RTP tower (option set 1401) supported controlFlowsOverRtpTower(4) - HPR base, RTP tower, and control flows over RTP (option set 1402) supported')
appnLocalTgIntersubnet = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgIntersubnet.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgIntersubnet.setDescription('Indicates whether the transmission group is an intersubnet TG, which defines a border between subnetworks.')
appnLocalTgMltgLinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgMltgLinkType.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgMltgLinkType.setDescription('This object indicates whether the transmission group is a multi-link TG. A TG that has been brought up as a multi-link TG is reported as one, even if it currently has only one link active.')
appnLocalTgBranchLinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("other", 1), ("uplink", 2), ("downlink", 3), ("downlinkToBranchNetworkNode", 4), ("none", 5), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgBranchLinkType.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgBranchLinkType.setDescription("Branch link type of this TG: other(1) = the agent has determined the TG's branch link type to be a value other than branch uplink or branch downlink. This is the value used for a connection network TG owned by a branch network node. uplink(2) = the TG is a branch uplink. downlink(3) = the TG is a branch downlink to an end node. downlinkToBranchNetworkNode(4) = the TG is a branch downlink to a cascaded branch network node. none(5) = the TG is not a branch TG. unknown(255) = the agent cannot determine the branch link type of the TG.")
appnLocalEnTgTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2), )
if mibBuilder.loadTexts: appnLocalEnTgTable.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgTable.setDescription('Table describing all of the TGs owned by the end nodes known to this node via TG registration. This node does not represent its own view of the TG on behalf of the partner node in this table. The TG destination can be a virtual routing node, network node, or end node.')
appnLocalEnTgEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1), ).setIndexNames((0, "APPN-MIB", "appnLocalEnTgOrigin"), (0, "APPN-MIB", "appnLocalEnTgDest"), (0, "APPN-MIB", "appnLocalEnTgNum"))
if mibBuilder.loadTexts: appnLocalEnTgEntry.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgEntry.setDescription('This table requires multiple indexes to uniquely identify each TG. They are originating CPname, destination CPname, and the TG number.')
appnLocalEnTgOrigin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 1), SnaControlPointName())
if mibBuilder.loadTexts: appnLocalEnTgOrigin.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgOrigin.setDescription('Administratively assigned name of the origin node for this TG. This is a fully qualified network name.')
appnLocalEnTgDest = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 2), SnaControlPointName())
if mibBuilder.loadTexts: appnLocalEnTgDest.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgDest.setDescription('Administratively assigned name of the destination node for this TG. This is the fully qualified name of a network node, end node, LEN node, or virtual routing node.')
appnLocalEnTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnLocalEnTgNum.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgNum.setDescription('Number associated with this transmission group.')
appnLocalEnTgEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 4), AppnTopologyEntryTimeLeft()).setUnits('days').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgEntryTimeLeft.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgEntryTimeLeft.setDescription('Number of days before deletion of this end node TG entry.')
appnLocalEnTgDestVirtual = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgDestVirtual.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgDestVirtual.setDescription('Indicates whether the destination node is a virtual routing node.')
appnLocalEnTgDlcData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 6), AppnTgDlcData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgDlcData.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgDlcData.setDescription('DLC-specific data related to a link connection network.')
appnLocalEnTgOperational = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgOperational.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgOperational.setDescription('Indicates whether the transmission group is operational.')
appnLocalEnTgCpCpSession = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("supportedUnknownStatus", 1), ("supportedActive", 2), ("notSupported", 3), ("supportedNotActive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgCpCpSession.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgCpCpSession.setDescription("Indicates whether CP-CP sessions are supported on this TG, and whether the TG owner's contention-winner session is active on this TG. Some nodes in the network are not able to differentiate support and status of CP-CP sessions, and thus may report the 'supportedUnknownStatus' value.")
appnLocalEnTgEffCap = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 9), AppnTgEffectiveCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgEffCap.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgEffCap.setDescription('Effective capacity for this TG.')
appnLocalEnTgConnCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgConnCost.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
appnLocalEnTgByteCost = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgByteCost.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0, which means no cost, to 255.')
appnLocalEnTgSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 12), AppnTgSecurity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgSecurity.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgSecurity.setDescription('Administratively assigned security level of this TG.')
appnLocalEnTgDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 13), AppnTgDelay()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgDelay.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgDelay.setDescription('Administratively assigned delay associated with this TG.')
appnLocalEnTgUsr1 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgUsr1.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgUsr1.setDescription('First user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalEnTgUsr2 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgUsr2.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgUsr2.setDescription('Second user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalEnTgUsr3 = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgUsr3.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgUsr3.setDescription('Third user-defined TG characteristic for this TG. This is an administratively assigned value associated with the TG.')
appnLocalEnTgMltgLinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 3, 2, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalEnTgMltgLinkType.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTgMltgLinkType.setDescription('This object indicates whether the transmission group is a multi-link TG. A TG that has been brought up as a multi-link TG is reported as one, even if it currently has only one link active.')
appnDir = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 4))
appnDirPerf = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1))
appnDirMaxCaches = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 1), Unsigned32()).setUnits('directory entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirMaxCaches.setStatus('current')
if mibBuilder.loadTexts: appnDirMaxCaches.setDescription('Maximum number of cache entries allowed. This is an administratively assigned value.')
appnDirCurCaches = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 2), Gauge32()).setUnits('directory entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirCurCaches.setStatus('current')
if mibBuilder.loadTexts: appnDirCurCaches.setDescription('Current number of cache entries.')
appnDirCurHomeEntries = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 3), Gauge32()).setUnits('directory entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirCurHomeEntries.setStatus('current')
if mibBuilder.loadTexts: appnDirCurHomeEntries.setDescription('Current number of home entries.')
appnDirRegEntries = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 4), Gauge32()).setUnits('directory entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirRegEntries.setStatus('current')
if mibBuilder.loadTexts: appnDirRegEntries.setDescription('Current number of registered entries.')
appnDirInLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 5), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirInLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirInLocates.setDescription('Number of directed Locates received since the node was last reinitialized.')
appnDirInBcastLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 6), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirInBcastLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirInBcastLocates.setDescription('Number of broadcast Locates received since the node was last reinitialized.')
appnDirOutLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 7), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirOutLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirOutLocates.setDescription('Number of directed Locates sent since the node was last reinitialized.')
appnDirOutBcastLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 8), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirOutBcastLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirOutBcastLocates.setDescription('Number of broadcast Locates sent since the node was last reinitialized.')
appnDirNotFoundLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 9), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirNotFoundLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirNotFoundLocates.setDescription("Number of directed Locates returned with a 'not found' since the node was last reinitialized.")
appnDirNotFoundBcastLocates = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 10), AppnNodeCounter()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirNotFoundBcastLocates.setStatus('current')
if mibBuilder.loadTexts: appnDirNotFoundBcastLocates.setDescription("Number of broadcast Locates returned with a 'not found' since the node was last reinitialized.")
appnDirLocateOutstands = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 1, 11), Gauge32()).setUnits('Locate messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirLocateOutstands.setStatus('current')
if mibBuilder.loadTexts: appnDirLocateOutstands.setDescription('Current number of outstanding Locates, both directed and broadcast. This value varies. A value of zero indicates that no Locates are unanswered.')
appnDirTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2), )
if mibBuilder.loadTexts: appnDirTable.setStatus('current')
if mibBuilder.loadTexts: appnDirTable.setDescription('Table containing information about all known LUs.')
appnDirEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1), ).setIndexNames((0, "APPN-MIB", "appnDirLuName"))
if mibBuilder.loadTexts: appnDirEntry.setStatus('current')
if mibBuilder.loadTexts: appnDirEntry.setDescription('This table is indexed by the LU name.')
appnDirLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnDirLuName.setStatus('current')
if mibBuilder.loadTexts: appnDirLuName.setDescription("Fully qualified network LU name in the domain of the serving network node. Entries take one of three forms: - Explicit entries do not contain the character '*'. - Partial wildcard entries have the form 'ccc*', where 'ccc' represents one to sixteen characters in a legal SNA LuName. - A full wildcard entry consists of the single character '*'")
appnDirNnServerName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 2), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirNnServerName.setStatus('current')
if mibBuilder.loadTexts: appnDirNnServerName.setDescription('Fully qualified control point (CP) name of the network node server. For unassociated end node entries, a zero-length string is returned.')
appnDirLuOwnerName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 3), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirLuOwnerName.setStatus('current')
if mibBuilder.loadTexts: appnDirLuOwnerName.setDescription('Fully qualified CP name of the node at which the LU is located. This name is the same as the serving NN name when the LU is located at a network node. It is also the same as the fully qualified LU name when this is the control point LU for this node.')
appnDirLuLocation = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local", 1), ("domain", 2), ("xdomain", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirLuLocation.setStatus('current')
if mibBuilder.loadTexts: appnDirLuLocation.setDescription('Specifies the location of the LU with respect to the local node.')
appnDirType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("home", 1), ("cache", 2), ("registered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirType.setStatus('current')
if mibBuilder.loadTexts: appnDirType.setDescription('Directory types are: 1 - Home The LU is in the domain of the local node, and the LU information has been configured at the local node. 2 - Cache The LU has previously been located by a broadcast search, and the location information has been saved. 3 - Registered The LU is at an end node that is in the domain of the local network node. Registered entries are registered by the served end node.')
appnDirApparentLuOwnerName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 4, 2, 1, 6), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirApparentLuOwnerName.setStatus('current')
if mibBuilder.loadTexts: appnDirApparentLuOwnerName.setDescription("Fully qualified CP name of the node at which the LU appears to be located. This object and the appnDirLuOwnerName object are related as follows: Implementations that support this object save in their directory database information about an LU's owning control point that was communicated in two control vectors: - an Associated Resource Entry (X'3C') CV with resource type X'00F4' (ENCP) - a Real Owning Control Point (X'4A') CV. The X'4A' CV is created by a branch network node to preserve the name of the real owning control point for an LU below the branch network node, before it overwrites this name with its own name in the X'3C' CV. The X'4A' CV is not present for LUs that are not below branch network nodes. If the information a node has about an LU's owning CP came only in a X'3C' CV, then the name from the X'3C' is returned in the appnDirLuOwnerName object, and a null string is returned in this object. If the information a node has about an LU's owning CP came in both X'3C' and X'4A' CVs, then the name from the X'4A' is returned in the appnDirLuOwnerName object, and the name from the X'3C' (which will be the branch network node's name) is returned in this object.")
appnCos = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 5))
appnCosModeTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 1), )
if mibBuilder.loadTexts: appnCosModeTable.setStatus('current')
if mibBuilder.loadTexts: appnCosModeTable.setDescription('Table representing all of the defined mode names for this node. The table contains the matching COS name for each mode name.')
appnCosModeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 1, 1), ).setIndexNames((0, "APPN-MIB", "appnCosModeName"))
if mibBuilder.loadTexts: appnCosModeEntry.setStatus('current')
if mibBuilder.loadTexts: appnCosModeEntry.setDescription('This table is indexed by the mode name.')
appnCosModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 1, 1, 1), SnaModeName())
if mibBuilder.loadTexts: appnCosModeName.setStatus('current')
if mibBuilder.loadTexts: appnCosModeName.setDescription('Administratively assigned name for this mode.')
appnCosModeCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 1, 1, 2), SnaClassOfServiceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosModeCosName.setStatus('current')
if mibBuilder.loadTexts: appnCosModeCosName.setDescription('Administratively assigned name for this class of service.')
appnCosNameTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 2), )
if mibBuilder.loadTexts: appnCosNameTable.setStatus('current')
if mibBuilder.loadTexts: appnCosNameTable.setDescription('Table mapping all of the defined class-of-service names for this node to their network transmission priorities.')
appnCosNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 2, 1), ).setIndexNames((0, "APPN-MIB", "appnCosName"))
if mibBuilder.loadTexts: appnCosNameEntry.setStatus('current')
if mibBuilder.loadTexts: appnCosNameEntry.setDescription('The COS name is the index to this table.')
appnCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 2, 1, 1), SnaClassOfServiceName())
if mibBuilder.loadTexts: appnCosName.setStatus('current')
if mibBuilder.loadTexts: appnCosName.setDescription('Administratively assigned name for this class of service.')
appnCosTransPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTransPriority.setStatus('current')
if mibBuilder.loadTexts: appnCosTransPriority.setDescription("Transmission priority for this class of service: low(1) - (X'01'): low priority medium(2) - (X'02'): medium priority high(3) - (X'03'): high priority network(4) - (X'04'): network priority")
appnCosNodeRowTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3), )
if mibBuilder.loadTexts: appnCosNodeRowTable.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowTable.setDescription('This table contains all node-row information for all classes of service defined in this node.')
appnCosNodeRowEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1), ).setIndexNames((0, "APPN-MIB", "appnCosNodeRowName"), (0, "APPN-MIB", "appnCosNodeRowIndex"))
if mibBuilder.loadTexts: appnCosNodeRowEntry.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowEntry.setDescription('A node entry for a given class of service.')
appnCosNodeRowName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 1), SnaClassOfServiceName())
if mibBuilder.loadTexts: appnCosNodeRowName.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowName.setDescription('Administratively assigned name for this class of service.')
appnCosNodeRowIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnCosNodeRowIndex.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowIndex.setDescription('Subindex under appnCosNodeRowName, corresponding to a row in the node table for the class of service identified in appnCosNodeRowName. For each class of service, this subindex orders rows in the appnCosNodeRowTable in the same order as that used for route calculation in the APPN node.')
appnCosNodeRowWgt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeRowWgt.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowWgt.setDescription('Weight to be associated with the nodes that fit the criteria specified by this node row. This value can either be a character representation of an integer, or a formula for calculating the weight.')
appnCosNodeRowResistMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeRowResistMin.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowResistMin.setDescription('Minimum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
appnCosNodeRowResistMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeRowResistMax.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowResistMax.setDescription('Maximum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
appnCosNodeRowMinCongestAllow = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeRowMinCongestAllow.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowMinCongestAllow.setDescription('Indicates whether low congestion will be tolerated. This object and appnCosNodeRowMaxCongestAllow together delineate a range of acceptable congestion states for a node. For the ordered pair (minimum congestion allowed, maximum congestion allowed), the values are interpreted as follows: - (0,0): only low congestion is acceptable - (0,1): either low or high congestion is acceptable - (1,1): only high congestion is acceptable. Note that the combination (1,0) is not defined, since it would identify a range whose lower bound was high congestion and whose upper bound was low congestion.')
appnCosNodeRowMaxCongestAllow = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeRowMaxCongestAllow.setStatus('current')
if mibBuilder.loadTexts: appnCosNodeRowMaxCongestAllow.setDescription('Indicates whether low congestion will be tolerated. This object and appnCosNodeRowMinCongestAllow together delineate a range of acceptable congestion states for a node. For the ordered pair (minimum congestion allowed, maximum congestion allowed), the values are interpreted as follows: - (0,0): only low congestion is acceptable - (0,1): either low or high congestion is acceptable - (1,1): only high congestion is acceptable. Note that the combination (1,0) is not defined, since it would identify a range whose lower bound was high congestion and whose upper bound was low congestion.')
appnCosTgRowTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4), )
if mibBuilder.loadTexts: appnCosTgRowTable.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowTable.setDescription('Table containing all the TG-row information for all classes of service defined in this node.')
appnCosTgRowEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1), ).setIndexNames((0, "APPN-MIB", "appnCosTgRowName"), (0, "APPN-MIB", "appnCosTgRowIndex"))
if mibBuilder.loadTexts: appnCosTgRowEntry.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowEntry.setDescription('A TG entry for a given class of service.')
appnCosTgRowName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 1), SnaClassOfServiceName())
if mibBuilder.loadTexts: appnCosTgRowName.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowName.setDescription('Administratively assigned name for this class of service.')
appnCosTgRowIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnCosTgRowIndex.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowIndex.setDescription('Subindex under appnCosTgRowName, corresponding to a row in the TG table for the class of service identified in appnCosTgRowName. For each class of service, this subindex orders rows in the appnCosTgRowTable in the same order as that used for route calculation in the APPN node.')
appnCosTgRowWgt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowWgt.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowWgt.setDescription('Weight to be associated with the TGs that fit the criteria specified by this TG row. This value can either be a character representation of an integer, or a formula for calculating the weight.')
appnCosTgRowEffCapMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 4), AppnTgEffectiveCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowEffCapMin.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowEffCapMin.setDescription('Minimum acceptable capacity for this class of service.')
appnCosTgRowEffCapMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 5), AppnTgEffectiveCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowEffCapMax.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowEffCapMax.setDescription('Maximum acceptable capacity for this class of service.')
appnCosTgRowConnCostMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowConnCostMin.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowConnCostMin.setDescription('Minimum acceptable cost per connect time for this class of service. Cost per connect time: a value representing the relative cost per unit of time to use this TG. Range is from 0, which means no cost, to 255.')
appnCosTgRowConnCostMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowConnCostMax.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowConnCostMax.setDescription('Maximum acceptable cost per connect time for this class of service. Cost per connect time: a value representing the relative cost per unit of time to use this TG. Range is from 0, which means no cost, to 255.')
appnCosTgRowByteCostMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowByteCostMin.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowByteCostMin.setDescription('Minimum acceptable cost per byte transmitted for this class of service. Cost per byte transmitted: a value representing the relative cost per unit of time to use this TG. Range is from 0, which means no cost, to 255.')
appnCosTgRowByteCostMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowByteCostMax.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowByteCostMax.setDescription('Maximum acceptable cost per byte transmitted for this class of service. Cost per byte transmitted: a value representing the relative cost of transmitting a byte over this TG. Range is from 0, which means no cost, to 255.')
appnCosTgRowSecurityMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 10), AppnTgSecurity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowSecurityMin.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowSecurityMin.setDescription('Minimum acceptable security for this class of service.')
appnCosTgRowSecurityMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 11), AppnTgSecurity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowSecurityMax.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowSecurityMax.setDescription('Maximum acceptable security for this class of service.')
appnCosTgRowDelayMin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 12), AppnTgDelay()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowDelayMin.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowDelayMin.setDescription('Minimum acceptable propagation delay for this class of service.')
appnCosTgRowDelayMax = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 13), AppnTgDelay()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowDelayMax.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowDelayMax.setDescription('Maximum acceptable propagation delay for this class of service.')
appnCosTgRowUsr1Min = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr1Min.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr1Min.setDescription('Minimum acceptable value for this user-defined characteristic.')
appnCosTgRowUsr1Max = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr1Max.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr1Max.setDescription('Maximum acceptable value for this user-defined characteristic.')
appnCosTgRowUsr2Min = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr2Min.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr2Min.setDescription('Minimum acceptable value for this user-defined characteristic.')
appnCosTgRowUsr2Max = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr2Max.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr2Max.setDescription('Maximum acceptable value for this user-defined characteristic.')
appnCosTgRowUsr3Min = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr3Min.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr3Min.setDescription('Minimum acceptable value for this user-defined characteristic.')
appnCosTgRowUsr3Max = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 5, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgRowUsr3Max.setStatus('current')
if mibBuilder.loadTexts: appnCosTgRowUsr3Max.setDescription('Maximum acceptable value for this user-defined characteristic.')
appnSessIntermediate = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 6))
appnIsInGlobal = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1))
appnIsInGlobeCtrAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2), ("ready", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsInGlobeCtrAdminStatus.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeCtrAdminStatus.setDescription('Object by which a Management Station can deactivate or activate capture of intermediate-session counts and names, by setting the value to notActive(1) or active(2), respectively. The value ready(3) is returned on GET operations until a SET has been processed; after that the value received on the most recent SET is returned. The counts referred to here are the eight objects in the AppnIsInTable, from appnIsInP2SFmdPius through appnIsInS2PNonFmdBytes. The names are the four objects in this table, from appnIsInPriLuName through appnIsInCosName. Setting this object to the following values has the following effects: notActive(1) stop collecting count data. If a count is queried, it returns the value 0. Collection of names may, but need not be, disabled. active(2) start collecting count data. If it is supported, collection of names is enabled.')
appnIsInGlobeCtrOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInGlobeCtrOperStatus.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeCtrOperStatus.setDescription('Indicates whether or not the intermediate session counts are active. The counts referred to here are the eight objects in the AppnIsInTable, from appnIsInP2SFmdPius through appnIsInS2PNonFmdBytes. These eight counts are of type Unsigned32 rather than Counter32 because when this object enters the notActive state, either because a Management Station has set appnInInGlobeCtrAdminStatus to notActive or because of a locally-initiated transition, the counts are all reset to 0. The values for this object are: notActive(1): collection of counts is not active; if it is queried, a count returns the value 0. active(2): collection of counts is active.')
appnIsInGlobeCtrStatusTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 3), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInGlobeCtrStatusTime.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeCtrStatusTime.setDescription('The time since the appnIsInGlobeCtrOperStatus object last changed, measured in hundredths of a second. This time can be used to identify when this change occurred in relation to other events in the agent, such as the last time the APPN node was reinitialized.')
appnIsInGlobeRscv = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsInGlobeRscv.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeRscv.setDescription('Indicates the current route selection control vector (RSCV) collection option in effect, and allows a Management Station to change the option. The values for this object are: notActive(1): collection of route selection control vectors is not active. active(2): collection of route selection control vectors is active.')
appnIsInGlobeRscvTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 5), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInGlobeRscvTime.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeRscvTime.setDescription('The time since the appnIsInGlobeRscv object last changed, measured in hundredths of a second. This time can be used to identify when this change occurred in relation to other events in the agent, such as the last time the APPN node was reinitialized.')
appnIsInGlobeActSess = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 6), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInGlobeActSess.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeActSess.setDescription('The number of currently active intermediate sessions.')
appnIsInGlobeHprBfActSess = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 1, 7), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInGlobeHprBfActSess.setStatus('current')
if mibBuilder.loadTexts: appnIsInGlobeHprBfActSess.setDescription('The number of currently active HPR intermediate sessions.')
appnIsInTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2), )
if mibBuilder.loadTexts: appnIsInTable.setStatus('current')
if mibBuilder.loadTexts: appnIsInTable.setDescription('Intermediate Session Information Table')
appnIsInEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1), ).setIndexNames((0, "APPN-MIB", "appnIsInFqCpName"), (0, "APPN-MIB", "appnIsInPcid"))
if mibBuilder.loadTexts: appnIsInEntry.setStatus('current')
if mibBuilder.loadTexts: appnIsInEntry.setDescription('Entry of Intermediate Session Information Table.')
appnIsInFqCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 1), SnaControlPointName())
if mibBuilder.loadTexts: appnIsInFqCpName.setStatus('current')
if mibBuilder.loadTexts: appnIsInFqCpName.setDescription('The network-qualified control point name of the node at which the session and PCID originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. For resources served by a dependent LU requester (DLUR), it is the name of the owning system services control point (SSCP).')
appnIsInPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: appnIsInPcid.setStatus('current')
if mibBuilder.loadTexts: appnIsInPcid.setDescription('The procedure correlation identifier (PCID) of a session. It is an 8-byte value assigned by the primary LU.')
appnIsInSessState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsInSessState.setStatus('current')
if mibBuilder.loadTexts: appnIsInSessState.setDescription('Indicates the state of the session: inactive(1) - session is inactive pendactive(2) - session is pending active active(3) - session is active pendinact(4) - session is pending inactive Active sessions can be deactivated by setting this object to inactive(1).')
appnIsInPriLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPriLuName.setStatus('current')
if mibBuilder.loadTexts: appnIsInPriLuName.setDescription('The primary LU name of the session. A zero-length string indicates that this name is not available.')
appnIsInSecLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSecLuName.setStatus('current')
if mibBuilder.loadTexts: appnIsInSecLuName.setDescription('The secondary LU name of the session. A zero-length string indicates that this name is not available.')
appnIsInModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 6), SnaModeName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInModeName.setStatus('current')
if mibBuilder.loadTexts: appnIsInModeName.setDescription('The mode name used for this session.')
appnIsInCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 7), SnaClassOfServiceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInCosName.setStatus('current')
if mibBuilder.loadTexts: appnIsInCosName.setDescription('The Class of Service (COS) name used for this session.')
appnIsInTransPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInTransPriority.setStatus('current')
if mibBuilder.loadTexts: appnIsInTransPriority.setDescription("Transmission priority for this class of service. Values are: low(1) - (X'01'): low priority medium(2) - (X'02'): medium priority high(3) - (X'03'): high priority network(4) - (X'04'): network priority")
appnIsInSessType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("lu62", 2), ("lu0thru3", 3), ("lu62dlur", 4), ("lu0thru3dlur", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSessType.setStatus('current')
if mibBuilder.loadTexts: appnIsInSessType.setDescription('The type of intermediate session. Defined values are unknown The session type is not known. lu62 A session between LUs of type 6.2 (as indicated by the LU type in Bind) lu0thru3 A session between LUs of type 0, 1, 2, or 3 (as indicated by the LU type in Bind) lu62dlur A session between LUs of type 6.2 (as indicated by the LU type in Bind). One of the LUs is a dependent LU supported by the dependent LU requester (DLUR) function at this node. lu0thru3dlur A session between LUs of type 0, 1, 2, or 3 (as indicated by the LU type in Bind) One of the LUs is a dependent LU supported by the dependent LU requester (DLUR) function at this node.')
appnIsInSessUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 10), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSessUpTime.setStatus('current')
if mibBuilder.loadTexts: appnIsInSessUpTime.setDescription('Length of time the session has been active, measured in hundredths of a second.')
appnIsInCtrUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 11), TimeTicks()).setUnits('hundredths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInCtrUpTime.setStatus('current')
if mibBuilder.loadTexts: appnIsInCtrUpTime.setDescription('Length of time the session counters have been active, measured in hundredths of a second.')
appnIsInP2SFmdPius = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 12), Unsigned32()).setUnits('path information units (PIUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInP2SFmdPius.setStatus('current')
if mibBuilder.loadTexts: appnIsInP2SFmdPius.setDescription('Number of function management data (FMD) path information units (PIUs) sent from the Primary LU to the Secondary LU since the counts were last activated.')
appnIsInS2PFmdPius = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 13), Unsigned32()).setUnits('path information units (PIUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInS2PFmdPius.setStatus('current')
if mibBuilder.loadTexts: appnIsInS2PFmdPius.setDescription('Number of FMD PIUs sent from the Secondary LU to the Primary LU since the counts were last activated.')
appnIsInP2SNonFmdPius = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 14), Unsigned32()).setUnits('path information units (PIUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInP2SNonFmdPius.setStatus('current')
if mibBuilder.loadTexts: appnIsInP2SNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Primary LU to the Secondary LU since the counts were last activated.')
appnIsInS2PNonFmdPius = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 15), Unsigned32()).setUnits('path information units (PIUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInS2PNonFmdPius.setStatus('current')
if mibBuilder.loadTexts: appnIsInS2PNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Secondary LU to the Primary LU since the counts were last activated.')
appnIsInP2SFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 16), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInP2SFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appnIsInP2SFmdBytes.setDescription('Number of FMD bytes sent from the Primary LU to the Secondary LU since the counts were last activated.')
appnIsInS2PFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 17), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInS2PFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appnIsInS2PFmdBytes.setDescription('Number of FMD bytes sent from the Secondary LU to the Primary LU since the counts were last activated.')
appnIsInP2SNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 18), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInP2SNonFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appnIsInP2SNonFmdBytes.setDescription('Number of non-FMD bytes sent from the Primary LU to the Secondary LU since the counts were last activated.')
appnIsInS2PNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 19), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInS2PNonFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appnIsInS2PNonFmdBytes.setDescription('Number of non-FMD bytes sent from the Secondary LU to the Primary LU since the counts were last activated.')
appnIsInPsAdjCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 20), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsAdjCpName.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsAdjCpName.setDescription('The primary stage adjacent CP name of this session. If the session stage traverses an RTP connection, the CP name of the remote RTP endpoint is returned.')
appnIsInPsAdjTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsAdjTgNum.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsAdjTgNum.setDescription("The primary stage adjacent transmission group (TG) number associated with this session. If the session stage traverses an RTP connection, the value 256 is returned. Values between 257 and 300 are available for other possible TG 'stand-ins' that may be added to APPN in the future.")
appnIsInPsSendMaxBtuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(99, 32767))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsSendMaxBtuSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsSendMaxBtuSize.setDescription('The primary stage maximum basic transmission unit (BTU) size for sending data.')
appnIsInPsSendPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsSendPacingType.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsSendPacingType.setDescription('The primary stage type of pacing being used for sending data.')
appnIsInPsSendRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 24), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsSendRpc.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsSendRpc.setDescription('The primary stage send residual pace count. This represents the primary stage number of message units (MUs) that can still be sent in the current session window.')
appnIsInPsSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 25), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsSendNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsSendNxWndwSize.setDescription('The primary stage size of the next window which will be used to send data.')
appnIsInPsRecvPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsRecvPacingType.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsRecvPacingType.setDescription('The primary stage type of pacing being used for receiving data.')
appnIsInPsRecvRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 27), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsRecvRpc.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsRecvRpc.setDescription('The primary stage receive residual pace count. This represents the primary stage number of message units (MUs) that can still be received in the current session window.')
appnIsInPsRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 28), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInPsRecvNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInPsRecvNxWndwSize.setDescription('The primary stage size of the next window which will be used to receive data.')
appnIsInSsAdjCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 29), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsAdjCpName.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsAdjCpName.setDescription('The secondary stage adjacent CP name of this session. If the session stage traverses an RTP connection, the CP name of the remote RTP endpoint is returned.')
appnIsInSsAdjTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsAdjTgNum.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsAdjTgNum.setDescription("The secondary stage adjacent transmission group (TG) number associated with this session. If the session stage traverses an RTP connection, the value 256 is returned. Values between 257 and 300 are available for other possible TG 'stand-ins' that may be added to APPN in the future.")
appnIsInSsSendMaxBtuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(99, 32767))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsSendMaxBtuSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsSendMaxBtuSize.setDescription('The secondary stage maximum basic transmission unit (BTU) size for sending data.')
appnIsInSsSendPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsSendPacingType.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsSendPacingType.setDescription('The secondary stage type of pacing being used for sending data.')
appnIsInSsSendRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 33), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsSendRpc.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsSendRpc.setDescription('The secondary stage send residual pace count. This represents the secondary stage number of message units (MUs) that can still be sent in the current session window.')
appnIsInSsSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 34), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsSendNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsSendNxWndwSize.setDescription('The secondary stage size of the next window which will be used to send data.')
appnIsInSsRecvPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsRecvPacingType.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsRecvPacingType.setDescription('The secondary stage type of pacing being used for receiving data.')
appnIsInSsRecvRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 36), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsRecvRpc.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsRecvRpc.setDescription('The secondary stage receive residual pace count. This represents the secondary stage number of message units (MUs) that can still be received in the current session window.')
appnIsInSsRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 37), Gauge32()).setUnits('message units (MUs)').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInSsRecvNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appnIsInSsRecvNxWndwSize.setDescription('The secondary stage size of the next window which will be used to receive data.')
appnIsInRouteInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInRouteInfo.setStatus('current')
if mibBuilder.loadTexts: appnIsInRouteInfo.setDescription("The route selection control vector (RSCV X'2B') used for this session. It is present for APPN nodes; but is not present for LEN nodes. The format of this vector is described in SNA Formats. If no RSCV is available, a zero-length string is returned.")
appnIsInRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 39), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInRtpNceId.setStatus('current')
if mibBuilder.loadTexts: appnIsInRtpNceId.setDescription('The HPR local Network Connection Endpoint of the session.')
appnIsInRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 2, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsInRtpTcid.setStatus('current')
if mibBuilder.loadTexts: appnIsInRtpTcid.setDescription('The RTP connection local TCID of the session.')
appnIsRtpTable = MibTable((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 3), )
if mibBuilder.loadTexts: appnIsRtpTable.setStatus('current')
if mibBuilder.loadTexts: appnIsRtpTable.setDescription('A table indicating how many ISR sessions are transported by each RTP connection.')
appnIsRtpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 3, 1), ).setIndexNames((0, "APPN-MIB", "appnIsRtpNceId"), (0, "APPN-MIB", "appnIsRtpTcid"))
if mibBuilder.loadTexts: appnIsRtpEntry.setStatus('current')
if mibBuilder.loadTexts: appnIsRtpEntry.setDescription('Entry of Intermediate Session RTP Table.')
appnIsRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnIsRtpNceId.setStatus('current')
if mibBuilder.loadTexts: appnIsRtpNceId.setDescription('The local Network Connection Endpoint of the RTP connection.')
appnIsRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: appnIsRtpTcid.setStatus('current')
if mibBuilder.loadTexts: appnIsRtpTcid.setDescription('The local TCID of the RTP connection.')
appnIsRtpSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 4, 1, 6, 3, 1, 3), Gauge32()).setUnits('sessions').setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsRtpSessions.setStatus('current')
if mibBuilder.loadTexts: appnIsRtpSessions.setDescription('The number of intermediate sessions using this RTP connection.')
appnTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 2))
alertTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 2, 1)).setObjects(("APPN-MIB", "alertIdNumber"), ("APPN-MIB", "affectedObject"))
if mibBuilder.loadTexts: alertTrap.setStatus('current')
if mibBuilder.loadTexts: alertTrap.setDescription('This trap carries a 32-bit SNA Management Services (SNA/MS) Alert ID Number, as specified in SNA/MS Formats.')
alertIdNumber = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: alertIdNumber.setStatus('current')
if mibBuilder.loadTexts: alertIdNumber.setDescription('A 32-bit SNA Management Services (SNA/MS) Alert ID Number, as specified in SNA/MS Formats.')
affectedObject = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 2, 3), VariablePointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: affectedObject.setStatus('current')
if mibBuilder.loadTexts: affectedObject.setDescription('The MIB object associated with the Alert condition, if there is an object associated with it. If no associated object can be identified, the value 0.0 is passed in the trap.')
appnConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 3))
appnCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 3, 1))
appnGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 3, 2))
appnCompliance2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 4, 3, 1, 3)).setObjects(("APPN-MIB", "appnGeneralConfGroup2"), ("APPN-MIB", "appnPortConfGroup"), ("APPN-MIB", "appnLinkConfGroup2"), ("APPN-MIB", "appnLocalTgConfGroup2"), ("APPN-MIB", "appnDirTableConfGroup2"), ("APPN-MIB", "appnNnUniqueConfGroup"), ("APPN-MIB", "appnEnUniqueConfGroup"), ("APPN-MIB", "appnVrnConfGroup"), ("APPN-MIB", "appnNnTopoConfGroup2"), ("APPN-MIB", "appnLocalEnTopoConfGroup2"), ("APPN-MIB", "appnLocalDirPerfConfGroup"), ("APPN-MIB", "appnCosConfGroup"), ("APPN-MIB", "appnIntSessConfGroup"), ("APPN-MIB", "appnHprBaseConfGroup"), ("APPN-MIB", "appnHprRtpConfGroup"), ("APPN-MIB", "appnHprCtrlFlowsRtpConfGroup"), ("APPN-MIB", "appnHprBfConfGroup"), ("APPN-MIB", "appnTrapConfGroup"), ("APPN-MIB", "appnTrapNotifGroup"), ("APPN-MIB", "appnBrNnConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnCompliance2 = appnCompliance2.setStatus('current')
if mibBuilder.loadTexts: appnCompliance2.setDescription('The compliance statement for the SNMPv2 entities that implement the APPN MIB. In the descriptions for the conditionally mandatory groups that follow, the branch network node is treated as a third node type, parallel to network node and end node. This is not how branch network nodes are treated in the base APPN architecture, but it increases clarity here to do it.')
appnGeneralConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 26)).setObjects(("APPN-MIB", "appnNodeCpName"), ("APPN-MIB", "appnNodeId"), ("APPN-MIB", "appnNodeType"), ("APPN-MIB", "appnNodeUpTime"), ("APPN-MIB", "appnNodeParallelTg"), ("APPN-MIB", "appnNodeAdaptiveBindPacing"), ("APPN-MIB", "appnNodeHprSupport"), ("APPN-MIB", "appnNodeCounterDisconTime"), ("APPN-MIB", "appnNodeLsCounterType"), ("APPN-MIB", "appnNodeBrNn"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnGeneralConfGroup2 = appnGeneralConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnGeneralConfGroup2.setDescription('A collection of objects providing the instrumentation of APPN general information and capabilities.')
appnPortConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 2)).setObjects(("APPN-MIB", "appnPortCommand"), ("APPN-MIB", "appnPortOperState"), ("APPN-MIB", "appnPortDlcType"), ("APPN-MIB", "appnPortPortType"), ("APPN-MIB", "appnPortSIMRIM"), ("APPN-MIB", "appnPortLsRole"), ("APPN-MIB", "appnPortNegotLs"), ("APPN-MIB", "appnPortDynamicLinkSupport"), ("APPN-MIB", "appnPortMaxRcvBtuSize"), ("APPN-MIB", "appnPortMaxIframeWindow"), ("APPN-MIB", "appnPortDefLsGoodXids"), ("APPN-MIB", "appnPortDefLsBadXids"), ("APPN-MIB", "appnPortDynLsGoodXids"), ("APPN-MIB", "appnPortDynLsBadXids"), ("APPN-MIB", "appnPortSpecific"), ("APPN-MIB", "appnPortDlcLocalAddr"), ("APPN-MIB", "appnPortCounterDisconTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnPortConfGroup = appnPortConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnPortConfGroup.setDescription('A collection of objects providing the instrumentation of APPN port information.')
appnLinkConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 27)).setObjects(("APPN-MIB", "appnLsCommand"), ("APPN-MIB", "appnLsOperState"), ("APPN-MIB", "appnLsPortName"), ("APPN-MIB", "appnLsDlcType"), ("APPN-MIB", "appnLsDynamic"), ("APPN-MIB", "appnLsAdjCpName"), ("APPN-MIB", "appnLsAdjNodeType"), ("APPN-MIB", "appnLsTgNum"), ("APPN-MIB", "appnLsLimResource"), ("APPN-MIB", "appnLsActOnDemand"), ("APPN-MIB", "appnLsMigration"), ("APPN-MIB", "appnLsPartnerNodeId"), ("APPN-MIB", "appnLsCpCpSessionSupport"), ("APPN-MIB", "appnLsMaxSendBtuSize"), ("APPN-MIB", "appnLsInXidBytes"), ("APPN-MIB", "appnLsInMsgBytes"), ("APPN-MIB", "appnLsInXidFrames"), ("APPN-MIB", "appnLsInMsgFrames"), ("APPN-MIB", "appnLsOutXidBytes"), ("APPN-MIB", "appnLsOutMsgBytes"), ("APPN-MIB", "appnLsOutXidFrames"), ("APPN-MIB", "appnLsOutMsgFrames"), ("APPN-MIB", "appnLsEchoRsps"), ("APPN-MIB", "appnLsCurrentDelay"), ("APPN-MIB", "appnLsMaxDelay"), ("APPN-MIB", "appnLsMinDelay"), ("APPN-MIB", "appnLsMaxDelayTime"), ("APPN-MIB", "appnLsGoodXids"), ("APPN-MIB", "appnLsBadXids"), ("APPN-MIB", "appnLsSpecific"), ("APPN-MIB", "appnLsActiveTime"), ("APPN-MIB", "appnLsCurrentStateTime"), ("APPN-MIB", "appnLsHprSup"), ("APPN-MIB", "appnLsLocalAddr"), ("APPN-MIB", "appnLsRemoteAddr"), ("APPN-MIB", "appnLsRemoteLsName"), ("APPN-MIB", "appnLsStatusTime"), ("APPN-MIB", "appnLsStatusLsName"), ("APPN-MIB", "appnLsStatusCpName"), ("APPN-MIB", "appnLsStatusPartnerId"), ("APPN-MIB", "appnLsStatusTgNum"), ("APPN-MIB", "appnLsStatusGeneralSense"), ("APPN-MIB", "appnLsStatusRetry"), ("APPN-MIB", "appnLsStatusEndSense"), ("APPN-MIB", "appnLsStatusXidLocalSense"), ("APPN-MIB", "appnLsStatusXidRemoteSense"), ("APPN-MIB", "appnLsStatusXidByteInError"), ("APPN-MIB", "appnLsStatusXidBitInError"), ("APPN-MIB", "appnLsStatusDlcType"), ("APPN-MIB", "appnLsStatusLocalAddr"), ("APPN-MIB", "appnLsStatusRemoteAddr"), ("APPN-MIB", "appnLsCounterDisconTime"), ("APPN-MIB", "appnLsMltgMember"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLinkConfGroup2 = appnLinkConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnLinkConfGroup2.setDescription('A collection of objects providing the instrumentation of APPN link information.')
appnLocalTgConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 28)).setObjects(("APPN-MIB", "appnLocalTgDestVirtual"), ("APPN-MIB", "appnLocalTgDlcData"), ("APPN-MIB", "appnLocalTgPortName"), ("APPN-MIB", "appnLocalTgQuiescing"), ("APPN-MIB", "appnLocalTgOperational"), ("APPN-MIB", "appnLocalTgCpCpSession"), ("APPN-MIB", "appnLocalTgEffCap"), ("APPN-MIB", "appnLocalTgConnCost"), ("APPN-MIB", "appnLocalTgByteCost"), ("APPN-MIB", "appnLocalTgSecurity"), ("APPN-MIB", "appnLocalTgDelay"), ("APPN-MIB", "appnLocalTgUsr1"), ("APPN-MIB", "appnLocalTgUsr2"), ("APPN-MIB", "appnLocalTgUsr3"), ("APPN-MIB", "appnLocalTgHprSup"), ("APPN-MIB", "appnLocalTgIntersubnet"), ("APPN-MIB", "appnLocalTgMltgLinkType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLocalTgConfGroup2 = appnLocalTgConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnLocalTgConfGroup2.setDescription('A collection of objects providing the instrumentation of APPN local TG information.')
appnDirTableConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 29)).setObjects(("APPN-MIB", "appnDirNnServerName"), ("APPN-MIB", "appnDirLuOwnerName"), ("APPN-MIB", "appnDirLuLocation"), ("APPN-MIB", "appnDirType"), ("APPN-MIB", "appnDirApparentLuOwnerName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnDirTableConfGroup2 = appnDirTableConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnDirTableConfGroup2.setDescription('A collection of objects providing the instrumentation of the APPN directory database.')
appnNnUniqueConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 6)).setObjects(("APPN-MIB", "appnNodeNnCentralDirectory"), ("APPN-MIB", "appnNodeNnTreeCache"), ("APPN-MIB", "appnNodeNnRouteAddResist"), ("APPN-MIB", "appnNodeNnIsr"), ("APPN-MIB", "appnNodeNnFrsn"), ("APPN-MIB", "appnNodeNnPeriBorderSup"), ("APPN-MIB", "appnNodeNnInterchangeSup"), ("APPN-MIB", "appnNodeNnExteBorderSup"), ("APPN-MIB", "appnNodeNnSafeStoreFreq"), ("APPN-MIB", "appnNodeNnRsn"), ("APPN-MIB", "appnNodeNnCongested"), ("APPN-MIB", "appnNodeNnIsrDepleted"), ("APPN-MIB", "appnNodeNnQuiescing"), ("APPN-MIB", "appnNodeNnGateway"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnNnUniqueConfGroup = appnNnUniqueConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnNnUniqueConfGroup.setDescription('A collection of objects providing instrumentation unique to APPN network nodes.')
appnEnUniqueConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 7)).setObjects(("APPN-MIB", "appnNodeEnModeCosMap"), ("APPN-MIB", "appnNodeEnNnServer"), ("APPN-MIB", "appnNodeEnLuSearch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnEnUniqueConfGroup = appnEnUniqueConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnEnUniqueConfGroup.setDescription('A collection of objects providing instrumentation for APPN end nodes. Some of these objects also appear in the instrumentation for a branch network node.')
appnVrnConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 8)).setObjects(("APPN-MIB", "appnVrnPortName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnVrnConfGroup = appnVrnConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnVrnConfGroup.setDescription('An object providing the instrumentation for virtual routing node support in an APPN node.')
appnNnTopoConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 30)).setObjects(("APPN-MIB", "appnNnTopoMaxNodes"), ("APPN-MIB", "appnNnTopoCurNumNodes"), ("APPN-MIB", "appnNnTopoNodePurges"), ("APPN-MIB", "appnNnTopoTgPurges"), ("APPN-MIB", "appnNnTopoTotalTduWars"), ("APPN-MIB", "appnNnNodeFREntryTimeLeft"), ("APPN-MIB", "appnNnNodeFRType"), ("APPN-MIB", "appnNnNodeFRRsn"), ("APPN-MIB", "appnNnNodeFRRouteAddResist"), ("APPN-MIB", "appnNnNodeFRCongested"), ("APPN-MIB", "appnNnNodeFRIsrDepleted"), ("APPN-MIB", "appnNnNodeFRQuiescing"), ("APPN-MIB", "appnNnNodeFRGateway"), ("APPN-MIB", "appnNnNodeFRCentralDirectory"), ("APPN-MIB", "appnNnNodeFRIsr"), ("APPN-MIB", "appnNnNodeFRGarbageCollect"), ("APPN-MIB", "appnNnNodeFRHprSupport"), ("APPN-MIB", "appnNnNodeFRPeriBorderSup"), ("APPN-MIB", "appnNnNodeFRInterchangeSup"), ("APPN-MIB", "appnNnNodeFRExteBorderSup"), ("APPN-MIB", "appnNnNodeFRBranchAwareness"), ("APPN-MIB", "appnNnTgFREntryTimeLeft"), ("APPN-MIB", "appnNnTgFRDestVirtual"), ("APPN-MIB", "appnNnTgFRDlcData"), ("APPN-MIB", "appnNnTgFRRsn"), ("APPN-MIB", "appnNnTgFROperational"), ("APPN-MIB", "appnNnTgFRQuiescing"), ("APPN-MIB", "appnNnTgFRCpCpSession"), ("APPN-MIB", "appnNnTgFREffCap"), ("APPN-MIB", "appnNnTgFRConnCost"), ("APPN-MIB", "appnNnTgFRByteCost"), ("APPN-MIB", "appnNnTgFRSecurity"), ("APPN-MIB", "appnNnTgFRDelay"), ("APPN-MIB", "appnNnTgFRUsr1"), ("APPN-MIB", "appnNnTgFRUsr2"), ("APPN-MIB", "appnNnTgFRUsr3"), ("APPN-MIB", "appnNnTgFRGarbageCollect"), ("APPN-MIB", "appnNnTgFRSubareaNum"), ("APPN-MIB", "appnNnTgFRHprSup"), ("APPN-MIB", "appnNnTgFRDestHprTrans"), ("APPN-MIB", "appnNnTgFRTypeIndicator"), ("APPN-MIB", "appnNnTgFRIntersubnet"), ("APPN-MIB", "appnNnTgFRMltgLinkType"), ("APPN-MIB", "appnNnTgFRBranchTg"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnNnTopoConfGroup2 = appnNnTopoConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnNnTopoConfGroup2.setDescription('The appnNnTopoConfGroup is mandatory only for network nodes.')
appnLocalEnTopoConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 31)).setObjects(("APPN-MIB", "appnLocalEnTgEntryTimeLeft"), ("APPN-MIB", "appnLocalEnTgDestVirtual"), ("APPN-MIB", "appnLocalEnTgDlcData"), ("APPN-MIB", "appnLocalEnTgOperational"), ("APPN-MIB", "appnLocalEnTgCpCpSession"), ("APPN-MIB", "appnLocalEnTgEffCap"), ("APPN-MIB", "appnLocalEnTgConnCost"), ("APPN-MIB", "appnLocalEnTgByteCost"), ("APPN-MIB", "appnLocalEnTgSecurity"), ("APPN-MIB", "appnLocalEnTgDelay"), ("APPN-MIB", "appnLocalEnTgUsr1"), ("APPN-MIB", "appnLocalEnTgUsr2"), ("APPN-MIB", "appnLocalEnTgUsr3"), ("APPN-MIB", "appnLocalEnTgMltgLinkType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLocalEnTopoConfGroup2 = appnLocalEnTopoConfGroup2.setStatus('current')
if mibBuilder.loadTexts: appnLocalEnTopoConfGroup2.setDescription('A collection of objects providing the instrumentation of the information that a network node possesses about the end nodes directly attached to it.')
appnLocalDirPerfConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 11)).setObjects(("APPN-MIB", "appnDirMaxCaches"), ("APPN-MIB", "appnDirCurCaches"), ("APPN-MIB", "appnDirCurHomeEntries"), ("APPN-MIB", "appnDirRegEntries"), ("APPN-MIB", "appnDirInLocates"), ("APPN-MIB", "appnDirInBcastLocates"), ("APPN-MIB", "appnDirOutLocates"), ("APPN-MIB", "appnDirOutBcastLocates"), ("APPN-MIB", "appnDirNotFoundLocates"), ("APPN-MIB", "appnDirNotFoundBcastLocates"), ("APPN-MIB", "appnDirLocateOutstands"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLocalDirPerfConfGroup = appnLocalDirPerfConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnLocalDirPerfConfGroup.setDescription('The appnLocalDirPerfConfGroup is mandatory only for APPN network nodes and end nodes.')
appnCosConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 12)).setObjects(("APPN-MIB", "appnCosModeCosName"), ("APPN-MIB", "appnCosTransPriority"), ("APPN-MIB", "appnCosNodeRowWgt"), ("APPN-MIB", "appnCosNodeRowResistMin"), ("APPN-MIB", "appnCosNodeRowResistMax"), ("APPN-MIB", "appnCosNodeRowMinCongestAllow"), ("APPN-MIB", "appnCosNodeRowMaxCongestAllow"), ("APPN-MIB", "appnCosTgRowWgt"), ("APPN-MIB", "appnCosTgRowEffCapMin"), ("APPN-MIB", "appnCosTgRowEffCapMax"), ("APPN-MIB", "appnCosTgRowConnCostMin"), ("APPN-MIB", "appnCosTgRowConnCostMax"), ("APPN-MIB", "appnCosTgRowByteCostMin"), ("APPN-MIB", "appnCosTgRowByteCostMax"), ("APPN-MIB", "appnCosTgRowSecurityMin"), ("APPN-MIB", "appnCosTgRowSecurityMax"), ("APPN-MIB", "appnCosTgRowDelayMin"), ("APPN-MIB", "appnCosTgRowDelayMax"), ("APPN-MIB", "appnCosTgRowUsr1Min"), ("APPN-MIB", "appnCosTgRowUsr1Max"), ("APPN-MIB", "appnCosTgRowUsr2Min"), ("APPN-MIB", "appnCosTgRowUsr2Max"), ("APPN-MIB", "appnCosTgRowUsr3Min"), ("APPN-MIB", "appnCosTgRowUsr3Max"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnCosConfGroup = appnCosConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnCosConfGroup.setDescription('The appnCosConfGroup is mandatory only for APPN network nodes and end nodes.')
appnIntSessConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 13)).setObjects(("APPN-MIB", "appnIsInGlobeCtrAdminStatus"), ("APPN-MIB", "appnIsInGlobeCtrOperStatus"), ("APPN-MIB", "appnIsInGlobeCtrStatusTime"), ("APPN-MIB", "appnIsInGlobeRscv"), ("APPN-MIB", "appnIsInGlobeRscvTime"), ("APPN-MIB", "appnIsInGlobeActSess"), ("APPN-MIB", "appnIsInSessState"), ("APPN-MIB", "appnIsInPriLuName"), ("APPN-MIB", "appnIsInSecLuName"), ("APPN-MIB", "appnIsInModeName"), ("APPN-MIB", "appnIsInCosName"), ("APPN-MIB", "appnIsInTransPriority"), ("APPN-MIB", "appnIsInSessType"), ("APPN-MIB", "appnIsInSessUpTime"), ("APPN-MIB", "appnIsInCtrUpTime"), ("APPN-MIB", "appnIsInP2SFmdPius"), ("APPN-MIB", "appnIsInS2PFmdPius"), ("APPN-MIB", "appnIsInP2SNonFmdPius"), ("APPN-MIB", "appnIsInS2PNonFmdPius"), ("APPN-MIB", "appnIsInP2SFmdBytes"), ("APPN-MIB", "appnIsInS2PFmdBytes"), ("APPN-MIB", "appnIsInP2SNonFmdBytes"), ("APPN-MIB", "appnIsInS2PNonFmdBytes"), ("APPN-MIB", "appnIsInPsAdjCpName"), ("APPN-MIB", "appnIsInPsAdjTgNum"), ("APPN-MIB", "appnIsInPsSendMaxBtuSize"), ("APPN-MIB", "appnIsInPsSendPacingType"), ("APPN-MIB", "appnIsInPsSendRpc"), ("APPN-MIB", "appnIsInPsSendNxWndwSize"), ("APPN-MIB", "appnIsInPsRecvPacingType"), ("APPN-MIB", "appnIsInPsRecvRpc"), ("APPN-MIB", "appnIsInPsRecvNxWndwSize"), ("APPN-MIB", "appnIsInSsAdjCpName"), ("APPN-MIB", "appnIsInSsAdjTgNum"), ("APPN-MIB", "appnIsInSsSendMaxBtuSize"), ("APPN-MIB", "appnIsInSsSendPacingType"), ("APPN-MIB", "appnIsInSsSendRpc"), ("APPN-MIB", "appnIsInSsSendNxWndwSize"), ("APPN-MIB", "appnIsInSsRecvPacingType"), ("APPN-MIB", "appnIsInSsRecvRpc"), ("APPN-MIB", "appnIsInSsRecvNxWndwSize"), ("APPN-MIB", "appnIsInRouteInfo"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnIntSessConfGroup = appnIntSessConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnIntSessConfGroup.setDescription('The appnIntSessConfGroup is mandatory only for network nodes.')
appnHprBaseConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 14)).setObjects(("APPN-MIB", "appnNodeHprIntRteSetups"), ("APPN-MIB", "appnNodeHprIntRteRejects"), ("APPN-MIB", "appnLsErrRecoSup"), ("APPN-MIB", "appnLsForAnrLabel"), ("APPN-MIB", "appnLsRevAnrLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnHprBaseConfGroup = appnHprBaseConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnHprBaseConfGroup.setDescription('The appnHprBaseConfGroup is mandatory only for nodes that implement the HPR base (APPN option set 1400).')
appnHprRtpConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 15)).setObjects(("APPN-MIB", "appnNodeMaxSessPerRtpConn"), ("APPN-MIB", "appnNodeHprOrgRteSetups"), ("APPN-MIB", "appnNodeHprOrgRteRejects"), ("APPN-MIB", "appnNodeHprEndRteSetups"), ("APPN-MIB", "appnNodeHprEndRteRejects"), ("APPN-MIB", "appnLsBfNceId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnHprRtpConfGroup = appnHprRtpConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnHprRtpConfGroup.setDescription('The appnHprRtpConfGroup is mandatory only for nodes that implement the HPR RTP tower (APPN option set 1401).')
appnHprCtrlFlowsRtpConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 16)).setObjects(("APPN-MIB", "appnLsCpCpNceId"), ("APPN-MIB", "appnLsRouteNceId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnHprCtrlFlowsRtpConfGroup = appnHprCtrlFlowsRtpConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnHprCtrlFlowsRtpConfGroup.setDescription('The appnHprCtrlFlowsRtpConfGroup is mandatory only for nodes that implement the HPR Control Flows over RTP tower (APPN option set 1402).')
appnHprBfConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 17)).setObjects(("APPN-MIB", "appnIsInGlobeHprBfActSess"), ("APPN-MIB", "appnIsInRtpNceId"), ("APPN-MIB", "appnIsInRtpTcid"), ("APPN-MIB", "appnIsRtpSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnHprBfConfGroup = appnHprBfConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnHprBfConfGroup.setDescription('The appnHprBfConfGroup is mandatory only for nodes that implement the APPN/HPR boundary function.')
appnTrapConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 18)).setObjects(("APPN-MIB", "alertIdNumber"), ("APPN-MIB", "affectedObject"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnTrapConfGroup = appnTrapConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnTrapConfGroup.setDescription('The appnTrapConfGroup is optional for all APPN nodes. Nodes implementing this group shall also implement the appnTrapNotifGroup.')
appnTrapNotifGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 19)).setObjects(("APPN-MIB", "alertTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnTrapNotifGroup = appnTrapNotifGroup.setStatus('current')
if mibBuilder.loadTexts: appnTrapNotifGroup.setDescription('The appnTrapNotifGroup is optional for all APPN nodes. Nodes implementing this group shall also implement the appnTrapConfGroup.')
appnBrNnConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 20)).setObjects(("APPN-MIB", "appnNodeEnNnServer"), ("APPN-MIB", "appnNodeEnLuSearch"), ("APPN-MIB", "appnLocalTgBranchLinkType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnBrNnConfGroup = appnBrNnConfGroup.setStatus('current')
if mibBuilder.loadTexts: appnBrNnConfGroup.setDescription('A collection of objects providing instrumentation for branch network nodes. Some of these objects also appear in the instrumentation for an end node. Note: A branch network node always returns endNode(2) as the value of the appnNodeType object from the appnGeneralConfGroup2 conformance group.')
appnNodeMibVersion = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNodeMibVersion.setStatus('deprecated')
if mibBuilder.loadTexts: appnNodeMibVersion.setDescription("The value of LAST-UPDATED from this module's MODULE-IDENTITY macro. This object gives a Management Station an easy way of determining the level of the MIB supported by an agent. Since this object incorporates the Year 2000-unfriendly 2-digit year specified in SMI for the LAST-UPDATED field, and since it was not found to be particularly useful, it has been deprecated. No replacement object has been defined.")
appnCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 4, 3, 1, 1)).setObjects(("APPN-MIB", "appnGeneralConfGroup"), ("APPN-MIB", "appnPortConfGroup"), ("APPN-MIB", "appnLinkConfGroup"), ("APPN-MIB", "appnLocalTgConfGroup"), ("APPN-MIB", "appnDirTableConfGroup"), ("APPN-MIB", "appnNnUniqueConfGroup"), ("APPN-MIB", "appnEnUniqueConfGroup"), ("APPN-MIB", "appnVrnConfGroup"), ("APPN-MIB", "appnNnTopoConfGroup"), ("APPN-MIB", "appnLocalEnTopoConfGroup"), ("APPN-MIB", "appnLocalDirPerfConfGroup"), ("APPN-MIB", "appnCosConfGroup"), ("APPN-MIB", "appnIntSessConfGroup"), ("APPN-MIB", "appnHprBaseConfGroup"), ("APPN-MIB", "appnHprRtpConfGroup"), ("APPN-MIB", "appnHprCtrlFlowsRtpConfGroup"), ("APPN-MIB", "appnHprBfConfGroup"), ("APPN-MIB", "appnTrapConfGroup"), ("APPN-MIB", "appnTrapNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnCompliance = appnCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: appnCompliance.setDescription('The compliance statement for the SNMPv2 entities that implement the APPN MIB. This is the compliance statement for the RFC 2155-level version of the APPN MIB. It was deprecated as new objects were added to the MIB for MLTG, branch network node, and other extensions to the APPN architecture.')
appnGeneralConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 1)).setObjects(("APPN-MIB", "appnNodeCpName"), ("APPN-MIB", "appnNodeMibVersion"), ("APPN-MIB", "appnNodeId"), ("APPN-MIB", "appnNodeType"), ("APPN-MIB", "appnNodeUpTime"), ("APPN-MIB", "appnNodeParallelTg"), ("APPN-MIB", "appnNodeAdaptiveBindPacing"), ("APPN-MIB", "appnNodeHprSupport"), ("APPN-MIB", "appnNodeCounterDisconTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnGeneralConfGroup = appnGeneralConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnGeneralConfGroup.setDescription('A collection of objects providing the instrumentation of APPN general information and capabilities. This RFC 2155-level group was deprecated when the appnNodeMibVersion object was removed and the appnNodeLsCounterType and appnNodeBrNn objects were added.')
appnLinkConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 3)).setObjects(("APPN-MIB", "appnLsCommand"), ("APPN-MIB", "appnLsOperState"), ("APPN-MIB", "appnLsPortName"), ("APPN-MIB", "appnLsDlcType"), ("APPN-MIB", "appnLsDynamic"), ("APPN-MIB", "appnLsAdjCpName"), ("APPN-MIB", "appnLsAdjNodeType"), ("APPN-MIB", "appnLsTgNum"), ("APPN-MIB", "appnLsLimResource"), ("APPN-MIB", "appnLsActOnDemand"), ("APPN-MIB", "appnLsMigration"), ("APPN-MIB", "appnLsPartnerNodeId"), ("APPN-MIB", "appnLsCpCpSessionSupport"), ("APPN-MIB", "appnLsMaxSendBtuSize"), ("APPN-MIB", "appnLsInXidBytes"), ("APPN-MIB", "appnLsInMsgBytes"), ("APPN-MIB", "appnLsInXidFrames"), ("APPN-MIB", "appnLsInMsgFrames"), ("APPN-MIB", "appnLsOutXidBytes"), ("APPN-MIB", "appnLsOutMsgBytes"), ("APPN-MIB", "appnLsOutXidFrames"), ("APPN-MIB", "appnLsOutMsgFrames"), ("APPN-MIB", "appnLsEchoRsps"), ("APPN-MIB", "appnLsCurrentDelay"), ("APPN-MIB", "appnLsMaxDelay"), ("APPN-MIB", "appnLsMinDelay"), ("APPN-MIB", "appnLsMaxDelayTime"), ("APPN-MIB", "appnLsGoodXids"), ("APPN-MIB", "appnLsBadXids"), ("APPN-MIB", "appnLsSpecific"), ("APPN-MIB", "appnLsActiveTime"), ("APPN-MIB", "appnLsCurrentStateTime"), ("APPN-MIB", "appnLsHprSup"), ("APPN-MIB", "appnLsLocalAddr"), ("APPN-MIB", "appnLsRemoteAddr"), ("APPN-MIB", "appnLsRemoteLsName"), ("APPN-MIB", "appnLsStatusTime"), ("APPN-MIB", "appnLsStatusLsName"), ("APPN-MIB", "appnLsStatusCpName"), ("APPN-MIB", "appnLsStatusPartnerId"), ("APPN-MIB", "appnLsStatusTgNum"), ("APPN-MIB", "appnLsStatusGeneralSense"), ("APPN-MIB", "appnLsStatusRetry"), ("APPN-MIB", "appnLsStatusEndSense"), ("APPN-MIB", "appnLsStatusXidLocalSense"), ("APPN-MIB", "appnLsStatusXidRemoteSense"), ("APPN-MIB", "appnLsStatusXidByteInError"), ("APPN-MIB", "appnLsStatusXidBitInError"), ("APPN-MIB", "appnLsStatusDlcType"), ("APPN-MIB", "appnLsStatusLocalAddr"), ("APPN-MIB", "appnLsStatusRemoteAddr"), ("APPN-MIB", "appnLsCounterDisconTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLinkConfGroup = appnLinkConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnLinkConfGroup.setDescription('A collection of objects providing the instrumentation of APPN link information. This RFC 2155-level group was deprecated when the appnLsMltgMember object was added.')
appnLocalTgConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 4)).setObjects(("APPN-MIB", "appnLocalTgDestVirtual"), ("APPN-MIB", "appnLocalTgDlcData"), ("APPN-MIB", "appnLocalTgPortName"), ("APPN-MIB", "appnLocalTgQuiescing"), ("APPN-MIB", "appnLocalTgOperational"), ("APPN-MIB", "appnLocalTgCpCpSession"), ("APPN-MIB", "appnLocalTgEffCap"), ("APPN-MIB", "appnLocalTgConnCost"), ("APPN-MIB", "appnLocalTgByteCost"), ("APPN-MIB", "appnLocalTgSecurity"), ("APPN-MIB", "appnLocalTgDelay"), ("APPN-MIB", "appnLocalTgUsr1"), ("APPN-MIB", "appnLocalTgUsr2"), ("APPN-MIB", "appnLocalTgUsr3"), ("APPN-MIB", "appnLocalTgHprSup"), ("APPN-MIB", "appnLocalTgIntersubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLocalTgConfGroup = appnLocalTgConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnLocalTgConfGroup.setDescription('A collection of objects providing the instrumentation of APPN local TG information. This RFC 2155-level group was deprecated when the appnLocalTgMltgLinkType object was added.')
appnDirTableConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 5)).setObjects(("APPN-MIB", "appnDirNnServerName"), ("APPN-MIB", "appnDirLuOwnerName"), ("APPN-MIB", "appnDirLuLocation"), ("APPN-MIB", "appnDirType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnDirTableConfGroup = appnDirTableConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnDirTableConfGroup.setDescription('A collection of objects providing the instrumentation of the APPN directory database. This RFC 2155-level group was deprecated when the appnDirApparentLuOwnerName object was added.')
appnNnTopoConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 9)).setObjects(("APPN-MIB", "appnNnTopoMaxNodes"), ("APPN-MIB", "appnNnTopoCurNumNodes"), ("APPN-MIB", "appnNnTopoNodePurges"), ("APPN-MIB", "appnNnTopoTgPurges"), ("APPN-MIB", "appnNnTopoTotalTduWars"), ("APPN-MIB", "appnNnNodeFREntryTimeLeft"), ("APPN-MIB", "appnNnNodeFRType"), ("APPN-MIB", "appnNnNodeFRRsn"), ("APPN-MIB", "appnNnNodeFRRouteAddResist"), ("APPN-MIB", "appnNnNodeFRCongested"), ("APPN-MIB", "appnNnNodeFRIsrDepleted"), ("APPN-MIB", "appnNnNodeFRQuiescing"), ("APPN-MIB", "appnNnNodeFRGateway"), ("APPN-MIB", "appnNnNodeFRCentralDirectory"), ("APPN-MIB", "appnNnNodeFRIsr"), ("APPN-MIB", "appnNnNodeFRGarbageCollect"), ("APPN-MIB", "appnNnNodeFRHprSupport"), ("APPN-MIB", "appnNnNodeFRPeriBorderSup"), ("APPN-MIB", "appnNnNodeFRInterchangeSup"), ("APPN-MIB", "appnNnNodeFRExteBorderSup"), ("APPN-MIB", "appnNnTgFREntryTimeLeft"), ("APPN-MIB", "appnNnTgFRDestVirtual"), ("APPN-MIB", "appnNnTgFRDlcData"), ("APPN-MIB", "appnNnTgFRRsn"), ("APPN-MIB", "appnNnTgFROperational"), ("APPN-MIB", "appnNnTgFRQuiescing"), ("APPN-MIB", "appnNnTgFRCpCpSession"), ("APPN-MIB", "appnNnTgFREffCap"), ("APPN-MIB", "appnNnTgFRConnCost"), ("APPN-MIB", "appnNnTgFRByteCost"), ("APPN-MIB", "appnNnTgFRSecurity"), ("APPN-MIB", "appnNnTgFRDelay"), ("APPN-MIB", "appnNnTgFRUsr1"), ("APPN-MIB", "appnNnTgFRUsr2"), ("APPN-MIB", "appnNnTgFRUsr3"), ("APPN-MIB", "appnNnTgFRGarbageCollect"), ("APPN-MIB", "appnNnTgFRSubareaNum"), ("APPN-MIB", "appnNnTgFRHprSup"), ("APPN-MIB", "appnNnTgFRDestHprTrans"), ("APPN-MIB", "appnNnTgFRTypeIndicator"), ("APPN-MIB", "appnNnTgFRIntersubnet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnNnTopoConfGroup = appnNnTopoConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnNnTopoConfGroup.setDescription('The appnNnTopoConfGroup is mandatory only for network nodes. This RFC 2155-level group was deprecated when the appnNnNodeFRBranchAwareness, appnNnTgFRMltgLinkType, and appnNnFRBranchTg objects were added.')
appnLocalEnTopoConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 10)).setObjects(("APPN-MIB", "appnLocalEnTgEntryTimeLeft"), ("APPN-MIB", "appnLocalEnTgDestVirtual"), ("APPN-MIB", "appnLocalEnTgDlcData"), ("APPN-MIB", "appnLocalEnTgOperational"), ("APPN-MIB", "appnLocalEnTgCpCpSession"), ("APPN-MIB", "appnLocalEnTgEffCap"), ("APPN-MIB", "appnLocalEnTgConnCost"), ("APPN-MIB", "appnLocalEnTgByteCost"), ("APPN-MIB", "appnLocalEnTgSecurity"), ("APPN-MIB", "appnLocalEnTgDelay"), ("APPN-MIB", "appnLocalEnTgUsr1"), ("APPN-MIB", "appnLocalEnTgUsr2"), ("APPN-MIB", "appnLocalEnTgUsr3"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appnLocalEnTopoConfGroup = appnLocalEnTopoConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: appnLocalEnTopoConfGroup.setDescription('The appnLocalEnTopoConfGroup is mandatory only for network nodes. This RFC 2155-level group was deprecated when the appnLocalEnTgMltgLinkType object was added.')
mibBuilder.exportSymbols("APPN-MIB", appnLinkStationInformation=appnLinkStationInformation, appnCosTgRowUsr2Min=appnCosTgRowUsr2Min, appnHprBfConfGroup=appnHprBfConfGroup, appnPortConfGroup=appnPortConfGroup, alertIdNumber=alertIdNumber, appnLsStatusEntry=appnLsStatusEntry, appnCosNodeRowResistMin=appnCosNodeRowResistMin, appnLocalTgEffCap=appnLocalTgEffCap, appnLsOutMsgBytes=appnLsOutMsgBytes, appnLsInMsgBytes=appnLsInMsgBytes, appnLocalEnTgDest=appnLocalEnTgDest, appnLocalEnTgUsr3=appnLocalEnTgUsr3, appnNodeParallelTg=appnNodeParallelTg, appnCosModeName=appnCosModeName, appnCosTgRowUsr3Max=appnCosTgRowUsr3Max, appnLsStatusEndSense=appnLsStatusEndSense, appnNnNodeFRFrsn=appnNnNodeFRFrsn, appnCosNodeRowEntry=appnCosNodeRowEntry, appnLsTable=appnLsTable, appnDirInBcastLocates=appnDirInBcastLocates, appnPortOperState=appnPortOperState, appnLsErrRecoSup=appnLsErrRecoSup, appnCosNodeRowName=appnCosNodeRowName, appnIsInSsAdjTgNum=appnIsInSsAdjTgNum, appnVrnName=appnVrnName, appnNnNodeFRInterchangeSup=appnNnNodeFRInterchangeSup, appnNnTopology=appnNnTopology, appnLocalTgUsr1=appnLocalTgUsr1, appnNodeCpName=appnNodeCpName, appnIsInRtpTcid=appnIsInRtpTcid, appnIsInPsAdjTgNum=appnIsInPsAdjTgNum, appnIsInSessType=appnIsInSessType, appnDirOutLocates=appnDirOutLocates, appnLocalEnTgSecurity=appnLocalEnTgSecurity, appnGeneralConfGroup=appnGeneralConfGroup, appnLsRouteNceId=appnLsRouteNceId, appnVrnEntry=appnVrnEntry, appnIsInPsRecvPacingType=appnIsInPsRecvPacingType, appnEnUniqueCaps=appnEnUniqueCaps, appnIsInCtrUpTime=appnIsInCtrUpTime, appnLocalTgOperational=appnLocalTgOperational, appnIsInSessState=appnIsInSessState, DisplayableDlcAddress=DisplayableDlcAddress, appnCosNodeRowTable=appnCosNodeRowTable, alertTrap=alertTrap, appnNnTopoCurNumNodes=appnNnTopoCurNumNodes, appnLocalTgQuiescing=appnLocalTgQuiescing, appnPortDlcLocalAddr=appnPortDlcLocalAddr, appnLocalTgDlcData=appnLocalTgDlcData, appnEnUniqueConfGroup=appnEnUniqueConfGroup, appnDirEntry=appnDirEntry, appnLsOutXidBytes=appnLsOutXidBytes, appnLsActiveTime=appnLsActiveTime, appnLsCounterDisconTime=appnLsCounterDisconTime, appnNnTgFRSubareaNum=appnNnTgFRSubareaNum, appnLocalTgUsr2=appnLocalTgUsr2, appnNnNodeFREntryTimeLeft=appnNnNodeFREntryTimeLeft, appnLsStatusTgNum=appnLsStatusTgNum, appnLsTgNum=appnLsTgNum, appnLocalEnTgEffCap=appnLocalEnTgEffCap, appnLocalTgHprSup=appnLocalTgHprSup, appnLocalEnTgByteCost=appnLocalEnTgByteCost, appnNnUniqueInfoAndCaps=appnNnUniqueInfoAndCaps, appnNnNodeFRGateway=appnNnNodeFRGateway, appnCosTgRowUsr1Max=appnCosTgRowUsr1Max, appnDirTable=appnDirTable, SnaControlPointName=SnaControlPointName, appnPortDefLsGoodXids=appnPortDefLsGoodXids, appnNnTgFRConnCost=appnNnTgFRConnCost, appnLsPartnerNodeId=appnLsPartnerNodeId, appnIsInSecLuName=appnIsInSecLuName, appnGeneralInfoAndCaps=appnGeneralInfoAndCaps, appnNodeNnQuiescing=appnNodeNnQuiescing, AppnTopologyEntryTimeLeft=AppnTopologyEntryTimeLeft, appnIsInSsSendNxWndwSize=appnIsInSsSendNxWndwSize, appnNnNodeFRCongested=appnNnNodeFRCongested, appnCosNameEntry=appnCosNameEntry, appnLocalEnTgDlcData=appnLocalEnTgDlcData, appnLsMinDelay=appnLsMinDelay, appnLocalEnTgUsr1=appnLocalEnTgUsr1, appnNodeHprOrgRteRejects=appnNodeHprOrgRteRejects, appnCosNodeRowIndex=appnCosNodeRowIndex, appnNnTopoConfGroup=appnNnTopoConfGroup, appnIsInSsRecvNxWndwSize=appnIsInSsRecvNxWndwSize, appnCosTgRowName=appnCosTgRowName, appnLsAdjCpName=appnLsAdjCpName, SnaModeName=SnaModeName, appnCosTgRowEntry=appnCosTgRowEntry, appnDirOutBcastLocates=appnDirOutBcastLocates, appnLsLimResource=appnLsLimResource, appnLsRemoteAddr=appnLsRemoteAddr, appnIsInModeName=appnIsInModeName, appnIsInSsRecvRpc=appnIsInSsRecvRpc, appnLsStatusRetry=appnLsStatusRetry, appnNnTopoMaxNodes=appnNnTopoMaxNodes, appnNnTgFRByteCost=appnNnTgFRByteCost, appnLocalTgBranchLinkType=appnLocalTgBranchLinkType, SnaClassOfServiceName=SnaClassOfServiceName, appnIsRtpTable=appnIsRtpTable, AppnLinkStationCounter=AppnLinkStationCounter, appnDirLuName=appnDirLuName, appnLocalTgCpCpSession=appnLocalTgCpCpSession, appnNodeNnFrsn=appnNodeNnFrsn, appnDirPerf=appnDirPerf, appnLinkConfGroup2=appnLinkConfGroup2, appnLsLocalAddr=appnLsLocalAddr, appnIsInFqCpName=appnIsInFqCpName, appnNnNodeFRCentralDirectory=appnNnNodeFRCentralDirectory, AppnTgEffectiveCapacity=AppnTgEffectiveCapacity, appnNnTgFRGarbageCollect=appnNnTgFRGarbageCollect, appnCosTgRowEffCapMax=appnCosTgRowEffCapMax, appnPortInformation=appnPortInformation, appnIsInPsSendNxWndwSize=appnIsInPsSendNxWndwSize, appnSessIntermediate=appnSessIntermediate, appnLocalEnTgOrigin=appnLocalEnTgOrigin, appnIsInGlobeCtrOperStatus=appnIsInGlobeCtrOperStatus, appnIsInGlobeCtrStatusTime=appnIsInGlobeCtrStatusTime, appnNnTgFRUsr2=appnNnTgFRUsr2, appnNodeEnNnServer=appnNodeEnNnServer, appnLsMaxSendBtuSize=appnLsMaxSendBtuSize, appnIsInCosName=appnIsInCosName, appnPortMaxIframeWindow=appnPortMaxIframeWindow, appnNnTgFRDest=appnNnTgFRDest, appnLocalTgPortName=appnLocalTgPortName, appnLsStatusXidByteInError=appnLsStatusXidByteInError, appnDirNnServerName=appnDirNnServerName, appnNodeId=appnNodeId, affectedObject=affectedObject, appnNnTgFRIntersubnet=appnNnTgFRIntersubnet, appnLocalEnTgEntryTimeLeft=appnLocalEnTgEntryTimeLeft, appnLsMltgMember=appnLsMltgMember, appnLsStatusXidLocalSense=appnLsStatusXidLocalSense, appnLsMigration=appnLsMigration, appnNnTopoTgPurges=appnNnTopoTgPurges, appnNodeNnIsrDepleted=appnNodeNnIsrDepleted, appnNodeType=appnNodeType, appnCosTgRowUsr1Min=appnCosTgRowUsr1Min, appnIsRtpTcid=appnIsRtpTcid, PYSNMP_MODULE_ID=appnMIB, appnNodeAdaptiveBindPacing=appnNodeAdaptiveBindPacing, appnPortDynLsGoodXids=appnPortDynLsGoodXids, appnLinkConfGroup=appnLinkConfGroup, appnIntSessConfGroup=appnIntSessConfGroup, appnLsAdjNodeType=appnLsAdjNodeType, appnNnNodeFRGarbageCollect=appnNnNodeFRGarbageCollect, appnIsInGlobeRscvTime=appnIsInGlobeRscvTime, appnLsCommand=appnLsCommand, appnNnTgFRSecurity=appnNnTgFRSecurity, appnLocalTgConfGroup=appnLocalTgConfGroup, appnLocalDirPerfConfGroup=appnLocalDirPerfConfGroup, appnNodeEnLuSearch=appnNodeEnLuSearch, appnCosNodeRowMaxCongestAllow=appnCosNodeRowMaxCongestAllow, appnNodeMibVersion=appnNodeMibVersion, appnNnTgFREntryTimeLeft=appnNnTgFREntryTimeLeft, appnNodeNnCongested=appnNodeNnCongested, appnLocalTgDelay=appnLocalTgDelay, appnIsInGlobeCtrAdminStatus=appnIsInGlobeCtrAdminStatus, appnNodeUpTime=appnNodeUpTime, appnLocalTgByteCost=appnLocalTgByteCost, appnNnTgTopologyFRTable=appnNnTgTopologyFRTable, appnLocalEnTgDelay=appnLocalEnTgDelay, appnNnTgFRFrsn=appnNnTgFRFrsn, appnNnTgFROwner=appnNnTgFROwner, appnNnTgFRDelay=appnNnTgFRDelay, appnNodeHprSupport=appnNodeHprSupport, appnLsStatusXidBitInError=appnLsStatusXidBitInError, appnCosTgRowByteCostMin=appnCosTgRowByteCostMin, appnLsInXidBytes=appnLsInXidBytes, appnLsStatusTime=appnLsStatusTime, appnNnNodeFRType=appnNnNodeFRType, appnNodeNnRouteAddResist=appnNodeNnRouteAddResist, appnNnUniqueConfGroup=appnNnUniqueConfGroup, appnNodeNnInterchangeSup=appnNodeNnInterchangeSup, appnLsDlcType=appnLsDlcType, appnIsInPsSendMaxBtuSize=appnIsInPsSendMaxBtuSize, appnLsOutMsgFrames=appnLsOutMsgFrames, appnCosTransPriority=appnCosTransPriority, appnNnTgFREffCap=appnNnTgFREffCap, appnDirApparentLuOwnerName=appnDirApparentLuOwnerName, appnLsInMsgFrames=appnLsInMsgFrames, appnIsInPsRecvRpc=appnIsInPsRecvRpc, appnIsRtpSessions=appnIsRtpSessions, appnIsInPsSendPacingType=appnIsInPsSendPacingType, appnPortPortType=appnPortPortType, appnLocalEnTopoConfGroup=appnLocalEnTopoConfGroup, appnNodeNnIsr=appnNodeNnIsr, AppnTgDelay=AppnTgDelay, appnTrapNotifGroup=appnTrapNotifGroup, appnPortMaxRcvBtuSize=appnPortMaxRcvBtuSize, appnNnTgFRDestVirtual=appnNnTgFRDestVirtual, appnLocalEnTgDestVirtual=appnLocalEnTgDestVirtual, appnNnNodeFRRouteAddResist=appnNnNodeFRRouteAddResist, appnNnTgFRDlcData=appnNnTgFRDlcData, appnCosTgRowDelayMin=appnCosTgRowDelayMin, appnLsGoodXids=appnLsGoodXids, appnIsInS2PNonFmdBytes=appnIsInS2PNonFmdBytes, appnLsOutXidFrames=appnLsOutXidFrames, appnCosTgRowEffCapMin=appnCosTgRowEffCapMin, appnDirLuLocation=appnDirLuLocation, appnNodeNnTreeCache=appnNodeNnTreeCache, appnLsCpCpNceId=appnLsCpCpNceId, appnLocalTgConfGroup2=appnLocalTgConfGroup2, appnLsHprSup=appnLsHprSup, appnLocalTopology=appnLocalTopology, appnNnTgFRRsn=appnNnTgFRRsn, appnNodeLsCounterType=appnNodeLsCounterType, appnCosTgRowWgt=appnCosTgRowWgt, appnCosTgRowByteCostMax=appnCosTgRowByteCostMax, appnPortSIMRIM=appnPortSIMRIM, appnCosNodeRowWgt=appnCosNodeRowWgt, appnLocalTgDestVirtual=appnLocalTgDestVirtual, appnIsRtpNceId=appnIsRtpNceId, appnNnTgFRTypeIndicator=appnNnTgFRTypeIndicator, appnLsRemoteLsName=appnLsRemoteLsName, appnPortDefLsBadXids=appnPortDefLsBadXids, appnLocalTgUsr3=appnLocalTgUsr3, appnCosConfGroup=appnCosConfGroup, appnNnTgFRNum=appnNnTgFRNum, appnPortEntry=appnPortEntry, appnIsInPsRecvNxWndwSize=appnIsInPsRecvNxWndwSize, appnDirTableConfGroup2=appnDirTableConfGroup2, appnNn=appnNn, appnNnNodeFRName=appnNnNodeFRName, appnNodeNnGateway=appnNodeNnGateway, appnLsCurrentDelay=appnLsCurrentDelay, appnIsInS2PNonFmdPius=appnIsInS2PNonFmdPius, appnLsOperState=appnLsOperState, appnConformance=appnConformance, appnLsDynamic=appnLsDynamic, appnNnNodeFRRsn=appnNnNodeFRRsn, appnNnNodeFRIsr=appnNnNodeFRIsr, appnLsCpCpSessionSupport=appnLsCpCpSessionSupport, appnNodeCounterDisconTime=appnNodeCounterDisconTime, appnCosTgRowSecurityMax=appnCosTgRowSecurityMax, appnCosNodeRowMinCongestAllow=appnCosNodeRowMinCongestAllow, appnIsInSsSendMaxBtuSize=appnIsInSsSendMaxBtuSize, appnNnNodeFRExteBorderSup=appnNnNodeFRExteBorderSup, appnLocalEnTgOperational=appnLocalEnTgOperational, appnIsInS2PFmdPius=appnIsInS2PFmdPius, appnIsInSsRecvPacingType=appnIsInSsRecvPacingType, appnNodeHprIntRteSetups=appnNodeHprIntRteSetups, appnIsInPriLuName=appnIsInPriLuName, appnLocalTgMltgLinkType=appnLocalTgMltgLinkType, appnLocalEnTgEntry=appnLocalEnTgEntry, appnCosModeCosName=appnCosModeCosName, appnIsInRtpNceId=appnIsInRtpNceId, appnIsRtpEntry=appnIsRtpEntry, appnPortDynamicLinkSupport=appnPortDynamicLinkSupport, appnTrapConfGroup=appnTrapConfGroup, appnLocalTgNum=appnLocalTgNum, appnDirLocateOutstands=appnDirLocateOutstands, appnNnTopoConfGroup2=appnNnTopoConfGroup2, appnNodeNnCentralDirectory=appnNodeNnCentralDirectory, appnLsStatusXidRemoteSense=appnLsStatusXidRemoteSense)
mibBuilder.exportSymbols("APPN-MIB", appnCos=appnCos, appnIsInGlobal=appnIsInGlobal, appnPortCommand=appnPortCommand, appnCosTgRowIndex=appnCosTgRowIndex, appnNnTgFROperational=appnNnTgFROperational, appnCompliance2=appnCompliance2, appnNnNodeFRQuiescing=appnNnNodeFRQuiescing, appnIsInTransPriority=appnIsInTransPriority, appnIsInGlobeRscv=appnIsInGlobeRscv, SnaNodeIdentification=SnaNodeIdentification, appnNnTgFRUsr3=appnNnTgFRUsr3, appnPortCounterDisconTime=appnPortCounterDisconTime, appnLocalTgSecurity=appnLocalTgSecurity, appnNodeMaxSessPerRtpConn=appnNodeMaxSessPerRtpConn, appnPortLsRole=appnPortLsRole, appnNodeNnExteBorderSup=appnNodeNnExteBorderSup, appnNnTgFRDestHprTrans=appnNnTgFRDestHprTrans, appnLsStatusCpName=appnLsStatusCpName, appnLsInXidFrames=appnLsInXidFrames, appnCosName=appnCosName, appnCosTgRowConnCostMax=appnCosTgRowConnCostMax, appnGroups=appnGroups, appnHprRtpConfGroup=appnHprRtpConfGroup, appnCompliance=appnCompliance, appnLocalEnTgCpCpSession=appnLocalEnTgCpCpSession, appnLsBadXids=appnLsBadXids, appnLsStatusLsName=appnLsStatusLsName, appnDirTableConfGroup=appnDirTableConfGroup, appnNnTopo=appnNnTopo, appnDirType=appnDirType, AppnTgSecurity=AppnTgSecurity, appnNode=appnNode, appnCosModeTable=appnCosModeTable, appnLocalTgIntersubnet=appnLocalTgIntersubnet, appnHprBaseConfGroup=appnHprBaseConfGroup, appnIsInSsSendRpc=appnIsInSsSendRpc, appnTraps=appnTraps, appnNnNodeFRIsrDepleted=appnNnNodeFRIsrDepleted, appnVrnPortName=appnVrnPortName, SnaSenseData=SnaSenseData, appnNnTopologyFRTable=appnNnTopologyFRTable, appnDirNotFoundBcastLocates=appnDirNotFoundBcastLocates, appnIsInRouteInfo=appnIsInRouteInfo, appnDirCurCaches=appnDirCurCaches, appnLsRevAnrLabel=appnLsRevAnrLabel, appnVrnInfo=appnVrnInfo, appnLocalTgTable=appnLocalTgTable, appnLsStatusGeneralSense=appnLsStatusGeneralSense, appnLsStatusDlcType=appnLsStatusDlcType, appnDirMaxCaches=appnDirMaxCaches, appnIsInP2SFmdPius=appnIsInP2SFmdPius, appnCosNameTable=appnCosNameTable, appnNodeNnRsn=appnNodeNnRsn, appnCosModeEntry=appnCosModeEntry, appnVrnTgNum=appnVrnTgNum, AppnTgDlcData=AppnTgDlcData, appnNnTgFRCpCpSession=appnNnTgFRCpCpSession, appnDir=appnDir, appnLsMaxDelay=appnLsMaxDelay, appnGeneralConfGroup2=appnGeneralConfGroup2, appnLsCurrentStateTime=appnLsCurrentStateTime, appnLsStatusRemoteAddr=appnLsStatusRemoteAddr, appnLsStatusPartnerId=appnLsStatusPartnerId, appnLocalTgConnCost=appnLocalTgConnCost, appnLocalEnTgTable=appnLocalEnTgTable, appnLocalEnTopoConfGroup2=appnLocalEnTopoConfGroup2, appnNnTgFRHprSup=appnNnTgFRHprSup, appnLocalEnTgUsr2=appnLocalEnTgUsr2, appnNnTgFRUsr1=appnNnTgFRUsr1, appnNnTopoTotalTduWars=appnNnTopoTotalTduWars, appnIsInP2SNonFmdBytes=appnIsInP2SNonFmdBytes, appnLocalEnTgNum=appnLocalEnTgNum, appnDirNotFoundLocates=appnDirNotFoundLocates, appnIsInGlobeHprBfActSess=appnIsInGlobeHprBfActSess, appnLocalEnTgMltgLinkType=appnLocalEnTgMltgLinkType, appnLocalEnTgConnCost=appnLocalEnTgConnCost, appnPortDlcType=appnPortDlcType, appnCosTgRowTable=appnCosTgRowTable, appnLsSpecific=appnLsSpecific, appnNnNodeFRHprSupport=appnNnNodeFRHprSupport, appnIsInSessUpTime=appnIsInSessUpTime, appnNodeHprIntRteRejects=appnNodeHprIntRteRejects, appnIsInP2SFmdBytes=appnIsInP2SFmdBytes, appnIsInPsSendRpc=appnIsInPsSendRpc, appnMIB=appnMIB, appnLocalTgDest=appnLocalTgDest, appnPortDynLsBadXids=appnPortDynLsBadXids, appnCosTgRowUsr3Min=appnCosTgRowUsr3Min, appnCompliances=appnCompliances, AppnNodeCounter=AppnNodeCounter, appnIsInGlobeActSess=appnIsInGlobeActSess, appnNodeHprOrgRteSetups=appnNodeHprOrgRteSetups, appnCosTgRowConnCostMin=appnCosTgRowConnCostMin, appnLsMaxDelayTime=appnLsMaxDelayTime, appnLsStatusTable=appnLsStatusTable, appnNodeHprEndRteSetups=appnNodeHprEndRteSetups, appnCosTgRowSecurityMin=appnCosTgRowSecurityMin, appnLsPortName=appnLsPortName, appnCosTgRowDelayMax=appnCosTgRowDelayMax, appnLsName=appnLsName, appnNnTgFRMltgLinkType=appnNnTgFRMltgLinkType, appnPortName=appnPortName, appnLsStatusIndex=appnLsStatusIndex, appnLocalTgEntry=appnLocalTgEntry, appnNodeNnSafeStoreFreq=appnNodeNnSafeStoreFreq, appnIsInPcid=appnIsInPcid, appnIsInS2PFmdBytes=appnIsInS2PFmdBytes, appnPortTable=appnPortTable, appnVrnTable=appnVrnTable, appnNodeBrNn=appnNodeBrNn, appnDirRegEntries=appnDirRegEntries, appnLsBfNceId=appnLsBfNceId, appnLsEntry=appnLsEntry, appnIsInSsAdjCpName=appnIsInSsAdjCpName, appnBrNnConfGroup=appnBrNnConfGroup, appnIsInTable=appnIsInTable, appnDirLuOwnerName=appnDirLuOwnerName, appnNnTgFRBranchTg=appnNnTgFRBranchTg, appnDirInLocates=appnDirInLocates, appnNnTgFRQuiescing=appnNnTgFRQuiescing, appnCosNodeRowResistMax=appnCosNodeRowResistMax, appnNnTopologyFREntry=appnNnTopologyFREntry, appnCosTgRowUsr2Max=appnCosTgRowUsr2Max, appnPortNegotLs=appnPortNegotLs, appnIsInSsSendPacingType=appnIsInSsSendPacingType, AppnPortCounter=AppnPortCounter, appnDirCurHomeEntries=appnDirCurHomeEntries, appnNnNodeFRBranchAwareness=appnNnNodeFRBranchAwareness, appnIsInEntry=appnIsInEntry, appnNodeEnModeCosMap=appnNodeEnModeCosMap, appnLsActOnDemand=appnLsActOnDemand, appnHprCtrlFlowsRtpConfGroup=appnHprCtrlFlowsRtpConfGroup, appnObjects=appnObjects, appnPortSpecific=appnPortSpecific, appnVrnConfGroup=appnVrnConfGroup, appnIsInPsAdjCpName=appnIsInPsAdjCpName, appnLsStatusLocalAddr=appnLsStatusLocalAddr, appnNodeHprEndRteRejects=appnNodeHprEndRteRejects, appnLsForAnrLabel=appnLsForAnrLabel, appnNnNodeFRPeriBorderSup=appnNnNodeFRPeriBorderSup, appnNodeNnPeriBorderSup=appnNodeNnPeriBorderSup, appnNnTgTopologyFREntry=appnNnTgTopologyFREntry, appnLsEchoRsps=appnLsEchoRsps, appnNnTopoNodePurges=appnNnTopoNodePurges, appnIsInP2SNonFmdPius=appnIsInP2SNonFmdPius)

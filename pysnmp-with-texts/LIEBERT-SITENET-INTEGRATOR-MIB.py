#
# PySNMP MIB module LIEBERT-SITENET-INTEGRATOR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-SITENET-INTEGRATOR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
TruthValue, = mibBuilder.importSymbols("RFC1253-MIB", "TruthValue")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Integer32, enterprises, iso, TimeTicks, IpAddress, NotificationType, MibIdentifier, ModuleIdentity, Counter32, ObjectIdentity, Bits, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "enterprises", "iso", "TimeTicks", "IpAddress", "NotificationType", "MibIdentifier", "ModuleIdentity", "Counter32", "ObjectIdentity", "Bits", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
emerson = MibIdentifier((1, 3, 6, 1, 4, 1, 476))
liebertCorp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1))
liebertUps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1))
liebertEnvironment = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2))
leExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1))
leExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 2))
lePrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 3))
leSiteNet01 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1))
envMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1))
envIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 1))
envIdentManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envIdentManufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: envIdentManufacturer.setDescription('The Environmental Control Unit manufacturer.')
envIdentModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envIdentModel.setStatus('mandatory')
if mibBuilder.loadTexts: envIdentModel.setDescription('The Environmental Control Unit Model designation.')
envIdentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envIdentSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: envIdentSoftwareVersion.setDescription('The Environmental SNMP Agent software version.')
envIdentSpecific = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envIdentSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: envIdentSpecific.setDescription('A reference to MIB definitions specific to the particular Environmental Unit being managed. This object is used to locate the product-specific MIB for this device. If this information is not present, its value should be the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
envDigitalInputs = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2))
envDigInput1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 1))
envDigInput1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput1State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput1State.setDescription('The state of Digital Input Number 1. When the envDigInput1Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput1Polarity is set to activeHigh(1) and the input on Digital Input Number 1 is asserted, this variable returns true(1). When the envDigInput1Polarity is set to activeLow(2) and the input on Digital Input 1 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput1Label.setDescription('A user-defined text string associated with Digital Input Number 1. The text string is stored in non-volatile memory.')
envDigInput1Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput1Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput1Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 1. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 1 is being deasserted and return true(1) if Digital Input Number 1 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 1 is being asserted and return true(1) if Digital Input Number 1 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput1TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput1TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput1TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 1. When envDigInput1TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput1TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 2))
envDigInput2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput2State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput2State.setDescription('The state of Digital Input Number 2. When the envDigInput2Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput2Polarity is set to activeHigh(1) and the input on Digital Input Number 2 is asserted, this variable returns true(1). When the envDigInput2Polarity is set to activeLow(2) and the input on Digital Input 2 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput2Label.setDescription('A user-defined text string associated with Digital Input Number 2. The text string is stored in non-volatile memory.')
envDigInput2Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput2Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput2Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 2. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 2 is being deasserted and return true(1) if Digital Input Number 2 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 2 is being asserted and return true(1) if Digital Input Number 2 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput2TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 2, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput2TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput2TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 2. When envDigInput2TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput2TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 3))
envDigInput3State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput3State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput3State.setDescription('The state of Digital Input Number 3. When the envDigInput3Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput3Polarity is set to activeHigh(1) and the input on Digital Input Number 3 is asserted, this variable returns true(1). When the envDigInput3Polarity is set to activeLow(2) and the input on Digital Input 3 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput3Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput3Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput3Label.setDescription('A user-defined text string associated with Digital Input Number 3. The text string is stored in non-volatile memory.')
envDigInput3Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput3Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput3Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 3. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 3 is being deasserted and return true(1) if Digital Input Number 3 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 3 is being asserted and return true(1) if Digital Input Number 3 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput3TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 3, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput3TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput3TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 3. When envDigInput3TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput3TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput4 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 4))
envDigInput4State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput4State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput4State.setDescription('The state of Digital Input Number 4. When the envDigInput4Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput4Polarity is set to activeHigh(1) and the input on Digital Input Number 4 is asserted, this variable returns true(1). When the envDigInput4Polarity is set to activeLow(2) and the input on Digital Input 4 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput4Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput4Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput4Label.setDescription('A user-defined text string associated with Digital Input Number 4. The text string is stored in non-volatile memory.')
envDigInput4Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput4Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput4Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 4. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 4 is being deasserted and return true(1) if Digital Input Number 4 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 4 is being asserted and return true(1) if Digital Input Number 4 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput4TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 4, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput4TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput4TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 4. When envDigInput4TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput4TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput5 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 5))
envDigInput5State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput5State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput5State.setDescription('The state of Digital Input Number 5. When the envDigInput5Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput5Polarity is set to activeHigh(1) and the input on Digital Input Number 5 is asserted, this variable returns true(1). When the envDigInput5Polarity is set to activeLow(2) and the input on Digital Input 5 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput5Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 5, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput5Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput5Label.setDescription('A user-defined text string associated with Digital Input Number 5. The text string is stored in non-volatile memory.')
envDigInput5Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput5Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput5Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 5. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 5 is being deasserted and return true(1) if Digital Input Number 5 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 5 is being asserted and return true(1) if Digital Input Number 5 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput5TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 5, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput5TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput5TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 5. When envDigInput5TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput5TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput6 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 6))
envDigInput6State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput6State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput6State.setDescription('The state of Digital Input Number 6. When the envDigInput6Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput6Polarity is set to activeHigh(1) and the input on Digital Input Number 6 is asserted, this variable returns true(1). When the envDigInput6Polarity is set to activeLow(2) and the input on Digital Input 6 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput6Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 6, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput6Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput6Label.setDescription('A user-defined text string associated with Digital Input Number 6. The text string is stored in non-volatile memory.')
envDigInput6Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput6Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput6Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 6. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 6 is being deasserted and return true(1) if Digital Input Number 6 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 6 is being asserted and return true(1) if Digital Input Number 6 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput6TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 6, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput6TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput6TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 6. When envDigInput6TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput6TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput7 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 7))
envDigInput7State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput7State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput7State.setDescription('The state of Digital Input Number 7. When the envDigInput7Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput7Polarity is set to activeHigh(1) and the input on Digital Input Number 7 is asserted, this variable returns true(1). When the envDigInput7Polarity is set to activeLow(2) and the input on Digital Input 7 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput7Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 7, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput7Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput7Label.setDescription('A user-defined text string associated with Digital Input Number 7. The text string is stored in non-volatile memory.')
envDigInput7Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput7Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput7Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 7. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 7 is being deasserted and return true(1) if Digital Input Number 7 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 7 is being asserted and return true(1) if Digital Input Number 7 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput7TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 7, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput7TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput7TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 7. When envDigInput7TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput7TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput8 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 8))
envDigInput8State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput8State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput8State.setDescription('The state of Digital Input Number 8. When the envDigInput8Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput8Polarity is set to activeHigh(1) and the input on Digital Input Number 8 is asserted, this variable returns true(1). When the envDigInput8Polarity is set to activeLow(2) and the input on Digital Input 8 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput8Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 8, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput8Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput8Label.setDescription('A user-defined text string associated with Digital Input Number 8. The text string is stored in non-volatile memory.')
envDigInput8Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput8Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput8Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 8. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 8 is being deasserted and return true(1) if Digital Input Number 8 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 8 is being asserted and return true(1) if Digital Input Number 8 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput8TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 8, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput8TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput8TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 8. When envDigInput8TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput8TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput9 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 9))
envDigInput9State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput9State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput9State.setDescription('The state of Digital Input Number 9. When the envDigInput9Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput9Polarity is set to activeHigh(1) and the input on Digital Input Number 9 is asserted, this variable returns true(1). When the envDigInput9Polarity is set to activeLow(2) and the input on Digital Input 9 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput9Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 9, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput9Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput9Label.setDescription('A user-defined text string associated with Digital Input Number 9. The text string is stored in non-volatile memory.')
envDigInput9Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput9Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput9Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 9. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 9 is being deasserted and return true(1) if Digital Input Number 9 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 9 is being asserted and return true(1) if Digital Input Number 9 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput9TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 9, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput9TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput9TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 9. When envDigInput9TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput9TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envDigInput10 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 10))
envDigInput10State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envDigInput10State.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput10State.setDescription('The state of Digital Input Number 10. When the envDigInput10Polarity is set to notDefined(3) this variable returns notInstalled(3). When the envDigInput10Polarity is set to activeHigh(1) and the input on Digital Input Number 10 is asserted, this variable returns true(1). When the envDigInput10Polarity is set to activeLow(2) and the input on Digital Input 10 is deasserted, this variable returns true(1). In all other cases, this variable returns false(2).')
envDigInput10Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 10, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput10Label.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput10Label.setDescription('A user-defined text string associated with Digital Input Number 10. The text string is stored in non-volatile memory.')
envDigInput10Polarity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeHigh", 1), ("activeLow", 2), ("notDefined", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput10Polarity.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput10Polarity.setDescription('The Polarity to be associated with the State variable for Digital Input Number 10. It controls the value returned by the State variable. When Polarity is set to notDefined(3), State will return notInstalled(3). When Polarity is set to activeHigh(1), State will return false(2) if Digital Input Number 10 is being deasserted and return true(1) if Digital Input Number 10 is being asserted. When Polarity is set to activeLow(2), State will return false(2) if Digital Input Number 10 is being asserted and return true(1) if Digital Input Number 10 is being deasserted. Polarity is stored in non-volatile memory.')
envDigInput10TrapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 2, 10, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envDigInput10TrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: envDigInput10TrapEnabled.setDescription('A TRAP may be associated with the State variable for Digital Input Number 10. When envDigInput10TrapEnabled is set to true(1), a TRAP message will be generated when State is true(1). When envDigInput10TrapEnabled is set to false(2), a TRAP message will not be generated regardless of the value of State. TrapEnabled is stored in non-volatile memory.')
envRelays = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3))
envRelay1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 1))
envRelay1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay1State.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay1State.setDescription('The state of Output Relay Number 1. When State is set to on(1) Output Relay Number 1 is activated and the normally open contacts are closed. When State is set to off(2) Output Relay Number 1 is deactivated and the normally closed contacts are closed.')
envRelay1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay1Label.setDescription('A user-defined text string associated with Output Relay Number 1. The text string is stored in non-volatile memory.')
envRelay1Control = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay1Control.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay1Control.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envRelay2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 2))
envRelay2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay2State.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay2State.setDescription('The state of Output Relay Number 2. When State is set to on(1) Output Relay Number 2 is activated and the normally open contacts are closed. When State is set to off(2) Output Relay Number 2 is deactivated and the normally closed contacts are closed.')
envRelay2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay2Label.setDescription('A user-defined text string associated with Output Relay Number 2. The text string is stored in non-volatile memory.')
envRelay2Control = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 3, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envRelay2Control.setStatus('mandatory')
if mibBuilder.loadTexts: envRelay2Control.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envOutputs = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4))
envAudible = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 1))
envAudibleState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envAudibleState.setStatus('mandatory')
if mibBuilder.loadTexts: envAudibleState.setDescription('The state of the Audible Output. When State is set to on(1) the Audible will be sounded. When State is set to off(2) the Audible is muted.')
envAudibleControl = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envAudibleControl.setStatus('mandatory')
if mibBuilder.loadTexts: envAudibleControl.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envLED1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 2))
envLED1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED1State.setStatus('mandatory')
if mibBuilder.loadTexts: envLED1State.setDescription('The state of Output LED Number 1. When State is set to on(1) LED Number 1 will be lighted. When State is set to off(2) LED Number 1 will not be lighted.')
envLED1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envLED1Label.setDescription('A user-defined text string associated with Output LED Number 1. The text string is stored in non-volatile memory.')
envLED1Control = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED1Control.setStatus('mandatory')
if mibBuilder.loadTexts: envLED1Control.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envLED2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 3))
envLED2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED2State.setStatus('mandatory')
if mibBuilder.loadTexts: envLED2State.setDescription('The state of Output LED Number 2. When State is set to on(1) LED Number 2 will be lighted. When State is set to off(2) LED Number 2 will not be lighted.')
envLED2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envLED2Label.setDescription('A user-defined text string associated with Output LED Number 2. The text string is stored in non-volatile memory.')
envLED2Control = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED2Control.setStatus('mandatory')
if mibBuilder.loadTexts: envLED2Control.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envLED3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 4))
envLED3State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED3State.setStatus('mandatory')
if mibBuilder.loadTexts: envLED3State.setDescription('The state of Output LED Number 3. When State is set to on(1) LED Number 3 will be lighted. When State is set to off(2) LED Number 3 will not be lighted.')
envLED3Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED3Label.setStatus('mandatory')
if mibBuilder.loadTexts: envLED3Label.setDescription('A user-defined text string associated with Output LED Number 3. The text string is stored in non-volatile memory.')
envLED3Control = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 4, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envLED3Control.setStatus('mandatory')
if mibBuilder.loadTexts: envLED3Control.setDescription('If Control value is 0 then this output may be directly controlled by the SNMP Manager. When Control contains any of the following values, or a value resulting from the sum of any of these values the Agent will activate the output when the any of the associated conditions is sensed and de-activate the output when all conditions clear. DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288 The Control variable is stored in non-volatile memory.')
envReceptacles = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5))
envReceptacle1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 1))
envReceptacle1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle1State.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle1State.setDescription('The state of the Receptacle Number 1. When State is set to on(1) power will be live on Receptacle Number 1. When State is set to off(2) no power is available from Receptacle Number 1.')
envReceptacle1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle1Label.setDescription('A user-defined text string associated with Receptacle Number 1. The text string is stored in non-volatile memory.')
envReceptacle2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 2))
envReceptacle2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle2State.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle2State.setDescription('The state of the Receptacle Number 2. When State is set to on(1) power will be live on Receptacle Number 2. When State is set to off(2) no power is available from Receptacle Number 2.')
envReceptacle2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle2Label.setDescription('A user-defined text string associated with Receptacle Number 2. The text string is stored in non-volatile memory.')
envReceptacle3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 3))
envReceptacle3State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle3State.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle3State.setDescription('The state of the Receptacle Number 3. When State is set to on(1) power will be live on Receptacle Number 3. When State is set to off(2) no power is available from Receptacle Number 3.')
envReceptacle3Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle3Label.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle3Label.setDescription('A user-defined text string associated with Receptacle Number 3. The text string is stored in non-volatile memory.')
envReceptacle4 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 4))
envReceptacle4State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle4State.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle4State.setDescription('The state of the Receptacle Number 4. When State is set to on(1) power will be live on Receptacle Number 4. When State is set to off(2) no power is available from Receptacle Number 4.')
envReceptacle4Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 5, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envReceptacle4Label.setStatus('mandatory')
if mibBuilder.loadTexts: envReceptacle4Label.setDescription('A user-defined text string associated with Receptacle Number 4. The text string is stored in non-volatile memory.')
envAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 6))
envSummaryAlarm = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envSummaryAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: envSummaryAlarm.setDescription('The envSummaryAlarm varible will be 0 when no Digital Inputs are true and no other alarm conditions exist. When alarms are active or Digital Inputs are true the value of envSummaryAlarm indicates which alarms and inputs are active as a sum of the values listed below: DigitalInput1State true(1) 1 DigitalInput2State true(1) 2 DigitalInput3State true(1) 4 DigitalInput4State true(1) 8 DigitalInput5State true(1) 16 DigitalInput6State true(1) 32 DigitalInput7State true(1) 64 DigitalInput8State true(1) 128 DigitalInput9State true(1) 256 DigitalInput10State true(1) 512 Temperature1 above HighLimit 1024 Temperature1 below LowLimit 2048 Temperature2 above HighLimit 4096 Temperature2 below LowLimit 8192 Temperature3 above HighLimit 16384 Temperature3 below LowLimit 32768 Humidity1 above HighLimit 65536 Humidity1 below LowLimit 131072 Humidity2 above HighLimit 262144 Humidity2 below LowLimit 524288')
envTemperatureSensors = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7))
envTemperature1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1))
envTemperature1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature1State.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1State.setDescription('The state of use of Temperature Input Number 1. When a sensor is connected to Temperature Input 1 set State to installed(2) to indicate that the value of envTemperature1F and envTemperature1C are valid. When no sensor is connected to Temperature Input 1 set State to notInstalled(1) to indicate that the value of envTemperature1F and envTemperature1C may not be valid. This variable is stored in non-volatile memory.')
envTemperature1F = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature1F.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1F.setDescription('The temperature for sensor 1 in degrees Fahrenheit.')
envTemperature1C = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature1C.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1C.setDescription('The temperature for sensor 1 in degrees Centigrade.')
envTemperature1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1Label.setDescription('A user-defined text string associated with Temperature Input Number 1. The text string is stored in non-volatile memory.')
envTemperature1OffsetF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature1OffsetF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1OffsetF.setDescription('A temperature correction Offset associated with the envTemperature1F variable. The value of OffsetF is added to the value from Temperature Sensor Number 1 to obtain the value of the envTemperature1F variable. When this variable is changed the envTemperature1OffsetC variable may also be effected. The OffsetF variable is stored in non-volatile memory.')
envTemperature1OffsetC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature1OffsetC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature1OffsetC.setDescription('A temperature correction Offset associated with the envTemperature1C variable. The value of OffsetC is added to the value from Temperature Sensor Number 1 to obtain the value of the envTemperature1C variable. When this variable is changed the envTemperature1OffsetF variable may also be effected. The OffsetC variable is stored in in non-volatile memory.')
envTemp1HighLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp1HighLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp1HighLimitF.setDescription('When envTemperature1F reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 1. The HighLimitF variable is stored in non-volatile memory.')
envTemp1HighLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp1HighLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp1HighLimitC.setDescription('When envTemperature1C reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 1. The HighLimitC variable is stored in non-volatile memory.')
envTemp1LowLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp1LowLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp1LowLimitF.setDescription('When envTemperature1F reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 1. The LowLimitF variable is stored in non-volatile memory.')
envTemp1LowLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp1LowLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp1LowLimitC.setDescription('When envTemperature1C reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 1. The LowLimitC variable is stored in non-volatile memory.')
envTemperature2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2))
envTemperature2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature2State.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2State.setDescription('The state of use of Temperature Input Number 2. When a sensor is connected to Temperature Input 2 set State to installed(2) to indicate that the value of envTemperature2F and envTemperature2C are valid. When no sensor is connected to Temperature Input 2 set State to notInstalled(1) to indicate that the value of envTemperature2F and envTemperature2C may not be valid. This variable is stored in non-volatile memory.')
envTemperature2F = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature2F.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2F.setDescription('The temperature for sensor 2 in degrees Fahrenheit.')
envTemperature2C = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature2C.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2C.setDescription('The temperature for sensor 2 in degrees Centigrade.')
envTemperature2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2Label.setDescription('A user-defined text string associated with Temperature Input Number 2. The text string is stored in non-volatile memory.')
envTemperature2OffsetF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature2OffsetF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2OffsetF.setDescription('A temperature correction Offset associated with the envTemperature2F variable. The value of OffsetF is added to the value from Temperature Sensor Number 2 to obtain the value of the envTemperature2F variable. When this variable is changed the envTemperature2OffsetC variable may also be effected. The OffsetF variable is stored in non-volatile memory.')
envTemperature2OffsetC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature2OffsetC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature2OffsetC.setDescription('A temperature correction Offset associated with the envTemperature2C variable. The value of OffsetC is added to the value from Temperature Sensor Number 2 to obtain the value of the envTemperature2C variable. When this variable is changed the envTemperature2OffsetF variable may also be effected. The OffsetC variable is stored in in non-volatile memory.')
envTemp2HighLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp2HighLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp2HighLimitF.setDescription('When envTemperature2F reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 2. The HighLimitF variable is stored in non-volatile memory.')
envTemp2HighLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp2HighLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp2HighLimitC.setDescription('When envTemperature2C reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 2. The HighLimitC variable is stored in non-volatile memory.')
envTemp2LowLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp2LowLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp2LowLimitF.setDescription('When envTemperature2F reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 2. The LowLimitF variable is stored in non-volatile memory.')
envTemp2LowLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp2LowLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp2LowLimitC.setDescription('When envTemperature2C reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 2. The LowLimitC variable is stored in non-volatile memory.')
envTemperature3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3))
envTemperature3State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notInstalled", 1), ("airSensorInstalled", 2), ("waterSensorInstalled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature3State.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3State.setDescription('The state of use of Temperature Input Number 3. When a water temperature sensor is connected to Temperature Input 3 set State to waterSensorInstalled(3), when and air temperature sensor is connected set State to airSensorInstalled(2). When no sensor is connected to Temperature Input 3 set State to notInstalled(1) to indicate that the value of envTemperature3F and envTemperature3C may not be valid. This variable is stored in non-volatile memory.')
envTemperature3F = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature3F.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3F.setDescription('The temperature for sensor 3 in degrees Fahrenheit.')
envTemperature3C = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTemperature3C.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3C.setDescription('The temperature for sensor 3 in degrees Centigrade.')
envTemperature3Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature3Label.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3Label.setDescription('A user-defined text string associated with Temperature Input Number 3. The text string is stored in non-volatile memory.')
envTemperature3OffsetF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature3OffsetF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3OffsetF.setDescription('A temperature correction Offset associated with the envTemperature3F variable. The value of OffsetF is added to the value from Temperature Sensor Number 3 to obtain the value of the envTemperature3F variable. When this variable is changed the envTemperature3OffsetF variable may also be effected. The OffsetF variable is stored in in non-volatile memory.')
envTemperature3OffsetC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemperature3OffsetC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemperature3OffsetC.setDescription('A temperature correction Offset associated with the envTemperature3C variable. The value of OffsetC is added to the value from Temperature Sensor Number 3 to obtain the value of the envTemperature3C variable. When this variable is changed the envTemperature3OffsetF variable may also be effected. The OffsetC variable is stored in in non-volatile memory.')
envTemp3HighLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp3HighLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp3HighLimitF.setDescription('When envTemperature3F reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 3. The HighLimitF variable is stored in non-volatile memory.')
envTemp3HighLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp3HighLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp3HighLimitC.setDescription('When envTemperature3C reaches or exceeds this value a trap will be generated signifying a high temperature condition at temperature sensor 3. The HighLimitC variable is stored in non-volatile memory.')
envTemp3LowLimitF = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp3LowLimitF.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp3LowLimitF.setDescription('When envTemperature3F reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 3. The LowLimitF variable is stored in non-volatile memory.')
envTemp3LowLimitC = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp3LowLimitC.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp3LowLimitC.setDescription('When envTemperature3C reaches or goes below this value a trap will be generated signifying a low temperature condition at temperature sensor 3. The LowLimitC variable is stored in non-volatile memory.')
envTemp3Calibrate = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 7, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envTemp3Calibrate.setStatus('mandatory')
if mibBuilder.loadTexts: envTemp3Calibrate.setDescription('A temperature Offset correction routine associated with Temperature Sensor Number 3. When Calibrate is set to on(1) and State is set to waterSensorInstalled(3) the agent runs a self calibration routine which automatically adjusts the OffsetF and OffsetC variables.')
envHumiditySensors = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8))
envHumidity1 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1))
envHumidity1State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity1State.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1State.setDescription('The state of use of Humidity Input Number 1. When a sensor is connected to Humidity Input 1 set State to installed(2) to indicate that the value of envHumidity1RH is valid. When no sensor is connected to Humidity Input 1 set State to notInstalled(1) to indicate that the value of envHumidity1RH may not be valid. This variable is stored in non-volatile memory.')
envHumidity1RH = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envHumidity1RH.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1RH.setDescription('The humidity for sensor 1 in percent RH.')
envHumidity1Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity1Label.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1Label.setDescription('A user-defined text string associated with Humidity Input Number 1. The text string is stored in non-volatile memory.')
envHumidity1Offset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity1Offset.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1Offset.setDescription('A humidity correction Offset associated with the envHumidity1RH variable. The value of Offset is added to the value from Humidity Sensor Number 1 to obtain the value of the envHumidity1RH variable. The Offset variable is stored in non-volatile memory.')
envHumidity1HighLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity1HighLimit.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1HighLimit.setDescription('When envHumidity1RH reaches or exceeds this value a trap will be generated signifying a high humidity condition at humidity sensor 1. The HighLimit variable is stored in non-volatile memory.')
envHumidity1LowLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity1LowLimit.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity1LowLimit.setDescription('When envHumidity1RH reaches or goes below this value a trap will be generated signifying a low humidity condition at humidity sensor 1. The LowLimit variable is stored in non-volatile memory.')
envHumidity2 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2))
envHumidity2State = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity2State.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2State.setDescription('The state of use of Humidity Input Number 2. When a sensor is connected to Humidity Input 2 set State to installed(2) to indicate that the value of envHumidity2RH is valid. When no sensor is connected to Humidity Input 2 set State to notInstalled(1) to indicate that the value of envHumidity2RH may not be valid. This variable is stored in non-volatile memory.')
envHumidity2RH = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envHumidity2RH.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2RH.setDescription('The humidity for sensor 2 in percent RH.')
envHumidity2Label = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity2Label.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2Label.setDescription('A user-defined text string associated with Humidity Input Number 2. The text string is stored in non-volatile memory.')
envHumidity2Offset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity2Offset.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2Offset.setDescription('A humidity correction Offset associated with the envHumidity2RH variable. The value of Offset is added to the value from Humidity Sensor Number 2 to obtain the value of the envHumidity2RH variable. The Offset variable is stored in non-volatile memory.')
envHumidity2HighLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity2HighLimit.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2HighLimit.setDescription('When envHumidity2RH reaches or exceeds this value a trap will be generated signifying a high humidity condition at humidity sensor 2. The HighLimit variable is stored in non-volatile memory.')
envHumidity2LowLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 8, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envHumidity2LowLimit.setStatus('mandatory')
if mibBuilder.loadTexts: envHumidity2LowLimit.setDescription('When envHumidity2RH reaches or goes below this value a trap will be generated signifying a low humidity condition at humidity sensor 2. The LowLimit variable is stored in non-volatile memory.')
envTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11))
envSummaryAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,1))
if mibBuilder.loadTexts: envSummaryAlarmTrap.setDescription('An envSummaryAlarmTrap is generated each time a digital input State variable changes to true(1) or whenever a temperature or humidity goes above the HighLimit or below the LowLimit.')
envDigInput1TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,2))
if mibBuilder.loadTexts: envDigInput1TrueTrap.setDescription('An envDigInput1TrueTrap signifies that envDigitalInput1State has changed from false(2) to true(1). This trap is not generated if envDigInput1TrapEnabled is not true(1).')
envDigInput1FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,3))
if mibBuilder.loadTexts: envDigInput1FalseTrap.setDescription('An envDigInput1FalseTrap signifies that envDigitalInput1State has changed from true(1) to false(2). This trap is not generated if envDigInput1TrapEnabled is not true(1).')
envDigInput2TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,4))
if mibBuilder.loadTexts: envDigInput2TrueTrap.setDescription('An envDigInput2TrueTrap signifies that envDigitalInput2State has changed from false(2) to true(1). This trap is not generated if envDigInput2TrapEnabled is not true(1).')
envDigInput2FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,5))
if mibBuilder.loadTexts: envDigInput2FalseTrap.setDescription('An envDigInput2FalseTrap signifies that envDigitalInput2State has changed from true(1) to false(2). This trap is not generated if envDigInput2TrapEnabled is not true(1).')
envDigInput3TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,6))
if mibBuilder.loadTexts: envDigInput3TrueTrap.setDescription('An envDigInput3TrueTrap signifies that envDigitalInput3State has changed from false(2) to true(1). This trap is not generated if envDigInput3TrapEnabled is not true(1).')
envDigInput3FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,7))
if mibBuilder.loadTexts: envDigInput3FalseTrap.setDescription('An envDigInput3FalseTrap signifies that envDigitalInput3State has changed from true(1) to false(2). This trap is not generated if envDigInput3TrapEnabled is not true(1).')
envDigInput4TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,8))
if mibBuilder.loadTexts: envDigInput4TrueTrap.setDescription('An envDigInput4TrueTrap signifies that envDigitalInput4State has changed from false(2) to true(1). This trap is not generated if envDigInput4TrapEnabled is not true(1).')
envDigInput4FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,9))
if mibBuilder.loadTexts: envDigInput4FalseTrap.setDescription('An envDigInput4FalseTrap signifies that envDigitalInput4State has changed from true(1) to false(2). This trap is not generated if envDigInput4TrapEnabled is not true(1).')
envDigInput5TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,10))
if mibBuilder.loadTexts: envDigInput5TrueTrap.setDescription('An envDigInput5TrueTrap signifies that envDigitalInput5State has changed from false(2) to true(1). This trap is not generated if envDigInput5TrapEnabled is not true(1).')
envDigInput5FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,11))
if mibBuilder.loadTexts: envDigInput5FalseTrap.setDescription('An envDigInput5FalseTrap signifies that envDigitalInput5State has changed from true(1) to false(2). This trap is not generated if envDigInput5TrapEnabled is not true(1).')
envDigInput6TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,12))
if mibBuilder.loadTexts: envDigInput6TrueTrap.setDescription('An envDigInput6TrueTrap signifies that envDigitalInput6State has changed from false(2) to true(1). This trap is not generated if envDigInput6TrapEnabled is not true(1).')
envDigInput6FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,13))
if mibBuilder.loadTexts: envDigInput6FalseTrap.setDescription('An envDigInput6FalseTrap signifies that envDigitalInput6State has changed from true(1) to false(2). This trap is not generated if envDigInput6TrapEnabled is not true(1).')
envDigInput7TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,14))
if mibBuilder.loadTexts: envDigInput7TrueTrap.setDescription('An envDigInput7TrueTrap signifies that envDigitalInput7State has changed from false(2) to true(1). This trap is not generated if envDigInput7TrapEnabled is not true(1).')
envDigInput7FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,15))
if mibBuilder.loadTexts: envDigInput7FalseTrap.setDescription('An envDigInput7FalseTrap signifies that envDigitalInput7State has changed from true(1) to false(2). This trap is not generated if envDigInput7TrapEnabled is not true(1).')
envDigInput8TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,16))
if mibBuilder.loadTexts: envDigInput8TrueTrap.setDescription('An envDigInput8TrueTrap signifies that envDigitalInput8State has changed from false(2) to true(1). This trap is not generated if envDigInput8TrapEnabled is not true(1).')
envDigInput8FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,17))
if mibBuilder.loadTexts: envDigInput8FalseTrap.setDescription('An envDigInput8FalseTrap signifies that envDigitalInput8State has changed from true(1) to false(2). This trap is not generated if envDigInput8TrapEnabled is not true(1).')
envDigInput9TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,18))
if mibBuilder.loadTexts: envDigInput9TrueTrap.setDescription('An envDigInput9TrueTrap signifies that envDigitalInput9State has changed from false(2) to true(1). This trap is not generated if envDigInput9TrapEnabled is not true(1).')
envDigInput9FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,19))
if mibBuilder.loadTexts: envDigInput9FalseTrap.setDescription('An envDigInput9FalseTrap signifies that envDigitalInput9State has changed from true(1) to false(2). This trap is not generated if envDigInput9TrapEnabled is not true(1).')
envDigInput10TrueTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,20))
if mibBuilder.loadTexts: envDigInput10TrueTrap.setDescription('An envDigInput10TrueTrap signifies that envDigitalInput10State has changed from false(2) to true(1). This trap is not generated if envDigInput10TrapEnabled is not true(1).')
envDigInput10FalseTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,21))
if mibBuilder.loadTexts: envDigInput10FalseTrap.setDescription('An envDigInput10FalseTrap signifies that envDigitalInput10State has changed from true(1) to false(2). This trap is not generated if envDigInput10TrapEnabled is not true(1).')
envTemperature1HighTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,22))
if mibBuilder.loadTexts: envTemperature1HighTrap.setDescription('An envTemperature1HighTrap signifies that the sensor reading has gone above the HighLimit value.')
envTemperature1LowTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,23))
if mibBuilder.loadTexts: envTemperature1LowTrap.setDescription('An envTemperature1LowTrap signifies that the sensor reading has gone below the LowLimit value.')
envTemperature1NormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,24))
if mibBuilder.loadTexts: envTemperature1NormalTrap.setDescription('An envTemperature1NormalTrap signifies that the sensor reading has return to the range bounded by HighLimit and LowLimit.')
envTemperature2HighTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,25))
if mibBuilder.loadTexts: envTemperature2HighTrap.setDescription('An envTemperature2HighTrap signifies that the sensor reading has gone above the HighLimit value.')
envTemperature2LowTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,26))
if mibBuilder.loadTexts: envTemperature2LowTrap.setDescription('An envTemperature2LowTrap signifies that the sensor reading has gone below the LowLimit value.')
envTemperature2NormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,27))
if mibBuilder.loadTexts: envTemperature2NormalTrap.setDescription('An envTemperature2NormalTrap signifies that the sensor reading has return to the range bounded by HighLimit and LowLimit.')
envTemperature3HighTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,28))
if mibBuilder.loadTexts: envTemperature3HighTrap.setDescription('An envTemperature3HighTrap signifies that the sensor reading has gone above the HighLimit value.')
envTemperature3LowTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,29))
if mibBuilder.loadTexts: envTemperature3LowTrap.setDescription('An envTemperature3LowTrap signifies that the sensor reading has gone below the LowLimit value.')
envTemperature3NormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,30))
if mibBuilder.loadTexts: envTemperature3NormalTrap.setDescription('An envTemperature3NormalTrap signifies that the sensor reading has return to the range bounded by HighLimit and LowLimit.')
envHumidity1HighTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,31))
if mibBuilder.loadTexts: envHumidity1HighTrap.setDescription('An envHumidity1HighTrap signifies that the sensor reading has gone above the HighLimit value.')
envHumidity1LowTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,32))
if mibBuilder.loadTexts: envHumidity1LowTrap.setDescription('An envHumidity1LowTrap signifies that the sensor reading has gone below the LowLimit value.')
envHumidity1NormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,33))
if mibBuilder.loadTexts: envHumidity1NormalTrap.setDescription('An envHumidity1NormalTrap signifies that the sensor reading has return to the range bounded by HighLimit and LowLimit.')
envHumidity2HighTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,34))
if mibBuilder.loadTexts: envHumidity2HighTrap.setDescription('An envHumidity2HighTrap signifies that the sensor reading has gone above the HighLimit value.')
envHumidity2LowTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,35))
if mibBuilder.loadTexts: envHumidity2LowTrap.setDescription('An envHumidity2LowTrap signifies that the sensor reading has gone below the LowLimit value.')
envHumidity2NormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 2, 1, 1, 1, 11) + (0,36))
if mibBuilder.loadTexts: envHumidity2NormalTrap.setDescription('An envHumidity2NormalTrap signifies that the sensor reading has return to the range bounded by HighLimit and LowLimit.')
mibBuilder.exportSymbols("LIEBERT-SITENET-INTEGRATOR-MIB", envDigInput6State=envDigInput6State, envRelay2State=envRelay2State, envIdentManufacturer=envIdentManufacturer, envSummaryAlarm=envSummaryAlarm, envTraps=envTraps, envDigInput4TrueTrap=envDigInput4TrueTrap, envTemp2LowLimitF=envTemp2LowLimitF, envHumidity2Offset=envHumidity2Offset, envDigInput4TrapEnabled=envDigInput4TrapEnabled, leExtensions=leExtensions, envDigInput5TrapEnabled=envDigInput5TrapEnabled, envRelay1Control=envRelay1Control, envDigInput7Label=envDigInput7Label, envReceptacle1State=envReceptacle1State, leExperimental=leExperimental, envDigInput4State=envDigInput4State, envReceptacle3State=envReceptacle3State, envTemperature2NormalTrap=envTemperature2NormalTrap, envDigInput9Label=envDigInput9Label, envTemp1LowLimitF=envTemp1LowLimitF, envDigInput6FalseTrap=envDigInput6FalseTrap, envDigInput4Label=envDigInput4Label, envDigInput6Polarity=envDigInput6Polarity, envHumidity2Label=envHumidity2Label, envAudible=envAudible, envDigInput3State=envDigInput3State, envDigInput8=envDigInput8, envDigInput7TrueTrap=envDigInput7TrueTrap, envHumidity2RH=envHumidity2RH, envDigInput2Polarity=envDigInput2Polarity, envHumidity2State=envHumidity2State, envDigInput5State=envDigInput5State, envDigInput10Label=envDigInput10Label, envTemp2HighLimitC=envTemp2HighLimitC, envDigInput7FalseTrap=envDigInput7FalseTrap, envTemperature2=envTemperature2, envDigInput7Polarity=envDigInput7Polarity, envDigInput7TrapEnabled=envDigInput7TrapEnabled, leSiteNet01=leSiteNet01, envMIB=envMIB, envLED3Control=envLED3Control, envReceptacle2=envReceptacle2, envHumidity1State=envHumidity1State, envRelay2Label=envRelay2Label, envDigInput9Polarity=envDigInput9Polarity, envHumidity1HighTrap=envHumidity1HighTrap, envDigInput4FalseTrap=envDigInput4FalseTrap, envDigInput4=envDigInput4, envRelays=envRelays, envDigInput8TrapEnabled=envDigInput8TrapEnabled, envLED1State=envLED1State, envReceptacle1Label=envReceptacle1Label, envTemperature1F=envTemperature1F, envRelay2=envRelay2, envDigInput2TrapEnabled=envDigInput2TrapEnabled, envLED3=envLED3, envTemp1HighLimitF=envTemp1HighLimitF, envDigInput1Label=envDigInput1Label, envReceptacles=envReceptacles, envHumidity1Label=envHumidity1Label, envHumidity1=envHumidity1, envDigInput6=envDigInput6, envHumidity2HighLimit=envHumidity2HighLimit, envDigInput6TrapEnabled=envDigInput6TrapEnabled, envDigInput7State=envDigInput7State, envReceptacle2Label=envReceptacle2Label, envAlarms=envAlarms, envDigInput8State=envDigInput8State, envRelay2Control=envRelay2Control, envTemperature1C=envTemperature1C, envDigInput3Label=envDigInput3Label, envTemperature1NormalTrap=envTemperature1NormalTrap, envDigInput3Polarity=envDigInput3Polarity, envReceptacle3Label=envReceptacle3Label, envRelay1=envRelay1, envDigInput10=envDigInput10, envTemperature1OffsetC=envTemperature1OffsetC, envTemperature3OffsetF=envTemperature3OffsetF, envHumidity2LowLimit=envHumidity2LowLimit, envDigInput5Label=envDigInput5Label, envDigInput4Polarity=envDigInput4Polarity, envDigInput5TrueTrap=envDigInput5TrueTrap, envTemperature3=envTemperature3, emerson=emerson, envTemp3HighLimitC=envTemp3HighLimitC, liebertUps=liebertUps, envDigInput2Label=envDigInput2Label, liebertCorp=liebertCorp, envDigInput1TrueTrap=envDigInput1TrueTrap, envDigInput9TrueTrap=envDigInput9TrueTrap, envDigInput5Polarity=envDigInput5Polarity, envLED2State=envLED2State, envTemperature1=envTemperature1, envLED1=envLED1, envDigInput10FalseTrap=envDigInput10FalseTrap, envOutputs=envOutputs, envDigInput1=envDigInput1, envLED2=envLED2, envAudibleControl=envAudibleControl, envRelay1State=envRelay1State, envDigInput5FalseTrap=envDigInput5FalseTrap, envIdentModel=envIdentModel, envIdent=envIdent, envDigInput3TrueTrap=envDigInput3TrueTrap, envDigInput10TrapEnabled=envDigInput10TrapEnabled, envDigInput10TrueTrap=envDigInput10TrueTrap, envTemp2HighLimitF=envTemp2HighLimitF, envDigInput1FalseTrap=envDigInput1FalseTrap, envTemp3LowLimitC=envTemp3LowLimitC, envReceptacle4State=envReceptacle4State, envTemperature2LowTrap=envTemperature2LowTrap, envReceptacle4Label=envReceptacle4Label, envHumidity1RH=envHumidity1RH, envTemp3LowLimitF=envTemp3LowLimitF, envDigInput5=envDigInput5, envLED3Label=envLED3Label, envTemperature3State=envTemperature3State, envLED1Label=envLED1Label, envTemperature1LowTrap=envTemperature1LowTrap, envDigInput2State=envDigInput2State, envTemperature1OffsetF=envTemperature1OffsetF, envDigInput1Polarity=envDigInput1Polarity, envTemperature2State=envTemperature2State, envDigInput6TrueTrap=envDigInput6TrueTrap, envDigInput1State=envDigInput1State, envTemperature2F=envTemperature2F, envTemperature3HighTrap=envTemperature3HighTrap, envTemperature3F=envTemperature3F, envDigInput9TrapEnabled=envDigInput9TrapEnabled, envIdentSpecific=envIdentSpecific, envDigInput3=envDigInput3, liebertEnvironment=liebertEnvironment, envTemp3HighLimitF=envTemp3HighLimitF, envDigInput9State=envDigInput9State, envDigInput9FalseTrap=envDigInput9FalseTrap, envTemperature2HighTrap=envTemperature2HighTrap, envLED1Control=envLED1Control, envTemperature3Label=envTemperature3Label, envReceptacle3=envReceptacle3, envDigInput10State=envDigInput10State, envDigInput8Label=envDigInput8Label, envTemperature2OffsetF=envTemperature2OffsetF, envDigInput1TrapEnabled=envDigInput1TrapEnabled, envTemperature2Label=envTemperature2Label, envTemperature1Label=envTemperature1Label, envTemp3Calibrate=envTemp3Calibrate, envTemperature2OffsetC=envTemperature2OffsetC, envReceptacle1=envReceptacle1, envTemp1HighLimitC=envTemp1HighLimitC, envHumidity2LowTrap=envHumidity2LowTrap, envTemperature3C=envTemperature3C, envHumidity2=envHumidity2, envHumiditySensors=envHumiditySensors, envHumidity1Offset=envHumidity1Offset, envTemperature3OffsetC=envTemperature3OffsetC, envDigInput3FalseTrap=envDigInput3FalseTrap, envHumidity1LowTrap=envHumidity1LowTrap, envLED3State=envLED3State, envTemp2LowLimitC=envTemp2LowLimitC, envDigInput6Label=envDigInput6Label, envHumidity1LowLimit=envHumidity1LowLimit, envDigInput2TrueTrap=envDigInput2TrueTrap, envTemperature3NormalTrap=envTemperature3NormalTrap, envTemperature1HighTrap=envTemperature1HighTrap, envReceptacle4=envReceptacle4, envDigInput2FalseTrap=envDigInput2FalseTrap, envSummaryAlarmTrap=envSummaryAlarmTrap, envLED2Control=envLED2Control, envTemperature3LowTrap=envTemperature3LowTrap, envHumidity1NormalTrap=envHumidity1NormalTrap, envHumidity2NormalTrap=envHumidity2NormalTrap, envReceptacle2State=envReceptacle2State, envDigInput9=envDigInput9, envDigInput7=envDigInput7, envDigInput3TrapEnabled=envDigInput3TrapEnabled, envTemperature2C=envTemperature2C, envHumidity1HighLimit=envHumidity1HighLimit, lePrivate=lePrivate, envDigitalInputs=envDigitalInputs, envHumidity2HighTrap=envHumidity2HighTrap, envTemperature1State=envTemperature1State, envIdentSoftwareVersion=envIdentSoftwareVersion, envDigInput2=envDigInput2, envLED2Label=envLED2Label, envDigInput10Polarity=envDigInput10Polarity, envTemperatureSensors=envTemperatureSensors, envTemp1LowLimitC=envTemp1LowLimitC, envAudibleState=envAudibleState, envDigInput8Polarity=envDigInput8Polarity, envDigInput8TrueTrap=envDigInput8TrueTrap, envRelay1Label=envRelay1Label, envDigInput8FalseTrap=envDigInput8FalseTrap)

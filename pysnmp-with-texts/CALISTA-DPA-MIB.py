#
# PySNMP MIB module CALISTA-DPA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CALISTA-DPA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:46:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, iso, enterprises, ModuleIdentity, MibIdentifier, Bits, Gauge32, Integer32, TimeTicks, ObjectIdentity, Counter32, NotificationType, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "enterprises", "ModuleIdentity", "MibIdentifier", "Bits", "Gauge32", "Integer32", "TimeTicks", "ObjectIdentity", "Counter32", "NotificationType", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class DisplayString(OctetString):
    pass

calista = MibIdentifier((1, 3, 6, 1, 4, 1, 7505))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 7505, 1))
dpa = MibIdentifier((1, 3, 6, 1, 4, 1, 7505, 1, 1))
serialNumber = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: serialNumber.setDescription('Unique value assigned to each DPA device.')
imageVersion = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imageVersion.setStatus('mandatory')
if mibBuilder.loadTexts: imageVersion.setDescription('The version of the main image code that the DPA is currently running.')
loaderVersion = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loaderVersion.setStatus('mandatory')
if mibBuilder.loadTexts: loaderVersion.setDescription('The version of the boot loader code that the DPA is currently running.')
integrationMode = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unconfigured", 1), ("simple", 2), ("hybrid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: integrationMode.setStatus('mandatory')
if mibBuilder.loadTexts: integrationMode.setDescription('The integration mode in which the DPA is currently operating: unconfigured the factory setting; the DPA requires configuring before it can be connected to an Octel voicemail system. simple the DPA is connected to only an Octel voicemail system and Cisco CallManager hybrid the DPA is connected to an Octel voicemail system, a PBX system and Cisco CallManager See the DPA Administration Guide for more detailed descriptions of these modes.')
pbxType = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pbxType.setStatus('mandatory')
if mibBuilder.loadTexts: pbxType.setDescription('The PBX type that the DPA is currently emulating in order to communicate with the Octel voicemail system. This also determines the protocol used on the digital telephony links to the PBX, if in hybrid mode.')
receivedCalls = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivedCalls.setStatus('mandatory')
if mibBuilder.loadTexts: receivedCalls.setDescription('The number of IP telephony calls made to this DPA. This includes all calls, regardless of whether the Octel answered. This could happen, for instance, if the original caller hangs up before the Octel accepts the call.')
outgoingCallsMade = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outgoingCallsMade.setStatus('mandatory')
if mibBuilder.loadTexts: outgoingCallsMade.setDescription('The number of calls originated by the Octel which go through the DPA. These include networking calls (communication between peer Octel systems), pager and mobile notifications and fax calls.')
mwiCommandsReceived = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mwiCommandsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mwiCommandsReceived.setDescription('The number of commands to set or clear a Message Waiting Indicator received by this DPA from the Octel voicemail system. These commands are relayed to the Cisco CallManager via the virtual port, and, if the DPA is operating in hybrid mode, the attached PBX system.')
pbxQueuedMWICommands = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pbxQueuedMWICommands.setStatus('mandatory')
if mibBuilder.loadTexts: pbxQueuedMWICommands.setDescription('The number of commands to set or clear a Message Waiting Indicator which are queued within the DPA, waiting to be sent to the PBX. These commands will be issued to the PBX when the appropriate port becomes available. If the DPA is not operating in hybrid mode, this value will always be zero.')
pbxCompletedMWICommands = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pbxCompletedMWICommands.setStatus('mandatory')
if mibBuilder.loadTexts: pbxCompletedMWICommands.setDescription('The number of commands to set or clear a Message Waiting Indicator which have been successfully sent to the PBX. If the DPA is not operating in hybrid mode, this value will always be zero.')
pbxMWIErrors = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pbxMWIErrors.setStatus('mandatory')
if mibBuilder.loadTexts: pbxMWIErrors.setDescription("The number of commands to set or clear a Message Waiting Indicator that the DPA was unable to send successfully to the PBX. Such commands will have been discarded, and the cause written to the DPA's error log. If the DPA is not operating in hybrid mode, this value will always be zero.")
callManagerQueuedMWICommands = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: callManagerQueuedMWICommands.setStatus('mandatory')
if mibBuilder.loadTexts: callManagerQueuedMWICommands.setDescription('The number of commands to set or clear a Message Waiting Indicator which are queued within the DPA, waiting to be sent to Cisco CallManager.')
callManagerCompletedMWICommands = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: callManagerCompletedMWICommands.setStatus('mandatory')
if mibBuilder.loadTexts: callManagerCompletedMWICommands.setDescription('The number of commands to set or clear a Message Waiting Indicator which have been successfully sent to Cisco CallManager.')
callManagerMWIErrors = MibScalar((1, 3, 6, 1, 4, 1, 7505, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: callManagerMWIErrors.setStatus('mandatory')
if mibBuilder.loadTexts: callManagerMWIErrors.setDescription("The number of commands to set or clear a Message Waiting Indicator that the DPA was unable to send successfully to Cisco CallManager. Such commands will have been discarded, and the cause written to the DPA's error log.")
portTable = MibTable((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15), )
if mibBuilder.loadTexts: portTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTable.setDescription('A list of the available ports on the DPA, with current state information for each.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1), ).setIndexNames((0, "CALISTA-DPA-MIB", "portIndex"))
if mibBuilder.loadTexts: portEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portEntry.setDescription('An entry containing all relevant information for a DPA port.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('A unique value for each port. Its value ranges from 1 to the total number of ports.')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notInUse", 1), ("octel", 2), ("pbx", 3), ("virtual", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('mandatory')
if mibBuilder.loadTexts: portType.setDescription('How this port is currently being used: notInUse not currently in use (may become active later) octel connected to an Octel voicemail system pbx connected to a digital PBX virtual not a physical port; connected only to Cisco CallManager It should be noted that the type of a port is determined when it first becomes active. Significantly, this value will not change back to notInUse if a port is later disconnected; the relevant portTelephonyLinkState value should be read to determine whether the port is currently active.')
portTelephonyLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("down", 2), ("registering", 3), ("up", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTelephonyLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: portTelephonyLinkState.setDescription('The state of the digital telephony link. This field only has meaning for physical ports connected to Octel voicemail systems or digital PBX systems. For virtual ports or those currently not in use, the state will be returned as notApplicable.')
portCallManagerLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("down", 2), ("registering", 3), ("up", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCallManagerLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: portCallManagerLinkState.setDescription("The state of this port's connection to a Cisco CallManager, if such a connection exists. For ports connected to digital PBX systems (see the portType entry) this will be returned as notApplicable.")
portCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 1), ("notApplicable", 2), ("onHook", 3), ("callIn", 4), ("callOut", 5), ("onCall", 6), ("offHook", 7), ("transfer", 8), ("outCall", 9), ("hangingUp", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCallState.setStatus('mandatory')
if mibBuilder.loadTexts: portCallState.setDescription("Once a port's required link(s) to an Octel / PBX and CallManager have become active, it then becomes available for use placing calls between the two realms. This entry shows the current state of any active call for a port, as described in the DPA Administration Guide.")
portDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDeviceName.setStatus('mandatory')
if mibBuilder.loadTexts: portDeviceName.setDescription('The device name under which this port is registered with Cisco CallManager.')
portCodecInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("g711ALaw", 2), ("g711MuLaw", 3), ("g723dot1", 4), ("g729a", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCodecInUse.setStatus('mandatory')
if mibBuilder.loadTexts: portCodecInUse.setDescription('If there is a call in progress on this port, this entry gives the codec in use, otherwise it will return none.')
portErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portErrors.setDescription('The number of centiseconds during which PBX protocol errors were detected for this port. It is normal for there to be some errors, especially during port initialization, but very large values should only be seen on disconnected ports.')
portDacLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 15, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDacLevel.setStatus('mandatory')
if mibBuilder.loadTexts: portDacLevel.setDescription('The DAC level for the port; this is related to the voltage level on the digital telephony port, and is only used in diagnosis of internal hardware faults.')
callManagerConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16), )
if mibBuilder.loadTexts: callManagerConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: callManagerConnectionTable.setDescription('A list of all of the Cisco CallManager connections that the DPA is currently maintaining.')
callManagerConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1), ).setIndexNames((0, "CALISTA-DPA-MIB", "portIndex"), (0, "CALISTA-DPA-MIB", "cmConnectionIndex"))
if mibBuilder.loadTexts: callManagerConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: callManagerConnectionEntry.setDescription('An entry containing all relevant information for a connection to a Cisco CallManager device.')
cmConnectionPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionPortIndex.setDescription('Corresponds to portIndex in PortEntry.')
cmConnectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionIndex.setDescription('The index of this connection; each port can have connections to several Cisco CallManagers, with one active connection and the rest operating in standby mode.')
cmConnectionCallManagerName = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionCallManagerName.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionCallManagerName.setDescription('The host name, if known, of the CallManager to which this connection refers.')
cmConnectionIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionIpAddress.setDescription('The IP address of the CallManager to which this connection refers.')
cmConnectionIpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionIpPort.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionIpPort.setDescription('The TCP port number on the CallManager to which this connection has been made.')
cmConnectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 7505, 1, 1, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connecting", 2), ("retryBackOff", 3), ("connectPending", 4), ("active", 5), ("standby", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmConnectionState.setStatus('mandatory')
if mibBuilder.loadTexts: cmConnectionState.setDescription('The current state of this connection. The possible values have the following meanings: idle initial state of the link before a connection has been attempted, and the state to which a link changes after teardown connecting a TCP link to a Cisco CallManager system is in the process of being established retryBackOff the attempt to establish to the Cisco CallManager failed; the connection stays in this state for a short while before the DPA tries again connectPending the retry back off period has finished and the DPA is about to re-attempt connection to the Cisco CallManager active the connection has been successfully established; this state signifies that the connection is being used for transmission and reception of Skinny Station Protocol messages standby the connection has been successfully established but it is not currently being used for data traffic; however, it would move into the active state were the currently active connection to go down ')
mibBuilder.exportSymbols("CALISTA-DPA-MIB", pbxMWIErrors=pbxMWIErrors, cmConnectionPortIndex=cmConnectionPortIndex, portEntry=portEntry, portIndex=portIndex, portType=portType, portCallManagerLinkState=portCallManagerLinkState, portCallState=portCallState, pbxType=pbxType, portTelephonyLinkState=portTelephonyLinkState, portCodecInUse=portCodecInUse, callManagerConnectionTable=callManagerConnectionTable, portDeviceName=portDeviceName, pbxCompletedMWICommands=pbxCompletedMWICommands, callManagerQueuedMWICommands=callManagerQueuedMWICommands, portTable=portTable, products=products, cmConnectionIpPort=cmConnectionIpPort, portDacLevel=portDacLevel, mwiCommandsReceived=mwiCommandsReceived, loaderVersion=loaderVersion, cmConnectionIpAddress=cmConnectionIpAddress, DisplayString=DisplayString, cmConnectionIndex=cmConnectionIndex, cmConnectionCallManagerName=cmConnectionCallManagerName, receivedCalls=receivedCalls, integrationMode=integrationMode, cmConnectionState=cmConnectionState, serialNumber=serialNumber, portErrors=portErrors, imageVersion=imageVersion, calista=calista, outgoingCallsMade=outgoingCallsMade, callManagerCompletedMWICommands=callManagerCompletedMWICommands, callManagerConnectionEntry=callManagerConnectionEntry, pbxQueuedMWICommands=pbxQueuedMWICommands, callManagerMWIErrors=callManagerMWIErrors, dpa=dpa)

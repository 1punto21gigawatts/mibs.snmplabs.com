#
# PySNMP MIB module A3COM0019-RMON-REMOTE-POLL (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM0019-RMON-REMOTE-POLL
# Produced by pysmi-0.3.4 at Wed May  1 11:08:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
remotePoll, = mibBuilder.importSymbols("A3COM0027-RMON-EXTENSIONS", "remotePoll")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
EntryStatus, = mibBuilder.importSymbols("RMON-MIB", "EntryStatus")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Bits, ObjectIdentity, Unsigned32, MibIdentifier, NotificationType, ModuleIdentity, Counter64, iso, Counter32, TimeTicks, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Bits", "ObjectIdentity", "Unsigned32", "MibIdentifier", "NotificationType", "ModuleIdentity", "Counter64", "iso", "Counter32", "TimeTicks", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
remPollTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1), )
if mibBuilder.loadTexts: remPollTable.setStatus('mandatory')
if mibBuilder.loadTexts: remPollTable.setDescription('This table is used to provide remote device monitoring facilities. This table allows a list of network devices to be set up and polled regularly (or only once) by a variety of protocols. The table can be configured to inform the management station(s) of devices that are not responding to polls or that have started to respond after a period of silence.')
remPollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1), ).setIndexNames((0, "A3COM0019-RMON-REMOTE-POLL", "remPollIndex"))
if mibBuilder.loadTexts: remPollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: remPollTableEntry.setDescription('A table used to define device monitoring.')
remPollIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: remPollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: remPollIndex.setDescription('Unique identifier of a row in the Poll Table. This index should be treated in the same way as indices of other RMON tables. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
remPollIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: remPollIfIndex.setDescription('Identifies the entry in the ifTable which is to be used as the source of the poll packet. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remPollAddress.setDescription('This DisplayString is the network address of the device to monitor. Typically this is an IP, MAC or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format MAC AABBCCDDEEFF - hex notation IPX AABBCCDD:AABBCCDDEEFF - network : node If the format is unrecognised then a badValue error is returned. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3), ("netBIOS", 4), ("appleTalk", 5), ("amp", 6), ("llc", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: remPollProtocol.setDescription('This defines the protocol with which to monitor the device. Writing an address to the remPollAddress field causes a default remPollProtocol value to be setup. The default value is derived from the format/content of the address. If the requested protocol is not supported or is not compatible with the remPollAddress, then an error is returned when an attempt is made to set the remPollStatus to valid. If the requested protocol is not supported then a badValue error should be returned. If the requested protocol is not compatible with the remPollAddress then an error is returned when an attempt is made to set the remPollStatus to valid. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: remPollTimeout.setDescription('The time-out value in hundreds of a second for each request packet. If a device replies to a request packet within the specified time-out, then the poll is judged to be successful. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: remPollAttempts.setDescription('The number of unsuccessful requests necessary before deciding that the device is definitely not responding. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: remPollPeriod.setDescription('The device will be polled every remPollPeriod seconds. The first poll is sent as soon as the remPollStatus is set to valid(1). To prevent overlapping polls, the value of remPollPeriod must be greater than 2*remPollTimeout*remPollAttempts - otherwise an error is returned when the row is set to valid. A poll consists of sending up to remPollAttempts request packets to the device. A reply to any of the request packets is sufficient to declare the poll successful (and stop further requests from being sent). A poll is deemed unsuccessful if no replies have been received after remPollTimeout*remPollAttempts seconds from the start of the poll. Note: each request packet must contain some sequence information so that late replies do not result in a successful poll. The first unsuccessful poll causes a PollFailure event to be generated - further unsuccessful polls do not generate events. The next successful poll to the device causes a PollSuccess event to be generated - further successful polls do not generate events. The pattern then repeats. The value 0 has a special value meaning of only-once When remPollStatus is set to valid(1), a single poll is started immediately. There are no events generated. whether the poll has been judged successful or unsuccessful. The results of the poll(s) can be monitored by reading the remPollLastRequest and remPolLastReply fields. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollLastRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remPollLastRequest.setStatus('mandatory')
if mibBuilder.loadTexts: remPollLastRequest.setDescription('This is the value of sysUpTime at which the most recent request packet was sent. To avoid temporary inconsistancies between the values of remPollLastRequest and remPollLastReply. The value of remPollLastRequest should not be updated until the end of a poll. At which point (a) remPollLastRequest is updated to the sysUpTime when the most recent request packet was sent and (b) if the poll was successful then remPollLastReply is also updated.')
remPollLastReply = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remPollLastReply.setStatus('mandatory')
if mibBuilder.loadTexts: remPollLastReply.setDescription('This is the value of sysUpTime at which the most recent reply packet was received. The device was responding at this time. The relationship of sysUpTime, remPollLastRequest and remPollLastReply provide the following information: (sysUpTime - remPollLastRequest) = time since last request was made. (sysUpTime - remPollLastReply) = time since device last responded. if( remPollLastReply => remPollLastRequest) then (remPollLastReply - remPollLastRequest) = round trip time of last request else if( remPollLastReply <remPollLastRequest) then there was no reply to the last request - the device is not responding ')
remPollInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remPollInformation.setStatus('mandatory')
if mibBuilder.loadTexts: remPollInformation.setDescription('After each successful poll, this field is updated with some protocol specific information that was gleaned from the packet exchange. For the IPX protocol, this string contains the number of router hops made by the poll response packet. For the IP protocol, this string contains the value of Time-To-Live from the IP packet header.')
remPollSuccessEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollSuccessEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: remPollSuccessEventIndex.setDescription('The index of the eventEntry that is used when a successful poll is made after a number of unsuccessful polls. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollFailureEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollFailureEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: remPollFailureEventIndex.setDescription('The index of the eventEntry that is used when an unsuccessful poll is made after a number of successful polls. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated remPollStatus object is equal to valid(1).')
remPollOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollOwner.setStatus('mandatory')
if mibBuilder.loadTexts: remPollOwner.setDescription('The RMON OwnerString conventions are used here to help control the multi-manager situations.')
remPollStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 25, 1, 1, 1, 15), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remPollStatus.setStatus('mandatory')
if mibBuilder.loadTexts: remPollStatus.setDescription('This object controls the creation and deletion of entries in the remPollTable. The RMON EntryStatus conventions are used.')
mibBuilder.exportSymbols("A3COM0019-RMON-REMOTE-POLL", remPollAttempts=remPollAttempts, remPollFailureEventIndex=remPollFailureEventIndex, remPollTimeout=remPollTimeout, remPollLastReply=remPollLastReply, remPollProtocol=remPollProtocol, remPollIfIndex=remPollIfIndex, remPollSuccessEventIndex=remPollSuccessEventIndex, remPollPeriod=remPollPeriod, remPollStatus=remPollStatus, remPollTableEntry=remPollTableEntry, remPollInformation=remPollInformation, remPollAddress=remPollAddress, remPollTable=remPollTable, remPollLastRequest=remPollLastRequest, remPollOwner=remPollOwner, remPollIndex=remPollIndex)

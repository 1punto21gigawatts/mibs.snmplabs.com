#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-UnackTrunksMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-UnackTrunksMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
RowStatus, Unsigned32, Gauge32, DisplayString, StorageType, Counter32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "RowStatus", "Unsigned32", "Gauge32", "DisplayString", "StorageType", "Counter32")
Link, PassportCounter64, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "Link", "PassportCounter64", "NonReplicated")
mscTrkIndex, mscTrk = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex", "mscTrk")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, MibIdentifier, IpAddress, ObjectIdentity, iso, Integer32, Unsigned32, Gauge32, Counter64, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibIdentifier", "IpAddress", "ObjectIdentity", "iso", "Integer32", "Unsigned32", "Gauge32", "Counter64", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
unackTrunksMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22))
mscTrkUnAcked = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2))
mscTrkUnAckedRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1), )
if mibBuilder.loadTexts: mscTrkUnAckedRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedRowStatusTable.setDescription('This entry controls the addition and deletion of mscTrkUnAcked components.')
mscTrkUnAckedRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedRowStatusEntry.setDescription('A single entry in the table represents a single mscTrkUnAcked component.')
mscTrkUnAckedRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTrkUnAcked components. These components can be added and deleted.')
mscTrkUnAckedComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTrkUnAckedStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedStorageType.setDescription('This variable represents the storage type value for the mscTrkUnAcked tables.')
mscTrkUnAckedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTrkUnAckedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedIndex.setDescription('This variable represents the index for the mscTrkUnAcked tables.')
mscTrkUnAckedProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 10), )
if mibBuilder.loadTexts: mscTrkUnAckedProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedProvTable.setDescription('This group of provisionable attributes contains the parameters used by Unacknowledged, Utp, and FrAccess for monitoring link quality.')
mscTrkUnAckedProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedProvEntry.setDescription('An entry in the mscTrkUnAckedProvTable.')
mscTrkUnAckedMaximumErroredInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 15), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedMaximumErroredInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedMaximumErroredInterval.setDescription('This attribute specifies the interval time over which the error threshold (as specified by receiveErrorSensitivity) must be continuously exceeded before the Unacknowledged, Utp, or FrAccess component can be degraded. Once the error interval count exceeds the provisioned value, the Unacknowledged, Utp, or FrAccess component issues an alarm indicating that link quality has degraded, and it disables its parent component. The exception to this is a value of zero, the default, which indicates that the mechanism is completely disabled.')
mscTrkUnAckedReceiveErrorSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 10), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedReceiveErrorSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedReceiveErrorSensitivity.setDescription('This attribute is the allowable error rate beyond which the Unacknowledged, Utp, or FrAccess component can be degraded if it persists for a duration longer than the maximumErrorInterval. The threshold is expressed as a percentage of number of errored frames in the last interval per number of frames received in the last interval. The exception to this is a value of zero, which indicates that the mechanism is completely disabled. The configurable values are: 0 = the mechanism is completely disabled 1 = 1/(2**1) 2 = 1/(2**2) 3 = 1/(2**3) : 10 = 1/(2**10)')
mscTrkUnAckedStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11), )
if mibBuilder.loadTexts: mscTrkUnAckedStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscTrkUnAckedStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedStateEntry.setDescription('An entry in the mscTrkUnAckedStateTable.')
mscTrkUnAckedAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscTrkUnAckedOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscTrkUnAckedUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscTrkUnAckedAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. Usually, the resource remains available for service. The operationalState is almost always enabled. There is one exception where an operationalState of disabled is used in conjunction with degraded for a component which represents a rolled up view of a set of other components. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. The value migrating indicates that a software migration activation is in progress, making the component unavailable for other activities until the migration is complete. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8) migrating(9)')
mscTrkUnAckedProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscTrkUnAckedControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscTrkUnAckedAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscTrkUnAckedStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below is present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscTrkUnAckedUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscTrkUnAckedFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2))
mscTrkUnAckedFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscTrkUnAckedFramer components.')
mscTrkUnAckedFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscTrkUnAckedFramer component.')
mscTrkUnAckedFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTrkUnAckedFramer components. These components cannot be added nor deleted.')
mscTrkUnAckedFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTrkUnAckedFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerStorageType.setDescription('This variable represents the storage type value for the mscTrkUnAckedFramer tables.')
mscTrkUnAckedFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTrkUnAckedFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerIndex.setDescription('This variable represents the index for the mscTrkUnAckedFramer tables.')
mscTrkUnAckedFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 10), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscTrkUnAckedFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerProvEntry.setDescription('An entry in the mscTrkUnAckedFramerProvTable.')
mscTrkUnAckedFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscTrkUnAckedFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscTrkUnAckedFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkEntry.setDescription('An entry in the mscTrkUnAckedFramerLinkTable.')
mscTrkUnAckedFramerFramingType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("hdlc", 0), ("interrupting", 1))).clone('interrupting')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFramingType.setDescription('This attribute specifies the type of framing protocol that will be used for frames transmitted to the link interface and received from the link interface. If the value of this attribute is set to the default interrupting, then a Proprietary hdlc protocol is used which allows for voice cells to interrupt transmission of data frames, transmit the voice cell, and then continue transmitting the data frame. If the value of this attribute is set to hdlc, then the standard hdlc procotol is used for the sequential transmission of individual frames.')
mscTrkUnAckedFramerDataInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 16))).clone(namedValues=NamedValues(("off", 0), ("on", 16))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerDataInversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerDataInversion.setDescription("This attribute determines whether data bits are to be inverted (1 to 0 and 0 to 1) before transmission of frames to the interface. If the value of this attribute is On, the incoming data bits will also be inverted when frames are received from the link before being processed. This option is typically used in hdlc framing mode when inversion is used to guarantee 1's density. Note that aborts (in hdlc and interrupting modes) are corrupted when data is inverted.")
mscTrkUnAckedFramerFrameCrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("crc16", 0), ("crc32", 1), ("noCrc", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrameCrcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrameCrcType.setDescription('This attribute defines the type of CRC used. The CRC value calculated is appended to the end of the frames transmitted to the link. The CRC value is removed from the end of frames received from the link and checked for correctness. NoCrc means that CRC is not used.')
mscTrkUnAckedFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscTrkUnAckedFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 12), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscTrkUnAckedFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerStateEntry.setDescription('An entry in the mscTrkUnAckedFramerStateTable.')
mscTrkUnAckedFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscTrkUnAckedFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscTrkUnAckedFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscTrkUnAckedFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerStatsTable.setDescription('This group contains the operational statistics data for a Unacknowledge Framer component.')
mscTrkUnAckedFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerStatsEntry.setDescription('An entry in the mscTrkUnAckedFramerStatsTable.')
mscTrkUnAckedFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscTrkUnAckedFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscTrkUnAckedFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscTrkUnAckedFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscTrkUnAckedFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscTrkUnAckedFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerCrcErrors.setDescription('This attribute is the total number of frames with with CRC errors.')
mscTrkUnAckedFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors.')
mscTrkUnAckedFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscTrkUnAckedFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscTrkUnAckedFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscTrkUnAckedFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerLargeFrmErrors.setDescription('This attribute is the total number of frames received which were too large. The frame execeeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscTrkUnAckedFramerFrmModeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmModeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmModeErrors.setDescription('This attribute is the total number of frames detected with framing mode errors. A framingModeError is flagged when frames are inconsistent with the specified framingType, that is when interrupting frames are used while running in hdlc mode.')
mscTrkUnAckedFramerOutOfSequenceFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerOutOfSequenceFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerOutOfSequenceFrm.setDescription('This attribute is the total number of out of sequence frames in interrupting mode that have been received from the link.')
mscTrkUnAckedFramerRepeatedFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerRepeatedFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerRepeatedFrm.setDescription('This attribute is the total number of repeated frames (frames with the same sequence number) in interrupting mode that have been received from the link.')
mscTrkUnAckedFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscTrkUnAckedFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscTrkUnAckedFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilTable.setDescription('This group contains the link utilization operational data for a Framer component.')
mscTrkUnAckedFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilEntry.setDescription('An entry in the mscTrkUnAckedFramerUtilTable.')
mscTrkUnAckedFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscTrkUnAckedFramerHighPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerHighPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerHighPrioLinkUtilToIf.setDescription('This attribute is the utilization of the interrupting data traffic sent to the link as a percentage of the available bandwidth on the link. Note that this includes traffic with a Transfer Priority (TP) of 11 and/or Emission Priority of 1. The utilization is the average for the last minute.')
mscTrkUnAckedFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscTrkUnAckedFramerHighPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 14, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkUnAckedFramerHighPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerHighPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the interrupting data traffic received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with a Transfer Priority (TP) of 11 and/or Emission Priority of 1. The utilization is the average for the last minute.')
mscTrkUnAckedFramerUtilThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15), )
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilThresholdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilThresholdTable.setDescription('This group contains all of the provisioning data required to set the link utilization alarm thresholds. All thresholds are percentages which can take on any value in the range of 0% through 100%. The value 100% is used to disable an individual threshold. For values other than 100%, a semantic check ensures that the minor alarm threshold is less than the other thresholds and that the major alarm threshold is less than the critical alarm threshold.')
mscTrkUnAckedFramerUtilThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedIndex"), (0, "Nortel-MsCarrier-MscPassport-UnackTrunksMIB", "mscTrkUnAckedFramerIndex"))
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilThresholdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerUtilThresholdEntry.setDescription('An entry in the mscTrkUnAckedFramerUtilThresholdTable.')
mscTrkUnAckedFramerMinorLinkUtilAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerMinorLinkUtilAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerMinorLinkUtilAlarmThreshold.setDescription('This attribute provides the threshold value which defines when a minor alarm would be issued, denoting a sustained total average link utilization. The total average link utilization is calculated based on the number of received bytes. The Set alarm is issued after 3 minutes of utilization greater than the given threshold. The corresponding Clear alarm is issued after a subsequent 3 minutes of utilization less than or equal to the given threshold. The value 100% is used to disable an individual threshold. For values other than 100%, a semantic check ensures that the minor alarm threshold is less than the other thresholds.')
mscTrkUnAckedFramerMajorLinkUtilAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(85)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerMajorLinkUtilAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerMajorLinkUtilAlarmThreshold.setDescription('This attribute provides the threshold value which defines when a major alarm would be issued, denoting a sustained total average link utilization. The total average link utilization is calculated based on the number of received bytes. The Set alarm is issued after 3 minutes of utilization greater than the given threshold. The corresponding Clear alarm is issued after a subsequent 3 minutes of utilization less than or equal to the given threshold. The value 100% is used to disable an individual threshold. For values other than 100%, a semantic check ensures that the major alarm threshold is greater than the minor threshold and less than the critical threshold.')
mscTrkUnAckedFramerCriticalLinkUtilAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(95)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerCriticalLinkUtilAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerCriticalLinkUtilAlarmThreshold.setDescription('This attribute provides the threshold value which defines when a critical alarm would be issued, denoting a sustained total average link utilization. The total average link utilization is calculated based on the number of received bytes. The Set alarm is issued after 3 minutes of utilization greater than the given threshold. The corresponding Clear alarm is issued after a subsequent 3 minutes of utilization less than or equal to the given threshold. The value 100% is used to disable an individual threshold. For values other than 100%, a semantic check ensures that the critical alarm threshold is greater than the other thresholds.')
mscTrkUnAckedFramerLinkUtilAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 2, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkUtilAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkUnAckedFramerLinkUtilAlarmStatus.setDescription('This attribute provides control of the generation of link utilization alarms. If the value is disabled, none of the alarms are generated (this is equivalent to setting all of the thresholds to 100%). If the value is enabled, the individual thresholds are handled.')
unackTrunksGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 1))
unackTrunksGroupCB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 1, 2))
unackTrunksGroupCB01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 1, 2, 2))
unackTrunksGroupCB01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 1, 2, 2, 2))
unackTrunksCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 3))
unackTrunksCapabilitiesCB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 3, 2))
unackTrunksCapabilitiesCB01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 3, 2, 2))
unackTrunksCapabilitiesCB01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 22, 3, 2, 2, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-UnackTrunksMIB", mscTrkUnAckedFramerHighPrioLinkUtilToIf=mscTrkUnAckedFramerHighPrioLinkUtilToIf, mscTrkUnAckedFramerStatsTable=mscTrkUnAckedFramerStatsTable, unackTrunksGroup=unackTrunksGroup, mscTrkUnAckedControlStatus=mscTrkUnAckedControlStatus, mscTrkUnAckedStorageType=mscTrkUnAckedStorageType, mscTrkUnAckedFramerMajorLinkUtilAlarmThreshold=mscTrkUnAckedFramerMajorLinkUtilAlarmThreshold, mscTrkUnAckedFramerUtilEntry=mscTrkUnAckedFramerUtilEntry, mscTrkUnAckedMaximumErroredInterval=mscTrkUnAckedMaximumErroredInterval, mscTrkUnAckedStateTable=mscTrkUnAckedStateTable, mscTrkUnAckedFramerProvTable=mscTrkUnAckedFramerProvTable, unackTrunksGroupCB01A=unackTrunksGroupCB01A, unackTrunksCapabilitiesCB01A=unackTrunksCapabilitiesCB01A, mscTrkUnAckedStandbyStatus=mscTrkUnAckedStandbyStatus, mscTrkUnAckedFramerUnderruns=mscTrkUnAckedFramerUnderruns, mscTrkUnAckedFramerRowStatus=mscTrkUnAckedFramerRowStatus, mscTrkUnAckedFramerNormPrioLinkUtilFromIf=mscTrkUnAckedFramerNormPrioLinkUtilFromIf, mscTrkUnAckedFramer=mscTrkUnAckedFramer, mscTrkUnAckedFramerCriticalLinkUtilAlarmThreshold=mscTrkUnAckedFramerCriticalLinkUtilAlarmThreshold, mscTrkUnAckedStateEntry=mscTrkUnAckedStateEntry, mscTrkUnAckedFramerMinorLinkUtilAlarmThreshold=mscTrkUnAckedFramerMinorLinkUtilAlarmThreshold, mscTrkUnAckedFramerFlagsBetweenFrames=mscTrkUnAckedFramerFlagsBetweenFrames, mscTrkUnAckedFramerDataInversion=mscTrkUnAckedFramerDataInversion, mscTrkUnAckedFramerLinkUtilAlarmStatus=mscTrkUnAckedFramerLinkUtilAlarmStatus, mscTrkUnAckedFramerStateTable=mscTrkUnAckedFramerStateTable, mscTrkUnAckedOperationalState=mscTrkUnAckedOperationalState, mscTrkUnAckedProceduralStatus=mscTrkUnAckedProceduralStatus, mscTrkUnAckedIndex=mscTrkUnAckedIndex, mscTrkUnAckedFramerProvEntry=mscTrkUnAckedFramerProvEntry, mscTrkUnAckedFramerLrcErrors=mscTrkUnAckedFramerLrcErrors, mscTrkUnAckedFramerInterfaceName=mscTrkUnAckedFramerInterfaceName, mscTrkUnAckedFramerNonOctetErrors=mscTrkUnAckedFramerNonOctetErrors, mscTrkUnAckedFramerLinkEntry=mscTrkUnAckedFramerLinkEntry, mscTrkUnAckedFramerRepeatedFrm=mscTrkUnAckedFramerRepeatedFrm, unackTrunksGroupCB01=unackTrunksGroupCB01, mscTrkUnAckedFramerNormPrioLinkUtilToIf=mscTrkUnAckedFramerNormPrioLinkUtilToIf, mscTrkUnAckedFramerFrmFromIf=mscTrkUnAckedFramerFrmFromIf, mscTrkUnAckedFramerOctetFromIf=mscTrkUnAckedFramerOctetFromIf, mscTrkUnAckedFramerUtilThresholdEntry=mscTrkUnAckedFramerUtilThresholdEntry, mscTrkUnAckedAdminState=mscTrkUnAckedAdminState, mscTrkUnAckedFramerUsageState=mscTrkUnAckedFramerUsageState, mscTrkUnAckedFramerFrmToIf=mscTrkUnAckedFramerFrmToIf, unackTrunksCapabilitiesCB=unackTrunksCapabilitiesCB, mscTrkUnAckedUnknownStatus=mscTrkUnAckedUnknownStatus, mscTrkUnAckedFramerOctetFromIf64=mscTrkUnAckedFramerOctetFromIf64, mscTrkUnAckedRowStatusTable=mscTrkUnAckedRowStatusTable, unackTrunksGroupCB=unackTrunksGroupCB, mscTrkUnAcked=mscTrkUnAcked, mscTrkUnAckedRowStatusEntry=mscTrkUnAckedRowStatusEntry, mscTrkUnAckedFramerStateEntry=mscTrkUnAckedFramerStateEntry, mscTrkUnAckedFramerRowStatusEntry=mscTrkUnAckedFramerRowStatusEntry, mscTrkUnAckedFramerComponentName=mscTrkUnAckedFramerComponentName, mscTrkUnAckedFramerFrameCrcType=mscTrkUnAckedFramerFrameCrcType, mscTrkUnAckedFramerStorageType=mscTrkUnAckedFramerStorageType, mscTrkUnAckedAlarmStatus=mscTrkUnAckedAlarmStatus, mscTrkUnAckedFramerCrcErrors=mscTrkUnAckedFramerCrcErrors, mscTrkUnAckedFramerLargeFrmErrors=mscTrkUnAckedFramerLargeFrmErrors, mscTrkUnAckedFramerStatsEntry=mscTrkUnAckedFramerStatsEntry, mscTrkUnAckedProvTable=mscTrkUnAckedProvTable, mscTrkUnAckedFramerOverruns=mscTrkUnAckedFramerOverruns, mscTrkUnAckedReceiveErrorSensitivity=mscTrkUnAckedReceiveErrorSensitivity, mscTrkUnAckedComponentName=mscTrkUnAckedComponentName, mscTrkUnAckedFramerFramingType=mscTrkUnAckedFramerFramingType, mscTrkUnAckedUsageState=mscTrkUnAckedUsageState, mscTrkUnAckedFramerRowStatusTable=mscTrkUnAckedFramerRowStatusTable, unackTrunksCapabilitiesCB01=unackTrunksCapabilitiesCB01, mscTrkUnAckedFramerOutOfSequenceFrm=mscTrkUnAckedFramerOutOfSequenceFrm, unackTrunksCapabilities=unackTrunksCapabilities, mscTrkUnAckedProvEntry=mscTrkUnAckedProvEntry, mscTrkUnAckedFramerAborts=mscTrkUnAckedFramerAborts, mscTrkUnAckedFramerUtilTable=mscTrkUnAckedFramerUtilTable, mscTrkUnAckedFramerUtilThresholdTable=mscTrkUnAckedFramerUtilThresholdTable, mscTrkUnAckedAvailabilityStatus=mscTrkUnAckedAvailabilityStatus, mscTrkUnAckedFramerLinkTable=mscTrkUnAckedFramerLinkTable, mscTrkUnAckedFramerIndex=mscTrkUnAckedFramerIndex, mscTrkUnAckedFramerOperationalState=mscTrkUnAckedFramerOperationalState, mscTrkUnAckedFramerHighPrioLinkUtilFromIf=mscTrkUnAckedFramerHighPrioLinkUtilFromIf, mscTrkUnAckedRowStatus=mscTrkUnAckedRowStatus, mscTrkUnAckedFramerAdminState=mscTrkUnAckedFramerAdminState, mscTrkUnAckedFramerFrmModeErrors=mscTrkUnAckedFramerFrmModeErrors, mscTrkUnAckedFramerFrmFromIf64=mscTrkUnAckedFramerFrmFromIf64, unackTrunksMIB=unackTrunksMIB)

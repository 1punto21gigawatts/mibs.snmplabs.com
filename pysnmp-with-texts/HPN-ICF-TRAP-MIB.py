#
# PySNMP MIB module HPN-ICF-TRAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HPN-ICF-TRAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:41:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
hpnicfCommon, = mibBuilder.importSymbols("HPN-ICF-OID-MIB", "hpnicfCommon")
InterfaceIndex, ifIndex, ifDescr = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "ifDescr")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter32, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, IpAddress, Bits, TimeTicks, Unsigned32, ObjectIdentity, ModuleIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "IpAddress", "Bits", "TimeTicks", "Unsigned32", "ObjectIdentity", "ModuleIdentity", "iso")
TextualConvention, TAddress, TruthValue, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TAddress", "TruthValue", "RowStatus", "DisplayString")
hpnicfTrap = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38))
hpnicfTrap.setRevisions(('2010-06-05 10:50',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpnicfTrap.setRevisionsDescriptions(('The initial revision of this MIB module.',))
if mibBuilder.loadTexts: hpnicfTrap.setLastUpdated('201006051050Z')
if mibBuilder.loadTexts: hpnicfTrap.setOrganization('')
if mibBuilder.loadTexts: hpnicfTrap.setContactInfo('')
if mibBuilder.loadTexts: hpnicfTrap.setDescription('This MIB is applicable to routers, switches and other products. Some objects in this may be used only for some specific products, so users should refer to the related documents to acquire more detail information. ')
hpnicfTableGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1))
hpnicfMacTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1))
hpnicfMacTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfMacTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfMacTabTrapEnable.setDescription('Indicates whether hpnicfMacTabFullTrap and hpnicfMacTabAlmostFullTrap traps should be generated when the MAC table is filled.')
hpnicfMacTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfMacTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfMacTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the MAC table is full or two traps which occur when the MAC table is almost full.')
hpnicfMacTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 3))
hpnicfMacTabLen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfMacTabLen.setStatus('current')
if mibBuilder.loadTexts: hpnicfMacTabLen.setDescription('The length of the MAC table.')
hpnicfMacTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 4))
hpnicfMacTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 4, 1)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfMacTabLen"))
if mibBuilder.loadTexts: hpnicfMacTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfMacTabFullTrap.setDescription('Send this trap when the MAC table is filled. The interval between two traps generated should be longer than hpnicfMacTabTrapInterval.')
hpnicfMacTabAlmostFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 1, 4, 2))
if mibBuilder.loadTexts: hpnicfMacTabAlmostFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfMacTabAlmostFullTrap.setDescription('Send this trap when the MAC table is almost full. The interval between two traps generated should be longer than hpnicfMacTabTrapInterval.')
hpnicfArpTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2))
hpnicfArpTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfArpTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfArpTabTrapEnable.setDescription('Indicates whether hpnicfArpTabFullTrap traps should be generated when the ARP table is filled.')
hpnicfArpTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfArpTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfArpTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the ARP table is filled.')
hpnicfArpTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 3))
hpnicfArpTabLen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfArpTabLen.setStatus('current')
if mibBuilder.loadTexts: hpnicfArpTabLen.setDescription('The length of the ARP table.')
hpnicfArpTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 4))
hpnicfArpTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 4, 1)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfArpTabLen"))
if mibBuilder.loadTexts: hpnicfArpTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfArpTabFullTrap.setDescription('Send this trap when the ARP table is filled. The interval between two traps generated should be longer than hpnicfArpTabTrapInterval.')
hpnicfArpPortDynamicEntryFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 2, 4, 2)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfArpTabLen"), ("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"))
if mibBuilder.loadTexts: hpnicfArpPortDynamicEntryFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfArpPortDynamicEntryFullTrap.setDescription('Send this trap when the dynamic ARP number of the port exceeds the limitation. The object hpnicfArpTabLen describes the limitation of the max dynamic ARP number of this port. The interval between two traps should be longer than hpnicfArpTabTrapInterval.')
hpnicfRtTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3))
hpnicfDetailRtTrapTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 1), )
if mibBuilder.loadTexts: hpnicfDetailRtTrapTable.setStatus('current')
if mibBuilder.loadTexts: hpnicfDetailRtTrapTable.setDescription('This table contains objects to decide what kind of trap should be sent.')
hpnicfDetailRtTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 1, 1), ).setIndexNames((0, "HPN-ICF-TRAP-MIB", "hpnicfDetailRtProType"))
if mibBuilder.loadTexts: hpnicfDetailRtTrapEntry.setStatus('current')
if mibBuilder.loadTexts: hpnicfDetailRtTrapEntry.setDescription('Entry items')
hpnicfDetailRtProType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("rip", 3), ("isis", 4), ("ospf", 5), ("bgp", 6)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfDetailRtProType.setStatus('current')
if mibBuilder.loadTexts: hpnicfDetailRtProType.setDescription('The index value which uniquely identifies an entry in the hpnicfDetailRtTrapTable.')
hpnicfDetailRtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfDetailRtEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfDetailRtEnable.setDescription('Indicates whether hpnicfDetailRtTabFullTrap traps should be generated when a specific routing table is filled.')
hpnicfRtTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfRtTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfRtTabTrapEnable.setDescription('Indicates whether hpnicfRtTabFullTrap traps should be generated when the routing table is filled.')
hpnicfRtTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfRtTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfRtTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the routing table is filled.')
hpnicfRtTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 4))
hpnicfRtTabLen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 4, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfRtTabLen.setStatus('current')
if mibBuilder.loadTexts: hpnicfRtTabLen.setDescription('The length of the routing table. The detail routing tables also use the same object.')
hpnicfDefaultRtNextHopType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 4, 2), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfDefaultRtNextHopType.setStatus('current')
if mibBuilder.loadTexts: hpnicfDefaultRtNextHopType.setDescription('The IP address type of the next hop of the default route. The value must be ipv4 or ipv6')
hpnicfDefaultRtNextHop = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 4, 3), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfDefaultRtNextHop.setStatus('current')
if mibBuilder.loadTexts: hpnicfDefaultRtNextHop.setDescription('The IP address of the next hop of the default route.')
hpnicfDefaultRtOutIf = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 4, 4), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfDefaultRtOutIf.setStatus('current')
if mibBuilder.loadTexts: hpnicfDefaultRtOutIf.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
hpnicfRtTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 5))
hpnicfRtTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 5, 1)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfRtTabLen"))
if mibBuilder.loadTexts: hpnicfRtTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfRtTabFullTrap.setDescription('Send this trap when the routing table is filled. The interval between two traps generated should be longer than hpnicfRtTabTrapInterval.')
hpnicfDetailRtTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 5, 2)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfDetailRtProType"), ("HPN-ICF-TRAP-MIB", "hpnicfRtTabLen"))
if mibBuilder.loadTexts: hpnicfDetailRtTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfDetailRtTabFullTrap.setDescription('Send this trap when the detail routing table is filled. The interval between two traps generated should be longer than hpnicfRtTabTrapInterval.')
hpnicfDefaultRtDelTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 5, 3)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfDetailRtProType"), ("HPN-ICF-TRAP-MIB", "hpnicfDefaultRtNextHopType"), ("HPN-ICF-TRAP-MIB", "hpnicfDefaultRtNextHop"), ("HPN-ICF-TRAP-MIB", "hpnicfDefaultRtOutIf"))
if mibBuilder.loadTexts: hpnicfDefaultRtDelTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfDefaultRtDelTrap.setDescription('Send this trap when the default route is deleted.')
hpnicfDefaultRtDelTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 3, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfDefaultRtDelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfDefaultRtDelTrapEnable.setDescription('Indicates whether hpnicfDefaultRtDelTrap traps should be generated when the default route is deleted.')
hpnicfMulticastTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4))
hpnicfMulticastTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfMulticastTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfMulticastTabTrapEnable.setDescription('Indicates whether hpnicfMulticastTabFullTrap traps should be generated when the multicast table is filled.')
hpnicfMulticastTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfMulticastTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfMulticastTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the multicast table is filled.')
hpnicfMulticastTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 3))
hpnicfMulticastTabType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lay2", 1), ("lay3", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfMulticastTabType.setStatus('current')
if mibBuilder.loadTexts: hpnicfMulticastTabType.setDescription('Defining the type of the multicast table, layer2 or layer3.')
hpnicfMulticastTabLen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 3, 2), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfMulticastTabLen.setStatus('current')
if mibBuilder.loadTexts: hpnicfMulticastTabLen.setDescription('The length of the multicast table.')
hpnicfMulticastTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 4))
hpnicfMulticastTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 4, 4, 1)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfMulticastTabType"), ("HPN-ICF-TRAP-MIB", "hpnicfMulticastTabLen"))
if mibBuilder.loadTexts: hpnicfMulticastTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfMulticastTabFullTrap.setDescription('Send this trap when the multicast table is filled. The interval between two traps generated should be longer than hpnicfMulticastTabTrapInterval.')
hpnicfNdTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5))
hpnicfNdTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfNdTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hpnicfNdTabTrapEnable.setDescription('Indicates whether hpnicfNdTabFullTrap traps should be generated when the ND table is filled.')
hpnicfNdTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfNdTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfNdTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the ND table is filled.')
hpnicfNdTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 3))
hpnicfNdTabLen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpnicfNdTabLen.setStatus('current')
if mibBuilder.loadTexts: hpnicfNdTabLen.setDescription('The length of the ND table.')
hpnicfNdTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 4))
hpnicfNdTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 5, 4, 1)).setObjects(("HPN-ICF-TRAP-MIB", "hpnicfNdTabLen"))
if mibBuilder.loadTexts: hpnicfNdTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfNdTabFullTrap.setDescription('Send this trap when the ND table is filled. The interval between two traps generated should be longer than hpnicfNdTabTrapInterval.')
hpnicfPeriodicalTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6))
hpnicfPeriodicalTrapObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 1))
hpnicfPeriodicalTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 3600), )).clone(60)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfPeriodicalTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hpnicfPeriodicalTrapInterval.setDescription('Definition of the periodical interval. If no trap occurs during the certain interval, an hpnicfPeriodicalTrap will be generated. If the interval is set to 0, no hpnicfPeriodicalTrap will be generated.')
hpnicfPeriodicalTrapSwitch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfPeriodicalTrapSwitch.setStatus('current')
if mibBuilder.loadTexts: hpnicfPeriodicalTrapSwitch.setDescription('Definition of the periodical switch. If the value is off,the hpnicfPeriodicalTrap will not be generated. the hpnicfPeriodicalTrapInterval will be set to 0.')
hpnicfPeriodicalTrapSwitch2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfPeriodicalTrapSwitch2.setStatus('current')
if mibBuilder.loadTexts: hpnicfPeriodicalTrapSwitch2.setDescription('Periodical heartbeat trap sending switch. If the value is off, the hpnicfPeriodicalTrap will not be generated, and the hpnicfPeriodicalTrapInterval will be set to 0. This node differs from hpnicfPeriodicalTrapSwitch in value.')
hpnicfPeriodicalTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 2))
hpnicfPeriodicalNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 3))
hpnicfPeriodicalNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 3, 0))
hpnicfPeriodicalTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 6, 3, 0, 1))
if mibBuilder.loadTexts: hpnicfPeriodicalTrap.setStatus('current')
if mibBuilder.loadTexts: hpnicfPeriodicalTrap.setDescription('If no trap occurs during the interval spicified by hpnicfPeriodicalTrapInterval, an hpnicfPeriodicalTrap will be generated. If the interval is set to 0, no hpnicfPeriodicalTrap will be generated.')
hpnicfTrapDesInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7))
hpnicfTrapDesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1), )
if mibBuilder.loadTexts: hpnicfTrapDesInfoTable.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesInfoTable.setDescription('A table of trap destination host address and port .')
hpnicfTrapDesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1), ).setIndexNames((0, "HPN-ICF-TRAP-MIB", "hpnicfTrapDesInfoIndex"))
if mibBuilder.loadTexts: hpnicfTrapDesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesInfoEntry.setDescription('The entry of trap destination host address and port.')
hpnicfTrapDesInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: hpnicfTrapDesInfoIndex.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesInfoIndex.setDescription('The index of this table.')
hpnicfTrapDesIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpnicfTrapDesIPAddress.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesIPAddress.setDescription('The host IP address of the trap destination.')
hpnicfTrapDesPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpnicfTrapDesPort.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesPort.setDescription('The port of the trap destination.')
hpnicfTrapDesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpnicfTrapDesRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesRowStatus.setDescription('The status of this table entry.')
hpnicfTrapDesAddrTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 7, 1, 1, 5), TAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpnicfTrapDesAddrTAddress.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapDesAddrTAddress.setDescription('This object contains a transport address.')
hpnicfTrapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8))
hpnicfTrapConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1), )
if mibBuilder.loadTexts: hpnicfTrapConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigTable.setDescription('A table of trap configuration.')
hpnicfTrapConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1), ).setIndexNames((0, "HPN-ICF-TRAP-MIB", "hpnicfTrapConfigIndex"))
if mibBuilder.loadTexts: hpnicfTrapConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigEntry.setDescription('The entry of trap configuration.')
hpnicfTrapConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpnicfTrapConfigIndex.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigIndex.setDescription('The index of this table.')
hpnicfTrapConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpnicfTrapConfigName.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigName.setDescription('The name of the appointed traps.')
hpnicfTrapConfigDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfTrapConfigDescr.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigDescr.setDescription('The description of the appointed traps.')
hpnicfTrapConfigSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfTrapConfigSwitch.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigSwitch.setDescription('Indicates whether the specified traps should be generated.')
hpnicfTrapConfigSwitch2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 15, 2, 38, 1, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpnicfTrapConfigSwitch2.setStatus('current')
if mibBuilder.loadTexts: hpnicfTrapConfigSwitch2.setDescription('Indicates whether the specified traps should be generated. This node differs from hpnicfTrapConfigSwitch in value.')
mibBuilder.exportSymbols("HPN-ICF-TRAP-MIB", hpnicfTrapConfigIndex=hpnicfTrapConfigIndex, hpnicfRtTabStatGroup=hpnicfRtTabStatGroup, hpnicfMacTabLen=hpnicfMacTabLen, hpnicfPeriodicalTrapInterval=hpnicfPeriodicalTrapInterval, hpnicfNdTabTrapInterval=hpnicfNdTabTrapInterval, hpnicfMacTabTrapInterval=hpnicfMacTabTrapInterval, hpnicfArpTabTrap=hpnicfArpTabTrap, hpnicfDefaultRtNextHop=hpnicfDefaultRtNextHop, hpnicfRtTabTrap=hpnicfRtTabTrap, hpnicfMulticastTabTrapEnable=hpnicfMulticastTabTrapEnable, hpnicfMacTabTrapEnable=hpnicfMacTabTrapEnable, hpnicfMulticastTabLen=hpnicfMulticastTabLen, hpnicfNdTabStatGroup=hpnicfNdTabStatGroup, hpnicfRtTabTrapInterval=hpnicfRtTabTrapInterval, hpnicfTrapConfigEntry=hpnicfTrapConfigEntry, hpnicfDetailRtTrapEntry=hpnicfDetailRtTrapEntry, hpnicfPeriodicalNotification=hpnicfPeriodicalNotification, hpnicfTableGroup=hpnicfTableGroup, hpnicfDetailRtProType=hpnicfDetailRtProType, hpnicfTrapDesInfoIndex=hpnicfTrapDesInfoIndex, hpnicfTrapDesRowStatus=hpnicfTrapDesRowStatus, hpnicfArpPortDynamicEntryFullTrap=hpnicfArpPortDynamicEntryFullTrap, hpnicfArpTabTrapInterval=hpnicfArpTabTrapInterval, hpnicfDetailRtEnable=hpnicfDetailRtEnable, hpnicfRtTabTrapEnable=hpnicfRtTabTrapEnable, hpnicfDefaultRtDelTrap=hpnicfDefaultRtDelTrap, hpnicfMacTabStatGroup=hpnicfMacTabStatGroup, hpnicfDefaultRtNextHopType=hpnicfDefaultRtNextHopType, hpnicfPeriodicalTrapSwitch=hpnicfPeriodicalTrapSwitch, hpnicfNdTabLen=hpnicfNdTabLen, hpnicfTrapConfigSwitch=hpnicfTrapConfigSwitch, hpnicfTrapDesInfoEntry=hpnicfTrapDesInfoEntry, hpnicfPeriodicalTrapGroup=hpnicfPeriodicalTrapGroup, hpnicfNdTabTrapInfo=hpnicfNdTabTrapInfo, hpnicfTrapDesAddrTAddress=hpnicfTrapDesAddrTAddress, hpnicfMulticastTabStatGroup=hpnicfMulticastTabStatGroup, hpnicfTrap=hpnicfTrap, hpnicfArpTabFullTrap=hpnicfArpTabFullTrap, hpnicfTrapConfigTable=hpnicfTrapConfigTable, hpnicfTrapDesInfoTable=hpnicfTrapDesInfoTable, hpnicfTrapDesPort=hpnicfTrapDesPort, hpnicfMulticastTabTrapInfo=hpnicfMulticastTabTrapInfo, hpnicfArpTabLen=hpnicfArpTabLen, hpnicfArpTabTrapEnable=hpnicfArpTabTrapEnable, hpnicfDetailRtTabFullTrap=hpnicfDetailRtTabFullTrap, hpnicfMulticastTabType=hpnicfMulticastTabType, hpnicfTrapConfigName=hpnicfTrapConfigName, hpnicfNdTabTrapEnable=hpnicfNdTabTrapEnable, hpnicfRtTabTrapInfo=hpnicfRtTabTrapInfo, hpnicfTrapConfigSwitch2=hpnicfTrapConfigSwitch2, hpnicfPeriodicalTrap=hpnicfPeriodicalTrap, hpnicfPeriodicalTrapObjects=hpnicfPeriodicalTrapObjects, hpnicfMulticastTabTrapInterval=hpnicfMulticastTabTrapInterval, hpnicfRtTabLen=hpnicfRtTabLen, hpnicfMacTabTrapInfo=hpnicfMacTabTrapInfo, PYSNMP_MODULE_ID=hpnicfTrap, hpnicfMacTabAlmostFullTrap=hpnicfMacTabAlmostFullTrap, hpnicfMacTabTrap=hpnicfMacTabTrap, hpnicfArpTabTrapInfo=hpnicfArpTabTrapInfo, hpnicfMacTabFullTrap=hpnicfMacTabFullTrap, hpnicfNdTabTrap=hpnicfNdTabTrap, hpnicfPeriodicalNotificationPrefix=hpnicfPeriodicalNotificationPrefix, hpnicfRtTabFullTrap=hpnicfRtTabFullTrap, hpnicfTrapDesIPAddress=hpnicfTrapDesIPAddress, hpnicfMulticastTabTrap=hpnicfMulticastTabTrap, hpnicfTrapConfig=hpnicfTrapConfig, hpnicfTrapConfigDescr=hpnicfTrapConfigDescr, hpnicfMulticastTabFullTrap=hpnicfMulticastTabFullTrap, hpnicfPeriodicalTrapInfo=hpnicfPeriodicalTrapInfo, hpnicfDefaultRtDelTrapEnable=hpnicfDefaultRtDelTrapEnable, hpnicfDetailRtTrapTable=hpnicfDetailRtTrapTable, hpnicfNdTabFullTrap=hpnicfNdTabFullTrap, hpnicfArpTabStatGroup=hpnicfArpTabStatGroup, hpnicfDefaultRtOutIf=hpnicfDefaultRtOutIf, hpnicfTrapDesInfo=hpnicfTrapDesInfo, hpnicfPeriodicalTrapSwitch2=hpnicfPeriodicalTrapSwitch2)

#
# PySNMP MIB module L2L3-VPN-MCAST-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/L2L3-VPN-MCAST-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:04:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
jnxL2L3VpnMcastExperiment, = mibBuilder.importSymbols("JUNIPER-EXPERIMENT-MIB", "jnxL2L3VpnMcastExperiment")
jnxMibs, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
MplsLabel, = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsLabel")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Integer32, IpAddress, Bits, TimeTicks, Gauge32, Counter32, Unsigned32, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType, experimental, ObjectIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "IpAddress", "Bits", "TimeTicks", "Gauge32", "Counter32", "Unsigned32", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType", "experimental", "ObjectIdentity", "MibIdentifier")
TimeInterval, TimeStamp, TextualConvention, RowPointer, DisplayString, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "TimeStamp", "TextualConvention", "RowPointer", "DisplayString", "RowStatus", "TruthValue")
jnxL2L3VpnMcastMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1))
jnxL2L3VpnMcastMIB.setRevisions(('2012-11-05 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxL2L3VpnMcastMIB.setRevisionsDescriptions(('Initial version of the draft.',))
if mibBuilder.loadTexts: jnxL2L3VpnMcastMIB.setLastUpdated('201211051200Z')
if mibBuilder.loadTexts: jnxL2L3VpnMcastMIB.setOrganization('IETF Layer-3 Virtual Private Networks Working Group.')
if mibBuilder.loadTexts: jnxL2L3VpnMcastMIB.setContactInfo(' Comments and discussion to l3vpn@ietf.org Jeffrey (Zhaohui) Zhang Juniper Networks, Inc. 10 Technology Park Drive Westford, MA 01886 USA Email: zzhang@juniper.net ')
if mibBuilder.loadTexts: jnxL2L3VpnMcastMIB.setDescription('This MIB contains common managed object definitions for multicast in Layer 2 and Layer 3 VPNs, defined by [I-D.ietf-l2vpn-vpls-mcast] and RFC 6513/6514. Copyright (C) The Internet Society (2012).')
class JnxL2L3VpnMcastProviderTunnelType(TextualConvention, Integer32):
    description = 'Types of provider tunnels used for multicast in a l2/l3vpn.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("unconfigured", 0), ("rsvp-p2mp", 1), ("ldp-p2mp", 2), ("pim-ssm", 3), ("pim-asm", 4), ("pim-bidir", 5), ("ingress-replication", 6), ("ldp-mp2mp", 7))

jnxL2L3VpnMcastObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1))
jnxL2L3VpnMcastPmsiStates = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1))
jnxL2L3VpnMcastPmsiTunnelAttributeTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1), )
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeTable.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeTable.setDescription('This table is for advertised/received PMSI attributes, to be referred to by I-PMSI or S-PMSI table entries')
jnxL2L3VpnMcastPmsiTunnelAttributeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1), ).setIndexNames((0, "L2L3-VPN-MCAST-MIB", "jnxL2L3VpnMcastPmsiTunnelAttributeFlags"), (0, "L2L3-VPN-MCAST-MIB", "jnxL2L3VpnMcastPmsiTunnelAttributeType"), (0, "L2L3-VPN-MCAST-MIB", "jnxL2L3VpnMcastPmsiTunnelAttributeLabel"), (0, "L2L3-VPN-MCAST-MIB", "jnxL2L3VpnMcastPmsiTunnelAttributeId"))
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeEntry.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeEntry.setDescription("An entry in this table corresponds to an PMSI attribute that is advertised/received on this router. For BGP-based signaling (for I-PMSI via auto-discovery procedure, or for S-PMSI via S-PMSI A-D routes), they are just as signaled by BGP (RFC 6514 section 5, 'PMSI Tunnel attribute'). For UDP-based S-PMSI signaling for PIM-MVPN, they're derived from S-PMSI Join Message (RFC 6513 section 7.4.2, 'UDP-based Protocol').. Note that BGP-based signaling may be used for PIM-MVPN as well.")
jnxL2L3VpnMcastPmsiTunnelAttributeFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1))
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeFlags.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeFlags.setDescription("For UDP-based S-PMSI signaling for PIM-MVPN, this is 0. For BGP-based I/S-PMSI signaling, per RFC 6514 section 5, 'PMSI Tunnel Attribute': The Flags field has the following format: 0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+ | reserved |L| +-+-+-+-+-+-+-+-+ This document defines the following flags: + Leaf Information Required (L)")
jnxL2L3VpnMcastPmsiTunnelAttributeType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 2), JnxL2L3VpnMcastProviderTunnelType())
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeType.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeType.setDescription("For BGP-based I/S-PMSI signaling for either PIM or BGP-MVPN, per RFC 6514 section 5, 'PMSI Tunnel Attribute': The Tunnel Type identifies the type of the tunneling technology used to establish the PMSI tunnel. The type determines the syntax and semantics of the Tunnel Identifier field. This document defines the following Tunnel Types: 0 - No tunnel information present 1 - RSVP-TE P2MP LSP 2 - mLDP P2MP LSP 3 - PIM-SSM Tree 4 - PIM-SM Tree 5 - PIM-Bidir Tree 6 - Ingress Replication 7 - mLDP MP2MP LSP For UDP-based S-PMSI signaling for PIM-MVPN, RFC 6513 does not specify if a PIM provider tunnel is SSM, SM or Bidir, and an agent can use either type 3, 4, or 5 based on its best knowledge.")
jnxL2L3VpnMcastPmsiTunnelAttributeLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 3), MplsLabel())
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeLabel.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeLabel.setDescription("For BGP-based I/S-PMSI signaling, per RFC 6514 section 5, 'PMSI Tunnel Attribute': If the MPLS Label field is non-zero, then it contains an MPLS label encoded as 3 octets, where the high-order 20 bits contain the label value. Absence of MPLS Label is indicated by setting the MPLS Label field to zero. For UDP-based S-PMSI signaling for PIM-MVPN, this is not applicable for now, as RFC 6513 does not specify mpls encapsulation and tunnel aggregation with UDP-based signaling.")
jnxL2L3VpnMcastPmsiTunnelAttributeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 37)))
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeId.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelAttributeId.setDescription("For BGP-based signaling, as defined in RFC 6514 section 5, 'PMSI Tunnel Attribute'. For UDP-based S-PMSI signaling for PIM-MVPN, RFC 6513 only specifies the 'P-Group' address, and that is filled into the first four octets of this field.")
jnxL2L3VpnMcastPmsiTunnelPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelPointer.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelPointer.setDescription('If the tunnel exists in some MIB table, this is the row pointer to it.')
jnxL2L3VpnMcastPmsiTunnelIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 11, 1, 1, 1, 1, 1, 6), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelIf.setStatus('current')
if mibBuilder.loadTexts: jnxL2L3VpnMcastPmsiTunnelIf.setDescription('If the tunnel has a corresponding interface, this is the row pointer to the ifName table.')
mibBuilder.exportSymbols("L2L3-VPN-MCAST-MIB", jnxL2L3VpnMcastMIB=jnxL2L3VpnMcastMIB, jnxL2L3VpnMcastPmsiStates=jnxL2L3VpnMcastPmsiStates, jnxL2L3VpnMcastPmsiTunnelAttributeLabel=jnxL2L3VpnMcastPmsiTunnelAttributeLabel, jnxL2L3VpnMcastPmsiTunnelAttributeId=jnxL2L3VpnMcastPmsiTunnelAttributeId, jnxL2L3VpnMcastObjects=jnxL2L3VpnMcastObjects, JnxL2L3VpnMcastProviderTunnelType=JnxL2L3VpnMcastProviderTunnelType, jnxL2L3VpnMcastPmsiTunnelPointer=jnxL2L3VpnMcastPmsiTunnelPointer, jnxL2L3VpnMcastPmsiTunnelIf=jnxL2L3VpnMcastPmsiTunnelIf, jnxL2L3VpnMcastPmsiTunnelAttributeTable=jnxL2L3VpnMcastPmsiTunnelAttributeTable, PYSNMP_MODULE_ID=jnxL2L3VpnMcastMIB, jnxL2L3VpnMcastPmsiTunnelAttributeFlags=jnxL2L3VpnMcastPmsiTunnelAttributeFlags, jnxL2L3VpnMcastPmsiTunnelAttributeType=jnxL2L3VpnMcastPmsiTunnelAttributeType, jnxL2L3VpnMcastPmsiTunnelAttributeEntry=jnxL2L3VpnMcastPmsiTunnelAttributeEntry)

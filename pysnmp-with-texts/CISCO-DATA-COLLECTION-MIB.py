#
# PySNMP MIB module CISCO-DATA-COLLECTION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-DATA-COLLECTION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:54:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
SnmpTagValue, = mibBuilder.importSymbols("SNMP-TARGET-MIB", "SnmpTagValue")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
NotificationType, ObjectIdentity, Integer32, zeroDotZero, Gauge32, Unsigned32, ModuleIdentity, TimeTicks, IpAddress, Counter32, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "ObjectIdentity", "Integer32", "zeroDotZero", "Gauge32", "Unsigned32", "ModuleIdentity", "TimeTicks", "IpAddress", "Counter32", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "iso")
TruthValue, RowStatus, TextualConvention, RowPointer, DateAndTime, DisplayString, VariablePointer = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "TextualConvention", "RowPointer", "DateAndTime", "DisplayString", "VariablePointer")
ciscoDataCollectionMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 312))
ciscoDataCollectionMIB.setRevisions(('2002-10-30 05:30',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoDataCollectionMIB.setRevisionsDescriptions(('Initial Version.',))
if mibBuilder.loadTexts: ciscoDataCollectionMIB.setLastUpdated('200210300530Z')
if mibBuilder.loadTexts: ciscoDataCollectionMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoDataCollectionMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoDataCollectionMIB.setDescription("The MIB module allows a management application to select a set of MIB object instances whose values need to be collected on a periodic basis. The term 'data' in the context of this MIB is used to generically refer to the values of the selected set of object instances. Once the required setup is done, the MIB implementation carries out the following periodic tasks: - collects the required object values into local file-like entities called VFiles (virtual files). - transfers the VFiles to specified locations. - carries out VFile management operations. Some of the key features of this MIB are: a) Allows grouping of MIB objects into groups called data groups. The constraint is that the MIB objects grouped into a data group, need to have the same semantic MIB index. So it is possible to group MIB objects belonging to different MIB tables into a single data group as long as the above constraint is met. For e.g. it is possible to group ifInOctets from ifTable, ifHCInOctets from ifXTable, dot3StatsExcessiveCollisions from dot3StatsTable into a single data group. b) Allows the application to specify a set of instances (of the MIB objects in a data group) whose values need to be collected. c) The required data can be collected for each such data group on a periodic basis into a virtual file (VFile). A VFile is an abstraction of a file. d) The format of the contents of the VFile, can be specified by the application. e) An application can also specify a collection period. A collection period is an interval of time during which data is collected into a VFile. After the collection period ends, the VFile is frozen, and a new VFile is created for storing data. The frozen VFile is then transferred to a specified destination. An application can choose to retain such frozen VFiles on the device for a certain period of time, called the retention period. Data Collection MIB vs Bulkfile MIB *********************************** The data collection MIB can pretty much do what the CISCO-BULK-FILE-MIB (Bulkfile MIB) can do. The 'manual' mode of the Data collection MIB is similar to the way in which the Bulkfile MIB operates. However the data collection MIB is mainly targetted for medium to high-end platforms which have sufficient local storage (volatile or permanent) to store VFiles. Locally storing VFiles, helps minimize loss of data during temporary network outages. If the local store is permament, then the collected data is also available across agent restarts. The data collection MIB has more powerful data selection features than the Bulkfile MIB. It allows grouping of MIB objects from different tables into data groups. It also incorporates a more flexible instance selection mechanism, where the application is not restricted to fetching an entire MIB table. Definitions: ************ Base objects: ************* MIB objects whose values an application needs to collect. Data group: *********** A group of base objects. Can be of 2 types: 'object' and 'table'. An 'object' type data group can consist of only one fully instantiated base object. A 'table' type data group can consist of more than one base objects, each a columnar object in a conceptual table. In addition a 'table' type data group can specify the instances of the base objects whose values need to be collected. In the context of this MIB, collecting data for a data group means fetching the values of the associated base object instances and storing them into VFiles. Virtual File (VFile): ********************* A VFile is a file like entity used to collect data. An agent might choose to implement a VFile as a simple in-memory buffer, or it might choose to use a file in it's filesystem. An application does not really need to know the location of a VFile - the MIB provides mechanisms to transfer the VFile to application specified locations. However if the implementation supports it, the application can specify the location of the VFiles. Current VFile: ************** The VFile into which data is currently being collected. Frozen VFile: ************* A VFile which is no longer used for collecting data. Only frozen VFiles can be transferred to specified destinations. Collection interval: ******************** A collection interval is associated with a VFile. It is the interval of time over which a VFile is used to collect data. This interval of time can be specified by the application. However there are conditions under which a collection interval can be shorter than the specified time. For e.g. a collection interval is prematurely terminated when the maximum size of a VFile is exceeded, or when there is an error condition. Polling period: *************** A polling period is associated with a data group. It determines the frequency at which the base objects of a data group should be fetched and stored into a VFile. Data collection operations: ************************** A generic term used to refer to operations that are carried out while collecting data. These include: - Periodically creating new VFiles for collecting data. - Transferring frozen VFiles either automatically or on demand. - Fetching base object values and storing them into current VFiles, either periodically or on demand. - Deleting frozen VFiles, either periodically or on demand.")
ciscoDataCollMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 0))
ciscoDataCollMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 1))
ciscoDataCollMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 2))
cdcVFile = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1))
cdcDataGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2))
cdcFileXfer = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3))
class CdcCollectionSubtree(TextualConvention, ObjectIdentifier):
    description = "The subtree component of a (subtree, list) tuple. The purpose of a tuple is to identify the columns (base objects) in a 'table' type data group. The subtree specifies a single OBJECT IDENTIFIER value such that each object in the set is named by the subtree value appended with a single additional sub-identifier derived from the list component of the tuple. A typical example would be the OBJECT IDENTIFER of the fooEntry construct in a MIB table. e.g. ifEntry."
    status = 'current'

class CdcCollectionList(TextualConvention, OctetString):
    description = "The list component of a (subtree, list) tuple. The purpose of a tuple is to identify the base objects of a 'table' type data group. The subtree specifies a single OBJECT IDENTIFIER value such that each object in the set is named by the subtree value appended with a single additional sub-identifier. The list specifies a set of data items, where the presence of an item in the list indicates that the item is selected as a column of the 'table' type data group; the absence of an item from the list indicates that the item is not selected as a column of the 'table' type data group. Each data item is represented by an integer which when appended (as as additional sub-identifier) to the OBJECT IDENTIFIER value of the subtree identified by the tuple, is the name of an object defining that data item (its description and its syntax). The list is specified as an OCTET STRING in which each data item is represented by a single bit, where data items 1 through 8 are represented by the bits in the first octet, data items 9 through 16 by the bits in the second octet, etc. In each octet, the lowest numbered data item is represented by the most significant bit, and the highest numbered data item by the least significant bit. A data item is present in the list when its bit is set, and absent when its bit is reset. If the length of an OCTET STRING value is too short to represent one or more data items defined in a subtree, then those data items are absent from the set identified by the tuple of that subtree and that OCTET STRING value."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 16)

class CdcRowInstanceId(TextualConvention, ObjectIdentifier):
    description = 'A fragment of a OBJECT IDENTIFIER (OID). It is used to specify the instances of the base objects whose values need to be fetched. To comply with the definition of an OBJECT IDENTIFIER, the first two sub-ids of a CdcRowInstanceId value is {0,0}. '
    status = 'current'

class CdcUrl(TextualConvention, OctetString):
    description = 'Represents a string that contains a Uniformed Resource Locator as defined in RFC 1738.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class CdcFileFormat(TextualConvention, Integer32):
    description = "The file formats supported are: cdcBulkASCII ASCII format similar to the 'bulkASCII' format of the CISCO-BULK-FILE-MIB. cdcBulkBinary Binary format similar to the 'bulkBinary' format of the CISCO-BULK-FILE-MIB. cdcSchemaASCII Again an ASCII format, but contains parser friendly hints for parsing data values. Format descriptions : --------------------- The below description applies to cdcBulkASCII & cdcBulkBinary and is extracted from CISCO-BULK-FILE-MIB. Some differences are highlighted below: 1) Data for a single data group can be collected more than once into the same VFile (due to periodic polling). Each such instance of a data group, can be treated much like different 'table' types in the CISCO-BULK-FILE-MIB. 2) Every object & table tag contains an additional sysUpTime field. Similarly each row tag contains the value of the sysUpTime when the data for that row was collected. The rest of the description is taken from the CISCO-BULK-FILE-MIB. The file contains two types of fields: tags and data. Tags identify portions of the file and are discussed in detail below. All other information is in data fields. Note: For efficiency and compactness data fields are not tagged with a type. The interpreter of the data must thus know or have access to appropriate MIB syntax descriptions to understand the file. All data fields are positional relative to a tag and every data field has a length prefix. All initial length prefixes are one byte. For any data type the distinguished length value 255 indicates that the data content is null, that is, no data content value was available and there are no additional bytes in the data field. INTEGER data fields include all data that maps to ASN.1 INTEGER, regardless of length and whether signed or unsigned. They have a length prefix value of zero to eight, followed by that many bytes of data, high-order byte first. High order bytes that are all zero are omitted, thus a length of zero indicates a value of zero. For signed numbers, leading bytes of all ones (hex FF) are omitted if the next remaining byte has the high bit on. This implies that the file parser must know the difference between signed and unsigned integers. OCTET STRING values have a length prefix value of zero to two for a subsequent unsigned byte count for the number of bytes in the OCTET STRING itself, which immediately follows the byte count. The byte count can thus range from zero to 65,535. OBJECT IDENTIFIER values have a length of zero to 128, for the number of sub-identifiers. Each subsequent sub-identifier is encoded as an unsigned INTEGER of 0-4 bytes. The bulk binary file layout directly reflects the contents of the cbfDefineFileObjectTable. It has tagged sections corresponding to cbfDefineObjectClass with a few additional tags for utility purposes. A tag is one byte with one of the following values: -2 row -1 prefix 0 reserved 2 table The prefix tag changes the default OID prefix that is assumed to precede all OIDs that are not MIB object data values. The prefix tag may appear anywhere another tag could appear. A prefix tag is followed by one OID data field. The default prefix is 1.3.6.1. A file need not set the prefix to the default value. Note that when changing the prefix, the default portion must be included at the beginning of the new prefix. Typically the prefix will change for each table or group of scalar objects. A table tag is followed by one INTEGER data field whose value is the number of columns in the table (including the sysUpTime column), as implemented by the agent. This is followed by an OID field containing the sysUpTime OID. This is followed by one OID data field for each column. This is the OID for the column minus the prefix and the instance (typically one subidentifier). The OIDs are then followed by one row for each row in the table. A row starts with a row tag, one OID data field containing only the instance portion of the OIDs for the objects in that row and one data field indicating the sysUpTime when the row was sampled. Following this is one data field of appropriate type for each column. The bulk ASCII form mechanically translates bulk binary into human-readable text. The indicator for a null value is '~'. An INTEGER becomes the integer value with a preceding '-' for negative values and no leading zeros. An OCTET STRING becomes the byte values in hexadecimal, lower case, two characters per byte (that is, with leading zeros), no delimiters between bytes. An OBJECT IDENTIFIER becomes the usual dotted decimal form. A tag becomes the tag's name, spelled out fully in lower case, followed by one blank and the data field(s) for the tag, separated by spaces and ending with a carriage return/line feed. All tags are at the beginning of a 'line' that is terminated with a carriage return/line feed that immediately precedes the next tag or the end of file."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("cdcBulkASCII", 1), ("cdcBulkBinary", 2), ("cdcSchemaASCII", 3))

class CdcFileXferStatus(TextualConvention, Integer32):
    description = 'The status of a file transfer. The different values are given below: notStarted File transfer has not started. success File transfer has successfully completed. aborted File transfer has been aborted. fileOpenFailRemote Remote file could not be opened. badDomainName Bad domain name given in the URL. unreachableIpAddress IP address given in the URL could not be reached. networkFailure Transfer failed due to a network failure. fileWriteFailed A write on the remote file has failed. authFailed Authentication failed. For instance incorrect password in CdcUrl incase of FTP(File Transfer Protocol).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("notStarted", 1), ("success", 2), ("aborted", 3), ("fileOpenFailRemote", 4), ("badDomainName", 5), ("unreachableIpAddress", 6), ("networkFailed", 7), ("fileWriteFailed", 8), ("authFailed", 9))

cdcVFilePersistentStorage = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFilePersistentStorage.setStatus('current')
if mibBuilder.loadTexts: cdcVFilePersistentStorage.setDescription("This object's value reads 'true', if the agent implementation of this MIB supports placement of VFiles in application specified persistent storage locations. Otherwise the value is 'false'.")
cdcVFileMaxSizeHitsLimit = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdcVFileMaxSizeHitsLimit.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMaxSizeHitsLimit.setDescription('A global limit for the number of consecutive times the maximum VFile size (cdcVFileMaxSize) is exceeded for a given VFile. When this limit is exceeded the offending cdcVFileEntry is moved to the error state (see cdcVFileOperStatus).')
cdcVFileTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3), )
if mibBuilder.loadTexts: cdcVFileTable.setStatus('current')
if mibBuilder.loadTexts: cdcVFileTable.setDescription('A table for setting up VFiles for collecting data.')
cdcVFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcVFileIndex"))
if mibBuilder.loadTexts: cdcVFileEntry.setStatus('current')
if mibBuilder.loadTexts: cdcVFileEntry.setDescription("An entry in the cdcVFileTable. Each entry contains application specified configuration that is used to create virtual files (VFile) and start data collection operations. A VFile is used to store data (values of base object instances) as selected by entities called data groups. A data group is defined in cdcDGTable. An entry in this table is said to be 'activated' when the corresponding instances of cdcVFileRowStatus is 'active' AND cdcVFileOperStatus is 'enabled'. The value of sysUpTime.0 when the condition evaluates to 'true' is called the activation time of the entry. The activation time for each entry is maintained internally by the agent.")
cdcVFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcVFileIndex.setStatus('current')
if mibBuilder.loadTexts: cdcVFileIndex.setDescription('An arbitrary integer for uniquely identifying this entry. When creating a row, the application should pick a random number. If the configuration in this entry is persisted across system/agent restarts then the same value of cdcVFileIndex must be assigned to this entry after the restart.')
cdcVFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileName.setStatus('current')
if mibBuilder.loadTexts: cdcVFileName.setDescription("The base-name of the VFiles (created by data collection operations corresponding to this entry) into which data is to be collected. When a VFile is created, it's full name is obtained by the concatentation of a suffix to this value. The suffix will be chosen by the agent such that the VFiles created for this entry have unique names. For e.g. the suffix could be a string representation of the date and time when the VFile was created. If VFiles are to be placed in the agent's local filesystem (provided the agent supports it) then this value should also contain the absolute path of the location as a prefix to the base name. An agent will respond with inconsistentValue to a management set operation which attempts to modify the value of this object to the same value as already held by another instance of cdcVFileName, or wrongValue if the new value is invalid for use as a file name on the local file system (e.g., many file systems do not support white space embedded in file names). This object's value may be modified at any time. However the new name will be used only when the next VFile is created for this entry.")
cdcVFileDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 3), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileDescription.setStatus('current')
if mibBuilder.loadTexts: cdcVFileDescription.setDescription("A string that can be used for administrative purposes. This object's value may be modified at any time.")
cdcVFileCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("idle", 1), ("swapToNewFile", 2), ("collectNow", 3))).clone('idle')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileCommand.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCommand.setDescription("An object for controlling collection of data. 'idle' Indicates that no command is in progress. 'swapToNewFile' When written, the current VFile is frozen, and a new VFile is created for collecting data. If the data collection mode is automatic (see cdcVFileCollectMode), then the current collection interval is stopped and a new collection interval is started (see cdcVFileCollectPeriod). 'collectNow' When written, base object values for all associated data groups are fetched and stored into the current VFile. This value can only be written when the collection mode is 'manual' (see cdcVFileCollectMode).")
cdcVFileMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(512, 4294967295)).clone(50000)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileMaxSize.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMaxSize.setDescription("The maximum size of a VFile. The agent maintains an internal counter for each cdcVFileEntry. This counter counts the number of consecutive times the size of a VFile has exceeded the value of this object. When the value of this counter exceeds the value of cdcVFileMaxSizeHitsLimit, this entry is moved to the 'error' state (see cdcVFileOperStatus). However if the value of cdcVFileMaxSizeHitsLimit is not exceeded, then the current VFile is frozen, and a new VFile is created for data collection. If the data collection mode is automatic (see cdcVFileCollectMode), then the current collection interval is stopped and a new collection interval is started. This object's value may be modified at any time. The new size limit MUST be checked against the size of the current VFile at the time of modification, and appropriate action taken.")
cdcVFileCurrentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileCurrentSize.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCurrentSize.setDescription('The size of the current VFile.')
cdcVFileFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 7), CdcFileFormat().clone('cdcSchemaASCII')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileFormat.setStatus('current')
if mibBuilder.loadTexts: cdcVFileFormat.setDescription("The format in which data is stored into the current VFile. This object's value cannot be modified while the entry is in the 'activated' state.")
cdcVFileCollectMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2))).clone('auto')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileCollectMode.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCollectMode.setDescription("Determines the mode of data collection. 'auto' Data is periodically fetched for all data groups associated with this entry. This is done at data group specific periodic intervals (cdcDGPollPeriod). The data thus collected, is formatted and stored into the current VFile. In addition at regular intervals (see cdcVFileCollectPeriod) a new VFile is created to store data, and the current VFile is frozen and transferred. 'manual' Data for all data groups is fetched and collected into the current VFile only when cdcVFileCommand is set to 'collectNow'. This object's value cannot be modified while the entry is in the 'activated' state.")
cdcVFileCollectionPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 604800)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileCollectionPeriod.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCollectionPeriod.setDescription("Specifies the period of a collection interval. The value of this object is used only when the data collection mode is automatic (see cdcVFileCollectMode). A periodic timer (one per entry) is started when this entry is 'activated'. The time at which this entry is 'activated' is called the 'activation time' for this entry, and is internally maintained by the agent. When this periodic timer expires, the current VFile is frozen and a new VFile is created for data collection. Transfer is then initiated for the frozen VFile. In addition, the internally maintained counter for counting the number of consecutive times the size of a VFile has exceeded the maximum limit, is reset to zero. (See cdcVFileMaxSize) This object's value may be modified at any time, and the new value takes effect immediately. i.e setting a new value can cause the current collection interval to terminate and a new collection interval to start.")
cdcVFileRetentionPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileRetentionPeriod.setStatus('current')
if mibBuilder.loadTexts: cdcVFileRetentionPeriod.setDescription("The time for which a frozen VFile is retained by the agent. When a VFile is frozen, a timer (one per frozen VFile) is started to keep track of the retention period for the VFile. Once this timer expires, the VFile is deleted. Till the expiry of the retention period, information about frozen VFiles is maintained in cdcVFileMgmtTable. This object's value may be modified at any time, however the new value will take effect only for new frozen VFiles.")
cdcVFileAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cdcVFileAdminStatus.setDescription("A control object to indicate the administratively desired state of data collection for this entry. On setting the value to 'disabled' data collection operations for this entry are stopped, the current VFile is frozen and it's transfer is initiated. Modifying the value of cdcVFileAdminStatus to 'disabled' does not remove or change the current configuration as represented by the active rows in this table.")
cdcVFileOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("error", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileOperStatus.setStatus('current')
if mibBuilder.loadTexts: cdcVFileOperStatus.setDescription("A status object to indicate the operational state of collection for this entry. When the value of cdcVFileAdminStatus is modified to be 'enabled', the value of this object will change to 'enabled' providing it is possible to begin collecting data. If at any point of time data cannot be collected because of some error, then the value of this object is changed to 'error' and all collection operations stop, as if cdcVFileAdminStatus has been set to 'disabled'. More information about the nature of the error can be obtained by retrieving the value of cdcVFileErrorCode. When the value of cdcVFileAdminStatus is modified to be 'disabled', the value of this object will change to 'disabled' and data collection operations are stopped for this entry.")
cdcVFileErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noError", 1), ("otherError", 2), ("noSpace", 3), ("openError", 4), ("tooSmallMaxSize", 5), ("tooManyMaxSizeHits", 6), ("noResource", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileErrorCode.setStatus('current')
if mibBuilder.loadTexts: cdcVFileErrorCode.setDescription("A value indicating the type of error that has occurred during data collection operations for this entry. noError The value is 'noError' when the corresponding value of cdcVFileOperStatus is not 'error'. otherError Any error other than one of the following listed errors. noSpace There is no space left to write into the current VFile. openError Could not open VFile for writing. One possible reason could be the existence of another file by the same name in the agent's filesystem. tooSmallMaxSize Indicates that cdcVFileMaxSize is too small for data collection. The cdcVFileMaxSize configured for this VFile is not sufficient even to hold the data collected in one poll. tooManyMaxSizeHits Indicates that data collection operations are stopped because the value of cdcVFileMaxSizeHitsLimit has been exceeded. noResource Some kind of resource was unavailable while collecting data. For e.g. unavailability of dynamic memory.")
cdcVFileCollectionErrorEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileCollectionErrorEnable.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCollectionErrorEnable.setDescription("When set to 'true', cdcVFileCollectionError notification will be sent out in the event of a data collection error.")
cdcVFileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 3, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcVFileRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdcVFileRowStatus.setDescription("The status of this conceptual row. A valid cdcVFileName is only mandatory object for setting this object to 'active'. But collection of data in to active vfile starts only on setting cdcVFileAdminStatus to 'enabled'. Setting this object to 'destroy' stops all data collection operations for this entry, deletes all VFiles and removes this entry from cdcVFileTable.")
cdcVFileMgmtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4), )
if mibBuilder.loadTexts: cdcVFileMgmtTable.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtTable.setDescription('A table to manage frozen VFiles.')
cdcVFileMgmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcVFileIndex"), (0, "CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtIndex"))
if mibBuilder.loadTexts: cdcVFileMgmtEntry.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtEntry.setDescription('An entry in cdcVFileMgmtTable. Each entry corresponds to a frozen VFile. An entry is created in this table, whenever a VFile is frozen. An entry is removed from this table whenever a frozen VFile is deleted either because the retention period elapsed or because it was adminstratively deleted. If the configuration specified in cdcVFileEntry is persisted across system/agent restarts AND the VFiles created as a result of that configuration are persisted across restarts, then this table must be populated with entries corresponding to those persisted VFiles. However any state related to an entry, like time to live etc. need not be maintained across restarts.')
cdcVFileMgmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcVFileMgmtIndex.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtIndex.setDescription("This value is a running counter starting at 1, generated by the agent so that the combination of cdcVFileIndex and cdcVFileMgmtIndex uniquely identifies a frozen VFile. The deleted file indicies do not get reused. This object's value needs to be unique only across the set of frozen VFiles corresponding to a cdcVFileEntry (identified by cdcVFileIndex).")
cdcVFileMgmtName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileMgmtName.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtName.setDescription("The full name of the VFile. If the VFile is stored as a file in the agent's filesystem, then this value also contains the absolute path of the file.")
cdcVFileMgmtTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileMgmtTimestamp.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtTimestamp.setDescription('The timestamp when this VFile was created, in the date-time format.')
cdcVFileMgmtTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileMgmtTimeToLive.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtTimeToLive.setDescription('The time left before this VFile is deleted (see cdcVFileRetentionPeriod).')
cdcVFileMgmtCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("delete", 2), ("transfer", 3), ("abortTransfer", 4))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdcVFileMgmtCommand.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtCommand.setDescription('A control to manage VFiles. idle This value can be only be read. It indicates that no management action is currently being performed on this VFile. delete This value is only written, and is used to delete the frozen VFile. Writing this value will cause this entry to be removed from this table. transfer This value can be both read and written. When read it means that the VFile is in the process of being transferred. When written, it initiates a transfer for the VFile. abortTransfer This value can only be written, and is used to abort an ongoing transfer.')
cdcVFileMgmtXferURL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 6), CdcUrl()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdcVFileMgmtXferURL.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtXferURL.setDescription("The complete URL of the destination to which this VFile will be transferred in the next attempt. The URL also includes the complete filename of the remote file that will be created. When the default value of this object is retained this VFile will be transferred to the URL specified in cdcFileXferConfPriUrl or cdcFileXferConfSecUrl, as the case may be. However an application can specify a different URL, in which case the VFile will be transferred to this new URL the next time transfer is initiated. This object's value may be modified at any time.")
cdcVFileMgmtLastXferStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 7), CdcFileXferStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileMgmtLastXferStatus.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtLastXferStatus.setDescription('Indicates the status of the last completed transfer.')
cdcVFileMgmtLastXferURL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 1, 4, 1, 8), CdcUrl()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdcVFileMgmtLastXferURL.setStatus('current')
if mibBuilder.loadTexts: cdcVFileMgmtLastXferURL.setDescription('Indicates the URL of the destination to which the last (completed) transfer was initiated.')
cdcDGTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1), )
if mibBuilder.loadTexts: cdcDGTable.setStatus('current')
if mibBuilder.loadTexts: cdcDGTable.setDescription('A table for specifying data groups.')
cdcDGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcDGIndex"))
if mibBuilder.loadTexts: cdcDGEntry.setStatus('current')
if mibBuilder.loadTexts: cdcDGEntry.setDescription("An entry in this table. Each entry corresponds to a data group. A data group is used to select data that needs to be collected into VFiles. The selection is done by specifying the base objects and their instances for which the values need to be fetched. Data is collected only for those data groups, that have the corresponding instance of cdcDGRowStatus set to 'active'. In order for data to be collected, each data group has to be associated with a cdcVFileEntry (see cdcDGVFileIndex). If the data collection mode of the associated cdcVFileEntry is automatic, then data is fetched and stored into the current VFile of the associated cdcVFileEntry at periodic intervals (cdcDGPollPeriod).")
cdcDGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcDGIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGIndex.setDescription('An arbitrary integer used to uniquely identify this entry. When creating an entry, a management application should pick a random number.')
cdcDGComment = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 2), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGComment.setStatus('current')
if mibBuilder.loadTexts: cdcDGComment.setDescription("A descriptive string. This object's value may be modified at any time.")
cdcDGType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("object", 1), ("table", 2))).clone('table')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGType.setStatus('current')
if mibBuilder.loadTexts: cdcDGType.setDescription("Identifies the type of this data group. object Data is a single MIB object. The fully instantiated OID is specified in cdcDGBaseObject. table Data is a logical table. The columns of this table correspond to the base objects specified in cdcDGBaseObjectTable, and the rows correspond to the values of the instances specified in cdcDGInstanceTable. This object's value cannot be modified while the value of cdcDGRowStatus is 'active'.")
cdcDGVFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGVFileIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGVFileIndex.setDescription("Corresponds to a value of cdcVFileIndex. It is used to associate this data group with a cdcVFileEntry. The values of the base objects for this data group are stored into the current VFile of the associated cdcVFileEntry. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGTargetTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 5), SnmpTagValue().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGTargetTag.setStatus('current')
if mibBuilder.loadTexts: cdcDGTargetTag.setDescription("The tag for the target from which to obtain the data for this data group. A length of 0 indicates the local system. In this case, access to the objects of this data group is under the security credentials of the requester that set cdcDGRowStatus to 'active'. Those credentials are the input parameters for isAccessAllowed from the Architecture for Describing SNMP Management Frameworks. Otherwise a search is carried out for an entry in the snmpTargetAddrTable whose snmpTargetAddrTagList contains the tag specified by the value of this object. The security credentials (snmpTargetParamsEntry) of the first entry that satisfies the above criteria, are passed as input parameters for isAccessAllowed. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 6), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGContextName.setStatus('current')
if mibBuilder.loadTexts: cdcDGContextName.setDescription("The management context from which to obtain data for this data group. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGObject = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 7), VariablePointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGObject.setStatus('current')
if mibBuilder.loadTexts: cdcDGObject.setDescription("The fully instantiated name of the MIB object whose value needs to be fetched. This object's value is used only when cdcDGType is of type 'object'. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGObjectGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGObjectGrpIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGObjectGrpIndex.setDescription("Corresponds to a value of cdcDGBaseObjectGrpIndex, thus identifying a set of entries in cdcDGBaseObjectTable, having this value of cdcDGBaseObjectGrpIndex. This object's value is used only when cdcDGType is of type 'table'. This set of entries in cdcDGBaseObjectTable in turn identifies the set of base objects, that makes up the columns of this 'table' type data group. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGInstGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstGrpIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstGrpIndex.setDescription("Corresponds to a value of cdcDGInstanceGrpIndex, thus identifying a set of entries in cdcDGInstanceTable, having this value of cdcDGInstanceGrpIndex. This object's value is used only when cdcDGType is of type 'table'. The set of entries in cdcDGInstanceTable, in turn identifies the set of instances of the base objects, whose values need to fetched. If the value is 0, then all instances of the base objects will be fetched. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGPollPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 86400)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGPollPeriod.setStatus('current')
if mibBuilder.loadTexts: cdcDGPollPeriod.setDescription("Specifies the time intervals at which the data should be fetched for this data group. This object's value is used only when the collection mode of the associated cdcVFileEntry is automatic (see cdcVFileCollectMode). A periodic timer is started for this data group when cdcDGRowStatus is set to 'active', provided the associated cdcVFileEntry has already been 'activated', otherwise it is started when the associated cdcVFileEntry is finally activated. The time interval after which the first expiration of this timer should occur, is calculated as follows: (value of sysUpTime.0) + (value of cdcPollPeriod for this entry - (value of sysUpTime.0 - VFile activation time for the associated cdcVFileEntry) % cdcPollPeriod) Subsequent expirations of the periodic timer can occur as per the value specified in cdcDGPollPeriod. This helps in synchronizing periodic polling of the data groups with respect to the VFile activation time. This object's value may be modified at any time, and the change must take effect immediately. i.e. if the periodic timer has been started, it's expiry time may need to be re-adjusted.")
cdcDGRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdcDGRowStatus.setDescription("The status of this conceptual row. This object cannot be set to 'active' until values have been assigned to cdcDGVFileIndex & cdcDGColGrpIndex.")
cdcDGBaseObjectTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2), )
if mibBuilder.loadTexts: cdcDGBaseObjectTable.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectTable.setDescription("A table specifying the base objects of a 'table' type data group.")
cdcDGBaseObjectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcDGBaseObjectGrpIndex"), (0, "CISCO-DATA-COLLECTION-MIB", "cdcDGBaseObjectIndex"))
if mibBuilder.loadTexts: cdcDGBaseObjectEntry.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectEntry.setDescription('An individual entry in this table. Each entry is a {subtree, list} tuple. Each tuple identifies a set of base objects for the associated data group.')
cdcDGBaseObjectGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcDGBaseObjectGrpIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectGrpIndex.setDescription("This object's value when combined with the value of cdcDGBaseObjectIndex uniquely identifies an entry in this table. An application must use the same value (can be randomly picked) for this object while creating a group of entries that collectively identifies the set of base objects for a data group.")
cdcDGBaseObjectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcDGBaseObjectIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectIndex.setDescription("This object's value when combined with the value of cdcDGBaseObjectGrpIndex uniquely identifies an entry in this table. A managment application can assign incremental values starting from one, when creating each entry in a group of entries (as identified by the value of cdcDGBaseObjectGrpIndex).")
cdcDGBaseObjectSubtree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1, 3), CdcCollectionSubtree()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGBaseObjectSubtree.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectSubtree.setDescription("The subtree component of a {subtree, list} tuple. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGBaseObjectList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1, 4), CdcCollectionList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGBaseObjectList.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectList.setDescription("The list component of a {subtree, list} tuple. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGBaseObjectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGBaseObjectRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdcDGBaseObjectRowStatus.setDescription("The status of this conceptual row. This object cannot be set to 'active' until values have been assigned to cdcDGBaseObjectSubtree & cdcDGBaseObjectList.")
cdcDGInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3), )
if mibBuilder.loadTexts: cdcDGInstanceTable.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceTable.setDescription("Identifies the instances of the base objects that need to be fetched for a 'table' type data group. The agent is not responsible for verifying that the instances specified for a data group do not overlap.")
cdcDGInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceGrpIndex"), (0, "CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceIndex"))
if mibBuilder.loadTexts: cdcDGInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceEntry.setDescription('An entry in this table. Each entry identifies one or more instances of the base objects that need to be fetched. An instance is represented by an OID fragment.')
cdcDGInstanceGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcDGInstanceGrpIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceGrpIndex.setDescription("This object's value when combined with the value of cdcDGInstanceIndex uniquely identifies an entry in this table. An application must use the same value (can be randomly picked) for this object while creating a group of entries that collectively identifies the set of instances for a data group.")
cdcDGInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdcDGInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceIndex.setDescription("This object's value when combined with the value of cdcDGInstanceGrpIndex uniquely identifies an entry in this table. A managment application can assign incremental values starting from one, when creating each entry within a group of entries (as identified by the value of cdcDGInstanceGrpIndex).")
cdcDGInstanceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("individual", 1), ("range", 2), ("repititions", 3), ("subTree", 4), ("other", 5))).clone('subTree')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceType.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceType.setDescription("Specifies the way in which the instances are to be used while collecting data. individual The value of cdcDGInstanceOid is appended to each base object of the associated data group, thus giving the exact instance of the objects to be collected. range The value of cdcDGInstanceOid is appended to each base object in the associated data group, thus giving the starting object instance of the range. The value of cdcDGInstanceEndOid is appended to to each base object in the associated data group, thus giving the last object instances of the range. repititions The value of cdcDGInstanceOid is appended to each base object in the associated data group, thus giving the first object instance of the next 'n' instances that need to be collected. The value of 'n' is set in cdcDGInstanceNumRepititions. subTree The value of cdcDGInstanceOid is appended to each base object in the associated data group, thus identifying the OBJECT IDENTFIFIER sub-tree, whose leaf instances need to be collected. other The value of cdcDGInstanceOtherPtr points to a row (in another MIB table) that contains MIB specific instance selection criteria. A MIB defined for such purposes should describe the selection criteria. This object's value cannot be modified while the value of cdcDGInstanceStatus is 'active'.")
cdcDGInstanceOid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 4), CdcRowInstanceId().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceOid.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceOid.setDescription("Contains the OBJECT IDENTIFIER fragment that identifies the instances of the base objects that need to be collected. If cdcDGInstanceType is 'individual' then this value should be the OID fragment that, when appended to each base MIB object gives the fully instantiated OID to be fetched. If cdcDGInstanceType is 'range' then this value should be the OID fragment that, when appended to each base MIB object gives the start of a range of object instances that needs to be fetched. If cdcDGInstanceType is 'subTree' then this value should be the OID fragment that, when appended to each base MIB gives the sub-tree under which all leaf object instances need to be fetched. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGInstanceOidEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 5), CdcRowInstanceId().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceOidEnd.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceOidEnd.setDescription("Contains the OID fragment that, when appended to each base object gives the end of the range of object instances that needs to be fetched. This value is used only when the value of cdcDGInstanceType is of type 'range'. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGInstanceNumRepititions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 6), Unsigned32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceNumRepititions.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceNumRepititions.setDescription("Specifies the number of lexicographically consecutive object instances to fetch. This value is used only when the value of cdcDGInstanceType is of type 'repititions'. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGInstanceOtherPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 7), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceOtherPtr.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceOtherPtr.setDescription("Contains a pointer to a row in another MIB table that contains MIB specific criteria for selecting instances. This value is used only when the value of cdcDGInstanceType is of type 'other'. This object's value may be modified at any time. The change takes effect the next time data is fetched for this data group.")
cdcDGInstanceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 2, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcDGInstanceRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdcDGInstanceRowStatus.setDescription('The status of this conceptual row.')
cdcFileXferConfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1), )
if mibBuilder.loadTexts: cdcFileXferConfTable.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfTable.setDescription('A table for configuring file transfer operations.')
cdcFileXferConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-DATA-COLLECTION-MIB", "cdcVFileIndex"))
if mibBuilder.loadTexts: cdcFileXferConfEntry.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfEntry.setDescription('An individual entry in the cdcFileXferConfTable. Each entry identifies a primary and an optional secondary destination. An entry is automatically created in this table, whenever an entry is created in the cdcVFileTable. The application needs to specify the URLs of the destination to which frozen VFiles are transferred. When a VFile is frozen, transfer will be first initiated to the primary destination, if the transfer fails, then transfer is initiated to the secondary destination. If this too fails, then the cycle is repeated again after a specified time period (value of cdcFileXferConfRetryPeriod) elapses.')
cdcFileXferConfPriUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 1), CdcUrl()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfPriUrl.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfPriUrl.setDescription("The URL which specifies the primary destination to which the file has to be transferred. The URL should contain the base-name of the remote file, the suffix will be carried over from the name of the VFile being tranferred, and will be automatically appended by the agent. This object's value may be modified at any time.")
cdcFileXferConfSecUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 2), CdcUrl()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfSecUrl.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfSecUrl.setDescription("The URL which specifies the secondary destination to which the file has to be transferred if the transfer to the primary destination fails. Failure occurs when the file cannot be transferred in it's entirety to the specified destination for some reason. Some common reasons for such failures are listed out in CdcFileXferStatus. The specified URL should contain the base-name of the remote file, the suffix will be carried over from the name of the VFile being tranferred, and will be automatically appended by the agent. This object's value may be modified at any time.")
cdcFileXferConfRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfRetryPeriod.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfRetryPeriod.setDescription("Specifies the time interval after which transfer has to be retried. Transfer needs to be retried only if in a previous attempt the file could not be successfully transferred to either the primary destination or the secondary destination. This object's value may be modified at any time.")
cdcFileXferConfRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfRetryCount.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfRetryCount.setDescription("Maximum number of times, transfer has to be retried. If the retry count exceeds this value, then no further attempts will be made. This object's value may be modified at any time.")
cdcFileXferConfSuccessEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfSuccessEnable.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfSuccessEnable.setDescription("When set to 'true', cdcFileXferComplete notification will be sent out in the event of a successful file transfer.")
cdcFileXferConfFailureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 312, 1, 3, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdcFileXferConfFailureEnable.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferConfFailureEnable.setDescription("When set to 'true', cdcFileXferComplete notification will be sent out in the event of a file transfer failure.")
cdcVFileCollectionError = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 312, 0, 1)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcVFileName"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileErrorCode"))
if mibBuilder.loadTexts: cdcVFileCollectionError.setStatus('current')
if mibBuilder.loadTexts: cdcVFileCollectionError.setDescription('Notification that data collection operations for a cdcVFileEntry has encountered an error. The cdcVFileEntry is identified by the instance portion of cdcVFileName. The error code is available as the value of the cdcVFileErrorCode variable.')
cdcFileXferComplete = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 312, 0, 2)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtLastXferStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtLastXferURL"))
if mibBuilder.loadTexts: cdcFileXferComplete.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferComplete.setDescription('Notification that file transfer to the destination specified by the cdcVFileMgmtLastXferURL variable, has completed with the status specified by the cdcVFileMgmtLastXferStatus variable.')
ciscoDataCollMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 1))
ciscoDataCollMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 2))
ciscoDataCollMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 1, 1)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcVFileGroup"), ("CISCO-DATA-COLLECTION-MIB", "cdcDataSelectionGroup"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferGroup"), ("CISCO-DATA-COLLECTION-MIB", "cdcNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoDataCollMIBCompliance = ciscoDataCollMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoDataCollMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco Data Collection MIB.')
cdcVFileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 2, 1)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcVFilePersistentStorage"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMaxSizeHitsLimit"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileName"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileDescription"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileCommand"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMaxSize"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileCurrentSize"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileFormat"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileCollectMode"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileCollectionPeriod"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileRetentionPeriod"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileAdminStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileOperStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileErrorCode"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileRowStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtName"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtTimestamp"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtTimeToLive"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtCommand"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtXferURL"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtLastXferStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileMgmtLastXferURL"), ("CISCO-DATA-COLLECTION-MIB", "cdcVFileCollectionErrorEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdcVFileGroup = cdcVFileGroup.setStatus('current')
if mibBuilder.loadTexts: cdcVFileGroup.setDescription('Objects related to VFiles.')
cdcDataSelectionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 2, 2)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcDGComment"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGType"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGVFileIndex"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGTargetTag"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGContextName"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGObject"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGObjectGrpIndex"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstGrpIndex"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGPollPeriod"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGRowStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGBaseObjectSubtree"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGBaseObjectList"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGBaseObjectRowStatus"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceType"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceOid"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceOidEnd"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceNumRepititions"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceOtherPtr"), ("CISCO-DATA-COLLECTION-MIB", "cdcDGInstanceRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdcDataSelectionGroup = cdcDataSelectionGroup.setStatus('current')
if mibBuilder.loadTexts: cdcDataSelectionGroup.setDescription('Objects related to data selection.')
cdcFileXferGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 2, 3)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfPriUrl"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfSecUrl"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfRetryPeriod"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfRetryCount"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfSuccessEnable"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferConfFailureEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdcFileXferGroup = cdcFileXferGroup.setStatus('current')
if mibBuilder.loadTexts: cdcFileXferGroup.setDescription('Objects related to file transfer.')
cdcNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 312, 2, 2, 4)).setObjects(("CISCO-DATA-COLLECTION-MIB", "cdcVFileCollectionError"), ("CISCO-DATA-COLLECTION-MIB", "cdcFileXferComplete"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdcNotificationGroup = cdcNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cdcNotificationGroup.setDescription('Collection of Notifications to inform errors occurred in data collection and status of file transfer operation.')
mibBuilder.exportSymbols("CISCO-DATA-COLLECTION-MIB", cdcDGContextName=cdcDGContextName, cdcVFilePersistentStorage=cdcVFilePersistentStorage, cdcVFileRetentionPeriod=cdcVFileRetentionPeriod, cdcDGInstanceIndex=cdcDGInstanceIndex, ciscoDataCollMIBObjects=ciscoDataCollMIBObjects, cdcFileXferConfEntry=cdcFileXferConfEntry, cdcVFileMgmtXferURL=cdcVFileMgmtXferURL, ciscoDataCollMIBCompliance=ciscoDataCollMIBCompliance, cdcDataSelectionGroup=cdcDataSelectionGroup, cdcVFileCollectionError=cdcVFileCollectionError, cdcFileXferConfSuccessEnable=cdcFileXferConfSuccessEnable, cdcVFile=cdcVFile, cdcDGBaseObjectIndex=cdcDGBaseObjectIndex, cdcVFileRowStatus=cdcVFileRowStatus, cdcDGTable=cdcDGTable, cdcFileXferConfRetryCount=cdcFileXferConfRetryCount, cdcVFileMgmtIndex=cdcVFileMgmtIndex, cdcVFileErrorCode=cdcVFileErrorCode, cdcDGVFileIndex=cdcDGVFileIndex, cdcFileXferConfSecUrl=cdcFileXferConfSecUrl, cdcDGBaseObjectList=cdcDGBaseObjectList, cdcDGInstanceOid=cdcDGInstanceOid, cdcVFileEntry=cdcVFileEntry, cdcDGTargetTag=cdcDGTargetTag, ciscoDataCollMIBConformance=ciscoDataCollMIBConformance, cdcFileXferConfRetryPeriod=cdcFileXferConfRetryPeriod, cdcFileXferGroup=cdcFileXferGroup, cdcVFileMgmtTimestamp=cdcVFileMgmtTimestamp, cdcDGInstanceOtherPtr=cdcDGInstanceOtherPtr, cdcDGInstanceEntry=cdcDGInstanceEntry, cdcDGComment=cdcDGComment, cdcDGType=cdcDGType, PYSNMP_MODULE_ID=ciscoDataCollectionMIB, cdcDGInstanceNumRepititions=cdcDGInstanceNumRepititions, cdcDGPollPeriod=cdcDGPollPeriod, ciscoDataCollMIBCompliances=ciscoDataCollMIBCompliances, CdcFileFormat=CdcFileFormat, cdcVFileIndex=cdcVFileIndex, CdcRowInstanceId=CdcRowInstanceId, cdcVFileMgmtCommand=cdcVFileMgmtCommand, cdcDGInstanceRowStatus=cdcDGInstanceRowStatus, cdcVFileCollectionErrorEnable=cdcVFileCollectionErrorEnable, cdcVFileDescription=cdcVFileDescription, cdcVFileGroup=cdcVFileGroup, cdcVFileMgmtName=cdcVFileMgmtName, cdcVFileCollectMode=cdcVFileCollectMode, ciscoDataCollMIBNotifs=ciscoDataCollMIBNotifs, cdcDGBaseObjectTable=cdcDGBaseObjectTable, cdcDGInstanceGrpIndex=cdcDGInstanceGrpIndex, cdcVFileMgmtLastXferStatus=cdcVFileMgmtLastXferStatus, cdcVFileTable=cdcVFileTable, CdcCollectionSubtree=CdcCollectionSubtree, cdcDataGroup=cdcDataGroup, cdcVFileAdminStatus=cdcVFileAdminStatus, ciscoDataCollectionMIB=ciscoDataCollectionMIB, cdcNotificationGroup=cdcNotificationGroup, cdcDGIndex=cdcDGIndex, cdcDGBaseObjectRowStatus=cdcDGBaseObjectRowStatus, ciscoDataCollMIBGroups=ciscoDataCollMIBGroups, cdcFileXferConfTable=cdcFileXferConfTable, cdcDGObject=cdcDGObject, cdcDGBaseObjectSubtree=cdcDGBaseObjectSubtree, cdcVFileFormat=cdcVFileFormat, cdcDGEntry=cdcDGEntry, cdcVFileMaxSize=cdcVFileMaxSize, cdcDGInstGrpIndex=cdcDGInstGrpIndex, cdcDGObjectGrpIndex=cdcDGObjectGrpIndex, cdcDGInstanceType=cdcDGInstanceType, cdcDGBaseObjectEntry=cdcDGBaseObjectEntry, CdcFileXferStatus=CdcFileXferStatus, cdcDGInstanceOidEnd=cdcDGInstanceOidEnd, cdcDGBaseObjectGrpIndex=cdcDGBaseObjectGrpIndex, cdcDGInstanceTable=cdcDGInstanceTable, cdcVFileCommand=cdcVFileCommand, cdcVFileCurrentSize=cdcVFileCurrentSize, cdcVFileOperStatus=cdcVFileOperStatus, cdcVFileMaxSizeHitsLimit=cdcVFileMaxSizeHitsLimit, cdcVFileCollectionPeriod=cdcVFileCollectionPeriod, cdcFileXferComplete=cdcFileXferComplete, cdcFileXferConfFailureEnable=cdcFileXferConfFailureEnable, cdcVFileName=cdcVFileName, cdcVFileMgmtTable=cdcVFileMgmtTable, CdcCollectionList=CdcCollectionList, cdcFileXfer=cdcFileXfer, CdcUrl=CdcUrl, cdcVFileMgmtEntry=cdcVFileMgmtEntry, cdcVFileMgmtLastXferURL=cdcVFileMgmtLastXferURL, cdcDGRowStatus=cdcDGRowStatus, cdcVFileMgmtTimeToLive=cdcVFileMgmtTimeToLive, cdcFileXferConfPriUrl=cdcFileXferConfPriUrl)
